pub fn sub_825AD638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825AD638 size=228
    let mut pc: u32 = 0x825AD638;
    'dispatch: loop {
        match pc {
            0x825AD638 => {
    //   block [0x825AD638..0x825AD71C)
	// 825AD638: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AD720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825AD720 size=1180
    let mut pc: u32 = 0x825AD720;
    'dispatch: loop {
        match pc {
            0x825AD720 => {
    //   block [0x825AD720..0x825ADBBC)
	// 825AD720: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AD724: 4BF8795D  bl 0x82535080
	ctx.lr = 0x825AD728;
	sub_82535080(ctx, base);
	// 825AD728: 3961FE90  addi r11, r1, -0x170
	ctx.r[11].s64 = ctx.r[1].s64 + -368;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ADBC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825ADBC0 size=4
    let mut pc: u32 = 0x825ADBC0;
    'dispatch: loop {
        match pc {
            0x825ADBC0 => {
    //   block [0x825ADBC0..0x825ADBC4)
	// 825ADBC0: 4BFFFB60  b 0x825ad720
	sub_825AD720(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ADBC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825ADBC8 size=416
    let mut pc: u32 = 0x825ADBC8;
    'dispatch: loop {
        match pc {
            0x825ADBC8 => {
    //   block [0x825ADBC8..0x825ADC50)
	// 825ADBC8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825ADBCC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825ADBD0: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 825ADBD4: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 825ADBD8: C00A1850  lfs f0, 0x1850(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825ADBDC: 419A0074  beq cr6, 0x825adc50
	if ctx.cr[6].eq {
	pc = 0x825ADC50; continue 'dispatch;
	}
	// 825ADBE0: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 825ADBE4: D001FFD0  stfs f0, -0x30(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), tmp.u32 ) };
	// 825ADBE8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825ADBEC: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 825ADBF0: 38C79F60  addi r6, r7, -0x60a0
	ctx.r[6].s64 = ctx.r[7].s64 + -24736;
	pc = 0x825ADC50; continue 'dispatch;
            }
            0x825ADC50 => {
    //   block [0x825ADC50..0x825ADD68)
	// 825ADC50: 54A6F0BE  srwi r6, r5, 2
	ctx.r[6].u32 = ctx.r[5].u32.wrapping_shr(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 825ADC54: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 825ADC58: 419A00B0  beq cr6, 0x825add08
	if ctx.cr[6].eq {
	pc = 0x825ADD08; continue 'dispatch;
	}
	// 825ADC5C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 825ADC60: 388A9FC0  addi r4, r10, -0x6040
	ctx.r[4].s64 = ctx.r[10].s64 + -24640;
	// 825ADC64: 392B0010  addi r9, r11, 0x10
	ctx.r[9].s64 = ctx.r[11].s64 + 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ADD68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825ADD68 size=92
    let mut pc: u32 = 0x825ADD68;
    'dispatch: loop {
        match pc {
            0x825ADD68 => {
    //   block [0x825ADD68..0x825ADDC4)
	// 825ADD68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ADD6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825ADD70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825ADD74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825ADD78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ADD7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825ADD80: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825ADD84: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 825ADD88: 4BFFA9C9  bl 0x825a8750
	ctx.lr = 0x825ADD8C;
	sub_825A8750(ctx, base);
	// 825ADD8C: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 825ADD90: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ADDC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825ADDC8 size=76
    let mut pc: u32 = 0x825ADDC8;
    'dispatch: loop {
        match pc {
            0x825ADDC8 => {
    //   block [0x825ADDC8..0x825ADE14)
	// 825ADDC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ADDCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825ADDD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825ADDD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825ADDD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ADDDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825ADDE0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825ADDE4: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 825ADDE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825ADDEC: 4BFFD815  bl 0x825ab600
	ctx.lr = 0x825ADDF0;
	sub_825AB600(ctx, base);
	// 825ADDF0: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ADE18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825ADE18 size=80
    let mut pc: u32 = 0x825ADE18;
    'dispatch: loop {
        match pc {
            0x825ADE18 => {
    //   block [0x825ADE18..0x825ADE24)
	// 825ADE18: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 825ADE1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825ADE20: 3D207F80  lis r9, 0x7f80
	ctx.r[9].s64 = 2139095040;
	pc = 0x825ADE24; continue 'dispatch;
            }
            0x825ADE24 => {
    //   block [0x825ADE24..0x825ADE4C)
	// 825ADE24: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 825ADE28: 419A0024  beq cr6, 0x825ade4c
	if ctx.cr[6].eq {
	pc = 0x825ADE4C; continue 'dispatch;
	}
	// 825ADE2C: 2F0B000B  cmpwi cr6, r11, 0xb
	ctx.cr[6].compare_i32(ctx.r[11].s32, 11, &mut ctx.xer);
	// 825ADE30: 419A001C  beq cr6, 0x825ade4c
	if ctx.cr[6].eq {
	pc = 0x825ADE4C; continue 'dispatch;
	}
	// 825ADE34: C00A0000  lfs f0, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825ADE38: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 825ADE3C: 8101FFF0  lwz r8, -0x10(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 825ADE40: 55080050  rlwinm r8, r8, 0, 1, 8
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 825ADE44: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825ADE48: 419A0020  beq cr6, 0x825ade68
	if ctx.cr[6].eq {
		sub_825ADE68(ctx, base);
		return;
	}
	pc = 0x825ADE4C; continue 'dispatch;
            }
            0x825ADE4C => {
    //   block [0x825ADE4C..0x825ADE68)
	// 825ADE4C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825ADE50: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825ADE54: 2F0B000C  cmpwi cr6, r11, 0xc
	ctx.cr[6].compare_i32(ctx.r[11].s32, 12, &mut ctx.xer);
	// 825ADE58: 4198FFCC  blt cr6, 0x825ade24
	if ctx.cr[6].lt {
	pc = 0x825ADE24; continue 'dispatch;
	}
	// 825ADE5C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825ADE60: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825ADE64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ADE68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825ADE68 size=12
    let mut pc: u32 = 0x825ADE68;
    'dispatch: loop {
        match pc {
            0x825ADE68 => {
    //   block [0x825ADE68..0x825ADE74)
	// 825ADE68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825ADE6C: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825ADE70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ADE78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825ADE78 size=104
    let mut pc: u32 = 0x825ADE78;
    'dispatch: loop {
        match pc {
            0x825ADE78 => {
    //   block [0x825ADE78..0x825ADEE0)
	// 825ADE78: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ADEE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825ADEE0 size=208
    let mut pc: u32 = 0x825ADEE0;
    'dispatch: loop {
        match pc {
            0x825ADEE0 => {
    //   block [0x825ADEE0..0x825ADFB0)
	// 825ADEE0: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 825ADEE4: D021FFE0  stfs f1, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ADFB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825ADFB0 size=212
    let mut pc: u32 = 0x825ADFB0;
    'dispatch: loop {
        match pc {
            0x825ADFB0 => {
    //   block [0x825ADFB0..0x825AE084)
	// 825ADFB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ADFB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825ADFB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825ADFBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825ADFC0: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ADFC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825ADFC8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825ADFCC: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 825ADFD0: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 825ADFD4: 4BFFD62D  bl 0x825ab600
	ctx.lr = 0x825ADFD8;
	sub_825AB600(ctx, base);
	// 825ADFD8: 396100F0  addi r11, r1, 0xf0
	ctx.r[11].s64 = ctx.r[1].s64 + 240;
	// 825ADFDC: C01F0020  lfs f0, 0x20(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825ADFE0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825ADFE4: 38810100  addi r4, r1, 0x100
	ctx.r[4].s64 = ctx.r[1].s64 + 256;
	// 825ADFE8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AE088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AE088 size=132
    let mut pc: u32 = 0x825AE088;
    'dispatch: loop {
        match pc {
            0x825AE088 => {
    //   block [0x825AE088..0x825AE10C)
	// 825AE088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AE08C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AE090: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825AE094: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AE098: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AE09C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825AE0A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825AE0A4: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 825AE0A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825AE0AC: 4800009D  bl 0x825ae148
	ctx.lr = 0x825AE0B0;
	sub_825AE148(ctx, base);
	// 825AE0B0: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 825AE0B4: 89610081  lbz r11, 0x81(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(129 as u32) ) } as u64;
	// 825AE0B8: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 825AE0BC: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 825AE0C0: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 825AE0C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AE110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AE110 size=44
    let mut pc: u32 = 0x825AE110;
    'dispatch: loop {
        match pc {
            0x825AE110 => {
    //   block [0x825AE110..0x825AE13C)
	// 825AE110: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AE114: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AE118: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AE11C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 825AE120: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AE124: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AE128: 4BFFFF61  bl 0x825ae088
	ctx.lr = 0x825AE12C;
	sub_825AE088(ctx, base);
	// 825AE12C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825AE130: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AE134: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AE138: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AE140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825AE140 size=4
    let mut pc: u32 = 0x825AE140;
    'dispatch: loop {
        match pc {
            0x825AE140 => {
    //   block [0x825AE140..0x825AE144)
	// 825AE140: 4BFFFE70  b 0x825adfb0
	sub_825ADFB0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AE148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AE148 size=1148
    let mut pc: u32 = 0x825AE148;
    'dispatch: loop {
        match pc {
            0x825AE148 => {
    //   block [0x825AE148..0x825AE5C4)
	// 825AE148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AE14C: 4BF86F71  bl 0x825350bc
	ctx.lr = 0x825AE150;
	sub_82535080(ctx, base);
	// 825AE150: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 825AE154: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 825AE158: 9421FD80  stwu r1, -0x280(r1)
	ea = ctx.r[1].u32.wrapping_add(-640 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AE15C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825AE160: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AE164: 386101B0  addi r3, r1, 0x1b0
	ctx.r[3].s64 = ctx.r[1].s64 + 432;
	// 825AE168: 4BFFAD61  bl 0x825a8ec8
	ctx.lr = 0x825AE16C;
	sub_825A8EC8(ctx, base);
	// 825AE16C: 396101E0  addi r11, r1, 0x1e0
	ctx.r[11].s64 = ctx.r[1].s64 + 480;
	// 825AE170: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AE5D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AE5D0 size=104
    let mut pc: u32 = 0x825AE5D0;
    'dispatch: loop {
        match pc {
            0x825AE5D0 => {
    //   block [0x825AE5D0..0x825AE638)
	// 825AE5D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AE5D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AE5D8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AE5DC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825AE5E0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825AE5E4: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 825AE5E8: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 825AE5EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AE638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AE638 size=72
    let mut pc: u32 = 0x825AE638;
    'dispatch: loop {
        match pc {
            0x825AE638 => {
    //   block [0x825AE638..0x825AE65C)
	// 825AE638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AE63C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AE640: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AE644: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AE648: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AE64C: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 825AE650: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AE654: 419A0008  beq cr6, 0x825ae65c
	if ctx.cr[6].eq {
	pc = 0x825AE65C; continue 'dispatch;
	}
	// 825AE658: 4BEED3D9  bl 0x8249ba30
	ctx.lr = 0x825AE65C;
	sub_8249BA30(ctx, base);
	pc = 0x825AE65C; continue 'dispatch;
            }
            0x825AE65C => {
    //   block [0x825AE65C..0x825AE66C)
	// 825AE65C: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 825AE660: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AE664: 419A0008  beq cr6, 0x825ae66c
	if ctx.cr[6].eq {
	pc = 0x825AE66C; continue 'dispatch;
	}
	// 825AE668: 4BEED3C9  bl 0x8249ba30
	ctx.lr = 0x825AE66C;
	sub_8249BA30(ctx, base);
	pc = 0x825AE66C; continue 'dispatch;
            }
            0x825AE66C => {
    //   block [0x825AE66C..0x825AE680)
	// 825AE66C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825AE670: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AE674: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AE678: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AE67C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AE680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825AE680 size=20
    let mut pc: u32 = 0x825AE680;
    'dispatch: loop {
        match pc {
            0x825AE680 => {
    //   block [0x825AE680..0x825AE694)
	// 825AE680: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AE684: 80640008  lwz r3, 8(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AE688: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825AE68C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 825AE690: 4BEE9D90  b 0x82498420
	sub_82498420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AE698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AE698 size=136
    let mut pc: u32 = 0x825AE698;
    'dispatch: loop {
        match pc {
            0x825AE698 => {
    //   block [0x825AE698..0x825AE6D4)
	// 825AE698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AE69C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AE6A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825AE6A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AE6A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AE6AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AE6B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825AE6B4: 80BF0018  lwz r5, 0x18(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 825AE6B8: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 825AE6BC: 419A0028  beq cr6, 0x825ae6e4
	if ctx.cr[6].eq {
	pc = 0x825AE6E4; continue 'dispatch;
	}
	// 825AE6C0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AE6C4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825AE6C8: 419A000C  beq cr6, 0x825ae6d4
	if ctx.cr[6].eq {
	pc = 0x825AE6D4; continue 'dispatch;
	}
	// 825AE6CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825AE6D0: 4BEE9FA9  bl 0x82498678
	ctx.lr = 0x825AE6D4;
	sub_82498678(ctx, base);
	pc = 0x825AE6D4; continue 'dispatch;
            }
            0x825AE6D4 => {
    //   block [0x825AE6D4..0x825AE6E4)
	// 825AE6D4: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 825AE6D8: 4BEED379  bl 0x8249ba50
	ctx.lr = 0x825AE6DC;
	sub_8249BA50(ctx, base);
	// 825AE6DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825AE6E0: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	pc = 0x825AE6E4; continue 'dispatch;
            }
            0x825AE6E4 => {
    //   block [0x825AE6E4..0x825AE708)
	// 825AE6E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AE6E8: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 825AE6EC: 4BEED345  bl 0x8249ba30
	ctx.lr = 0x825AE6F0;
	sub_8249BA30(ctx, base);
	// 825AE6F0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AE6F4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825AE6F8: 419A0010  beq cr6, 0x825ae708
	if ctx.cr[6].eq {
	pc = 0x825AE708; continue 'dispatch;
	}
	// 825AE6FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825AE700: 80BF0018  lwz r5, 0x18(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 825AE704: 4BEE640D  bl 0x82494b10
	ctx.lr = 0x825AE708;
	sub_82494B10(ctx, base);
	pc = 0x825AE708; continue 'dispatch;
            }
            0x825AE708 => {
    //   block [0x825AE708..0x825AE720)
	// 825AE708: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825AE70C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AE710: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AE714: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825AE718: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AE71C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AE720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AE720 size=136
    let mut pc: u32 = 0x825AE720;
    'dispatch: loop {
        match pc {
            0x825AE720 => {
    //   block [0x825AE720..0x825AE75C)
	// 825AE720: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AE724: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AE728: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825AE72C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AE730: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AE734: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AE738: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825AE73C: 80BF001C  lwz r5, 0x1c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 825AE740: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 825AE744: 419A0028  beq cr6, 0x825ae76c
	if ctx.cr[6].eq {
	pc = 0x825AE76C; continue 'dispatch;
	}
	// 825AE748: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AE74C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825AE750: 419A000C  beq cr6, 0x825ae75c
	if ctx.cr[6].eq {
	pc = 0x825AE75C; continue 'dispatch;
	}
	// 825AE754: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825AE758: 4BEE9F21  bl 0x82498678
	ctx.lr = 0x825AE75C;
	sub_82498678(ctx, base);
	pc = 0x825AE75C; continue 'dispatch;
            }
            0x825AE75C => {
    //   block [0x825AE75C..0x825AE76C)
	// 825AE75C: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 825AE760: 4BEED2F1  bl 0x8249ba50
	ctx.lr = 0x825AE764;
	sub_8249BA50(ctx, base);
	// 825AE764: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825AE768: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	pc = 0x825AE76C; continue 'dispatch;
            }
            0x825AE76C => {
    //   block [0x825AE76C..0x825AE790)
	// 825AE76C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AE770: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 825AE774: 4BEED2BD  bl 0x8249ba30
	ctx.lr = 0x825AE778;
	sub_8249BA30(ctx, base);
	// 825AE778: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AE77C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825AE780: 419A0010  beq cr6, 0x825ae790
	if ctx.cr[6].eq {
	pc = 0x825AE790; continue 'dispatch;
	}
	// 825AE784: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825AE788: 80BF001C  lwz r5, 0x1c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 825AE78C: 4BEE6385  bl 0x82494b10
	ctx.lr = 0x825AE790;
	sub_82494B10(ctx, base);
	pc = 0x825AE790; continue 'dispatch;
            }
            0x825AE790 => {
    //   block [0x825AE790..0x825AE7A8)
	// 825AE790: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825AE794: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AE798: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AE79C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825AE7A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AE7A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AE7A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AE7A8 size=140
    let mut pc: u32 = 0x825AE7A8;
    'dispatch: loop {
        match pc {
            0x825AE7A8 => {
    //   block [0x825AE7A8..0x825AE7FC)
	// 825AE7A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AE7AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AE7B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AE7B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AE7B8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825AE7BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AE7C0: 394B15CC  addi r10, r11, 0x15cc
	ctx.r[10].s64 = ctx.r[11].s64 + 5580;
	// 825AE7C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825AE7C8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 825AE7CC: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 825AE7D0: 90DF0010  stw r6, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[6].u32 ) };
	// 825AE7D4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825AE7D8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825AE7DC: B13F0006  sth r9, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 825AE7E0: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 825AE7E4: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 825AE7E8: 909F0018  stw r4, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[4].u32 ) };
	// 825AE7EC: 90BF001C  stw r5, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[5].u32 ) };
	// 825AE7F0: 409A000C  bne cr6, 0x825ae7fc
	if !ctx.cr[6].eq {
	pc = 0x825AE7FC; continue 'dispatch;
	}
	// 825AE7F4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825AE7F8: 419A0024  beq cr6, 0x825ae81c
	if ctx.cr[6].eq {
	pc = 0x825AE81C; continue 'dispatch;
	}
	pc = 0x825AE7FC; continue 'dispatch;
            }
            0x825AE7FC => {
    //   block [0x825AE7FC..0x825AE80C)
	// 825AE7FC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825AE800: 419A000C  beq cr6, 0x825ae80c
	if ctx.cr[6].eq {
	pc = 0x825AE80C; continue 'dispatch;
	}
	// 825AE804: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825AE808: 4BEED229  bl 0x8249ba30
	ctx.lr = 0x825AE80C;
	sub_8249BA30(ctx, base);
	pc = 0x825AE80C; continue 'dispatch;
            }
            0x825AE80C => {
    //   block [0x825AE80C..0x825AE81C)
	// 825AE80C: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 825AE810: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AE814: 419A0008  beq cr6, 0x825ae81c
	if ctx.cr[6].eq {
	pc = 0x825AE81C; continue 'dispatch;
	}
	// 825AE818: 4BEED219  bl 0x8249ba30
	ctx.lr = 0x825AE81C;
	sub_8249BA30(ctx, base);
	pc = 0x825AE81C; continue 'dispatch;
            }
            0x825AE81C => {
    //   block [0x825AE81C..0x825AE834)
	// 825AE81C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AE820: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825AE824: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AE828: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AE82C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AE830: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AE838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AE838 size=116
    let mut pc: u32 = 0x825AE838;
    'dispatch: loop {
        match pc {
            0x825AE838 => {
    //   block [0x825AE838..0x825AE874)
	// 825AE838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AE83C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AE840: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825AE844: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AE848: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AE84C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AE850: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825AE854: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825AE858: 396B15CC  addi r11, r11, 0x15cc
	ctx.r[11].s64 = ctx.r[11].s64 + 5580;
	// 825AE85C: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 825AE860: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AE864: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825AE868: 419A000C  beq cr6, 0x825ae874
	if ctx.cr[6].eq {
	pc = 0x825AE874; continue 'dispatch;
	}
	// 825AE86C: 4BEED1E5  bl 0x8249ba50
	ctx.lr = 0x825AE870;
	sub_8249BA50(ctx, base);
	// 825AE870: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	pc = 0x825AE874; continue 'dispatch;
            }
            0x825AE874 => {
    //   block [0x825AE874..0x825AE888)
	// 825AE874: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 825AE878: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AE87C: 419A000C  beq cr6, 0x825ae888
	if ctx.cr[6].eq {
	pc = 0x825AE888; continue 'dispatch;
	}
	// 825AE880: 4BEED1D1  bl 0x8249ba50
	ctx.lr = 0x825AE884;
	sub_8249BA50(ctx, base);
	// 825AE884: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	pc = 0x825AE888; continue 'dispatch;
            }
            0x825AE888 => {
    //   block [0x825AE888..0x825AE8AC)
	// 825AE888: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825AE88C: 396B6DD0  addi r11, r11, 0x6dd0
	ctx.r[11].s64 = ctx.r[11].s64 + 28112;
	// 825AE890: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825AE894: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825AE898: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AE89C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AE8A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825AE8A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AE8A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AE8B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AE8B0 size=176
    let mut pc: u32 = 0x825AE8B0;
    'dispatch: loop {
        match pc {
            0x825AE8B0 => {
    //   block [0x825AE8B0..0x825AE8EC)
	// 825AE8B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AE8B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AE8B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825AE8BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AE8C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AE8C4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825AE8C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825AE8CC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AE8D0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AE8D4: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825AE8D8: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825AE8DC: 409A0010  bne cr6, 0x825ae8ec
	if !ctx.cr[6].eq {
	pc = 0x825AE8EC; continue 'dispatch;
	}
	// 825AE8E0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 825AE8E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AE8E8: 4BEBFA69  bl 0x8246e350
	ctx.lr = 0x825AE8EC;
	sub_8246E350(ctx, base);
	pc = 0x825AE8EC; continue 'dispatch;
            }
            0x825AE8EC => {
    //   block [0x825AE8EC..0x825AE928)
	// 825AE8EC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AE8F0: 815E0018  lwz r10, 0x18(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 825AE8F4: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AE8F8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825AE8FC: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 825AE900: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AE904: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AE908: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825AE90C: 554A00BE  clrlwi r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 825AE910: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825AE914: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825AE918: 409A0010  bne cr6, 0x825ae928
	if !ctx.cr[6].eq {
	pc = 0x825AE928; continue 'dispatch;
	}
	// 825AE91C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 825AE920: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AE924: 4BEBFA2D  bl 0x8246e350
	ctx.lr = 0x825AE928;
	sub_8246E350(ctx, base);
	pc = 0x825AE928; continue 'dispatch;
            }
            0x825AE928 => {
    //   block [0x825AE928..0x825AE960)
	// 825AE928: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AE92C: 815E001C  lwz r10, 0x1c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 825AE930: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AE934: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825AE938: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 825AE93C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AE940: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825AE944: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825AE948: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825AE94C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AE950: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AE954: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825AE958: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AE95C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AE960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825AE960 size=20
    let mut pc: u32 = 0x825AE960;
    'dispatch: loop {
        match pc {
            0x825AE960 => {
    //   block [0x825AE960..0x825AE974)
	// 825AE960: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AE964: 80640008  lwz r3, 8(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AE968: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825AE96C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 825AE970: 4BEE9AB0  b 0x82498420
	sub_82498420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AE978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AE978 size=136
    let mut pc: u32 = 0x825AE978;
    'dispatch: loop {
        match pc {
            0x825AE978 => {
    //   block [0x825AE978..0x825AE9B4)
	// 825AE978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AE97C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AE980: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825AE984: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AE988: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AE98C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AE990: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825AE994: 80BF0018  lwz r5, 0x18(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 825AE998: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 825AE99C: 419A0028  beq cr6, 0x825ae9c4
	if ctx.cr[6].eq {
	pc = 0x825AE9C4; continue 'dispatch;
	}
	// 825AE9A0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AE9A4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825AE9A8: 419A000C  beq cr6, 0x825ae9b4
	if ctx.cr[6].eq {
	pc = 0x825AE9B4; continue 'dispatch;
	}
	// 825AE9AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825AE9B0: 4BEE9CC9  bl 0x82498678
	ctx.lr = 0x825AE9B4;
	sub_82498678(ctx, base);
	pc = 0x825AE9B4; continue 'dispatch;
            }
            0x825AE9B4 => {
    //   block [0x825AE9B4..0x825AE9C4)
	// 825AE9B4: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 825AE9B8: 4BEED099  bl 0x8249ba50
	ctx.lr = 0x825AE9BC;
	sub_8249BA50(ctx, base);
	// 825AE9BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825AE9C0: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	pc = 0x825AE9C4; continue 'dispatch;
            }
            0x825AE9C4 => {
    //   block [0x825AE9C4..0x825AE9E8)
	// 825AE9C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AE9C8: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 825AE9CC: 4BEED065  bl 0x8249ba30
	ctx.lr = 0x825AE9D0;
	sub_8249BA30(ctx, base);
	// 825AE9D0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AE9D4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825AE9D8: 419A0010  beq cr6, 0x825ae9e8
	if ctx.cr[6].eq {
	pc = 0x825AE9E8; continue 'dispatch;
	}
	// 825AE9DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825AE9E0: 80BF0018  lwz r5, 0x18(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 825AE9E4: 4BEE612D  bl 0x82494b10
	ctx.lr = 0x825AE9E8;
	sub_82494B10(ctx, base);
	pc = 0x825AE9E8; continue 'dispatch;
            }
            0x825AE9E8 => {
    //   block [0x825AE9E8..0x825AEA00)
	// 825AE9E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825AE9EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AE9F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AE9F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825AE9F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AE9FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AEA00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AEA00 size=104
    let mut pc: u32 = 0x825AEA00;
    'dispatch: loop {
        match pc {
            0x825AEA00 => {
    //   block [0x825AEA00..0x825AEA50)
	// 825AEA00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AEA04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AEA08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AEA0C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AEA10: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825AEA14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AEA18: 394B1A74  addi r10, r11, 0x1a74
	ctx.r[10].s64 = ctx.r[11].s64 + 6772;
	// 825AEA1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825AEA20: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 825AEA24: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825AEA28: 90BF0010  stw r5, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[5].u32 ) };
	// 825AEA2C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825AEA30: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825AEA34: B13F0006  sth r9, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 825AEA38: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 825AEA3C: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 825AEA40: 909F0018  stw r4, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[4].u32 ) };
	// 825AEA44: 419A000C  beq cr6, 0x825aea50
	if ctx.cr[6].eq {
	pc = 0x825AEA50; continue 'dispatch;
	}
	// 825AEA48: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825AEA4C: 4BEECFE5  bl 0x8249ba30
	ctx.lr = 0x825AEA50;
	sub_8249BA30(ctx, base);
	pc = 0x825AEA50; continue 'dispatch;
            }
            0x825AEA50 => {
    //   block [0x825AEA50..0x825AEA68)
	// 825AEA50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEA54: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825AEA58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AEA5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AEA60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AEA64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AEA68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AEA68 size=88
    let mut pc: u32 = 0x825AEA68;
    'dispatch: loop {
        match pc {
            0x825AEA68 => {
    //   block [0x825AEA68..0x825AEAA0)
	// 825AEA68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AEA6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AEA70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AEA74: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AEA78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AEA7C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825AEA80: 396B1A74  addi r11, r11, 0x1a74
	ctx.r[11].s64 = ctx.r[11].s64 + 6772;
	// 825AEA84: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 825AEA88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AEA8C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825AEA90: 419A0010  beq cr6, 0x825aeaa0
	if ctx.cr[6].eq {
	pc = 0x825AEAA0; continue 'dispatch;
	}
	// 825AEA94: 4BEECFBD  bl 0x8249ba50
	ctx.lr = 0x825AEA98;
	sub_8249BA50(ctx, base);
	// 825AEA98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825AEA9C: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	pc = 0x825AEAA0; continue 'dispatch;
            }
            0x825AEAA0 => {
    //   block [0x825AEAA0..0x825AEAC0)
	// 825AEAA0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825AEAA4: 396B6DD0  addi r11, r11, 0x6dd0
	ctx.r[11].s64 = ctx.r[11].s64 + 28112;
	// 825AEAA8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825AEAAC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825AEAB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AEAB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AEAB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AEABC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AEAC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AEAC0 size=116
    let mut pc: u32 = 0x825AEAC0;
    'dispatch: loop {
        match pc {
            0x825AEAC0 => {
    //   block [0x825AEAC0..0x825AEAFC)
	// 825AEAC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AEAC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AEAC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825AEACC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AEAD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AEAD4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825AEAD8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825AEADC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEAE0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AEAE4: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825AEAE8: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825AEAEC: 409A0010  bne cr6, 0x825aeafc
	if !ctx.cr[6].eq {
	pc = 0x825AEAFC; continue 'dispatch;
	}
	// 825AEAF0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 825AEAF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEAF8: 4BEBF859  bl 0x8246e350
	ctx.lr = 0x825AEAFC;
	sub_8246E350(ctx, base);
	pc = 0x825AEAFC; continue 'dispatch;
            }
            0x825AEAFC => {
    //   block [0x825AEAFC..0x825AEB34)
	// 825AEAFC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AEB00: 815E0018  lwz r10, 0x18(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 825AEB04: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AEB08: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825AEB0C: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 825AEB10: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AEB14: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825AEB18: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825AEB1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825AEB20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AEB24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AEB28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825AEB2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AEB30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AEB38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825AEB38 size=4
    let mut pc: u32 = 0x825AEB38;
    'dispatch: loop {
        match pc {
            0x825AEB38 => {
    //   block [0x825AEB38..0x825AEB3C)
	// 825AEB38: 48023150  b 0x825d1c88
	sub_825D1C88(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AEB40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825AEB40 size=64
    let mut pc: u32 = 0x825AEB40;
    'dispatch: loop {
        match pc {
            0x825AEB40 => {
    //   block [0x825AEB40..0x825AEB54)
	// 825AEB40: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AEB44: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825AEB48: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AEB4C: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 825AEB50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825AEB54; continue 'dispatch;
            }
            0x825AEB54 => {
    //   block [0x825AEB54..0x825AEB80)
	// 825AEB54: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AEB58: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825AEB5C: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825AEB60: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 825AEB64: C009000C  lfs f0, 0xc(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AEB68: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 825AEB6C: D009000C  stfs f0, 0xc(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 825AEB70: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AEB74: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825AEB78: 4198FFDC  blt cr6, 0x825aeb54
	if ctx.cr[6].lt {
	pc = 0x825AEB54; continue 'dispatch;
	}
	// 825AEB7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AEB80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AEB80 size=1368
    let mut pc: u32 = 0x825AEB80;
    'dispatch: loop {
        match pc {
            0x825AEB80 => {
    //   block [0x825AEB80..0x825AF0D8)
	// 825AEB80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AEB84: 4BF86515  bl 0x82535098
	ctx.lr = 0x825AEB88;
	sub_82535080(ctx, base);
	// 825AEB88: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 825AEB8C: 4BF87445  bl 0x82535fd0
	ctx.lr = 0x825AEB90;
	sub_82535FB0(ctx, base);
	// 825AEB90: 3981FF40  addi r12, r1, -0xc0
	ctx.r[12].s64 = ctx.r[1].s64 + -192;
	// 825AEB94: 4BF8A811  bl 0x825393a4
	ctx.lr = 0x825AEB98;
	sub_82539130(ctx, base);
	// 825AEB98: 9421FE00  stwu r1, -0x200(r1)
	ea = ctx.r[1].u32.wrapping_add(-512 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AEB9C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 825AEBA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AEBA4: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 825AEBA8: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 825AEBAC: 7CF43B78  mr r20, r7
	ctx.r[20].u64 = ctx.r[7].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AF0D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825AF0D8 size=1172
    let mut pc: u32 = 0x825AF0D8;
    'dispatch: loop {
        match pc {
            0x825AF0D8 => {
    //   block [0x825AF0D8..0x825AF56C)
	// 825AF0D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AF0DC: 4BF85FD5  bl 0x825350b0
	ctx.lr = 0x825AF0E0;
	sub_82535080(ctx, base);
	// 825AF0E0: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 825AF0E4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825AF0E8: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 825AF0EC: C04B1FF8  lfs f2, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825AF0F0: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 825AF0F4: FC001090  fmr f0, f2
	ctx.f[0].f64 = ctx.f[2].f64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AF570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825AF570 size=280
    let mut pc: u32 = 0x825AF570;
    'dispatch: loop {
        match pc {
            0x825AF570 => {
    //   block [0x825AF570..0x825AF608)
	// 825AF570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AF574: 4BF85B49  bl 0x825350bc
	ctx.lr = 0x825AF578;
	sub_82535080(ctx, base);
	// 825AF578: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AF57C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825AF580: 38A0001E  li r5, 0x1e
	ctx.r[5].s64 = 30;
	// 825AF584: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 825AF588: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 825AF58C: 4BFFFB4D  bl 0x825af0d8
	ctx.lr = 0x825AF590;
	sub_825AF0D8(ctx, base);
	// 825AF590: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AF594: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AF598: 409A0070  bne cr6, 0x825af608
	if !ctx.cr[6].eq {
	pc = 0x825AF608; continue 'dispatch;
	}
	// 825AF59C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825AF5A0: C1AB1850  lfs f13, 0x1850(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825AF5A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825AF5A8: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 825AF5AC: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825AF5B0: D1A10088  stfs f13, 0x88(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 825AF5B4: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AF5B8: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825AF5BC: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 825AF5C0: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 825AF5C4: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 825AF5C8: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 825AF5CC: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 825AF5D0: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 825AF5D4: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	pc = 0x825AF608; continue 'dispatch;
            }
            0x825AF608 => {
    //   block [0x825AF608..0x825AF688)
	// 825AF608: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AF688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825AF688 size=36
    let mut pc: u32 = 0x825AF688;
    'dispatch: loop {
        match pc {
            0x825AF688 => {
    //   block [0x825AF688..0x825AF6AC)
	// 825AF688: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AF68C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825AF690: C1A40000  lfs f13, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825AF694: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 825AF698: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 825AF69C: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 825AF6A0: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	// 825AF6A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825AF6A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AF6B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825AF6B0 size=92
    let mut pc: u32 = 0x825AF6B0;
    'dispatch: loop {
        match pc {
            0x825AF6B0 => {
    //   block [0x825AF6B0..0x825AF704)
	// 825AF6B0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825AF6B4: C1A30000  lfs f13, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825AF6B8: C1830004  lfs f12, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825AF6BC: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AF6C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825AF6C4: D001FFFC  stfs f0, -4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 825AF6C8: FC006A10  fabs f0, f13
	ctx.f[0].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 825AF6CC: FDA06210  fabs f13, f12
	ctx.f[13].u64 = ctx.f[12].u64 & !0x8000_0000_0000_0000u64;
	// 825AF6D0: C1830008  lfs f12, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825AF6D4: FD806210  fabs f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 & !0x8000_0000_0000_0000u64;
	// 825AF6D8: ED606828  fsubs f11, f0, f13
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 825AF6DC: FC0B682E  fsel f0, f11, f0, f13
	ctx.f[0].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 825AF6E0: EDAC0028  fsubs f13, f12, f0
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 825AF6E4: FDAD032E  fsel f13, f13, f12, f0
	ctx.f[13].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[0].f64 };
	// 825AF6E8: C00B1850  lfs f0, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AF6EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AF6F0: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 825AF6F4: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 825AF6F8: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 825AF6FC: 41980008  blt cr6, 0x825af704
	if ctx.cr[6].lt {
	pc = 0x825AF704; continue 'dispatch;
	}
	// 825AF700: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825AF704; continue 'dispatch;
            }
            0x825AF704 => {
    //   block [0x825AF704..0x825AF70C)
	// 825AF704: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AF708: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AF710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825AF710 size=668
    let mut pc: u32 = 0x825AF710;
    'dispatch: loop {
        match pc {
            0x825AF710 => {
    //   block [0x825AF710..0x825AF9AC)
	// 825AF710: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 825AF714: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825AF718: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 825AF71C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 825AF720: C00BA07C  lfs f0, -0x5f84(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24452 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AF724: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825AF728: D001FFA0  stfs f0, -0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), tmp.u32 ) };
	// 825AF72C: C00BA078  lfs f0, -0x5f88(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24456 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AF730: 3961FFA0  addi r11, r1, -0x60
	ctx.r[11].s64 = ctx.r[1].s64 + -96;
	// 825AF734: D001FFB0  stfs f0, -0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AF9B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AF9B0 size=348
    let mut pc: u32 = 0x825AF9B0;
    'dispatch: loop {
        match pc {
            0x825AF9B0 => {
    //   block [0x825AF9B0..0x825AFB0C)
	// 825AF9B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AF9B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AF9B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AF9BC: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AFB10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AFB10 size=352
    let mut pc: u32 = 0x825AFB10;
    'dispatch: loop {
        match pc {
            0x825AFB10 => {
    //   block [0x825AFB10..0x825AFC70)
	// 825AFB10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AFB14: 4BF85585  bl 0x82535098
	ctx.lr = 0x825AFB18;
	sub_82535080(ctx, base);
	// 825AFB18: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AFB1C: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 825AFB20: FD800890  fmr f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = ctx.f[1].f64;
	// 825AFB24: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 825AFB28: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 825AFB2C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825AFB30: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AFC70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825AFC70 size=360
    let mut pc: u32 = 0x825AFC70;
    'dispatch: loop {
        match pc {
            0x825AFC70 => {
    //   block [0x825AFC70..0x825AFDD8)
	// 825AFC70: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 825AFC74: 39410024  addi r10, r1, 0x24
	ctx.r[10].s64 = ctx.r[1].s64 + 36;
	// 825AFC78: D0210024  stfs f1, 0x24(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(36 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AFDD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825AFDD8 size=616
    let mut pc: u32 = 0x825AFDD8;
    'dispatch: loop {
        match pc {
            0x825AFDD8 => {
    //   block [0x825AFDD8..0x825AFE70)
	// 825AFDD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AFDDC: 4BF852D1  bl 0x825350ac
	ctx.lr = 0x825AFDE0;
	sub_82535080(ctx, base);
	// 825AFDE0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AFDE4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825AFDE8: FD800890  fmr f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = ctx.f[1].f64;
	// 825AFDEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AFDF0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825AFDF4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825AFDF8: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825AFDFC: C0EB1FF8  lfs f7, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 825AFE00: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 825AFE04: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	// 825AFE08: FD603890  fmr f11, f7
	ctx.f[11].f64 = ctx.f[7].f64;
	// 825AFE0C: FD203890  fmr f9, f7
	ctx.f[9].f64 = ctx.f[7].f64;
	// 825AFE10: 4BFFFBA1  bl 0x825af9b0
	ctx.lr = 0x825AFE14;
	sub_825AF9B0(ctx, base);
	// 825AFE14: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825AFE18: FCC00890  fmr f6, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[6].f64 = ctx.f[1].f64;
	// 825AFE1C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825AFE20: FC206090  fmr f1, f12
	ctx.f[1].f64 = ctx.f[12].f64;
	// 825AFE24: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825AFE28: 4BFFFE49  bl 0x825afc70
	ctx.lr = 0x825AFE2C;
	sub_825AFC70(ctx, base);
	// 825AFE2C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825AFE30: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825AFE34: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825AFE38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AFE3C: 4BFFFB75  bl 0x825af9b0
	ctx.lr = 0x825AFE40;
	sub_825AF9B0(ctx, base);
	// 825AFE40: FD400890  fmr f10, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[10].f64 = ctx.f[1].f64;
	// 825AFE44: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825AFE48: FD006090  fmr f8, f12
	ctx.f[8].f64 = ctx.f[12].f64;
	// 825AFE4C: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 825AFE50: C0ABBFFC  lfs f5, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 825AFE54: FF0A3000  fcmpu cr6, f10, f6
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[6].f64);
	// 825AFE58: 40980080  bge cr6, 0x825afed8
	if !ctx.cr[6].lt {
	pc = 0x825AFED8; continue 'dispatch;
	}
	// 825AFE5C: FD605090  fmr f11, f10
	ctx.f[11].f64 = ctx.f[10].f64;
	// 825AFE60: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 825AFE64: 409900D8  ble cr6, 0x825aff3c
	if !ctx.cr[6].gt {
	pc = 0x825AFF3C; continue 'dispatch;
	}
	// 825AFE68: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825AFE6C: C14B8E2C  lfs f10, -0x71d4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29140 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	pc = 0x825AFE70; continue 'dispatch;
            }
            0x825AFE70 => {
    //   block [0x825AFE70..0x825AFECC)
	// 825AFE70: ED0802B2  fmuls f8, f8, f10
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[10].f64) as f32) as f64);
	// 825AFE74: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825AFE78: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825AFE7C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825AFE80: FC204090  fmr f1, f8
	ctx.f[1].f64 = ctx.f[8].f64;
	// 825AFE84: 4BFFFDED  bl 0x825afc70
	ctx.lr = 0x825AFE88;
	sub_825AFC70(ctx, base);
	// 825AFE88: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825AFE8C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825AFE90: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825AFE94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AFE98: 4BFFFB19  bl 0x825af9b0
	ctx.lr = 0x825AFE9C;
	sub_825AF9B0(ctx, base);
	// 825AFE9C: FD200890  fmr f9, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[9].f64 = ctx.f[1].f64;
	// 825AFEA0: FF0B4800  fcmpu cr6, f11, f9
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[9].f64);
	// 825AFEA4: 41980098  blt cr6, 0x825aff3c
	if ctx.cr[6].lt {
	pc = 0x825AFF3C; continue 'dispatch;
	}
	// 825AFEA8: 397AFFFF  addi r11, r26, -1
	ctx.r[11].s64 = ctx.r[26].s64 + -1;
	// 825AFEAC: FD804090  fmr f12, f8
	ctx.f[12].f64 = ctx.f[8].f64;
	// 825AFEB0: FD604890  fmr f11, f9
	ctx.f[11].f64 = ctx.f[9].f64;
	// 825AFEB4: 7F195800  cmpw cr6, r25, r11
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825AFEB8: 419A0014  beq cr6, 0x825afecc
	if ctx.cr[6].eq {
	pc = 0x825AFECC; continue 'dispatch;
	}
	// 825AFEBC: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 825AFEC0: 7F19D000  cmpw cr6, r25, r26
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[26].s32, &mut ctx.xer);
	// 825AFEC4: 4198FFAC  blt cr6, 0x825afe70
	if ctx.cr[6].lt {
	pc = 0x825AFE70; continue 'dispatch;
	}
	// 825AFEC8: 48000074  b 0x825aff3c
	pc = 0x825AFF3C; continue 'dispatch;
            }
            0x825AFECC => {
    //   block [0x825AFECC..0x825AFED8)
	// 825AFECC: FC204090  fmr f1, f8
	ctx.f[1].f64 = ctx.f[8].f64;
	// 825AFED0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825AFED4: 4BF85228  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            0x825AFED8 => {
    //   block [0x825AFED8..0x825AFEE4)
	// 825AFED8: FD205090  fmr f9, f10
	ctx.f[9].f64 = ctx.f[10].f64;
	// 825AFEDC: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 825AFEE0: 4099005C  ble cr6, 0x825aff3c
	if !ctx.cr[6].gt {
	pc = 0x825AFF3C; continue 'dispatch;
	}
	pc = 0x825AFEE4; continue 'dispatch;
            }
            0x825AFEE4 => {
    //   block [0x825AFEE4..0x825AFF24)
	// 825AFEE4: ED8C0172  fmuls f12, f12, f5
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[5].f64) as f32) as f64);
	// 825AFEE8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825AFEEC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825AFEF0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825AFEF4: FC206090  fmr f1, f12
	ctx.f[1].f64 = ctx.f[12].f64;
	// 825AFEF8: 4BFFFD79  bl 0x825afc70
	ctx.lr = 0x825AFEFC;
	sub_825AFC70(ctx, base);
	// 825AFEFC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825AFF00: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825AFF04: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825AFF08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AFF0C: 4BFFFAA5  bl 0x825af9b0
	ctx.lr = 0x825AFF10;
	sub_825AF9B0(ctx, base);
	// 825AFF10: FD600890  fmr f11, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].f64 = ctx.f[1].f64;
	// 825AFF14: FF0B3000  fcmpu cr6, f11, f6
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[6].f64);
	// 825AFF18: 4098000C  bge cr6, 0x825aff24
	if !ctx.cr[6].lt {
	pc = 0x825AFF24; continue 'dispatch;
	}
	// 825AFF1C: FF0B5000  fcmpu cr6, f11, f10
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[10].f64);
	// 825AFF20: 4198001C  blt cr6, 0x825aff3c
	if ctx.cr[6].lt {
	pc = 0x825AFF3C; continue 'dispatch;
	}
	pc = 0x825AFF24; continue 'dispatch;
            }
            0x825AFF24 => {
    //   block [0x825AFF24..0x825AFF3C)
	// 825AFF24: 397AFFFF  addi r11, r26, -1
	ctx.r[11].s64 = ctx.r[26].s64 + -1;
	// 825AFF28: 7F195800  cmpw cr6, r25, r11
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825AFF2C: 419A0104  beq cr6, 0x825b0030
	if ctx.cr[6].eq {
	pc = 0x825B0030; continue 'dispatch;
	}
	// 825AFF30: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 825AFF34: 7F19D000  cmpw cr6, r25, r26
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[26].s32, &mut ctx.xer);
	// 825AFF38: 4198FFAC  blt cr6, 0x825afee4
	if ctx.cr[6].lt {
	pc = 0x825AFEE4; continue 'dispatch;
	}
	pc = 0x825AFF3C; continue 'dispatch;
            }
            0x825AFF3C => {
    //   block [0x825AFF3C..0x825AFF80)
	// 825AFF3C: FF0C3800  fcmpu cr6, f12, f7
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[7].f64);
	// 825AFF40: 419800F0  blt cr6, 0x825b0030
	if ctx.cr[6].lt {
	pc = 0x825B0030; continue 'dispatch;
	}
	// 825AFF44: FF0C4000  fcmpu cr6, f12, f8
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[8].f64);
	// 825AFF48: 419900E8  bgt cr6, 0x825b0030
	if ctx.cr[6].gt {
	pc = 0x825B0030; continue 'dispatch;
	}
	// 825AFF4C: FF065800  fcmpu cr6, f6, f11
	ctx.cr[6].compare_f64(ctx.f[6].f64, ctx.f[11].f64);
	// 825AFF50: 419800E0  blt cr6, 0x825b0030
	if ctx.cr[6].lt {
	pc = 0x825B0030; continue 'dispatch;
	}
	// 825AFF54: FF095800  fcmpu cr6, f9, f11
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[11].f64);
	// 825AFF58: 419800D8  blt cr6, 0x825b0030
	if ctx.cr[6].lt {
	pc = 0x825B0030; continue 'dispatch;
	}
	// 825AFF5C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825AFF60: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 825AFF64: C00B0828  lfs f0, 0x828(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2088 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AFF68: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825AFF6C: EDA0002C  fsqrts f13, f0
	ctx.f[13].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 825AFF70: C00B2940  lfs f0, 0x2940(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10560 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AFF74: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 825AFF78: ED200172  fmuls f9, f0, f5
	ctx.f[9].f64 = (((ctx.f[0].f64 * ctx.f[5].f64) as f32) as f64);
	// 825AFF7C: 409900A8  ble cr6, 0x825b0024
	if !ctx.cr[6].gt {
	pc = 0x825B0024; continue 'dispatch;
	}
	pc = 0x825AFF80; continue 'dispatch;
            }
            0x825AFF80 => {
    //   block [0x825AFF80..0x825AFFD4)
	// 825AFF80: EC0C3828  fsubs f0, f12, f7
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[7].f64) as f32) as f64);
	// 825AFF84: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825AFF88: EDA86028  fsubs f13, f8, f12
	ctx.f[13].f64 = (((ctx.f[8].f64 - ctx.f[12].f64) as f32) as f64);
	// 825AFF8C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825AFF90: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825AFF94: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 825AFF98: 40990044  ble cr6, 0x825affdc
	if !ctx.cr[6].gt {
	pc = 0x825AFFDC; continue 'dispatch;
	}
	// 825AFF9C: ED40627C  fnmsubs f10, f0, f9, f12
	ctx.f[10].f64 = -(((ctx.f[0].f64 * ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 825AFFA0: FC205090  fmr f1, f10
	ctx.f[1].f64 = ctx.f[10].f64;
	// 825AFFA4: 4BFFFCCD  bl 0x825afc70
	ctx.lr = 0x825AFFA8;
	sub_825AFC70(ctx, base);
	// 825AFFA8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825AFFAC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825AFFB0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825AFFB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AFFB8: 4BFFF9F9  bl 0x825af9b0
	ctx.lr = 0x825AFFBC;
	sub_825AF9B0(ctx, base);
	// 825AFFBC: FF015800  fcmpu cr6, f1, f11
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[11].f64);
	// 825AFFC0: 40980014  bge cr6, 0x825affd4
	if !ctx.cr[6].lt {
	pc = 0x825AFFD4; continue 'dispatch;
	}
	// 825AFFC4: FD006090  fmr f8, f12
	ctx.f[8].f64 = ctx.f[12].f64;
	// 825AFFC8: FD805090  fmr f12, f10
	ctx.f[12].f64 = ctx.f[10].f64;
	// 825AFFCC: FD600890  fmr f11, f1
	ctx.f[11].f64 = ctx.f[1].f64;
	// 825AFFD0: 48000048  b 0x825b0018
	pc = 0x825B0018; continue 'dispatch;
            }
            0x825AFFD4 => {
    //   block [0x825AFFD4..0x825AFFDC)
	// 825AFFD4: FCE05090  fmr f7, f10
	ctx.f[7].f64 = ctx.f[10].f64;
	// 825AFFD8: 48000040  b 0x825b0018
	pc = 0x825B0018; continue 'dispatch;
            }
            0x825AFFDC => {
    //   block [0x825AFFDC..0x825B0014)
	// 825AFFDC: ED4D627A  fmadds f10, f13, f9, f12
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[9].f64 + ctx.f[12].f64) as f32) as f64);
	// 825AFFE0: FC205090  fmr f1, f10
	ctx.f[1].f64 = ctx.f[10].f64;
	// 825AFFE4: 4BFFFC8D  bl 0x825afc70
	ctx.lr = 0x825AFFE8;
	sub_825AFC70(ctx, base);
	// 825AFFE8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825AFFEC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825AFFF0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825AFFF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AFFF8: 4BFFF9B9  bl 0x825af9b0
	ctx.lr = 0x825AFFFC;
	sub_825AF9B0(ctx, base);
	// 825AFFFC: FF015800  fcmpu cr6, f1, f11
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[11].f64);
	// 825B0000: 40980014  bge cr6, 0x825b0014
	if !ctx.cr[6].lt {
	pc = 0x825B0014; continue 'dispatch;
	}
	// 825B0004: FCE06090  fmr f7, f12
	ctx.f[7].f64 = ctx.f[12].f64;
	// 825B0008: FD805090  fmr f12, f10
	ctx.f[12].f64 = ctx.f[10].f64;
	// 825B000C: FD600890  fmr f11, f1
	ctx.f[11].f64 = ctx.f[1].f64;
	// 825B0010: 48000008  b 0x825b0018
	pc = 0x825B0018; continue 'dispatch;
            }
            0x825B0014 => {
    //   block [0x825B0014..0x825B0018)
	// 825B0014: FD005090  fmr f8, f10
	ctx.f[8].f64 = ctx.f[10].f64;
	pc = 0x825B0018; continue 'dispatch;
            }
            0x825B0018 => {
    //   block [0x825B0018..0x825B0024)
	// 825B0018: 3B5AFFFF  addi r26, r26, -1
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	// 825B001C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 825B0020: 409AFF60  bne cr6, 0x825aff80
	if !ctx.cr[6].eq {
	pc = 0x825AFF80; continue 'dispatch;
	}
	pc = 0x825B0024; continue 'dispatch;
            }
            0x825B0024 => {
    //   block [0x825B0024..0x825B0030)
	// 825B0024: FC206090  fmr f1, f12
	ctx.f[1].f64 = ctx.f[12].f64;
	// 825B0028: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825B002C: 4BF850D0  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            0x825B0030 => {
    //   block [0x825B0030..0x825B0040)
	// 825B0030: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825B0034: C02B2074  lfs f1, 0x2074(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8308 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825B0038: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825B003C: 4BF850C0  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B0040 size=328
    let mut pc: u32 = 0x825B0040;
    'dispatch: loop {
        match pc {
            0x825B0040 => {
    //   block [0x825B0040..0x825B0188)
	// 825B0040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B0044: 4BF85061  bl 0x825350a4
	ctx.lr = 0x825B0048;
	sub_82535080(ctx, base);
	// 825B0048: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 825B004C: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B0050: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825B0054: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825B0058: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 825B005C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 825B0060: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 825B0064: C10B2238  lfs f8, 0x2238(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8760 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 825B0068: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 825B006C: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 825B0070: 4BFFF941  bl 0x825af9b0
	ctx.lr = 0x825B0074;
	sub_825AF9B0(ctx, base);
	// 825B0074: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B0188 size=108
    let mut pc: u32 = 0x825B0188;
    'dispatch: loop {
        match pc {
            0x825B0188 => {
    //   block [0x825B0188..0x825B01F4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B01F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B01F8 size=256
    let mut pc: u32 = 0x825B01F8;
    'dispatch: loop {
        match pc {
            0x825B01F8 => {
    //   block [0x825B01F8..0x825B02F8)
	// 825B01F8: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B02F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B02F8 size=324
    let mut pc: u32 = 0x825B02F8;
    'dispatch: loop {
        match pc {
            0x825B02F8 => {
    //   block [0x825B02F8..0x825B043C)
	// 825B02F8: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B0440 size=608
    let mut pc: u32 = 0x825B0440;
    'dispatch: loop {
        match pc {
            0x825B0440 => {
    //   block [0x825B0440..0x825B0494)
	// 825B0440: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B0444: 4BF84C69  bl 0x825350ac
	ctx.lr = 0x825B0448;
	sub_82535080(ctx, base);
	// 825B0448: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 825B044C: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B0450: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 825B0454: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 825B0458: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B045C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825B0460: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 825B0464: 2B1A0003  cmplwi cr6, r26, 3
	ctx.cr[6].compare_u32(ctx.r[26].u32, 3 as u32, &mut ctx.xer);
	// 825B0468: 41990200  bgt cr6, 0x825b0668
	if ctx.cr[6].gt {
	pc = 0x825B0668; continue 'dispatch;
	}
	// 825B046C: 3D80825B  lis r12, -0x7da5
	ctx.r[12].s64 = -2107965440;
	// 825B0470: 398C0484  addi r12, r12, 0x484
	ctx.r[12].s64 = ctx.r[12].s64 + 1156;
	// 825B0474: 5740103A  slwi r0, r26, 2
	ctx.r[0].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 825B0478: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 825B047C: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 825B0480: 4E800420  bctr
	match ctx.r[26].u64 {
		0 => {
	pc = 0x825B0494; continue 'dispatch;
		},
		1 => {
	pc = 0x825B04C0; continue 'dispatch;
		},
		2 => {
	pc = 0x825B04E0; continue 'dispatch;
		},
		3 => {
	pc = 0x825B0560; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 825B0484: 825B0494  lwz r18, 0x494(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1172 as u32) ) } as u64;
	// 825B0488: 825B04C0  lwz r18, 0x4c0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1216 as u32) ) } as u64;
	// 825B048C: 825B04E0  lwz r18, 0x4e0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1248 as u32) ) } as u64;
	// 825B0490: 825B0560  lwz r18, 0x560(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1376 as u32) ) } as u64;
            }
            0x825B0494 => {
    //   block [0x825B0494..0x825B04C0)
	// 825B0494: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	pc = 0x825B04C0; continue 'dispatch;
            }
            0x825B04C0 => {
    //   block [0x825B04C0..0x825B04E0)
	// 825B04C0: 3960FFF0  li r11, -0x10
	ctx.r[11].s64 = -16;
	pc = 0x825B04E0; continue 'dispatch;
            }
            0x825B04E0 => {
    //   block [0x825B04E0..0x825B0560)
	// 825B04E0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 825B04E4: 39210054  addi r9, r1, 0x54
	ctx.r[9].s64 = ctx.r[1].s64 + 84;
	// 825B04E8: 397DFFF0  addi r11, r29, -0x10
	ctx.r[11].s64 = ctx.r[29].s64 + -16;
	// 825B04EC: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 825B04F0: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825B04F4: C00ABFFC  lfs f0, -0x4004(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B04F8: 3940FFE0  li r10, -0x20
	ctx.r[10].s64 = -32;
	// 825B04FC: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	pc = 0x825B0560; continue 'dispatch;
            }
            0x825B0560 => {
    //   block [0x825B0560..0x825B0668)
	// 825B0560: 38DDFFD0  addi r6, r29, -0x30
	ctx.r[6].s64 = ctx.r[29].s64 + -48;
	// 825B0564: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825B0568: 38BDFFE0  addi r5, r29, -0x20
	ctx.r[5].s64 = ctx.r[29].s64 + -32;
	// 825B056C: 389DFFF0  addi r4, r29, -0x10
	ctx.r[4].s64 = ctx.r[29].s64 + -16;
	// 825B0570: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825B0574: 4BFFFC85  bl 0x825b01f8
	ctx.lr = 0x825B0578;
	sub_825B01F8(ctx, base);
	pc = 0x825B0668; continue 'dispatch;
            }
            0x825B0668 => {
    //   block [0x825B0668..0x825B06A0)
	// 825B0668: 38FDFFC0  addi r7, r29, -0x40
	ctx.r[7].s64 = ctx.r[29].s64 + -64;
	// 825B066C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825B0670: 38DDFFD0  addi r6, r29, -0x30
	ctx.r[6].s64 = ctx.r[29].s64 + -48;
	// 825B0674: 38BDFFE0  addi r5, r29, -0x20
	ctx.r[5].s64 = ctx.r[29].s64 + -32;
	// 825B0678: 389DFFF0  addi r4, r29, -0x10
	ctx.r[4].s64 = ctx.r[29].s64 + -16;
	// 825B067C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825B0680: 4BFFFC79  bl 0x825b02f8
	ctx.lr = 0x825B0684;
	sub_825B02F8(ctx, base);
	// 825B0684: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B06A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B06A0 size=220
    let mut pc: u32 = 0x825B06A0;
    'dispatch: loop {
        match pc {
            0x825B06A0 => {
    //   block [0x825B06A0..0x825B0704)
	// 825B06A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B06A4: 4BF84A11  bl 0x825350b4
	ctx.lr = 0x825B06A8;
	sub_82535080(ctx, base);
	// 825B06A8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 825B06AC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B06B0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825B06B4: 838D0000  lwz r28, 0(r13)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B06B8: 3BA00010  li r29, 0x10
	ctx.r[29].s64 = 16;
	// 825B06BC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 825B06C0: 38A00007  li r5, 7
	ctx.r[5].s64 = 7;
	// 825B06C4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825B06C8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B06CC: 7C7DE02E  lwzx r3, r29, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 825B06D0: 55642036  slwi r4, r11, 4
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 825B06D4: 4BEB3B95  bl 0x82464268
	ctx.lr = 0x825B06D8;
	sub_82464268(ctx, base);
	// 825B06D8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B06DC: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B06E0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B06E4: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 825B06E8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825B06EC: 7D4B0194  addze r10, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[10].s64 = tmp.s64;
	// 825B06F0: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 825B06F4: 40990054  ble cr6, 0x825b0748
	if !ctx.cr[6].gt {
	pc = 0x825B0748; continue 'dispatch;
	}
	// 825B06F8: 5547103A  slwi r7, r10, 2
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825B06FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B0700: 395E0008  addi r10, r30, 8
	ctx.r[10].s64 = ctx.r[30].s64 + 8;
	pc = 0x825B0704; continue 'dispatch;
            }
            0x825B0704 => {
    //   block [0x825B0704..0x825B0748)
	// 825B0704: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0708: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825B070C: 7C085C2E  lfsx f0, r8, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B0710: D00AFFF8  stfs f0, -8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 825B0714: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0718: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 825B071C: C0080004  lfs f0, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B0720: D00AFFFC  stfs f0, -4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 825B0724: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0728: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 825B072C: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 825B0730: C0080008  lfs f0, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B0734: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825B0738: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B073C: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 825B0740: 7F094000  cmpw cr6, r9, r8
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[8].s32, &mut ctx.xer);
	// 825B0744: 4198FFC0  blt cr6, 0x825b0704
	if ctx.cr[6].lt {
	pc = 0x825B0704; continue 'dispatch;
	}
	pc = 0x825B0748; continue 'dispatch;
            }
            0x825B0748 => {
    //   block [0x825B0748..0x825B077C)
	// 825B0748: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825B074C: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0750: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B0754: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825B0758: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B075C: 4BFFFCE5  bl 0x825b0440
	ctx.lr = 0x825B0760;
	sub_825B0440(ctx, base);
	// 825B0760: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B0764: 7C7DE02E  lwzx r3, r29, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 825B0768: 4BEB3B59  bl 0x824642c0
	ctx.lr = 0x825B076C;
	sub_824642C0(ctx, base);
	// 825B076C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B0770: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825B0774: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 825B0778: 4BF8498C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B0780 size=356
    let mut pc: u32 = 0x825B0780;
    'dispatch: loop {
        match pc {
            0x825B0780 => {
    //   block [0x825B0780..0x825B07D4)
	// 825B0780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B0784: 4BF84921  bl 0x825350a4
	ctx.lr = 0x825B0788;
	sub_82535080(ctx, base);
	// 825B0788: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B078C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B0790: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 825B0794: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 825B0798: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 825B079C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B07A0: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 825B07A4: 409A0030  bne cr6, 0x825b07d4
	if !ctx.cr[6].eq {
	pc = 0x825B07D4; continue 'dispatch;
	}
	// 825B07A8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B07AC: 546A073E  clrlwi r10, r3, 0x1c
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x0000000Fu64;
	// 825B07B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B07B4: 409A0020  bne cr6, 0x825b07d4
	if !ctx.cr[6].eq {
	pc = 0x825B07D4; continue 'dispatch;
	}
	// 825B07B8: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 825B07BC: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B07C0: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 825B07C4: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 825B07C8: 48027FF9  bl 0x825d87c0
	ctx.lr = 0x825B07CC;
	sub_825D87C0(ctx, base);
	// 825B07CC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825B07D0: 4BF84924  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            0x825B07D4 => {
    //   block [0x825B07D4..0x825B080C)
	// 825B07D4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825B07D8: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B07DC: 3D008000  lis r8, -0x8000
	ctx.r[8].s64 = -2147483648;
	// 825B07E0: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 825B07E4: 7D5C5378  mr r28, r10
	ctx.r[28].u64 = ctx.r[10].u64;
	// 825B07E8: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 825B07EC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825B07F0: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825B07F4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B07F8: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 825B07FC: 4099009C  ble cr6, 0x825b0898
	if !ctx.cr[6].gt {
	pc = 0x825B0898; continue 'dispatch;
	}
	// 825B0800: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	// 825B0804: 557A103A  slwi r26, r11, 2
	ctx.r[26].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[26].u64 = ctx.r[26].u32 as u64;
	// 825B0808: 48000008  b 0x825b0810
	pc = 0x825B0810; continue 'dispatch;
            }
            0x825B080C => {
    //   block [0x825B080C..0x825B0810)
	// 825B080C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x825B0810; continue 'dispatch;
            }
            0x825B0810 => {
    //   block [0x825B0810..0x825B0838)
	// 825B0810: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B0814: 3BAA0001  addi r29, r10, 1
	ctx.r[29].s64 = ctx.r[10].s64 + 1;
	// 825B0818: 7D5B5378  mr r27, r10
	ctx.r[27].u64 = ctx.r[10].u64;
	// 825B081C: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825B0820: 7F0BE800  cmpw cr6, r11, r29
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[29].s32, &mut ctx.xer);
	// 825B0824: 40980024  bge cr6, 0x825b0848
	if !ctx.cr[6].lt {
	pc = 0x825B0848; continue 'dispatch;
	}
	// 825B0828: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B082C: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825B0830: 41980008  blt cr6, 0x825b0838
	if ctx.cr[6].lt {
	pc = 0x825B0838; continue 'dispatch;
	}
	// 825B0834: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x825B0838; continue 'dispatch;
            }
            0x825B0838 => {
    //   block [0x825B0838..0x825B0848)
	// 825B0838: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 825B083C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 825B0840: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B0844: 4BEBDA85  bl 0x8246e2c8
	ctx.lr = 0x825B0848;
	sub_8246E2C8(ctx, base);
	pc = 0x825B0848; continue 'dispatch;
            }
            0x825B0848 => {
    //   block [0x825B0848..0x825B0898)
	// 825B0848: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B084C: 576B2036  slwi r11, r27, 4
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B0850: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0854: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 825B0858: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825B085C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825B0860: 7C0AFC2E  lfsx f0, r10, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B0864: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825B0868: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B086C: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 825B0870: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B0874: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 825B0878: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B087C: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 825B0880: 7FFAFA14  add r31, r26, r31
	ctx.r[31].u64 = ctx.r[26].u64 + ctx.r[31].u64;
	// 825B0884: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B0888: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 825B088C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0890: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825B0894: 4198FF78  blt cr6, 0x825b080c
	if ctx.cr[6].lt {
	pc = 0x825B080C; continue 'dispatch;
	}
	pc = 0x825B0898; continue 'dispatch;
            }
            0x825B0898 => {
    //   block [0x825B0898..0x825B08DC)
	// 825B0898: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 825B089C: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B08A0: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 825B08A4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B08A8: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 825B08AC: 48027F15  bl 0x825d87c0
	ctx.lr = 0x825B08B0;
	sub_825D87C0(ctx, base);
	// 825B08B0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B08B4: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B08B8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825B08BC: 409A0020  bne cr6, 0x825b08dc
	if !ctx.cr[6].eq {
	pc = 0x825B08DC; continue 'dispatch;
	}
	// 825B08C0: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B08C4: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 825B08C8: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 825B08CC: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B08D0: 55652036  slwi r5, r11, 4
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 825B08D4: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825B08D8: 4BEB37E1  bl 0x824640b8
	ctx.lr = 0x825B08DC;
	sub_824640B8(ctx, base);
	pc = 0x825B08DC; continue 'dispatch;
            }
            0x825B08DC => {
    //   block [0x825B08DC..0x825B08E4)
	// 825B08DC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825B08E0: 4BF84814  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B08E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B08E8 size=2556
    let mut pc: u32 = 0x825B08E8;
    'dispatch: loop {
        match pc {
            0x825B08E8 => {
    //   block [0x825B08E8..0x825B12E4)
	// 825B08E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B08EC: 4BF847A9  bl 0x82535094
	ctx.lr = 0x825B08F0;
	sub_82535080(ctx, base);
	// 825B08F0: DBA1FF78  stfd f29, -0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[29].u64 ) };
	// 825B08F4: DBC1FF80  stfd f30, -0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[30].u64 ) };
	// 825B08F8: DBE1FF88  stfd f31, -0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 825B08FC: 3980FF60  li r12, -0xa0
	ctx.r[12].s64 = -160;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B12E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B12E8 size=432
    let mut pc: u32 = 0x825B12E8;
    'dispatch: loop {
        match pc {
            0x825B12E8 => {
    //   block [0x825B12E8..0x825B1348)
	// 825B12E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B12EC: 4BF83DC5  bl 0x825350b0
	ctx.lr = 0x825B12F0;
	sub_82535080(ctx, base);
	// 825B12F0: 9421FB10  stwu r1, -0x4f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-1264 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B12F4: 83AD0000  lwz r29, 0(r13)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B12F8: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 825B12FC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825B1300: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B1304: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 825B1308: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825B130C: 7D5DF82E  lwzx r10, r29, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 825B1310: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B1314: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B1318: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B131C: 4098002C  bge cr6, 0x825b1348
	if !ctx.cr[6].lt {
	pc = 0x825B1348; continue 'dispatch;
	}
	// 825B1320: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825B1324: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 825B1328: 3929A09C  addi r9, r9, -0x5f64
	ctx.r[9].s64 = ctx.r[9].s64 + -24420;
	// 825B132C: 3908A094  addi r8, r8, -0x5f6c
	ctx.r[8].s64 = ctx.r[8].s64 + -24428;
	// 825B1330: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B1334: 910B000C  stw r8, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 825B1338: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 825B133C: 390B0010  addi r8, r11, 0x10
	ctx.r[8].s64 = ctx.r[11].s64 + 16;
	// 825B1340: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B1344: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x825B1348; continue 'dispatch;
            }
            0x825B1348 => {
    //   block [0x825B1348..0x825B13A0)
	// 825B1348: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825B134C: 48027FCD  bl 0x825d9318
	ctx.lr = 0x825B1350;
	sub_825D9318(ctx, base);
	// 825B1350: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825B1354: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825B1358: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 825B135C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B1360: 4BFFF421  bl 0x825b0780
	ctx.lr = 0x825B1364;
	sub_825B0780(ctx, base);
	// 825B1364: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B1368: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825B136C: 48025C1D  bl 0x825d6f88
	ctx.lr = 0x825B1370;
	sub_825D6F88(ctx, base);
	// 825B1370: 7D5DF82E  lwzx r10, r29, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 825B1374: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B1378: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B137C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B1380: 40980020  bge cr6, 0x825b13a0
	if !ctx.cr[6].lt {
	pc = 0x825B13A0; continue 'dispatch;
	}
	// 825B1384: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825B1388: 3929A088  addi r9, r9, -0x5f78
	ctx.r[9].s64 = ctx.r[9].s64 + -24440;
	// 825B138C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B1390: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 825B1394: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 825B1398: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B139C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x825B13A0; continue 'dispatch;
            }
            0x825B13A0 => {
    //   block [0x825B13A0..0x825B1468)
	// 825B13A0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825B13A4: 395CFFFE  addi r10, r28, -2
	ctx.r[10].s64 = ctx.r[28].s64 + -2;
	// 825B13A8: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 825B13AC: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 825B13B0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825B13B4: C1ABA074  lfs f13, -0x5f8c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24460 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825B13B8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825B13BC: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 825B13C0: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825B13C4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825B13C8: D1A10090  stfs f13, 0x90(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 825B13CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B13D0: C00BA070  lfs f0, -0x5f90(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24464 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B13D4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825B13D8: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 825B13DC: C00B2150  lfs f0, 0x2150(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8528 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B13E0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825B13E4: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 825B13E8: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 825B13EC: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 825B13F0: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 825B13F4: C18B2298  lfs f12, 0x2298(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8856 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825B13F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825B13FC: D1810070  stfs f12, 0x70(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 825B1400: D181008C  stfs f12, 0x8c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 825B1404: C16B2954  lfs f11, 0x2954(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10580 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825B1408: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B140C: D1610074  stfs f11, 0x74(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825B1410: 99610060  stb r11, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 825B1414: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825B1418: C16B2784  lfs f11, 0x2784(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10116 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825B141C: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 825B1420: D1610080  stfs f11, 0x80(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 825B1424: 99610062  stb r11, 0x62(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(98 as u32), ctx.r[11].u8 ) };
	// 825B1428: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825B142C: C00B20AC  lfs f0, 0x20ac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8364 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B1430: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 825B1434: 48025C3D  bl 0x825d7070
	ctx.lr = 0x825B1438;
	sub_825D7070(ctx, base);
	// 825B1438: 7D7DF82E  lwzx r11, r29, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 825B143C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B1440: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B1444: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B1448: 40980020  bge cr6, 0x825b1468
	if !ctx.cr[6].lt {
	pc = 0x825B1468; continue 'dispatch;
	}
	// 825B144C: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 825B1450: 3929FE14  addi r9, r9, -0x1ec
	ctx.r[9].s64 = ctx.r[9].s64 + -492;
	// 825B1454: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B1458: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 825B145C: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 825B1460: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B1464: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x825B1468; continue 'dispatch;
            }
            0x825B1468 => {
    //   block [0x825B1468..0x825B1490)
	// 825B1468: 816100AC  lwz r11, 0xac(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 825B146C: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B1470: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825B1474: 409A001C  bne cr6, 0x825b1490
	if !ctx.cr[6].eq {
	pc = 0x825B1490; continue 'dispatch;
	}
	// 825B1478: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 825B147C: 808100A4  lwz r4, 0xa4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 825B1480: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 825B1484: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 825B1488: 7C7D502E  lwzx r3, r29, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825B148C: 4BEB2C2D  bl 0x824640b8
	ctx.lr = 0x825B1490;
	sub_824640B8(ctx, base);
	pc = 0x825B1490; continue 'dispatch;
            }
            0x825B1490 => {
    //   block [0x825B1490..0x825B1498)
	// 825B1490: 382104F0  addi r1, r1, 0x4f0
	ctx.r[1].s64 = ctx.r[1].s64 + 1264;
	// 825B1494: 4BF83C6C  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B1498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B1498 size=116
    let mut pc: u32 = 0x825B1498;
    'dispatch: loop {
        match pc {
            0x825B1498 => {
    //   block [0x825B1498..0x825B1504)
	// 825B1498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B149C: 4BF83C21  bl 0x825350bc
	ctx.lr = 0x825B14A0;
	sub_82535080(ctx, base);
	// 825B14A0: 9421FB80  stwu r1, -0x480(r1)
	ea = ctx.r[1].u32.wrapping_add(-1152 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B14A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B14A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B14AC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825B14B0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825B14B4: 48027E65  bl 0x825d9318
	ctx.lr = 0x825B14B8;
	sub_825D9318(ctx, base);
	// 825B14B8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 825B14BC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B14C0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B14C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B14C8: 4BFFF2B9  bl 0x825b0780
	ctx.lr = 0x825B14CC;
	sub_825B0780(ctx, base);
	// 825B14CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B14D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B14D4: 48025AB5  bl 0x825d6f88
	ctx.lr = 0x825B14D8;
	sub_825D6F88(ctx, base);
	// 825B14D8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825B14DC: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B14E0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825B14E4: 409A0020  bne cr6, 0x825b1504
	if !ctx.cr[6].eq {
	pc = 0x825B1504; continue 'dispatch;
	}
	// 825B14E8: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B14EC: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 825B14F0: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 825B14F4: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B14F8: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 825B14FC: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825B1500: 4BEB2BB9  bl 0x824640b8
	ctx.lr = 0x825B1504;
	sub_824640B8(ctx, base);
	pc = 0x825B1504; continue 'dispatch;
            }
            0x825B1504 => {
    //   block [0x825B1504..0x825B150C)
	// 825B1504: 38210480  addi r1, r1, 0x480
	ctx.r[1].s64 = ctx.r[1].s64 + 1152;
	// 825B1508: 4BF83C04  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B1510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B1510 size=180
    let mut pc: u32 = 0x825B1510;
    'dispatch: loop {
        match pc {
            0x825B1510 => {
    //   block [0x825B1510..0x825B1578)
	// 825B1510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B1514: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B1518: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825B151C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B1520: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B1524: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825B1528: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 825B152C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B1530: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B1534: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825B1538: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 825B153C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825B1540: 48020749  bl 0x825d1c88
	ctx.lr = 0x825B1544;
	sub_825D1C88(ctx, base);
	// 825B1544: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B1548: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B154C: 4099002C  ble cr6, 0x825b1578
	if !ctx.cr[6].gt {
	pc = 0x825B1578; continue 'dispatch;
	}
	// 825B1550: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B1554: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825B1558: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B155C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825B1560: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B1564: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825B1568: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 825B156C: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 825B1570: 4BFFFF29  bl 0x825b1498
	ctx.lr = 0x825B1574;
	sub_825B1498(ctx, base);
	// 825B1574: 4800000C  b 0x825b1580
	pc = 0x825B1580; continue 'dispatch;
            }
            0x825B1578 => {
    //   block [0x825B1578..0x825B1580)
	// 825B1578: 93FE0010  stw r31, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 825B157C: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x825B1580; continue 'dispatch;
            }
            0x825B1580 => {
    //   block [0x825B1580..0x825B15AC)
	// 825B1580: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B1584: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B1588: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825B158C: 409A0020  bne cr6, 0x825b15ac
	if !ctx.cr[6].eq {
	pc = 0x825B15AC; continue 'dispatch;
	}
	// 825B1590: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B1594: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 825B1598: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 825B159C: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B15A0: 55652036  slwi r5, r11, 4
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 825B15A4: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825B15A8: 4BEB2B11  bl 0x824640b8
	ctx.lr = 0x825B15AC;
	sub_824640B8(ctx, base);
	pc = 0x825B15AC; continue 'dispatch;
            }
            0x825B15AC => {
    //   block [0x825B15AC..0x825B15C4)
	// 825B15AC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825B15B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B15B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B15B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825B15BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B15C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B15C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B15C8 size=1084
    let mut pc: u32 = 0x825B15C8;
    'dispatch: loop {
        match pc {
            0x825B15C8 => {
    //   block [0x825B15C8..0x825B165C)
	// 825B15C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B15CC: 4BF83AD5  bl 0x825350a0
	ctx.lr = 0x825B15D0;
	sub_82535080(ctx, base);
	// 825B15D0: DBE1FFA0  stfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 825B15D4: 9421FA30  stwu r1, -0x5d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-1488 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B15D8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825B15DC: 3FE08000  lis r31, -0x8000
	ctx.r[31].s64 = -2147483648;
	// 825B15E0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B15E4: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 825B15E8: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 825B15EC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 825B15F0: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 825B15F4: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 825B15F8: 93610074  stw r27, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[27].u32 ) };
	// 825B15FC: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 825B1600: 9361007C  stw r27, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[27].u32 ) };
	// 825B1604: 93610080  stw r27, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[27].u32 ) };
	// 825B1608: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 825B160C: 48027D0D  bl 0x825d9318
	ctx.lr = 0x825B1610;
	sub_825D9318(ctx, base);
	// 825B1610: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825B1614: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 825B1618: 38810160  addi r4, r1, 0x160
	ctx.r[4].s64 = ctx.r[1].s64 + 352;
	// 825B161C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B1620: 4BFFF161  bl 0x825b0780
	ctx.lr = 0x825B1624;
	sub_825B0780(ctx, base);
	// 825B1624: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825B1628: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 825B162C: 4802595D  bl 0x825d6f88
	ctx.lr = 0x825B1630;
	sub_825D6F88(ctx, base);
	// 825B1630: 8161016C  lwz r11, 0x16c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(364 as u32) ) } as u64;
	// 825B1634: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B1638: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825B163C: 409A0020  bne cr6, 0x825b165c
	if !ctx.cr[6].eq {
	pc = 0x825B165C; continue 'dispatch;
	}
	// 825B1640: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B1644: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 825B1648: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 825B164C: 80810164  lwz r4, 0x164(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(356 as u32) ) } as u64;
	// 825B1650: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 825B1654: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825B1658: 4BEB2A61  bl 0x824640b8
	ctx.lr = 0x825B165C;
	sub_824640B8(ctx, base);
	pc = 0x825B165C; continue 'dispatch;
            }
            0x825B165C => {
    //   block [0x825B165C..0x825B16A4)
	// 825B165C: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 825B1660: 3B200010  li r25, 0x10
	ctx.r[25].s64 = 16;
	// 825B1664: 830D0000  lwz r24, 0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B1668: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825B166C: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 825B1670: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 825B1674: 7FCB5214  add r30, r11, r10
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B1678: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825B167C: 7D79C02E  lwzx r11, r25, r24
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 825B1680: 393E0001  addi r9, r30, 1
	ctx.r[9].s64 = ctx.r[30].s64 + 1;
	// 825B1684: 55242036  slwi r4, r9, 4
	ctx.r[4].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 825B1688: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 825B168C: 810B002C  lwz r8, 0x2c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 825B1690: 7D2A2214  add r9, r10, r4
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 825B1694: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825B1698: 4199000C  bgt cr6, 0x825b16a4
	if ctx.cr[6].gt {
	pc = 0x825B16A4; continue 'dispatch;
	}
	// 825B169C: 912B0020  stw r9, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 825B16A0: 4800001C  b 0x825b16bc
	pc = 0x825B16BC; continue 'dispatch;
            }
            0x825B16A4 => {
    //   block [0x825B16A4..0x825B16BC)
	// 825B16A4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B16A8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825B16AC: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B16B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B16B4: 4E800421  bctrl
	ctx.lr = 0x825B16B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B16B8: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
            }
            0x825B16BC => {
    //   block [0x825B16BC..0x825B16F4)
	// 825B16BC: 7FC9FB78  or r9, r30, r31
	ctx.r[9].u64 = ctx.r[30].u64 | ctx.r[31].u64;
	// 825B16C0: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 825B16C4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825B16C8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 825B16CC: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825B16D0: 7FEB5214  add r31, r11, r10
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B16D4: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 825B16D8: 552900BE  clrlwi r9, r9, 2
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x3FFFFFFFu64;
	// 825B16DC: 7F09F800  cmpw cr6, r9, r31
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[31].s32, &mut ctx.xer);
	// 825B16E0: 40980028  bge cr6, 0x825b1708
	if !ctx.cr[6].lt {
	pc = 0x825B1708; continue 'dispatch;
	}
	// 825B16E4: 552B083C  slwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B16E8: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825B16EC: 41980008  blt cr6, 0x825b16f4
	if ctx.cr[6].lt {
	pc = 0x825B16F4; continue 'dispatch;
	}
	// 825B16F0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x825B16F4; continue 'dispatch;
            }
            0x825B16F4 => {
    //   block [0x825B16F4..0x825B1708)
	// 825B16F4: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 825B16F8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 825B16FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B1700: 4BEBCBC9  bl 0x8246e2c8
	ctx.lr = 0x825B1704;
	sub_8246E2C8(ctx, base);
	// 825B1704: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	pc = 0x825B1708; continue 'dispatch;
            }
            0x825B1708 => {
    //   block [0x825B1708..0x825B17A4)
	// 825B1708: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 825B170C: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 825B1710: 3B800010  li r28, 0x10
	ctx.r[28].s64 = 16;
	// 825B1714: 3BA00020  li r29, 0x20
	ctx.r[29].s64 = 32;
	// 825B1718: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B171C: 40990088  ble cr6, 0x825b17a4
	if !ctx.cr[6].gt {
	pc = 0x825B17A4; continue 'dispatch;
	}
	// 825B1720: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 825B1724: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 825B1728: 8101007C  lwz r8, 0x7c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825B172C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825B1730: 80E10070  lwz r7, 0x70(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 825B1734: 7D0B402E  lwzx r8, r11, r8
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 825B1738: 55082036  slwi r8, r8, 4
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	pc = 0x825B17A4; continue 'dispatch;
            }
            0x825B17A4 => {
    //   block [0x825B17A4..0x825B1A04)
	// 825B17A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825B17A8: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 825B17AC: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 825B17B0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825B17B4: C02B20B0  lfs f1, 0x20b0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8368 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825B17B8: 4BFFF131  bl 0x825b08e8
	ctx.lr = 0x825B17BC;
	sub_825B08E8(ctx, base);
	// 825B17BC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825B17C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B17C4: 409A01E0  bne cr6, 0x825b19a4
	if !ctx.cr[6].eq {
	pc = 0x825B19A4; continue 'dispatch;
	}
	// 825B17C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825B17CC: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B17D0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B17D4: 390100B0  addi r8, r1, 0xb0
	ctx.r[8].s64 = ctx.r[1].s64 + 176;
	// 825B17D8: 38E10100  addi r7, r1, 0x100
	ctx.r[7].s64 = ctx.r[1].s64 + 256;
	// 825B17DC: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 825B17E0: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 825B17E4: C1AB1850  lfs f13, 0x1850(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825B17E8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825B17EC: D1A100A0  stfs f13, 0xa0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 825B17F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B17F4: D1A10094  stfs f13, 0x94(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 825B17F8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B17FC: D1A100B8  stfs f13, 0xb8(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 825B1800: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B1804: 39610100  addi r11, r1, 0x100
	ctx.r[11].s64 = ctx.r[1].s64 + 256;
	// 825B1808: D00100A4  stfs f0, 0xa4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 825B180C: D00100A8  stfs f0, 0xa8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 825B1810: D00100AC  stfs f0, 0xac(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 825B1814: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 825B1818: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 825B181C: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 825B1820: D001009C  stfs f0, 0x9c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 825B1824: D00100B0  stfs f0, 0xb0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B1A08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B1A08 size=132
    let mut pc: u32 = 0x825B1A08;
    'dispatch: loop {
        match pc {
            0x825B1A08 => {
    //   block [0x825B1A08..0x825B1A8C)
	// 825B1A08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B1A0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B1A10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825B1A14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B1A18: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B1A1C: 80650000  lwz r3, 0(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B1A20: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B1A24: 90A10050  stw r5, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u32 ) };
	// 825B1A28: 90C10054  stw r6, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[6].u32 ) };
	// 825B1A2C: 90E10060  stw r7, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[7].u32 ) };
	// 825B1A30: 91010064  stw r8, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[8].u32 ) };
	// 825B1A34: 91210068  stw r9, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 825B1A38: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B1A3C: 83E60000  lwz r31, 0(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B1A40: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B1A44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B1A48: 4E800421  bctrl
	ctx.lr = 0x825B1A4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B1A4C: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 825B1A50: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B1A54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B1A58: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B1A5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B1A60: 4E800421  bctrl
	ctx.lr = 0x825B1A64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B1A64: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 825B1A68: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B1A6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B1A70: 4800D289  bl 0x825becf8
	ctx.lr = 0x825B1A74;
	sub_825BECF8(ctx, base);
	// 825B1A74: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825B1A78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B1A7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B1A80: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825B1A84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B1A88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B1A90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B1A90 size=96
    let mut pc: u32 = 0x825B1A90;
    'dispatch: loop {
        match pc {
            0x825B1A90 => {
    //   block [0x825B1A90..0x825B1AF0)
	// 825B1A90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B1A94: 4BF83629  bl 0x825350bc
	ctx.lr = 0x825B1A98;
	sub_82535080(ctx, base);
	// 825B1A98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B1A9C: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 825B1AA0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825B1AA4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B1AA8: 388BA0C0  addi r4, r11, -0x5f40
	ctx.r[4].s64 = ctx.r[11].s64 + -24384;
	// 825B1AAC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825B1AB0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B1AB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B1AB8: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 825B1ABC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B1AC0: 4E800421  bctrl
	ctx.lr = 0x825B1AC4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B1AC4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B1AC8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825B1ACC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B1AD0: 4BF24B41  bl 0x824d6610
	ctx.lr = 0x825B1AD4;
	sub_824D6610(ctx, base);
	// 825B1AD4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B1AD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B1ADC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B1AE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B1AE4: 4E800421  bctrl
	ctx.lr = 0x825B1AE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B1AE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B1AEC: 4BF83620  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B1B10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B1B10 size=900
    let mut pc: u32 = 0x825B1B10;
    'dispatch: loop {
        match pc {
            0x825B1B10 => {
    //   block [0x825B1B10..0x825B1B5C)
	// 825B1B10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B1B14: 4BF83575  bl 0x82535088
	ctx.lr = 0x825B1B18;
	sub_82535080(ctx, base);
	// 825B1B18: DBE1FF70  stfd f31, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[31].u64 ) };
	// 825B1B1C: 9421FB10  stwu r1, -0x4f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-1264 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B1B20: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825B1B24: 7C932378  mr r19, r4
	ctx.r[19].u64 = ctx.r[4].u64;
	// 825B1B28: 7CB22B78  mr r18, r5
	ctx.r[18].u64 = ctx.r[5].u64;
	// 825B1B2C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 825B1B30: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 825B1B34: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B1B38: 7D1F4378  mr r31, r8
	ctx.r[31].u64 = ctx.r[8].u64;
	// 825B1B3C: 816B0060  lwz r11, 0x60(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 825B1B40: 822B0010  lwz r17, 0x10(r11)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825B1B44: 2F110000  cmpwi cr6, r17, 0
	ctx.cr[6].compare_i32(ctx.r[17].s32, 0, &mut ctx.xer);
	// 825B1B48: 419A0030  beq cr6, 0x825b1b78
	if ctx.cr[6].eq {
	pc = 0x825B1B78; continue 'dispatch;
	}
	// 825B1B4C: 8172000C  lwz r11, 0xc(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B1B50: 7E4A9378  mr r10, r18
	ctx.r[10].u64 = ctx.r[18].u64;
	// 825B1B54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B1B58: 419A0014  beq cr6, 0x825b1b6c
	if ctx.cr[6].eq {
	pc = 0x825B1B6C; continue 'dispatch;
	}
	pc = 0x825B1B5C; continue 'dispatch;
            }
            0x825B1B5C => {
    //   block [0x825B1B5C..0x825B1B6C)
	// 825B1B5C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B1B60: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B1B64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B1B68: 409AFFF4  bne cr6, 0x825b1b5c
	if !ctx.cr[6].eq {
	pc = 0x825B1B5C; continue 'dispatch;
	}
	pc = 0x825B1B6C; continue 'dispatch;
            }
            0x825B1B6C => {
    //   block [0x825B1B6C..0x825B1B78)
	// 825B1B6C: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 825B1B70: 806A0008  lwz r3, 8(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B1B74: 4BF4F3CD  bl 0x82500f40
	ctx.lr = 0x825B1B78;
	sub_82500F40(ctx, base);
	pc = 0x825B1B78; continue 'dispatch;
            }
            0x825B1B78 => {
    //   block [0x825B1B78..0x825B1D98)
	// 825B1B78: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 825B1B7C: 4099030C  ble cr6, 0x825b1e88
	if !ctx.cr[6].gt {
	pc = 0x825B1E88; continue 'dispatch;
	}
	// 825B1B80: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825B1B84: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 825B1B88: 3B2B9F50  addi r25, r11, -0x60b0
	ctx.r[25].s64 = ctx.r[11].s64 + -24752;
	// 825B1B8C: 3D608283  lis r11, -0x7d7d
	ctx.r[11].s64 = -2105344000;
	// 825B1B90: 3BFF0018  addi r31, r31, 0x18
	ctx.r[31].s64 = ctx.r[31].s64 + 24;
	// 825B1B94: 3B0B26E0  addi r24, r11, 0x26e0
	ctx.r[24].s64 = ctx.r[11].s64 + 9952;
	// 825B1B98: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825B1B9C: C3EABFFC  lfs f31, -0x4004(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825B1BA0: 3B800020  li r28, 0x20
	ctx.r[28].s64 = 32;
	// 825B1BA4: 3A8B9F60  addi r20, r11, -0x60a0
	ctx.r[20].s64 = ctx.r[11].s64 + -24736;
	// 825B1BA8: 3AA0FFF0  li r21, -0x10
	ctx.r[21].s64 = -16;
	// 825B1BAC: 3AC00010  li r22, 0x10
	ctx.r[22].s64 = 16;
	// 825B1BB0: 3A000090  li r16, 0x90
	ctx.r[16].s64 = 144;
	// 825B1BB4: 3AE00030  li r23, 0x30
	ctx.r[23].s64 = 48;
	// 825B1BB8: 81730000  lwz r11, 0(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B1BBC: 38A10260  addi r5, r1, 0x260
	ctx.r[5].s64 = ctx.r[1].s64 + 608;
	// 825B1BC0: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B1BC4: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 825B1BC8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825B1BCC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B1BD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B1BD4: 4E800421  bctrl
	ctx.lr = 0x825B1BD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B1BD8: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B1BDC: 80920008  lwz r4, 8(r18)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B1BE0: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 825B1BE4: C02B0004  lfs f1, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825B1BE8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B1BEC: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 825B1BF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B1BF4: 4E800421  bctrl
	ctx.lr = 0x825B1BF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B1BF8: 2F110000  cmpwi cr6, r17, 0
	ctx.cr[6].compare_i32(ctx.r[17].s32, 0, &mut ctx.xer);
	// 825B1BFC: 419A019C  beq cr6, 0x825b1d98
	if ctx.cr[6].eq {
	pc = 0x825B1D98; continue 'dispatch;
	}
	// 825B1C00: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 825B1C04: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825B1C08: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
            }
            0x825B1D98 => {
    //   block [0x825B1D98..0x825B1E88)
	// 825B1D98: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B1D9C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	pc = 0x825B1E88; continue 'dispatch;
            }
            0x825B1E88 => {
    //   block [0x825B1E88..0x825B1E94)
	// 825B1E88: 382104F0  addi r1, r1, 0x4f0
	ctx.r[1].s64 = ctx.r[1].s64 + 1264;
	// 825B1E8C: CBE1FF70  lfd f31, -0x90(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 825B1E90: 4BF83248  b 0x825350d8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B1E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B1E98 size=1484
    let mut pc: u32 = 0x825B1E98;
    'dispatch: loop {
        match pc {
            0x825B1E98 => {
    //   block [0x825B1E98..0x825B2464)
	// 825B1E98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B1E9C: 4BF831ED  bl 0x82535088
	ctx.lr = 0x825B1EA0;
	sub_82535080(ctx, base);
	// 825B1EA0: DBE1FF70  stfd f31, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[31].u64 ) };
	// 825B1EA4: 3980FF50  li r12, -0xb0
	ctx.r[12].s64 = -176;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B2468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B2468 size=3140
    let mut pc: u32 = 0x825B2468;
    'dispatch: loop {
        match pc {
            0x825B2468 => {
    //   block [0x825B2468..0x825B24CC)
	// 825B2468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B246C: 4BF82C15  bl 0x82535080
	ctx.lr = 0x825B2470;
	sub_82535080(ctx, base);
	// 825B2470: DBE1FF60  stfd f31, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 825B2474: 9421FA90  stwu r1, -0x570(r1)
	ea = ctx.r[1].u32.wrapping_add(-1392 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B2478: 832D0000  lwz r25, 0(r13)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B247C: 3B000014  li r24, 0x14
	ctx.r[24].s64 = 20;
	// 825B2480: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825B2484: 90A10594  stw r5, 0x594(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1428 as u32), ctx.r[5].u32 ) };
	// 825B2488: 90E105A4  stw r7, 0x5a4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1444 as u32), ctx.r[7].u32 ) };
	// 825B248C: 7D59C02E  lwzx r10, r25, r24
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 825B2490: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 825B2494: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2498: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B249C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B24A0: 4098002C  bge cr6, 0x825b24cc
	if !ctx.cr[6].lt {
	pc = 0x825B24CC; continue 'dispatch;
	}
	// 825B24A4: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825B24A8: 3D008206  lis r8, -0x7dfa
	ctx.r[8].s64 = -2113536000;
	// 825B24AC: 3929A134  addi r9, r9, -0x5ecc
	ctx.r[9].s64 = ctx.r[9].s64 + -24268;
	// 825B24B0: 3908077C  addi r8, r8, 0x77c
	ctx.r[8].s64 = ctx.r[8].s64 + 1916;
	// 825B24B4: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B24B8: 910B000C  stw r8, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 825B24BC: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 825B24C0: 390B0010  addi r8, r11, 0x10
	ctx.r[8].s64 = ctx.r[11].s64 + 16;
	// 825B24C4: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B24C8: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x825B24CC; continue 'dispatch;
            }
            0x825B24CC => {
    //   block [0x825B24CC..0x825B2530)
	// 825B24CC: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B24D0: 811C0004  lwz r8, 4(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B24D4: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B24D8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B24DC: 80E80000  lwz r7, 0(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B24E0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B24E4: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B24E8: 8147000C  lwz r10, 0xc(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B24EC: 39290044  addi r9, r9, 0x44
	ctx.r[9].s64 = ctx.r[9].s64 + 68;
	// 825B24F0: 394A0044  addi r10, r10, 0x44
	ctx.r[10].s64 = ctx.r[10].s64 + 68;
	// 825B24F4: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825B24F8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825B24FC: 7D29582E  lwzx r9, r9, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825B2500: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825B2504: 7D2A48F8  nor r10, r9, r9
	ctx.r[10].u64 = !(ctx.r[9].u64 | ctx.r[9].u64);
	// 825B2508: 7D6958F8  nor r9, r11, r11
	ctx.r[9].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 825B250C: 554BBFFE  rlwinm r11, r10, 0x17, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000001FFu64;
	// 825B2510: 553DBFFE  rlwinm r29, r9, 0x17, 0x1f, 0x1f
	ctx.r[29].u64 = ctx.r[9].u32 as u64 & 0x000001FFu64;
	// 825B2514: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 825B2518: 7FCAEB78  or r10, r30, r29
	ctx.r[10].u64 = ctx.r[30].u64 | ctx.r[29].u64;
	// 825B251C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 825B2520: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B2524: 419A000C  beq cr6, 0x825b2530
	if ctx.cr[6].eq {
	pc = 0x825B2530; continue 'dispatch;
	}
	// 825B2528: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825B252C: 48000138  b 0x825b2664
	pc = 0x825B2664; continue 'dispatch;
            }
            0x825B2530 => {
    //   block [0x825B2530..0x825B254C)
	// 825B2530: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B2534: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B2538: 409A0014  bne cr6, 0x825b254c
	if !ctx.cr[6].eq {
	pc = 0x825B254C; continue 'dispatch;
	}
	// 825B253C: 81630044  lwz r11, 0x44(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) } as u64;
	// 825B2540: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B2544: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B2548: 409A0008  bne cr6, 0x825b2550
	if !ctx.cr[6].eq {
	pc = 0x825B2550; continue 'dispatch;
	}
	pc = 0x825B254C; continue 'dispatch;
            }
            0x825B254C => {
    //   block [0x825B254C..0x825B2550)
	// 825B254C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x825B2550; continue 'dispatch;
            }
            0x825B2550 => {
    //   block [0x825B2550..0x825B256C)
	// 825B2550: 8168000C  lwz r11, 0xc(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B2554: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B2558: 409A0014  bne cr6, 0x825b256c
	if !ctx.cr[6].eq {
	pc = 0x825B256C; continue 'dispatch;
	}
	// 825B255C: 81680044  lwz r11, 0x44(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(68 as u32) ) } as u64;
	// 825B2560: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B2564: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B2568: 409A0008  bne cr6, 0x825b2570
	if !ctx.cr[6].eq {
	pc = 0x825B2570; continue 'dispatch;
	}
	pc = 0x825B256C; continue 'dispatch;
            }
            0x825B256C => {
    //   block [0x825B256C..0x825B2570)
	// 825B256C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825B2570; continue 'dispatch;
            }
            0x825B2570 => {
    //   block [0x825B2570..0x825B25B0)
	// 825B2570: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B2574: 5549063E  clrlwi r9, r10, 0x18
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 825B2578: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B257C: 409A00E4  bne cr6, 0x825b2660
	if !ctx.cr[6].eq {
	pc = 0x825B2660; continue 'dispatch;
	}
	// 825B2580: 480010E1  bl 0x825b3660
	ctx.lr = 0x825B2584;
	sub_825B3660(ctx, base);
	// 825B2584: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2588: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B258C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825B2590: 480010D1  bl 0x825b3660
	ctx.lr = 0x825B2594;
	sub_825B3660(ctx, base);
	// 825B2594: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825B2598: 419A0018  beq cr6, 0x825b25b0
	if ctx.cr[6].eq {
	pc = 0x825B25B0; continue 'dispatch;
	}
	// 825B259C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B25A0: 396BFFF6  addi r11, r11, -0xa
	ctx.r[11].s64 = ctx.r[11].s64 + -10;
	// 825B25A4: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825B25A8: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 825B25AC: 48000008  b 0x825b25b4
	pc = 0x825B25B4; continue 'dispatch;
            }
            0x825B25B0 => {
    //   block [0x825B25B0..0x825B25B4)
	// 825B25B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825B25B4; continue 'dispatch;
            }
            0x825B25B4 => {
    //   block [0x825B25B4..0x825B25D4)
	// 825B25B4: 5569063E  clrlwi r9, r11, 0x18
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B25B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B25BC: 419A0018  beq cr6, 0x825b25d4
	if ctx.cr[6].eq {
	pc = 0x825B25D4; continue 'dispatch;
	}
	// 825B25C0: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B25C4: 396BFFF6  addi r11, r11, -0xa
	ctx.r[11].s64 = ctx.r[11].s64 + -10;
	// 825B25C8: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825B25CC: 556ADFFE  rlwinm r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 825B25D0: 48000008  b 0x825b25d8
	pc = 0x825B25D8; continue 'dispatch;
            }
            0x825B25D4 => {
    //   block [0x825B25D4..0x825B25D8)
	// 825B25D4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x825B25D8; continue 'dispatch;
            }
            0x825B25D8 => {
    //   block [0x825B25D8..0x825B2614)
	// 825B25D8: 552B063E  clrlwi r11, r9, 0x18
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 825B25DC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 825B25E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B25E4: 419A0030  beq cr6, 0x825b2614
	if ctx.cr[6].eq {
	pc = 0x825B2614; continue 'dispatch;
	}
	// 825B25E8: 5548063E  clrlwi r8, r10, 0x18
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 825B25EC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 825B25F0: 419A0024  beq cr6, 0x825b2614
	if ctx.cr[6].eq {
	pc = 0x825B2614; continue 'dispatch;
	}
	// 825B25F4: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 825B25F8: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 825B25FC: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825B2600: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B2604: 40990054  ble cr6, 0x825b2658
	if !ctx.cr[6].gt {
	pc = 0x825B2658; continue 'dispatch;
	}
	// 825B2608: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B260C: 557F063E  clrlwi r31, r11, 0x18
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B2610: 48000054  b 0x825b2664
	pc = 0x825B2664; continue 'dispatch;
            }
            0x825B2614 => {
    //   block [0x825B2614..0x825B2630)
	// 825B2614: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 825B2618: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 825B261C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B2620: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B2624: 419A000C  beq cr6, 0x825b2630
	if ctx.cr[6].eq {
	pc = 0x825B2630; continue 'dispatch;
	}
	// 825B2628: 7D3F4B78  mr r31, r9
	ctx.r[31].u64 = ctx.r[9].u64;
	// 825B262C: 48000038  b 0x825b2664
	pc = 0x825B2664; continue 'dispatch;
            }
            0x825B2630 => {
    //   block [0x825B2630..0x825B2658)
	// 825B2630: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B2634: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2638: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B263C: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B2640: C00B00A0  lfs f0, 0xa0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B2644: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B2648: C1AA00A0  lfs f13, 0xa0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825B264C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 825B2650: 40990008  ble cr6, 0x825b2658
	if !ctx.cr[6].gt {
	pc = 0x825B2658; continue 'dispatch;
	}
	// 825B2654: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825B2658; continue 'dispatch;
            }
            0x825B2658 => {
    //   block [0x825B2658..0x825B2660)
	// 825B2658: 557F063E  clrlwi r31, r11, 0x18
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B265C: 48000008  b 0x825b2664
	pc = 0x825B2664; continue 'dispatch;
            }
            0x825B2660 => {
    //   block [0x825B2660..0x825B2664)
	// 825B2660: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	pc = 0x825B2664; continue 'dispatch;
            }
            0x825B2664 => {
    //   block [0x825B2664..0x825B26B8)
	// 825B2664: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B2668: 48000FE1  bl 0x825b3648
	ctx.lr = 0x825B266C;
	sub_825B3648(ctx, base);
	// 825B266C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825B2670: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2674: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825B2678: 93410078  stw r26, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[26].u32 ) };
	// 825B267C: 48000FCD  bl 0x825b3648
	ctx.lr = 0x825B2680;
	sub_825B3648(ctx, base);
	// 825B2680: 3B600010  li r27, 0x10
	ctx.r[27].s64 = 16;
	// 825B2684: 7C6F1B78  mr r15, r3
	ctx.r[15].u64 = ctx.r[3].u64;
	// 825B2688: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 825B268C: 61648010  ori r4, r11, 0x8010
	ctx.r[4].u64 = ctx.r[11].u64 | 32784;
	// 825B2690: 7C79D82E  lwzx r3, r25, r27
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 825B2694: 91E1007C  stw r15, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[15].u32 ) };
	// 825B2698: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 825B269C: 8123002C  lwz r9, 0x2c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 825B26A0: 7D4B2214  add r10, r11, r4
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 825B26A4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B26A8: 41990010  bgt cr6, 0x825b26b8
	if ctx.cr[6].gt {
	pc = 0x825B26B8; continue 'dispatch;
	}
	// 825B26AC: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825B26B0: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 825B26B4: 48000018  b 0x825b26cc
	pc = 0x825B26CC; continue 'dispatch;
            }
            0x825B26B8 => {
    //   block [0x825B26B8..0x825B26CC)
	// 825B26B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B26BC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B26C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B26C4: 4E800421  bctrl
	ctx.lr = 0x825B26C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B26C8: 90610064  stw r3, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
            }
            0x825B26CC => {
    //   block [0x825B26CC..0x825B270C)
	// 825B26CC: 7FCBE838  and r11, r30, r29
	ctx.r[11].u64 = ctx.r[30].u64 & ctx.r[29].u64;
	// 825B26D0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B26D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B26D8: 409A05B8  bne cr6, 0x825b2c90
	if !ctx.cr[6].eq {
	pc = 0x825B2C90; continue 'dispatch;
	}
	// 825B26DC: 7D59C02E  lwzx r10, r25, r24
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 825B26E0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B26E4: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B26E8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B26EC: 40980020  bge cr6, 0x825b270c
	if !ctx.cr[6].lt {
	pc = 0x825B270C; continue 'dispatch;
	}
	// 825B26F0: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825B26F4: 3929A128  addi r9, r9, -0x5ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -24280;
	// 825B26F8: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B26FC: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 825B2700: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 825B2704: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B2708: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x825B270C; continue 'dispatch;
            }
            0x825B270C => {
    //   block [0x825B270C..0x825B2734)
	// 825B270C: 7C79D82E  lwzx r3, r25, r27
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 825B2710: 3D600002  lis r11, 2
	ctx.r[11].s64 = 131072;
	// 825B2714: 61640090  ori r4, r11, 0x90
	ctx.r[4].u64 = ctx.r[11].u64 | 144;
	// 825B2718: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 825B271C: 8123002C  lwz r9, 0x2c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 825B2720: 7D4B2214  add r10, r11, r4
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 825B2724: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B2728: 4199000C  bgt cr6, 0x825b2734
	if ctx.cr[6].gt {
	pc = 0x825B2734; continue 'dispatch;
	}
	// 825B272C: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 825B2730: 48000018  b 0x825b2748
	pc = 0x825B2748; continue 'dispatch;
            }
            0x825B2734 => {
    //   block [0x825B2734..0x825B2748)
	// 825B2734: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B2738: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B273C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B2740: 4E800421  bctrl
	ctx.lr = 0x825B2744;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B2744: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
            }
            0x825B2748 => {
    //   block [0x825B2748..0x825B2774)
	// 825B2748: 7C79D82E  lwzx r3, r25, r27
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 825B274C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825B2750: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825B2754: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 825B2758: 8123002C  lwz r9, 0x2c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 825B275C: 394B4010  addi r10, r11, 0x4010
	ctx.r[10].s64 = ctx.r[11].s64 + 16400;
	// 825B2760: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B2764: 41990010  bgt cr6, 0x825b2774
	if ctx.cr[6].gt {
	pc = 0x825B2774; continue 'dispatch;
	}
	// 825B2768: 7D725B78  mr r18, r11
	ctx.r[18].u64 = ctx.r[11].u64;
	// 825B276C: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 825B2770: 4800001C  b 0x825b278c
	pc = 0x825B278C; continue 'dispatch;
            }
            0x825B2774 => {
    //   block [0x825B2774..0x825B278C)
	// 825B2774: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B2778: 38804010  li r4, 0x4010
	ctx.r[4].s64 = 16400;
	// 825B277C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B2780: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B2784: 4E800421  bctrl
	ctx.lr = 0x825B2788;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B2788: 7C721B78  mr r18, r3
	ctx.r[18].u64 = ctx.r[3].u64;
            }
            0x825B278C => {
    //   block [0x825B278C..0x825B27DC)
	// 825B278C: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 825B2790: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B2794: 419A0048  beq cr6, 0x825b27dc
	if ctx.cr[6].eq {
	pc = 0x825B27DC; continue 'dispatch;
	}
	// 825B2798: 389C0010  addi r4, r28, 0x10
	ctx.r[4].s64 = ctx.r[28].s64 + 16;
	// 825B279C: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 825B27A0: 4BFF6879  bl 0x825a9018
	ctx.lr = 0x825B27A4;
	sub_825A9018(ctx, base);
	// 825B27A4: 39401000  li r10, 0x1000
	ctx.r[10].s64 = 4096;
	// 825B27A8: 7E499378  mr r9, r18
	ctx.r[9].u64 = ctx.r[18].u64;
	// 825B27AC: 80FC0008  lwz r7, 8(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B27B0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825B27B4: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B27B8: 38DC0060  addi r6, r28, 0x60
	ctx.r[6].s64 = ctx.r[28].s64 + 96;
	// 825B27BC: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B27C0: 38A100F0  addi r5, r1, 0xf0
	ctx.r[5].s64 = ctx.r[1].s64 + 240;
	// 825B27C4: 48000EBD  bl 0x825b3680
	ctx.lr = 0x825B27C8;
	sub_825B3680(ctx, base);
	// 825B27C8: 7DF37B78  mr r19, r15
	ctx.r[19].u64 = ctx.r[15].u64;
	// 825B27CC: 811C0004  lwz r8, 4(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B27D0: 7F4FD378  mr r15, r26
	ctx.r[15].u64 = ctx.r[26].u64;
	// 825B27D4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B27D8: 48000054  b 0x825b282c
	pc = 0x825B282C; continue 'dispatch;
            }
            0x825B27DC => {
    //   block [0x825B27DC..0x825B282C)
	// 825B27DC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825B27E0: 80FC0008  lwz r7, 8(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B27E4: 38C00060  li r6, 0x60
	ctx.r[6].s64 = 96;
	// 825B27E8: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B27EC: 396B08F0  addi r11, r11, 0x8f0
	ctx.r[11].s64 = ctx.r[11].s64 + 2288;
	// 825B27F0: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B27F4: 39401000  li r10, 0x1000
	ctx.r[10].s64 = 4096;
	// 825B27F8: 7E499378  mr r9, r18
	ctx.r[9].u64 = ctx.r[18].u64;
	// 825B27FC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	pc = 0x825B282C; continue 'dispatch;
            }
            0x825B282C => {
    //   block [0x825B282C..0x825B2C90)
	// 825B282C: 7D59C02E  lwzx r10, r25, r24
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 825B2830: 7C6E1B78  mr r14, r3
	ctx.r[14].u64 = ctx.r[3].u64;
	// 825B2834: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 825B2838: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 825B283C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2840: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B2844: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B2848: 40980020  bge cr6, 0x825b2868
	if !ctx.cr[6].lt {
	pc = 0x825B2868; continue 'dispatch;
	}
	// 825B284C: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825B2850: 3929A114  addi r9, r9, -0x5eec
	ctx.r[9].s64 = ctx.r[9].s64 + -24300;
	// 825B2854: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B2858: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 825B285C: 38EB000C  addi r7, r11, 0xc
	ctx.r[7].s64 = ctx.r[11].s64 + 12;
	// 825B2860: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B2864: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 825B2868: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B286C: 816B0060  lwz r11, 0x60(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 825B2870: 820B0010  lwz r16, 0x10(r11)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825B2874: 2F100000  cmpwi cr6, r16, 0
	ctx.cr[6].compare_i32(ctx.r[16].s32, 0, &mut ctx.xer);
	// 825B2878: 419A0030  beq cr6, 0x825b28a8
	if ctx.cr[6].eq {
	pc = 0x825B28A8; continue 'dispatch;
	}
	// 825B287C: 8168000C  lwz r11, 0xc(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B2880: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 825B2884: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B2888: 419A0014  beq cr6, 0x825b289c
	if ctx.cr[6].eq {
	pc = 0x825B289C; continue 'dispatch;
	}
	// 825B288C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B2890: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B2894: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B2898: 409AFFF4  bne cr6, 0x825b288c
	if !ctx.cr[6].eq {
	pc = 0x825B288C; continue 'dispatch;
	}
	// 825B289C: 38810130  addi r4, r1, 0x130
	ctx.r[4].s64 = ctx.r[1].s64 + 304;
	// 825B28A0: 806A0008  lwz r3, 8(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B28A4: 4BF4E69D  bl 0x82500f40
	ctx.lr = 0x825B28A8;
	sub_82500F40(ctx, base);
	// 825B28A8: 2F0E0000  cmpwi cr6, r14, 0
	ctx.cr[6].compare_i32(ctx.r[14].s32, 0, &mut ctx.xer);
	// 825B28AC: 40990330  ble cr6, 0x825b2bdc
	if !ctx.cr[6].gt {
	pc = 0x825B2BDC; continue 'dispatch;
	}
	// 825B28B0: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825B28B4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 825B28B8: 7E5E9378  mr r30, r18
	ctx.r[30].u64 = ctx.r[18].u64;
	// 825B28BC: 3BEB0018  addi r31, r11, 0x18
	ctx.r[31].s64 = ctx.r[11].s64 + 24;
	// 825B28C0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825B28C4: 7DDA7378  mr r26, r14
	ctx.r[26].u64 = ctx.r[14].u64;
	// 825B28C8: 3B2B9F50  addi r25, r11, -0x60b0
	ctx.r[25].s64 = ctx.r[11].s64 + -24752;
	// 825B28CC: C3EABFFC  lfs f31, -0x4004(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825B28D0: 3D608283  lis r11, -0x7d7d
	ctx.r[11].s64 = -2105344000;
	// 825B28D4: 3B600020  li r27, 0x20
	ctx.r[27].s64 = 32;
	// 825B28D8: 3B0B26E0  addi r24, r11, 0x26e0
	ctx.r[24].s64 = ctx.r[11].s64 + 9952;
	// 825B28DC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825B28E0: 3AA0FFF0  li r21, -0x10
	ctx.r[21].s64 = -16;
	// 825B28E4: 3A8B9F60  addi r20, r11, -0x60a0
	ctx.r[20].s64 = ctx.r[11].s64 + -24736;
	// 825B28E8: 3AC00010  li r22, 0x10
	ctx.r[22].s64 = 16;
	// 825B28EC: 3A200090  li r17, 0x90
	ctx.r[17].s64 = 144;
	// 825B28F0: 3AE00030  li r23, 0x30
	ctx.r[23].s64 = 48;
	// 825B28F4: 81730000  lwz r11, 0(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B28F8: 38A102D0  addi r5, r1, 0x2d0
	ctx.r[5].s64 = ctx.r[1].s64 + 720;
	// 825B28FC: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B2900: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 825B2904: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825B2908: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B290C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B2910: 4E800421  bctrl
	ctx.lr = 0x825B2914;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B2914: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B2918: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B291C: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 825B2920: C02B0004  lfs f1, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825B2924: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B2928: 808A0008  lwz r4, 8(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B292C: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 825B2930: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B2934: 4E800421  bctrl
	ctx.lr = 0x825B2938;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B2938: 2F100000  cmpwi cr6, r16, 0
	ctx.cr[6].compare_i32(ctx.r[16].s32, 0, &mut ctx.xer);
	// 825B293C: 419A01A4  beq cr6, 0x825b2ae0
	if ctx.cr[6].eq {
	pc = 0x825B2AE0; continue 'dispatch;
	}
	// 825B2940: 396100B0  addi r11, r1, 0xb0
	ctx.r[11].s64 = ctx.r[1].s64 + 176;
	// 825B2944: D3E10070  stfs f31, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 825B2948: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
            }
            0x825B2C90 => {
    //   block [0x825B2C90..0x825B30AC)
	// 825B2C90: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B2C94: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825B2C98: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2C9C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B2CA0: 4E800421  bctrl
	ctx.lr = 0x825B2CA4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B2CA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B2CA8: 7D79D82E  lwzx r11, r25, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 825B2CAC: 57EA2834  slwi r10, r31, 5
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825B2CB0: 394A0090  addi r10, r10, 0x90
	ctx.r[10].s64 = ctx.r[10].s64 + 144;
	// 825B2CB4: 80CB0020  lwz r6, 0x20(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 825B2CB8: 55440036  rlwinm r4, r10, 0, 0, 0x1b
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 825B2CBC: 812B002C  lwz r9, 0x2c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 825B2CC0: 7D462214  add r10, r6, r4
	ctx.r[10].u64 = ctx.r[6].u64 + ctx.r[4].u64;
	// 825B2CC4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B2CC8: 4199000C  bgt cr6, 0x825b2cd4
	if ctx.cr[6].gt {
	pc = 0x825B2CD4; continue 'dispatch;
	}
	// 825B2CCC: 914B0020  stw r10, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 825B2CD0: 4800001C  b 0x825b2cec
	pc = 0x825B2CEC; continue 'dispatch;
	// 825B2CD4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B2CD8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825B2CDC: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B2CE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B2CE4: 4E800421  bctrl
	ctx.lr = 0x825B2CE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B2CE8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825B2CEC: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 825B2CF0: 80BC0008  lwz r5, 8(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B2CF4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825B2CF8: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B2CFC: 90C10054  stw r6, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[6].u32 ) };
	// 825B2D00: 4BFFF199  bl 0x825b1e98
	ctx.lr = 0x825B2D04;
	sub_825B1E98(ctx, base);
	// 825B2D04: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B2D08: 7C6E1B78  mr r14, r3
	ctx.r[14].u64 = ctx.r[3].u64;
	// 825B2D0C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825B2D10: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2D14: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 825B2D18: 2F0E0000  cmpwi cr6, r14, 0
	ctx.cr[6].compare_i32(ctx.r[14].s32, 0, &mut ctx.xer);
	// 825B2D1C: 419A0084  beq cr6, 0x825b2da0
	if ctx.cr[6].eq {
	pc = 0x825B2DA0; continue 'dispatch;
	}
	// 825B2D20: 816F0000  lwz r11, 0(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B2D24: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 825B2D28: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2D2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B2D30: 4E800421  bctrl
	ctx.lr = 0x825B2D34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B2D34: 82E1005C  lwz r23, 0x5c(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825B2D38: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 825B2D3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B2D40: 7C77582E  lwzx r3, r23, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[23].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825B2D44: 57EB2834  slwi r11, r31, 5
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B2D48: 396B0090  addi r11, r11, 0x90
	ctx.r[11].s64 = ctx.r[11].s64 + 144;
	// 825B2D4C: 55640036  rlwinm r4, r11, 0, 0, 0x1b
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B2D50: 80C30020  lwz r6, 0x20(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 825B2D54: 8143002C  lwz r10, 0x2c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 825B2D58: 7D662214  add r11, r6, r4
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[4].u64;
	// 825B2D5C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B2D60: 4199000C  bgt cr6, 0x825b2d6c
	if ctx.cr[6].gt {
	pc = 0x825B2D6C; continue 'dispatch;
	}
	// 825B2D64: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 825B2D68: 48000018  b 0x825b2d80
	pc = 0x825B2D80; continue 'dispatch;
	// 825B2D6C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B2D70: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B2D74: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B2D78: 4E800421  bctrl
	ctx.lr = 0x825B2D7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B2D7C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825B2D80: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 825B2D84: 80BC0008  lwz r5, 8(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B2D88: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 825B2D8C: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825B2D90: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 825B2D94: 4BFFF105  bl 0x825b1e98
	ctx.lr = 0x825B2D98;
	sub_825B1E98(ctx, base);
	// 825B2D98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B2D9C: 48000050  b 0x825b2dec
	pc = 0x825B2DEC; continue 'dispatch;
	// 825B2DA0: 82E1005C  lwz r23, 0x5c(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825B2DA4: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 825B2DA8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825B2DAC: 7D77582E  lwzx r11, r23, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[23].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825B2DB0: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 825B2DB4: 810B002C  lwz r8, 0x2c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 825B2DB8: 392A0090  addi r9, r10, 0x90
	ctx.r[9].s64 = ctx.r[10].s64 + 144;
	// 825B2DBC: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825B2DC0: 4199000C  bgt cr6, 0x825b2dcc
	if ctx.cr[6].gt {
	pc = 0x825B2DCC; continue 'dispatch;
	}
	// 825B2DC4: 912B0020  stw r9, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 825B2DC8: 48000020  b 0x825b2de8
	pc = 0x825B2DE8; continue 'dispatch;
	// 825B2DCC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B2DD0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825B2DD4: 38800090  li r4, 0x90
	ctx.r[4].s64 = 144;
	// 825B2DD8: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B2DDC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B2DE0: 4E800421  bctrl
	ctx.lr = 0x825B2DE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B2DE4: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 825B2DE8: 7D5E5378  mr r30, r10
	ctx.r[30].u64 = ctx.r[10].u64;
	// 825B2DEC: 396E0004  addi r11, r14, 4
	ctx.r[11].s64 = ctx.r[14].s64 + 4;
	// 825B2DF0: 83410054  lwz r26, 0x54(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B2DF4: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 825B2DF8: 7F0E5800  cmpw cr6, r14, r11
	ctx.cr[6].compare_i32(ctx.r[14].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825B2DFC: 40980024  bge cr6, 0x825b2e20
	if !ctx.cr[6].lt {
	pc = 0x825B2E20; continue 'dispatch;
	}
	// 825B2E00: 55CA2834  slwi r10, r14, 5
	ctx.r[10].u32 = ctx.r[14].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825B2E04: 7D6E5850  subf r11, r14, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[14].s64;
	// 825B2E08: 7D4AD214  add r10, r10, r26
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 825B2E0C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B2E10: 93AA0000  stw r29, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825B2E14: 394A0020  addi r10, r10, 0x20
	ctx.r[10].s64 = ctx.r[10].s64 + 32;
	// 825B2E18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B2E1C: 409AFFF0  bne cr6, 0x825b2e0c
	if !ctx.cr[6].eq {
	pc = 0x825B2E0C; continue 'dispatch;
	}
	// 825B2E20: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825B2E24: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825B2E28: 40980024  bge cr6, 0x825b2e4c
	if !ctx.cr[6].lt {
	pc = 0x825B2E4C; continue 'dispatch;
	}
	// 825B2E2C: 57EA2834  slwi r10, r31, 5
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825B2E30: 7D7F5850  subf r11, r31, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 825B2E34: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 825B2E38: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B2E3C: 93AA0000  stw r29, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825B2E40: 394A0020  addi r10, r10, 0x20
	ctx.r[10].s64 = ctx.r[10].s64 + 32;
	// 825B2E44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B2E48: 409AFFF0  bne cr6, 0x825b2e38
	if !ctx.cr[6].eq {
	pc = 0x825B2E38; continue 'dispatch;
	}
	// 825B2E4C: 3B000014  li r24, 0x14
	ctx.r[24].s64 = 20;
	// 825B2E50: 7D57C02E  lwzx r10, r23, r24
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[23].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 825B2E54: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2E58: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B2E5C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B2E60: 40980020  bge cr6, 0x825b2e80
	if !ctx.cr[6].lt {
	pc = 0x825B2E80; continue 'dispatch;
	}
	// 825B2E64: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825B2E68: 3929A0F8  addi r9, r9, -0x5f08
	ctx.r[9].s64 = ctx.r[9].s64 + -24328;
	// 825B2E6C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B2E70: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 825B2E74: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 825B2E78: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B2E7C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 825B2E80: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 825B2E84: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B2E88: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B2E8C: 39210054  addi r9, r1, 0x54
	ctx.r[9].s64 = ctx.r[1].s64 + 84;
	// 825B2E90: 83610064  lwz r27, 0x64(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825B2E94: 39000FFF  li r8, 0xfff
	ctx.r[8].s64 = 4095;
	// 825B2E98: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B2E9C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 825B2EA0: 92C10054  stw r22, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[22].u32 ) };
	// 825B2EA4: 409A0018  bne cr6, 0x825b2ebc
	if !ctx.cr[6].eq {
	pc = 0x825B2EBC; continue 'dispatch;
	}
	// 825B2EA8: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 825B2EAC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825B2EB0: 7DC47378  mr r4, r14
	ctx.r[4].u64 = ctx.r[14].u64;
	// 825B2EB4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825B2EB8: 48000014  b 0x825b2ecc
	pc = 0x825B2ECC; continue 'dispatch;
	// 825B2EBC: 7DC67378  mr r6, r14
	ctx.r[6].u64 = ctx.r[14].u64;
	// 825B2EC0: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 825B2EC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B2EC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B2ECC: 480267ED  bl 0x825d96b8
	ctx.lr = 0x825B2ED0;
	sub_825D96B8(ctx, base);
	// 825B2ED0: 3B200010  li r25, 0x10
	ctx.r[25].s64 = 16;
	// 825B2ED4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B2ED8: 7C77C82E  lwzx r3, r23, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[23].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 825B2EDC: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 825B2EE0: 93C30020  stw r30, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 825B2EE4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B2EE8: 409A0018  bne cr6, 0x825b2f00
	if !ctx.cr[6].eq {
	pc = 0x825B2F00; continue 'dispatch;
	}
	// 825B2EEC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B2EF0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B2EF4: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 825B2EF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B2EFC: 4E800421  bctrl
	ctx.lr = 0x825B2F00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B2F00: 7C77C82E  lwzx r3, r23, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[23].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 825B2F04: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 825B2F08: 93430020  stw r26, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[26].u32 ) };
	// 825B2F0C: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B2F10: 409A0018  bne cr6, 0x825b2f28
	if !ctx.cr[6].eq {
	pc = 0x825B2F28; continue 'dispatch;
	}
	// 825B2F14: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B2F18: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825B2F1C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 825B2F20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B2F24: 4E800421  bctrl
	ctx.lr = 0x825B2F28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B2F28: 7D57C02E  lwzx r10, r23, r24
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[23].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 825B2F2C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2F30: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B2F34: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B2F38: 40980020  bge cr6, 0x825b2f58
	if !ctx.cr[6].lt {
	pc = 0x825B2F58; continue 'dispatch;
	}
	// 825B2F3C: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825B2F40: 3929A0EC  addi r9, r9, -0x5f14
	ctx.r[9].s64 = ctx.r[9].s64 + -24340;
	// 825B2F44: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B2F48: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 825B2F4C: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 825B2F50: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B2F54: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 825B2F58: 7D57C02E  lwzx r10, r23, r24
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[23].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 825B2F5C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2F60: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B2F64: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B2F68: 40980030  bge cr6, 0x825b2f98
	if !ctx.cr[6].lt {
	pc = 0x825B2F98; continue 'dispatch;
	}
	// 825B2F6C: 7FE807B4  extsw r8, r31
	ctx.r[8].s64 = ctx.r[31].s32 as i64;
	// 825B2F70: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825B2F74: 3929A0E0  addi r9, r9, -0x5f20
	ctx.r[9].s64 = ctx.r[9].s64 + -24352;
	// 825B2F78: F9010070  std r8, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[8].u64 ) };
	// 825B2F7C: C8010070  lfd f0, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 825B2F80: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 825B2F84: 390B0008  addi r8, r11, 8
	ctx.r[8].s64 = ctx.r[11].s64 + 8;
	// 825B2F88: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B2F8C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 825B2F90: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 825B2F94: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 825B2F98: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825B2F9C: 2F1F0001  cmpwi cr6, r31, 1
	ctx.cr[6].compare_i32(ctx.r[31].s32, 1, &mut ctx.xer);
	// 825B2FA0: 9ACB0000  stb r22, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[22].u8 ) };
	// 825B2FA4: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B2FA8: 40990014  ble cr6, 0x825b2fbc
	if !ctx.cr[6].gt {
	pc = 0x825B2FBC; continue 'dispatch;
	}
	// 825B2FAC: 38BFFFFF  addi r5, r31, -1
	ctx.r[5].s64 = ctx.r[31].s64 + -1;
	// 825B2FB0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825B2FB4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B2FB8: 48000469  bl 0x825b3420
	ctx.lr = 0x825B2FBC;
	sub_825B3420(ctx, base);
	// 825B2FBC: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B2FC0: 395F0001  addi r10, r31, 1
	ctx.r[10].s64 = ctx.r[31].s64 + 1;
	// 825B2FC4: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 825B2FC8: 2F0A1000  cmpwi cr6, r10, 0x1000
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4096, &mut ctx.xer);
	// 825B2FCC: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825B2FD0: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 825B2FD4: 40980018  bge cr6, 0x825b2fec
	if !ctx.cr[6].lt {
	pc = 0x825B2FEC; continue 'dispatch;
	}
	// 825B2FD8: 396A0002  addi r11, r10, 2
	ctx.r[11].s64 = ctx.r[10].s64 + 2;
	// 825B2FDC: 7D57C82E  lwzx r10, r23, r25
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[23].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 825B2FE0: 556B1836  rlwinm r11, r11, 3, 0, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 825B2FE4: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 825B2FE8: 916A0020  stw r11, 0x20(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 825B2FEC: 7D77C02E  lwzx r11, r23, r24
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[23].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 825B2FF0: 815C0054  lwz r10, 0x54(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B2FF4: 83E10594  lwz r31, 0x594(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1428 as u32) ) } as u64;
	// 825B2FF8: 7C8AFA14  add r4, r10, r31
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 825B2FFC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B3000: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B3004: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B3008: 40980020  bge cr6, 0x825b3028
	if !ctx.cr[6].lt {
	pc = 0x825B3028; continue 'dispatch;
	}
	// 825B300C: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 825B3010: 39294BFC  addi r9, r9, 0x4bfc
	ctx.r[9].s64 = ctx.r[9].s64 + 19452;
	// 825B3014: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B3018: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 825B301C: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 825B3020: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B3024: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 825B3028: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 825B302C: 812105A4  lwz r9, 0x5a4(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 825B3030: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825B3034: 80E1007C  lwz r7, 0x7c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825B3038: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B303C: 80C10078  lwz r6, 0x78(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 825B3040: 4800CD79  bl 0x825bfdb8
	ctx.lr = 0x825B3044;
	sub_825BFDB8(ctx, base);
	// 825B3044: 7C77C82E  lwzx r3, r23, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[23].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 825B3048: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 825B304C: 93630020  stw r27, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[27].u32 ) };
	// 825B3050: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B3054: 409A0018  bne cr6, 0x825b306c
	if !ctx.cr[6].eq {
	pc = 0x825B306C; continue 'dispatch;
	}
	// 825B3058: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B305C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825B3060: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 825B3064: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B3068: 4E800421  bctrl
	ctx.lr = 0x825B306C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B306C: 7D57C02E  lwzx r10, r23, r24
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[23].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 825B3070: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B3074: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B3078: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B307C: 40980020  bge cr6, 0x825b309c
	if !ctx.cr[6].lt {
	pc = 0x825B309C; continue 'dispatch;
	}
	// 825B3080: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 825B3084: 3929FE14  addi r9, r9, -0x1ec
	ctx.r[9].s64 = ctx.r[9].s64 + -492;
	// 825B3088: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B308C: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 825B3090: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 825B3094: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B3098: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 825B309C: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 825B30A0: 38210570  addi r1, r1, 0x570
	ctx.r[1].s64 = ctx.r[1].s64 + 1392;
	// 825B30A4: CBE1FF60  lfd f31, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 825B30A8: 4BF82028  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B30B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B30B0 size=120
    let mut pc: u32 = 0x825B30B0;
    'dispatch: loop {
        match pc {
            0x825B30B0 => {
    //   block [0x825B30B0..0x825B3128)
	// 825B30B0: 3D60825B  lis r11, -0x7da5
	ctx.r[11].s64 = -2107965440;
	// 825B30B4: 3CA0825B  lis r5, -0x7da5
	ctx.r[5].s64 = -2107965440;
	// 825B30B8: 388B2468  addi r4, r11, 0x2468
	ctx.r[4].s64 = ctx.r[11].s64 + 9320;
	// 825B30BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B30C0: 3CC0825B  lis r6, -0x7da5
	ctx.r[6].s64 = -2107965440;
	// 825B30C4: 3CE0825B  lis r7, -0x7da5
	ctx.r[7].s64 = -2107965440;
	// 825B30C8: 3D00825B  lis r8, -0x7da5
	ctx.r[8].s64 = -2107965440;
	// 825B30CC: 3D20825B  lis r9, -0x7da5
	ctx.r[9].s64 = -2107965440;
	// 825B30D0: 9083002C  stw r4, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[4].u32 ) };
	// 825B30D4: 3D40825B  lis r10, -0x7da5
	ctx.r[10].s64 = -2107965440;
	// 825B30D8: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 825B30DC: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825B30E0: 38A53FB8  addi r5, r5, 0x3fb8
	ctx.r[5].s64 = ctx.r[5].s64 + 16312;
	// 825B30E4: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 825B30E8: 38C61A08  addi r6, r6, 0x1a08
	ctx.r[6].s64 = ctx.r[6].s64 + 6664;
	// 825B30EC: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 825B30F0: 38E71A90  addi r7, r7, 0x1a90
	ctx.r[7].s64 = ctx.r[7].s64 + 6800;
	// 825B30F4: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 825B30F8: 39081AF0  addi r8, r8, 0x1af0
	ctx.r[8].s64 = ctx.r[8].s64 + 6896;
	// 825B30FC: 39291B00  addi r9, r9, 0x1b00
	ctx.r[9].s64 = ctx.r[9].s64 + 6912;
	// 825B3100: 394A3D30  addi r10, r10, 0x3d30
	ctx.r[10].s64 = ctx.r[10].s64 + 15664;
	// 825B3104: 90A30000  stw r5, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 825B3108: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B310C: 90C30018  stw r6, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[6].u32 ) };
	// 825B3110: 90E3001C  stw r7, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[7].u32 ) };
	// 825B3114: 91030020  stw r8, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[8].u32 ) };
	// 825B3118: 91230024  stw r9, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[9].u32 ) };
	// 825B311C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825B3120: 99630030  stb r11, 0x30(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[11].u8 ) };
	// 825B3124: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B3128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B3128 size=236
    let mut pc: u32 = 0x825B3128;
    'dispatch: loop {
        match pc {
            0x825B3128 => {
    //   block [0x825B3128..0x825B3214)
	// 825B3128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B312C: 4BF81F8D  bl 0x825350b8
	ctx.lr = 0x825B3130;
	sub_82535080(ctx, base);
	// 825B3130: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B3134: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B3138: 3FC0825B  lis r30, -0x7da5
	ctx.r[30].s64 = -2107965440;
	// 825B313C: 3CE0825B  lis r7, -0x7da5
	ctx.r[7].s64 = -2107965440;
	// 825B3140: 3D00825B  lis r8, -0x7da5
	ctx.r[8].s64 = -2107965440;
	// 825B3144: 3D20825B  lis r9, -0x7da5
	ctx.r[9].s64 = -2107965440;
	// 825B3148: 99610081  stb r11, 0x81(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(129 as u32), ctx.r[11].u8 ) };
	// 825B314C: 3D40825B  lis r10, -0x7da5
	ctx.r[10].s64 = -2107965440;
	// 825B3150: 99610082  stb r11, 0x82(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(130 as u32), ctx.r[11].u8 ) };
	// 825B3154: 3F80825B  lis r28, -0x7da5
	ctx.r[28].s64 = -2107965440;
	// 825B3158: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 825B315C: 3FA0825B  lis r29, -0x7da5
	ctx.r[29].s64 = -2107965440;
	// 825B3160: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825B3164: 3B9C3FB8  addi r28, r28, 0x3fb8
	ctx.r[28].s64 = ctx.r[28].s64 + 16312;
	// 825B3168: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825B316C: 3BBD2468  addi r29, r29, 0x2468
	ctx.r[29].s64 = ctx.r[29].s64 + 9320;
	// 825B3170: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825B3174: 38C00009  li r6, 9
	ctx.r[6].s64 = 9;
	// 825B3178: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825B317C: 397E1A08  addi r11, r30, 0x1a08
	ctx.r[11].s64 = ctx.r[30].s64 + 6664;
	// 825B3180: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 825B3184: 38A00009  li r5, 9
	ctx.r[5].s64 = 9;
	// 825B3188: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825B318C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B3190: 93A1007C  stw r29, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[29].u32 ) };
	// 825B3194: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B3198: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 825B319C: 39671A90  addi r11, r7, 0x1a90
	ctx.r[11].s64 = ctx.r[7].s64 + 6800;
	// 825B31A0: 9BC10080  stb r30, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u8 ) };
	// 825B31A4: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 825B31A8: 39681AF0  addi r11, r8, 0x1af0
	ctx.r[11].s64 = ctx.r[8].s64 + 6896;
	// 825B31AC: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 825B31B0: 39691B00  addi r11, r9, 0x1b00
	ctx.r[11].s64 = ctx.r[9].s64 + 6912;
	// 825B31B4: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 825B31B8: 396A3D30  addi r11, r10, 0x3d30
	ctx.r[11].s64 = ctx.r[10].s64 + 15664;
	// 825B31BC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825B31C0: 4BF4CDA9  bl 0x824fff68
	ctx.lr = 0x825B31C4;
	sub_824FFF68(ctx, base);
	// 825B31C4: 38C00009  li r6, 9
	ctx.r[6].s64 = 9;
	// 825B31C8: 9BC10081  stb r30, 0x81(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(129 as u32), ctx.r[30].u8 ) };
	// 825B31CC: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 825B31D0: 9BC10082  stb r30, 0x82(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(130 as u32), ctx.r[30].u8 ) };
	// 825B31D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B31D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B31DC: 4BF4CD8D  bl 0x824fff68
	ctx.lr = 0x825B31E0;
	sub_824FFF68(ctx, base);
	// 825B31E0: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 825B31E4: 38A00009  li r5, 9
	ctx.r[5].s64 = 9;
	// 825B31E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B31EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B31F0: 4BF4CD79  bl 0x824fff68
	ctx.lr = 0x825B31F4;
	sub_824FFF68(ctx, base);
	// 825B31F4: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 825B31F8: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 825B31FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B3200: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B3204: 4BF4CD65  bl 0x824fff68
	ctx.lr = 0x825B3208;
	sub_824FFF68(ctx, base);
	// 825B3208: 9BDF1E22  stb r30, 0x1e22(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(7714 as u32), ctx.r[30].u8 ) };
	// 825B320C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825B3210: 4BF81EF8  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B3218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B3218 size=516
    let mut pc: u32 = 0x825B3218;
    'dispatch: loop {
        match pc {
            0x825B3218 => {
    //   block [0x825B3218..0x825B3230)
	// 825B3218: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B321C: 4BF81E89  bl 0x825350a4
	ctx.lr = 0x825B3220;
	sub_82535080(ctx, base);
	// 825B3220: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B3224: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B3228: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825B322C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	pc = 0x825B3230; continue 'dispatch;
            }
            0x825B3230 => {
    //   block [0x825B3230..0x825B3260)
	// 825B3230: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 825B3234: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825B3238: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825B323C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B3240: 7D64E214  add r11, r4, r28
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[28].u64;
	// 825B3244: 39210078  addi r9, r1, 0x78
	ctx.r[9].s64 = ctx.r[1].s64 + 120;
	// 825B3248: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B324C: 556A2834  slwi r10, r11, 5
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825B3250: 7D6AF214  add r11, r10, r30
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 825B3254: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825B3258: 7D5E5050  subf r10, r30, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[30].s64;
	// 825B325C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	pc = 0x825B3260; continue 'dispatch;
            }
            0x825B3260 => {
    //   block [0x825B3260..0x825B3290)
	// 825B3260: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B3264: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B3268: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B326C: 80CB000C  lwz r6, 0xc(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B3270: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 825B3274: 912AFFF8  stw r9, -8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8 as u32), ctx.r[9].u32 ) };
	// 825B3278: 910AFFFC  stw r8, -4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), ctx.r[8].u32 ) };
	// 825B327C: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 825B3280: 90CA0004  stw r6, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 825B3284: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 825B3288: 4200FFD8  bdnz 0x825b3260
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825B3260; continue 'dispatch;
	}
	// 825B328C: 83A10070  lwz r29, 0x70(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	pc = 0x825B3290; continue 'dispatch;
            }
            0x825B3290 => {
    //   block [0x825B3290..0x825B32A4)
	// 825B3290: 57EB2834  slwi r11, r31, 5
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B3294: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 825B3298: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B329C: 7F0AE840  cmplw cr6, r10, r29
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[29].u32, &mut ctx.xer);
	// 825B32A0: 40980018  bge cr6, 0x825b32b8
	if !ctx.cr[6].lt {
	pc = 0x825B32B8; continue 'dispatch;
	}
	pc = 0x825B32A4; continue 'dispatch;
            }
            0x825B32A4 => {
    //   block [0x825B32A4..0x825B32B8)
	// 825B32A4: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 825B32A8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825B32AC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B32B0: 7F0AE840  cmplw cr6, r10, r29
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[29].u32, &mut ctx.xer);
	// 825B32B4: 4198FFF0  blt cr6, 0x825b32a4
	if ctx.cr[6].lt {
	pc = 0x825B32A4; continue 'dispatch;
	}
	pc = 0x825B32B8; continue 'dispatch;
            }
            0x825B32B8 => {
    //   block [0x825B32B8..0x825B32CC)
	// 825B32B8: 54AB2834  slwi r11, r5, 5
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B32BC: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 825B32C0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B32C4: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B32C8: 40980018  bge cr6, 0x825b32e0
	if !ctx.cr[6].lt {
	pc = 0x825B32E0; continue 'dispatch;
	}
	pc = 0x825B32CC; continue 'dispatch;
            }
            0x825B32CC => {
    //   block [0x825B32CC..0x825B32E0)
	// 825B32CC: 396BFFE0  addi r11, r11, -0x20
	ctx.r[11].s64 = ctx.r[11].s64 + -32;
	// 825B32D0: 38A5FFFF  addi r5, r5, -1
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	// 825B32D4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B32D8: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B32DC: 4198FFF0  blt cr6, 0x825b32cc
	if ctx.cr[6].lt {
	pc = 0x825B32CC; continue 'dispatch;
	}
	pc = 0x825B32E0; continue 'dispatch;
            }
            0x825B32E0 => {
    //   block [0x825B32E0..0x825B3314)
	// 825B32E0: 7F05F800  cmpw cr6, r5, r31
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[31].s32, &mut ctx.xer);
	// 825B32E4: 4198010C  blt cr6, 0x825b33f0
	if ctx.cr[6].lt {
	pc = 0x825B33F0; continue 'dispatch;
	}
	// 825B32E8: 419A00F8  beq cr6, 0x825b33e0
	if ctx.cr[6].eq {
	pc = 0x825B33E0; continue 'dispatch;
	}
	// 825B32EC: 54AA2834  slwi r10, r5, 5
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825B32F0: 57EB2834  slwi r11, r31, 5
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B32F4: 7D2AF214  add r9, r10, r30
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 825B32F8: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 825B32FC: 38C90008  addi r6, r9, 8
	ctx.r[6].s64 = ctx.r[9].s64 + 8;
	// 825B3300: 7CEBF214  add r7, r11, r30
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 825B3304: 7C6A4850  subf r3, r10, r9
	ctx.r[3].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 825B3308: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 825B330C: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 825B3310: 7CCA3378  mr r10, r6
	ctx.r[10].u64 = ctx.r[6].u64;
	pc = 0x825B3314; continue 'dispatch;
            }
            0x825B3314 => {
    //   block [0x825B3314..0x825B3358)
	// 825B3314: 7F43582E  lwzx r26, r3, r11
	ctx.r[26].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825B3318: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 825B331C: 832AFFFC  lwz r25, -4(r10)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) } as u64;
	// 825B3320: 830A0000  lwz r24, 0(r10)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B3324: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 825B3328: 82EA0004  lwz r23, 4(r10)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B332C: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 825B3330: 934BFFF8  stw r26, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[26].u32 ) };
	// 825B3334: 932BFFFC  stw r25, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[25].u32 ) };
	// 825B3338: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 825B333C: 92EB0004  stw r23, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[23].u32 ) };
	// 825B3340: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 825B3344: 4199FFD0  bgt cr6, 0x825b3314
	if ctx.cr[6].gt {
	pc = 0x825B3314; continue 'dispatch;
	}
	// 825B3348: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 825B334C: 3947000C  addi r10, r7, 0xc
	ctx.r[10].s64 = ctx.r[7].s64 + 12;
	// 825B3350: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825B3354: 7D293850  subf r9, r9, r7
	ctx.r[9].s64 = ctx.r[7].s64 - ctx.r[9].s64;
	pc = 0x825B3358; continue 'dispatch;
            }
            0x825B3358 => {
    //   block [0x825B3358..0x825B33AC)
	// 825B3358: 80CAFFF4  lwz r6, -0xc(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) } as u64;
	// 825B335C: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 825B3360: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 825B3364: 90CBFFF8  stw r6, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[6].u32 ) };
	// 825B3368: 80CAFFF8  lwz r6, -8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B336C: 90CBFFFC  stw r6, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[6].u32 ) };
	// 825B3370: 7CC9582E  lwzx r6, r9, r11
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825B3374: 90CB0000  stw r6, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 825B3378: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B337C: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 825B3380: 90CB0004  stw r6, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 825B3384: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 825B3388: 4199FFD0  bgt cr6, 0x825b3358
	if ctx.cr[6].gt {
	pc = 0x825B3358; continue 'dispatch;
	}
	// 825B338C: 7D0700D0  neg r8, r7
	ctx.r[8].s64 = -ctx.r[7].s64;
	// 825B3390: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B3394: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 825B3398: 39670008  addi r11, r7, 8
	ctx.r[11].s64 = ctx.r[7].s64 + 8;
	// 825B339C: 7CE81A14  add r7, r8, r3
	ctx.r[7].u64 = ctx.r[8].u64 + ctx.r[3].u64;
	// 825B33A0: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 825B33A4: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825B33A8: 7D083214  add r8, r8, r6
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[6].u64;
	pc = 0x825B33AC; continue 'dispatch;
            }
            0x825B33AC => {
    //   block [0x825B33AC..0x825B33E0)
	// 825B33AC: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B33B0: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 825B33B4: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B33B8: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 825B33BC: 7F47582E  lwzx r26, r7, r11
	ctx.r[26].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825B33C0: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825B33C4: 7F28582E  lwzx r25, r8, r11
	ctx.r[25].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825B33C8: 90CBFFF8  stw r6, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[6].u32 ) };
	// 825B33CC: 906BFFFC  stw r3, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[3].u32 ) };
	// 825B33D0: 934B0000  stw r26, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 825B33D4: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 825B33D8: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 825B33DC: 4199FFD0  bgt cr6, 0x825b33ac
	if ctx.cr[6].gt {
	pc = 0x825B33AC; continue 'dispatch;
	}
	pc = 0x825B33E0; continue 'dispatch;
            }
            0x825B33E0 => {
    //   block [0x825B33E0..0x825B33F0)
	// 825B33E0: 38A5FFFF  addi r5, r5, -1
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	// 825B33E4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825B33E8: 7F1F2800  cmpw cr6, r31, r5
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[5].s32, &mut ctx.xer);
	// 825B33EC: 4099FEA4  ble cr6, 0x825b3290
	if !ctx.cr[6].gt {
	pc = 0x825B3290; continue 'dispatch;
	}
	pc = 0x825B33F0; continue 'dispatch;
            }
            0x825B33F0 => {
    //   block [0x825B33F0..0x825B3404)
	// 825B33F0: 7F042800  cmpw cr6, r4, r5
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[5].s32, &mut ctx.xer);
	// 825B33F4: 40980010  bge cr6, 0x825b3404
	if !ctx.cr[6].lt {
	pc = 0x825B3404; continue 'dispatch;
	}
	// 825B33F8: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 825B33FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B3400: 4BFFFE19  bl 0x825b3218
	ctx.lr = 0x825B3404;
	sub_825B3218(ctx, base);
	pc = 0x825B3404; continue 'dispatch;
            }
            0x825B3404 => {
    //   block [0x825B3404..0x825B3414)
	// 825B3404: 7F1FE000  cmpw cr6, r31, r28
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[28].s32, &mut ctx.xer);
	// 825B3408: 4098000C  bge cr6, 0x825b3414
	if !ctx.cr[6].lt {
	pc = 0x825B3414; continue 'dispatch;
	}
	// 825B340C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B3410: 4BFFFE20  b 0x825b3230
	pc = 0x825B3230; continue 'dispatch;
            }
            0x825B3414 => {
    //   block [0x825B3414..0x825B341C)
	// 825B3414: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825B3418: 4BF81CDC  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B3420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B3420 size=316
    let mut pc: u32 = 0x825B3420;
    'dispatch: loop {
        match pc {
            0x825B3420 => {
    //   block [0x825B3420..0x825B3438)
	// 825B3420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B3424: 4BF81C95  bl 0x825350b8
	ctx.lr = 0x825B3428;
	sub_82535080(ctx, base);
	// 825B3428: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B342C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B3430: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825B3434: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	pc = 0x825B3438; continue 'dispatch;
            }
            0x825B3438 => {
    //   block [0x825B3438..0x825B345C)
	// 825B3438: 7D64EA14  add r11, r4, r29
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[29].u64;
	// 825B343C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825B3440: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B3444: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825B3448: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B344C: 7D6BF02A  ldx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	// 825B3450: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825B3454: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B3458: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x825B345C; continue 'dispatch;
            }
            0x825B345C => {
    //   block [0x825B345C..0x825B3464)
	// 825B345C: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B3460: 7D4BF214  add r10, r11, r30
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	pc = 0x825B3464; continue 'dispatch;
            }
            0x825B3464 => {
    //   block [0x825B3464..0x825B3480)
	// 825B3464: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B3468: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825B346C: 4198001C  blt cr6, 0x825b3488
	if ctx.cr[6].lt {
	pc = 0x825B3488; continue 'dispatch;
	}
	// 825B3470: 409A0010  bne cr6, 0x825b3480
	if !ctx.cr[6].eq {
	pc = 0x825B3480; continue 'dispatch;
	}
	// 825B3474: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B3478: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825B347C: 4198000C  blt cr6, 0x825b3488
	if ctx.cr[6].lt {
	pc = 0x825B3488; continue 'dispatch;
	}
	pc = 0x825B3480; continue 'dispatch;
            }
            0x825B3480 => {
    //   block [0x825B3480..0x825B3488)
	// 825B3480: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B3484: 48000008  b 0x825b348c
	pc = 0x825B348C; continue 'dispatch;
            }
            0x825B3488 => {
    //   block [0x825B3488..0x825B348C)
	// 825B3488: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x825B348C; continue 'dispatch;
            }
            0x825B348C => {
    //   block [0x825B348C..0x825B34A4)
	// 825B348C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 825B3490: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B3494: 419A0010  beq cr6, 0x825b34a4
	if ctx.cr[6].eq {
	pc = 0x825B34A4; continue 'dispatch;
	}
	// 825B3498: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825B349C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B34A0: 4BFFFFC4  b 0x825b3464
	pc = 0x825B3464; continue 'dispatch;
            }
            0x825B34A4 => {
    //   block [0x825B34A4..0x825B34AC)
	// 825B34A4: 54AB1838  slwi r11, r5, 3
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B34A8: 7D4BF214  add r10, r11, r30
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	pc = 0x825B34AC; continue 'dispatch;
            }
            0x825B34AC => {
    //   block [0x825B34AC..0x825B34C8)
	// 825B34AC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B34B0: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B34B4: 4198001C  blt cr6, 0x825b34d0
	if ctx.cr[6].lt {
	pc = 0x825B34D0; continue 'dispatch;
	}
	// 825B34B8: 409A0010  bne cr6, 0x825b34c8
	if !ctx.cr[6].eq {
	pc = 0x825B34C8; continue 'dispatch;
	}
	// 825B34BC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B34C0: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B34C4: 4198000C  blt cr6, 0x825b34d0
	if ctx.cr[6].lt {
	pc = 0x825B34D0; continue 'dispatch;
	}
	pc = 0x825B34C8; continue 'dispatch;
            }
            0x825B34C8 => {
    //   block [0x825B34C8..0x825B34D0)
	// 825B34C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B34CC: 48000008  b 0x825b34d4
	pc = 0x825B34D4; continue 'dispatch;
            }
            0x825B34D0 => {
    //   block [0x825B34D0..0x825B34D4)
	// 825B34D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x825B34D4; continue 'dispatch;
            }
            0x825B34D4 => {
    //   block [0x825B34D4..0x825B34EC)
	// 825B34D4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 825B34D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B34DC: 419A0010  beq cr6, 0x825b34ec
	if ctx.cr[6].eq {
	pc = 0x825B34EC; continue 'dispatch;
	}
	// 825B34E0: 38A5FFFF  addi r5, r5, -1
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	// 825B34E4: 394AFFF8  addi r10, r10, -8
	ctx.r[10].s64 = ctx.r[10].s64 + -8;
	// 825B34E8: 4BFFFFC4  b 0x825b34ac
	pc = 0x825B34AC; continue 'dispatch;
            }
            0x825B34EC => {
    //   block [0x825B34EC..0x825B3520)
	// 825B34EC: 7F05F800  cmpw cr6, r5, r31
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[31].s32, &mut ctx.xer);
	// 825B34F0: 41980040  blt cr6, 0x825b3530
	if ctx.cr[6].lt {
	pc = 0x825B3530; continue 'dispatch;
	}
	// 825B34F4: 419A002C  beq cr6, 0x825b3520
	if ctx.cr[6].eq {
	pc = 0x825B3520; continue 'dispatch;
	}
	// 825B34F8: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B34FC: 54AA1838  slwi r10, r5, 3
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825B3500: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 825B3504: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 825B3508: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B350C: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 825B3510: 90CA0000  stw r6, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 825B3514: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B3518: 90CA0004  stw r6, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 825B351C: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	pc = 0x825B3520; continue 'dispatch;
            }
            0x825B3520 => {
    //   block [0x825B3520..0x825B3530)
	// 825B3520: 38A5FFFF  addi r5, r5, -1
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	// 825B3524: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825B3528: 7F1F2800  cmpw cr6, r31, r5
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[5].s32, &mut ctx.xer);
	// 825B352C: 4099FF30  ble cr6, 0x825b345c
	if !ctx.cr[6].gt {
	pc = 0x825B345C; continue 'dispatch;
	}
	pc = 0x825B3530; continue 'dispatch;
            }
            0x825B3530 => {
    //   block [0x825B3530..0x825B3544)
	// 825B3530: 7F042800  cmpw cr6, r4, r5
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[5].s32, &mut ctx.xer);
	// 825B3534: 40980010  bge cr6, 0x825b3544
	if !ctx.cr[6].lt {
	pc = 0x825B3544; continue 'dispatch;
	}
	// 825B3538: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825B353C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B3540: 4BFFFEE1  bl 0x825b3420
	ctx.lr = 0x825B3544;
	sub_825B3420(ctx, base);
	pc = 0x825B3544; continue 'dispatch;
            }
            0x825B3544 => {
    //   block [0x825B3544..0x825B3554)
	// 825B3544: 7F1FE800  cmpw cr6, r31, r29
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[29].s32, &mut ctx.xer);
	// 825B3548: 4098000C  bge cr6, 0x825b3554
	if !ctx.cr[6].lt {
	pc = 0x825B3554; continue 'dispatch;
	}
	// 825B354C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B3550: 4BFFFEE8  b 0x825b3438
	pc = 0x825B3438; continue 'dispatch;
            }
            0x825B3554 => {
    //   block [0x825B3554..0x825B355C)
	// 825B3554: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825B3558: 4BF81BB0  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B3560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B3560 size=96
    let mut pc: u32 = 0x825B3560;
    'dispatch: loop {
        match pc {
            0x825B3560 => {
    //   block [0x825B3560..0x825B35C0)
	// 825B3560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B3564: 4BF81B59  bl 0x825350bc
	ctx.lr = 0x825B3568;
	sub_82535080(ctx, base);
	// 825B3568: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B356C: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 825B3570: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825B3574: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B3578: 388BA140  addi r4, r11, -0x5ec0
	ctx.r[4].s64 = ctx.r[11].s64 + -24256;
	// 825B357C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825B3580: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B3584: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B3588: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 825B358C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B3590: 4E800421  bctrl
	ctx.lr = 0x825B3594;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B3594: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B3598: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825B359C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B35A0: 4BF23071  bl 0x824d6610
	ctx.lr = 0x825B35A4;
	sub_824D6610(ctx, base);
	// 825B35A4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B35A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B35AC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B35B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B35B4: 4E800421  bctrl
	ctx.lr = 0x825B35B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B35B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B35BC: 4BF81B50  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B35E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B35E0 size=104
    let mut pc: u32 = 0x825B35E0;
    'dispatch: loop {
        match pc {
            0x825B35E0 => {
    //   block [0x825B35E0..0x825B3648)
	// 825B35E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B35E4: 4BF81ACD  bl 0x825350b0
	ctx.lr = 0x825B35E8;
	sub_82535080(ctx, base);
	// 825B35E8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B35EC: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 825B35F0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B35F4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825B35F8: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 825B35FC: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 825B3600: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B3604: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	// 825B3608: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B360C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B3610: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B3614: 4E800421  bctrl
	ctx.lr = 0x825B3618;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B3618: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825B361C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B3620: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 825B3624: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B3628: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 825B362C: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 825B3630: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 825B3634: 93410068  stw r26, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[26].u32 ) };
	// 825B3638: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825B363C: 4800B4F5  bl 0x825beb30
	ctx.lr = 0x825B3640;
	sub_825BEB30(ctx, base);
	// 825B3640: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825B3644: 4BF81ABC  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B3648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B3648 size=20
    let mut pc: u32 = 0x825B3648;
    'dispatch: loop {
        match pc {
            0x825B3648 => {
    //   block [0x825B3648..0x825B365C)
	// 825B3648: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B364C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B3650: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B3654: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B3658: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B3660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B3660 size=28
    let mut pc: u32 = 0x825B3660;
    'dispatch: loop {
        match pc {
            0x825B3660 => {
    //   block [0x825B3660..0x825B367C)
	// 825B3660: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B3664: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825B3668: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B366C: 2F0A000B  cmpwi cr6, r10, 0xb
	ctx.cr[6].compare_i32(ctx.r[10].s32, 11, &mut ctx.xer);
	// 825B3670: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 825B3674: 806B0034  lwz r3, 0x34(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 825B3678: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B3680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B3680 size=1004
    let mut pc: u32 = 0x825B3680;
    'dispatch: loop {
        match pc {
            0x825B3680 => {
    //   block [0x825B3680..0x825B3A6C)
	// 825B3680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B3684: 4BF81A19  bl 0x8253509c
	ctx.lr = 0x825B3688;
	sub_82535080(ctx, base);
	// 825B3688: DBC1FF90  stfd f30, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[30].u64 ) };
	// 825B368C: DBE1FF98  stfd f31, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 825B3690: 3980FF80  li r12, -0x80
	ctx.r[12].s64 = -128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B3A70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B3A70 size=424
    let mut pc: u32 = 0x825B3A70;
    'dispatch: loop {
        match pc {
            0x825B3A70 => {
    //   block [0x825B3A70..0x825B3ACC)
	// 825B3A70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B3A74: 4BF81635  bl 0x825350a8
	ctx.lr = 0x825B3A78;
	sub_82535080(ctx, base);
	// 825B3A78: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B3A7C: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B3A80: 3B800014  li r28, 0x14
	ctx.r[28].s64 = 20;
	// 825B3A84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B3A88: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 825B3A8C: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 825B3A90: 7D5EE02E  lwzx r10, r30, r28
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 825B3A94: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B3A98: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B3A9C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B3AA0: 4098002C  bge cr6, 0x825b3acc
	if !ctx.cr[6].lt {
	pc = 0x825B3ACC; continue 'dispatch;
	}
	// 825B3AA4: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 825B3AA8: 3D008206  lis r8, -0x7dfa
	ctx.r[8].s64 = -2113536000;
	// 825B3AAC: 39294C14  addi r9, r9, 0x4c14
	ctx.r[9].s64 = ctx.r[9].s64 + 19476;
	// 825B3AB0: 39084C08  addi r8, r8, 0x4c08
	ctx.r[8].s64 = ctx.r[8].s64 + 19464;
	// 825B3AB4: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B3AB8: 910B000C  stw r8, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 825B3ABC: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 825B3AC0: 390B0010  addi r8, r11, 0x10
	ctx.r[8].s64 = ctx.r[11].s64 + 16;
	// 825B3AC4: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B3AC8: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x825B3ACC; continue 'dispatch;
            }
            0x825B3ACC => {
    //   block [0x825B3ACC..0x825B3AF0)
	// 825B3ACC: 3B000010  li r24, 0x10
	ctx.r[24].s64 = 16;
	// 825B3AD0: 7C7EC02E  lwzx r3, r30, r24
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 825B3AD4: 83A30020  lwz r29, 0x20(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 825B3AD8: 8143002C  lwz r10, 0x2c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 825B3ADC: 397D4010  addi r11, r29, 0x4010
	ctx.r[11].s64 = ctx.r[29].s64 + 16400;
	// 825B3AE0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B3AE4: 4199000C  bgt cr6, 0x825b3af0
	if ctx.cr[6].gt {
	pc = 0x825B3AF0; continue 'dispatch;
	}
	// 825B3AE8: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 825B3AEC: 4800001C  b 0x825b3b08
	pc = 0x825B3B08; continue 'dispatch;
            }
            0x825B3AF0 => {
    //   block [0x825B3AF0..0x825B3B08)
	// 825B3AF0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B3AF4: 38804010  li r4, 0x4010
	ctx.r[4].s64 = 16400;
	// 825B3AF8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B3AFC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B3B00: 4E800421  bctrl
	ctx.lr = 0x825B3B04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B3B04: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
            }
            0x825B3B08 => {
    //   block [0x825B3B08..0x825B3B88)
	// 825B3B08: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 825B3B0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B3B10: 4BFF5509  bl 0x825a9018
	ctx.lr = 0x825B3B14;
	sub_825A9018(ctx, base);
	// 825B3B14: 39401000  li r10, 0x1000
	ctx.r[10].s64 = 4096;
	// 825B3B18: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 825B3B1C: 80FF0008  lwz r7, 8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B3B20: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825B3B24: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B3B28: 38DF0060  addi r6, r31, 0x60
	ctx.r[6].s64 = ctx.r[31].s64 + 96;
	// 825B3B2C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B3B30: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825B3B34: 4BFFFB4D  bl 0x825b3680
	ctx.lr = 0x825B3B38;
	sub_825B3680(ctx, base);
	// 825B3B38: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B3B3C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825B3B40: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B3B44: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B3B48: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B3B4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B3B50: 4E800421  bctrl
	ctx.lr = 0x825B3B54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B3B54: 7D7EE02E  lwzx r11, r30, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 825B3B58: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825B3B5C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B3B60: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B3B64: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B3B68: 40980020  bge cr6, 0x825b3b88
	if !ctx.cr[6].lt {
	pc = 0x825B3B88; continue 'dispatch;
	}
	// 825B3B6C: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 825B3B70: 39294BFC  addi r9, r9, 0x4bfc
	ctx.r[9].s64 = ctx.r[9].s64 + 19452;
	// 825B3B74: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B3B78: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 825B3B7C: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 825B3B80: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B3B84: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x825B3B88 => {
    //   block [0x825B3B88..0x825B3B98)
	// 825B3B88: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 825B3B8C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 825B3B90: 40980008  bge cr6, 0x825b3b98
	if !ctx.cr[6].lt {
	pc = 0x825B3B98; continue 'dispatch;
	}
	// 825B3B94: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x825B3B98; continue 'dispatch;
            }
            0x825B3B98 => {
    //   block [0x825B3B98..0x825B3BE0)
	// 825B3B98: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B3B9C: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 825B3BA0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B3BA4: 7C8BD214  add r4, r11, r26
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 825B3BA8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825B3BAC: 4800B36D  bl 0x825bef18
	ctx.lr = 0x825B3BB0;
	sub_825BEF18(ctx, base);
	// 825B3BB0: 7D7EE02E  lwzx r11, r30, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 825B3BB4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B3BB8: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B3BBC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B3BC0: 40980020  bge cr6, 0x825b3be0
	if !ctx.cr[6].lt {
	pc = 0x825B3BE0; continue 'dispatch;
	}
	// 825B3BC4: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 825B3BC8: 3929FE14  addi r9, r9, -0x1ec
	ctx.r[9].s64 = ctx.r[9].s64 + -492;
	// 825B3BCC: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B3BD0: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 825B3BD4: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 825B3BD8: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B3BDC: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x825B3BE0; continue 'dispatch;
            }
            0x825B3BE0 => {
    //   block [0x825B3BE0..0x825B3C0C)
	// 825B3BE0: 7C7EC02E  lwzx r3, r30, r24
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 825B3BE4: 3BFA0010  addi r31, r26, 0x10
	ctx.r[31].s64 = ctx.r[26].s64 + 16;
	// 825B3BE8: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 825B3BEC: 93A30020  stw r29, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[29].u32 ) };
	// 825B3BF0: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B3BF4: 409A0018  bne cr6, 0x825b3c0c
	if !ctx.cr[6].eq {
	pc = 0x825B3C0C; continue 'dispatch;
	}
	// 825B3BF8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B3BFC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825B3C00: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 825B3C04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B3C08: 4E800421  bctrl
	ctx.lr = 0x825B3C0C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x825B3C0C => {
    //   block [0x825B3C0C..0x825B3C18)
	// 825B3C0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B3C10: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825B3C14: 4BF814E4  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B3C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B3C18 size=120
    let mut pc: u32 = 0x825B3C18;
    'dispatch: loop {
        match pc {
            0x825B3C18 => {
    //   block [0x825B3C18..0x825B3C90)
	// 825B3C18: 3D60825B  lis r11, -0x7da5
	ctx.r[11].s64 = -2107965440;
	// 825B3C1C: 3CA0825B  lis r5, -0x7da5
	ctx.r[5].s64 = -2107965440;
	// 825B3C20: 388B3A70  addi r4, r11, 0x3a70
	ctx.r[4].s64 = ctx.r[11].s64 + 14960;
	// 825B3C24: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B3C28: 3CC0825B  lis r6, -0x7da5
	ctx.r[6].s64 = -2107965440;
	// 825B3C2C: 3CE0825B  lis r7, -0x7da5
	ctx.r[7].s64 = -2107965440;
	// 825B3C30: 3D00825B  lis r8, -0x7da5
	ctx.r[8].s64 = -2107965440;
	// 825B3C34: 3D20825B  lis r9, -0x7da5
	ctx.r[9].s64 = -2107965440;
	// 825B3C38: 9083002C  stw r4, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[4].u32 ) };
	// 825B3C3C: 3D40825B  lis r10, -0x7da5
	ctx.r[10].s64 = -2107965440;
	// 825B3C40: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 825B3C44: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825B3C48: 38A53FB8  addi r5, r5, 0x3fb8
	ctx.r[5].s64 = ctx.r[5].s64 + 16312;
	// 825B3C4C: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 825B3C50: 38C635E0  addi r6, r6, 0x35e0
	ctx.r[6].s64 = ctx.r[6].s64 + 13792;
	// 825B3C54: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 825B3C58: 38E73560  addi r7, r7, 0x3560
	ctx.r[7].s64 = ctx.r[7].s64 + 13664;
	// 825B3C5C: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 825B3C60: 390835C0  addi r8, r8, 0x35c0
	ctx.r[8].s64 = ctx.r[8].s64 + 13760;
	// 825B3C64: 392935D0  addi r9, r9, 0x35d0
	ctx.r[9].s64 = ctx.r[9].s64 + 13776;
	// 825B3C68: 394A3D30  addi r10, r10, 0x3d30
	ctx.r[10].s64 = ctx.r[10].s64 + 15664;
	// 825B3C6C: 90A30000  stw r5, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 825B3C70: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B3C74: 90C30018  stw r6, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[6].u32 ) };
	// 825B3C78: 90E3001C  stw r7, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[7].u32 ) };
	// 825B3C7C: 91030020  stw r8, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[8].u32 ) };
	// 825B3C80: 91230024  stw r9, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[9].u32 ) };
	// 825B3C84: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825B3C88: 99630030  stb r11, 0x30(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[11].u8 ) };
	// 825B3C8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B3C90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B3C90 size=160
    let mut pc: u32 = 0x825B3C90;
    'dispatch: loop {
        match pc {
            0x825B3C90 => {
    //   block [0x825B3C90..0x825B3D30)
	// 825B3C90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B3C94: 4BF81429  bl 0x825350bc
	ctx.lr = 0x825B3C98;
	sub_82535080(ctx, base);
	// 825B3C98: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B3C9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B3CA0: 3FE0825B  lis r31, -0x7da5
	ctx.r[31].s64 = -2107965440;
	// 825B3CA4: 3CE0825B  lis r7, -0x7da5
	ctx.r[7].s64 = -2107965440;
	// 825B3CA8: 3D00825B  lis r8, -0x7da5
	ctx.r[8].s64 = -2107965440;
	// 825B3CAC: 3D20825B  lis r9, -0x7da5
	ctx.r[9].s64 = -2107965440;
	// 825B3CB0: 99610081  stb r11, 0x81(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(129 as u32), ctx.r[11].u8 ) };
	// 825B3CB4: 3D40825B  lis r10, -0x7da5
	ctx.r[10].s64 = -2107965440;
	// 825B3CB8: 99610082  stb r11, 0x82(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(130 as u32), ctx.r[11].u8 ) };
	// 825B3CBC: 3FA0825B  lis r29, -0x7da5
	ctx.r[29].s64 = -2107965440;
	// 825B3CC0: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 825B3CC4: 3FC0825B  lis r30, -0x7da5
	ctx.r[30].s64 = -2107965440;
	// 825B3CC8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825B3CCC: 3BBD3FB8  addi r29, r29, 0x3fb8
	ctx.r[29].s64 = ctx.r[29].s64 + 16312;
	// 825B3CD0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825B3CD4: 3BDE3A70  addi r30, r30, 0x3a70
	ctx.r[30].s64 = ctx.r[30].s64 + 14960;
	// 825B3CD8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825B3CDC: 38C00009  li r6, 9
	ctx.r[6].s64 = 9;
	// 825B3CE0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825B3CE4: 397F35E0  addi r11, r31, 0x35e0
	ctx.r[11].s64 = ctx.r[31].s64 + 13792;
	// 825B3CE8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825B3CEC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B3CF0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 825B3CF4: 93C1007C  stw r30, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 825B3CF8: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 825B3CFC: 39673560  addi r11, r7, 0x3560
	ctx.r[11].s64 = ctx.r[7].s64 + 13664;
	// 825B3D00: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 825B3D04: 396835C0  addi r11, r8, 0x35c0
	ctx.r[11].s64 = ctx.r[8].s64 + 13760;
	// 825B3D08: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 825B3D0C: 396935D0  addi r11, r9, 0x35d0
	ctx.r[11].s64 = ctx.r[9].s64 + 13776;
	// 825B3D10: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 825B3D14: 396A3D30  addi r11, r10, 0x3d30
	ctx.r[11].s64 = ctx.r[10].s64 + 15664;
	// 825B3D18: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825B3D1C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B3D20: 99610080  stb r11, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u8 ) };
	// 825B3D24: 4BF4C245  bl 0x824fff68
	ctx.lr = 0x825B3D28;
	sub_824FFF68(ctx, base);
	// 825B3D28: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825B3D2C: 4BF813E0  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B3D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B3D40 size=96
    let mut pc: u32 = 0x825B3D40;
    'dispatch: loop {
        match pc {
            0x825B3D40 => {
    //   block [0x825B3D40..0x825B3DA0)
	// 825B3D40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B3D44: 4BF81379  bl 0x825350bc
	ctx.lr = 0x825B3D48;
	sub_82535080(ctx, base);
	// 825B3D48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B3D4C: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 825B3D50: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825B3D54: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B3D58: 388BA150  addi r4, r11, -0x5eb0
	ctx.r[4].s64 = ctx.r[11].s64 + -24240;
	// 825B3D5C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825B3D60: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B3D64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B3D68: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 825B3D6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B3D70: 4E800421  bctrl
	ctx.lr = 0x825B3D74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B3D74: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B3D78: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825B3D7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B3D80: 4BF22891  bl 0x824d6610
	ctx.lr = 0x825B3D84;
	sub_824D6610(ctx, base);
	// 825B3D84: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B3D88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B3D8C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B3D90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B3D94: 4E800421  bctrl
	ctx.lr = 0x825B3D98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B3D98: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B3D9C: 4BF81370  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B3DC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B3DC0 size=104
    let mut pc: u32 = 0x825B3DC0;
    'dispatch: loop {
        match pc {
            0x825B3DC0 => {
    //   block [0x825B3DC0..0x825B3E28)
	// 825B3DC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B3DC4: 4BF812ED  bl 0x825350b0
	ctx.lr = 0x825B3DC8;
	sub_82535080(ctx, base);
	// 825B3DC8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B3DCC: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 825B3DD0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B3DD4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825B3DD8: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 825B3DDC: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 825B3DE0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B3DE4: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	// 825B3DE8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B3DEC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B3DF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B3DF4: 4E800421  bctrl
	ctx.lr = 0x825B3DF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B3DF8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825B3DFC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B3E00: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 825B3E04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B3E08: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 825B3E0C: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 825B3E10: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 825B3E14: 93410068  stw r26, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[26].u32 ) };
	// 825B3E18: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825B3E1C: 4800AD15  bl 0x825beb30
	ctx.lr = 0x825B3E20;
	sub_825BEB30(ctx, base);
	// 825B3E20: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825B3E24: 4BF812DC  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B3E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B3E28 size=400
    let mut pc: u32 = 0x825B3E28;
    'dispatch: loop {
        match pc {
            0x825B3E28 => {
    //   block [0x825B3E28..0x825B3E78)
	// 825B3E28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B3E2C: 4BF81279  bl 0x825350a4
	ctx.lr = 0x825B3E30;
	sub_82535080(ctx, base);
	// 825B3E30: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B3E34: 836D0000  lwz r27, 0(r13)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B3E38: 3B200014  li r25, 0x14
	ctx.r[25].s64 = 20;
	// 825B3E3C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825B3E40: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 825B3E44: 7CF73B78  mr r23, r7
	ctx.r[23].u64 = ctx.r[7].u64;
	// 825B3E48: 7D5BC82E  lwzx r10, r27, r25
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 825B3E4C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B3E50: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B3E54: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B3E58: 40980020  bge cr6, 0x825b3e78
	if !ctx.cr[6].lt {
	pc = 0x825B3E78; continue 'dispatch;
	}
	// 825B3E5C: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825B3E60: 3929A160  addi r9, r9, -0x5ea0
	ctx.r[9].s64 = ctx.r[9].s64 + -24224;
	// 825B3E64: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B3E68: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 825B3E6C: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 825B3E70: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B3E74: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x825B3E78; continue 'dispatch;
            }
            0x825B3E78 => {
    //   block [0x825B3E78..0x825B3EB4)
	// 825B3E78: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B3E7C: 3B000010  li r24, 0x10
	ctx.r[24].s64 = 16;
	// 825B3E80: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B3E84: 7C7BC02E  lwzx r3, r27, r24
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 825B3E88: 839E001C  lwz r28, 0x1c(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 825B3E8C: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 825B3E90: 395C0005  addi r10, r28, 5
	ctx.r[10].s64 = ctx.r[28].s64 + 5;
	// 825B3E94: 8123002C  lwz r9, 0x2c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 825B3E98: 55441036  rlwinm r4, r10, 2, 0, 0x1b
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 825B3E9C: 7D4B2214  add r10, r11, r4
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 825B3EA0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B3EA4: 41990010  bgt cr6, 0x825b3eb4
	if ctx.cr[6].gt {
	pc = 0x825B3EB4; continue 'dispatch;
	}
	// 825B3EA8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825B3EAC: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 825B3EB0: 48000018  b 0x825b3ec8
	pc = 0x825B3EC8; continue 'dispatch;
            }
            0x825B3EB4 => {
    //   block [0x825B3EB4..0x825B3EC8)
	// 825B3EB4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B3EB8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B3EBC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B3EC0: 4E800421  bctrl
	ctx.lr = 0x825B3EC4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B3EC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
            }
            0x825B3EC8 => {
    //   block [0x825B3EC8..0x825B3EE0)
	// 825B3EC8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825B3ECC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B3ED0: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 825B3ED4: 40990050  ble cr6, 0x825b3f24
	if !ctx.cr[6].gt {
	pc = 0x825B3F24; continue 'dispatch;
	}
	// 825B3ED8: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 825B3EDC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	pc = 0x825B3EE0; continue 'dispatch;
            }
            0x825B3EE0 => {
    //   block [0x825B3EE0..0x825B3F0C)
	// 825B3EE0: 2B0B0100  cmplwi cr6, r11, 0x100
	ctx.cr[6].compare_u32(ctx.r[11].u32, 256 as u32, &mut ctx.xer);
	// 825B3EE4: 40980028  bge cr6, 0x825b3f0c
	if !ctx.cr[6].lt {
	pc = 0x825B3F0C; continue 'dispatch;
	}
	// 825B3EE8: 556606FE  clrlwi r6, r11, 0x1b
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 825B3EEC: 556AD97E  srwi r10, r11, 5
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825B3EF0: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 825B3EF4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825B3EF8: 7D4AF02E  lwzx r10, r10, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825B3EFC: 7CE63030  slw r6, r7, r6
	if (ctx.r[6].u8 & 0x20) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = ((ctx.r[7].u32) << ((ctx.r[6].u8 & 0x1F) as u32)) as u64;
	}
	// 825B3F00: 7CCA5038  and r10, r6, r10
	ctx.r[10].u64 = ctx.r[6].u64 & ctx.r[10].u64;
	// 825B3F04: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825B3F08: 419A0010  beq cr6, 0x825b3f18
	if ctx.cr[6].eq {
	pc = 0x825B3F18; continue 'dispatch;
	}
	pc = 0x825B3F0C; continue 'dispatch;
            }
            0x825B3F0C => {
    //   block [0x825B3F0C..0x825B3F18)
	// 825B3F0C: 91680000  stw r11, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825B3F10: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825B3F14: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	pc = 0x825B3F18; continue 'dispatch;
            }
            0x825B3F18 => {
    //   block [0x825B3F18..0x825B3F24)
	// 825B3F18: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825B3F1C: 7F0BE000  cmpw cr6, r11, r28
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[28].s32, &mut ctx.xer);
	// 825B3F20: 4198FFC0  blt cr6, 0x825b3ee0
	if ctx.cr[6].lt {
	pc = 0x825B3EE0; continue 'dispatch;
	}
	pc = 0x825B3F24; continue 'dispatch;
            }
            0x825B3F24 => {
    //   block [0x825B3F24..0x825B3F80)
	// 825B3F24: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B3F28: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 825B3F2C: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 825B3F30: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 825B3F34: 38DE0010  addi r6, r30, 0x10
	ctx.r[6].s64 = ctx.r[30].s64 + 16;
	// 825B3F38: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825B3F3C: 7D4BF92E  stwx r10, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[10].u32) };
	// 825B3F40: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825B3F44: 817D0054  lwz r11, 0x54(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B3F48: 7C8BD214  add r4, r11, r26
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 825B3F4C: 4800AFCD  bl 0x825bef18
	ctx.lr = 0x825B3F50;
	sub_825BEF18(ctx, base);
	// 825B3F50: 7D7BC82E  lwzx r11, r27, r25
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 825B3F54: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B3F58: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B3F5C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B3F60: 40980020  bge cr6, 0x825b3f80
	if !ctx.cr[6].lt {
	pc = 0x825B3F80; continue 'dispatch;
	}
	// 825B3F64: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 825B3F68: 392974DC  addi r9, r9, 0x74dc
	ctx.r[9].s64 = ctx.r[9].s64 + 29916;
	// 825B3F6C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B3F70: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 825B3F74: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 825B3F78: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B3F7C: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x825B3F80; continue 'dispatch;
            }
            0x825B3F80 => {
    //   block [0x825B3F80..0x825B3FAC)
	// 825B3F80: 7C7BC02E  lwzx r3, r27, r24
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 825B3F84: 3BDA0010  addi r30, r26, 0x10
	ctx.r[30].s64 = ctx.r[26].s64 + 16;
	// 825B3F88: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 825B3F8C: 93E30020  stw r31, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[31].u32 ) };
	// 825B3F90: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B3F94: 409A0018  bne cr6, 0x825b3fac
	if !ctx.cr[6].eq {
	pc = 0x825B3FAC; continue 'dispatch;
	}
	// 825B3F98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B3F9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B3FA0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 825B3FA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B3FA8: 4E800421  bctrl
	ctx.lr = 0x825B3FAC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x825B3FAC => {
    //   block [0x825B3FAC..0x825B3FB8)
	// 825B3FAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B3FB0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825B3FB4: 4BF81140  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B3FB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B3FB8 size=80
    let mut pc: u32 = 0x825B3FB8;
    'dispatch: loop {
        match pc {
            0x825B3FB8 => {
    //   block [0x825B3FB8..0x825B3FE8)
	// 825B3FB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B3FBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B3FC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B3FC4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B3FC8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825B3FCC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825B3FD0: 419A0018  beq cr6, 0x825b3fe8
	if ctx.cr[6].eq {
	pc = 0x825B3FE8; continue 'dispatch;
	}
	// 825B3FD4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B3FD8: 3D408000  lis r10, -0x8000
	ctx.r[10].s64 = -2147483648;
	// 825B3FDC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825B3FE0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825B3FE4: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x825B3FE8; continue 'dispatch;
            }
            0x825B3FE8 => {
    //   block [0x825B3FE8..0x825B4008)
	// 825B3FE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B3FEC: 48009CE5  bl 0x825bdcd0
	ctx.lr = 0x825B3FF0;
	sub_825BDCD0(ctx, base);
	// 825B3FF0: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 825B3FF4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825B3FF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B3FFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B4000: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B4004: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B4008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B4008 size=120
    let mut pc: u32 = 0x825B4008;
    'dispatch: loop {
        match pc {
            0x825B4008 => {
    //   block [0x825B4008..0x825B4080)
	// 825B4008: 3D60825B  lis r11, -0x7da5
	ctx.r[11].s64 = -2107965440;
	// 825B400C: 3CA0825B  lis r5, -0x7da5
	ctx.r[5].s64 = -2107965440;
	// 825B4010: 388B3E28  addi r4, r11, 0x3e28
	ctx.r[4].s64 = ctx.r[11].s64 + 15912;
	// 825B4014: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B4018: 3CC0825B  lis r6, -0x7da5
	ctx.r[6].s64 = -2107965440;
	// 825B401C: 3CE0825B  lis r7, -0x7da5
	ctx.r[7].s64 = -2107965440;
	// 825B4020: 3D00825B  lis r8, -0x7da5
	ctx.r[8].s64 = -2107965440;
	// 825B4024: 3D20825B  lis r9, -0x7da5
	ctx.r[9].s64 = -2107965440;
	// 825B4028: 9083002C  stw r4, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[4].u32 ) };
	// 825B402C: 3D40825B  lis r10, -0x7da5
	ctx.r[10].s64 = -2107965440;
	// 825B4030: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 825B4034: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825B4038: 38A53FB8  addi r5, r5, 0x3fb8
	ctx.r[5].s64 = ctx.r[5].s64 + 16312;
	// 825B403C: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 825B4040: 38C63DC0  addi r6, r6, 0x3dc0
	ctx.r[6].s64 = ctx.r[6].s64 + 15808;
	// 825B4044: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 825B4048: 38E73D40  addi r7, r7, 0x3d40
	ctx.r[7].s64 = ctx.r[7].s64 + 15680;
	// 825B404C: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 825B4050: 39083DA0  addi r8, r8, 0x3da0
	ctx.r[8].s64 = ctx.r[8].s64 + 15776;
	// 825B4054: 39293DB0  addi r9, r9, 0x3db0
	ctx.r[9].s64 = ctx.r[9].s64 + 15792;
	// 825B4058: 394A3D30  addi r10, r10, 0x3d30
	ctx.r[10].s64 = ctx.r[10].s64 + 15664;
	// 825B405C: 90A30000  stw r5, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 825B4060: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B4064: 90C30018  stw r6, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[6].u32 ) };
	// 825B4068: 90E3001C  stw r7, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[7].u32 ) };
	// 825B406C: 91030020  stw r8, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[8].u32 ) };
	// 825B4070: 91230024  stw r9, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[9].u32 ) };
	// 825B4074: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825B4078: 99630030  stb r11, 0x30(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[11].u8 ) };
	// 825B407C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B4080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B4080 size=160
    let mut pc: u32 = 0x825B4080;
    'dispatch: loop {
        match pc {
            0x825B4080 => {
    //   block [0x825B4080..0x825B4120)
	// 825B4080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B4084: 4BF81039  bl 0x825350bc
	ctx.lr = 0x825B4088;
	sub_82535080(ctx, base);
	// 825B4088: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B408C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B4090: 3FE0825B  lis r31, -0x7da5
	ctx.r[31].s64 = -2107965440;
	// 825B4094: 3CE0825B  lis r7, -0x7da5
	ctx.r[7].s64 = -2107965440;
	// 825B4098: 3D00825B  lis r8, -0x7da5
	ctx.r[8].s64 = -2107965440;
	// 825B409C: 3D20825B  lis r9, -0x7da5
	ctx.r[9].s64 = -2107965440;
	// 825B40A0: 99610081  stb r11, 0x81(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(129 as u32), ctx.r[11].u8 ) };
	// 825B40A4: 3D40825B  lis r10, -0x7da5
	ctx.r[10].s64 = -2107965440;
	// 825B40A8: 99610082  stb r11, 0x82(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(130 as u32), ctx.r[11].u8 ) };
	// 825B40AC: 3FA0825B  lis r29, -0x7da5
	ctx.r[29].s64 = -2107965440;
	// 825B40B0: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 825B40B4: 3FC0825B  lis r30, -0x7da5
	ctx.r[30].s64 = -2107965440;
	// 825B40B8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825B40BC: 3BBD3FB8  addi r29, r29, 0x3fb8
	ctx.r[29].s64 = ctx.r[29].s64 + 16312;
	// 825B40C0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825B40C4: 3BDE3E28  addi r30, r30, 0x3e28
	ctx.r[30].s64 = ctx.r[30].s64 + 15912;
	// 825B40C8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825B40CC: 38C0000A  li r6, 0xa
	ctx.r[6].s64 = 10;
	// 825B40D0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825B40D4: 397F3DC0  addi r11, r31, 0x3dc0
	ctx.r[11].s64 = ctx.r[31].s64 + 15808;
	// 825B40D8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825B40DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B40E0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 825B40E4: 93C1007C  stw r30, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 825B40E8: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 825B40EC: 39673D40  addi r11, r7, 0x3d40
	ctx.r[11].s64 = ctx.r[7].s64 + 15680;
	// 825B40F0: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 825B40F4: 39683DA0  addi r11, r8, 0x3da0
	ctx.r[11].s64 = ctx.r[8].s64 + 15776;
	// 825B40F8: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 825B40FC: 39693DB0  addi r11, r9, 0x3db0
	ctx.r[11].s64 = ctx.r[9].s64 + 15792;
	// 825B4100: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 825B4104: 396A3D30  addi r11, r10, 0x3d30
	ctx.r[11].s64 = ctx.r[10].s64 + 15664;
	// 825B4108: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825B410C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B4110: 99610080  stb r11, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u8 ) };
	// 825B4114: 4BF4BE55  bl 0x824fff68
	ctx.lr = 0x825B4118;
	sub_824FFF68(ctx, base);
	// 825B4118: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825B411C: 4BF80FF0  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B4120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B4120 size=8
    let mut pc: u32 = 0x825B4120;
    'dispatch: loop {
        match pc {
            0x825B4120 => {
    //   block [0x825B4120..0x825B4128)
	// 825B4120: 38640010  addi r3, r4, 0x10
	ctx.r[3].s64 = ctx.r[4].s64 + 16;
	// 825B4124: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B4128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B4128 size=8
    let mut pc: u32 = 0x825B4128;
    'dispatch: loop {
        match pc {
            0x825B4128 => {
    //   block [0x825B4128..0x825B4130)
	// 825B4128: 38640010  addi r3, r4, 0x10
	ctx.r[3].s64 = ctx.r[4].s64 + 16;
	// 825B412C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B4130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B4130 size=112
    let mut pc: u32 = 0x825B4130;
    'dispatch: loop {
        match pc {
            0x825B4130 => {
    //   block [0x825B4130..0x825B4198)
	// 825B4130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B4134: 4BF80F89  bl 0x825350bc
	ctx.lr = 0x825B4138;
	sub_82535080(ctx, base);
	// 825B4138: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B413C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B4140: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825B4144: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 825B4148: 897E000B  lbz r11, 0xb(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(11 as u32) ) } as u64;
	// 825B414C: 556B06B4  rlwinm r11, r11, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B4150: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B4154: 409A0044  bne cr6, 0x825b4198
	if !ctx.cr[6].eq {
	pc = 0x825B4198; continue 'dispatch;
	}
	// 825B4158: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B415C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825B4160: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B4164: 388BA168  addi r4, r11, -0x5e98
	ctx.r[4].s64 = ctx.r[11].s64 + -24216;
	// 825B4168: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 825B416C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B4170: 4E800421  bctrl
	ctx.lr = 0x825B4174;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B4174: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B4178: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825B417C: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 825B4180: 4BF22491  bl 0x824d6610
	ctx.lr = 0x825B4184;
	sub_824D6610(ctx, base);
	// 825B4184: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4188: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B418C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B4190: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B4194: 4E800421  bctrl
	ctx.lr = 0x825B4198;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x825B4198 => {
    //   block [0x825B4198..0x825B41A0)
	// 825B4198: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B419C: 4BF80F70  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B41A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B41A0 size=32
    let mut pc: u32 = 0x825B41A0;
    'dispatch: loop {
        match pc {
            0x825B41A0 => {
    //   block [0x825B41A0..0x825B41C0)
	// 825B41A0: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 825B41A4: 894B000B  lbz r10, 0xb(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(11 as u32) ) } as u64;
	// 825B41A8: 554A06B4  rlwinm r10, r10, 0, 0x1a, 0x1a
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 825B41AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B41B0: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 825B41B4: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 825B41B8: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 825B41BC: 48009564  b 0x825bd720
	sub_825BD720(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B41C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B41C0 size=4
    let mut pc: u32 = 0x825B41C0;
    'dispatch: loop {
        match pc {
            0x825B41C0 => {
    //   block [0x825B41C0..0x825B41C4)
	// 825B41C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B41C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B41C8 size=28
    let mut pc: u32 = 0x825B41C8;
    'dispatch: loop {
        match pc {
            0x825B41C8 => {
    //   block [0x825B41C8..0x825B41E4)
	// 825B41C8: 8964000B  lbz r11, 0xb(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(11 as u32) ) } as u64;
	// 825B41CC: 556B06B4  rlwinm r11, r11, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B41D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B41D4: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 825B41D8: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 825B41DC: 38640010  addi r3, r4, 0x10
	ctx.r[3].s64 = ctx.r[4].s64 + 16;
	// 825B41E0: 48009690  b 0x825bd870
	sub_825BD870(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B41E4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B41E4 size=4
    let mut pc: u32 = 0x825B41E4;
    'dispatch: loop {
        match pc {
            0x825B41E4 => {
    //   block [0x825B41E4..0x825B41E8)
	// 825B41E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B41E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B41E8 size=60
    let mut pc: u32 = 0x825B41E8;
    'dispatch: loop {
        match pc {
            0x825B41E8 => {
    //   block [0x825B41E8..0x825B4224)
	// 825B41E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B41EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B41F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B41F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B41F8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825B41FC: 48001885  bl 0x825b5a80
	ctx.lr = 0x825B4200;
	sub_825B5A80(ctx, base);
	// 825B4200: 897F000B  lbz r11, 0xb(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(11 as u32) ) } as u64;
	// 825B4204: 716B009F  andi. r11, r11, 0x9f
	ctx.r[11].u64 = ctx.r[11].u64 & 159;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B4208: 616B0020  ori r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 | 32;
	// 825B420C: 997F000B  stb r11, 0xb(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(11 as u32), ctx.r[11].u8 ) };
	// 825B4210: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825B4214: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B4218: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B421C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B4220: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B4228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B4228 size=24
    let mut pc: u32 = 0x825B4228;
    'dispatch: loop {
        match pc {
            0x825B4228 => {
    //   block [0x825B4228..0x825B4240)
	// 825B4228: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 825B422C: 894B000B  lbz r10, 0xb(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(11 as u32) ) } as u64;
	// 825B4230: 554A06B4  rlwinm r10, r10, 0, 0x1a, 0x1a
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 825B4234: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B4238: 419A0008  beq cr6, 0x825b4240
	if ctx.cr[6].eq {
		sub_825B4240(ctx, base);
		return;
	}
	// 825B423C: 480017FC  b 0x825b5a38
	sub_825B5A38(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B4240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B4240 size=12
    let mut pc: u32 = 0x825B4240;
    'dispatch: loop {
        match pc {
            0x825B4240 => {
    //   block [0x825B4240..0x825B424C)
	// 825B4240: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 825B4244: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 825B4248: 48009878  b 0x825bdac0
	sub_825BDAC0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B4250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B4250 size=4
    let mut pc: u32 = 0x825B4250;
    'dispatch: loop {
        match pc {
            0x825B4250 => {
    //   block [0x825B4250..0x825B4254)
	// 825B4250: 48001780  b 0x825b59d0
	sub_825B59D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B4258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B4258 size=20
    let mut pc: u32 = 0x825B4258;
    'dispatch: loop {
        match pc {
            0x825B4258 => {
    //   block [0x825B4258..0x825B426C)
	// 825B4258: 8964000B  lbz r11, 0xb(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(11 as u32) ) } as u64;
	// 825B425C: 556B06B4  rlwinm r11, r11, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B4260: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B4264: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 825B4268: 48001690  b 0x825b58f8
	sub_825B58F8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B426C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B426C size=4
    let mut pc: u32 = 0x825B426C;
    'dispatch: loop {
        match pc {
            0x825B426C => {
    //   block [0x825B426C..0x825B4270)
	// 825B426C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B4270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B4270 size=20
    let mut pc: u32 = 0x825B4270;
    'dispatch: loop {
        match pc {
            0x825B4270 => {
    //   block [0x825B4270..0x825B4284)
	// 825B4270: 8964000B  lbz r11, 0xb(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(11 as u32) ) } as u64;
	// 825B4274: 556B06B4  rlwinm r11, r11, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B4278: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B427C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 825B4280: 480016B8  b 0x825b5938
	sub_825B5938(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B4284(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B4284 size=4
    let mut pc: u32 = 0x825B4284;
    'dispatch: loop {
        match pc {
            0x825B4284 => {
    //   block [0x825B4284..0x825B4288)
	// 825B4284: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B4288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B4288 size=20
    let mut pc: u32 = 0x825B4288;
    'dispatch: loop {
        match pc {
            0x825B4288 => {
    //   block [0x825B4288..0x825B429C)
	// 825B4288: 8964000B  lbz r11, 0xb(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(11 as u32) ) } as u64;
	// 825B428C: 556B06B4  rlwinm r11, r11, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B4290: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B4294: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 825B4298: 480016E8  b 0x825b5980
	sub_825B5980(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B429C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B429C size=4
    let mut pc: u32 = 0x825B429C;
    'dispatch: loop {
        match pc {
            0x825B429C => {
    //   block [0x825B429C..0x825B42A0)
	// 825B429C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B42A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B42A0 size=120
    let mut pc: u32 = 0x825B42A0;
    'dispatch: loop {
        match pc {
            0x825B42A0 => {
    //   block [0x825B42A0..0x825B4310)
	// 825B42A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B42A4: 4BF80E0D  bl 0x825350b0
	ctx.lr = 0x825B42A8;
	sub_82535080(ctx, base);
	// 825B42A8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B42AC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B42B0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825B42B4: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 825B42B8: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 825B42BC: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 825B42C0: 897E000B  lbz r11, 0xb(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(11 as u32) ) } as u64;
	// 825B42C4: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	// 825B42C8: 556B06B4  rlwinm r11, r11, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B42CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B42D0: 409A0040  bne cr6, 0x825b4310
	if !ctx.cr[6].eq {
	pc = 0x825B4310; continue 'dispatch;
	}
	// 825B42D4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B42D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B42DC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B42E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B42E4: 4E800421  bctrl
	ctx.lr = 0x825B42E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B42E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825B42EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B42F0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 825B42F4: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 825B42F8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 825B42FC: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 825B4300: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 825B4304: 93410068  stw r26, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[26].u32 ) };
	// 825B4308: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825B430C: 4800A825  bl 0x825beb30
	ctx.lr = 0x825B4310;
	sub_825BEB30(ctx, base);
            }
            0x825B4310 => {
    //   block [0x825B4310..0x825B4318)
	// 825B4310: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825B4314: 4BF80DEC  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B4350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B4350 size=1096
    let mut pc: u32 = 0x825B4350;
    'dispatch: loop {
        match pc {
            0x825B4350 => {
    //   block [0x825B4350..0x825B43BC)
	// 825B4350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B4354: 4BF80D31  bl 0x82535084
	ctx.lr = 0x825B4358;
	sub_82535080(ctx, base);
	// 825B4358: DBE1FF68  stfd f31, -0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.f[31].u64 ) };
	// 825B435C: E981F000  ld r12, -0x1000(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-4096 as u32) ) };
	// 825B4360: 9421ED90  stwu r1, -0x1270(r1)
	ea = ctx.r[1].u32.wrapping_add(-4720 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B4364: 822D0000  lwz r17, 0(r13)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4368: 39E00014  li r15, 0x14
	ctx.r[15].s64 = 20;
	// 825B436C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B4370: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 825B4374: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825B4378: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825B437C: 7D51782E  lwzx r10, r17, r15
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[17].u32.wrapping_add(ctx.r[15].u32)) } as u64;
	// 825B4380: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 825B4384: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B4388: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B438C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B4390: 4098002C  bge cr6, 0x825b43bc
	if !ctx.cr[6].lt {
	pc = 0x825B43BC; continue 'dispatch;
	}
	// 825B4394: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 825B4398: 3D008206  lis r8, -0x7dfa
	ctx.r[8].s64 = -2113536000;
	// 825B439C: 3929506C  addi r9, r9, 0x506c
	ctx.r[9].s64 = ctx.r[9].s64 + 20588;
	// 825B43A0: 39085064  addi r8, r8, 0x5064
	ctx.r[8].s64 = ctx.r[8].s64 + 20580;
	// 825B43A4: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B43A8: 910B000C  stw r8, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 825B43AC: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 825B43B0: 390B0010  addi r8, r11, 0x10
	ctx.r[8].s64 = ctx.r[11].s64 + 16;
	// 825B43B4: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B43B8: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x825B43BC; continue 'dispatch;
            }
            0x825B43BC => {
    //   block [0x825B43BC..0x825B4414)
	// 825B43BC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B43C0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825B43C4: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 825B43C8: 824B0000  lwz r18, 0(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B43CC: 4BF6589D  bl 0x82519c68
	ctx.lr = 0x825B43D0;
	sub_82519C68(ctx, base);
	// 825B43D0: 897E000B  lbz r11, 0xb(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(11 as u32) ) } as u64;
	// 825B43D4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 825B43D8: 3AA00019  li r21, 0x19
	ctx.r[21].s64 = 25;
	// 825B43DC: 556B06B4  rlwinm r11, r11, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B43E0: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 825B43E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B43E8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825B43EC: C3EA2068  lfs f31, 0x2068(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8296 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825B43F0: 3AC00001  li r22, 1
	ctx.r[22].s64 = 1;
	// 825B43F4: 3A8B6DD0  addi r20, r11, 0x6dd0
	ctx.r[20].s64 = ctx.r[11].s64 + 28112;
	// 825B43F8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825B43FC: 3AE00002  li r23, 2
	ctx.r[23].s64 = 2;
	// 825B4400: 3B6B4F68  addi r27, r11, 0x4f68
	ctx.r[27].s64 = ctx.r[11].s64 + 20328;
	// 825B4404: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825B4408: 3E008000  lis r16, -0x8000
	ctx.r[16].s64 = -2147483648;
	// 825B440C: 3A6B5058  addi r19, r11, 0x5058
	ctx.r[19].s64 = ctx.r[11].s64 + 20568;
	// 825B4410: 409A00F0  bne cr6, 0x825b4500
	if !ctx.cr[6].eq {
	pc = 0x825B4500; continue 'dispatch;
	}
	pc = 0x825B4414; continue 'dispatch;
            }
            0x825B4414 => {
    //   block [0x825B4414..0x825B443C)
	// 825B4414: 7D51782E  lwzx r10, r17, r15
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[17].u32.wrapping_add(ctx.r[15].u32)) } as u64;
	// 825B4418: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B441C: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B4420: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B4424: 40980018  bge cr6, 0x825b443c
	if !ctx.cr[6].lt {
	pc = 0x825B443C; continue 'dispatch;
	}
	// 825B4428: 926B0000  stw r19, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[19].u32 ) };
	// 825B442C: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 825B4430: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 825B4434: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B4438: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x825B443C; continue 'dispatch;
            }
            0x825B443C => {
    //   block [0x825B443C..0x825B4500)
	// 825B443C: A17E000C  lhz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B4440: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 825B4444: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 825B4448: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B444C: B15E000C  sth r10, 0xc(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[10].u16 ) };
	// 825B4450: 4098021C  bge cr6, 0x825b466c
	if !ctx.cr[6].lt {
	pc = 0x825B466C; continue 'dispatch;
	}
	// 825B4454: B2BE000C  sth r21, 0xc(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[21].u16 ) };
	// 825B4458: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 825B445C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B4460: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4464: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B4468: 808A0008  lwz r4, 8(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B446C: 4BFF4CED  bl 0x825a9158
	ctx.lr = 0x825B4470;
	sub_825A9158(ctx, base);
	// 825B4470: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4474: 38C10100  addi r6, r1, 0x100
	ctx.r[6].s64 = ctx.r[1].s64 + 256;
	// 825B4478: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B447C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825B4480: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B4484: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B4488: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825B448C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4490: 91010078  stw r8, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[8].u32 ) };
	// 825B4494: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4498: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 825B449C: 39410110  addi r10, r1, 0x110
	ctx.r[10].s64 = ctx.r[1].s64 + 272;
	// 825B44A0: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 825B44A4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B44A8: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 825B44AC: C0090004  lfs f0, 4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B44B0: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 825B44B4: 48014305  bl 0x825c87b8
	ctx.lr = 0x825B44B8;
	sub_825C87B8(ctx, base);
	// 825B44B8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825B44BC: 419A01B0  beq cr6, 0x825b466c
	if ctx.cr[6].eq {
	pc = 0x825B466C; continue 'dispatch;
	}
	// 825B44C0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B44C4: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 825B44C8: 80DA0004  lwz r6, 4(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B44CC: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B44D0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B44D4: 480095ED  bl 0x825bdac0
	ctx.lr = 0x825B44D8;
	sub_825BDAC0(ctx, base);
	// 825B44D8: 897E000B  lbz r11, 0xb(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(11 as u32) ) } as u64;
	// 825B44DC: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 825B44E0: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 825B44E4: 933E000C  stw r25, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[25].u32 ) };
	// 825B44E8: 616B0020  ori r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 | 32;
	// 825B44EC: 997E000B  stb r11, 0xb(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(11 as u32), ctx.r[11].u8 ) };
	// 825B44F0: 80FF000C  lwz r7, 0xc(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B44F4: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B44F8: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B44FC: 4BF64FFD  bl 0x825194f8
	ctx.lr = 0x825B4500;
	sub_825194F8(ctx, base);
	pc = 0x825B4500; continue 'dispatch;
            }
            0x825B4500 => {
    //   block [0x825B4500..0x825B45AC)
	// 825B4500: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B4504: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B4508: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825B450C: B2C10056  sth r22, 0x56(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[22].u16 ) };
	// 825B4510: 92E10058  stw r23, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[23].u32 ) };
	// 825B4514: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 825B4518: 9B210060  stb r25, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[25].u8 ) };
	// 825B451C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825B4520: 480003A1  bl 0x825b48c0
	ctx.lr = 0x825B4524;
	sub_825B48C0(ctx, base);
	// 825B4524: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B4528: 395F0060  addi r10, r31, 0x60
	ctx.r[10].s64 = ctx.r[31].s64 + 96;
	// 825B452C: 813F0054  lwz r9, 0x54(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B4530: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 825B4534: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825B4538: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825B453C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 825B4540: 916100E0  stw r11, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[11].u32 ) };
	// 825B4544: 396100F0  addi r11, r1, 0xf0
	ctx.r[11].s64 = ctx.r[1].s64 + 240;
	// 825B4548: 912100E4  stw r9, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 825B454C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825B4550: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 825B4554: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 825B4558: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 825B455C: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 825B4560: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825B4564: 9161009C  stw r11, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 825B4568: 480016F1  bl 0x825b5c58
	ctx.lr = 0x825B456C;
	sub_825B5C58(ctx, base);
	// 825B456C: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825B4570: 89610060  lbz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825B4574: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B4578: 9141009C  stw r10, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[10].u32 ) };
	// 825B457C: 409A0084  bne cr6, 0x825b4600
	if !ctx.cr[6].eq {
	pc = 0x825B4600; continue 'dispatch;
	}
	// 825B4580: 897E000E  lbz r11, 0xe(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(14 as u32) ) } as u64;
	// 825B4584: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B4588: 419A00DC  beq cr6, 0x825b4664
	if ctx.cr[6].eq {
	pc = 0x825B4664; continue 'dispatch;
	}
	// 825B458C: 897E000B  lbz r11, 0xb(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(11 as u32) ) } as u64;
	// 825B4590: 556B0672  rlwinm r11, r11, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B4594: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B4598: 409A00CC  bne cr6, 0x825b4664
	if !ctx.cr[6].eq {
	pc = 0x825B4664; continue 'dispatch;
	}
	// 825B459C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B45A0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B45A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B45A8: 419A0014  beq cr6, 0x825b45bc
	if ctx.cr[6].eq {
	pc = 0x825B45BC; continue 'dispatch;
	}
	pc = 0x825B45AC; continue 'dispatch;
            }
            0x825B45AC => {
    //   block [0x825B45AC..0x825B45BC)
	// 825B45AC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 825B45B0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B45B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B45B8: 409AFFF4  bne cr6, 0x825b45ac
	if !ctx.cr[6].eq {
	pc = 0x825B45AC; continue 'dispatch;
	}
	pc = 0x825B45BC; continue 'dispatch;
            }
            0x825B45BC => {
    //   block [0x825B45BC..0x825B45D0)
	// 825B45BC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B45C0: C1AB0048  lfs f13, 0x48(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825B45C4: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B45C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B45CC: 419A0014  beq cr6, 0x825b45e0
	if ctx.cr[6].eq {
	pc = 0x825B45E0; continue 'dispatch;
	}
	pc = 0x825B45D0; continue 'dispatch;
            }
            0x825B45D0 => {
    //   block [0x825B45D0..0x825B45E0)
	// 825B45D0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B45D4: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B45D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B45DC: 409AFFF4  bne cr6, 0x825b45d0
	if !ctx.cr[6].eq {
	pc = 0x825B45D0; continue 'dispatch;
	}
	pc = 0x825B45E0; continue 'dispatch;
            }
            0x825B45E0 => {
    //   block [0x825B45E0..0x825B4600)
	// 825B45E0: C00A0048  lfs f0, 0x48(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(72 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B45E4: ED606828  fsubs f11, f0, f13
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 825B45E8: C19C000C  lfs f12, 0xc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825B45EC: FC0B036E  fsel f0, f11, f13, f0
	ctx.f[0].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[0].f64 };
	// 825B45F0: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 825B45F4: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 825B45F8: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 825B45FC: 40980068  bge cr6, 0x825b4664
	if !ctx.cr[6].lt {
	pc = 0x825B4664; continue 'dispatch;
	}
	pc = 0x825B4600; continue 'dispatch;
            }
            0x825B4600 => {
    //   block [0x825B4600..0x825B4650)
	// 825B4600: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 825B4604: 80FF000C  lwz r7, 0xc(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B4608: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 825B460C: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B4610: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4614: 4BF64EE5  bl 0x825194f8
	ctx.lr = 0x825B4618;
	sub_825194F8(ctx, base);
	// 825B4618: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B461C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 825B4620: 80DA0004  lwz r6, 4(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B4624: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B4628: 480013A9  bl 0x825b59d0
	ctx.lr = 0x825B462C;
	sub_825B59D0(ctx, base);
	// 825B462C: 897E000B  lbz r11, 0xb(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(11 as u32) ) } as u64;
	// 825B4630: 3BBE000C  addi r29, r30, 0xc
	ctx.r[29].s64 = ctx.r[30].s64 + 12;
	// 825B4634: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825B4638: 716B00DF  andi. r11, r11, 0xdf
	ctx.r[11].u64 = ctx.r[11].u64 & 223;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B463C: 997E000B  stb r11, 0xb(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(11 as u32), ctx.r[11].u8 ) };
	// 825B4640: 419A0010  beq cr6, 0x825b4650
	if ctx.cr[6].eq {
	pc = 0x825B4650; continue 'dispatch;
	}
	// 825B4644: 933D0004  stw r25, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 825B4648: 933D0008  stw r25, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 825B464C: 921D000C  stw r16, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[16].u32 ) };
	pc = 0x825B4650; continue 'dispatch;
            }
            0x825B4650 => {
    //   block [0x825B4650..0x825B4664)
	// 825B4650: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 825B4654: 4800967D  bl 0x825bdcd0
	ctx.lr = 0x825B4658;
	sub_825BDCD0(ctx, base);
	// 825B4658: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 825B465C: B2BD0000  sth r21, 0(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[21].u16 ) };
	// 825B4660: 4BFFFDB4  b 0x825b4414
	pc = 0x825B4414; continue 'dispatch;
            }
            0x825B4664 => {
    //   block [0x825B4664..0x825B466C)
	// 825B4664: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 825B4668: 480000CC  b 0x825b4734
	pc = 0x825B4734; continue 'dispatch;
            }
            0x825B466C => {
    //   block [0x825B466C..0x825B46A8)
	// 825B466C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825B4670: 3B600010  li r27, 0x10
	ctx.r[27].s64 = 16;
	// 825B4674: C00BA17C  lfs f0, -0x5e84(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B4678: D01C000C  stfs f0, 0xc(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 825B467C: 7C71D82E  lwzx r3, r17, r27
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[17].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 825B4680: 83920048  lwz r28, 0x48(r18)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B4684: 397C0005  addi r11, r28, 5
	ctx.r[11].s64 = ctx.r[28].s64 + 5;
	// 825B4688: 83A30020  lwz r29, 0x20(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 825B468C: 55641036  rlwinm r4, r11, 2, 0, 0x1b
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825B4690: 8143002C  lwz r10, 0x2c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 825B4694: 7D7D2214  add r11, r29, r4
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[4].u64;
	// 825B4698: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B469C: 4199000C  bgt cr6, 0x825b46a8
	if ctx.cr[6].gt {
	pc = 0x825B46A8; continue 'dispatch;
	}
	// 825B46A0: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 825B46A4: 48000018  b 0x825b46bc
	pc = 0x825B46BC; continue 'dispatch;
            }
            0x825B46A8 => {
    //   block [0x825B46A8..0x825B46BC)
	// 825B46A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B46AC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B46B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B46B4: 4E800421  bctrl
	ctx.lr = 0x825B46B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B46B8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
            }
            0x825B46BC => {
    //   block [0x825B46BC..0x825B46CC)
	// 825B46BC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 825B46C0: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 825B46C4: 4099001C  ble cr6, 0x825b46e0
	if !ctx.cr[6].gt {
	pc = 0x825B46E0; continue 'dispatch;
	}
	// 825B46C8: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x825B46CC; continue 'dispatch;
            }
            0x825B46CC => {
    //   block [0x825B46CC..0x825B46E0)
	// 825B46CC: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825B46D0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825B46D4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825B46D8: 7F0BE000  cmpw cr6, r11, r28
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[28].s32, &mut ctx.xer);
	// 825B46DC: 4198FFF0  blt cr6, 0x825b46cc
	if ctx.cr[6].lt {
	pc = 0x825B46CC; continue 'dispatch;
	}
	pc = 0x825B46E0; continue 'dispatch;
            }
            0x825B46E0 => {
    //   block [0x825B46E0..0x825B4730)
	// 825B46E0: 578B103A  slwi r11, r28, 2
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B46E4: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 825B46E8: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 825B46EC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 825B46F0: 38D20014  addi r6, r18, 0x14
	ctx.r[6].s64 = ctx.r[18].s64 + 20;
	// 825B46F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B46F8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825B46FC: 7D4BE92E  stwx r10, r11, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32), ctx.r[10].u32) };
	// 825B4700: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 825B4704: 4800A815  bl 0x825bef18
	ctx.lr = 0x825B4708;
	sub_825BEF18(ctx, base);
	// 825B4708: 7C71D82E  lwzx r3, r17, r27
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[17].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 825B470C: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 825B4710: 93A30020  stw r29, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[29].u32 ) };
	// 825B4714: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B4718: 409A0018  bne cr6, 0x825b4730
	if !ctx.cr[6].eq {
	pc = 0x825B4730; continue 'dispatch;
	}
	// 825B471C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4720: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825B4724: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 825B4728: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B472C: 4E800421  bctrl
	ctx.lr = 0x825B4730;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x825B4730 => {
    //   block [0x825B4730..0x825B4734)
	// 825B4730: 387E001C  addi r3, r30, 0x1c
	ctx.r[3].s64 = ctx.r[30].s64 + 28;
	pc = 0x825B4734; continue 'dispatch;
            }
            0x825B4734 => {
    //   block [0x825B4734..0x825B4784)
	// 825B4734: 897E000B  lbz r11, 0xb(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(11 as u32) ) } as u64;
	// 825B4738: 616B0040  ori r11, r11, 0x40
	ctx.r[11].u64 = ctx.r[11].u64 | 64;
	// 825B473C: 997E000B  stb r11, 0xb(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(11 as u32), ctx.r[11].u8 ) };
	// 825B4740: 7D51782E  lwzx r10, r17, r15
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[17].u32.wrapping_add(ctx.r[15].u32)) } as u64;
	// 825B4744: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B4748: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B474C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B4750: 40980034  bge cr6, 0x825b4784
	if !ctx.cr[6].lt {
	pc = 0x825B4784; continue 'dispatch;
	}
	// 825B4754: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 825B4758: 3929FE14  addi r9, r9, -0x1ec
	ctx.r[9].s64 = ctx.r[9].s64 + -492;
	// 825B475C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B4760: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 825B4764: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 825B4768: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B476C: 38E3000F  addi r7, r3, 0xf
	ctx.r[7].s64 = ctx.r[3].s64 + 15;
	// 825B4770: 54E30036  rlwinm r3, r7, 0, 0, 0x1b
	ctx.r[3].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 825B4774: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 825B4778: 38211270  addi r1, r1, 0x1270
	ctx.r[1].s64 = ctx.r[1].s64 + 4720;
	// 825B477C: CBE1FF68  lfd f31, -0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 825B4780: 4BF80954  b 0x825350d4
	sub_825350D0(ctx, base);
	return;
            }
            0x825B4784 => {
    //   block [0x825B4784..0x825B4798)
	// 825B4784: 3963000F  addi r11, r3, 0xf
	ctx.r[11].s64 = ctx.r[3].s64 + 15;
	// 825B4788: 55630036  rlwinm r3, r11, 0, 0, 0x1b
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B478C: 38211270  addi r1, r1, 0x1270
	ctx.r[1].s64 = ctx.r[1].s64 + 4720;
	// 825B4790: CBE1FF68  lfd f31, -0x98(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 825B4794: 4BF80940  b 0x825350d4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B4798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B4798 size=164
    let mut pc: u32 = 0x825B4798;
    'dispatch: loop {
        match pc {
            0x825B4798 => {
    //   block [0x825B4798..0x825B483C)
	// 825B4798: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B479C: 4BF8091D  bl 0x825350b8
	ctx.lr = 0x825B47A0;
	sub_82535080(ctx, base);
	// 825B47A0: 3CC0825B  lis r6, -0x7da5
	ctx.r[6].s64 = -2107965440;
	// 825B47A4: 3F80825B  lis r28, -0x7da5
	ctx.r[28].s64 = -2107965440;
	// 825B47A8: 38C64288  addi r6, r6, 0x4288
	ctx.r[6].s64 = ctx.r[6].s64 + 17032;
	// 825B47AC: 3FA0825B  lis r29, -0x7da5
	ctx.r[29].s64 = -2107965440;
	// 825B47B0: 3FC0825B  lis r30, -0x7da5
	ctx.r[30].s64 = -2107965440;
	// 825B47B4: 3FE0825B  lis r31, -0x7da5
	ctx.r[31].s64 = -2107965440;
	// 825B47B8: 3C80825B  lis r4, -0x7da5
	ctx.r[4].s64 = -2107965440;
	// 825B47BC: 3CA0825B  lis r5, -0x7da5
	ctx.r[5].s64 = -2107965440;
	// 825B47C0: 90C30014  stw r6, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[6].u32 ) };
	// 825B47C4: 3CE0825B  lis r7, -0x7da5
	ctx.r[7].s64 = -2107965440;
	// 825B47C8: 3D00825B  lis r8, -0x7da5
	ctx.r[8].s64 = -2107965440;
	// 825B47CC: 3D20825B  lis r9, -0x7da5
	ctx.r[9].s64 = -2107965440;
	// 825B47D0: 3D40825B  lis r10, -0x7da5
	ctx.r[10].s64 = -2107965440;
	// 825B47D4: 3D60825B  lis r11, -0x7da5
	ctx.r[11].s64 = -2107965440;
	// 825B47D8: 3B9C41E8  addi r28, r28, 0x41e8
	ctx.r[28].s64 = ctx.r[28].s64 + 16872;
	// 825B47DC: 3BBD4350  addi r29, r29, 0x4350
	ctx.r[29].s64 = ctx.r[29].s64 + 17232;
	// 825B47E0: 3BDE4318  addi r30, r30, 0x4318
	ctx.r[30].s64 = ctx.r[30].s64 + 17176;
	// 825B47E4: 3BFF4250  addi r31, r31, 0x4250
	ctx.r[31].s64 = ctx.r[31].s64 + 16976;
	// 825B47E8: 38844258  addi r4, r4, 0x4258
	ctx.r[4].s64 = ctx.r[4].s64 + 16984;
	// 825B47EC: 38A54270  addi r5, r5, 0x4270
	ctx.r[5].s64 = ctx.r[5].s64 + 17008;
	// 825B47F0: 93830000  stw r28, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825B47F4: 38E742A0  addi r7, r7, 0x42a0
	ctx.r[7].s64 = ctx.r[7].s64 + 17056;
	// 825B47F8: 93A3002C  stw r29, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[29].u32 ) };
	// 825B47FC: 39084130  addi r8, r8, 0x4130
	ctx.r[8].s64 = ctx.r[8].s64 + 16688;
	// 825B4800: 93C30028  stw r30, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 825B4804: 392941A0  addi r9, r9, 0x41a0
	ctx.r[9].s64 = ctx.r[9].s64 + 16800;
	// 825B4808: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 825B480C: 394A41C8  addi r10, r10, 0x41c8
	ctx.r[10].s64 = ctx.r[10].s64 + 16840;
	// 825B4810: 9083000C  stw r4, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	// 825B4814: 396B4228  addi r11, r11, 0x4228
	ctx.r[11].s64 = ctx.r[11].s64 + 16936;
	// 825B4818: 90A30010  stw r5, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[5].u32 ) };
	// 825B481C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825B4820: 90E30018  stw r7, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[7].u32 ) };
	// 825B4824: 9103001C  stw r8, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[8].u32 ) };
	// 825B4828: 91230020  stw r9, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 825B482C: 91430024  stw r10, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 825B4830: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825B4834: 98C30030  stb r6, 0x30(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[6].u8 ) };
	// 825B4838: 4BF808D0  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B4840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B4840 size=124
    let mut pc: u32 = 0x825B4840;
    'dispatch: loop {
        match pc {
            0x825B4840 => {
    //   block [0x825B4840..0x825B48BC)
	// 825B4840: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B4844: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B4848: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B484C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B4850: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B4854: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B4858: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B485C: 99610080  stb r11, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u8 ) };
	// 825B4860: 99610081  stb r11, 0x81(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(129 as u32), ctx.r[11].u8 ) };
	// 825B4864: 99610082  stb r11, 0x82(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(130 as u32), ctx.r[11].u8 ) };
	// 825B4868: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 825B486C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 825B4870: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 825B4874: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 825B4878: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 825B487C: 4BFFFF1D  bl 0x825b4798
	ctx.lr = 0x825B4880;
	sub_825B4798(ctx, base);
	// 825B4880: 38C00015  li r6, 0x15
	ctx.r[6].s64 = 21;
	// 825B4884: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825B4888: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B488C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B4890: 4BF4B6D9  bl 0x824fff68
	ctx.lr = 0x825B4894;
	sub_824FFF68(ctx, base);
	// 825B4894: 38C00015  li r6, 0x15
	ctx.r[6].s64 = 21;
	// 825B4898: 38A00015  li r5, 0x15
	ctx.r[5].s64 = 21;
	// 825B489C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B48A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B48A4: 4BF4B6C5  bl 0x824fff68
	ctx.lr = 0x825B48A8;
	sub_824FFF68(ctx, base);
	// 825B48A8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825B48AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B48B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B48B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B48B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B48C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B48C0 size=204
    let mut pc: u32 = 0x825B48C0;
    'dispatch: loop {
        match pc {
            0x825B48C0 => {
    //   block [0x825B48C0..0x825B498C)
	// 825B48C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B48C4: 4BF807E5  bl 0x825350a8
	ctx.lr = 0x825B48C8;
	sub_82535080(ctx, base);
	// 825B48C8: 80A40000  lwz r5, 0(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B48CC: 39640010  addi r11, r4, 0x10
	ctx.r[11].s64 = ctx.r[4].s64 + 16;
	// 825B48D0: 3921FF70  addi r9, r1, -0x90
	ctx.r[9].s64 = ctx.r[1].s64 + -144;
	// 825B48D4: 3BEB0030  addi r31, r11, 0x30
	ctx.r[31].s64 = ctx.r[11].s64 + 48;
	// 825B48D8: 3901FF80  addi r8, r1, -0x80
	ctx.r[8].s64 = ctx.r[1].s64 + -128;
	// 825B48DC: 38E1FF90  addi r7, r1, -0x70
	ctx.r[7].s64 = ctx.r[1].s64 + -112;
	// 825B48E0: 90A30000  stw r5, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 825B48E4: 38C1FFA0  addi r6, r1, -0x60
	ctx.r[6].s64 = ctx.r[1].s64 + -96;
	// 825B48E8: 80A40004  lwz r5, 4(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B48EC: 39430010  addi r10, r3, 0x10
	ctx.r[10].s64 = ctx.r[3].s64 + 16;
	// 825B48F0: 3BC00010  li r30, 0x10
	ctx.r[30].s64 = 16;
	// 825B48F4: 3BA00020  li r29, 0x20
	ctx.r[29].s64 = 32;
	// 825B48F8: 3B800030  li r28, 0x30
	ctx.r[28].s64 = 48;
	// 825B48FC: 90A30004  stw r5, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 825B4900: 80A40008  lwz r5, 8(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B4904: 90A30008  stw r5, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 825B4908: 80A4000C  lwz r5, 0xc(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B490C: 388B0020  addi r4, r11, 0x20
	ctx.r[4].s64 = ctx.r[11].s64 + 32;
	// 825B4910: 90A3000C  stw r5, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[5].u32 ) };
	// 825B4914: 38AB0010  addi r5, r11, 0x10
	ctx.r[5].s64 = ctx.r[11].s64 + 16;
	// 825B4918: EB6B0000  ld r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 825B491C: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 825B4920: EB240000  ld r25, 0(r4)
	ctx.r[25].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	// 825B4924: E8840008  ld r4, 8(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	// 825B4928: EB450000  ld r26, 0(r5)
	ctx.r[26].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	// 825B492C: FB690000  std r27, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[27].u64 ) };
	// 825B4930: F9690008  std r11, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 825B4934: 3961FF70  addi r11, r1, -0x90
	ctx.r[11].s64 = ctx.r[1].s64 + -144;
	// 825B4938: E8A50008  ld r5, 8(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	// 825B493C: FB270000  std r25, 0(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[25].u64 ) };
	// 825B4940: FB480000  std r26, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[26].u64 ) };
	// 825B4944: EB1F0000  ld r24, 0(r31)
	ctx.r[24].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B4990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B4990 size=116
    let mut pc: u32 = 0x825B4990;
    'dispatch: loop {
        match pc {
            0x825B4990 => {
    //   block [0x825B4990..0x825B4A04)
	// 825B4990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B4994: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B4998: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825B499C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B49A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B49A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B49A8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B49AC: 4BFFFF15  bl 0x825b48c0
	ctx.lr = 0x825B49B0;
	sub_825B48C0(ctx, base);
	// 825B49B0: 813E0050  lwz r9, 0x50(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B49B4: 397E0060  addi r11, r30, 0x60
	ctx.r[11].s64 = ctx.r[30].s64 + 96;
	// 825B49B8: 395F0060  addi r10, r31, 0x60
	ctx.r[10].s64 = ctx.r[31].s64 + 96;
	// 825B49BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B49C0: 913F0050  stw r9, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 825B49C4: 813E0054  lwz r9, 0x54(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B49C8: 913F0054  stw r9, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825B49CC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B49D0: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B49D4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B49D8: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B49DC: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B49E0: 912A0008  stw r9, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 825B49E4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B49E8: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 825B49EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B49F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B49F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B49F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825B49FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B4A00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B4A08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B4A08 size=72
    let mut pc: u32 = 0x825B4A08;
    'dispatch: loop {
        match pc {
            0x825B4A08 => {
    //   block [0x825B4A08..0x825B4A50)
	// 825B4A08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B4A0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B4A10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825B4A14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B4A18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B4A1C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B4A20: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 825B4A24: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 825B4A28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B4A2C: 4800DFED  bl 0x825c2a18
	ctx.lr = 0x825B4A30;
	sub_825C2A18(ctx, base);
	// 825B4A30: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B4A34: 997E0002  stb r11, 2(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(2 as u32), ctx.r[11].u8 ) };
	// 825B4A38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B4A3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B4A40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B4A44: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825B4A48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B4A4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B4A50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B4A50 size=140
    let mut pc: u32 = 0x825B4A50;
    'dispatch: loop {
        match pc {
            0x825B4A50 => {
    //   block [0x825B4A50..0x825B4A68)
	// 825B4A50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B4A54: 4BF80669  bl 0x825350bc
	ctx.lr = 0x825B4A58;
	sub_82535080(ctx, base);
	// 825B4A58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B4A5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B4A60: 7FA32050  subf r29, r3, r4
	ctx.r[29].s64 = ctx.r[4].s64 - ctx.r[3].s64;
	// 825B4A64: 3BC00002  li r30, 2
	ctx.r[30].s64 = 2;
	pc = 0x825B4A68; continue 'dispatch;
            }
            0x825B4A68 => {
    //   block [0x825B4A68..0x825B4AB8)
	// 825B4A68: 7D7DF82E  lwzx r11, r29, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 825B4A6C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B4A70: 419A0054  beq cr6, 0x825b4ac4
	if ctx.cr[6].eq {
	pc = 0x825B4AC4; continue 'dispatch;
	}
	// 825B4A74: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4A78: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4A7C: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4A80: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B4A84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B4A88: 419A0030  beq cr6, 0x825b4ab8
	if ctx.cr[6].eq {
	pc = 0x825B4AB8; continue 'dispatch;
	}
	// 825B4A8C: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 825B4A90: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B4A94: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 825B4A98: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B4A9C: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 825B4AA0: 409A0018  bne cr6, 0x825b4ab8
	if !ctx.cr[6].eq {
	pc = 0x825B4AB8; continue 'dispatch;
	}
	// 825B4AA4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4AA8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825B4AAC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4AB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B4AB4: 4E800421  bctrl
	ctx.lr = 0x825B4AB8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x825B4AB8 => {
    //   block [0x825B4AB8..0x825B4AC4)
	// 825B4AB8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4ABC: 7D5DF82E  lwzx r10, r29, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 825B4AC0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x825B4AC4; continue 'dispatch;
            }
            0x825B4AC4 => {
    //   block [0x825B4AC4..0x825B4ADC)
	// 825B4AC4: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 825B4AC8: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825B4ACC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825B4AD0: 409AFF98  bne cr6, 0x825b4a68
	if !ctx.cr[6].eq {
	pc = 0x825B4A68; continue 'dispatch;
	}
	// 825B4AD4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B4AD8: 4BF80634  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B4AE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B4AE0 size=252
    let mut pc: u32 = 0x825B4AE0;
    'dispatch: loop {
        match pc {
            0x825B4AE0 => {
    //   block [0x825B4AE0..0x825B4B1C)
	// 825B4AE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B4AE4: 4BF805BD  bl 0x825350a0
	ctx.lr = 0x825B4AE8;
	sub_82535080(ctx, base);
	// 825B4AE8: DBC1FF98  stfd f30, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[30].u64 ) };
	// 825B4AEC: DBE1FFA0  stfd f31, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 825B4AF0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B4AF4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825B4AF8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825B4AFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B4B00: 7EE32050  subf r23, r3, r4
	ctx.r[23].s64 = ctx.r[4].s64 - ctx.r[3].s64;
	// 825B4B04: 7F633050  subf r27, r3, r6
	ctx.r[27].s64 = ctx.r[6].s64 - ctx.r[3].s64;
	// 825B4B08: C3CB21A4  lfs f30, 0x21a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8612 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825B4B0C: 3B200002  li r25, 2
	ctx.r[25].s64 = 2;
	// 825B4B10: 3B000040  li r24, 0x40
	ctx.r[24].s64 = 64;
	// 825B4B14: 3B40FFFF  li r26, -1
	ctx.r[26].s64 = -1;
	// 825B4B18: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	pc = 0x825B4B1C; continue 'dispatch;
            }
            0x825B4B1C => {
    //   block [0x825B4B1C..0x825B4B94)
	// 825B4B1C: 7D77F82E  lwzx r11, r23, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[23].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 825B4B20: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B4B24: 419A0090  beq cr6, 0x825b4bb4
	if ctx.cr[6].eq {
	pc = 0x825B4BB4; continue 'dispatch;
	}
	// 825B4B28: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4B2C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 825B4B30: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4B34: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 825B4B38: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 825B4B3C: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825B4B40: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4B44: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4B48: 4BEAF4F1  bl 0x82464038
	ctx.lr = 0x825B4B4C;
	sub_82464038(ctx, base);
	// 825B4B4C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825B4B50: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825B4B54: B31C0004  sth r24, 4(r28)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[24].u16 ) };
	// 825B4B58: C3FD0010  lfs f31, 0x10(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825B4B5C: 4BF4C885  bl 0x825013e0
	ctx.lr = 0x825B4B60;
	sub_825013E0(ctx, base);
	// 825B4B60: EC01F82A  fadds f0, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[31].f64) as f32) as f64;
	// 825B4B64: 38BD0030  addi r5, r29, 0x30
	ctx.r[5].s64 = ctx.r[29].s64 + 48;
	// 825B4B68: 389D0020  addi r4, r29, 0x20
	ctx.r[4].s64 = ctx.r[29].s64 + 32;
	// 825B4B6C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825B4B70: EC20F02A  fadds f1, f0, f30
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 825B4B74: 4BF4DF5D  bl 0x82502ad0
	ctx.lr = 0x825B4B78;
	sub_82502AD0(ctx, base);
	// 825B4B78: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825B4B7C: 419A0018  beq cr6, 0x825b4b94
	if ctx.cr[6].eq {
	pc = 0x825B4B94; continue 'dispatch;
	}
	// 825B4B80: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4B84: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4B88: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B4B8C: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 825B4B90: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x825B4B94; continue 'dispatch;
            }
            0x825B4B94 => {
    //   block [0x825B4B94..0x825B4BB4)
	// 825B4B94: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 825B4B98: 935E0004  stw r26, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 825B4B9C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4BA0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4BA4: 7D7BF92E  stwx r11, r27, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[31].u32), ctx.r[11].u32) };
	// 825B4BA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4BAC: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825B4BB0: 48000008  b 0x825b4bb8
	pc = 0x825B4BB8; continue 'dispatch;
            }
            0x825B4BB4 => {
    //   block [0x825B4BB4..0x825B4BB8)
	// 825B4BB4: 7EDBF92E  stwx r22, r27, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[31].u32), ctx.r[22].u32) };
	pc = 0x825B4BB8; continue 'dispatch;
            }
            0x825B4BB8 => {
    //   block [0x825B4BB8..0x825B4BDC)
	// 825B4BB8: 3B39FFFF  addi r25, r25, -1
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	// 825B4BBC: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 825B4BC0: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825B4BC4: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 825B4BC8: 409AFF54  bne cr6, 0x825b4b1c
	if !ctx.cr[6].eq {
	pc = 0x825B4B1C; continue 'dispatch;
	}
	// 825B4BCC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825B4BD0: CBC1FF98  lfd f30, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 825B4BD4: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 825B4BD8: 4BF80518  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B4BE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B4BE0 size=184
    let mut pc: u32 = 0x825B4BE0;
    'dispatch: loop {
        match pc {
            0x825B4BE0 => {
    //   block [0x825B4BE0..0x825B4C34)
	// 825B4BE0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4BE4: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 825B4BE8: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 825B4BEC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825B4BF0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B4BF4: 419A0040  beq cr6, 0x825b4c34
	if ctx.cr[6].eq {
	pc = 0x825B4C34; continue 'dispatch;
	}
	// 825B4BF8: A0E30000  lhz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4BFC: 89630008  lbz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B4C00: 54E7CFFE  rlwinm r7, r7, 0x19, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x0000007Fu64;
	// 825B4C04: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 825B4C08: 20E70001  subfic r7, r7, 1
	ctx.xer.ca = ctx.r[7].u32 <= 1 as u32;
	ctx.r[7].s64 = (1 as i64) - ctx.r[7].s64;
	// 825B4C0C: 54E72436  rlwinm r7, r7, 4, 0x10, 0x1b
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x0FFFFFFFu64;
	// 825B4C10: B0E30000  sth r7, 0(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
	// 825B4C14: 40990020  ble cr6, 0x825b4c34
	if !ctx.cr[6].gt {
	pc = 0x825B4C34; continue 'dispatch;
	}
	// 825B4C18: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 825B4C1C: B1230000  sth r9, 0(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u16 ) };
	// 825B4C20: B1430002  sth r10, 2(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(2 as u32), ctx.r[10].u16 ) };
	// 825B4C24: 409A0010  bne cr6, 0x825b4c34
	if !ctx.cr[6].eq {
	pc = 0x825B4C34; continue 'dispatch;
	}
	// 825B4C28: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 825B4C2C: 99030008  stb r8, 8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u8 ) };
	// 825B4C30: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	pc = 0x825B4C34; continue 'dispatch;
            }
            0x825B4C34 => {
    //   block [0x825B4C34..0x825B4C98)
	// 825B4C34: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B4C38: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B4C3C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 825B4C40: 89630008  lbz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B4C44: 556B083E  rotlwi r11, r11, 1
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 825B4C48: 7CEB1A2E  lhzx r7, r11, r3
	ctx.r[7].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 825B4C4C: 54E7CFFE  rlwinm r7, r7, 0x19, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x0000007Fu64;
	// 825B4C50: 20E70001  subfic r7, r7, 1
	ctx.xer.ca = ctx.r[7].u32 <= 1 as u32;
	ctx.r[7].s64 = (1 as i64) - ctx.r[7].s64;
	// 825B4C54: 54E72436  rlwinm r7, r7, 4, 0x10, 0x1b
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x0FFFFFFFu64;
	// 825B4C58: 7CEB1B2E  sthx r7, r11, r3
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32), ctx.r[7].u16) };
	// 825B4C5C: 89630009  lbz r11, 9(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(9 as u32) ) } as u64;
	// 825B4C60: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 825B4C64: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 825B4C68: 89630008  lbz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B4C6C: 556B083E  rotlwi r11, r11, 1
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 825B4C70: 7D2B1B2E  sthx r9, r11, r3
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32), ctx.r[9].u16) };
	// 825B4C74: 89630008  lbz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B4C78: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825B4C7C: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B4C80: 7D4B1B2E  sthx r10, r11, r3
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32), ctx.r[10].u16) };
	// 825B4C84: 89630009  lbz r11, 9(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(9 as u32) ) } as u64;
	// 825B4C88: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 825B4C8C: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 825B4C90: 99030009  stb r8, 9(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(9 as u32), ctx.r[8].u8 ) };
	// 825B4C94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B4C98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B4C98 size=128
    let mut pc: u32 = 0x825B4C98;
    'dispatch: loop {
        match pc {
            0x825B4C98 => {
    //   block [0x825B4C98..0x825B4CE0)
	// 825B4C98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B4C9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B4CA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825B4CA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B4CA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B4CAC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B4CB0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825B4CB4: 48000DCD  bl 0x825b5a80
	ctx.lr = 0x825B4CB8;
	sub_825B5A80(ctx, base);
	// 825B4CB8: 897F000B  lbz r11, 0xb(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(11 as u32) ) } as u64;
	// 825B4CBC: 556B0036  rlwinm r11, r11, 0, 0, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B4CC0: 997F000B  stb r11, 0xb(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(11 as u32), ctx.r[11].u8 ) };
	// 825B4CC4: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4CC8: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4CCC: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B4CD0: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 825B4CD4: 409A000C  bne cr6, 0x825b4ce0
	if !ctx.cr[6].eq {
	pc = 0x825B4CE0; continue 'dispatch;
	}
	// 825B4CD8: 616B0005  ori r11, r11, 5
	ctx.r[11].u64 = ctx.r[11].u64 | 5;
	// 825B4CDC: 997F000B  stb r11, 0xb(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(11 as u32), ctx.r[11].u8 ) };
	pc = 0x825B4CE0; continue 'dispatch;
            }
            0x825B4CE0 => {
    //   block [0x825B4CE0..0x825B4D00)
	// 825B4CE0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B4CE4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4CE8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B4CEC: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 825B4CF0: 409A0010  bne cr6, 0x825b4d00
	if !ctx.cr[6].eq {
	pc = 0x825B4D00; continue 'dispatch;
	}
	// 825B4CF4: 897F000B  lbz r11, 0xb(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(11 as u32) ) } as u64;
	// 825B4CF8: 616B000A  ori r11, r11, 0xa
	ctx.r[11].u64 = ctx.r[11].u64 | 10;
	// 825B4CFC: 997F000B  stb r11, 0xb(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(11 as u32), ctx.r[11].u8 ) };
	pc = 0x825B4D00; continue 'dispatch;
            }
            0x825B4D00 => {
    //   block [0x825B4D00..0x825B4D18)
	// 825B4D00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B4D04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B4D08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B4D0C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825B4D10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B4D14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B4D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B4D18 size=468
    let mut pc: u32 = 0x825B4D18;
    'dispatch: loop {
        match pc {
            0x825B4D18 => {
    //   block [0x825B4D18..0x825B4D8C)
	// 825B4D18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B4D1C: 4BF80385  bl 0x825350a0
	ctx.lr = 0x825B4D20;
	sub_82535080(ctx, base);
	// 825B4D20: DBC1FF98  stfd f30, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[30].u64 ) };
	// 825B4D24: DBE1FFA0  stfd f31, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 825B4D28: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B4D2C: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 825B4D30: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 825B4D34: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 825B4D38: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825B4D3C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825B4D40: 4BFFFC51  bl 0x825b4990
	ctx.lr = 0x825B4D44;
	sub_825B4990(ctx, base);
	// 825B4D44: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 825B4D48: 897F000B  lbz r11, 0xb(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(11 as u32) ) } as u64;
	// 825B4D4C: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 825B4D50: 3BC10100  addi r30, r1, 0x100
	ctx.r[30].s64 = ctx.r[1].s64 + 256;
	// 825B4D54: 7F1BC378  mr r27, r24
	ctx.r[27].u64 = ctx.r[24].u64;
	// 825B4D58: 3B400040  li r26, 0x40
	ctx.r[26].s64 = 64;
	// 825B4D5C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825B4D60: 39410094  addi r10, r1, 0x94
	ctx.r[10].s64 = ctx.r[1].s64 + 148;
	// 825B4D64: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 825B4D68: 3B20FFFF  li r25, -1
	ctx.r[25].s64 = -1;
	// 825B4D6C: 93010054  stw r24, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[24].u32 ) };
	// 825B4D70: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 825B4D74: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 825B4D78: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B4D7C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825B4D80: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825B4D84: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825B4D88: C3CB21A4  lfs f30, 0x21a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8612 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	pc = 0x825B4D8C; continue 'dispatch;
            }
            0x825B4D8C => {
    //   block [0x825B4D8C..0x825B4E08)
	// 825B4D8C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 825B4D90: 7D7B582E  lwzx r11, r27, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825B4D94: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B4D98: 419A008C  beq cr6, 0x825b4e24
	if ctx.cr[6].eq {
	pc = 0x825B4E24; continue 'dispatch;
	}
	// 825B4D9C: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 825B4DA0: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4DA4: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 825B4DA8: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 825B4DAC: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 825B4DB0: 7FBB582E  lwzx r29, r27, r11
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825B4DB4: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825B4DB8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4DBC: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4DC0: 4BEAF279  bl 0x82464038
	ctx.lr = 0x825B4DC4;
	sub_82464038(ctx, base);
	// 825B4DC4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825B4DC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B4DCC: B35C0004  sth r26, 4(r28)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[26].u16 ) };
	// 825B4DD0: C3FF0010  lfs f31, 0x10(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825B4DD4: 4BF4C60D  bl 0x825013e0
	ctx.lr = 0x825B4DD8;
	sub_825013E0(ctx, base);
	// 825B4DD8: EC01F82A  fadds f0, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[31].f64) as f32) as f64;
	// 825B4DDC: 38BF0030  addi r5, r31, 0x30
	ctx.r[5].s64 = ctx.r[31].s64 + 48;
	// 825B4DE0: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 825B4DE4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825B4DE8: EC20F02A  fadds f1, f0, f30
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 825B4DEC: 4BF4DCE5  bl 0x82502ad0
	ctx.lr = 0x825B4DF0;
	sub_82502AD0(ctx, base);
	// 825B4DF0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825B4DF4: 419A0014  beq cr6, 0x825b4e08
	if ctx.cr[6].eq {
	pc = 0x825B4E08; continue 'dispatch;
	}
	// 825B4DF8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4DFC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B4E00: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 825B4E04: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x825B4E08; continue 'dispatch;
            }
            0x825B4E08 => {
    //   block [0x825B4E08..0x825B4E24)
	// 825B4E08: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 825B4E0C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825B4E10: 933E0004  stw r25, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 825B4E14: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4E18: 93DD0000  stw r30, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825B4E1C: 7D5B592E  stwx r10, r27, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u32) };
	// 825B4E20: 4800000C  b 0x825b4e2c
	pc = 0x825B4E2C; continue 'dispatch;
            }
            0x825B4E24 => {
    //   block [0x825B4E24..0x825B4E2C)
	// 825B4E24: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825B4E28: 7F1B592E  stwx r24, r27, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32), ctx.r[24].u32) };
	pc = 0x825B4E2C; continue 'dispatch;
            }
            0x825B4E2C => {
    //   block [0x825B4E2C..0x825B4E70)
	// 825B4E2C: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 825B4E30: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 825B4E34: 2F1B0008  cmpwi cr6, r27, 8
	ctx.cr[6].compare_i32(ctx.r[27].s32, 8, &mut ctx.xer);
	// 825B4E38: 4198FF54  blt cr6, 0x825b4d8c
	if ctx.cr[6].lt {
	pc = 0x825B4D8C; continue 'dispatch;
	}
	// 825B4E3C: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 825B4E40: 38D70010  addi r6, r23, 0x10
	ctx.r[6].s64 = ctx.r[23].s64 + 16;
	// 825B4E44: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825B4E48: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4E4C: 81610090  lwz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 825B4E50: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4E54: 4800FDF5  bl 0x825c4c48
	ctx.lr = 0x825B4E58;
	sub_825C4C48(ctx, base);
	// 825B4E58: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 825B4E5C: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 825B4E60: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 825B4E64: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825B4E68: 48000CC1  bl 0x825b5b28
	ctx.lr = 0x825B4E6C;
	sub_825B5B28(ctx, base);
	// 825B4E6C: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	pc = 0x825B4E70; continue 'dispatch;
            }
            0x825B4E70 => {
    //   block [0x825B4E70..0x825B4EC8)
	// 825B4E70: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825B4E74: 7FBF582E  lwzx r29, r31, r11
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825B4E78: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825B4E7C: 419A0050  beq cr6, 0x825b4ecc
	if ctx.cr[6].eq {
	pc = 0x825B4ECC; continue 'dispatch;
	}
	// 825B4E80: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 825B4E84: 7FDF582E  lwzx r30, r31, r11
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825B4E88: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4E8C: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4E90: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B4E94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B4E98: 419A0030  beq cr6, 0x825b4ec8
	if ctx.cr[6].eq {
	pc = 0x825B4EC8; continue 'dispatch;
	}
	// 825B4E9C: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 825B4EA0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B4EA4: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 825B4EA8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B4EAC: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 825B4EB0: 409A0018  bne cr6, 0x825b4ec8
	if !ctx.cr[6].eq {
	pc = 0x825B4EC8; continue 'dispatch;
	}
	// 825B4EB4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4EB8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825B4EBC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4EC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B4EC4: 4E800421  bctrl
	ctx.lr = 0x825B4EC8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x825B4EC8 => {
    //   block [0x825B4EC8..0x825B4ECC)
	// 825B4EC8: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x825B4ECC; continue 'dispatch;
            }
            0x825B4ECC => {
    //   block [0x825B4ECC..0x825B4EEC)
	// 825B4ECC: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825B4ED0: 2F1F0008  cmpwi cr6, r31, 8
	ctx.cr[6].compare_i32(ctx.r[31].s32, 8, &mut ctx.xer);
	// 825B4ED4: 4198FF9C  blt cr6, 0x825b4e70
	if ctx.cr[6].lt {
	pc = 0x825B4E70; continue 'dispatch;
	}
	// 825B4ED8: C021008C  lfs f1, 0x8c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825B4EDC: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 825B4EE0: CBC1FF98  lfd f30, -0x68(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 825B4EE4: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 825B4EE8: 4BF80208  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B4EF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B4EF0 size=2368
    let mut pc: u32 = 0x825B4EF0;
    'dispatch: loop {
        match pc {
            0x825B4EF0 => {
    //   block [0x825B4EF0..0x825B4F54)
	// 825B4EF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B4EF4: 4BF8018D  bl 0x82535080
	ctx.lr = 0x825B4EF8;
	sub_82535080(ctx, base);
	// 825B4EF8: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 825B4EFC: 4BF810E5  bl 0x82535fe0
	ctx.lr = 0x825B4F00;
	sub_82535FB0(ctx, base);
	// 825B4F00: 9421FD10  stwu r1, -0x2f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-752 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B4F04: 828D0000  lwz r20, 0(r13)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4F08: 39600014  li r11, 0x14
	ctx.r[11].s64 = 20;
	// 825B4F0C: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 825B4F10: 7DD45A14  add r14, r20, r11
	ctx.r[14].u64 = ctx.r[20].u64 + ctx.r[11].u64;
	// 825B4F14: 7C912378  mr r17, r4
	ctx.r[17].u64 = ctx.r[4].u64;
	// 825B4F18: 7CAF2B78  mr r15, r5
	ctx.r[15].u64 = ctx.r[5].u64;
	// 825B4F1C: 7CD33378  mr r19, r6
	ctx.r[19].u64 = ctx.r[6].u64;
	// 825B4F20: 7CF23B78  mr r18, r7
	ctx.r[18].u64 = ctx.r[7].u64;
	// 825B4F24: 816E0000  lwz r11, 0(r14)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4F28: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B4F2C: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B4F30: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B4F34: 40980020  bge cr6, 0x825b4f54
	if !ctx.cr[6].lt {
	pc = 0x825B4F54; continue 'dispatch;
	}
	// 825B4F38: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825B4F3C: 3929A190  addi r9, r9, -0x5e70
	ctx.r[9].s64 = ctx.r[9].s64 + -24176;
	// 825B4F40: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B4F44: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 825B4F48: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 825B4F4C: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B4F50: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x825B4F54; continue 'dispatch;
            }
            0x825B4F54 => {
    //   block [0x825B4F54..0x825B512C)
	// 825B4F54: 896F000B  lbz r11, 0xb(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[15].u32.wrapping_add(11 as u32) ) } as u64;
	// 825B4F58: 3A000000  li r16, 0
	ctx.r[16].s64 = 0;
	// 825B4F5C: 3AB60004  addi r21, r22, 4
	ctx.r[21].s64 = ctx.r[22].s64 + 4;
	// 825B4F60: C3560050  lfs f26, 0x50(r22)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(80 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 825B4F64: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 825B4F68: 92C10068  stw r22, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[22].u32 ) };
	// 825B4F6C: 38C100D0  addi r6, r1, 0xd0
	ctx.r[6].s64 = ctx.r[1].s64 + 208;
	// 825B4F70: 7DE57B78  mr r5, r15
	ctx.r[5].u64 = ctx.r[15].u64;
	// 825B4F74: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 825B4F78: 92010060  stw r16, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[16].u32 ) };
	// 825B4F7C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 825B4F80: 92010064  stw r16, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[16].u32 ) };
	// 825B4F84: 91410090  stw r10, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 825B4F88: 556A07BC  rlwinm r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B4F8C: 3B4F000C  addi r26, r15, 0xc
	ctx.r[26].s64 = ctx.r[15].s64 + 12;
	// 825B4F90: 92A1006C  stw r21, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[21].u32 ) };
	// 825B4F94: 3BCF000B  addi r30, r15, 0xb
	ctx.r[30].s64 = ctx.r[15].s64 + 11;
	// 825B4F98: 91410094  stw r10, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[10].u32 ) };
	// 825B4F9C: 556A077A  rlwinm r10, r11, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B4FA0: 556B0738  rlwinm r11, r11, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B4FA4: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 825B4FA8: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 825B4FAC: 48000B7D  bl 0x825b5b28
	ctx.lr = 0x825B4FB0;
	sub_825B5B28(ctx, base);
	// 825B4FB0: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 825B4FB4: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 825B4FB8: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 825B4FBC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825B4FC0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825B4FC4: C36720B0  lfs f27, 0x20b0(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8368 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 825B4FC8: 7E1D8378  mr r29, r16
	ctx.r[29].u64 = ctx.r[16].u64;
	// 825B4FCC: C3A82954  lfs f29, 0x2954(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(10580 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 825B4FD0: 7E1B8378  mr r27, r16
	ctx.r[27].u64 = ctx.r[16].u64;
	// 825B4FD4: C3891FF8  lfs f28, 0x1ff8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 825B4FD8: 3AE00020  li r23, 0x20
	ctx.r[23].s64 = 32;
	// 825B4FDC: C3CA8E30  lfs f30, -0x71d0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-29136 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825B4FE0: 3B000030  li r24, 0x30
	ctx.r[24].s64 = 48;
	// 825B4FE4: C3EB1850  lfs f31, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825B4FE8: 3B800004  li r28, 4
	ctx.r[28].s64 = 4;
	// 825B4FEC: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 825B4FF0: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 825B4FF4: 7D7B582E  lwzx r11, r27, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825B4FF8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B4FFC: 419A0130  beq cr6, 0x825b512c
	if ctx.cr[6].eq {
	pc = 0x825B512C; continue 'dispatch;
	}
	// 825B5000: 39610068  addi r11, r1, 0x68
	ctx.r[11].s64 = ctx.r[1].s64 + 104;
	// 825B5004: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 825B5008: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 825B500C: 7D7B582E  lwzx r11, r27, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825B5010: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5014: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825B512C; continue 'dispatch;
            }
            0x825B512C => {
    //   block [0x825B512C..0x825B5830)
	// 825B512C: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 825B5130: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 825B5134: 2F1B0008  cmpwi cr6, r27, 8
	ctx.cr[6].compare_i32(ctx.r[27].s32, 8, &mut ctx.xer);
	// 825B5138: 4198FEB8  blt cr6, 0x825b4ff0
	if ctx.cr[6].lt {
	pc = 0x825B4FF0; continue 'dispatch;
	}
	// 825B513C: 81760008  lwz r11, 8(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B5140: 810B0060  lwz r8, 0x60(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 825B5144: 81680010  lwz r11, 0x10(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) } as u64;
	// 825B5148: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B514C: 419A0150  beq cr6, 0x825b529c
	if ctx.cr[6].eq {
	pc = 0x825B529C; continue 'dispatch;
	}
	// 825B5150: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5154: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B5158: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B515C: 419A0014  beq cr6, 0x825b5170
	if ctx.cr[6].eq {
	pc = 0x825B5170; continue 'dispatch;
	}
	// 825B5160: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 825B5164: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B5168: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B516C: 409AFFF4  bne cr6, 0x825b5160
	if !ctx.cr[6].eq {
	pc = 0x825B5160; continue 'dispatch;
	}
	// 825B5170: 81550000  lwz r10, 0(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5174: C1AB0048  lfs f13, 0x48(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825B5178: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B517C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B5180: 419A0014  beq cr6, 0x825b5194
	if ctx.cr[6].eq {
	pc = 0x825B5194; continue 'dispatch;
	}
	// 825B5184: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B5188: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B518C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B5190: 409AFFF4  bne cr6, 0x825b5184
	if !ctx.cr[6].eq {
	pc = 0x825B5184; continue 'dispatch;
	}
	// 825B5194: C00A0048  lfs f0, 0x48(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(72 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B5198: ED2D0028  fsubs f9, f13, f0
	ctx.f[9].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 825B519C: C1680018  lfs f11, 0x18(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825B51A0: C193000C  lfs f12, 0xc(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825B51A4: C1480014  lfs f10, 0x14(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(20 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825B51A8: FC29682E  fsel f1, f9, f0, f13
	ctx.f[1].f64 = if ctx.f[9].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 825B51AC: EC0A0072  fmuls f0, f10, f1
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[1].f64) as f32) as f64);
	// 825B51B0: EDAB607A  fmadds f13, f11, f1, f12
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[1].f64 + ctx.f[12].f64) as f32) as f64);
	// 825B51B4: ED606828  fsubs f11, f0, f13
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 825B51B8: FC4B036E  fsel f2, f11, f13, f0
	ctx.f[2].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[0].f64 };
	// 825B51BC: FF1A1000  fcmpu cr6, f26, f2
	ctx.cr[6].compare_f64(ctx.f[26].f64, ctx.f[2].f64);
	// 825B51C0: 409800DC  bge cr6, 0x825b529c
	if !ctx.cr[6].lt {
	pc = 0x825B529C; continue 'dispatch;
	}
	// 825B51C4: C1A80028  lfs f13, 0x28(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825B51C8: 7E499378  mr r9, r18
	ctx.r[9].u64 = ctx.r[18].u64;
	// 825B51CC: C0080024  lfs f0, 0x24(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B51D0: EDAD607A  fmadds f13, f13, f1, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[1].f64 + ctx.f[12].f64) as f32) as f64);
	// 825B51D4: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 825B51D8: 7E689B78  mr r8, r19
	ctx.r[8].u64 = ctx.r[19].u64;
	// 825B51DC: 7DE77B78  mr r7, r15
	ctx.r[7].u64 = ctx.r[15].u64;
	// 825B51E0: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 825B51E4: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 825B51E8: FC6C036E  fsel f3, f12, f13, f0
	ctx.f[3].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[0].f64 };
	// 825B51EC: 4801A97D  bl 0x825cfb68
	ctx.lr = 0x825B51F0;
	sub_825CFB68(ctx, base);
	// 825B51F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825B51F4: 3BC100E0  addi r30, r1, 0xe0
	ctx.r[30].s64 = ctx.r[1].s64 + 224;
	// 825B51F8: 7E1B8378  mr r27, r16
	ctx.r[27].u64 = ctx.r[16].u64;
	// 825B51FC: 3B200040  li r25, 0x40
	ctx.r[25].s64 = 64;
	// 825B5200: 3B00FFFF  li r24, -1
	ctx.r[24].s64 = -1;
	// 825B5204: C3CB21A4  lfs f30, 0x21a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8612 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825B5208: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 825B520C: 7D7B582E  lwzx r11, r27, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825B5210: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B5214: 419A040C  beq cr6, 0x825b5620
	if ctx.cr[6].eq {
	pc = 0x825B5620; continue 'dispatch;
	}
	// 825B5218: 39610068  addi r11, r1, 0x68
	ctx.r[11].s64 = ctx.r[1].s64 + 104;
	// 825B521C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 825B5220: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 825B5224: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 825B5228: 7FBB582E  lwzx r29, r27, r11
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825B522C: 7C74502E  lwzx r3, r20, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[20].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825B5230: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5234: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5238: 4BEAEE01  bl 0x82464038
	ctx.lr = 0x825B523C;
	sub_82464038(ctx, base);
	// 825B523C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825B5240: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B5244: B33C0004  sth r25, 4(r28)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[25].u16 ) };
	// 825B5248: C3FF0010  lfs f31, 0x10(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825B524C: 4BF4C195  bl 0x825013e0
	ctx.lr = 0x825B5250;
	sub_825013E0(ctx, base);
	// 825B5250: EC01F82A  fadds f0, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[31].f64) as f32) as f64;
	// 825B5254: 38BF0030  addi r5, r31, 0x30
	ctx.r[5].s64 = ctx.r[31].s64 + 48;
	// 825B5258: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 825B525C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825B5260: EC20F02A  fadds f1, f0, f30
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 825B5264: 4BF4D86D  bl 0x82502ad0
	ctx.lr = 0x825B5268;
	sub_82502AD0(ctx, base);
	// 825B5268: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825B526C: 419A0014  beq cr6, 0x825b5280
	if ctx.cr[6].eq {
	pc = 0x825B5280; continue 'dispatch;
	}
	// 825B5270: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5274: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B5278: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 825B527C: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825B5280: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 825B5284: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 825B5288: 931E0004  stw r24, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	// 825B528C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5290: 93DD0000  stw r30, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825B5294: 7D5B592E  stwx r10, r27, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u32) };
	// 825B5298: 48000390  b 0x825b5628
	pc = 0x825B5628; continue 'dispatch;
	// 825B529C: C008000C  lfs f0, 0xc(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B52A0: FF1A0000  fcmpu cr6, f26, f0
	ctx.cr[6].compare_f64(ctx.f[26].f64, ctx.f[0].f64);
	// 825B52A4: 4099FF4C  ble cr6, 0x825b51f0
	if !ctx.cr[6].gt {
	pc = 0x825B51F0; continue 'dispatch;
	}
	// 825B52A8: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B52AC: 556B06F6  rlwinm r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B52B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B52B4: 409AFF3C  bne cr6, 0x825b51f0
	if !ctx.cr[6].eq {
	pc = 0x825B51F0; continue 'dispatch;
	}
	// 825B52B8: D353000C  stfs f26, 0xc(r19)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[19].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 825B52BC: 897A0002  lbz r11, 2(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B52C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B52C4: 419A0490  beq cr6, 0x825b5754
	if ctx.cr[6].eq {
	pc = 0x825B5754; continue 'dispatch;
	}
	// 825B52C8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825B52CC: 3BC100E0  addi r30, r1, 0xe0
	ctx.r[30].s64 = ctx.r[1].s64 + 224;
	// 825B52D0: 7E1B8378  mr r27, r16
	ctx.r[27].u64 = ctx.r[16].u64;
	// 825B52D4: 3B200040  li r25, 0x40
	ctx.r[25].s64 = 64;
	// 825B52D8: 3B00FFFF  li r24, -1
	ctx.r[24].s64 = -1;
	// 825B52DC: C3CB21A4  lfs f30, 0x21a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8612 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825B52E0: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 825B52E4: 7D7B582E  lwzx r11, r27, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825B52E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B52EC: 419A0088  beq cr6, 0x825b5374
	if ctx.cr[6].eq {
	pc = 0x825B5374; continue 'dispatch;
	}
	// 825B52F0: 39610068  addi r11, r1, 0x68
	ctx.r[11].s64 = ctx.r[1].s64 + 104;
	// 825B52F4: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 825B52F8: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 825B52FC: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 825B5300: 7FBB582E  lwzx r29, r27, r11
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825B5304: 7C74502E  lwzx r3, r20, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[20].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825B5308: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B530C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5310: 4BEAED29  bl 0x82464038
	ctx.lr = 0x825B5314;
	sub_82464038(ctx, base);
	// 825B5314: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825B5318: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B531C: B33C0004  sth r25, 4(r28)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[25].u16 ) };
	// 825B5320: C3FF0010  lfs f31, 0x10(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825B5324: 4BF4C0BD  bl 0x825013e0
	ctx.lr = 0x825B5328;
	sub_825013E0(ctx, base);
	// 825B5328: EC01F82A  fadds f0, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[31].f64) as f32) as f64;
	// 825B532C: 38BF0030  addi r5, r31, 0x30
	ctx.r[5].s64 = ctx.r[31].s64 + 48;
	// 825B5330: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 825B5334: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825B5338: EC20F02A  fadds f1, f0, f30
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 825B533C: 4BF4D795  bl 0x82502ad0
	ctx.lr = 0x825B5340;
	sub_82502AD0(ctx, base);
	// 825B5340: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825B5344: 419A0014  beq cr6, 0x825b5358
	if ctx.cr[6].eq {
	pc = 0x825B5358; continue 'dispatch;
	}
	// 825B5348: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B534C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B5350: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 825B5354: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825B5358: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 825B535C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 825B5360: 931E0004  stw r24, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	// 825B5364: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5368: 93DD0000  stw r30, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825B536C: 7D5B592E  stwx r10, r27, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u32) };
	// 825B5370: 4800000C  b 0x825b537c
	pc = 0x825B537C; continue 'dispatch;
	// 825B5374: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 825B5378: 7E1B592E  stwx r16, r27, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32), ctx.r[16].u32) };
	// 825B537C: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 825B5380: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 825B5384: 2F1B0008  cmpwi cr6, r27, 8
	ctx.cr[6].compare_i32(ctx.r[27].s32, 8, &mut ctx.xer);
	// 825B5388: 4198FF58  blt cr6, 0x825b52e0
	if ctx.cr[6].lt {
	pc = 0x825B52E0; continue 'dispatch;
	}
	// 825B538C: 81560008  lwz r10, 8(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B5830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B5830 size=196
    let mut pc: u32 = 0x825B5830;
    'dispatch: loop {
        match pc {
            0x825B5830 => {
    //   block [0x825B5830..0x825B58F4)
	// 825B5830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B5834: 4BF7F881  bl 0x825350b4
	ctx.lr = 0x825B5838;
	sub_82535080(ctx, base);
	// 825B5838: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B583C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B5840: 3F60825B  lis r27, -0x7da5
	ctx.r[27].s64 = -2107965440;
	// 825B5844: 3F80825B  lis r28, -0x7da5
	ctx.r[28].s64 = -2107965440;
	// 825B5848: 3FA0825B  lis r29, -0x7da5
	ctx.r[29].s64 = -2107965440;
	// 825B584C: 3FC0825B  lis r30, -0x7da5
	ctx.r[30].s64 = -2107965440;
	// 825B5850: 99610082  stb r11, 0x82(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(130 as u32), ctx.r[11].u8 ) };
	// 825B5854: 3CE0825B  lis r7, -0x7da5
	ctx.r[7].s64 = -2107965440;
	// 825B5858: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 825B585C: 3D00825B  lis r8, -0x7da5
	ctx.r[8].s64 = -2107965440;
	// 825B5860: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 825B5864: 3D20825B  lis r9, -0x7da5
	ctx.r[9].s64 = -2107965440;
	// 825B5868: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 825B586C: 3D40825B  lis r10, -0x7da5
	ctx.r[10].s64 = -2107965440;
	// 825B5870: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 825B5874: 397B4C98  addi r11, r27, 0x4c98
	ctx.r[11].s64 = ctx.r[27].s64 + 19608;
	// 825B5878: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825B587C: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 825B5880: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B5884: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B5888: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825B588C: 397C4EF0  addi r11, r28, 0x4ef0
	ctx.r[11].s64 = ctx.r[28].s64 + 20208;
	// 825B5890: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 825B5894: 397D5B28  addi r11, r29, 0x5b28
	ctx.r[11].s64 = ctx.r[29].s64 + 23336;
	// 825B5898: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 825B589C: 397E59D0  addi r11, r30, 0x59d0
	ctx.r[11].s64 = ctx.r[30].s64 + 22992;
	// 825B58A0: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 825B58A4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825B58A8: 396758F8  addi r11, r7, 0x58f8
	ctx.r[11].s64 = ctx.r[7].s64 + 22776;
	// 825B58AC: 9BC10080  stb r30, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u8 ) };
	// 825B58B0: 9BC10081  stb r30, 0x81(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(129 as u32), ctx.r[30].u8 ) };
	// 825B58B4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825B58B8: 39685938  addi r11, r8, 0x5938
	ctx.r[11].s64 = ctx.r[8].s64 + 22840;
	// 825B58BC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825B58C0: 39695980  addi r11, r9, 0x5980
	ctx.r[11].s64 = ctx.r[9].s64 + 22912;
	// 825B58C4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825B58C8: 396A5A38  addi r11, r10, 0x5a38
	ctx.r[11].s64 = ctx.r[10].s64 + 23096;
	// 825B58CC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825B58D0: 4BF4A699  bl 0x824fff68
	ctx.lr = 0x825B58D4;
	sub_824FFF68(ctx, base);
	// 825B58D4: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 825B58D8: 9BC10082  stb r30, 0x82(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(130 as u32), ctx.r[30].u8 ) };
	// 825B58DC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825B58E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B58E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B58E8: 4BF4A681  bl 0x824fff68
	ctx.lr = 0x825B58EC;
	sub_824FFF68(ctx, base);
	// 825B58EC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825B58F0: 4BF7F814  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B58F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B58F8 size=60
    let mut pc: u32 = 0x825B58F8;
    'dispatch: loop {
        match pc {
            0x825B58F8 => {
    //   block [0x825B58F8..0x825B5914)
	// 825B58F8: 3864000C  addi r3, r4, 0xc
	ctx.r[3].s64 = ctx.r[4].s64 + 12;
	// 825B58FC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825B5900: 89430002  lbz r10, 2(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B5904: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825B5908: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 825B590C: 54A9043E  clrlwi r9, r5, 0x10
	ctx.r[9].u64 = ctx.r[5].u32 as u64 & 0x0000FFFFu64;
	// 825B5910: 39630006  addi r11, r3, 6
	ctx.r[11].s64 = ctx.r[3].s64 + 6;
	pc = 0x825B5914; continue 'dispatch;
            }
            0x825B5914 => {
    //   block [0x825B5914..0x825B5934)
	// 825B5914: A10B0000  lhz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5918: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B591C: 419A0018  beq cr6, 0x825b5934
	if ctx.cr[6].eq {
		sub_825B5934(ctx, base);
		return;
	}
	// 825B5920: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 825B5924: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 825B5928: 7F045000  cmpw cr6, r4, r10
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825B592C: 4198FFE8  blt cr6, 0x825b5914
	if ctx.cr[6].lt {
	pc = 0x825B5914; continue 'dispatch;
	}
	// 825B5930: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B5934(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B5934 size=4
    let mut pc: u32 = 0x825B5934;
    'dispatch: loop {
        match pc {
            0x825B5934 => {
    //   block [0x825B5934..0x825B5938)
	// 825B5934: 4800E034  b 0x825c3968
	sub_825C3968(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B5938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B5938 size=56
    let mut pc: u32 = 0x825B5938;
    'dispatch: loop {
        match pc {
            0x825B5938 => {
    //   block [0x825B5938..0x825B5950)
	// 825B5938: 3904000C  addi r8, r4, 0xc
	ctx.r[8].s64 = ctx.r[4].s64 + 12;
	// 825B593C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B5940: 89280002  lbz r9, 2(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B5944: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825B5948: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 825B594C: 39480006  addi r10, r8, 6
	ctx.r[10].s64 = ctx.r[8].s64 + 6;
	pc = 0x825B5950; continue 'dispatch;
            }
            0x825B5950 => {
    //   block [0x825B5950..0x825B5970)
	// 825B5950: A0EA0000  lhz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5954: 2B07FFFF  cmplwi cr6, r7, 0xffff
	ctx.cr[6].compare_u32(ctx.r[7].u32, 65535 as u32, &mut ctx.xer);
	// 825B5958: 419A0018  beq cr6, 0x825b5970
	if ctx.cr[6].eq {
		sub_825B5970(ctx, base);
		return;
	}
	// 825B595C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825B5960: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B5964: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825B5968: 4198FFE8  blt cr6, 0x825b5950
	if ctx.cr[6].lt {
	pc = 0x825B5950; continue 'dispatch;
	}
	// 825B596C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B5970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B5970 size=16
    let mut pc: u32 = 0x825B5970;
    'dispatch: loop {
        match pc {
            0x825B5970 => {
    //   block [0x825B5970..0x825B5980)
	// 825B5970: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B5974: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825B5978: B0AB0006  sth r5, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[5].u16 ) };
	// 825B597C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B5980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B5980 size=64
    let mut pc: u32 = 0x825B5980;
    'dispatch: loop {
        match pc {
            0x825B5980 => {
    //   block [0x825B5980..0x825B59A0)
	// 825B5980: 3964000C  addi r11, r4, 0xc
	ctx.r[11].s64 = ctx.r[4].s64 + 12;
	// 825B5984: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825B5988: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 825B598C: 892B0002  lbz r9, 2(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B5990: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825B5994: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 825B5998: 54A8043E  clrlwi r8, r5, 0x10
	ctx.r[8].u64 = ctx.r[5].u32 as u64 & 0x0000FFFFu64;
	// 825B599C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x825B59A0; continue 'dispatch;
            }
            0x825B59A0 => {
    //   block [0x825B59A0..0x825B59C0)
	// 825B59A0: A0CB0002  lhz r6, 2(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B59A4: 7F064040  cmplw cr6, r6, r8
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825B59A8: 419A0018  beq cr6, 0x825b59c0
	if ctx.cr[6].eq {
		sub_825B59C0(ctx, base);
		return;
	}
	// 825B59AC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825B59B0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 825B59B4: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825B59B8: 4198FFE8  blt cr6, 0x825b59a0
	if ctx.cr[6].lt {
	pc = 0x825B59A0; continue 'dispatch;
	}
	// 825B59BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B59C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B59C0 size=12
    let mut pc: u32 = 0x825B59C0;
    'dispatch: loop {
        match pc {
            0x825B59C0 => {
    //   block [0x825B59C0..0x825B59CC)
	// 825B59C0: 98EB0000  stb r7, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u8 ) };
	// 825B59C4: 98EB0001  stb r7, 1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1 as u32), ctx.r[7].u8 ) };
	// 825B59C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B59D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B59D0 size=100
    let mut pc: u32 = 0x825B59D0;
    'dispatch: loop {
        match pc {
            0x825B59D0 => {
    //   block [0x825B59D0..0x825B5A34)
	// 825B59D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B59D4: 4BF7F6E9  bl 0x825350bc
	ctx.lr = 0x825B59D8;
	sub_82535080(ctx, base);
	// 825B59D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B59DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B59E0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825B59E4: 3BFE000C  addi r31, r30, 0xc
	ctx.r[31].s64 = ctx.r[30].s64 + 12;
	// 825B59E8: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 825B59EC: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 825B59F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B59F4: 4800D025  bl 0x825c2a18
	ctx.lr = 0x825B59F8;
	sub_825C2A18(ctx, base);
	// 825B59F8: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B59FC: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B5A00: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825B5A04: 556B103E  rotlwi r11, r11, 2
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 825B5A08: 895F0000  lbz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5A0C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825B5A10: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B5A14: 991D0002  stb r8, 2(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(2 as u32), ctx.r[8].u8 ) };
	// 825B5A18: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 825B5A1C: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B5A20: 396B001B  addi r11, r11, 0x1b
	ctx.r[11].s64 = ctx.r[11].s64 + 27;
	// 825B5A24: 556B0036  rlwinm r11, r11, 0, 0, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B5A28: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 825B5A2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B5A30: 4BF7F6DC  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B5A38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B5A38 size=68
    let mut pc: u32 = 0x825B5A38;
    'dispatch: loop {
        match pc {
            0x825B5A38 => {
    //   block [0x825B5A38..0x825B5A7C)
	// 825B5A38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B5A3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B5A40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B5A44: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B5A48: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 825B5A4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B5A50: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 825B5A54: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 825B5A58: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 825B5A5C: 4800CFBD  bl 0x825c2a18
	ctx.lr = 0x825B5A60;
	sub_825C2A18(ctx, base);
	// 825B5A60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B5A64: 997F0002  stb r11, 2(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(2 as u32), ctx.r[11].u8 ) };
	// 825B5A68: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825B5A6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B5A70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B5A74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B5A78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B5A80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B5A80 size=164
    let mut pc: u32 = 0x825B5A80;
    'dispatch: loop {
        match pc {
            0x825B5A80 => {
    //   block [0x825B5A80..0x825B5AC8)
	// 825B5A80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B5A84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B5A88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825B5A8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B5A90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B5A94: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B5A98: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825B5A9C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5AA0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B5AA4: 38C30010  addi r6, r3, 0x10
	ctx.r[6].s64 = ctx.r[3].s64 + 16;
	// 825B5AA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B5AAC: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5AB0: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5AB4: 8165000C  lwz r11, 0xc(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B5AB8: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 825B5ABC: 409A000C  bne cr6, 0x825b5ac8
	if !ctx.cr[6].eq {
	pc = 0x825B5AC8; continue 'dispatch;
	}
	// 825B5AC0: 4800F371  bl 0x825c4e30
	ctx.lr = 0x825B5AC4;
	sub_825C4E30(ctx, base);
	// 825B5AC4: 48000008  b 0x825b5acc
	pc = 0x825B5ACC; continue 'dispatch;
            }
            0x825B5AC8 => {
    //   block [0x825B5AC8..0x825B5ACC)
	// 825B5AC8: 4800F181  bl 0x825c4c48
	ctx.lr = 0x825B5ACC;
	sub_825C4C48(ctx, base);
	pc = 0x825B5ACC; continue 'dispatch;
            }
            0x825B5ACC => {
    //   block [0x825B5ACC..0x825B5B24)
	// 825B5ACC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B5AD0: 997E0002  stb r11, 2(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(2 as u32), ctx.r[11].u8 ) };
	// 825B5AD4: 895F000B  lbz r10, 0xb(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(11 as u32) ) } as u64;
	// 825B5AD8: 714A00EF  andi. r10, r10, 0xef
	ctx.r[10].u64 = ctx.r[10].u64 & 239;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825B5ADC: 995F000B  stb r10, 0xb(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(11 as u32), ctx.r[10].u8 ) };
	// 825B5AE0: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 825B5AE4: 897F000E  lbz r11, 0xe(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(14 as u32) ) } as u64;
	// 825B5AE8: 893F000D  lbz r9, 0xd(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(13 as u32) ) } as u64;
	// 825B5AEC: 556B103E  rotlwi r11, r11, 2
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 825B5AF0: 895F000C  lbz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B5AF4: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825B5AF8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B5AFC: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B5B00: 396B001F  addi r11, r11, 0x1f
	ctx.r[11].s64 = ctx.r[11].s64 + 31;
	// 825B5B04: 556B0036  rlwinm r11, r11, 0, 0, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B5B08: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825B5B0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B5B10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B5B14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B5B18: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825B5B1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B5B20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B5B28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B5B28 size=300
    let mut pc: u32 = 0x825B5B28;
    'dispatch: loop {
        match pc {
            0x825B5B28 => {
    //   block [0x825B5B28..0x825B5BF4)
	// 825B5B28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B5B2C: 4BF7F589  bl 0x825350b4
	ctx.lr = 0x825B5B30;
	sub_82535080(ctx, base);
	// 825B5B30: 9421FDF0  stwu r1, -0x210(r1)
	ea = ctx.r[1].u32.wrapping_add(-528 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B5B34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B5B38: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825B5B3C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 825B5B40: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 825B5B44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B5B48: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5B4C: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B5B50: 897F000A  lbz r11, 0xa(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10 as u32) ) } as u64;
	// 825B5B54: 88BF0008  lbz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B5B58: 83AA0000  lwz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5B5C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825B5B60: 83890000  lwz r28, 0(r9)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5B64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825B5B68: 90A10060  stw r5, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[5].u32 ) };
	// 825B5B6C: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 825B5B70: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 825B5B74: 895F0009  lbz r10, 9(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(9 as u32) ) } as u64;
	// 825B5B78: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 825B5B7C: 556AE13E  srwi r10, r11, 4
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825B5B80: 556B073E  clrlwi r11, r11, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 825B5B84: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 825B5B88: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 825B5B8C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5B90: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 825B5B94: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B5B98: 4E800421  bctrl
	ctx.lr = 0x825B5B9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B5B9C: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825B5BA0: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5BA4: 38C10140  addi r6, r1, 0x140
	ctx.r[6].s64 = ctx.r[1].s64 + 320;
	// 825B5BA8: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B5BAC: 80A10064  lwz r5, 0x64(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825B5BB0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825B5BB4: 7C8BFA14  add r4, r11, r31
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825B5BB8: 816A0034  lwz r11, 0x34(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) } as u64;
	// 825B5BBC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B5BC0: 4E800421  bctrl
	ctx.lr = 0x825B5BC4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B5BC4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825B5BC8: 38DE0010  addi r6, r30, 0x10
	ctx.r[6].s64 = ctx.r[30].s64 + 16;
	// 825B5BCC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825B5BD0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825B5BD4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B5BD8: 48011D59  bl 0x825c7930
	ctx.lr = 0x825B5BDC;
	sub_825C7930(ctx, base);
	// 825B5BDC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825B5BE0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B5BE4: 419A0010  beq cr6, 0x825b5bf4
	if ctx.cr[6].eq {
	pc = 0x825B5BF4; continue 'dispatch;
	}
	// 825B5BE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B5BEC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B5BF0: 480106D1  bl 0x825c62c0
	ctx.lr = 0x825B5BF4;
	sub_825C62C0(ctx, base);
            }
            0x825B5BF4 => {
    //   block [0x825B5BF4..0x825B5C54)
	// 825B5BF4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5BF8: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825B5BFC: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 825B5C00: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B5C58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B5C58 size=1104
    let mut pc: u32 = 0x825B5C58;
    'dispatch: loop {
        match pc {
            0x825B5C58 => {
    //   block [0x825B5C58..0x825B5CB0)
	// 825B5C58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B5C5C: 4BF7F429  bl 0x82535084
	ctx.lr = 0x825B5C60;
	sub_82535080(ctx, base);
	// 825B5C60: 9421FDC0  stwu r1, -0x240(r1)
	ea = ctx.r[1].u32.wrapping_add(-576 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B5C64: 828D0000  lwz r20, 0(r13)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5C68: 3AA00014  li r21, 0x14
	ctx.r[21].s64 = 20;
	// 825B5C6C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825B5C70: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 825B5C74: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 825B5C78: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 825B5C7C: 7D75A02E  lwzx r11, r21, r20
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[21].u32.wrapping_add(ctx.r[20].u32)) } as u64;
	// 825B5C80: 7CF73B78  mr r23, r7
	ctx.r[23].u64 = ctx.r[7].u64;
	// 825B5C84: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B5C88: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B5C8C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B5C90: 40980020  bge cr6, 0x825b5cb0
	if !ctx.cr[6].lt {
	pc = 0x825B5CB0; continue 'dispatch;
	}
	// 825B5C94: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825B5C98: 3929A190  addi r9, r9, -0x5e70
	ctx.r[9].s64 = ctx.r[9].s64 + -24176;
	// 825B5C9C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B5CA0: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 825B5CA4: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 825B5CA8: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B5CAC: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x825B5CB0; continue 'dispatch;
            }
            0x825B5CB0 => {
    //   block [0x825B5CB0..0x825B5CDC)
	// 825B5CB0: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B5CB4: C17A0050  lfs f11, 0x50(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825B5CB8: 3BF8000C  addi r31, r24, 0xc
	ctx.r[31].s64 = ctx.r[24].s64 + 12;
	// 825B5CBC: 810B0060  lwz r8, 0x60(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 825B5CC0: 81680010  lwz r11, 0x10(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) } as u64;
	// 825B5CC4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B5CC8: 419A012C  beq cr6, 0x825b5df4
	if ctx.cr[6].eq {
	pc = 0x825B5DF4; continue 'dispatch;
	}
	// 825B5CCC: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5CD0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B5CD4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B5CD8: 419A0014  beq cr6, 0x825b5cec
	if ctx.cr[6].eq {
	pc = 0x825B5CEC; continue 'dispatch;
	}
	pc = 0x825B5CDC; continue 'dispatch;
            }
            0x825B5CDC => {
    //   block [0x825B5CDC..0x825B5CEC)
	// 825B5CDC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 825B5CE0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B5CE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B5CE8: 409AFFF4  bne cr6, 0x825b5cdc
	if !ctx.cr[6].eq {
	pc = 0x825B5CDC; continue 'dispatch;
	}
	pc = 0x825B5CEC; continue 'dispatch;
            }
            0x825B5CEC => {
    //   block [0x825B5CEC..0x825B5D00)
	// 825B5CEC: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B5CF0: C1AB0048  lfs f13, 0x48(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825B5CF4: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B5CF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B5CFC: 419A0014  beq cr6, 0x825b5d10
	if ctx.cr[6].eq {
	pc = 0x825B5D10; continue 'dispatch;
	}
	pc = 0x825B5D00; continue 'dispatch;
            }
            0x825B5D00 => {
    //   block [0x825B5D00..0x825B5D10)
	// 825B5D00: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B5D04: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B5D08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B5D0C: 409AFFF4  bne cr6, 0x825b5d00
	if !ctx.cr[6].eq {
	pc = 0x825B5D00; continue 'dispatch;
	}
	pc = 0x825B5D10; continue 'dispatch;
            }
            0x825B5D10 => {
    //   block [0x825B5D10..0x825B5D6C)
	// 825B5D10: C00A0048  lfs f0, 0x48(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(72 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B5D14: ED0D0028  fsubs f8, f13, f0
	ctx.f[8].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 825B5D18: C1480018  lfs f10, 0x18(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825B5D1C: C19E000C  lfs f12, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825B5D20: C1280014  lfs f9, 0x14(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(20 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 825B5D24: FC28682E  fsel f1, f8, f0, f13
	ctx.f[1].f64 = if ctx.f[8].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 825B5D28: EC090072  fmuls f0, f9, f1
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[1].f64) as f32) as f64);
	// 825B5D2C: EDAA607A  fmadds f13, f10, f1, f12
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[1].f64 + ctx.f[12].f64) as f32) as f64);
	// 825B5D30: ED406828  fsubs f10, f0, f13
	ctx.f[10].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 825B5D34: FC4A036E  fsel f2, f10, f13, f0
	ctx.f[2].f64 = if ctx.f[10].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[0].f64 };
	// 825B5D38: FF0B1000  fcmpu cr6, f11, f2
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[2].f64);
	// 825B5D3C: 409800B8  bge cr6, 0x825b5df4
	if !ctx.cr[6].lt {
	pc = 0x825B5DF4; continue 'dispatch;
	}
	// 825B5D40: C1A80028  lfs f13, 0x28(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825B5D44: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 825B5D48: C0080024  lfs f0, 0x24(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B5D4C: EDAD607A  fmadds f13, f13, f1, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[1].f64 + ctx.f[12].f64) as f32) as f64);
	// 825B5D50: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 825B5D54: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 825B5D58: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 825B5D5C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825B5D60: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 825B5D64: FC6C036E  fsel f3, f12, f13, f0
	ctx.f[3].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[0].f64 };
	// 825B5D68: 48019E01  bl 0x825cfb68
	ctx.lr = 0x825B5D6C;
	sub_825CFB68(ctx, base);
	pc = 0x825B5D6C; continue 'dispatch;
            }
            0x825B5D6C => {
    //   block [0x825B5D6C..0x825B5D8C)
	// 825B5D6C: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 825B5D70: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 825B5D74: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 825B5D78: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 825B5D7C: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 825B5D80: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 825B5D84: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825B5D88: 4801AE41  bl 0x825d0bc8
	ctx.lr = 0x825B5D8C;
	sub_825D0BC8(ctx, base);
	pc = 0x825B5D8C; continue 'dispatch;
            }
            0x825B5D8C => {
    //   block [0x825B5D8C..0x825B5DEC)
	// 825B5D8C: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B5D90: 99760002  stb r11, 2(r22)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[22].u32.wrapping_add(2 as u32), ctx.r[11].u8 ) };
	// 825B5D94: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B5D98: 891F0001  lbz r8, 1(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B5D9C: 554A103E  rotlwi r10, r10, 2
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 825B5DA0: 893F0000  lbz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5DA4: 7D75A02E  lwzx r11, r21, r20
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[21].u32.wrapping_add(ctx.r[20].u32)) } as u64;
	// 825B5DA8: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 825B5DAC: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825B5DB0: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825B5DB4: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B5DB8: 394A001F  addi r10, r10, 0x1f
	ctx.r[10].s64 = ctx.r[10].s64 + 31;
	// 825B5DBC: 554A0036  rlwinm r10, r10, 0, 0, 0x1b
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 825B5DC0: 7C6AC214  add r3, r10, r24
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[24].u64;
	// 825B5DC4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B5DC8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B5DCC: 40980020  bge cr6, 0x825b5dec
	if !ctx.cr[6].lt {
	pc = 0x825B5DEC; continue 'dispatch;
	}
	// 825B5DD0: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 825B5DD4: 392974DC  addi r9, r9, 0x74dc
	ctx.r[9].s64 = ctx.r[9].s64 + 29916;
	// 825B5DD8: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B5DDC: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 825B5DE0: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 825B5DE4: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B5DE8: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x825B5DEC; continue 'dispatch;
            }
            0x825B5DEC => {
    //   block [0x825B5DEC..0x825B5DF4)
	// 825B5DEC: 38210240  addi r1, r1, 0x240
	ctx.r[1].s64 = ctx.r[1].s64 + 576;
	// 825B5DF0: 4BF7F2E4  b 0x825350d4
	sub_825350D0(ctx, base);
	return;
            }
            0x825B5DF4 => {
    //   block [0x825B5DF4..0x825B60A8)
	// 825B5DF4: C008000C  lfs f0, 0xc(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B5DF8: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 825B5DFC: 4099FF70  ble cr6, 0x825b5d6c
	if !ctx.cr[6].gt {
	pc = 0x825B5D6C; continue 'dispatch;
	}
	// 825B5E00: 8978000B  lbz r11, 0xb(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[24].u32.wrapping_add(11 as u32) ) } as u64;
	// 825B5E04: 556B06F6  rlwinm r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B5E08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B5E0C: 409AFF60  bne cr6, 0x825b5d6c
	if !ctx.cr[6].eq {
	pc = 0x825B5D6C; continue 'dispatch;
	}
	// 825B5E10: D17E000C  stfs f11, 0xc(r30)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 825B5E14: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B5E18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B5E1C: 419AFF70  beq cr6, 0x825b5d8c
	if ctx.cr[6].eq {
	pc = 0x825B5D8C; continue 'dispatch;
	}
	// 825B5E20: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B60A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B60A8 size=108
    let mut pc: u32 = 0x825B60A8;
    'dispatch: loop {
        match pc {
            0x825B60A8 => {
    //   block [0x825B60A8..0x825B6114)
	// 825B60A8: 3CC0825B  lis r6, -0x7da5
	ctx.r[6].s64 = -2107965440;
	// 825B60AC: 3C80825B  lis r4, -0x7da5
	ctx.r[4].s64 = -2107965440;
	// 825B60B0: 38C65B28  addi r6, r6, 0x5b28
	ctx.r[6].s64 = ctx.r[6].s64 + 23336;
	// 825B60B4: 3CA0825B  lis r5, -0x7da5
	ctx.r[5].s64 = -2107965440;
	// 825B60B8: 3CE0825B  lis r7, -0x7da5
	ctx.r[7].s64 = -2107965440;
	// 825B60BC: 3D00825B  lis r8, -0x7da5
	ctx.r[8].s64 = -2107965440;
	// 825B60C0: 3D20825B  lis r9, -0x7da5
	ctx.r[9].s64 = -2107965440;
	// 825B60C4: 3D40825B  lis r10, -0x7da5
	ctx.r[10].s64 = -2107965440;
	// 825B60C8: 90C30028  stw r6, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[6].u32 ) };
	// 825B60CC: 3D60825B  lis r11, -0x7da5
	ctx.r[11].s64 = -2107965440;
	// 825B60D0: 38845A80  addi r4, r4, 0x5a80
	ctx.r[4].s64 = ctx.r[4].s64 + 23168;
	// 825B60D4: 38A55C58  addi r5, r5, 0x5c58
	ctx.r[5].s64 = ctx.r[5].s64 + 23640;
	// 825B60D8: 38E759D0  addi r7, r7, 0x59d0
	ctx.r[7].s64 = ctx.r[7].s64 + 22992;
	// 825B60DC: 390858F8  addi r8, r8, 0x58f8
	ctx.r[8].s64 = ctx.r[8].s64 + 22776;
	// 825B60E0: 39295938  addi r9, r9, 0x5938
	ctx.r[9].s64 = ctx.r[9].s64 + 22840;
	// 825B60E4: 394A5980  addi r10, r10, 0x5980
	ctx.r[10].s64 = ctx.r[10].s64 + 22912;
	// 825B60E8: 90830000  stw r4, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 825B60EC: 396B5A38  addi r11, r11, 0x5a38
	ctx.r[11].s64 = ctx.r[11].s64 + 23096;
	// 825B60F0: 90A3002C  stw r5, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[5].u32 ) };
	// 825B60F4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825B60F8: 90E30008  stw r7, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 825B60FC: 9103000C  stw r8, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 825B6100: 91230010  stw r9, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 825B6104: 91430014  stw r10, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 825B6108: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825B610C: 98C30030  stb r6, 0x30(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[6].u8 ) };
	// 825B6110: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B6118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B6118 size=168
    let mut pc: u32 = 0x825B6118;
    'dispatch: loop {
        match pc {
            0x825B6118 => {
    //   block [0x825B6118..0x825B61C0)
	// 825B6118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B611C: 4BF7EF9D  bl 0x825350b8
	ctx.lr = 0x825B6120;
	sub_82535080(ctx, base);
	// 825B6120: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B6124: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B6128: 3F80825B  lis r28, -0x7da5
	ctx.r[28].s64 = -2107965440;
	// 825B612C: 3FA0825B  lis r29, -0x7da5
	ctx.r[29].s64 = -2107965440;
	// 825B6130: 3FC0825B  lis r30, -0x7da5
	ctx.r[30].s64 = -2107965440;
	// 825B6134: 3FE0825B  lis r31, -0x7da5
	ctx.r[31].s64 = -2107965440;
	// 825B6138: 99610081  stb r11, 0x81(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(129 as u32), ctx.r[11].u8 ) };
	// 825B613C: 3CE0825B  lis r7, -0x7da5
	ctx.r[7].s64 = -2107965440;
	// 825B6140: 99610082  stb r11, 0x82(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(130 as u32), ctx.r[11].u8 ) };
	// 825B6144: 3D00825B  lis r8, -0x7da5
	ctx.r[8].s64 = -2107965440;
	// 825B6148: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 825B614C: 3D20825B  lis r9, -0x7da5
	ctx.r[9].s64 = -2107965440;
	// 825B6150: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 825B6154: 3D40825B  lis r10, -0x7da5
	ctx.r[10].s64 = -2107965440;
	// 825B6158: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 825B615C: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 825B6160: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 825B6164: 397C5A80  addi r11, r28, 0x5a80
	ctx.r[11].s64 = ctx.r[28].s64 + 23168;
	// 825B6168: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 825B616C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B6170: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825B6174: 397D5C58  addi r11, r29, 0x5c58
	ctx.r[11].s64 = ctx.r[29].s64 + 23640;
	// 825B6178: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 825B617C: 397E5B28  addi r11, r30, 0x5b28
	ctx.r[11].s64 = ctx.r[30].s64 + 23336;
	// 825B6180: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 825B6184: 397F59D0  addi r11, r31, 0x59d0
	ctx.r[11].s64 = ctx.r[31].s64 + 22992;
	// 825B6188: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825B618C: 396758F8  addi r11, r7, 0x58f8
	ctx.r[11].s64 = ctx.r[7].s64 + 22776;
	// 825B6190: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825B6194: 39685938  addi r11, r8, 0x5938
	ctx.r[11].s64 = ctx.r[8].s64 + 22840;
	// 825B6198: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825B619C: 39695980  addi r11, r9, 0x5980
	ctx.r[11].s64 = ctx.r[9].s64 + 22912;
	// 825B61A0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825B61A4: 396A5A38  addi r11, r10, 0x5a38
	ctx.r[11].s64 = ctx.r[10].s64 + 23096;
	// 825B61A8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825B61AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B61B0: 99610080  stb r11, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u8 ) };
	// 825B61B4: 4BF49DB5  bl 0x824fff68
	ctx.lr = 0x825B61B8;
	sub_824FFF68(ctx, base);
	// 825B61B8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825B61BC: 4BF7EF4C  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B61C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B61C0 size=44
    let mut pc: u32 = 0x825B61C0;
    'dispatch: loop {
        match pc {
            0x825B61C0 => {
    //   block [0x825B61C0..0x825B61CC)
	// 825B61C0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825B61C4: 54A9043E  clrlwi r9, r5, 0x10
	ctx.r[9].u64 = ctx.r[5].u32 as u64 & 0x0000FFFFu64;
	// 825B61C8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	pc = 0x825B61CC; continue 'dispatch;
            }
            0x825B61CC => {
    //   block [0x825B61CC..0x825B61EC)
	// 825B61CC: A10B0000  lhz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B61D0: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B61D4: 419A0018  beq cr6, 0x825b61ec
	if ctx.cr[6].eq {
		sub_825B61EC(ctx, base);
		return;
	}
	// 825B61D8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825B61DC: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 825B61E0: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 825B61E4: 4198FFE8  blt cr6, 0x825b61cc
	if ctx.cr[6].lt {
	pc = 0x825B61CC; continue 'dispatch;
	}
	// 825B61E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B61EC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B61EC size=16
    let mut pc: u32 = 0x825B61EC;
    'dispatch: loop {
        match pc {
            0x825B61EC => {
    //   block [0x825B61EC..0x825B61FC)
	// 825B61EC: 554B083C  slwi r11, r10, 1
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B61F0: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 825B61F4: 7D4B232E  sthx r10, r11, r4
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32), ctx.r[10].u16) };
	// 825B61F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B6200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B6200 size=40
    let mut pc: u32 = 0x825B6200;
    'dispatch: loop {
        match pc {
            0x825B6200 => {
    //   block [0x825B6200..0x825B6208)
	// 825B6200: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B6204: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	pc = 0x825B6208; continue 'dispatch;
            }
            0x825B6208 => {
    //   block [0x825B6208..0x825B6228)
	// 825B6208: A12A0000  lhz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B620C: 2B09FFFF  cmplwi cr6, r9, 0xffff
	ctx.cr[6].compare_u32(ctx.r[9].u32, 65535 as u32, &mut ctx.xer);
	// 825B6210: 419A0018  beq cr6, 0x825b6228
	if ctx.cr[6].eq {
		sub_825B6228(ctx, base);
		return;
	}
	// 825B6214: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825B6218: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 825B621C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 825B6220: 4198FFE8  blt cr6, 0x825b6208
	if ctx.cr[6].lt {
	pc = 0x825B6208; continue 'dispatch;
	}
	// 825B6224: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B6228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B6228 size=12
    let mut pc: u32 = 0x825B6228;
    'dispatch: loop {
        match pc {
            0x825B6228 => {
    //   block [0x825B6228..0x825B6234)
	// 825B6228: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B622C: 7CAB232E  sthx r5, r11, r4
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32), ctx.r[5].u16) };
	// 825B6230: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B6238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B6238 size=4
    let mut pc: u32 = 0x825B6238;
    'dispatch: loop {
        match pc {
            0x825B6238 => {
    //   block [0x825B6238..0x825B623C)
	// 825B6238: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B6240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B6240 size=108
    let mut pc: u32 = 0x825B6240;
    'dispatch: loop {
        match pc {
            0x825B6240 => {
    //   block [0x825B6240..0x825B62AC)
	// 825B6240: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B6244: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B6248: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B624C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B6250: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 825B6254: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B6258: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825B625C: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 825B6260: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 825B6264: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825B6268: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 825B626C: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 825B6270: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 825B6274: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B6278: 389F0008  addi r4, r31, 8
	ctx.r[4].s64 = ctx.r[31].s64 + 8;
	// 825B627C: 386B0020  addi r3, r11, 0x20
	ctx.r[3].s64 = ctx.r[11].s64 + 32;
	// 825B6280: 990A0002  stb r8, 2(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(2 as u32), ctx.r[8].u8 ) };
	// 825B6284: B0FF0000  sth r7, 0(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
	// 825B6288: B0DF0002  sth r6, 2(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(2 as u32), ctx.r[6].u16 ) };
	// 825B628C: B0BF0004  sth r5, 4(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[5].u16 ) };
	// 825B6290: 48012A01  bl 0x825c8c90
	ctx.lr = 0x825B6294;
	sub_825C8C90(ctx, base);
	// 825B6294: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 825B6298: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825B629C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B62A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B62A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B62A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B62B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B62B0 size=108
    let mut pc: u32 = 0x825B62B0;
    'dispatch: loop {
        match pc {
            0x825B62B0 => {
    //   block [0x825B62B0..0x825B62D8)
	// 825B62B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B62B4: 4BF7EDFD  bl 0x825350b0
	ctx.lr = 0x825B62B8;
	sub_82535080(ctx, base);
	// 825B62B8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B62BC: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 825B62C0: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 825B62C4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825B62C8: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825B62CC: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 825B62D0: 3B600003  li r27, 3
	ctx.r[27].s64 = 3;
	// 825B62D4: 617DFFFF  ori r29, r11, 0xffff
	ctx.r[29].u64 = ctx.r[11].u64 | 65535;
	pc = 0x825B62D8; continue 'dispatch;
            }
            0x825B62D8 => {
    //   block [0x825B62D8..0x825B6300)
	// 825B62D8: A09F0000  lhz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B62DC: 2B04FFFF  cmplwi cr6, r4, 0xffff
	ctx.cr[6].compare_u32(ctx.r[4].u32, 65535 as u32, &mut ctx.xer);
	// 825B62E0: 419A0020  beq cr6, 0x825b6300
	if ctx.cr[6].eq {
	pc = 0x825B6300; continue 'dispatch;
	}
	// 825B62E4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B62E8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825B62EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B62F0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B62F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B62F8: 4E800421  bctrl
	ctx.lr = 0x825B62FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B62FC: B3BF0000  sth r29, 0(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u16 ) };
            }
            0x825B6300 => {
    //   block [0x825B6300..0x825B631C)
	// 825B6300: 3B7BFFFF  addi r27, r27, -1
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	// 825B6304: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 825B6308: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 825B630C: 409AFFCC  bne cr6, 0x825b62d8
	if !ctx.cr[6].eq {
	pc = 0x825B62D8; continue 'dispatch;
	}
	// 825B6310: 387A0020  addi r3, r26, 0x20
	ctx.r[3].s64 = ctx.r[26].s64 + 32;
	// 825B6314: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825B6318: 4BF7EDE8  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B6328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B6328 size=504
    let mut pc: u32 = 0x825B6328;
    'dispatch: loop {
        match pc {
            0x825B6328 => {
    //   block [0x825B6328..0x825B6520)
	// 825B6328: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B632C: 4BF7ED71  bl 0x8253509c
	ctx.lr = 0x825B6330;
	sub_82535080(ctx, base);
	// 825B6330: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B6334: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B6338: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 825B633C: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B6340: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 825B6344: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 825B6348: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 825B634C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825B6350: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B6354: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 825B6358: 834A0000  lwz r26, 0(r10)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B635C: 3B8100A0  addi r28, r1, 0xa0
	ctx.r[28].s64 = ctx.r[1].s64 + 160;
	// 825B6360: 394B0010  addi r10, r11, 0x10
	ctx.r[10].s64 = ctx.r[11].s64 + 16;
	// 825B6364: 837F0000  lwz r27, 0(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B6368: 388B0020  addi r4, r11, 0x20
	ctx.r[4].s64 = ctx.r[11].s64 + 32;
	// 825B636C: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 825B6370: EB0B0000  ld r24, 0(r11)
	ctx.r[24].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 825B6374: 3BBA0030  addi r29, r26, 0x30
	ctx.r[29].s64 = ctx.r[26].s64 + 48;
	// 825B6378: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 825B637C: EAEA0000  ld r23, 0(r10)
	ctx.r[23].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 825B6380: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 825B6384: EAC40000  ld r22, 0(r4)
	ctx.r[22].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	// 825B6388: FB090000  std r24, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[24].u64 ) };
	// 825B638C: F9690008  std r11, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 825B6390: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 825B6394: FAE80000  std r23, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[23].u64 ) };
	// 825B6398: F9480008  std r10, 8(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 825B639C: E8840008  ld r4, 8(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	// 825B63A0: FAC70000  std r22, 0(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[22].u64 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B6520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B6520 size=976
    let mut pc: u32 = 0x825B6520;
    'dispatch: loop {
        match pc {
            0x825B6520 => {
    //   block [0x825B6520..0x825B6578)
	// 825B6520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B6524: 4BF7EB61  bl 0x82535084
	ctx.lr = 0x825B6528;
	sub_82535080(ctx, base);
	// 825B6528: 9421FE30  stwu r1, -0x1d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-464 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B652C: 824D0000  lwz r18, 0(r13)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B6530: 3A600014  li r19, 0x14
	ctx.r[19].s64 = 20;
	// 825B6534: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825B6538: 7C942378  mr r20, r4
	ctx.r[20].u64 = ctx.r[4].u64;
	// 825B653C: 7CB52B78  mr r21, r5
	ctx.r[21].u64 = ctx.r[5].u64;
	// 825B6540: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 825B6544: 7D73902E  lwzx r11, r19, r18
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[18].u32)) } as u64;
	// 825B6548: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 825B654C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B6550: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B6554: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B6558: 40980020  bge cr6, 0x825b6578
	if !ctx.cr[6].lt {
	pc = 0x825B6578; continue 'dispatch;
	}
	// 825B655C: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825B6560: 3929A1C0  addi r9, r9, -0x5e40
	ctx.r[9].s64 = ctx.r[9].s64 + -24128;
	// 825B6564: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B6568: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 825B656C: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 825B6570: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B6574: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x825B6578; continue 'dispatch;
            }
            0x825B6578 => {
    //   block [0x825B6578..0x825B68F0)
	// 825B6578: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B657C: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 825B6580: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 825B6584: 807A0004  lwz r3, 4(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B6588: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 825B658C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825B6590: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 825B6594: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B6598: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 825B659C: 836A0000  lwz r27, 0(r10)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B65A0: 3BA100A0  addi r29, r1, 0xa0
	ctx.r[29].s64 = ctx.r[1].s64 + 160;
	// 825B65A4: 394B0010  addi r10, r11, 0x10
	ctx.r[10].s64 = ctx.r[11].s64 + 16;
	// 825B65A8: 83830000  lwz r28, 0(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B65AC: 38AB0020  addi r5, r11, 0x20
	ctx.r[5].s64 = ctx.r[11].s64 + 32;
	// 825B65B0: 388B0030  addi r4, r11, 0x30
	ctx.r[4].s64 = ctx.r[11].s64 + 48;
	// 825B65B4: EACB0000  ld r22, 0(r11)
	ctx.r[22].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 825B65B8: 3BDB0030  addi r30, r27, 0x30
	ctx.r[30].s64 = ctx.r[27].s64 + 48;
	// 825B65BC: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 825B65C0: EA2A0000  ld r17, 0(r10)
	ctx.r[17].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 825B65C4: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 825B65C8: EA050000  ld r16, 0(r5)
	ctx.r[16].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	// 825B65CC: FAC90000  std r22, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[22].u64 ) };
	// 825B65D0: F9690008  std r11, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 825B65D4: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 825B65D8: FA280000  std r17, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[17].u64 ) };
	// 825B65DC: F9480008  std r10, 8(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 825B65E0: E8A50008  ld r5, 8(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	// 825B65E4: FA070000  std r16, 0(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[16].u64 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B68F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B68F0 size=164
    let mut pc: u32 = 0x825B68F0;
    'dispatch: loop {
        match pc {
            0x825B68F0 => {
    //   block [0x825B68F0..0x825B6994)
	// 825B68F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B68F4: 4BF7E7C5  bl 0x825350b8
	ctx.lr = 0x825B68F8;
	sub_82535080(ctx, base);
	// 825B68F8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B68FC: 3F80825B  lis r28, -0x7da5
	ctx.r[28].s64 = -2107965440;
	// 825B6900: 3FA0825B  lis r29, -0x7da5
	ctx.r[29].s64 = -2107965440;
	// 825B6904: 3FC0825B  lis r30, -0x7da5
	ctx.r[30].s64 = -2107965440;
	// 825B6908: 3FE0825B  lis r31, -0x7da5
	ctx.r[31].s64 = -2107965440;
	// 825B690C: 3CE0825B  lis r7, -0x7da5
	ctx.r[7].s64 = -2107965440;
	// 825B6910: 3D00825B  lis r8, -0x7da5
	ctx.r[8].s64 = -2107965440;
	// 825B6914: 3D20825B  lis r9, -0x7da5
	ctx.r[9].s64 = -2107965440;
	// 825B6918: 3D40825B  lis r10, -0x7da5
	ctx.r[10].s64 = -2107965440;
	// 825B691C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B6920: 38E761C0  addi r7, r7, 0x61c0
	ctx.r[7].s64 = ctx.r[7].s64 + 25024;
	// 825B6924: 39086200  addi r8, r8, 0x6200
	ctx.r[8].s64 = ctx.r[8].s64 + 25088;
	// 825B6928: 39296238  addi r9, r9, 0x6238
	ctx.r[9].s64 = ctx.r[9].s64 + 25144;
	// 825B692C: 394A6320  addi r10, r10, 0x6320
	ctx.r[10].s64 = ctx.r[10].s64 + 25376;
	// 825B6930: 3B9C6240  addi r28, r28, 0x6240
	ctx.r[28].s64 = ctx.r[28].s64 + 25152;
	// 825B6934: 99610081  stb r11, 0x81(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(129 as u32), ctx.r[11].u8 ) };
	// 825B6938: 3BBD6520  addi r29, r29, 0x6520
	ctx.r[29].s64 = ctx.r[29].s64 + 25888;
	// 825B693C: 99610082  stb r11, 0x82(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(130 as u32), ctx.r[11].u8 ) };
	// 825B6940: 3BDE6328  addi r30, r30, 0x6328
	ctx.r[30].s64 = ctx.r[30].s64 + 25384;
	// 825B6944: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 825B6948: 3BFF62B0  addi r31, r31, 0x62b0
	ctx.r[31].s64 = ctx.r[31].s64 + 25264;
	// 825B694C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 825B6950: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 825B6954: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 825B6958: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 825B695C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825B6960: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B6964: 93A1007C  stw r29, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[29].u32 ) };
	// 825B6968: 93C10078  stw r30, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 825B696C: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825B6970: 90E1005C  stw r7, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[7].u32 ) };
	// 825B6974: 91010060  stw r8, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 825B6978: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 825B697C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 825B6980: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B6984: 99610080  stb r11, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u8 ) };
	// 825B6988: 4BF495E1  bl 0x824fff68
	ctx.lr = 0x825B698C;
	sub_824FFF68(ctx, base);
	// 825B698C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825B6990: 4BF7E778  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B6998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B6998 size=132
    let mut pc: u32 = 0x825B6998;
    'dispatch: loop {
        match pc {
            0x825B6998 => {
    //   block [0x825B6998..0x825B69C8)
	// 825B6998: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B699C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B69A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B69A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B69A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B69AC: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825B69B0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825B69B4: 89430021  lbz r10, 0x21(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(33 as u32) ) } as u64;
	// 825B69B8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825B69BC: 4099004C  ble cr6, 0x825b6a08
	if !ctx.cr[6].gt {
	pc = 0x825B6A08; continue 'dispatch;
	}
	// 825B69C0: 54A9043E  clrlwi r9, r5, 0x10
	ctx.r[9].u64 = ctx.r[5].u32 as u64 & 0x0000FFFFu64;
	// 825B69C4: 39630002  addi r11, r3, 2
	ctx.r[11].s64 = ctx.r[3].s64 + 2;
	pc = 0x825B69C8; continue 'dispatch;
            }
            0x825B69C8 => {
    //   block [0x825B69C8..0x825B69F8)
	// 825B69C8: A10B0000  lhz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B69CC: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B69D0: 419A0028  beq cr6, 0x825b69f8
	if ctx.cr[6].eq {
	pc = 0x825B69F8; continue 'dispatch;
	}
	// 825B69D4: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 825B69D8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825B69DC: 7F045000  cmpw cr6, r4, r10
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825B69E0: 4198FFE8  blt cr6, 0x825b69c8
	if ctx.cr[6].lt {
	pc = 0x825B69C8; continue 'dispatch;
	}
	// 825B69E4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825B69E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B69EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B69F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B69F4: 4E800020  blr
	return;
            }
            0x825B69F8 => {
    //   block [0x825B69F8..0x825B6A08)
	// 825B69F8: 4BF75899  bl 0x8252c290
	ctx.lr = 0x825B69FC;
	sub_8252C290(ctx, base);
	// 825B69FC: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B6A00: 396B00FF  addi r11, r11, 0xff
	ctx.r[11].s64 = ctx.r[11].s64 + 255;
	// 825B6A04: 997F0002  stb r11, 2(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(2 as u32), ctx.r[11].u8 ) };
	pc = 0x825B6A08; continue 'dispatch;
            }
            0x825B6A08 => {
    //   block [0x825B6A08..0x825B6A1C)
	// 825B6A08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825B6A0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B6A10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B6A14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B6A18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B6A20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B6A20 size=52
    let mut pc: u32 = 0x825B6A20;
    'dispatch: loop {
        match pc {
            0x825B6A20 => {
    //   block [0x825B6A20..0x825B6A34)
	// 825B6A20: 89240021  lbz r9, 0x21(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(33 as u32) ) } as u64;
	// 825B6A24: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B6A28: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825B6A2C: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 825B6A30: 39440002  addi r10, r4, 2
	ctx.r[10].s64 = ctx.r[4].s64 + 2;
	pc = 0x825B6A34; continue 'dispatch;
            }
            0x825B6A34 => {
    //   block [0x825B6A34..0x825B6A54)
	// 825B6A34: A10A0000  lhz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B6A38: 2B08FFFF  cmplwi cr6, r8, 0xffff
	ctx.cr[6].compare_u32(ctx.r[8].u32, 65535 as u32, &mut ctx.xer);
	// 825B6A3C: 419A0018  beq cr6, 0x825b6a54
	if ctx.cr[6].eq {
		sub_825B6A54(ctx, base);
		return;
	}
	// 825B6A40: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825B6A44: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825B6A48: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825B6A4C: 4198FFE8  blt cr6, 0x825b6a34
	if ctx.cr[6].lt {
	pc = 0x825B6A34; continue 'dispatch;
	}
	// 825B6A50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B6A54(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B6A54 size=16
    let mut pc: u32 = 0x825B6A54;
    'dispatch: loop {
        match pc {
            0x825B6A54 => {
    //   block [0x825B6A54..0x825B6A64)
	// 825B6A54: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B6A58: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 825B6A5C: B0AB0002  sth r5, 2(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[5].u16 ) };
	// 825B6A60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B6A68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B6A68 size=4
    let mut pc: u32 = 0x825B6A68;
    'dispatch: loop {
        match pc {
            0x825B6A68 => {
    //   block [0x825B6A68..0x825B6A6C)
	// 825B6A68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B6A70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B6A70 size=60
    let mut pc: u32 = 0x825B6A70;
    'dispatch: loop {
        match pc {
            0x825B6A70 => {
    //   block [0x825B6A70..0x825B6A94)
	// 825B6A70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B6A74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B6A78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B6A7C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B6A80: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825B6A84: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825B6A88: 419A000C  beq cr6, 0x825b6a94
	if ctx.cr[6].eq {
	pc = 0x825B6A94; continue 'dispatch;
	}
	// 825B6A8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B6A90: 4BF75841  bl 0x8252c2d0
	ctx.lr = 0x825B6A94;
	sub_8252C2D0(ctx, base);
	pc = 0x825B6A94; continue 'dispatch;
            }
            0x825B6A94 => {
    //   block [0x825B6A94..0x825B6AAC)
	// 825B6A94: 387F0040  addi r3, r31, 0x40
	ctx.r[3].s64 = ctx.r[31].s64 + 64;
	// 825B6A98: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825B6A9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B6AA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B6AA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B6AA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B6AB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B6AB0 size=128
    let mut pc: u32 = 0x825B6AB0;
    'dispatch: loop {
        match pc {
            0x825B6AB0 => {
    //   block [0x825B6AB0..0x825B6AE4)
	// 825B6AB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B6AB4: 4BF7E5F9  bl 0x825350ac
	ctx.lr = 0x825B6AB8;
	sub_82535080(ctx, base);
	// 825B6AB8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B6ABC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825B6AC0: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 825B6AC4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825B6AC8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825B6ACC: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 825B6AD0: 897F0021  lbz r11, 0x21(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(33 as u32) ) } as u64;
	// 825B6AD4: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 825B6AD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B6ADC: 419A0040  beq cr6, 0x825b6b1c
	if ctx.cr[6].eq {
	pc = 0x825B6B1C; continue 'dispatch;
	}
	// 825B6AE0: 3BBF0002  addi r29, r31, 2
	ctx.r[29].s64 = ctx.r[31].s64 + 2;
	pc = 0x825B6AE4; continue 'dispatch;
            }
            0x825B6AE4 => {
    //   block [0x825B6AE4..0x825B6B08)
	// 825B6AE4: A09D0000  lhz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B6AE8: 2B04FFFF  cmplwi cr6, r4, 0xffff
	ctx.cr[6].compare_u32(ctx.r[4].u32, 65535 as u32, &mut ctx.xer);
	// 825B6AEC: 419A001C  beq cr6, 0x825b6b08
	if ctx.cr[6].eq {
	pc = 0x825B6B08; continue 'dispatch;
	}
	// 825B6AF0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B6AF4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 825B6AF8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825B6AFC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B6B00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B6B04: 4E800421  bctrl
	ctx.lr = 0x825B6B08;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x825B6B08 => {
    //   block [0x825B6B08..0x825B6B1C)
	// 825B6B08: 897F0021  lbz r11, 0x21(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(33 as u32) ) } as u64;
	// 825B6B0C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 825B6B10: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 825B6B14: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825B6B18: 4198FFCC  blt cr6, 0x825b6ae4
	if ctx.cr[6].lt {
	pc = 0x825B6AE4; continue 'dispatch;
	}
	pc = 0x825B6B1C; continue 'dispatch;
            }
            0x825B6B1C => {
    //   block [0x825B6B1C..0x825B6B30)
	// 825B6B1C: 9B3F0021  stb r25, 0x21(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(33 as u32), ctx.r[25].u8 ) };
	// 825B6B20: 387F0040  addi r3, r31, 0x40
	ctx.r[3].s64 = ctx.r[31].s64 + 64;
	// 825B6B24: 9B3A0002  stb r25, 2(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(2 as u32), ctx.r[25].u8 ) };
	// 825B6B28: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825B6B2C: 4BF7E5D0  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B6B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B6B38 size=572
    let mut pc: u32 = 0x825B6B38;
    'dispatch: loop {
        match pc {
            0x825B6B38 => {
    //   block [0x825B6B38..0x825B6B84)
	// 825B6B38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B6B3C: 4BF7E549  bl 0x82535084
	ctx.lr = 0x825B6B40;
	sub_82535080(ctx, base);
	// 825B6B40: 9421FD90  stwu r1, -0x270(r1)
	ea = ctx.r[1].u32.wrapping_add(-624 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B6B44: 820D0000  lwz r16, 0(r13)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B6B48: 3A200014  li r17, 0x14
	ctx.r[17].s64 = 20;
	// 825B6B4C: 7C8F2378  mr r15, r4
	ctx.r[15].u64 = ctx.r[4].u64;
	// 825B6B50: 7CB52B78  mr r21, r5
	ctx.r[21].u64 = ctx.r[5].u64;
	// 825B6B54: 7D71802E  lwzx r11, r17, r16
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[17].u32.wrapping_add(ctx.r[16].u32)) } as u64;
	// 825B6B58: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B6B5C: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B6B60: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B6B64: 40980020  bge cr6, 0x825b6b84
	if !ctx.cr[6].lt {
	pc = 0x825B6B84; continue 'dispatch;
	}
	// 825B6B68: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825B6B6C: 3929A1CC  addi r9, r9, -0x5e34
	ctx.r[9].s64 = ctx.r[9].s64 + -24116;
	// 825B6B70: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B6B74: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 825B6B78: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 825B6B7C: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B6B80: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x825B6B84; continue 'dispatch;
            }
            0x825B6B84 => {
    //   block [0x825B6B84..0x825B6D74)
	// 825B6B84: 83A30004  lwz r29, 4(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B6B88: 3A400020  li r18, 0x20
	ctx.r[18].s64 = 32;
	// 825B6B8C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B6B90: 39630010  addi r11, r3, 0x10
	ctx.r[11].s64 = ctx.r[3].s64 + 16;
	// 825B6B94: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 825B6B98: 80A30008  lwz r5, 8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B6B9C: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 825B6BA0: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B6BA4: 3B0B0010  addi r24, r11, 0x10
	ctx.r[24].s64 = ctx.r[11].s64 + 16;
	// 825B6BA8: 83BD0000  lwz r29, 0(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B6BAC: 3AEB0020  addi r23, r11, 0x20
	ctx.r[23].s64 = ctx.r[11].s64 + 32;
	// 825B6BB0: 832A0000  lwz r25, 0(r10)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B6BB4: 3ACB0030  addi r22, r11, 0x30
	ctx.r[22].s64 = ctx.r[11].s64 + 48;
	// 825B6BB8: 828A0008  lwz r20, 8(r10)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B6BBC: C0050004  lfs f0, 4(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B6BC0: 82680008  lwz r19, 8(r8)
	ctx.r[19].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B6BC4: 3BE10090  addi r31, r1, 0x90
	ctx.r[31].s64 = ctx.r[1].s64 + 144;
	// 825B6BC8: 3BC10070  addi r30, r1, 0x70
	ctx.r[30].s64 = ctx.r[1].s64 + 112;
	// 825B6BCC: C1BD0010  lfs f13, 0x10(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825B6BD0: 3B810080  addi r28, r1, 0x80
	ctx.r[28].s64 = ctx.r[1].s64 + 128;
	// 825B6BD4: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 825B6BD8: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B6D78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B6D78 size=104
    let mut pc: u32 = 0x825B6D78;
    'dispatch: loop {
        match pc {
            0x825B6D78 => {
    //   block [0x825B6D78..0x825B6DE0)
	// 825B6D78: 3D60825B  lis r11, -0x7da5
	ctx.r[11].s64 = -2107965440;
	// 825B6D7C: 3CA0825B  lis r5, -0x7da5
	ctx.r[5].s64 = -2107965440;
	// 825B6D80: 3CC0825B  lis r6, -0x7da5
	ctx.r[6].s64 = -2107965440;
	// 825B6D84: 3CE0825B  lis r7, -0x7da5
	ctx.r[7].s64 = -2107965440;
	// 825B6D88: 3D00825B  lis r8, -0x7da5
	ctx.r[8].s64 = -2107965440;
	// 825B6D8C: 3D20825B  lis r9, -0x7da5
	ctx.r[9].s64 = -2107965440;
	// 825B6D90: 3D40825B  lis r10, -0x7da5
	ctx.r[10].s64 = -2107965440;
	// 825B6D94: 388B6B38  addi r4, r11, 0x6b38
	ctx.r[4].s64 = ctx.r[11].s64 + 27448;
	// 825B6D98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B6D9C: 38A56A70  addi r5, r5, 0x6a70
	ctx.r[5].s64 = ctx.r[5].s64 + 27248;
	// 825B6DA0: 38C66AB0  addi r6, r6, 0x6ab0
	ctx.r[6].s64 = ctx.r[6].s64 + 27312;
	// 825B6DA4: 38E76998  addi r7, r7, 0x6998
	ctx.r[7].s64 = ctx.r[7].s64 + 27032;
	// 825B6DA8: 39086A20  addi r8, r8, 0x6a20
	ctx.r[8].s64 = ctx.r[8].s64 + 27168;
	// 825B6DAC: 9083002C  stw r4, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[4].u32 ) };
	// 825B6DB0: 39296A68  addi r9, r9, 0x6a68
	ctx.r[9].s64 = ctx.r[9].s64 + 27240;
	// 825B6DB4: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 825B6DB8: 394A6B30  addi r10, r10, 0x6b30
	ctx.r[10].s64 = ctx.r[10].s64 + 27440;
	// 825B6DBC: 90A30000  stw r5, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 825B6DC0: 90C30008  stw r6, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 825B6DC4: 90E3000C  stw r7, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 825B6DC8: 91030010  stw r8, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 825B6DCC: 91230014  stw r9, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 825B6DD0: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 825B6DD4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825B6DD8: 99630030  stb r11, 0x30(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[11].u8 ) };
	// 825B6DDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B6DE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B6DE0 size=156
    let mut pc: u32 = 0x825B6DE0;
    'dispatch: loop {
        match pc {
            0x825B6DE0 => {
    //   block [0x825B6DE0..0x825B6E7C)
	// 825B6DE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B6DE4: 4BF7E2D9  bl 0x825350bc
	ctx.lr = 0x825B6DE8;
	sub_82535080(ctx, base);
	// 825B6DE8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B6DEC: 3FA0825B  lis r29, -0x7da5
	ctx.r[29].s64 = -2107965440;
	// 825B6DF0: 3FC0825B  lis r30, -0x7da5
	ctx.r[30].s64 = -2107965440;
	// 825B6DF4: 3FE0825B  lis r31, -0x7da5
	ctx.r[31].s64 = -2107965440;
	// 825B6DF8: 3CE0825B  lis r7, -0x7da5
	ctx.r[7].s64 = -2107965440;
	// 825B6DFC: 3D00825B  lis r8, -0x7da5
	ctx.r[8].s64 = -2107965440;
	// 825B6E00: 3D20825B  lis r9, -0x7da5
	ctx.r[9].s64 = -2107965440;
	// 825B6E04: 3D40825B  lis r10, -0x7da5
	ctx.r[10].s64 = -2107965440;
	// 825B6E08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B6E0C: 38E76998  addi r7, r7, 0x6998
	ctx.r[7].s64 = ctx.r[7].s64 + 27032;
	// 825B6E10: 39086A20  addi r8, r8, 0x6a20
	ctx.r[8].s64 = ctx.r[8].s64 + 27168;
	// 825B6E14: 39296A68  addi r9, r9, 0x6a68
	ctx.r[9].s64 = ctx.r[9].s64 + 27240;
	// 825B6E18: 394A6B30  addi r10, r10, 0x6b30
	ctx.r[10].s64 = ctx.r[10].s64 + 27440;
	// 825B6E1C: 3BBD6A70  addi r29, r29, 0x6a70
	ctx.r[29].s64 = ctx.r[29].s64 + 27248;
	// 825B6E20: 99610081  stb r11, 0x81(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(129 as u32), ctx.r[11].u8 ) };
	// 825B6E24: 3BDE6B38  addi r30, r30, 0x6b38
	ctx.r[30].s64 = ctx.r[30].s64 + 27448;
	// 825B6E28: 99610082  stb r11, 0x82(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(130 as u32), ctx.r[11].u8 ) };
	// 825B6E2C: 3BFF6AB0  addi r31, r31, 0x6ab0
	ctx.r[31].s64 = ctx.r[31].s64 + 27312;
	// 825B6E30: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 825B6E34: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 825B6E38: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 825B6E3C: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 825B6E40: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 825B6E44: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B6E48: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 825B6E4C: 93C1007C  stw r30, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 825B6E50: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 825B6E54: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825B6E58: 90E1005C  stw r7, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[7].u32 ) };
	// 825B6E5C: 91010060  stw r8, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 825B6E60: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 825B6E64: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 825B6E68: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B6E6C: 99610080  stb r11, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u8 ) };
	// 825B6E70: 4BF490F9  bl 0x824fff68
	ctx.lr = 0x825B6E74;
	sub_824FFF68(ctx, base);
	// 825B6E74: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825B6E78: 4BF7E294  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B6E80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B6E80 size=2732
    let mut pc: u32 = 0x825B6E80;
    'dispatch: loop {
        match pc {
            0x825B6E80 => {
    //   block [0x825B6E80..0x825B6EC4)
	// 825B6E80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B6E84: 4BF7E21D  bl 0x825350a0
	ctx.lr = 0x825B6E88;
	sub_82535080(ctx, base);
	// 825B6E88: 9421FD00  stwu r1, -0x300(r1)
	ea = ctx.r[1].u32.wrapping_add(-768 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B6E8C: 3FA0829A  lis r29, -0x7d66
	ctx.r[29].s64 = -2103836672;
	// 825B6E90: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825B6E94: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B6E98: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825B6E9C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 825B6EA0: 897D3E84  lbz r11, 0x3e84(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(16004 as u32) ) } as u64;
	// 825B6EA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B6EA8: 409A001C  bne cr6, 0x825b6ec4
	if !ctx.cr[6].eq {
	pc = 0x825B6EC4; continue 'dispatch;
	}
	// 825B6EAC: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 825B6EB0: 4BF42291  bl 0x824f9140
	ctx.lr = 0x825B6EB4;
	sub_824F9140(ctx, base);
	// 825B6EB4: 7C6B0774  extsb r11, r3
	ctx.r[11].s64 = ctx.r[3].s8 as i64;
	// 825B6EB8: 987D3E84  stb r3, 0x3e84(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(16004 as u32), ctx.r[3].u8 ) };
	// 825B6EBC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B6EC0: 419A0A64  beq cr6, 0x825b7924
	if ctx.cr[6].eq {
	pc = 0x825B7924; continue 'dispatch;
	}
	pc = 0x825B6EC4; continue 'dispatch;
            }
            0x825B6EC4 => {
    //   block [0x825B6EC4..0x825B6ED8)
	// 825B6EC4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825B6EC8: 3F008293  lis r24, -0x7d6d
	ctx.r[24].s64 = -2104295424;
	// 825B6ECC: 3B4BA26C  addi r26, r11, -0x5d94
	ctx.r[26].s64 = ctx.r[11].s64 + -23956;
	// 825B6ED0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825B6ED4: 3B2BA1D8  addi r25, r11, -0x5e28
	ctx.r[25].s64 = ctx.r[11].s64 + -24104;
	pc = 0x825B6ED8; continue 'dispatch;
            }
            0x825B6ED8 => {
    //   block [0x825B6ED8..0x825B70AC)
	// 825B6ED8: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B6EDC: 2B0B006B  cmplwi cr6, r11, 0x6b
	ctx.cr[6].compare_u32(ctx.r[11].u32, 107 as u32, &mut ctx.xer);
	// 825B6EE0: 41990930  bgt cr6, 0x825b7810
	if ctx.cr[6].gt {
	pc = 0x825B7810; continue 'dispatch;
	}
	// 825B6EE4: 3D80825B  lis r12, -0x7da5
	ctx.r[12].s64 = -2107965440;
	// 825B6EE8: 398C6EFC  addi r12, r12, 0x6efc
	ctx.r[12].s64 = ctx.r[12].s64 + 28412;
	// 825B6EEC: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 825B6EF0: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 825B6EF4: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 825B6EF8: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x825B7924; continue 'dispatch;
		},
		1 => {
	pc = 0x825B7564; continue 'dispatch;
		},
		2 => {
	pc = 0x825B7564; continue 'dispatch;
		},
		3 => {
	pc = 0x825B7564; continue 'dispatch;
		},
		4 => {
	pc = 0x825B7564; continue 'dispatch;
		},
		5 => {
	pc = 0x825B74EC; continue 'dispatch;
		},
		6 => {
	pc = 0x825B74FC; continue 'dispatch;
		},
		7 => {
	pc = 0x825B7518; continue 'dispatch;
		},
		8 => {
	pc = 0x825B7810; continue 'dispatch;
		},
		9 => {
	pc = 0x825B7654; continue 'dispatch;
		},
		10 => {
	pc = 0x825B769C; continue 'dispatch;
		},
		11 => {
	pc = 0x825B76F0; continue 'dispatch;
		},
		12 => {
	pc = 0x825B7540; continue 'dispatch;
		},
		13 => {
	pc = 0x825B774C; continue 'dispatch;
		},
		14 => {
	pc = 0x825B7810; continue 'dispatch;
		},
		15 => {
	pc = 0x825B7810; continue 'dispatch;
		},
		16 => {
	pc = 0x825B7314; continue 'dispatch;
		},
		17 => {
	pc = 0x825B7314; continue 'dispatch;
		},
		18 => {
	pc = 0x825B7314; continue 'dispatch;
		},
		19 => {
	pc = 0x825B70AC; continue 'dispatch;
		},
		20 => {
	pc = 0x825B70D8; continue 'dispatch;
		},
		21 => {
	pc = 0x825B710C; continue 'dispatch;
		},
		22 => {
	pc = 0x825B7138; continue 'dispatch;
		},
		23 => {
	pc = 0x825B716C; continue 'dispatch;
		},
		24 => {
	pc = 0x825B7198; continue 'dispatch;
		},
		25 => {
	pc = 0x825B71CC; continue 'dispatch;
		},
		26 => {
	pc = 0x825B7208; continue 'dispatch;
		},
		27 => {
	pc = 0x825B7244; continue 'dispatch;
		},
		28 => {
	pc = 0x825B7280; continue 'dispatch;
		},
		29 => {
	pc = 0x825B7810; continue 'dispatch;
		},
		30 => {
	pc = 0x825B7810; continue 'dispatch;
		},
		31 => {
	pc = 0x825B7810; continue 'dispatch;
		},
		32 => {
	pc = 0x825B7378; continue 'dispatch;
		},
		33 => {
	pc = 0x825B7378; continue 'dispatch;
		},
		34 => {
	pc = 0x825B7378; continue 'dispatch;
		},
		35 => {
	pc = 0x825B73C8; continue 'dispatch;
		},
		36 => {
	pc = 0x825B73C8; continue 'dispatch;
		},
		37 => {
	pc = 0x825B73C8; continue 'dispatch;
		},
		38 => {
	pc = 0x825B744C; continue 'dispatch;
		},
		39 => {
	pc = 0x825B744C; continue 'dispatch;
		},
		40 => {
	pc = 0x825B744C; continue 'dispatch;
		},
		41 => {
	pc = 0x825B7484; continue 'dispatch;
		},
		42 => {
	pc = 0x825B7484; continue 'dispatch;
		},
		43 => {
	pc = 0x825B7484; continue 'dispatch;
		},
		44 => {
	pc = 0x825B7810; continue 'dispatch;
		},
		45 => {
	pc = 0x825B7810; continue 'dispatch;
		},
		46 => {
	pc = 0x825B7810; continue 'dispatch;
		},
		47 => {
	pc = 0x825B7810; continue 'dispatch;
		},
		48 => {
	pc = 0x825B78CC; continue 'dispatch;
		},
		49 => {
	pc = 0x825B78CC; continue 'dispatch;
		},
		50 => {
	pc = 0x825B78CC; continue 'dispatch;
		},
		51 => {
	pc = 0x825B78CC; continue 'dispatch;
		},
		52 => {
	pc = 0x825B78CC; continue 'dispatch;
		},
		53 => {
	pc = 0x825B78CC; continue 'dispatch;
		},
		54 => {
	pc = 0x825B78CC; continue 'dispatch;
		},
		55 => {
	pc = 0x825B78CC; continue 'dispatch;
		},
		56 => {
	pc = 0x825B78CC; continue 'dispatch;
		},
		57 => {
	pc = 0x825B78CC; continue 'dispatch;
		},
		58 => {
	pc = 0x825B78CC; continue 'dispatch;
		},
		59 => {
	pc = 0x825B78CC; continue 'dispatch;
		},
		60 => {
	pc = 0x825B78CC; continue 'dispatch;
		},
		61 => {
	pc = 0x825B78CC; continue 'dispatch;
		},
		62 => {
	pc = 0x825B78CC; continue 'dispatch;
		},
		63 => {
	pc = 0x825B78CC; continue 'dispatch;
		},
		64 => {
	pc = 0x825B78CC; continue 'dispatch;
		},
		65 => {
	pc = 0x825B78CC; continue 'dispatch;
		},
		66 => {
	pc = 0x825B78CC; continue 'dispatch;
		},
		67 => {
	pc = 0x825B78CC; continue 'dispatch;
		},
		68 => {
	pc = 0x825B78CC; continue 'dispatch;
		},
		69 => {
	pc = 0x825B78CC; continue 'dispatch;
		},
		70 => {
	pc = 0x825B78CC; continue 'dispatch;
		},
		71 => {
	pc = 0x825B78CC; continue 'dispatch;
		},
		72 => {
	pc = 0x825B78CC; continue 'dispatch;
		},
		73 => {
	pc = 0x825B78CC; continue 'dispatch;
		},
		74 => {
	pc = 0x825B78CC; continue 'dispatch;
		},
		75 => {
	pc = 0x825B78CC; continue 'dispatch;
		},
		76 => {
	pc = 0x825B78CC; continue 'dispatch;
		},
		77 => {
	pc = 0x825B78CC; continue 'dispatch;
		},
		78 => {
	pc = 0x825B78CC; continue 'dispatch;
		},
		79 => {
	pc = 0x825B78CC; continue 'dispatch;
		},
		80 => {
	pc = 0x825B7864; continue 'dispatch;
		},
		81 => {
	pc = 0x825B786C; continue 'dispatch;
		},
		82 => {
	pc = 0x825B7880; continue 'dispatch;
		},
		83 => {
	pc = 0x825B78A0; continue 'dispatch;
		},
		84 => {
	pc = 0x825B7810; continue 'dispatch;
		},
		85 => {
	pc = 0x825B7810; continue 'dispatch;
		},
		86 => {
	pc = 0x825B7810; continue 'dispatch;
		},
		87 => {
	pc = 0x825B7810; continue 'dispatch;
		},
		88 => {
	pc = 0x825B7810; continue 'dispatch;
		},
		89 => {
	pc = 0x825B7810; continue 'dispatch;
		},
		90 => {
	pc = 0x825B7810; continue 'dispatch;
		},
		91 => {
	pc = 0x825B7810; continue 'dispatch;
		},
		92 => {
	pc = 0x825B7810; continue 'dispatch;
		},
		93 => {
	pc = 0x825B7810; continue 'dispatch;
		},
		94 => {
	pc = 0x825B7810; continue 'dispatch;
		},
		95 => {
	pc = 0x825B7810; continue 'dispatch;
		},
		96 => {
	pc = 0x825B7754; continue 'dispatch;
		},
		97 => {
	pc = 0x825B7754; continue 'dispatch;
		},
		98 => {
	pc = 0x825B7754; continue 'dispatch;
		},
		99 => {
	pc = 0x825B7754; continue 'dispatch;
		},
		100 => {
	pc = 0x825B7770; continue 'dispatch;
		},
		101 => {
	pc = 0x825B7770; continue 'dispatch;
		},
		102 => {
	pc = 0x825B7770; continue 'dispatch;
		},
		103 => {
	pc = 0x825B7770; continue 'dispatch;
		},
		104 => {
	pc = 0x825B7798; continue 'dispatch;
		},
		105 => {
	pc = 0x825B7798; continue 'dispatch;
		},
		106 => {
	pc = 0x825B7798; continue 'dispatch;
		},
		107 => {
	pc = 0x825B7798; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 825B6EFC: 825B7924  lwz r18, 0x7924(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(31012 as u32) ) } as u64;
	// 825B6F00: 825B7564  lwz r18, 0x7564(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30052 as u32) ) } as u64;
	// 825B6F04: 825B7564  lwz r18, 0x7564(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30052 as u32) ) } as u64;
	// 825B6F08: 825B7564  lwz r18, 0x7564(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30052 as u32) ) } as u64;
	// 825B6F0C: 825B7564  lwz r18, 0x7564(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30052 as u32) ) } as u64;
	// 825B6F10: 825B74EC  lwz r18, 0x74ec(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(29932 as u32) ) } as u64;
	// 825B6F14: 825B74FC  lwz r18, 0x74fc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(29948 as u32) ) } as u64;
	// 825B6F18: 825B7518  lwz r18, 0x7518(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(29976 as u32) ) } as u64;
	// 825B6F1C: 825B7810  lwz r18, 0x7810(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30736 as u32) ) } as u64;
	// 825B6F20: 825B7654  lwz r18, 0x7654(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30292 as u32) ) } as u64;
	// 825B6F24: 825B769C  lwz r18, 0x769c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30364 as u32) ) } as u64;
	// 825B6F28: 825B76F0  lwz r18, 0x76f0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30448 as u32) ) } as u64;
	// 825B6F2C: 825B7540  lwz r18, 0x7540(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30016 as u32) ) } as u64;
	// 825B6F30: 825B774C  lwz r18, 0x774c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30540 as u32) ) } as u64;
	// 825B6F34: 825B7810  lwz r18, 0x7810(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30736 as u32) ) } as u64;
	// 825B6F38: 825B7810  lwz r18, 0x7810(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30736 as u32) ) } as u64;
	// 825B6F3C: 825B7314  lwz r18, 0x7314(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(29460 as u32) ) } as u64;
	// 825B6F40: 825B7314  lwz r18, 0x7314(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(29460 as u32) ) } as u64;
	// 825B6F44: 825B7314  lwz r18, 0x7314(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(29460 as u32) ) } as u64;
	// 825B6F48: 825B70AC  lwz r18, 0x70ac(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28844 as u32) ) } as u64;
	// 825B6F4C: 825B70D8  lwz r18, 0x70d8(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28888 as u32) ) } as u64;
	// 825B6F50: 825B710C  lwz r18, 0x710c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28940 as u32) ) } as u64;
	// 825B6F54: 825B7138  lwz r18, 0x7138(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28984 as u32) ) } as u64;
	// 825B6F58: 825B716C  lwz r18, 0x716c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(29036 as u32) ) } as u64;
	// 825B6F5C: 825B7198  lwz r18, 0x7198(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(29080 as u32) ) } as u64;
	// 825B6F60: 825B71CC  lwz r18, 0x71cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(29132 as u32) ) } as u64;
	// 825B6F64: 825B7208  lwz r18, 0x7208(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(29192 as u32) ) } as u64;
	// 825B6F68: 825B7244  lwz r18, 0x7244(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(29252 as u32) ) } as u64;
	// 825B6F6C: 825B7280  lwz r18, 0x7280(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(29312 as u32) ) } as u64;
	// 825B6F70: 825B7810  lwz r18, 0x7810(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30736 as u32) ) } as u64;
	// 825B6F74: 825B7810  lwz r18, 0x7810(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30736 as u32) ) } as u64;
	// 825B6F78: 825B7810  lwz r18, 0x7810(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30736 as u32) ) } as u64;
	// 825B6F7C: 825B7378  lwz r18, 0x7378(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(29560 as u32) ) } as u64;
	// 825B6F80: 825B7378  lwz r18, 0x7378(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(29560 as u32) ) } as u64;
	// 825B6F84: 825B7378  lwz r18, 0x7378(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(29560 as u32) ) } as u64;
	// 825B6F88: 825B73C8  lwz r18, 0x73c8(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(29640 as u32) ) } as u64;
	// 825B6F8C: 825B73C8  lwz r18, 0x73c8(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(29640 as u32) ) } as u64;
	// 825B6F90: 825B73C8  lwz r18, 0x73c8(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(29640 as u32) ) } as u64;
	// 825B6F94: 825B744C  lwz r18, 0x744c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(29772 as u32) ) } as u64;
	// 825B6F98: 825B744C  lwz r18, 0x744c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(29772 as u32) ) } as u64;
	// 825B6F9C: 825B744C  lwz r18, 0x744c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(29772 as u32) ) } as u64;
	// 825B6FA0: 825B7484  lwz r18, 0x7484(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(29828 as u32) ) } as u64;
	// 825B6FA4: 825B7484  lwz r18, 0x7484(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(29828 as u32) ) } as u64;
	// 825B6FA8: 825B7484  lwz r18, 0x7484(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(29828 as u32) ) } as u64;
	// 825B6FAC: 825B7810  lwz r18, 0x7810(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30736 as u32) ) } as u64;
	// 825B6FB0: 825B7810  lwz r18, 0x7810(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30736 as u32) ) } as u64;
	// 825B6FB4: 825B7810  lwz r18, 0x7810(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30736 as u32) ) } as u64;
	// 825B6FB8: 825B7810  lwz r18, 0x7810(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30736 as u32) ) } as u64;
	// 825B6FBC: 825B78CC  lwz r18, 0x78cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30924 as u32) ) } as u64;
	// 825B6FC0: 825B78CC  lwz r18, 0x78cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30924 as u32) ) } as u64;
	// 825B6FC4: 825B78CC  lwz r18, 0x78cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30924 as u32) ) } as u64;
	// 825B6FC8: 825B78CC  lwz r18, 0x78cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30924 as u32) ) } as u64;
	// 825B6FCC: 825B78CC  lwz r18, 0x78cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30924 as u32) ) } as u64;
	// 825B6FD0: 825B78CC  lwz r18, 0x78cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30924 as u32) ) } as u64;
	// 825B6FD4: 825B78CC  lwz r18, 0x78cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30924 as u32) ) } as u64;
	// 825B6FD8: 825B78CC  lwz r18, 0x78cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30924 as u32) ) } as u64;
	// 825B6FDC: 825B78CC  lwz r18, 0x78cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30924 as u32) ) } as u64;
	// 825B6FE0: 825B78CC  lwz r18, 0x78cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30924 as u32) ) } as u64;
	// 825B6FE4: 825B78CC  lwz r18, 0x78cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30924 as u32) ) } as u64;
	// 825B6FE8: 825B78CC  lwz r18, 0x78cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30924 as u32) ) } as u64;
	// 825B6FEC: 825B78CC  lwz r18, 0x78cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30924 as u32) ) } as u64;
	// 825B6FF0: 825B78CC  lwz r18, 0x78cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30924 as u32) ) } as u64;
	// 825B6FF4: 825B78CC  lwz r18, 0x78cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30924 as u32) ) } as u64;
	// 825B6FF8: 825B78CC  lwz r18, 0x78cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30924 as u32) ) } as u64;
	// 825B6FFC: 825B78CC  lwz r18, 0x78cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30924 as u32) ) } as u64;
	// 825B7000: 825B78CC  lwz r18, 0x78cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30924 as u32) ) } as u64;
	// 825B7004: 825B78CC  lwz r18, 0x78cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30924 as u32) ) } as u64;
	// 825B7008: 825B78CC  lwz r18, 0x78cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30924 as u32) ) } as u64;
	// 825B700C: 825B78CC  lwz r18, 0x78cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30924 as u32) ) } as u64;
	// 825B7010: 825B78CC  lwz r18, 0x78cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30924 as u32) ) } as u64;
	// 825B7014: 825B78CC  lwz r18, 0x78cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30924 as u32) ) } as u64;
	// 825B7018: 825B78CC  lwz r18, 0x78cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30924 as u32) ) } as u64;
	// 825B701C: 825B78CC  lwz r18, 0x78cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30924 as u32) ) } as u64;
	// 825B7020: 825B78CC  lwz r18, 0x78cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30924 as u32) ) } as u64;
	// 825B7024: 825B78CC  lwz r18, 0x78cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30924 as u32) ) } as u64;
	// 825B7028: 825B78CC  lwz r18, 0x78cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30924 as u32) ) } as u64;
	// 825B702C: 825B78CC  lwz r18, 0x78cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30924 as u32) ) } as u64;
	// 825B7030: 825B78CC  lwz r18, 0x78cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30924 as u32) ) } as u64;
	// 825B7034: 825B78CC  lwz r18, 0x78cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30924 as u32) ) } as u64;
	// 825B7038: 825B78CC  lwz r18, 0x78cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30924 as u32) ) } as u64;
	// 825B703C: 825B7864  lwz r18, 0x7864(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30820 as u32) ) } as u64;
	// 825B7040: 825B786C  lwz r18, 0x786c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30828 as u32) ) } as u64;
	// 825B7044: 825B7880  lwz r18, 0x7880(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30848 as u32) ) } as u64;
	// 825B7048: 825B78A0  lwz r18, 0x78a0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30880 as u32) ) } as u64;
	// 825B704C: 825B7810  lwz r18, 0x7810(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30736 as u32) ) } as u64;
	// 825B7050: 825B7810  lwz r18, 0x7810(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30736 as u32) ) } as u64;
	// 825B7054: 825B7810  lwz r18, 0x7810(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30736 as u32) ) } as u64;
	// 825B7058: 825B7810  lwz r18, 0x7810(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30736 as u32) ) } as u64;
	// 825B705C: 825B7810  lwz r18, 0x7810(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30736 as u32) ) } as u64;
	// 825B7060: 825B7810  lwz r18, 0x7810(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30736 as u32) ) } as u64;
	// 825B7064: 825B7810  lwz r18, 0x7810(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30736 as u32) ) } as u64;
	// 825B7068: 825B7810  lwz r18, 0x7810(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30736 as u32) ) } as u64;
	// 825B706C: 825B7810  lwz r18, 0x7810(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30736 as u32) ) } as u64;
	// 825B7070: 825B7810  lwz r18, 0x7810(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30736 as u32) ) } as u64;
	// 825B7074: 825B7810  lwz r18, 0x7810(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30736 as u32) ) } as u64;
	// 825B7078: 825B7810  lwz r18, 0x7810(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30736 as u32) ) } as u64;
	// 825B707C: 825B7754  lwz r18, 0x7754(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30548 as u32) ) } as u64;
	// 825B7080: 825B7754  lwz r18, 0x7754(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30548 as u32) ) } as u64;
	// 825B7084: 825B7754  lwz r18, 0x7754(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30548 as u32) ) } as u64;
	// 825B7088: 825B7754  lwz r18, 0x7754(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30548 as u32) ) } as u64;
	// 825B708C: 825B7770  lwz r18, 0x7770(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30576 as u32) ) } as u64;
	// 825B7090: 825B7770  lwz r18, 0x7770(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30576 as u32) ) } as u64;
	// 825B7094: 825B7770  lwz r18, 0x7770(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30576 as u32) ) } as u64;
	// 825B7098: 825B7770  lwz r18, 0x7770(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30576 as u32) ) } as u64;
	// 825B709C: 825B7798  lwz r18, 0x7798(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30616 as u32) ) } as u64;
	// 825B70A0: 825B7798  lwz r18, 0x7798(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30616 as u32) ) } as u64;
	// 825B70A4: 825B7798  lwz r18, 0x7798(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30616 as u32) ) } as u64;
	// 825B70A8: 825B7798  lwz r18, 0x7798(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(30616 as u32) ) } as u64;
            }
            0x825B70AC => {
    //   block [0x825B70AC..0x825B70D8)
	// 825B70AC: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B70B0: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B70B4: 5549083E  rotlwi r9, r10, 1
	ctx.r[9].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 825B70B8: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 825B70BC: 80DE0014  lwz r6, 0x14(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B70C0: 5508083E  rotlwi r8, r8, 1
	ctx.r[8].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 825B70C4: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B70C8: 80FE0004  lwz r7, 4(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B70CC: 7D6B3214  add r11, r11, r6
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 825B70D0: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 825B70D4: 480001F4  b 0x825b72c8
	pc = 0x825B72C8; continue 'dispatch;
            }
            0x825B70D8 => {
    //   block [0x825B70D8..0x825B710C)
	// 825B70D8: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B70DC: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B70E0: 556B083E  rotlwi r11, r11, 1
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 825B70E4: 80FE0014  lwz r7, 0x14(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B70E8: 554A083E  rotlwi r10, r10, 1
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 825B70EC: 80DE0008  lwz r6, 8(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B70F0: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B70F4: 392BFF01  addi r9, r11, -0xff
	ctx.r[9].s64 = ctx.r[11].s64 + -255;
	// 825B70F8: 809E0018  lwz r4, 0x18(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 825B70FC: 390AFF01  addi r8, r10, -0xff
	ctx.r[8].s64 = ctx.r[10].s64 + -255;
	// 825B7100: 7D663850  subf r11, r6, r7
	ctx.r[11].s64 = ctx.r[7].s64 - ctx.r[6].s64;
	// 825B7104: 7D442850  subf r10, r4, r5
	ctx.r[10].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 825B7108: 480001C0  b 0x825b72c8
	pc = 0x825B72C8; continue 'dispatch;
            }
            0x825B710C => {
    //   block [0x825B710C..0x825B7138)
	// 825B710C: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B7110: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B7114: 5549083E  rotlwi r9, r10, 1
	ctx.r[9].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 825B7118: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 825B711C: 80DE0010  lwz r6, 0x10(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825B7120: 5508083E  rotlwi r8, r8, 1
	ctx.r[8].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 825B7124: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B7128: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B712C: 7D6B3214  add r11, r11, r6
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 825B7130: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 825B7134: 48000194  b 0x825b72c8
	pc = 0x825B72C8; continue 'dispatch;
            }
            0x825B7138 => {
    //   block [0x825B7138..0x825B716C)
	// 825B7138: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B713C: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B7140: 556B083E  rotlwi r11, r11, 1
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 825B7144: 80FE0010  lwz r7, 0x10(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825B7148: 554A083E  rotlwi r10, r10, 1
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 825B714C: 80DE0008  lwz r6, 8(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B7150: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B7154: 392BFF01  addi r9, r11, -0xff
	ctx.r[9].s64 = ctx.r[11].s64 + -255;
	// 825B7158: 809E0018  lwz r4, 0x18(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 825B715C: 390AFF01  addi r8, r10, -0xff
	ctx.r[8].s64 = ctx.r[10].s64 + -255;
	// 825B7160: 7D663850  subf r11, r6, r7
	ctx.r[11].s64 = ctx.r[7].s64 - ctx.r[6].s64;
	// 825B7164: 7D442850  subf r10, r4, r5
	ctx.r[10].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 825B7168: 48000160  b 0x825b72c8
	pc = 0x825B72C8; continue 'dispatch;
            }
            0x825B716C => {
    //   block [0x825B716C..0x825B7198)
	// 825B716C: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B7170: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B7174: 5549083E  rotlwi r9, r10, 1
	ctx.r[9].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 825B7178: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B717C: 80DE0010  lwz r6, 0x10(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825B7180: 5508083E  rotlwi r8, r8, 1
	ctx.r[8].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 825B7184: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B7188: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B718C: 7D6B3214  add r11, r11, r6
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 825B7190: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 825B7194: 48000134  b 0x825b72c8
	pc = 0x825B72C8; continue 'dispatch;
            }
            0x825B7198 => {
    //   block [0x825B7198..0x825B71CC)
	// 825B7198: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B719C: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B71A0: 556B083E  rotlwi r11, r11, 1
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 825B71A4: 80FE0010  lwz r7, 0x10(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825B71A8: 554A083E  rotlwi r10, r10, 1
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 825B71AC: 80DE0004  lwz r6, 4(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B71B0: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B71B4: 392BFF01  addi r9, r11, -0xff
	ctx.r[9].s64 = ctx.r[11].s64 + -255;
	// 825B71B8: 809E0014  lwz r4, 0x14(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B71BC: 390AFF01  addi r8, r10, -0xff
	ctx.r[8].s64 = ctx.r[10].s64 + -255;
	// 825B71C0: 7D663850  subf r11, r6, r7
	ctx.r[11].s64 = ctx.r[7].s64 - ctx.r[6].s64;
	// 825B71C4: 7D442850  subf r10, r4, r5
	ctx.r[10].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 825B71C8: 48000100  b 0x825b72c8
	pc = 0x825B72C8; continue 'dispatch;
            }
            0x825B71CC => {
    //   block [0x825B71CC..0x825B7208)
	// 825B71CC: 80FE0014  lwz r7, 0x14(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B71D0: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 825B71D4: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B71D8: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B71DC: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 825B71E0: 80DE0010  lwz r6, 0x10(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825B71E4: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B71E8: 7D4A2A14  add r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[5].u64;
	// 825B71EC: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B71F0: 7D6B3214  add r11, r11, r6
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 825B71F4: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B71F8: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 825B71FC: 5526083E  rotlwi r6, r9, 1
	ctx.r[6].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 825B7200: 5507083E  rotlwi r7, r8, 1
	ctx.r[7].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 825B7204: 480000BC  b 0x825b72c0
	pc = 0x825B72C0; continue 'dispatch;
            }
            0x825B7208 => {
    //   block [0x825B7208..0x825B7244)
	// 825B7208: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B720C: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B7210: 392BFFAB  addi r9, r11, -0x55
	ctx.r[9].s64 = ctx.r[11].s64 + -85;
	// 825B7214: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B7218: 390AFFAB  addi r8, r10, -0x55
	ctx.r[8].s64 = ctx.r[10].s64 + -85;
	// 825B721C: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B7220: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B7224: 809E0018  lwz r4, 0x18(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 825B7228: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825B722C: 80DE0010  lwz r6, 0x10(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825B7230: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B7234: 7D442850  subf r10, r4, r5
	ctx.r[10].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 825B7238: 7D6B3214  add r11, r11, r6
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 825B723C: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 825B7240: 48000078  b 0x825b72b8
	pc = 0x825B72B8; continue 'dispatch;
            }
            0x825B7244 => {
    //   block [0x825B7244..0x825B7280)
	// 825B7244: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B7248: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B724C: 392BFFAB  addi r9, r11, -0x55
	ctx.r[9].s64 = ctx.r[11].s64 + -85;
	// 825B7250: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 825B7254: 390AFFAB  addi r8, r10, -0x55
	ctx.r[8].s64 = ctx.r[10].s64 + -85;
	// 825B7258: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B725C: 80BE0008  lwz r5, 8(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B7260: 809E0014  lwz r4, 0x14(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B7264: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825B7268: 80DE0010  lwz r6, 0x10(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825B726C: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B7270: 7D442850  subf r10, r4, r5
	ctx.r[10].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 825B7274: 7D6B3214  add r11, r11, r6
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 825B7278: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 825B727C: 4800003C  b 0x825b72b8
	pc = 0x825B72B8; continue 'dispatch;
            }
            0x825B7280 => {
    //   block [0x825B7280..0x825B72B8)
	// 825B7280: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B7284: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B7288: 392BFF56  addi r9, r11, -0xaa
	ctx.r[9].s64 = ctx.r[11].s64 + -170;
	// 825B728C: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825B7290: 390AFF56  addi r8, r10, -0xaa
	ctx.r[8].s64 = ctx.r[10].s64 + -170;
	// 825B7294: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B7298: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B729C: 80DE0018  lwz r6, 0x18(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 825B72A0: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825B72A4: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B72A8: 80BE0014  lwz r5, 0x14(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B72AC: 7CE63850  subf r7, r6, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[6].s64;
	// 825B72B0: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825B72B4: 7D453850  subf r10, r5, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[5].s64;
	pc = 0x825B72B8; continue 'dispatch;
            }
            0x825B72B8 => {
    //   block [0x825B72B8..0x825B72C0)
	// 825B72B8: 5526083C  slwi r6, r9, 1
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 825B72BC: 5507083C  slwi r7, r8, 1
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	pc = 0x825B72C0; continue 'dispatch;
            }
            0x825B72C0 => {
    //   block [0x825B72C0..0x825B72C8)
	// 825B72C0: 7D083A14  add r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 825B72C4: 7D293214  add r9, r9, r6
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[6].u64;
	pc = 0x825B72C8; continue 'dispatch;
            }
            0x825B72C8 => {
    //   block [0x825B72C8..0x825B72E4)
	// 825B72C8: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825B72CC: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 825B72D0: 41990014  bgt cr6, 0x825b72e4
	if ctx.cr[6].gt {
	pc = 0x825B72E4; continue 'dispatch;
	}
	// 825B72D4: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825B72D8: 4198FC00  blt cr6, 0x825b6ed8
	if ctx.cr[6].lt {
	pc = 0x825B6ED8; continue 'dispatch;
	}
	// 825B72DC: 38210300  addi r1, r1, 0x300
	ctx.r[1].s64 = ctx.r[1].s64 + 768;
	// 825B72E0: 4BF7DE10  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x825B72E4 => {
    //   block [0x825B72E4..0x825B72F8)
	// 825B72E4: 8BBFFFFF  lbz r29, -1(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825B72E8: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825B72EC: 4198000C  blt cr6, 0x825b72f8
	if ctx.cr[6].lt {
	pc = 0x825B72F8; continue 'dispatch;
	}
	// 825B72F0: 7FFDFA14  add r31, r29, r31
	ctx.r[31].u64 = ctx.r[29].u64 + ctx.r[31].u64;
	// 825B72F4: 4BFFFBE4  b 0x825b6ed8
	pc = 0x825B6ED8; continue 'dispatch;
            }
            0x825B72F8 => {
    //   block [0x825B72F8..0x825B7314)
	// 825B72F8: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 825B72FC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B7300: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B7304: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825B7308: 4BFFFB79  bl 0x825b6e80
	ctx.lr = 0x825B730C;
	sub_825B6E80(ctx, base);
	// 825B730C: 7FFDFA14  add r31, r29, r31
	ctx.r[31].u64 = ctx.r[29].u64 + ctx.r[31].u64;
	// 825B7310: 4BFFFBC8  b 0x825b6ed8
	pc = 0x825B6ED8; continue 'dispatch;
            }
            0x825B7314 => {
    //   block [0x825B7314..0x825B7350)
	// 825B7314: 390BFFF0  addi r8, r11, -0x10
	ctx.r[8].s64 = ctx.r[11].s64 + -16;
	// 825B7318: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B731C: 396BFFF4  addi r11, r11, -0xc
	ctx.r[11].s64 = ctx.r[11].s64 + -12;
	// 825B7320: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B7324: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B7328: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B732C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825B7330: 7CE8F02E  lwzx r7, r8, r30
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825B7334: 7D0BF02E  lwzx r8, r11, r30
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825B7338: 7F075000  cmpw cr6, r7, r10
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825B733C: 41990014  bgt cr6, 0x825b7350
	if ctx.cr[6].gt {
	pc = 0x825B7350; continue 'dispatch;
	}
	// 825B7340: 7F084800  cmpw cr6, r8, r9
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825B7344: 4198FB94  blt cr6, 0x825b6ed8
	if ctx.cr[6].lt {
	pc = 0x825B6ED8; continue 'dispatch;
	}
	// 825B7348: 38210300  addi r1, r1, 0x300
	ctx.r[1].s64 = ctx.r[1].s64 + 768;
	// 825B734C: 4BF7DDA4  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x825B7350 => {
    //   block [0x825B7350..0x825B7378)
	// 825B7350: 897FFFFF  lbz r11, -1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825B7354: 7F084800  cmpw cr6, r8, r9
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825B7358: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825B735C: 4098FB7C  bge cr6, 0x825b6ed8
	if !ctx.cr[6].lt {
	pc = 0x825B6ED8; continue 'dispatch;
	}
	// 825B7360: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 825B7364: 7CABF850  subf r5, r11, r31
	ctx.r[5].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 825B7368: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B736C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825B7370: 4BFFFB11  bl 0x825b6e80
	ctx.lr = 0x825B7374;
	sub_825B6E80(ctx, base);
	// 825B7374: 4BFFFB64  b 0x825b6ed8
	pc = 0x825B6ED8; continue 'dispatch;
            }
            0x825B7378 => {
    //   block [0x825B7378..0x825B73C8)
	// 825B7378: 394BFFE0  addi r10, r11, -0x20
	ctx.r[10].s64 = ctx.r[11].s64 + -32;
	// 825B737C: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B7380: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825B7384: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825B7388: 7D4AF02E  lwzx r10, r10, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825B738C: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825B7390: 4099FB48  ble cr6, 0x825b6ed8
	if !ctx.cr[6].gt {
	pc = 0x825B6ED8; continue 'dispatch;
	}
	// 825B7394: 396BFFE4  addi r11, r11, -0x1c
	ctx.r[11].s64 = ctx.r[11].s64 + -28;
	// 825B7398: 895FFFFF  lbz r10, -1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825B739C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B73A0: 7FEAFA14  add r31, r10, r31
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 825B73A4: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825B73A8: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825B73AC: 4199FB2C  bgt cr6, 0x825b6ed8
	if ctx.cr[6].gt {
	pc = 0x825B6ED8; continue 'dispatch;
	}
	// 825B73B0: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 825B73B4: 7CAAF850  subf r5, r10, r31
	ctx.r[5].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 825B73B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B73BC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825B73C0: 4BFFFAC1  bl 0x825b6e80
	ctx.lr = 0x825B73C4;
	sub_825B6E80(ctx, base);
	// 825B73C4: 4BFFFB14  b 0x825b6ed8
	pc = 0x825B6ED8; continue 'dispatch;
            }
            0x825B73C8 => {
    //   block [0x825B73C8..0x825B7414)
	// 825B73C8: 392BFFDD  addi r9, r11, -0x23
	ctx.r[9].s64 = ctx.r[11].s64 + -35;
	// 825B73CC: 88DF0003  lbz r6, 3(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825B73D0: 396BFFE1  addi r11, r11, -0x1f
	ctx.r[11].s64 = ctx.r[11].s64 + -31;
	// 825B73D4: 891F0004  lbz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B73D8: 5525103A  slwi r5, r9, 2
	ctx.r[5].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 825B73DC: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B73E0: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 825B73E4: 88FF0001  lbz r7, 1(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B73E8: 54C9403E  rotlwi r9, r6, 8
	ctx.r[9].u64 = ((ctx.r[6].u32).rotate_left(8)) as u64;
	// 825B73EC: 397F0007  addi r11, r31, 7
	ctx.r[11].s64 = ctx.r[31].s64 + 7;
	// 825B73F0: 7D094214  add r8, r9, r8
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 825B73F4: 7CC5F02E  lwzx r6, r5, r30
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825B73F8: 7D24F02E  lwzx r9, r4, r30
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825B73FC: 7F065000  cmpw cr6, r6, r10
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825B7400: 41990014  bgt cr6, 0x825b7414
	if ctx.cr[6].gt {
	pc = 0x825B7414; continue 'dispatch;
	}
	// 825B7404: 7F093800  cmpw cr6, r9, r7
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[7].s32, &mut ctx.xer);
	// 825B7408: 4098051C  bge cr6, 0x825b7924
	if !ctx.cr[6].lt {
	pc = 0x825B7924; continue 'dispatch;
	}
	// 825B740C: 7FE85A14  add r31, r8, r11
	ctx.r[31].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 825B7410: 4BFFFAC8  b 0x825b6ed8
	pc = 0x825B6ED8; continue 'dispatch;
            }
            0x825B7414 => {
    //   block [0x825B7414..0x825B744C)
	// 825B7414: 894BFFFE  lbz r10, -2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-2 as u32) ) } as u64;
	// 825B7418: 7F093800  cmpw cr6, r9, r7
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[7].s32, &mut ctx.xer);
	// 825B741C: 892BFFFF  lbz r9, -1(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825B7420: 554A403E  rotlwi r10, r10, 8
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(8)) as u64;
	// 825B7424: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825B7428: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B742C: 4098FAAC  bge cr6, 0x825b6ed8
	if !ctx.cr[6].lt {
	pc = 0x825B6ED8; continue 'dispatch;
	}
	// 825B7430: 7D6A4050  subf r11, r10, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	// 825B7434: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 825B7438: 7CABFA14  add r5, r11, r31
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825B743C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B7440: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825B7444: 4BFFFA3D  bl 0x825b6e80
	ctx.lr = 0x825B7448;
	sub_825B6E80(ctx, base);
	// 825B7448: 4BFFFA90  b 0x825b6ed8
	pc = 0x825B6ED8; continue 'dispatch;
            }
            0x825B744C => {
    //   block [0x825B744C..0x825B7484)
	// 825B744C: 394BFFDA  addi r10, r11, -0x26
	ctx.r[10].s64 = ctx.r[11].s64 + -38;
	// 825B7450: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B7454: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825B7458: 7D4AF02E  lwzx r10, r10, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825B745C: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825B7460: 419804C4  blt cr6, 0x825b7924
	if ctx.cr[6].lt {
	pc = 0x825B7924; continue 'dispatch;
	}
	// 825B7464: 396BFFDE  addi r11, r11, -0x22
	ctx.r[11].s64 = ctx.r[11].s64 + -34;
	// 825B7468: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B746C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B7470: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825B7474: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825B7478: 409804AC  bge cr6, 0x825b7924
	if !ctx.cr[6].lt {
	pc = 0x825B7924; continue 'dispatch;
	}
	// 825B747C: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825B7480: 4BFFFA58  b 0x825b6ed8
	pc = 0x825B6ED8; continue 'dispatch;
            }
            0x825B7484 => {
    //   block [0x825B7484..0x825B74EC)
	// 825B7484: 394BFFDB  addi r10, r11, -0x25
	ctx.r[10].s64 = ctx.r[11].s64 + -37;
	// 825B7488: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B748C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825B7490: 5528403E  rotlwi r8, r9, 8
	ctx.r[8].u64 = ((ctx.r[9].u32).rotate_left(8)) as u64;
	// 825B7494: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825B7498: 7CEAE02E  lwzx r7, r10, r28
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 825B749C: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B74A0: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 825B74A4: 554A402E  slwi r10, r10, 8
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(8);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825B74A8: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825B74AC: 7F075000  cmpw cr6, r7, r10
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825B74B0: 41980474  blt cr6, 0x825b7924
	if ctx.cr[6].lt {
	pc = 0x825B7924; continue 'dispatch;
	}
	// 825B74B4: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B74B8: 390BFFDF  addi r8, r11, -0x21
	ctx.r[8].s64 = ctx.r[11].s64 + -33;
	// 825B74BC: 893F0005  lbz r9, 5(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(5 as u32) ) } as u64;
	// 825B74C0: 554B403E  rotlwi r11, r10, 8
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(8)) as u64;
	// 825B74C4: 895F0006  lbz r10, 6(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 825B74C8: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B74CC: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825B74D0: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B74D4: 7D28E02E  lwzx r9, r8, r28
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 825B74D8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B74DC: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825B74E0: 41990444  bgt cr6, 0x825b7924
	if ctx.cr[6].gt {
	pc = 0x825B7924; continue 'dispatch;
	}
	// 825B74E4: 3BFF0007  addi r31, r31, 7
	ctx.r[31].s64 = ctx.r[31].s64 + 7;
	// 825B74E8: 4BFFF9F0  b 0x825b6ed8
	pc = 0x825B6ED8; continue 'dispatch;
            }
            0x825B74EC => {
    //   block [0x825B74EC..0x825B74FC)
	// 825B74EC: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B74F0: 395F0002  addi r10, r31, 2
	ctx.r[10].s64 = ctx.r[31].s64 + 2;
	// 825B74F4: 7FEB5214  add r31, r11, r10
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B74F8: 4BFFF9E0  b 0x825b6ed8
	pc = 0x825B6ED8; continue 'dispatch;
            }
            0x825B74FC => {
    //   block [0x825B74FC..0x825B7518)
	// 825B74FC: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B7500: 393F0003  addi r9, r31, 3
	ctx.r[9].s64 = ctx.r[31].s64 + 3;
	// 825B7504: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B7508: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825B750C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B7510: 7FEB4A14  add r31, r11, r9
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825B7514: 4BFFF9C4  b 0x825b6ed8
	pc = 0x825B6ED8; continue 'dispatch;
            }
            0x825B7518 => {
    //   block [0x825B7518..0x825B7540)
	// 825B7518: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B751C: 391F0004  addi r8, r31, 4
	ctx.r[8].s64 = ctx.r[31].s64 + 4;
	// 825B7520: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B7524: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825B7528: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825B752C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B7530: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B7534: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825B7538: 7FEB4214  add r31, r11, r8
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825B753C: 4BFFF99C  b 0x825b6ed8
	pc = 0x825B6ED8; continue 'dispatch;
            }
            0x825B7540 => {
    //   block [0x825B7540..0x825B7564)
	// 825B7540: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B7544: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B7548: 813C0030  lwz r9, 0x30(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) } as u64;
	// 825B754C: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825B7550: 7D7B5378  or r27, r11, r10
	ctx.r[27].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 825B7554: 576A482C  slwi r10, r27, 9
	ctx.r[10].u32 = ctx.r[27].u32.wrapping_shl(9);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825B7558: 81690020  lwz r11, 0x20(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 825B755C: 7FEB5214  add r31, r11, r10
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B7560: 4BFFF978  b 0x825b6ed8
	pc = 0x825B6ED8; continue 'dispatch;
            }
            0x825B7564 => {
    //   block [0x825B7564..0x825B7654)
	// 825B7564: 811E0020  lwz r8, 0x20(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 825B7568: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B756C: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B7570: 7CC94214  add r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 825B7574: 80FE0024  lwz r7, 0x24(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 825B7578: 811E0028  lwz r8, 0x28(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 825B757C: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825B7580: 7CEA3A14  add r7, r10, r7
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 825B7584: 815E0030  lwz r10, 0x30(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 825B7588: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825B758C: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 825B7590: 811C0020  lwz r8, 0x20(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 825B7594: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B7598: 80BC0024  lwz r5, 0x24(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 825B759C: 809C0028  lwz r4, 0x28(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) } as u64;
	// 825B75A0: 807C0010  lwz r3, 0x10(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 825B75A4: 83BC0014  lwz r29, 0x14(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B75A8: 82FC0018  lwz r23, 0x18(r28)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 825B75AC: 82DE0034  lwz r22, 0x34(r30)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 825B75B0: 83DE002C  lwz r30, 0x2c(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 825B75B4: 92C10084  stw r22, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[22].u32 ) };
	// 825B75B8: 93C1007C  stw r30, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 825B75BC: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825B75C0: 7CC65830  slw r6, r6, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = ((ctx.r[6].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 825B75C4: 7CE75830  slw r7, r7, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = ((ctx.r[7].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 825B75C8: 7D2B5830  slw r11, r9, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[9].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 825B75CC: 90C10070  stw r6, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[6].u32 ) };
	// 825B75D0: 90E10074  stw r7, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[7].u32 ) };
	// 825B75D4: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 825B75D8: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 825B75DC: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 825B75E0: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 825B75E4: 216B0010  subfic r11, r11, 0x10
	ctx.xer.ca = ctx.r[11].u32 <= 16 as u32;
	ctx.r[11].s64 = (16 as i64) - ctx.r[11].s64;
	// 825B75E8: 7D095E30  sraw r9, r8, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[8].s32 >> tmp.u32) as i64;
	// 825B75EC: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 825B75F0: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825B75F4: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825B75F8: 7CA95E30  sraw r9, r5, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[5].s32 >> tmp.u32) as i64;
	// 825B75FC: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 825B7600: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 825B7604: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 825B7608: 7C895E30  sraw r9, r4, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[4].s32 >> tmp.u32) as i64;
	// 825B760C: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 825B7610: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 825B7614: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 825B7618: 7C695E30  sraw r9, r3, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[3].s32 < 0) && ((ctx.r[3].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[3].s32 >> tmp.u32) as i64;
	// 825B761C: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 825B7620: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825B7624: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825B7628: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825B762C: 7FA95E30  sraw r9, r29, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[29].s32 < 0) && ((ctx.r[29].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[29].s32 >> tmp.u32) as i64;
	// 825B7630: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 825B7634: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825B7638: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B763C: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 825B7640: 7EEB5E30  sraw r11, r23, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[23].s32 < 0) && ((ctx.r[23].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[23].s32 >> tmp.u32) as i64;
	// 825B7644: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825B7648: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825B764C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825B7650: 4BFFF888  b 0x825b6ed8
	pc = 0x825B6ED8; continue 'dispatch;
            }
            0x825B7654 => {
    //   block [0x825B7654..0x825B7670)
	// 825B7654: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825B7658: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B765C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B7660: 419A0028  beq cr6, 0x825b7688
	if ctx.cr[6].eq {
	pc = 0x825B7688; continue 'dispatch;
	}
	// 825B7664: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825B7668: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 825B766C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x825B7670; continue 'dispatch;
            }
            0x825B7670 => {
    //   block [0x825B7670..0x825B7688)
	// 825B7670: E95E0000  ld r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 825B7674: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 825B7678: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 825B767C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 825B7680: 4200FFF0  bdnz 0x825b7670
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825B7670; continue 'dispatch;
	}
	// 825B7684: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	pc = 0x825B7688; continue 'dispatch;
            }
            0x825B7688 => {
    //   block [0x825B7688..0x825B769C)
	// 825B7688: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825B768C: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 825B7690: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825B7694: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 825B7698: 4BFFF840  b 0x825b6ed8
	pc = 0x825B6ED8; continue 'dispatch;
            }
            0x825B769C => {
    //   block [0x825B769C..0x825B76C4)
	// 825B769C: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B76A0: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 825B76A4: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B76A8: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825B76AC: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B76B0: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B76B4: 419A0028  beq cr6, 0x825b76dc
	if ctx.cr[6].eq {
	pc = 0x825B76DC; continue 'dispatch;
	}
	// 825B76B8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825B76BC: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 825B76C0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x825B76C4; continue 'dispatch;
            }
            0x825B76C4 => {
    //   block [0x825B76C4..0x825B76DC)
	// 825B76C4: E95E0000  ld r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 825B76C8: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 825B76CC: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 825B76D0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 825B76D4: 4200FFF0  bdnz 0x825b76c4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825B76C4; continue 'dispatch;
	}
	// 825B76D8: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	pc = 0x825B76DC; continue 'dispatch;
            }
            0x825B76DC => {
    //   block [0x825B76DC..0x825B76F0)
	// 825B76DC: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825B76E0: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825B76E4: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825B76E8: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 825B76EC: 4BFFF7EC  b 0x825b6ed8
	pc = 0x825B6ED8; continue 'dispatch;
            }
            0x825B76F0 => {
    //   block [0x825B76F0..0x825B7730)
	// 825B76F0: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B76F4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825B76F8: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B76FC: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825B7700: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825B7704: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B7708: 7F1E3840  cmplw cr6, r30, r7
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825B770C: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825B7710: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B7714: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825B7718: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B771C: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B7720: 419A0028  beq cr6, 0x825b7748
	if ctx.cr[6].eq {
	pc = 0x825B7748; continue 'dispatch;
	}
	// 825B7724: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825B7728: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 825B772C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x825B7730; continue 'dispatch;
            }
            0x825B7730 => {
    //   block [0x825B7730..0x825B7748)
	// 825B7730: E95E0000  ld r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 825B7734: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 825B7738: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 825B773C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 825B7740: 4200FFF0  bdnz 0x825b7730
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825B7730; continue 'dispatch;
	}
	// 825B7744: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	pc = 0x825B7748; continue 'dispatch;
            }
            0x825B7748 => {
    //   block [0x825B7748..0x825B774C)
	// 825B7748: 9121007C  stw r9, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[9].u32 ) };
	pc = 0x825B774C; continue 'dispatch;
            }
            0x825B774C => {
    //   block [0x825B774C..0x825B7754)
	// 825B774C: 3BFF0005  addi r31, r31, 5
	ctx.r[31].s64 = ctx.r[31].s64 + 5;
	// 825B7750: 4BFFF788  b 0x825b6ed8
	pc = 0x825B6ED8; continue 'dispatch;
            }
            0x825B7754 => {
    //   block [0x825B7754..0x825B7770)
	// 825B7754: 396BFFA0  addi r11, r11, -0x60
	ctx.r[11].s64 = ctx.r[11].s64 + -96;
	// 825B7758: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B775C: 39210084  addi r9, r1, 0x84
	ctx.r[9].s64 = ctx.r[1].s64 + 132;
	// 825B7760: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B7764: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 825B7768: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 825B776C: 48000068  b 0x825b77d4
	pc = 0x825B77D4; continue 'dispatch;
            }
            0x825B7770 => {
    //   block [0x825B7770..0x825B7798)
	// 825B7770: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B7774: 390BFF9C  addi r8, r11, -0x64
	ctx.r[8].s64 = ctx.r[11].s64 + -100;
	// 825B7778: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B777C: 38E10084  addi r7, r1, 0x84
	ctx.r[7].s64 = ctx.r[1].s64 + 132;
	// 825B7780: 552B403E  rotlwi r11, r9, 8
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(8)) as u64;
	// 825B7784: 5509103A  slwi r9, r8, 2
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825B7788: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B778C: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825B7790: 7D69392E  stwx r11, r9, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32), ctx.r[11].u32) };
	// 825B7794: 48000040  b 0x825b77d4
	pc = 0x825B77D4; continue 'dispatch;
            }
            0x825B7798 => {
    //   block [0x825B7798..0x825B77D4)
	// 825B7798: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B779C: 38EBFF98  addi r7, r11, -0x68
	ctx.r[7].s64 = ctx.r[11].s64 + -104;
	// 825B77A0: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B77A4: 38C10084  addi r6, r1, 0x84
	ctx.r[6].s64 = ctx.r[1].s64 + 132;
	// 825B77A8: 554B403E  rotlwi r11, r10, 8
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(8)) as u64;
	// 825B77AC: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825B77B0: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B77B4: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825B77B8: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825B77BC: 3BFF0005  addi r31, r31, 5
	ctx.r[31].s64 = ctx.r[31].s64 + 5;
	// 825B77C0: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B77C4: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825B77C8: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B77CC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B77D0: 7D67312E  stwx r11, r7, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32), ctx.r[11].u32) };
	pc = 0x825B77D4; continue 'dispatch;
            }
            0x825B77D4 => {
    //   block [0x825B77D4..0x825B77F0)
	// 825B77D4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825B77D8: 81210084  lwz r9, 0x84(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 825B77DC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B77E0: 419A0028  beq cr6, 0x825b7808
	if ctx.cr[6].eq {
	pc = 0x825B7808; continue 'dispatch;
	}
	// 825B77E4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825B77E8: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 825B77EC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x825B77F0; continue 'dispatch;
            }
            0x825B77F0 => {
    //   block [0x825B77F0..0x825B7808)
	// 825B77F0: E95E0000  ld r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 825B77F4: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 825B77F8: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 825B77FC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 825B7800: 4200FFF0  bdnz 0x825b77f0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825B77F0; continue 'dispatch;
	}
	// 825B7804: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	pc = 0x825B7808; continue 'dispatch;
            }
            0x825B7808 => {
    //   block [0x825B7808..0x825B7810)
	// 825B7808: 91210084  stw r9, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[9].u32 ) };
	// 825B780C: 4BFFF6CC  b 0x825b6ed8
	pc = 0x825B6ED8; continue 'dispatch;
            }
            0x825B7810 => {
    //   block [0x825B7810..0x825B7864)
	// 825B7810: 38A00200  li r5, 0x200
	ctx.r[5].s64 = 512;
	// 825B7814: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 825B7818: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825B781C: 4BEB15DD  bl 0x82468df8
	ctx.lr = 0x825B7820;
	sub_82468DF8(ctx, base);
	// 825B7820: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825B7824: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825B7828: 4BEB0A79  bl 0x824682a0
	ctx.lr = 0x825B782C;
	sub_824682A0(ctx, base);
	// 825B782C: 80789190  lwz r3, -0x6e70(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-28272 as u32) ) } as u64;
	// 825B7830: 3CA01298  lis r5, 0x1298
	ctx.r[5].s64 = 311951360;
	// 825B7834: 390001C2  li r8, 0x1c2
	ctx.r[8].s64 = 450;
	// 825B7838: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 825B783C: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 825B7840: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B7844: 60A5FEDD  ori r5, r5, 0xfedd
	ctx.r[5].u64 = ctx.r[5].u64 | 65245;
	// 825B7848: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825B784C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B7850: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B7854: 4E800421  bctrl
	ctx.lr = 0x825B7858;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B7858: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825B785C: 4BEB1085  bl 0x824688e0
	ctx.lr = 0x825B7860;
	sub_824688E0(ctx, base);
	// 825B7860: 4BFFF678  b 0x825b6ed8
	pc = 0x825B6ED8; continue 'dispatch;
            }
            0x825B7864 => {
    //   block [0x825B7864..0x825B786C)
	// 825B7864: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B7868: 48000068  b 0x825b78d0
	pc = 0x825B78D0; continue 'dispatch;
            }
            0x825B786C => {
    //   block [0x825B786C..0x825B7880)
	// 825B786C: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B7870: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B7874: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825B7878: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B787C: 48000054  b 0x825b78d0
	pc = 0x825B78D0; continue 'dispatch;
            }
            0x825B7880 => {
    //   block [0x825B7880..0x825B78A0)
	// 825B7880: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B7884: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B7888: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825B788C: 895F0003  lbz r10, 3(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825B7890: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825B7894: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B7898: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B789C: 48000034  b 0x825b78d0
	pc = 0x825B78D0; continue 'dispatch;
            }
            0x825B78A0 => {
    //   block [0x825B78A0..0x825B78CC)
	// 825B78A0: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B78A4: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B78A8: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825B78AC: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825B78B0: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B78B4: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825B78B8: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B78BC: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825B78C0: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B78C4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B78C8: 48000008  b 0x825b78d0
	pc = 0x825B78D0; continue 'dispatch;
            }
            0x825B78CC => {
    //   block [0x825B78CC..0x825B78D0)
	// 825B78CC: 396BFFD0  addi r11, r11, -0x30
	ctx.r[11].s64 = ctx.r[11].s64 + -48;
	pc = 0x825B78D0; continue 'dispatch;
            }
            0x825B78D0 => {
    //   block [0x825B78D0..0x825B790C)
	// 825B78D0: 815E002C  lwz r10, 0x2c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 825B78D4: 5769402E  slwi r9, r27, 8
	ctx.r[9].u32 = ctx.r[27].u32.wrapping_shl(8);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825B78D8: 811C0034  lwz r8, 0x34(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) } as u64;
	// 825B78DC: 83FC0000  lwz r31, 0(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B78E0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B78E4: 7D094838  and r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 825B78E8: 7D3E5B78  or r30, r9, r11
	ctx.r[30].u64 = ctx.r[9].u64 | ctx.r[11].u64;
	// 825B78EC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B78F0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B78F4: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825B78F8: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825B78FC: 409A0010  bne cr6, 0x825b790c
	if !ctx.cr[6].eq {
	pc = 0x825B790C; continue 'dispatch;
	}
	// 825B7900: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 825B7904: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B7908: 4BEB6A49  bl 0x8246e350
	ctx.lr = 0x825B790C;
	sub_8246E350(ctx, base);
	pc = 0x825B790C; continue 'dispatch;
            }
            0x825B790C => {
    //   block [0x825B790C..0x825B7924)
	// 825B790C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B7910: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B7914: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825B7918: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825B791C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825B7920: 7FCA492E  stwx r30, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[30].u32) };
	pc = 0x825B7924; continue 'dispatch;
            }
            0x825B7924 => {
    //   block [0x825B7924..0x825B792C)
	// 825B7924: 38210300  addi r1, r1, 0x300
	ctx.r[1].s64 = ctx.r[1].s64 + 768;
	// 825B7928: 4BF7D7C8  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B7930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B7930 size=536
    let mut pc: u32 = 0x825B7930;
    'dispatch: loop {
        match pc {
            0x825B7930 => {
    //   block [0x825B7930..0x825B7B48)
	// 825B7930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B7934: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B7938: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B793C: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 825B7940: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825B7944: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 825B7948: D0210070  stfs f1, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 825B794C: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 825B7950: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 825B7954: 91430030  stw r10, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B7B48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B7B48 size=416
    let mut pc: u32 = 0x825B7B48;
    'dispatch: loop {
        match pc {
            0x825B7B48 => {
    //   block [0x825B7B48..0x825B7CE8)
	// 825B7B48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B7B4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B7B50: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B7B54: 90830030  stw r4, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[4].u32 ) };
	// 825B7B58: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825B7B5C: 90C30000  stw r6, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 825B7B60: C1A40010  lfs f13, 0x10(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825B7B64: C1850000  lfs f12, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825B7B68: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825B7B6C: ED8C6828  fsubs f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 825B7B70: C004001C  lfs f0, 0x1c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B7B74: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 825B7B78: FD80601E  fctiwz f12, f12
	ctx.f[12].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 825B7B7C: 7D805FAE  stfiwx f12, 0, r11
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 825B7B80: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B7B84: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825B7B88: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B7B8C: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 825B7B90: C1850010  lfs f12, 0x10(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825B7B94: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 825B7B98: A1630020  lhz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 825B7B9C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 825B7BA0: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 825B7BA4: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825B7BA8: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 825B7BAC: 7DA057AE  stfiwx f13, 0, r10
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 825B7BB0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B7BB4: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825B7BB8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825B7BBC: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 825B7BC0: C1A40014  lfs f13, 0x14(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825B7BC4: C1850004  lfs f12, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825B7BC8: A1630010  lhz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 825B7BCC: ED8C6828  fsubs f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 825B7BD0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 825B7BD4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825B7BD8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825B7BDC: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 825B7BE0: FD80601E  fctiwz f12, f12
	ctx.f[12].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 825B7BE4: 7D8057AE  stfiwx f12, 0, r10
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 825B7BE8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B7BEC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825B7BF0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B7BF4: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 825B7BF8: C1850014  lfs f12, 0x14(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825B7BFC: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 825B7C00: A1630024  lhz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 825B7C04: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 825B7C08: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 825B7C0C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825B7C10: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 825B7C14: 7DA057AE  stfiwx f13, 0, r10
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 825B7C18: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B7C1C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825B7C20: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825B7C24: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 825B7C28: C1A40018  lfs f13, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825B7C2C: C1850008  lfs f12, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825B7C30: ED8C6828  fsubs f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 825B7C34: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 825B7C38: FD80601E  fctiwz f12, f12
	ctx.f[12].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 825B7C3C: 7D8057AE  stfiwx f12, 0, r10
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 825B7C40: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B7C44: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825B7C48: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B7C4C: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 825B7C50: C1850018  lfs f12, 0x18(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825B7C54: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 825B7C58: A1230028  lhz r9, 0x28(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 825B7C5C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825B7C60: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 825B7C64: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 825B7C68: A1430014  lhz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B7C6C: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 825B7C70: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825B7C74: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 825B7C78: 7D2A0734  extsh r10, r9
	ctx.r[10].s64 = ctx.r[9].s16 as i64;
	// 825B7C7C: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 825B7C80: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B7C84: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825B7C88: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 825B7C8C: 7D6B8670  srawi r11, r11, 0x10
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 16) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 16) as i64;
	// 825B7C90: 80A40020  lwz r5, 0x20(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 825B7C94: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825B7C98: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825B7C9C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 825B7CA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B7CA4: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 825B7CA8: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 825B7CAC: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 825B7CB0: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 825B7CB4: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 825B7CB8: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 825B7CBC: 89650000  lbz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B7CC0: 396BFFF3  addi r11, r11, -0xd
	ctx.r[11].s64 = ctx.r[11].s64 + -13;
	// 825B7CC4: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825B7CC8: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 825B7CCC: 7D6B00D0  neg r11, r11
	ctx.r[11].s64 = -ctx.r[11].s64;
	// 825B7CD0: 91630034  stw r11, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 825B7CD4: 4BFFF1AD  bl 0x825b6e80
	ctx.lr = 0x825B7CD8;
	sub_825B6E80(ctx, base);
	// 825B7CD8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825B7CDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B7CE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B7CE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B7CE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B7CE8 size=4364
    let mut pc: u32 = 0x825B7CE8;
    'dispatch: loop {
        match pc {
            0x825B7CE8 => {
    //   block [0x825B7CE8..0x825B7D38)
	// 825B7CE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B7CEC: 4BF7D395  bl 0x82535080
	ctx.lr = 0x825B7CF0;
	sub_82535080(ctx, base);
	// 825B7CF0: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 825B7CF4: 4BF7E2E5  bl 0x82535fd8
	ctx.lr = 0x825B7CF8;
	sub_82535FB0(ctx, base);
	// 825B7CF8: 9421FB60  stwu r1, -0x4a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-1184 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B7CFC: 3FA0829A  lis r29, -0x7d66
	ctx.r[29].s64 = -2103836672;
	// 825B7D00: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 825B7D04: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 825B7D08: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825B7D0C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 825B7D10: 897D3E85  lbz r11, 0x3e85(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(16005 as u32) ) } as u64;
	// 825B7D14: 7CF13B78  mr r17, r7
	ctx.r[17].u64 = ctx.r[7].u64;
	// 825B7D18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B7D1C: 409A001C  bne cr6, 0x825b7d38
	if !ctx.cr[6].eq {
	pc = 0x825B7D38; continue 'dispatch;
	}
	// 825B7D20: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 825B7D24: 4BF4141D  bl 0x824f9140
	ctx.lr = 0x825B7D28;
	sub_824F9140(ctx, base);
	// 825B7D28: 7C6B0774  extsb r11, r3
	ctx.r[11].s64 = ctx.r[3].s8 as i64;
	// 825B7D2C: 987D3E85  stb r3, 0x3e85(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(16005 as u32), ctx.r[3].u8 ) };
	// 825B7D30: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B7D34: 419A10B0  beq cr6, 0x825b8de4
	if ctx.cr[6].eq {
	pc = 0x825B8DE4; continue 'dispatch;
	}
	pc = 0x825B7D38; continue 'dispatch;
            }
            0x825B7D38 => {
    //   block [0x825B7D38..0x825B7D7C)
	// 825B7D38: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825B7D3C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 825B7D40: 3ACB9F60  addi r22, r11, -0x60a0
	ctx.r[22].s64 = ctx.r[11].s64 + -24736;
	// 825B7D44: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825B7D48: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825B7D4C: 3A0BA2A0  addi r16, r11, -0x5d60
	ctx.r[16].s64 = ctx.r[11].s64 + -23904;
	// 825B7D50: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825B7D54: C3291FF8  lfs f25, 0x1ff8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 825B7D58: 3DC08293  lis r14, -0x7d6d
	ctx.r[14].s64 = -2104295424;
	// 825B7D5C: 39EBA1D8  addi r15, r11, -0x5e28
	ctx.r[15].s64 = ctx.r[11].s64 + -24104;
	// 825B7D60: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825B7D64: C30A1850  lfs f24, 0x1850(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6224 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 825B7D68: 3A400020  li r18, 0x20
	ctx.r[18].s64 = 32;
	// 825B7D6C: 3AEB9B20  addi r23, r11, -0x64e0
	ctx.r[23].s64 = ctx.r[11].s64 + -25824;
	// 825B7D70: 3A600030  li r19, 0x30
	ctx.r[19].s64 = 48;
	// 825B7D74: 3AA00010  li r21, 0x10
	ctx.r[21].s64 = 16;
	// 825B7D78: 3A800014  li r20, 0x14
	ctx.r[20].s64 = 20;
	pc = 0x825B7D7C; continue 'dispatch;
            }
            0x825B7D7C => {
    //   block [0x825B7D7C..0x825B7F54)
	// 825B7D7C: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B7D80: 3B8003E7  li r28, 0x3e7
	ctx.r[28].s64 = 999;
	// 825B7D84: 2B0B006B  cmplwi cr6, r11, 0x6b
	ctx.cr[6].compare_u32(ctx.r[11].u32, 107 as u32, &mut ctx.xer);
	// 825B7D88: 41990E60  bgt cr6, 0x825b8be8
	if ctx.cr[6].gt {
	pc = 0x825B8BE8; continue 'dispatch;
	}
	// 825B7D8C: 3D80825B  lis r12, -0x7da5
	ctx.r[12].s64 = -2107965440;
	// 825B7D90: 398C7DA4  addi r12, r12, 0x7da4
	ctx.r[12].s64 = ctx.r[12].s64 + 32164;
	// 825B7D94: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 825B7D98: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 825B7D9C: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 825B7DA0: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x825B8DE4; continue 'dispatch;
		},
		1 => {
	pc = 0x825B8900; continue 'dispatch;
		},
		2 => {
	pc = 0x825B8900; continue 'dispatch;
		},
		3 => {
	pc = 0x825B8900; continue 'dispatch;
		},
		4 => {
	pc = 0x825B8900; continue 'dispatch;
		},
		5 => {
	pc = 0x825B8888; continue 'dispatch;
		},
		6 => {
	pc = 0x825B8898; continue 'dispatch;
		},
		7 => {
	pc = 0x825B88B4; continue 'dispatch;
		},
		8 => {
	pc = 0x825B8BE8; continue 'dispatch;
		},
		9 => {
	pc = 0x825B89FC; continue 'dispatch;
		},
		10 => {
	pc = 0x825B8A50; continue 'dispatch;
		},
		11 => {
	pc = 0x825B8AB0; continue 'dispatch;
		},
		12 => {
	pc = 0x825B88DC; continue 'dispatch;
		},
		13 => {
	pc = 0x825B8B18; continue 'dispatch;
		},
		14 => {
	pc = 0x825B8BE8; continue 'dispatch;
		},
		15 => {
	pc = 0x825B8BE8; continue 'dispatch;
		},
		16 => {
	pc = 0x825B83B4; continue 'dispatch;
		},
		17 => {
	pc = 0x825B83B4; continue 'dispatch;
		},
		18 => {
	pc = 0x825B83B4; continue 'dispatch;
		},
		19 => {
	pc = 0x825B7F54; continue 'dispatch;
		},
		20 => {
	pc = 0x825B7FA8; continue 'dispatch;
		},
		21 => {
	pc = 0x825B8004; continue 'dispatch;
		},
		22 => {
	pc = 0x825B8058; continue 'dispatch;
		},
		23 => {
	pc = 0x825B80B4; continue 'dispatch;
		},
		24 => {
	pc = 0x825B8108; continue 'dispatch;
		},
		25 => {
	pc = 0x825B8164; continue 'dispatch;
		},
		26 => {
	pc = 0x825B81D0; continue 'dispatch;
		},
		27 => {
	pc = 0x825B8244; continue 'dispatch;
		},
		28 => {
	pc = 0x825B82B8; continue 'dispatch;
		},
		29 => {
	pc = 0x825B8BE8; continue 'dispatch;
		},
		30 => {
	pc = 0x825B8BE8; continue 'dispatch;
		},
		31 => {
	pc = 0x825B8BE8; continue 'dispatch;
		},
		32 => {
	pc = 0x825B832C; continue 'dispatch;
		},
		33 => {
	pc = 0x825B832C; continue 'dispatch;
		},
		34 => {
	pc = 0x825B832C; continue 'dispatch;
		},
		35 => {
	pc = 0x825B835C; continue 'dispatch;
		},
		36 => {
	pc = 0x825B835C; continue 'dispatch;
		},
		37 => {
	pc = 0x825B835C; continue 'dispatch;
		},
		38 => {
	pc = 0x825B874C; continue 'dispatch;
		},
		39 => {
	pc = 0x825B874C; continue 'dispatch;
		},
		40 => {
	pc = 0x825B874C; continue 'dispatch;
		},
		41 => {
	pc = 0x825B86B8; continue 'dispatch;
		},
		42 => {
	pc = 0x825B86B8; continue 'dispatch;
		},
		43 => {
	pc = 0x825B86B8; continue 'dispatch;
		},
		44 => {
	pc = 0x825B8BE8; continue 'dispatch;
		},
		45 => {
	pc = 0x825B8BE8; continue 'dispatch;
		},
		46 => {
	pc = 0x825B8BE8; continue 'dispatch;
		},
		47 => {
	pc = 0x825B8BE8; continue 'dispatch;
		},
		48 => {
	pc = 0x825B8CA4; continue 'dispatch;
		},
		49 => {
	pc = 0x825B8CA4; continue 'dispatch;
		},
		50 => {
	pc = 0x825B8CA4; continue 'dispatch;
		},
		51 => {
	pc = 0x825B8CA4; continue 'dispatch;
		},
		52 => {
	pc = 0x825B8CA4; continue 'dispatch;
		},
		53 => {
	pc = 0x825B8CA4; continue 'dispatch;
		},
		54 => {
	pc = 0x825B8CA4; continue 'dispatch;
		},
		55 => {
	pc = 0x825B8CA4; continue 'dispatch;
		},
		56 => {
	pc = 0x825B8CA4; continue 'dispatch;
		},
		57 => {
	pc = 0x825B8CA4; continue 'dispatch;
		},
		58 => {
	pc = 0x825B8CA4; continue 'dispatch;
		},
		59 => {
	pc = 0x825B8CA4; continue 'dispatch;
		},
		60 => {
	pc = 0x825B8CA4; continue 'dispatch;
		},
		61 => {
	pc = 0x825B8CA4; continue 'dispatch;
		},
		62 => {
	pc = 0x825B8CA4; continue 'dispatch;
		},
		63 => {
	pc = 0x825B8CA4; continue 'dispatch;
		},
		64 => {
	pc = 0x825B8CA4; continue 'dispatch;
		},
		65 => {
	pc = 0x825B8CA4; continue 'dispatch;
		},
		66 => {
	pc = 0x825B8CA4; continue 'dispatch;
		},
		67 => {
	pc = 0x825B8CA4; continue 'dispatch;
		},
		68 => {
	pc = 0x825B8CA4; continue 'dispatch;
		},
		69 => {
	pc = 0x825B8CA4; continue 'dispatch;
		},
		70 => {
	pc = 0x825B8CA4; continue 'dispatch;
		},
		71 => {
	pc = 0x825B8CA4; continue 'dispatch;
		},
		72 => {
	pc = 0x825B8CA4; continue 'dispatch;
		},
		73 => {
	pc = 0x825B8CA4; continue 'dispatch;
		},
		74 => {
	pc = 0x825B8CA4; continue 'dispatch;
		},
		75 => {
	pc = 0x825B8CA4; continue 'dispatch;
		},
		76 => {
	pc = 0x825B8CA4; continue 'dispatch;
		},
		77 => {
	pc = 0x825B8CA4; continue 'dispatch;
		},
		78 => {
	pc = 0x825B8CA4; continue 'dispatch;
		},
		79 => {
	pc = 0x825B8CA4; continue 'dispatch;
		},
		80 => {
	pc = 0x825B8C3C; continue 'dispatch;
		},
		81 => {
	pc = 0x825B8C44; continue 'dispatch;
		},
		82 => {
	pc = 0x825B8C58; continue 'dispatch;
		},
		83 => {
	pc = 0x825B8C78; continue 'dispatch;
		},
		84 => {
	pc = 0x825B8BE8; continue 'dispatch;
		},
		85 => {
	pc = 0x825B8BE8; continue 'dispatch;
		},
		86 => {
	pc = 0x825B8BE8; continue 'dispatch;
		},
		87 => {
	pc = 0x825B8BE8; continue 'dispatch;
		},
		88 => {
	pc = 0x825B8BE8; continue 'dispatch;
		},
		89 => {
	pc = 0x825B8BE8; continue 'dispatch;
		},
		90 => {
	pc = 0x825B8BE8; continue 'dispatch;
		},
		91 => {
	pc = 0x825B8BE8; continue 'dispatch;
		},
		92 => {
	pc = 0x825B8BE8; continue 'dispatch;
		},
		93 => {
	pc = 0x825B8BE8; continue 'dispatch;
		},
		94 => {
	pc = 0x825B8BE8; continue 'dispatch;
		},
		95 => {
	pc = 0x825B8BE8; continue 'dispatch;
		},
		96 => {
	pc = 0x825B8B20; continue 'dispatch;
		},
		97 => {
	pc = 0x825B8B20; continue 'dispatch;
		},
		98 => {
	pc = 0x825B8B20; continue 'dispatch;
		},
		99 => {
	pc = 0x825B8B20; continue 'dispatch;
		},
		100 => {
	pc = 0x825B8B3C; continue 'dispatch;
		},
		101 => {
	pc = 0x825B8B3C; continue 'dispatch;
		},
		102 => {
	pc = 0x825B8B3C; continue 'dispatch;
		},
		103 => {
	pc = 0x825B8B3C; continue 'dispatch;
		},
		104 => {
	pc = 0x825B8B64; continue 'dispatch;
		},
		105 => {
	pc = 0x825B8B64; continue 'dispatch;
		},
		106 => {
	pc = 0x825B8B64; continue 'dispatch;
		},
		107 => {
	pc = 0x825B8B64; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 825B7DA4: 825B8DE4  lwz r18, -0x721c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29212 as u32) ) } as u64;
	// 825B7DA8: 825B8900  lwz r18, -0x7700(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-30464 as u32) ) } as u64;
	// 825B7DAC: 825B8900  lwz r18, -0x7700(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-30464 as u32) ) } as u64;
	// 825B7DB0: 825B8900  lwz r18, -0x7700(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-30464 as u32) ) } as u64;
	// 825B7DB4: 825B8900  lwz r18, -0x7700(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-30464 as u32) ) } as u64;
	// 825B7DB8: 825B8888  lwz r18, -0x7778(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-30584 as u32) ) } as u64;
	// 825B7DBC: 825B8898  lwz r18, -0x7768(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-30568 as u32) ) } as u64;
	// 825B7DC0: 825B88B4  lwz r18, -0x774c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-30540 as u32) ) } as u64;
	// 825B7DC4: 825B8BE8  lwz r18, -0x7418(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29720 as u32) ) } as u64;
	// 825B7DC8: 825B89FC  lwz r18, -0x7604(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-30212 as u32) ) } as u64;
	// 825B7DCC: 825B8A50  lwz r18, -0x75b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-30128 as u32) ) } as u64;
	// 825B7DD0: 825B8AB0  lwz r18, -0x7550(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-30032 as u32) ) } as u64;
	// 825B7DD4: 825B88DC  lwz r18, -0x7724(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-30500 as u32) ) } as u64;
	// 825B7DD8: 825B8B18  lwz r18, -0x74e8(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29928 as u32) ) } as u64;
	// 825B7DDC: 825B8BE8  lwz r18, -0x7418(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29720 as u32) ) } as u64;
	// 825B7DE0: 825B8BE8  lwz r18, -0x7418(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29720 as u32) ) } as u64;
	// 825B7DE4: 825B83B4  lwz r18, -0x7c4c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-31820 as u32) ) } as u64;
	// 825B7DE8: 825B83B4  lwz r18, -0x7c4c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-31820 as u32) ) } as u64;
	// 825B7DEC: 825B83B4  lwz r18, -0x7c4c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-31820 as u32) ) } as u64;
	// 825B7DF0: 825B7F54  lwz r18, 0x7f54(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32596 as u32) ) } as u64;
	// 825B7DF4: 825B7FA8  lwz r18, 0x7fa8(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32680 as u32) ) } as u64;
	// 825B7DF8: 825B8004  lwz r18, -0x7ffc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-32764 as u32) ) } as u64;
	// 825B7DFC: 825B8058  lwz r18, -0x7fa8(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-32680 as u32) ) } as u64;
	// 825B7E00: 825B80B4  lwz r18, -0x7f4c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-32588 as u32) ) } as u64;
	// 825B7E04: 825B8108  lwz r18, -0x7ef8(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-32504 as u32) ) } as u64;
	// 825B7E08: 825B8164  lwz r18, -0x7e9c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-32412 as u32) ) } as u64;
	// 825B7E0C: 825B81D0  lwz r18, -0x7e30(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-32304 as u32) ) } as u64;
	// 825B7E10: 825B8244  lwz r18, -0x7dbc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-32188 as u32) ) } as u64;
	// 825B7E14: 825B82B8  lwz r18, -0x7d48(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-32072 as u32) ) } as u64;
	// 825B7E18: 825B8BE8  lwz r18, -0x7418(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29720 as u32) ) } as u64;
	// 825B7E1C: 825B8BE8  lwz r18, -0x7418(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29720 as u32) ) } as u64;
	// 825B7E20: 825B8BE8  lwz r18, -0x7418(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29720 as u32) ) } as u64;
	// 825B7E24: 825B832C  lwz r18, -0x7cd4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-31956 as u32) ) } as u64;
	// 825B7E28: 825B832C  lwz r18, -0x7cd4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-31956 as u32) ) } as u64;
	// 825B7E2C: 825B832C  lwz r18, -0x7cd4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-31956 as u32) ) } as u64;
	// 825B7E30: 825B835C  lwz r18, -0x7ca4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-31908 as u32) ) } as u64;
	// 825B7E34: 825B835C  lwz r18, -0x7ca4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-31908 as u32) ) } as u64;
	// 825B7E38: 825B835C  lwz r18, -0x7ca4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-31908 as u32) ) } as u64;
	// 825B7E3C: 825B874C  lwz r18, -0x78b4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-30900 as u32) ) } as u64;
	// 825B7E40: 825B874C  lwz r18, -0x78b4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-30900 as u32) ) } as u64;
	// 825B7E44: 825B874C  lwz r18, -0x78b4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-30900 as u32) ) } as u64;
	// 825B7E48: 825B86B8  lwz r18, -0x7948(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-31048 as u32) ) } as u64;
	// 825B7E4C: 825B86B8  lwz r18, -0x7948(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-31048 as u32) ) } as u64;
	// 825B7E50: 825B86B8  lwz r18, -0x7948(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-31048 as u32) ) } as u64;
	// 825B7E54: 825B8BE8  lwz r18, -0x7418(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29720 as u32) ) } as u64;
	// 825B7E58: 825B8BE8  lwz r18, -0x7418(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29720 as u32) ) } as u64;
	// 825B7E5C: 825B8BE8  lwz r18, -0x7418(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29720 as u32) ) } as u64;
	// 825B7E60: 825B8BE8  lwz r18, -0x7418(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29720 as u32) ) } as u64;
	// 825B7E64: 825B8CA4  lwz r18, -0x735c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29532 as u32) ) } as u64;
	// 825B7E68: 825B8CA4  lwz r18, -0x735c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29532 as u32) ) } as u64;
	// 825B7E6C: 825B8CA4  lwz r18, -0x735c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29532 as u32) ) } as u64;
	// 825B7E70: 825B8CA4  lwz r18, -0x735c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29532 as u32) ) } as u64;
	// 825B7E74: 825B8CA4  lwz r18, -0x735c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29532 as u32) ) } as u64;
	// 825B7E78: 825B8CA4  lwz r18, -0x735c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29532 as u32) ) } as u64;
	// 825B7E7C: 825B8CA4  lwz r18, -0x735c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29532 as u32) ) } as u64;
	// 825B7E80: 825B8CA4  lwz r18, -0x735c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29532 as u32) ) } as u64;
	// 825B7E84: 825B8CA4  lwz r18, -0x735c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29532 as u32) ) } as u64;
	// 825B7E88: 825B8CA4  lwz r18, -0x735c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29532 as u32) ) } as u64;
	// 825B7E8C: 825B8CA4  lwz r18, -0x735c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29532 as u32) ) } as u64;
	// 825B7E90: 825B8CA4  lwz r18, -0x735c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29532 as u32) ) } as u64;
	// 825B7E94: 825B8CA4  lwz r18, -0x735c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29532 as u32) ) } as u64;
	// 825B7E98: 825B8CA4  lwz r18, -0x735c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29532 as u32) ) } as u64;
	// 825B7E9C: 825B8CA4  lwz r18, -0x735c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29532 as u32) ) } as u64;
	// 825B7EA0: 825B8CA4  lwz r18, -0x735c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29532 as u32) ) } as u64;
	// 825B7EA4: 825B8CA4  lwz r18, -0x735c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29532 as u32) ) } as u64;
	// 825B7EA8: 825B8CA4  lwz r18, -0x735c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29532 as u32) ) } as u64;
	// 825B7EAC: 825B8CA4  lwz r18, -0x735c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29532 as u32) ) } as u64;
	// 825B7EB0: 825B8CA4  lwz r18, -0x735c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29532 as u32) ) } as u64;
	// 825B7EB4: 825B8CA4  lwz r18, -0x735c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29532 as u32) ) } as u64;
	// 825B7EB8: 825B8CA4  lwz r18, -0x735c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29532 as u32) ) } as u64;
	// 825B7EBC: 825B8CA4  lwz r18, -0x735c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29532 as u32) ) } as u64;
	// 825B7EC0: 825B8CA4  lwz r18, -0x735c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29532 as u32) ) } as u64;
	// 825B7EC4: 825B8CA4  lwz r18, -0x735c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29532 as u32) ) } as u64;
	// 825B7EC8: 825B8CA4  lwz r18, -0x735c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29532 as u32) ) } as u64;
	// 825B7ECC: 825B8CA4  lwz r18, -0x735c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29532 as u32) ) } as u64;
	// 825B7ED0: 825B8CA4  lwz r18, -0x735c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29532 as u32) ) } as u64;
	// 825B7ED4: 825B8CA4  lwz r18, -0x735c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29532 as u32) ) } as u64;
	// 825B7ED8: 825B8CA4  lwz r18, -0x735c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29532 as u32) ) } as u64;
	// 825B7EDC: 825B8CA4  lwz r18, -0x735c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29532 as u32) ) } as u64;
	// 825B7EE0: 825B8CA4  lwz r18, -0x735c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29532 as u32) ) } as u64;
	// 825B7EE4: 825B8C3C  lwz r18, -0x73c4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29636 as u32) ) } as u64;
	// 825B7EE8: 825B8C44  lwz r18, -0x73bc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29628 as u32) ) } as u64;
	// 825B7EEC: 825B8C58  lwz r18, -0x73a8(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29608 as u32) ) } as u64;
	// 825B7EF0: 825B8C78  lwz r18, -0x7388(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29576 as u32) ) } as u64;
	// 825B7EF4: 825B8BE8  lwz r18, -0x7418(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29720 as u32) ) } as u64;
	// 825B7EF8: 825B8BE8  lwz r18, -0x7418(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29720 as u32) ) } as u64;
	// 825B7EFC: 825B8BE8  lwz r18, -0x7418(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29720 as u32) ) } as u64;
	// 825B7F00: 825B8BE8  lwz r18, -0x7418(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29720 as u32) ) } as u64;
	// 825B7F04: 825B8BE8  lwz r18, -0x7418(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29720 as u32) ) } as u64;
	// 825B7F08: 825B8BE8  lwz r18, -0x7418(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29720 as u32) ) } as u64;
	// 825B7F0C: 825B8BE8  lwz r18, -0x7418(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29720 as u32) ) } as u64;
	// 825B7F10: 825B8BE8  lwz r18, -0x7418(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29720 as u32) ) } as u64;
	// 825B7F14: 825B8BE8  lwz r18, -0x7418(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29720 as u32) ) } as u64;
	// 825B7F18: 825B8BE8  lwz r18, -0x7418(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29720 as u32) ) } as u64;
	// 825B7F1C: 825B8BE8  lwz r18, -0x7418(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29720 as u32) ) } as u64;
	// 825B7F20: 825B8BE8  lwz r18, -0x7418(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29720 as u32) ) } as u64;
	// 825B7F24: 825B8B20  lwz r18, -0x74e0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29920 as u32) ) } as u64;
	// 825B7F28: 825B8B20  lwz r18, -0x74e0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29920 as u32) ) } as u64;
	// 825B7F2C: 825B8B20  lwz r18, -0x74e0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29920 as u32) ) } as u64;
	// 825B7F30: 825B8B20  lwz r18, -0x74e0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29920 as u32) ) } as u64;
	// 825B7F34: 825B8B3C  lwz r18, -0x74c4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29892 as u32) ) } as u64;
	// 825B7F38: 825B8B3C  lwz r18, -0x74c4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29892 as u32) ) } as u64;
	// 825B7F3C: 825B8B3C  lwz r18, -0x74c4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29892 as u32) ) } as u64;
	// 825B7F40: 825B8B3C  lwz r18, -0x74c4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29892 as u32) ) } as u64;
	// 825B7F44: 825B8B64  lwz r18, -0x749c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29852 as u32) ) } as u64;
	// 825B7F48: 825B8B64  lwz r18, -0x749c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29852 as u32) ) } as u64;
	// 825B7F4C: 825B8B64  lwz r18, -0x749c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29852 as u32) ) } as u64;
	// 825B7F50: 825B8B64  lwz r18, -0x749c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-29852 as u32) ) } as u64;
            }
            0x825B7F54 => {
    //   block [0x825B7F54..0x825B7FA8)
	// 825B7F54: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B7F58: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825B7F5C: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B7F60: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B7F64: 556B083E  rotlwi r11, r11, 1
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 825B7F68: C19E0018  lfs f12, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825B7F6C: 554A083E  rotlwi r10, r10, 1
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 825B7F70: C17E0014  lfs f11, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825B7F74: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825B7F78: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 825B7F7C: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825B7F80: EDAC582A  fadds f13, f12, f11
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64;
	// 825B7F84: F9610158  std r11, 0x158(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(344 as u32), ctx.r[11].u64 ) };
	// 825B7F88: F9410130  std r10, 0x130(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), ctx.r[10].u64 ) };
	// 825B7F8C: C9810158  lfd f12, 0x158(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(344 as u32) ) };
	// 825B7F90: C9610130  lfd f11, 0x130(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(304 as u32) ) };
	// 825B7F94: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 825B7F98: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 825B7F9C: FFC06018  frsp f30, f12
	ctx.f[30].f64 = (ctx.f[12].f64 as f32) as f64;
	// 825B7FA0: FFE05818  frsp f31, f11
	ctx.f[31].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825B7FA4: 48000440  b 0x825b83e4
	pc = 0x825B83E4; continue 'dispatch;
            }
            0x825B7FA8 => {
    //   block [0x825B7FA8..0x825B8004)
	// 825B7FA8: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B7FAC: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825B7FB0: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B7FB4: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B7FB8: 556A083E  rotlwi r10, r11, 1
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 825B7FBC: C19E0014  lfs f12, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825B7FC0: 552B083E  rotlwi r11, r9, 1
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 825B7FC4: C17E0018  lfs f11, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825B7FC8: 394AFF01  addi r10, r10, -0xff
	ctx.r[10].s64 = ctx.r[10].s64 + -255;
	// 825B7FCC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 825B7FD0: 396BFF01  addi r11, r11, -0xff
	ctx.r[11].s64 = ctx.r[11].s64 + -255;
	// 825B7FD4: EDAC5828  fsubs f13, f12, f11
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 825B7FD8: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825B7FDC: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825B7FE0: F9410140  std r10, 0x140(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(320 as u32), ctx.r[10].u64 ) };
	// 825B7FE4: F9610170  std r11, 0x170(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(368 as u32), ctx.r[11].u64 ) };
	// 825B7FE8: C9810140  lfd f12, 0x140(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(320 as u32) ) };
	// 825B7FEC: C9610170  lfd f11, 0x170(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(368 as u32) ) };
	// 825B7FF0: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 825B7FF4: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 825B7FF8: FFC06018  frsp f30, f12
	ctx.f[30].f64 = (ctx.f[12].f64 as f32) as f64;
	// 825B7FFC: FFE05818  frsp f31, f11
	ctx.f[31].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825B8000: 480003E4  b 0x825b83e4
	pc = 0x825B83E4; continue 'dispatch;
            }
            0x825B8004 => {
    //   block [0x825B8004..0x825B8058)
	// 825B8004: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B8008: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825B800C: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B8010: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B8014: 556B083E  rotlwi r11, r11, 1
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 825B8018: C19E0018  lfs f12, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825B801C: 554A083E  rotlwi r10, r10, 1
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 825B8020: C17E0010  lfs f11, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825B8024: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825B8028: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 825B802C: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825B8030: EDAC582A  fadds f13, f12, f11
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64;
	// 825B8034: F96100C0  std r11, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u64 ) };
	// 825B8038: F9410160  std r10, 0x160(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), ctx.r[10].u64 ) };
	// 825B803C: C98100C0  lfd f12, 0xc0(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) };
	// 825B8040: C9610160  lfd f11, 0x160(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(352 as u32) ) };
	// 825B8044: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 825B8048: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 825B804C: FFC06018  frsp f30, f12
	ctx.f[30].f64 = (ctx.f[12].f64 as f32) as f64;
	// 825B8050: FFE05818  frsp f31, f11
	ctx.f[31].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825B8054: 48000390  b 0x825b83e4
	pc = 0x825B83E4; continue 'dispatch;
            }
            0x825B8058 => {
    //   block [0x825B8058..0x825B80B4)
	// 825B8058: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B805C: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825B8060: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B8064: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B8068: 556A083E  rotlwi r10, r11, 1
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 825B806C: C19E0010  lfs f12, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825B8070: 552B083E  rotlwi r11, r9, 1
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 825B8074: C17E0018  lfs f11, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825B8078: 394AFF01  addi r10, r10, -0xff
	ctx.r[10].s64 = ctx.r[10].s64 + -255;
	// 825B807C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 825B8080: 396BFF01  addi r11, r11, -0xff
	ctx.r[11].s64 = ctx.r[11].s64 + -255;
	// 825B8084: EDAC5828  fsubs f13, f12, f11
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 825B8088: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825B808C: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825B8090: F94100D0  std r10, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[10].u64 ) };
	// 825B8094: F9610138  std r11, 0x138(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), ctx.r[11].u64 ) };
	// 825B8098: C98100D0  lfd f12, 0xd0(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) };
	// 825B809C: C9610138  lfd f11, 0x138(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(312 as u32) ) };
	// 825B80A0: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 825B80A4: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 825B80A8: FFC06018  frsp f30, f12
	ctx.f[30].f64 = (ctx.f[12].f64 as f32) as f64;
	// 825B80AC: FFE05818  frsp f31, f11
	ctx.f[31].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825B80B0: 48000334  b 0x825b83e4
	pc = 0x825B83E4; continue 'dispatch;
            }
            0x825B80B4 => {
    //   block [0x825B80B4..0x825B8108)
	// 825B80B4: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B80B8: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825B80BC: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B80C0: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B80C4: 556B083E  rotlwi r11, r11, 1
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 825B80C8: C19E0014  lfs f12, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825B80CC: 554A083E  rotlwi r10, r10, 1
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 825B80D0: C17E0010  lfs f11, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825B80D4: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825B80D8: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 825B80DC: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825B80E0: EDAC582A  fadds f13, f12, f11
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64;
	// 825B80E4: F96100E0  std r11, 0xe0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[11].u64 ) };
	// 825B80E8: F9410150  std r10, 0x150(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(336 as u32), ctx.r[10].u64 ) };
	// 825B80EC: C98100E0  lfd f12, 0xe0(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) };
	// 825B80F0: C9610150  lfd f11, 0x150(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(336 as u32) ) };
	// 825B80F4: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 825B80F8: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 825B80FC: FFC06018  frsp f30, f12
	ctx.f[30].f64 = (ctx.f[12].f64 as f32) as f64;
	// 825B8100: FFE05818  frsp f31, f11
	ctx.f[31].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825B8104: 480002E0  b 0x825b83e4
	pc = 0x825B83E4; continue 'dispatch;
            }
            0x825B8108 => {
    //   block [0x825B8108..0x825B8164)
	// 825B8108: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B810C: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825B8110: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B8114: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B8118: 556A083E  rotlwi r10, r11, 1
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 825B811C: C19E0010  lfs f12, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825B8120: 552B083E  rotlwi r11, r9, 1
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 825B8124: C17E0014  lfs f11, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825B8128: 394AFF01  addi r10, r10, -0xff
	ctx.r[10].s64 = ctx.r[10].s64 + -255;
	// 825B812C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 825B8130: 396BFF01  addi r11, r11, -0xff
	ctx.r[11].s64 = ctx.r[11].s64 + -255;
	// 825B8134: EDAC5828  fsubs f13, f12, f11
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 825B8138: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825B813C: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825B8140: F94100F0  std r10, 0xf0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[10].u64 ) };
	// 825B8144: F9610148  std r11, 0x148(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(328 as u32), ctx.r[11].u64 ) };
	// 825B8148: C98100F0  lfd f12, 0xf0(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(240 as u32) ) };
	// 825B814C: C9610148  lfd f11, 0x148(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(328 as u32) ) };
	// 825B8150: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 825B8154: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 825B8158: FFC06018  frsp f30, f12
	ctx.f[30].f64 = (ctx.f[12].f64 as f32) as f64;
	// 825B815C: FFE05818  frsp f31, f11
	ctx.f[31].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825B8160: 48000284  b 0x825b83e4
	pc = 0x825B83E4; continue 'dispatch;
            }
            0x825B8164 => {
    //   block [0x825B8164..0x825B81D0)
	// 825B8164: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B8168: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825B816C: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B8170: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B8174: 5568083E  rotlwi r8, r11, 1
	ctx.r[8].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 825B8178: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 825B817C: 5549083E  rotlwi r9, r10, 1
	ctx.r[9].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 825B8180: C19E0018  lfs f12, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825B8184: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825B8188: C1BE0014  lfs f13, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825B818C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825B8190: EDAC682A  fadds f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 825B8194: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825B8198: C19E0000  lfs f12, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825B819C: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825B81A0: C17E0010  lfs f11, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825B81A4: F9610100  std r11, 0x100(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[11].u64 ) };
	// 825B81A8: F94100B0  std r10, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[10].u64 ) };
	// 825B81AC: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 825B81B0: EDAD582A  fadds f13, f13, f11
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64;
	// 825B81B4: C9810100  lfd f12, 0x100(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 825B81B8: C96100B0  lfd f11, 0xb0(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 825B81BC: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 825B81C0: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 825B81C4: FFC06018  frsp f30, f12
	ctx.f[30].f64 = (ctx.f[12].f64 as f32) as f64;
	// 825B81C8: FFE05818  frsp f31, f11
	ctx.f[31].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825B81CC: 48000218  b 0x825b83e4
	pc = 0x825B83E4; continue 'dispatch;
            }
            0x825B81D0 => {
    //   block [0x825B81D0..0x825B8244)
	// 825B81D0: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B81D4: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825B81D8: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B81DC: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B81E0: 396BFFAB  addi r11, r11, -0x55
	ctx.r[11].s64 = ctx.r[11].s64 + -85;
	// 825B81E4: C17E0010  lfs f11, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825B81E8: 394AFFAB  addi r10, r10, -0x55
	ctx.r[10].s64 = ctx.r[10].s64 + -85;
	// 825B81EC: C19E0014  lfs f12, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825B81F0: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B81F4: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 825B81F8: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825B81FC: ED8C582A  fadds f12, f12, f11
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64;
	// 825B8200: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825B8204: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825B8208: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825B820C: C17E0018  lfs f11, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825B8210: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825B8214: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825B8218: F9610110  std r11, 0x110(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[11].u64 ) };
	// 825B821C: F9410168  std r10, 0x168(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(360 as u32), ctx.r[10].u64 ) };
	// 825B8220: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 825B8224: EDAC5828  fsubs f13, f12, f11
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 825B8228: C9810110  lfd f12, 0x110(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(272 as u32) ) };
	// 825B822C: C9610168  lfd f11, 0x168(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(360 as u32) ) };
	// 825B8230: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 825B8234: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 825B8238: FFC06018  frsp f30, f12
	ctx.f[30].f64 = (ctx.f[12].f64 as f32) as f64;
	// 825B823C: FFE05818  frsp f31, f11
	ctx.f[31].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825B8240: 480001A4  b 0x825b83e4
	pc = 0x825B83E4; continue 'dispatch;
            }
            0x825B8244 => {
    //   block [0x825B8244..0x825B82B8)
	// 825B8244: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B8248: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825B824C: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B8250: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B8254: 396BFFAB  addi r11, r11, -0x55
	ctx.r[11].s64 = ctx.r[11].s64 + -85;
	// 825B8258: C17E0014  lfs f11, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825B825C: 394AFFAB  addi r10, r10, -0x55
	ctx.r[10].s64 = ctx.r[10].s64 + -85;
	// 825B8260: C19E0010  lfs f12, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825B8264: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B8268: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 825B826C: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825B8270: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 825B8274: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825B8278: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825B827C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825B8280: C17E0018  lfs f11, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825B8284: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825B8288: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825B828C: F9610128  std r11, 0x128(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), ctx.r[11].u64 ) };
	// 825B8290: F94100B8  std r10, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[10].u64 ) };
	// 825B8294: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 825B8298: EDAC582A  fadds f13, f12, f11
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64;
	// 825B829C: C9810128  lfd f12, 0x128(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(296 as u32) ) };
	// 825B82A0: C96100B8  lfd f11, 0xb8(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	// 825B82A4: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 825B82A8: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 825B82AC: FFC06018  frsp f30, f12
	ctx.f[30].f64 = (ctx.f[12].f64 as f32) as f64;
	// 825B82B0: FFE05818  frsp f31, f11
	ctx.f[31].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825B82B4: 48000130  b 0x825b83e4
	pc = 0x825B83E4; continue 'dispatch;
            }
            0x825B82B8 => {
    //   block [0x825B82B8..0x825B832C)
	// 825B82B8: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B82BC: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825B82C0: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B82C4: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B82C8: 396BFF56  addi r11, r11, -0xaa
	ctx.r[11].s64 = ctx.r[11].s64 + -170;
	// 825B82CC: C17E0014  lfs f11, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825B82D0: 394AFF56  addi r10, r10, -0xaa
	ctx.r[10].s64 = ctx.r[10].s64 + -170;
	// 825B82D4: C19E0010  lfs f12, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825B82D8: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B82DC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 825B82E0: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825B82E4: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 825B82E8: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825B82EC: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825B82F0: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825B82F4: C17E0018  lfs f11, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825B82F8: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825B82FC: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825B8300: F96100C8  std r11, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[11].u64 ) };
	// 825B8304: F94100D8  std r10, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[10].u64 ) };
	// 825B8308: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 825B830C: EDAC5828  fsubs f13, f12, f11
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 825B8310: C98100C8  lfd f12, 0xc8(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) };
	// 825B8314: C96100D8  lfd f11, 0xd8(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) };
	// 825B8318: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 825B831C: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 825B8320: FFC06018  frsp f30, f12
	ctx.f[30].f64 = (ctx.f[12].f64 as f32) as f64;
	// 825B8324: FFE05818  frsp f31, f11
	ctx.f[31].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825B8328: 480000BC  b 0x825b83e4
	pc = 0x825B83E4; continue 'dispatch;
            }
            0x825B832C => {
    //   block [0x825B832C..0x825B835C)
	// 825B832C: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B8330: 3B8BFFE0  addi r28, r11, -0x20
	ctx.r[28].s64 = ctx.r[11].s64 + -32;
	// 825B8334: 397F0003  addi r11, r31, 3
	ctx.r[11].s64 = ctx.r[31].s64 + 3;
	// 825B8338: 554A103E  rotlwi r10, r10, 2
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 825B833C: 5789103A  slwi r9, r28, 2
	ctx.r[9].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825B8340: 7FEABC2E  lfsx f31, r10, r23
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[23].u32)) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825B8344: 395C0004  addi r10, r28, 4
	ctx.r[10].s64 = ctx.r[28].s64 + 4;
	// 825B8348: 7C09F42E  lfsx f0, r9, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B834C: EFDFC02A  fadds f30, f31, f24
	ctx.f[30].f64 = ((ctx.f[31].f64 + ctx.f[24].f64) as f32) as f64;
	// 825B8350: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825B8354: 7DAAF42E  lfsx f13, r10, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825B8358: 48000090  b 0x825b83e8
	pc = 0x825B83E8; continue 'dispatch;
            }
            0x825B835C => {
    //   block [0x825B835C..0x825B83B4)
	// 825B835C: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B8360: 3B8BFFDD  addi r28, r11, -0x23
	ctx.r[28].s64 = ctx.r[11].s64 + -35;
	// 825B8364: 88FF0003  lbz r7, 3(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825B8368: 397F0007  addi r11, r31, 7
	ctx.r[11].s64 = ctx.r[31].s64 + 7;
	// 825B836C: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B8370: 5546103E  rotlwi r6, r10, 2
	ctx.r[6].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 825B8374: 893F0004  lbz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B8378: 54EA403E  rotlwi r10, r7, 8
	ctx.r[10].u64 = ((ctx.r[7].u32).rotate_left(8)) as u64;
	// 825B837C: 5508103E  rotlwi r8, r8, 2
	ctx.r[8].u64 = ((ctx.r[8].u32).rotate_left(2)) as u64;
	// 825B8380: 7F4A4A14  add r26, r10, r9
	ctx.r[26].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825B8384: 395C0004  addi r10, r28, 4
	ctx.r[10].s64 = ctx.r[28].s64 + 4;
	// 825B8388: 892BFFFF  lbz r9, -1(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825B838C: 7FC6BC2E  lfsx f30, r6, r23
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[23].u32)) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825B8390: 5547103A  slwi r7, r10, 2
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825B8394: 894BFFFE  lbz r10, -2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-2 as u32) ) } as u64;
	// 825B8398: 7FE8BC2E  lfsx f31, r8, r23
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[23].u32)) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825B839C: 5788103A  slwi r8, r28, 2
	ctx.r[8].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B83A0: 554A403E  rotlwi r10, r10, 8
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(8)) as u64;
	// 825B83A4: 7F6A4A14  add r27, r10, r9
	ctx.r[27].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825B83A8: 7DA7F42E  lfsx f13, r7, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825B83AC: 7C08F42E  lfsx f0, r8, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B83B0: 48000040  b 0x825b83f0
	pc = 0x825B83F0; continue 'dispatch;
            }
            0x825B83B4 => {
    //   block [0x825B83B4..0x825B83E4)
	// 825B83B4: 3B8BFFF0  addi r28, r11, -0x10
	ctx.r[28].s64 = ctx.r[11].s64 + -16;
	// 825B83B8: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B83BC: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B83C0: 556B103E  rotlwi r11, r11, 2
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 825B83C4: 554A103E  rotlwi r10, r10, 2
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 825B83C8: 7FCBBC2E  lfsx f30, r11, r23
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[23].u32)) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825B83CC: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 825B83D0: 7FEABC2E  lfsx f31, r10, r23
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[23].u32)) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825B83D4: 578A103A  slwi r10, r28, 2
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825B83D8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B83DC: 7C0AF42E  lfsx f0, r10, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B83E0: 7DABF42E  lfsx f13, r11, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x825B83E4; continue 'dispatch;
            }
            0x825B83E4 => {
    //   block [0x825B83E4..0x825B83E8)
	// 825B83E4: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	pc = 0x825B83E8; continue 'dispatch;
            }
            0x825B83E8 => {
    //   block [0x825B83E8..0x825B83F0)
	// 825B83E8: 8B6BFFFF  lbz r27, -1(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825B83EC: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	pc = 0x825B83F0; continue 'dispatch;
            }
            0x825B83F0 => {
    //   block [0x825B83F0..0x825B8408)
	// 825B83F0: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 825B83F4: 40980014  bge cr6, 0x825b8408
	if !ctx.cr[6].lt {
	pc = 0x825B8408; continue 'dispatch;
	}
	// 825B83F8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 825B83FC: 4098000C  bge cr6, 0x825b8408
	if !ctx.cr[6].lt {
	pc = 0x825B8408; continue 'dispatch;
	}
	// 825B8400: 7FFA5A14  add r31, r26, r11
	ctx.r[31].u64 = ctx.r[26].u64 + ctx.r[11].u64;
	// 825B8404: 4BFFF978  b 0x825b7d7c
	pc = 0x825B7D7C; continue 'dispatch;
            }
            0x825B8408 => {
    //   block [0x825B8408..0x825B841C)
	// 825B8408: 7FFB5A14  add r31, r27, r11
	ctx.r[31].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 825B840C: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 825B8410: 4099000C  ble cr6, 0x825b841c
	if !ctx.cr[6].gt {
	pc = 0x825B841C; continue 'dispatch;
	}
	// 825B8414: FF0DF000  fcmpu cr6, f13, f30
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[30].f64);
	// 825B8418: 4199F964  bgt cr6, 0x825b7d7c
	if ctx.cr[6].gt {
	pc = 0x825B7D7C; continue 'dispatch;
	}
	pc = 0x825B841C; continue 'dispatch;
            }
            0x825B841C => {
    //   block [0x825B841C..0x825B86B8)
	// 825B841C: 39610180  addi r11, r1, 0x180
	ctx.r[11].s64 = ctx.r[1].s64 + 384;
	// 825B8420: EFA0F028  fsubs f29, f0, f30
	ctx.f[29].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 825B8424: EF8DF028  fsubs f28, f13, f30
	ctx.f[28].f64 = (((ctx.f[13].f64 - ctx.f[30].f64) as f32) as f64);
	pc = 0x825B86B8; continue 'dispatch;
            }
            0x825B86B8 => {
    //   block [0x825B86B8..0x825B874C)
	// 825B86B8: 395F0001  addi r10, r31, 1
	ctx.r[10].s64 = ctx.r[31].s64 + 1;
	// 825B86BC: C0180014  lfs f0, 0x14(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B86C0: 393F0004  addi r9, r31, 4
	ctx.r[9].s64 = ctx.r[31].s64 + 4;
	// 825B86C4: C1B90014  lfs f13, 0x14(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825B86C8: 396BFFD7  addi r11, r11, -0x29
	ctx.r[11].s64 = ctx.r[11].s64 + -41;
	// 825B86CC: 3BFF0007  addi r31, r31, 7
	ctx.r[31].s64 = ctx.r[31].s64 + 7;
	// 825B86D0: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B86D4: 88C90000  lbz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B86D8: 88EA0001  lbz r7, 1(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B86DC: 5505403E  rotlwi r5, r8, 8
	ctx.r[5].u64 = ((ctx.r[8].u32).rotate_left(8)) as u64;
	// 825B86E0: 89090001  lbz r8, 1(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B86E4: 54C6403E  rotlwi r6, r6, 8
	ctx.r[6].u64 = ((ctx.r[6].u32).rotate_left(8)) as u64;
	// 825B86E8: 7CA72A14  add r5, r7, r5
	ctx.r[5].u64 = ctx.r[7].u64 + ctx.r[5].u64;
	// 825B86EC: 88EA0002  lbz r7, 2(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B86F0: 7D483214  add r10, r8, r6
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[6].u64;
	// 825B86F4: 89290002  lbz r9, 2(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B86F8: 54A8402E  slwi r8, r5, 8
	ctx.r[8].u32 = ctx.r[5].u32.wrapping_shl(8);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B86FC: 554A402E  slwi r10, r10, 8
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(8);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825B8700: 7D083A14  add r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 825B8704: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825B8708: 7D0907B4  extsw r9, r8
	ctx.r[9].s64 = ctx.r[8].s32 as i64;
	// 825B870C: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825B8710: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B8714: F92100E8  std r9, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[9].u64 ) };
	// 825B8718: F94100F8  std r10, 0xf8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[10].u64 ) };
	// 825B871C: 7D88CC2E  lfsx f12, r8, r25
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[25].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825B8720: C96100E8  lfd f11, 0xe8(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(232 as u32) ) };
	// 825B8724: C94100F8  lfd f10, 0xf8(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(248 as u32) ) };
	// 825B8728: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 825B872C: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 825B8730: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825B8734: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 825B8738: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 825B873C: EC0A0032  fmuls f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 825B8740: ED4B6378  fmsubs f10, f11, f13, f12
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 825B8744: EC006378  fmsubs f0, f0, f13, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 825B8748: 48000024  b 0x825b876c
	pc = 0x825B876C; continue 'dispatch;
            }
            0x825B874C => {
    //   block [0x825B874C..0x825B8888)
	// 825B874C: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B8750: 396BFFDA  addi r11, r11, -0x26
	ctx.r[11].s64 = ctx.r[11].s64 + -38;
	// 825B8754: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B8758: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825B875C: 554A103E  rotlwi r10, r10, 2
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 825B8760: 5529103E  rotlwi r9, r9, 2
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(2)) as u64;
	// 825B8764: 7D4ABC2E  lfsx f10, r10, r23
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[23].u32)) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825B8768: 7C09BC2E  lfsx f0, r9, r23
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[23].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B876C: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 825B8770: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B8774: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825B8778: 7D8BF42E  lfsx f12, r11, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825B877C: 7D6AF42E  lfsx f11, r10, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825B8780: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 825B8784: 4098001C  bge cr6, 0x825b87a0
	if !ctx.cr[6].lt {
	pc = 0x825B87A0; continue 'dispatch;
	}
	// 825B8788: FF0B5000  fcmpu cr6, f11, f10
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[10].f64);
	// 825B878C: 41980658  blt cr6, 0x825b8de4
	if ctx.cr[6].lt {
	pc = 0x825B8DE4; continue 'dispatch;
	}
	// 825B8790: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 825B8794: 41990650  bgt cr6, 0x825b8de4
	if ctx.cr[6].gt {
	pc = 0x825B8DE4; continue 'dispatch;
	}
	// 825B8798: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825B879C: 48000018  b 0x825b87b4
	pc = 0x825B87B4; continue 'dispatch;
	// 825B87A0: FF0C5000  fcmpu cr6, f12, f10
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[10].f64);
	// 825B87A4: 41980640  blt cr6, 0x825b8de4
	if ctx.cr[6].lt {
	pc = 0x825B8DE4; continue 'dispatch;
	}
	// 825B87A8: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 825B87AC: 41990638  bgt cr6, 0x825b8de4
	if ctx.cr[6].gt {
	pc = 0x825B8DE4; continue 'dispatch;
	}
	// 825B87B0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825B87B4: 397E0010  addi r11, r30, 0x10
	ctx.r[11].s64 = ctx.r[30].s64 + 16;
	// 825B87B8: EDAC0028  fsubs f13, f12, f0
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 825B87BC: EC0B0028  fsubs f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 825B87C0: E8FE0000  ld r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 825B87C4: 394101A0  addi r10, r1, 0x1a0
	ctx.r[10].s64 = ctx.r[1].s64 + 416;
	// 825B87C8: E8BE0008  ld r5, 8(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 825B87CC: 392101B0  addi r9, r1, 0x1b0
	ctx.r[9].s64 = ctx.r[1].s64 + 432;
	// 825B87D0: E8CB0000  ld r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 825B87D4: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 825B87D8: F8EA0000  std r7, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u64 ) };
	// 825B87DC: F8AA0008  std r5, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[5].u64 ) };
	// 825B87E0: F8C90000  std r6, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 825B87E4: F9690008  std r11, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 825B87E8: 396101A0  addi r11, r1, 0x1a0
	ctx.r[11].s64 = ctx.r[1].s64 + 416;
	// 825B87EC: ED200372  fmuls f9, f0, f13
	ctx.f[9].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
            }
            0x825B8888 => {
    //   block [0x825B8888..0x825B8898)
	// 825B8888: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B888C: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825B8890: 3BEB0002  addi r31, r11, 2
	ctx.r[31].s64 = ctx.r[11].s64 + 2;
	// 825B8894: 4BFFF4E8  b 0x825b7d7c
	pc = 0x825B7D7C; continue 'dispatch;
            }
            0x825B8898 => {
    //   block [0x825B8898..0x825B88B4)
	// 825B8898: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B889C: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B88A0: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825B88A4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B88A8: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825B88AC: 3BEB0003  addi r31, r11, 3
	ctx.r[31].s64 = ctx.r[11].s64 + 3;
	// 825B88B0: 4BFFF4CC  b 0x825b7d7c
	pc = 0x825B7D7C; continue 'dispatch;
            }
            0x825B88B4 => {
    //   block [0x825B88B4..0x825B88DC)
	// 825B88B4: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B88B8: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B88BC: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825B88C0: 895F0003  lbz r10, 3(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825B88C4: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825B88C8: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B88CC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B88D0: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825B88D4: 3BEB0004  addi r31, r11, 4
	ctx.r[31].s64 = ctx.r[11].s64 + 4;
	// 825B88D8: 4BFFF4A4  b 0x825b7d7c
	pc = 0x825B7D7C; continue 'dispatch;
            }
            0x825B88DC => {
    //   block [0x825B88DC..0x825B8900)
	// 825B88DC: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B88E0: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B88E4: 81380010  lwz r9, 0x10(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 825B88E8: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825B88EC: 7D715378  or r17, r11, r10
	ctx.r[17].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 825B88F0: 562A482C  slwi r10, r17, 9
	ctx.r[10].u32 = ctx.r[17].u32.wrapping_shl(9);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825B88F4: 81690020  lwz r11, 0x20(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 825B88F8: 7FEB5214  add r31, r11, r10
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B88FC: 4BFFF480  b 0x825b7d7c
	pc = 0x825B7D7C; continue 'dispatch;
            }
            0x825B8900 => {
    //   block [0x825B8900..0x825B89FC)
	// 825B8900: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B8904: D321009C  stfs f25, 0x9c(r1)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 825B8908: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	pc = 0x825B89FC; continue 'dispatch;
            }
            0x825B89FC => {
    //   block [0x825B89FC..0x825B8A50)
	// 825B89FC: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 825B8A00: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B8A04: 7F195040  cmplw cr6, r25, r10
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B8A08: 419A0034  beq cr6, 0x825b8a3c
	if ctx.cr[6].eq {
	pc = 0x825B8A3C; continue 'dispatch;
	}
	// 825B8A0C: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	pc = 0x825B8A50; continue 'dispatch;
            }
            0x825B8A50 => {
    //   block [0x825B8A50..0x825B8AB0)
	// 825B8A50: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B8A54: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 825B8A58: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B8A5C: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825B8A60: 7F194840  cmplw cr6, r25, r9
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B8A64: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B8A68: 419A0034  beq cr6, 0x825b8a9c
	if ctx.cr[6].eq {
	pc = 0x825B8A9C; continue 'dispatch;
	}
	// 825B8A6C: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	pc = 0x825B8AB0; continue 'dispatch;
            }
            0x825B8AB0 => {
    //   block [0x825B8AB0..0x825B8B18)
	// 825B8AB0: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B8AB4: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 825B8AB8: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B8ABC: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825B8AC0: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825B8AC4: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B8AC8: 7F193840  cmplw cr6, r25, r7
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825B8ACC: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825B8AD0: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B8AD4: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825B8AD8: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B8ADC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B8AE0: 419A0034  beq cr6, 0x825b8b14
	if ctx.cr[6].eq {
	pc = 0x825B8B14; continue 'dispatch;
	}
	// 825B8AE4: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	pc = 0x825B8B18; continue 'dispatch;
            }
            0x825B8B18 => {
    //   block [0x825B8B18..0x825B8B20)
	// 825B8B18: 3BFF0005  addi r31, r31, 5
	ctx.r[31].s64 = ctx.r[31].s64 + 5;
	// 825B8B1C: 4BFFF260  b 0x825b7d7c
	pc = 0x825B7D7C; continue 'dispatch;
            }
            0x825B8B20 => {
    //   block [0x825B8B20..0x825B8B3C)
	// 825B8B20: 396BFFA0  addi r11, r11, -0x60
	ctx.r[11].s64 = ctx.r[11].s64 + -96;
	// 825B8B24: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B8B28: 3921007C  addi r9, r1, 0x7c
	ctx.r[9].s64 = ctx.r[1].s64 + 124;
	// 825B8B2C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B8B30: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 825B8B34: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 825B8B38: 48000068  b 0x825b8ba0
	pc = 0x825B8BA0; continue 'dispatch;
            }
            0x825B8B3C => {
    //   block [0x825B8B3C..0x825B8B64)
	// 825B8B3C: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B8B40: 390BFF9C  addi r8, r11, -0x64
	ctx.r[8].s64 = ctx.r[11].s64 + -100;
	// 825B8B44: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B8B48: 38E1007C  addi r7, r1, 0x7c
	ctx.r[7].s64 = ctx.r[1].s64 + 124;
	// 825B8B4C: 552B403E  rotlwi r11, r9, 8
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(8)) as u64;
	// 825B8B50: 5509103A  slwi r9, r8, 2
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825B8B54: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B8B58: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825B8B5C: 7D69392E  stwx r11, r9, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32), ctx.r[11].u32) };
	// 825B8B60: 48000040  b 0x825b8ba0
	pc = 0x825B8BA0; continue 'dispatch;
            }
            0x825B8B64 => {
    //   block [0x825B8B64..0x825B8BE8)
	// 825B8B64: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B8B68: 38EBFF98  addi r7, r11, -0x68
	ctx.r[7].s64 = ctx.r[11].s64 + -104;
	// 825B8B6C: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B8B70: 38C1007C  addi r6, r1, 0x7c
	ctx.r[6].s64 = ctx.r[1].s64 + 124;
	// 825B8B74: 554B403E  rotlwi r11, r10, 8
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(8)) as u64;
	// 825B8B78: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825B8B7C: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B8B80: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825B8B84: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825B8B88: 3BFF0005  addi r31, r31, 5
	ctx.r[31].s64 = ctx.r[31].s64 + 5;
	// 825B8B8C: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B8B90: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825B8B94: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B8B98: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B8B9C: 7D67312E  stwx r11, r7, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32), ctx.r[11].u32) };
	// 825B8BA0: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 825B8BA4: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825B8BA8: 7F195040  cmplw cr6, r25, r10
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B8BAC: 419A0034  beq cr6, 0x825b8be0
	if ctx.cr[6].eq {
	pc = 0x825B8BE0; continue 'dispatch;
	}
	// 825B8BB0: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	pc = 0x825B8BE8; continue 'dispatch;
            }
            0x825B8BE8 => {
    //   block [0x825B8BE8..0x825B8C3C)
	// 825B8BE8: 38A00200  li r5, 0x200
	ctx.r[5].s64 = 512;
	// 825B8BEC: 388101C0  addi r4, r1, 0x1c0
	ctx.r[4].s64 = ctx.r[1].s64 + 448;
	// 825B8BF0: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 825B8BF4: 4BEB0205  bl 0x82468df8
	ctx.lr = 0x825B8BF8;
	sub_82468DF8(ctx, base);
	// 825B8BF8: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 825B8BFC: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 825B8C00: 4BEAF6A1  bl 0x824682a0
	ctx.lr = 0x825B8C04;
	sub_824682A0(ctx, base);
	// 825B8C04: 806E9190  lwz r3, -0x6e70(r14)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(-28272 as u32) ) } as u64;
	// 825B8C08: 3CA01298  lis r5, 0x1298
	ctx.r[5].s64 = 311951360;
	// 825B8C0C: 39000222  li r8, 0x222
	ctx.r[8].s64 = 546;
	// 825B8C10: 7E078378  mr r7, r16
	ctx.r[7].u64 = ctx.r[16].u64;
	// 825B8C14: 38C101C0  addi r6, r1, 0x1c0
	ctx.r[6].s64 = ctx.r[1].s64 + 448;
	// 825B8C18: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B8C1C: 60A5FEDD  ori r5, r5, 0xfedd
	ctx.r[5].u64 = ctx.r[5].u64 | 65245;
	// 825B8C20: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825B8C24: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B8C28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B8C2C: 4E800421  bctrl
	ctx.lr = 0x825B8C30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B8C30: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 825B8C34: 4BEAFCAD  bl 0x824688e0
	ctx.lr = 0x825B8C38;
	sub_824688E0(ctx, base);
	// 825B8C38: 4BFFF144  b 0x825b7d7c
	pc = 0x825B7D7C; continue 'dispatch;
            }
            0x825B8C3C => {
    //   block [0x825B8C3C..0x825B8C44)
	// 825B8C3C: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B8C40: 48000068  b 0x825b8ca8
	pc = 0x825B8CA8; continue 'dispatch;
            }
            0x825B8C44 => {
    //   block [0x825B8C44..0x825B8C58)
	// 825B8C44: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B8C48: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B8C4C: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825B8C50: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B8C54: 48000054  b 0x825b8ca8
	pc = 0x825B8CA8; continue 'dispatch;
            }
            0x825B8C58 => {
    //   block [0x825B8C58..0x825B8C78)
	// 825B8C58: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B8C5C: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B8C60: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825B8C64: 895F0003  lbz r10, 3(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825B8C68: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825B8C6C: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B8C70: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B8C74: 48000034  b 0x825b8ca8
	pc = 0x825B8CA8; continue 'dispatch;
            }
            0x825B8C78 => {
    //   block [0x825B8C78..0x825B8CA4)
	// 825B8C78: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B8C7C: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B8C80: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825B8C84: 891F0003  lbz r8, 3(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825B8C88: 893F0004  lbz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B8C8C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B8C90: 550A403E  rotlwi r10, r8, 8
	ctx.r[10].u64 = ((ctx.r[8].u32).rotate_left(8)) as u64;
	// 825B8C94: 556B801E  slwi r11, r11, 0x10
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(16);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B8C98: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825B8C9C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B8CA0: 48000008  b 0x825b8ca8
	pc = 0x825B8CA8; continue 'dispatch;
            }
            0x825B8CA4 => {
    //   block [0x825B8CA4..0x825B8DE4)
	// 825B8CA4: 396BFFD0  addi r11, r11, -0x30
	ctx.r[11].s64 = ctx.r[11].s64 + -48;
	// 825B8CA8: 81180068  lwz r8, 0x68(r24)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(104 as u32) ) } as u64;
	// 825B8CAC: 5629402E  slwi r9, r17, 8
	ctx.r[9].u32 = ctx.r[17].u32.wrapping_shl(8);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825B8CB0: 81590018  lwz r10, 0x18(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(24 as u32) ) } as u64;
	// 825B8CB4: 38A101C0  addi r5, r1, 0x1c0
	ctx.r[5].s64 = ctx.r[1].s64 + 448;
	// 825B8CB8: 80780064  lwz r3, 0x64(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(100 as u32) ) } as u64;
	// 825B8CBC: 7D094838  and r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 825B8CC0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B8CC4: 7D3E5B78  or r30, r9, r11
	ctx.r[30].u64 = ctx.r[9].u64 | ctx.r[11].u64;
	// 825B8CC8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B8CCC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B8CD0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B8CD4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B8CD8: 4E800421  bctrl
	ctx.lr = 0x825B8CDC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B8CDC: 80980044  lwz r4, 0x44(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(68 as u32) ) } as u64;
	// 825B8CE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B8CE4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825B8CE8: 419A0034  beq cr6, 0x825b8d1c
	if ctx.cr[6].eq {
	pc = 0x825B8D1C; continue 'dispatch;
	}
	// 825B8CEC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B8CF0: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 825B8CF4: 80F80064  lwz r7, 0x64(r24)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(100 as u32) ) } as u64;
	// 825B8CF8: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 825B8CFC: 38B80020  addi r5, r24, 0x20
	ctx.r[5].s64 = ctx.r[24].s64 + 32;
	// 825B8D00: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825B8D04: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B8D08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B8D0C: 4E800421  bctrl
	ctx.lr = 0x825B8D10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B8D10: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B8D14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B8D18: 419A00CC  beq cr6, 0x825b8de4
	if ctx.cr[6].eq {
	pc = 0x825B8DE4; continue 'dispatch;
	}
	// 825B8D1C: 81780058  lwz r11, 0x58(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B8D20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B8D24: 419A007C  beq cr6, 0x825b8da0
	if ctx.cr[6].eq {
	pc = 0x825B8DA0; continue 'dispatch;
	}
	// 825B8D28: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 825B8D2C: 38B80020  addi r5, r24, 0x20
	ctx.r[5].s64 = ctx.r[24].s64 + 32;
	// 825B8D30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B8D34: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825B8D38: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825B8D3C: 914B0040  stw r10, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 825B8D40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B8D44: 80D80058  lwz r6, 0x58(r24)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B8D48: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 825B8D4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B8D50: 4E800421  bctrl
	ctx.lr = 0x825B8D54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B8D54: 81780058  lwz r11, 0x58(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B8D58: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 825B8D5C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 825B8D60: 914B0040  stw r10, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 825B8D64: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B8D68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B8D6C: 419A0078  beq cr6, 0x825b8de4
	if ctx.cr[6].eq {
	pc = 0x825B8DE4; continue 'dispatch;
	}
	// 825B8D70: 81780058  lwz r11, 0x58(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B8D74: 99580050  stb r10, 0x50(r24)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[24].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 825B8D78: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B8D7C: D0180054  stfs f0, 0x54(r24)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825B8D80: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 825B8D84: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B8D88: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825B8D8C: 7FCA592E  stwx r30, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[30].u32) };
	// 825B8D90: 382104A0  addi r1, r1, 0x4a0
	ctx.r[1].s64 = ctx.r[1].s64 + 1184;
	// 825B8D94: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 825B8D98: 4BF7D28D  bl 0x82536024
	ctx.lr = 0x825B8D9C;
	sub_82535FFC(ctx, base);
	// 825B8D9C: 4BF7C334  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
	// 825B8DA0: 81780060  lwz r11, 0x60(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(96 as u32) ) } as u64;
	// 825B8DA4: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 825B8DA8: 80D8005C  lwz r6, 0x5c(r24)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(92 as u32) ) } as u64;
	// 825B8DAC: 38980020  addi r4, r24, 0x20
	ctx.r[4].s64 = ctx.r[24].s64 + 32;
	// 825B8DB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B8DB4: 916100AC  stw r11, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 825B8DB8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B8DBC: 93E100A0  stw r31, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[31].u32 ) };
	// 825B8DC0: 93C100A4  stw r30, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[30].u32 ) };
	// 825B8DC4: 916100A8  stw r11, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 825B8DC8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B8DCC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825B8DD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B8DD4: 4E800421  bctrl
	ctx.lr = 0x825B8DD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B8DD8: 8178005C  lwz r11, 0x5c(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(92 as u32) ) } as u64;
	// 825B8DDC: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B8DE0: D0180054  stfs f0, 0x54(r24)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(84 as u32), tmp.u32 ) };
            }
            0x825B8DE4 => {
    //   block [0x825B8DE4..0x825B8DF4)
	// 825B8DE4: 382104A0  addi r1, r1, 0x4a0
	ctx.r[1].s64 = ctx.r[1].s64 + 1184;
	// 825B8DE8: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 825B8DEC: 4BF7D239  bl 0x82536024
	ctx.lr = 0x825B8DF0;
	sub_82535FFC(ctx, base);
	// 825B8DF0: 4BF7C2E0  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B8DF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B8DF8 size=312
    let mut pc: u32 = 0x825B8DF8;
    'dispatch: loop {
        match pc {
            0x825B8DF8 => {
    //   block [0x825B8DF8..0x825B8F30)
	// 825B8DF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B8DFC: 4BF7C2BD  bl 0x825350b8
	ctx.lr = 0x825B8E00;
	sub_82535080(ctx, base);
	// 825B8E00: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B8E04: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825B8E08: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825B8E0C: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 825B8E10: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 825B8E14: 3B800010  li r28, 0x10
	ctx.r[28].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B8F30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B8F30 size=304
    let mut pc: u32 = 0x825B8F30;
    'dispatch: loop {
        match pc {
            0x825B8F30 => {
    //   block [0x825B8F30..0x825B9060)
	// 825B8F30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B8F34: 4BF7C189  bl 0x825350bc
	ctx.lr = 0x825B8F38;
	sub_82535080(ctx, base);
	// 825B8F38: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B8F3C: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 825B8F40: 9103005C  stw r8, 0x5c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 825B8F44: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825B8F48: 90830064  stw r4, 0x64(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), ctx.r[4].u32 ) };
	// 825B8F4C: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 825B8F50: 90E30060  stw r7, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[7].u32 ) };
	// 825B8F54: 3BA00010  li r29, 0x10
	ctx.r[29].s64 = 16;
	// 825B8F58: 7CCA3378  mr r10, r6
	ctx.r[10].u64 = ctx.r[6].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B9060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B9060 size=76
    let mut pc: u32 = 0x825B9060;
    'dispatch: loop {
        match pc {
            0x825B9060 => {
    //   block [0x825B9060..0x825B90AC)
	// 825B9060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B9064: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B9068: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B906C: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 825B9070: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	// 825B9074: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 825B9078: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825B907C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825B9080: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B9084: 4802170D  bl 0x825da790
	ctx.lr = 0x825B9088;
	sub_825DA790(ctx, base);
	// 825B9088: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B908C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 825B9090: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825B9094: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 825B9098: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 825B909C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825B90A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B90A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B90A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B90B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B90B0 size=48
    let mut pc: u32 = 0x825B90B0;
    'dispatch: loop {
        match pc {
            0x825B90B0 => {
    //   block [0x825B90B0..0x825B90E0)
	// 825B90B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B90B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B90B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B90BC: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 825B90C0: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 825B90C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B90C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B90CC: 48022125  bl 0x825db1f0
	ctx.lr = 0x825B90D0;
	sub_825DB1F0(ctx, base);
	// 825B90D0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825B90D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B90D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B90DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B90E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B90E0 size=68
    let mut pc: u32 = 0x825B90E0;
    'dispatch: loop {
        match pc {
            0x825B90E0 => {
    //   block [0x825B90E0..0x825B9124)
	// 825B90E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B90E4: 4BF7BFD9  bl 0x825350bc
	ctx.lr = 0x825B90E8;
	sub_82535080(ctx, base);
	// 825B90E8: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B90EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B90F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B90F4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B90F8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825B90FC: 480222DD  bl 0x825db3d8
	ctx.lr = 0x825B9100;
	sub_825DB3D8(ctx, base);
	// 825B9100: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 825B9104: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825B9108: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B910C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B9110: 48023419  bl 0x825dc528
	ctx.lr = 0x825B9114;
	sub_825DC528(ctx, base);
	// 825B9114: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B9118: 480222F1  bl 0x825db408
	ctx.lr = 0x825B911C;
	sub_825DB408(ctx, base);
	// 825B911C: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 825B9120: 4BF7BFEC  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B9128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B9128 size=64
    let mut pc: u32 = 0x825B9128;
    'dispatch: loop {
        match pc {
            0x825B9128 => {
    //   block [0x825B9128..0x825B9168)
	// 825B9128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B912C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B9130: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B9134: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 825B9138: 80A30020  lwz r5, 0x20(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 825B913C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B9140: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B9144: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825B9148: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B914C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825B9150: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825B9154: 480234C5  bl 0x825dc618
	ctx.lr = 0x825B9158;
	sub_825DC618(ctx, base);
	// 825B9158: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825B915C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B9160: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B9164: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B9168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B9168 size=52
    let mut pc: u32 = 0x825B9168;
    'dispatch: loop {
        match pc {
            0x825B9168 => {
    //   block [0x825B9168..0x825B919C)
	// 825B9168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B916C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B9170: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B9174: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 825B9178: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 825B917C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B9180: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 825B9184: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B9188: 4BFFE7A9  bl 0x825b7930
	ctx.lr = 0x825B918C;
	sub_825B7930(ctx, base);
	// 825B918C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825B9190: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B9194: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B9198: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B91A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B91A0 size=48
    let mut pc: u32 = 0x825B91A0;
    'dispatch: loop {
        match pc {
            0x825B91A0 => {
    //   block [0x825B91A0..0x825B91D0)
	// 825B91A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B91A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B91A8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B91AC: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 825B91B0: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 825B91B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B91B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B91BC: 4BFFE98D  bl 0x825b7b48
	ctx.lr = 0x825B91C0;
	sub_825B7B48(ctx, base);
	// 825B91C0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825B91C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B91C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B91CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B91D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B91D0 size=48
    let mut pc: u32 = 0x825B91D0;
    'dispatch: loop {
        match pc {
            0x825B91D0 => {
    //   block [0x825B91D0..0x825B9200)
	// 825B91D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B91D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B91D8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B91DC: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 825B91E0: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 825B91E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B91E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B91EC: 48024ECD  bl 0x825de0b8
	ctx.lr = 0x825B91F0;
	sub_825DE0B8(ctx, base);
	// 825B91F0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825B91F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B91F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B91FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B9200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B9200 size=872
    let mut pc: u32 = 0x825B9200;
    'dispatch: loop {
        match pc {
            0x825B9200 => {
    //   block [0x825B9200..0x825B9568)
	// 825B9200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B9204: 4BF7BEB5  bl 0x825350b8
	ctx.lr = 0x825B9208;
	sub_82535080(ctx, base);
	// 825B9208: 9421FAC0  stwu r1, -0x540(r1)
	ea = ctx.r[1].u32.wrapping_add(-1344 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B920C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825B9210: C1A3001C  lfs f13, 0x1c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825B9214: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 825B9218: 83E40000  lwz r31, 0(r4)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B921C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825B9220: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B9224: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 825B9228: 80A30020  lwz r5, 0x20(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 825B922C: 3BA00020  li r29, 0x20
	ctx.r[29].s64 = 32;
	// 825B9230: C00A1850  lfs f0, 0x1850(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B9234: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 825B9238: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 825B923C: D00100E0  stfs f0, 0xe0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 825B9240: 916100D0  stw r11, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 825B9244: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B9248: 90C100A4  stw r6, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[6].u32 ) };
	// 825B924C: 3BC00030  li r30, 0x30
	ctx.r[30].s64 = 48;
	// 825B9250: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B9568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B9568 size=872
    let mut pc: u32 = 0x825B9568;
    'dispatch: loop {
        match pc {
            0x825B9568 => {
    //   block [0x825B9568..0x825B98D0)
	// 825B9568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B956C: 4BF7BB4D  bl 0x825350b8
	ctx.lr = 0x825B9570;
	sub_82535080(ctx, base);
	// 825B9570: 9421FAC0  stwu r1, -0x540(r1)
	ea = ctx.r[1].u32.wrapping_add(-1344 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B9574: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825B9578: C1A3001C  lfs f13, 0x1c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825B957C: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 825B9580: 83E40000  lwz r31, 0(r4)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B9584: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825B9588: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B958C: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 825B9590: 80A30020  lwz r5, 0x20(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 825B9594: 3BA00020  li r29, 0x20
	ctx.r[29].s64 = 32;
	// 825B9598: C00A1850  lfs f0, 0x1850(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B959C: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 825B95A0: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 825B95A4: D00100E0  stfs f0, 0xe0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 825B95A8: 916100D0  stw r11, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 825B95AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B95B0: 90C100A4  stw r6, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[6].u32 ) };
	// 825B95B4: 3BC00030  li r30, 0x30
	ctx.r[30].s64 = 48;
	// 825B95B8: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B98D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B98D0 size=228
    let mut pc: u32 = 0x825B98D0;
    'dispatch: loop {
        match pc {
            0x825B98D0 => {
    //   block [0x825B98D0..0x825B99B4)
	// 825B98D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B98D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B98D8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B98DC: 392100C0  addi r9, r1, 0xc0
	ctx.r[9].s64 = ctx.r[1].s64 + 192;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B99B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B99B8 size=228
    let mut pc: u32 = 0x825B99B8;
    'dispatch: loop {
        match pc {
            0x825B99B8 => {
    //   block [0x825B99B8..0x825B9A9C)
	// 825B99B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B99BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B99C0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B99C4: 392100C0  addi r9, r1, 0xc0
	ctx.r[9].s64 = ctx.r[1].s64 + 192;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B9AA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B9AA0 size=4208
    let mut pc: u32 = 0x825B9AA0;
    'dispatch: loop {
        match pc {
            0x825B9AA0 => {
    //   block [0x825B9AA0..0x825B9CE4)
	// 825B9AA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B9AA4: 4BF7B5DD  bl 0x82535080
	ctx.lr = 0x825B9AA8;
	sub_82535080(ctx, base);
	// 825B9AA8: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 825B9AAC: 4BF7C53D  bl 0x82535fe8
	ctx.lr = 0x825B9AB0;
	sub_82535FB0(ctx, base);
	// 825B9AB0: 9421FAF0  stwu r1, -0x510(r1)
	ea = ctx.r[1].u32.wrapping_add(-1296 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B9AB4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825B9AB8: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 825B9ABC: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 825B9AC0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825B9AC4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825B9AC8: 3A0BA2D8  addi r16, r11, -0x5d28
	ctx.r[16].s64 = ctx.r[11].s64 + -23848;
	// 825B9ACC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825B9AD0: C3872068  lfs f28, 0x2068(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8296 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 825B9AD4: C3A8294C  lfs f29, 0x294c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(10572 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 825B9AD8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825B9ADC: C3C91848  lfs f30, 0x1848(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(6216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825B9AE0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B9AE4: C3EA1850  lfs f31, 0x1850(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6224 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825B9AE8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825B9AEC: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 825B9AF0: 3DC08293  lis r14, -0x7d6d
	ctx.r[14].s64 = -2104295424;
	// 825B9AF4: 39EBA1D8  addi r15, r11, -0x5e28
	ctx.r[15].s64 = ctx.r[11].s64 + -24104;
	// 825B9AF8: 3A200010  li r17, 0x10
	ctx.r[17].s64 = 16;
	// 825B9AFC: 3A40FFE0  li r18, -0x20
	ctx.r[18].s64 = -32;
	// 825B9B00: 3A60FDF0  li r19, -0x210
	ctx.r[19].s64 = -528;
	// 825B9B04: 3A80FFF0  li r20, -0x10
	ctx.r[20].s64 = -16;
	// 825B9B08: 3AA0FE00  li r21, -0x200
	ctx.r[21].s64 = -512;
	// 825B9B0C: 3AC0FE10  li r22, -0x1f0
	ctx.r[22].s64 = -496;
	// 825B9B10: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B9B14: 2B0B006B  cmplwi cr6, r11, 0x6b
	ctx.cr[6].compare_u32(ctx.r[11].u32, 107 as u32, &mut ctx.xer);
	// 825B9B18: 41990EE4  bgt cr6, 0x825ba9fc
	if ctx.cr[6].gt {
	pc = 0x825BA9FC; continue 'dispatch;
	}
	// 825B9B1C: 3D80825C  lis r12, -0x7da4
	ctx.r[12].s64 = -2107899904;
	// 825B9B20: 398C9B34  addi r12, r12, -0x64cc
	ctx.r[12].s64 = ctx.r[12].s64 + -25804;
	// 825B9B24: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 825B9B28: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 825B9B2C: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 825B9B30: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x825BAB00; continue 'dispatch;
		},
		1 => {
	pc = 0x825BA7D0; continue 'dispatch;
		},
		2 => {
	pc = 0x825BA7D0; continue 'dispatch;
		},
		3 => {
	pc = 0x825BA7D0; continue 'dispatch;
		},
		4 => {
	pc = 0x825BA7D0; continue 'dispatch;
		},
		5 => {
	pc = 0x825BA77C; continue 'dispatch;
		},
		6 => {
	pc = 0x825BA78C; continue 'dispatch;
		},
		7 => {
	pc = 0x825BA7A8; continue 'dispatch;
		},
		8 => {
	pc = 0x825BA9FC; continue 'dispatch;
		},
		9 => {
	pc = 0x825BA840; continue 'dispatch;
		},
		10 => {
	pc = 0x825BA888; continue 'dispatch;
		},
		11 => {
	pc = 0x825BA8DC; continue 'dispatch;
		},
		12 => {
	pc = 0x825BA9FC; continue 'dispatch;
		},
		13 => {
	pc = 0x825BA9FC; continue 'dispatch;
		},
		14 => {
	pc = 0x825BA9FC; continue 'dispatch;
		},
		15 => {
	pc = 0x825BA9FC; continue 'dispatch;
		},
		16 => {
	pc = 0x825B9D20; continue 'dispatch;
		},
		17 => {
	pc = 0x825B9D20; continue 'dispatch;
		},
		18 => {
	pc = 0x825B9D20; continue 'dispatch;
		},
		19 => {
	pc = 0x825B9CE4; continue 'dispatch;
		},
		20 => {
	pc = 0x825B9CE4; continue 'dispatch;
		},
		21 => {
	pc = 0x825B9CE4; continue 'dispatch;
		},
		22 => {
	pc = 0x825B9CE4; continue 'dispatch;
		},
		23 => {
	pc = 0x825B9CE4; continue 'dispatch;
		},
		24 => {
	pc = 0x825B9CE4; continue 'dispatch;
		},
		25 => {
	pc = 0x825B9CE4; continue 'dispatch;
		},
		26 => {
	pc = 0x825B9CE4; continue 'dispatch;
		},
		27 => {
	pc = 0x825B9CE4; continue 'dispatch;
		},
		28 => {
	pc = 0x825B9CE4; continue 'dispatch;
		},
		29 => {
	pc = 0x825BA9FC; continue 'dispatch;
		},
		30 => {
	pc = 0x825BA9FC; continue 'dispatch;
		},
		31 => {
	pc = 0x825BA9FC; continue 'dispatch;
		},
		32 => {
	pc = 0x825B9DD0; continue 'dispatch;
		},
		33 => {
	pc = 0x825B9DD0; continue 'dispatch;
		},
		34 => {
	pc = 0x825B9DD0; continue 'dispatch;
		},
		35 => {
	pc = 0x825B9E74; continue 'dispatch;
		},
		36 => {
	pc = 0x825B9E74; continue 'dispatch;
		},
		37 => {
	pc = 0x825B9E74; continue 'dispatch;
		},
		38 => {
	pc = 0x825BA57C; continue 'dispatch;
		},
		39 => {
	pc = 0x825BA57C; continue 'dispatch;
		},
		40 => {
	pc = 0x825BA57C; continue 'dispatch;
		},
		41 => {
	pc = 0x825BA4F8; continue 'dispatch;
		},
		42 => {
	pc = 0x825BA4F8; continue 'dispatch;
		},
		43 => {
	pc = 0x825BA4F8; continue 'dispatch;
		},
		44 => {
	pc = 0x825BA9FC; continue 'dispatch;
		},
		45 => {
	pc = 0x825BA9FC; continue 'dispatch;
		},
		46 => {
	pc = 0x825BA9FC; continue 'dispatch;
		},
		47 => {
	pc = 0x825BA9FC; continue 'dispatch;
		},
		48 => {
	pc = 0x825BAAB8; continue 'dispatch;
		},
		49 => {
	pc = 0x825BAAB8; continue 'dispatch;
		},
		50 => {
	pc = 0x825BAAB8; continue 'dispatch;
		},
		51 => {
	pc = 0x825BAAB8; continue 'dispatch;
		},
		52 => {
	pc = 0x825BAAB8; continue 'dispatch;
		},
		53 => {
	pc = 0x825BAAB8; continue 'dispatch;
		},
		54 => {
	pc = 0x825BAAB8; continue 'dispatch;
		},
		55 => {
	pc = 0x825BAAB8; continue 'dispatch;
		},
		56 => {
	pc = 0x825BAAB8; continue 'dispatch;
		},
		57 => {
	pc = 0x825BAAB8; continue 'dispatch;
		},
		58 => {
	pc = 0x825BAAB8; continue 'dispatch;
		},
		59 => {
	pc = 0x825BAAB8; continue 'dispatch;
		},
		60 => {
	pc = 0x825BAAB8; continue 'dispatch;
		},
		61 => {
	pc = 0x825BAAB8; continue 'dispatch;
		},
		62 => {
	pc = 0x825BAAB8; continue 'dispatch;
		},
		63 => {
	pc = 0x825BAAB8; continue 'dispatch;
		},
		64 => {
	pc = 0x825BAAB8; continue 'dispatch;
		},
		65 => {
	pc = 0x825BAAB8; continue 'dispatch;
		},
		66 => {
	pc = 0x825BAAB8; continue 'dispatch;
		},
		67 => {
	pc = 0x825BAAB8; continue 'dispatch;
		},
		68 => {
	pc = 0x825BAAB8; continue 'dispatch;
		},
		69 => {
	pc = 0x825BAAB8; continue 'dispatch;
		},
		70 => {
	pc = 0x825BAAB8; continue 'dispatch;
		},
		71 => {
	pc = 0x825BAAB8; continue 'dispatch;
		},
		72 => {
	pc = 0x825BAAB8; continue 'dispatch;
		},
		73 => {
	pc = 0x825BAAB8; continue 'dispatch;
		},
		74 => {
	pc = 0x825BAAB8; continue 'dispatch;
		},
		75 => {
	pc = 0x825BAAB8; continue 'dispatch;
		},
		76 => {
	pc = 0x825BAAB8; continue 'dispatch;
		},
		77 => {
	pc = 0x825BAAB8; continue 'dispatch;
		},
		78 => {
	pc = 0x825BAAB8; continue 'dispatch;
		},
		79 => {
	pc = 0x825BAAB8; continue 'dispatch;
		},
		80 => {
	pc = 0x825BAA50; continue 'dispatch;
		},
		81 => {
	pc = 0x825BAA58; continue 'dispatch;
		},
		82 => {
	pc = 0x825BAA6C; continue 'dispatch;
		},
		83 => {
	pc = 0x825BAA8C; continue 'dispatch;
		},
		84 => {
	pc = 0x825BA9FC; continue 'dispatch;
		},
		85 => {
	pc = 0x825BA9FC; continue 'dispatch;
		},
		86 => {
	pc = 0x825BA9FC; continue 'dispatch;
		},
		87 => {
	pc = 0x825BA9FC; continue 'dispatch;
		},
		88 => {
	pc = 0x825BA9FC; continue 'dispatch;
		},
		89 => {
	pc = 0x825BA9FC; continue 'dispatch;
		},
		90 => {
	pc = 0x825BA9FC; continue 'dispatch;
		},
		91 => {
	pc = 0x825BA9FC; continue 'dispatch;
		},
		92 => {
	pc = 0x825BA9FC; continue 'dispatch;
		},
		93 => {
	pc = 0x825BA9FC; continue 'dispatch;
		},
		94 => {
	pc = 0x825BA9FC; continue 'dispatch;
		},
		95 => {
	pc = 0x825BA9FC; continue 'dispatch;
		},
		96 => {
	pc = 0x825BA940; continue 'dispatch;
		},
		97 => {
	pc = 0x825BA940; continue 'dispatch;
		},
		98 => {
	pc = 0x825BA940; continue 'dispatch;
		},
		99 => {
	pc = 0x825BA940; continue 'dispatch;
		},
		100 => {
	pc = 0x825BA95C; continue 'dispatch;
		},
		101 => {
	pc = 0x825BA95C; continue 'dispatch;
		},
		102 => {
	pc = 0x825BA95C; continue 'dispatch;
		},
		103 => {
	pc = 0x825BA95C; continue 'dispatch;
		},
		104 => {
	pc = 0x825BA984; continue 'dispatch;
		},
		105 => {
	pc = 0x825BA984; continue 'dispatch;
		},
		106 => {
	pc = 0x825BA984; continue 'dispatch;
		},
		107 => {
	pc = 0x825BA984; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 825B9B34: 825BAB00  lwz r18, -0x5500(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21760 as u32) ) } as u64;
	// 825B9B38: 825BA7D0  lwz r18, -0x5830(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22576 as u32) ) } as u64;
	// 825B9B3C: 825BA7D0  lwz r18, -0x5830(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22576 as u32) ) } as u64;
	// 825B9B40: 825BA7D0  lwz r18, -0x5830(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22576 as u32) ) } as u64;
	// 825B9B44: 825BA7D0  lwz r18, -0x5830(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22576 as u32) ) } as u64;
	// 825B9B48: 825BA77C  lwz r18, -0x5884(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22660 as u32) ) } as u64;
	// 825B9B4C: 825BA78C  lwz r18, -0x5874(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22644 as u32) ) } as u64;
	// 825B9B50: 825BA7A8  lwz r18, -0x5858(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22616 as u32) ) } as u64;
	// 825B9B54: 825BA9FC  lwz r18, -0x5604(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22020 as u32) ) } as u64;
	// 825B9B58: 825BA840  lwz r18, -0x57c0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22464 as u32) ) } as u64;
	// 825B9B5C: 825BA888  lwz r18, -0x5778(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22392 as u32) ) } as u64;
	// 825B9B60: 825BA8DC  lwz r18, -0x5724(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22308 as u32) ) } as u64;
	// 825B9B64: 825BA9FC  lwz r18, -0x5604(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22020 as u32) ) } as u64;
	// 825B9B68: 825BA9FC  lwz r18, -0x5604(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22020 as u32) ) } as u64;
	// 825B9B6C: 825BA9FC  lwz r18, -0x5604(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22020 as u32) ) } as u64;
	// 825B9B70: 825BA9FC  lwz r18, -0x5604(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22020 as u32) ) } as u64;
	// 825B9B74: 825B9D20  lwz r18, -0x62e0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-25312 as u32) ) } as u64;
	// 825B9B78: 825B9D20  lwz r18, -0x62e0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-25312 as u32) ) } as u64;
	// 825B9B7C: 825B9D20  lwz r18, -0x62e0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-25312 as u32) ) } as u64;
	// 825B9B80: 825B9CE4  lwz r18, -0x631c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-25372 as u32) ) } as u64;
	// 825B9B84: 825B9CE4  lwz r18, -0x631c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-25372 as u32) ) } as u64;
	// 825B9B88: 825B9CE4  lwz r18, -0x631c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-25372 as u32) ) } as u64;
	// 825B9B8C: 825B9CE4  lwz r18, -0x631c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-25372 as u32) ) } as u64;
	// 825B9B90: 825B9CE4  lwz r18, -0x631c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-25372 as u32) ) } as u64;
	// 825B9B94: 825B9CE4  lwz r18, -0x631c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-25372 as u32) ) } as u64;
	// 825B9B98: 825B9CE4  lwz r18, -0x631c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-25372 as u32) ) } as u64;
	// 825B9B9C: 825B9CE4  lwz r18, -0x631c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-25372 as u32) ) } as u64;
	// 825B9BA0: 825B9CE4  lwz r18, -0x631c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-25372 as u32) ) } as u64;
	// 825B9BA4: 825B9CE4  lwz r18, -0x631c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-25372 as u32) ) } as u64;
	// 825B9BA8: 825BA9FC  lwz r18, -0x5604(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22020 as u32) ) } as u64;
	// 825B9BAC: 825BA9FC  lwz r18, -0x5604(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22020 as u32) ) } as u64;
	// 825B9BB0: 825BA9FC  lwz r18, -0x5604(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22020 as u32) ) } as u64;
	// 825B9BB4: 825B9DD0  lwz r18, -0x6230(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-25136 as u32) ) } as u64;
	// 825B9BB8: 825B9DD0  lwz r18, -0x6230(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-25136 as u32) ) } as u64;
	// 825B9BBC: 825B9DD0  lwz r18, -0x6230(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-25136 as u32) ) } as u64;
	// 825B9BC0: 825B9E74  lwz r18, -0x618c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-24972 as u32) ) } as u64;
	// 825B9BC4: 825B9E74  lwz r18, -0x618c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-24972 as u32) ) } as u64;
	// 825B9BC8: 825B9E74  lwz r18, -0x618c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-24972 as u32) ) } as u64;
	// 825B9BCC: 825BA57C  lwz r18, -0x5a84(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-23172 as u32) ) } as u64;
	// 825B9BD0: 825BA57C  lwz r18, -0x5a84(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-23172 as u32) ) } as u64;
	// 825B9BD4: 825BA57C  lwz r18, -0x5a84(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-23172 as u32) ) } as u64;
	// 825B9BD8: 825BA4F8  lwz r18, -0x5b08(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-23304 as u32) ) } as u64;
	// 825B9BDC: 825BA4F8  lwz r18, -0x5b08(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-23304 as u32) ) } as u64;
	// 825B9BE0: 825BA4F8  lwz r18, -0x5b08(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-23304 as u32) ) } as u64;
	// 825B9BE4: 825BA9FC  lwz r18, -0x5604(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22020 as u32) ) } as u64;
	// 825B9BE8: 825BA9FC  lwz r18, -0x5604(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22020 as u32) ) } as u64;
	// 825B9BEC: 825BA9FC  lwz r18, -0x5604(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22020 as u32) ) } as u64;
	// 825B9BF0: 825BA9FC  lwz r18, -0x5604(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22020 as u32) ) } as u64;
	// 825B9BF4: 825BAAB8  lwz r18, -0x5548(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21832 as u32) ) } as u64;
	// 825B9BF8: 825BAAB8  lwz r18, -0x5548(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21832 as u32) ) } as u64;
	// 825B9BFC: 825BAAB8  lwz r18, -0x5548(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21832 as u32) ) } as u64;
	// 825B9C00: 825BAAB8  lwz r18, -0x5548(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21832 as u32) ) } as u64;
	// 825B9C04: 825BAAB8  lwz r18, -0x5548(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21832 as u32) ) } as u64;
	// 825B9C08: 825BAAB8  lwz r18, -0x5548(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21832 as u32) ) } as u64;
	// 825B9C0C: 825BAAB8  lwz r18, -0x5548(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21832 as u32) ) } as u64;
	// 825B9C10: 825BAAB8  lwz r18, -0x5548(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21832 as u32) ) } as u64;
	// 825B9C14: 825BAAB8  lwz r18, -0x5548(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21832 as u32) ) } as u64;
	// 825B9C18: 825BAAB8  lwz r18, -0x5548(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21832 as u32) ) } as u64;
	// 825B9C1C: 825BAAB8  lwz r18, -0x5548(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21832 as u32) ) } as u64;
	// 825B9C20: 825BAAB8  lwz r18, -0x5548(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21832 as u32) ) } as u64;
	// 825B9C24: 825BAAB8  lwz r18, -0x5548(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21832 as u32) ) } as u64;
	// 825B9C28: 825BAAB8  lwz r18, -0x5548(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21832 as u32) ) } as u64;
	// 825B9C2C: 825BAAB8  lwz r18, -0x5548(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21832 as u32) ) } as u64;
	// 825B9C30: 825BAAB8  lwz r18, -0x5548(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21832 as u32) ) } as u64;
	// 825B9C34: 825BAAB8  lwz r18, -0x5548(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21832 as u32) ) } as u64;
	// 825B9C38: 825BAAB8  lwz r18, -0x5548(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21832 as u32) ) } as u64;
	// 825B9C3C: 825BAAB8  lwz r18, -0x5548(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21832 as u32) ) } as u64;
	// 825B9C40: 825BAAB8  lwz r18, -0x5548(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21832 as u32) ) } as u64;
	// 825B9C44: 825BAAB8  lwz r18, -0x5548(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21832 as u32) ) } as u64;
	// 825B9C48: 825BAAB8  lwz r18, -0x5548(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21832 as u32) ) } as u64;
	// 825B9C4C: 825BAAB8  lwz r18, -0x5548(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21832 as u32) ) } as u64;
	// 825B9C50: 825BAAB8  lwz r18, -0x5548(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21832 as u32) ) } as u64;
	// 825B9C54: 825BAAB8  lwz r18, -0x5548(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21832 as u32) ) } as u64;
	// 825B9C58: 825BAAB8  lwz r18, -0x5548(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21832 as u32) ) } as u64;
	// 825B9C5C: 825BAAB8  lwz r18, -0x5548(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21832 as u32) ) } as u64;
	// 825B9C60: 825BAAB8  lwz r18, -0x5548(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21832 as u32) ) } as u64;
	// 825B9C64: 825BAAB8  lwz r18, -0x5548(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21832 as u32) ) } as u64;
	// 825B9C68: 825BAAB8  lwz r18, -0x5548(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21832 as u32) ) } as u64;
	// 825B9C6C: 825BAAB8  lwz r18, -0x5548(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21832 as u32) ) } as u64;
	// 825B9C70: 825BAAB8  lwz r18, -0x5548(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21832 as u32) ) } as u64;
	// 825B9C74: 825BAA50  lwz r18, -0x55b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21936 as u32) ) } as u64;
	// 825B9C78: 825BAA58  lwz r18, -0x55a8(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21928 as u32) ) } as u64;
	// 825B9C7C: 825BAA6C  lwz r18, -0x5594(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21908 as u32) ) } as u64;
	// 825B9C80: 825BAA8C  lwz r18, -0x5574(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21876 as u32) ) } as u64;
	// 825B9C84: 825BA9FC  lwz r18, -0x5604(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22020 as u32) ) } as u64;
	// 825B9C88: 825BA9FC  lwz r18, -0x5604(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22020 as u32) ) } as u64;
	// 825B9C8C: 825BA9FC  lwz r18, -0x5604(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22020 as u32) ) } as u64;
	// 825B9C90: 825BA9FC  lwz r18, -0x5604(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22020 as u32) ) } as u64;
	// 825B9C94: 825BA9FC  lwz r18, -0x5604(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22020 as u32) ) } as u64;
	// 825B9C98: 825BA9FC  lwz r18, -0x5604(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22020 as u32) ) } as u64;
	// 825B9C9C: 825BA9FC  lwz r18, -0x5604(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22020 as u32) ) } as u64;
	// 825B9CA0: 825BA9FC  lwz r18, -0x5604(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22020 as u32) ) } as u64;
	// 825B9CA4: 825BA9FC  lwz r18, -0x5604(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22020 as u32) ) } as u64;
	// 825B9CA8: 825BA9FC  lwz r18, -0x5604(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22020 as u32) ) } as u64;
	// 825B9CAC: 825BA9FC  lwz r18, -0x5604(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22020 as u32) ) } as u64;
	// 825B9CB0: 825BA9FC  lwz r18, -0x5604(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22020 as u32) ) } as u64;
	// 825B9CB4: 825BA940  lwz r18, -0x56c0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22208 as u32) ) } as u64;
	// 825B9CB8: 825BA940  lwz r18, -0x56c0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22208 as u32) ) } as u64;
	// 825B9CBC: 825BA940  lwz r18, -0x56c0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22208 as u32) ) } as u64;
	// 825B9CC0: 825BA940  lwz r18, -0x56c0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22208 as u32) ) } as u64;
	// 825B9CC4: 825BA95C  lwz r18, -0x56a4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22180 as u32) ) } as u64;
	// 825B9CC8: 825BA95C  lwz r18, -0x56a4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22180 as u32) ) } as u64;
	// 825B9CCC: 825BA95C  lwz r18, -0x56a4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22180 as u32) ) } as u64;
	// 825B9CD0: 825BA95C  lwz r18, -0x56a4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22180 as u32) ) } as u64;
	// 825B9CD4: 825BA984  lwz r18, -0x567c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22140 as u32) ) } as u64;
	// 825B9CD8: 825BA984  lwz r18, -0x567c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22140 as u32) ) } as u64;
	// 825B9CDC: 825BA984  lwz r18, -0x567c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22140 as u32) ) } as u64;
	// 825B9CE0: 825BA984  lwz r18, -0x567c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-22140 as u32) ) } as u64;
            }
            0x825B9CE4 => {
    //   block [0x825B9CE4..0x825B9D20)
	// 825B9CE4: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 825B9CE8: 8BBF0003  lbz r29, 3(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	pc = 0x825B9D20; continue 'dispatch;
            }
            0x825B9D20 => {
    //   block [0x825B9D20..0x825B9DD0)
	// 825B9D20: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	pc = 0x825B9DD0; continue 'dispatch;
            }
            0x825B9DD0 => {
    //   block [0x825B9DD0..0x825B9E74)
	// 825B9DD0: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	pc = 0x825B9E74; continue 'dispatch;
            }
            0x825B9E74 => {
    //   block [0x825B9E74..0x825BA4F8)
	// 825B9E74: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	pc = 0x825BA4F8; continue 'dispatch;
            }
            0x825BA4F8 => {
    //   block [0x825BA4F8..0x825BA57C)
	// 825BA4F8: 395F0001  addi r10, r31, 1
	ctx.r[10].s64 = ctx.r[31].s64 + 1;
	// 825BA4FC: C01B0010  lfs f0, 0x10(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BA500: 392BFFD7  addi r9, r11, -0x29
	ctx.r[9].s64 = ctx.r[11].s64 + -41;
	// 825BA504: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825BA508: 5525103A  slwi r5, r9, 2
	ctx.r[5].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 825BA50C: 3BFF0007  addi r31, r31, 7
	ctx.r[31].s64 = ctx.r[31].s64 + 7;
	// 825BA510: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BA514: 88CA0001  lbz r6, 1(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BA518: 5507403E  rotlwi r7, r8, 8
	ctx.r[7].u64 = ((ctx.r[8].u32).rotate_left(8)) as u64;
	// 825BA51C: 890A0002  lbz r8, 2(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BA520: 39490004  addi r10, r9, 4
	ctx.r[10].s64 = ctx.r[9].s64 + 4;
	// 825BA524: 7D273214  add r9, r7, r6
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 825BA528: 5547103A  slwi r7, r10, 2
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825BA52C: 552A402E  slwi r10, r9, 8
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(8);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BA530: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 825BA534: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825BA538: F9410188  std r10, 0x188(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), ctx.r[10].u64 ) };
	// 825BA53C: C9A10188  lfd f13, 0x188(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(392 as u32) ) };
	// 825BA540: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 825BA544: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825BA548: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825BA54C: 7C05D52E  stfsx f0, r5, r26
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[26].u32), tmp.u32) };
	// 825BA550: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BA554: 892B0001  lbz r9, 1(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BA558: 5548403E  rotlwi r8, r10, 8
	ctx.r[8].u64 = ((ctx.r[10].u32).rotate_left(8)) as u64;
	// 825BA55C: 894B0002  lbz r10, 2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BA560: 7D694214  add r11, r9, r8
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 825BA564: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BA568: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BA56C: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825BA570: F9610160  std r11, 0x160(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), ctx.r[11].u64 ) };
	// 825BA574: C9A10160  lfd f13, 0x160(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(352 as u32) ) };
	// 825BA578: 48000074  b 0x825ba5ec
	pc = 0x825BA5EC; continue 'dispatch;
            }
            0x825BA57C => {
    //   block [0x825BA57C..0x825BA77C)
	// 825BA57C: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BA580: 396BFFDA  addi r11, r11, -0x26
	ctx.r[11].s64 = ctx.r[11].s64 + -38;
	// 825BA584: 813E0014  lwz r9, 0x14(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BA588: C01B0010  lfs f0, 0x10(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BA58C: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825BA590: 7D494830  slw r9, r10, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[10].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 825BA594: 394B0002  addi r10, r11, 2
	ctx.r[10].s64 = ctx.r[11].s64 + 2;
	// 825BA598: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825BA59C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BA5A0: 5567103A  slwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825BA5A4: 7D6AF02E  lwzx r11, r10, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825BA5A8: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825BA5AC: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825BA5B0: F9610198  std r11, 0x198(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(408 as u32), ctx.r[11].u64 ) };
	// 825BA5B4: C9A10198  lfd f13, 0x198(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(408 as u32) ) };
	// 825BA5B8: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 825BA5BC: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825BA5C0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825BA5C4: 7C08D52E  stfsx f0, r8, r26
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[26].u32), tmp.u32) };
	// 825BA5C8: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BA5CC: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825BA5D0: 813E0014  lwz r9, 0x14(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BA5D4: 7D4AF02E  lwzx r10, r10, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825BA5D8: 7D6B4830  slw r11, r11, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[11].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 825BA5DC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BA5E0: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825BA5E4: F9610170  std r11, 0x170(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(368 as u32), ctx.r[11].u64 ) };
	// 825BA5E8: C9A10170  lfd f13, 0x170(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(368 as u32) ) };
	// 825BA5EC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 825BA5F0: C01B0010  lfs f0, 0x10(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BA5F4: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825BA5F8: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825BA5FC: 7C07D52E  stfsx f0, r7, r26
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[26].u32), tmp.u32) };
	// 825BA600: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BA604: 2B0B0026  cmplwi cr6, r11, 0x26
	ctx.cr[6].compare_u32(ctx.r[11].u32, 38 as u32, &mut ctx.xer);
	// 825BA608: 4198000C  blt cr6, 0x825ba614
	if ctx.cr[6].lt {
	pc = 0x825BA614; continue 'dispatch;
	}
	// 825BA60C: 2B0B002B  cmplwi cr6, r11, 0x2b
	ctx.cr[6].compare_u32(ctx.r[11].u32, 43 as u32, &mut ctx.xer);
	// 825BA610: 4099F500  ble cr6, 0x825b9b10
	if !ctx.cr[6].gt {
	pc = 0x825B9B10; continue 'dispatch;
	}
	// 825BA614: 387B0020  addi r3, r27, 0x20
	ctx.r[3].s64 = ctx.r[27].s64 + 32;
	pc = 0x825BA77C; continue 'dispatch;
            }
            0x825BA77C => {
    //   block [0x825BA77C..0x825BA78C)
	// 825BA77C: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BA780: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825BA784: 3BEB0002  addi r31, r11, 2
	ctx.r[31].s64 = ctx.r[11].s64 + 2;
	// 825BA788: 4BFFF388  b 0x825b9b10
	pc = 0x825B9B10; continue 'dispatch;
            }
            0x825BA78C => {
    //   block [0x825BA78C..0x825BA7A8)
	// 825BA78C: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BA790: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BA794: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825BA798: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BA79C: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825BA7A0: 3BEB0003  addi r31, r11, 3
	ctx.r[31].s64 = ctx.r[11].s64 + 3;
	// 825BA7A4: 4BFFF36C  b 0x825b9b10
	pc = 0x825B9B10; continue 'dispatch;
            }
            0x825BA7A8 => {
    //   block [0x825BA7A8..0x825BA7D0)
	// 825BA7A8: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BA7AC: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BA7B0: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825BA7B4: 895F0003  lbz r10, 3(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BA7B8: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825BA7BC: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BA7C0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BA7C4: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825BA7C8: 3BEB0004  addi r31, r11, 4
	ctx.r[31].s64 = ctx.r[11].s64 + 4;
	// 825BA7CC: 4BFFF344  b 0x825b9b10
	pc = 0x825B9B10; continue 'dispatch;
            }
            0x825BA7D0 => {
    //   block [0x825BA7D0..0x825BA840)
	// 825BA7D0: 811E0014  lwz r8, 0x14(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BA7D4: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BA7D8: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BA7DC: 7D4A4030  slw r10, r10, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 825BA7E0: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825BA7E4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825BA7E8: 811E0014  lwz r8, 0x14(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BA7EC: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BA7F0: 813E000C  lwz r9, 0xc(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BA7F4: 7D4A4030  slw r10, r10, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 825BA7F8: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825BA7FC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 825BA800: 895F0003  lbz r10, 3(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BA804: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825BA808: 811E0014  lwz r8, 0x14(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BA80C: 813E0010  lwz r9, 0x10(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BA810: 7D4A4030  slw r10, r10, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 825BA814: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825BA818: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825BA81C: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BA820: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BA824: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825BA828: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BA82C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825BA830: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BA834: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825BA838: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825BA83C: 4BFFF2D4  b 0x825b9b10
	pc = 0x825B9B10; continue 'dispatch;
            }
            0x825BA840 => {
    //   block [0x825BA840..0x825BA888)
	// 825BA840: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825BA844: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BA848: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825BA84C: 419A0028  beq cr6, 0x825ba874
	if ctx.cr[6].eq {
	pc = 0x825BA874; continue 'dispatch;
	}
	// 825BA850: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825BA854: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 825BA858: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825BA85C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BA860: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 825BA864: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BA868: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825BA86C: 4200FFF0  bdnz 0x825ba85c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825BA85C; continue 'dispatch;
	}
	// 825BA870: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825BA874: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825BA878: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 825BA87C: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825BA880: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825BA884: 4BFFF28C  b 0x825b9b10
	pc = 0x825B9B10; continue 'dispatch;
            }
            0x825BA888 => {
    //   block [0x825BA888..0x825BA8DC)
	// 825BA888: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BA88C: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 825BA890: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BA894: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825BA898: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825BA89C: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BA8A0: 419A0028  beq cr6, 0x825ba8c8
	if ctx.cr[6].eq {
	pc = 0x825BA8C8; continue 'dispatch;
	}
	// 825BA8A4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825BA8A8: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 825BA8AC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825BA8B0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BA8B4: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 825BA8B8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BA8BC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825BA8C0: 4200FFF0  bdnz 0x825ba8b0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825BA8B0; continue 'dispatch;
	}
	// 825BA8C4: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825BA8C8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825BA8CC: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825BA8D0: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825BA8D4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825BA8D8: 4BFFF238  b 0x825b9b10
	pc = 0x825B9B10; continue 'dispatch;
            }
            0x825BA8DC => {
    //   block [0x825BA8DC..0x825BA940)
	// 825BA8DC: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BA8E0: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825BA8E4: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BA8E8: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825BA8EC: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BA8F0: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BA8F4: 7F1E3840  cmplw cr6, r30, r7
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825BA8F8: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825BA8FC: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BA900: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825BA904: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BA908: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BA90C: 419A0028  beq cr6, 0x825ba934
	if ctx.cr[6].eq {
	pc = 0x825BA934; continue 'dispatch;
	}
	// 825BA910: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825BA914: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 825BA918: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825BA91C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BA920: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 825BA924: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BA928: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825BA92C: 4200FFF0  bdnz 0x825ba91c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825BA91C; continue 'dispatch;
	}
	// 825BA930: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825BA934: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 825BA938: 3BFF0005  addi r31, r31, 5
	ctx.r[31].s64 = ctx.r[31].s64 + 5;
	// 825BA93C: 4BFFF1D4  b 0x825b9b10
	pc = 0x825B9B10; continue 'dispatch;
            }
            0x825BA940 => {
    //   block [0x825BA940..0x825BA95C)
	// 825BA940: 396BFFA0  addi r11, r11, -0x60
	ctx.r[11].s64 = ctx.r[11].s64 + -96;
	// 825BA944: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BA948: 39210054  addi r9, r1, 0x54
	ctx.r[9].s64 = ctx.r[1].s64 + 84;
	// 825BA94C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BA950: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 825BA954: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 825BA958: 48000068  b 0x825ba9c0
	pc = 0x825BA9C0; continue 'dispatch;
            }
            0x825BA95C => {
    //   block [0x825BA95C..0x825BA984)
	// 825BA95C: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BA960: 390BFF9C  addi r8, r11, -0x64
	ctx.r[8].s64 = ctx.r[11].s64 + -100;
	// 825BA964: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BA968: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 825BA96C: 552B403E  rotlwi r11, r9, 8
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(8)) as u64;
	// 825BA970: 5509103A  slwi r9, r8, 2
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825BA974: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BA978: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825BA97C: 7D69392E  stwx r11, r9, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32), ctx.r[11].u32) };
	// 825BA980: 48000040  b 0x825ba9c0
	pc = 0x825BA9C0; continue 'dispatch;
            }
            0x825BA984 => {
    //   block [0x825BA984..0x825BA9FC)
	// 825BA984: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BA988: 38EBFF98  addi r7, r11, -0x68
	ctx.r[7].s64 = ctx.r[11].s64 + -104;
	// 825BA98C: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BA990: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 825BA994: 554B403E  rotlwi r11, r10, 8
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(8)) as u64;
	// 825BA998: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BA99C: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BA9A0: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825BA9A4: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825BA9A8: 3BFF0005  addi r31, r31, 5
	ctx.r[31].s64 = ctx.r[31].s64 + 5;
	// 825BA9AC: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BA9B0: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825BA9B4: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BA9B8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BA9BC: 7D67312E  stwx r11, r7, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32), ctx.r[11].u32) };
	// 825BA9C0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825BA9C4: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825BA9C8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825BA9CC: 419A0028  beq cr6, 0x825ba9f4
	if ctx.cr[6].eq {
	pc = 0x825BA9F4; continue 'dispatch;
	}
	// 825BA9D0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825BA9D4: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 825BA9D8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825BA9DC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BA9E0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 825BA9E4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BA9E8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825BA9EC: 4200FFF0  bdnz 0x825ba9dc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825BA9DC; continue 'dispatch;
	}
	// 825BA9F0: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825BA9F4: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825BA9F8: 4BFFF118  b 0x825b9b10
	pc = 0x825B9B10; continue 'dispatch;
            }
            0x825BA9FC => {
    //   block [0x825BA9FC..0x825BAA50)
	// 825BA9FC: 38A00200  li r5, 0x200
	ctx.r[5].s64 = 512;
	// 825BAA00: 38810250  addi r4, r1, 0x250
	ctx.r[4].s64 = ctx.r[1].s64 + 592;
	// 825BAA04: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 825BAA08: 4BEAE3F1  bl 0x82468df8
	ctx.lr = 0x825BAA0C;
	sub_82468DF8(ctx, base);
	// 825BAA0C: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 825BAA10: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 825BAA14: 4BEAD88D  bl 0x824682a0
	ctx.lr = 0x825BAA18;
	sub_824682A0(ctx, base);
	// 825BAA18: 806E9190  lwz r3, -0x6e70(r14)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(-28272 as u32) ) } as u64;
	// 825BAA1C: 3CA01298  lis r5, 0x1298
	ctx.r[5].s64 = 311951360;
	// 825BAA20: 3900012D  li r8, 0x12d
	ctx.r[8].s64 = 301;
	// 825BAA24: 7E078378  mr r7, r16
	ctx.r[7].u64 = ctx.r[16].u64;
	// 825BAA28: 38C10250  addi r6, r1, 0x250
	ctx.r[6].s64 = ctx.r[1].s64 + 592;
	// 825BAA2C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BAA30: 60A5FEDD  ori r5, r5, 0xfedd
	ctx.r[5].u64 = ctx.r[5].u64 | 65245;
	// 825BAA34: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825BAA38: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BAA3C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BAA40: 4E800421  bctrl
	ctx.lr = 0x825BAA44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BAA44: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 825BAA48: 4BEADE99  bl 0x824688e0
	ctx.lr = 0x825BAA4C;
	sub_824688E0(ctx, base);
	// 825BAA4C: 4BFFF0C4  b 0x825b9b10
	pc = 0x825B9B10; continue 'dispatch;
            }
            0x825BAA50 => {
    //   block [0x825BAA50..0x825BAA58)
	// 825BAA50: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BAA54: 48000068  b 0x825baabc
	pc = 0x825BAABC; continue 'dispatch;
            }
            0x825BAA58 => {
    //   block [0x825BAA58..0x825BAA6C)
	// 825BAA58: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BAA5C: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BAA60: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825BAA64: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BAA68: 48000054  b 0x825baabc
	pc = 0x825BAABC; continue 'dispatch;
            }
            0x825BAA6C => {
    //   block [0x825BAA6C..0x825BAA8C)
	// 825BAA6C: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BAA70: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BAA74: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825BAA78: 895F0003  lbz r10, 3(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BAA7C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825BAA80: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BAA84: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BAA88: 48000034  b 0x825baabc
	pc = 0x825BAABC; continue 'dispatch;
            }
            0x825BAA8C => {
    //   block [0x825BAA8C..0x825BAAB8)
	// 825BAA8C: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BAA90: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BAA94: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825BAA98: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BAA9C: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BAAA0: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825BAAA4: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BAAA8: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825BAAAC: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BAAB0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BAAB4: 48000008  b 0x825baabc
	pc = 0x825BAABC; continue 'dispatch;
            }
            0x825BAAB8 => {
    //   block [0x825BAAB8..0x825BAB00)
	// 825BAAB8: 396BFFD0  addi r11, r11, -0x30
	ctx.r[11].s64 = ctx.r[11].s64 + -48;
	// 825BAABC: 83FB0000  lwz r31, 0(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BAAC0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BAAC4: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825BAAC8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BAACC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BAAD0: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825BAAD4: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825BAAD8: 409A0010  bne cr6, 0x825baae8
	if !ctx.cr[6].eq {
	pc = 0x825BAAE8; continue 'dispatch;
	}
	// 825BAADC: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 825BAAE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BAAE4: 4BEB386D  bl 0x8246e350
	ctx.lr = 0x825BAAE8;
	sub_8246E350(ctx, base);
	// 825BAAE8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BAAEC: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BAAF0: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BAAF4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825BAAF8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825BAAFC: 7FCA492E  stwx r30, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[30].u32) };
	pc = 0x825BAB00; continue 'dispatch;
            }
            0x825BAB00 => {
    //   block [0x825BAB00..0x825BAB10)
	// 825BAB00: 38210510  addi r1, r1, 0x510
	ctx.r[1].s64 = ctx.r[1].s64 + 1296;
	// 825BAB04: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 825BAB08: 4BF7B52D  bl 0x82536034
	ctx.lr = 0x825BAB0C;
	sub_82535FFC(ctx, base);
	// 825BAB0C: 4BF7A5C4  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BAB10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BAB10 size=4296
    let mut pc: u32 = 0x825BAB10;
    'dispatch: loop {
        match pc {
            0x825BAB10 => {
    //   block [0x825BAB10..0x825BAD50)
	// 825BAB10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BAB14: 4BF7A56D  bl 0x82535080
	ctx.lr = 0x825BAB18;
	sub_82535080(ctx, base);
	// 825BAB18: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 825BAB1C: 4BF7B4CD  bl 0x82535fe8
	ctx.lr = 0x825BAB20;
	sub_82535FB0(ctx, base);
	// 825BAB20: 9421FAF0  stwu r1, -0x510(r1)
	ea = ctx.r[1].u32.wrapping_add(-1296 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BAB24: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825BAB28: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 825BAB2C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 825BAB30: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825BAB34: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825BAB38: 39EBA2D8  addi r15, r11, -0x5d28
	ctx.r[15].s64 = ctx.r[11].s64 + -23848;
	// 825BAB3C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825BAB40: C3872068  lfs f28, 0x2068(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8296 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 825BAB44: C3A8294C  lfs f29, 0x294c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(10572 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 825BAB48: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825BAB4C: C3C91848  lfs f30, 0x1848(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(6216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825BAB50: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825BAB54: C3EA1850  lfs f31, 0x1850(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6224 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825BAB58: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825BAB5C: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 825BAB60: 39CBA1D8  addi r14, r11, -0x5e28
	ctx.r[14].s64 = ctx.r[11].s64 + -24104;
	// 825BAB64: 3AA00010  li r21, 0x10
	ctx.r[21].s64 = 16;
	// 825BAB68: 3A00FFF0  li r16, -0x10
	ctx.r[16].s64 = -16;
	// 825BAB6C: 3A20FE00  li r17, -0x200
	ctx.r[17].s64 = -512;
	// 825BAB70: 3A40FE10  li r18, -0x1f0
	ctx.r[18].s64 = -496;
	// 825BAB74: 3A600020  li r19, 0x20
	ctx.r[19].s64 = 32;
	// 825BAB78: 3A80FE20  li r20, -0x1e0
	ctx.r[20].s64 = -480;
	// 825BAB7C: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BAB80: 2B0B006B  cmplwi cr6, r11, 0x6b
	ctx.cr[6].compare_u32(ctx.r[11].u32, 107 as u32, &mut ctx.xer);
	// 825BAB84: 41990F3C  bgt cr6, 0x825bbac0
	if ctx.cr[6].gt {
	pc = 0x825BBAC0; continue 'dispatch;
	}
	// 825BAB88: 3D80825C  lis r12, -0x7da4
	ctx.r[12].s64 = -2107899904;
	// 825BAB8C: 398CABA0  addi r12, r12, -0x5460
	ctx.r[12].s64 = ctx.r[12].s64 + -21600;
	// 825BAB90: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 825BAB94: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 825BAB98: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 825BAB9C: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x825BBBC8; continue 'dispatch;
		},
		1 => {
	pc = 0x825BB894; continue 'dispatch;
		},
		2 => {
	pc = 0x825BB894; continue 'dispatch;
		},
		3 => {
	pc = 0x825BB894; continue 'dispatch;
		},
		4 => {
	pc = 0x825BB894; continue 'dispatch;
		},
		5 => {
	pc = 0x825BB840; continue 'dispatch;
		},
		6 => {
	pc = 0x825BB850; continue 'dispatch;
		},
		7 => {
	pc = 0x825BB86C; continue 'dispatch;
		},
		8 => {
	pc = 0x825BBAC0; continue 'dispatch;
		},
		9 => {
	pc = 0x825BB904; continue 'dispatch;
		},
		10 => {
	pc = 0x825BB94C; continue 'dispatch;
		},
		11 => {
	pc = 0x825BB9A0; continue 'dispatch;
		},
		12 => {
	pc = 0x825BBAC0; continue 'dispatch;
		},
		13 => {
	pc = 0x825BBAC0; continue 'dispatch;
		},
		14 => {
	pc = 0x825BBAC0; continue 'dispatch;
		},
		15 => {
	pc = 0x825BBAC0; continue 'dispatch;
		},
		16 => {
	pc = 0x825BAD8C; continue 'dispatch;
		},
		17 => {
	pc = 0x825BAD8C; continue 'dispatch;
		},
		18 => {
	pc = 0x825BAD8C; continue 'dispatch;
		},
		19 => {
	pc = 0x825BAD50; continue 'dispatch;
		},
		20 => {
	pc = 0x825BAD50; continue 'dispatch;
		},
		21 => {
	pc = 0x825BAD50; continue 'dispatch;
		},
		22 => {
	pc = 0x825BAD50; continue 'dispatch;
		},
		23 => {
	pc = 0x825BAD50; continue 'dispatch;
		},
		24 => {
	pc = 0x825BAD50; continue 'dispatch;
		},
		25 => {
	pc = 0x825BAD50; continue 'dispatch;
		},
		26 => {
	pc = 0x825BAD50; continue 'dispatch;
		},
		27 => {
	pc = 0x825BAD50; continue 'dispatch;
		},
		28 => {
	pc = 0x825BAD50; continue 'dispatch;
		},
		29 => {
	pc = 0x825BBAC0; continue 'dispatch;
		},
		30 => {
	pc = 0x825BBAC0; continue 'dispatch;
		},
		31 => {
	pc = 0x825BBAC0; continue 'dispatch;
		},
		32 => {
	pc = 0x825BAE3C; continue 'dispatch;
		},
		33 => {
	pc = 0x825BAE3C; continue 'dispatch;
		},
		34 => {
	pc = 0x825BAE3C; continue 'dispatch;
		},
		35 => {
	pc = 0x825BAEE0; continue 'dispatch;
		},
		36 => {
	pc = 0x825BAEE0; continue 'dispatch;
		},
		37 => {
	pc = 0x825BAEE0; continue 'dispatch;
		},
		38 => {
	pc = 0x825BB624; continue 'dispatch;
		},
		39 => {
	pc = 0x825BB624; continue 'dispatch;
		},
		40 => {
	pc = 0x825BB624; continue 'dispatch;
		},
		41 => {
	pc = 0x825BB5A0; continue 'dispatch;
		},
		42 => {
	pc = 0x825BB5A0; continue 'dispatch;
		},
		43 => {
	pc = 0x825BB5A0; continue 'dispatch;
		},
		44 => {
	pc = 0x825BBAC0; continue 'dispatch;
		},
		45 => {
	pc = 0x825BBAC0; continue 'dispatch;
		},
		46 => {
	pc = 0x825BBAC0; continue 'dispatch;
		},
		47 => {
	pc = 0x825BBAC0; continue 'dispatch;
		},
		48 => {
	pc = 0x825BBB80; continue 'dispatch;
		},
		49 => {
	pc = 0x825BBB80; continue 'dispatch;
		},
		50 => {
	pc = 0x825BBB80; continue 'dispatch;
		},
		51 => {
	pc = 0x825BBB80; continue 'dispatch;
		},
		52 => {
	pc = 0x825BBB80; continue 'dispatch;
		},
		53 => {
	pc = 0x825BBB80; continue 'dispatch;
		},
		54 => {
	pc = 0x825BBB80; continue 'dispatch;
		},
		55 => {
	pc = 0x825BBB80; continue 'dispatch;
		},
		56 => {
	pc = 0x825BBB80; continue 'dispatch;
		},
		57 => {
	pc = 0x825BBB80; continue 'dispatch;
		},
		58 => {
	pc = 0x825BBB80; continue 'dispatch;
		},
		59 => {
	pc = 0x825BBB80; continue 'dispatch;
		},
		60 => {
	pc = 0x825BBB80; continue 'dispatch;
		},
		61 => {
	pc = 0x825BBB80; continue 'dispatch;
		},
		62 => {
	pc = 0x825BBB80; continue 'dispatch;
		},
		63 => {
	pc = 0x825BBB80; continue 'dispatch;
		},
		64 => {
	pc = 0x825BBB80; continue 'dispatch;
		},
		65 => {
	pc = 0x825BBB80; continue 'dispatch;
		},
		66 => {
	pc = 0x825BBB80; continue 'dispatch;
		},
		67 => {
	pc = 0x825BBB80; continue 'dispatch;
		},
		68 => {
	pc = 0x825BBB80; continue 'dispatch;
		},
		69 => {
	pc = 0x825BBB80; continue 'dispatch;
		},
		70 => {
	pc = 0x825BBB80; continue 'dispatch;
		},
		71 => {
	pc = 0x825BBB80; continue 'dispatch;
		},
		72 => {
	pc = 0x825BBB80; continue 'dispatch;
		},
		73 => {
	pc = 0x825BBB80; continue 'dispatch;
		},
		74 => {
	pc = 0x825BBB80; continue 'dispatch;
		},
		75 => {
	pc = 0x825BBB80; continue 'dispatch;
		},
		76 => {
	pc = 0x825BBB80; continue 'dispatch;
		},
		77 => {
	pc = 0x825BBB80; continue 'dispatch;
		},
		78 => {
	pc = 0x825BBB80; continue 'dispatch;
		},
		79 => {
	pc = 0x825BBB80; continue 'dispatch;
		},
		80 => {
	pc = 0x825BBB18; continue 'dispatch;
		},
		81 => {
	pc = 0x825BBB20; continue 'dispatch;
		},
		82 => {
	pc = 0x825BBB34; continue 'dispatch;
		},
		83 => {
	pc = 0x825BBB54; continue 'dispatch;
		},
		84 => {
	pc = 0x825BBAC0; continue 'dispatch;
		},
		85 => {
	pc = 0x825BBAC0; continue 'dispatch;
		},
		86 => {
	pc = 0x825BBAC0; continue 'dispatch;
		},
		87 => {
	pc = 0x825BBAC0; continue 'dispatch;
		},
		88 => {
	pc = 0x825BBAC0; continue 'dispatch;
		},
		89 => {
	pc = 0x825BBAC0; continue 'dispatch;
		},
		90 => {
	pc = 0x825BBAC0; continue 'dispatch;
		},
		91 => {
	pc = 0x825BBAC0; continue 'dispatch;
		},
		92 => {
	pc = 0x825BBAC0; continue 'dispatch;
		},
		93 => {
	pc = 0x825BBAC0; continue 'dispatch;
		},
		94 => {
	pc = 0x825BBAC0; continue 'dispatch;
		},
		95 => {
	pc = 0x825BBAC0; continue 'dispatch;
		},
		96 => {
	pc = 0x825BBA04; continue 'dispatch;
		},
		97 => {
	pc = 0x825BBA04; continue 'dispatch;
		},
		98 => {
	pc = 0x825BBA04; continue 'dispatch;
		},
		99 => {
	pc = 0x825BBA04; continue 'dispatch;
		},
		100 => {
	pc = 0x825BBA20; continue 'dispatch;
		},
		101 => {
	pc = 0x825BBA20; continue 'dispatch;
		},
		102 => {
	pc = 0x825BBA20; continue 'dispatch;
		},
		103 => {
	pc = 0x825BBA20; continue 'dispatch;
		},
		104 => {
	pc = 0x825BBA48; continue 'dispatch;
		},
		105 => {
	pc = 0x825BBA48; continue 'dispatch;
		},
		106 => {
	pc = 0x825BBA48; continue 'dispatch;
		},
		107 => {
	pc = 0x825BBA48; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 825BABA0: 825BBBC8  lwz r18, -0x4438(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17464 as u32) ) } as u64;
	// 825BABA4: 825BB894  lwz r18, -0x476c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-18284 as u32) ) } as u64;
	// 825BABA8: 825BB894  lwz r18, -0x476c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-18284 as u32) ) } as u64;
	// 825BABAC: 825BB894  lwz r18, -0x476c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-18284 as u32) ) } as u64;
	// 825BABB0: 825BB894  lwz r18, -0x476c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-18284 as u32) ) } as u64;
	// 825BABB4: 825BB840  lwz r18, -0x47c0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-18368 as u32) ) } as u64;
	// 825BABB8: 825BB850  lwz r18, -0x47b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-18352 as u32) ) } as u64;
	// 825BABBC: 825BB86C  lwz r18, -0x4794(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-18324 as u32) ) } as u64;
	// 825BABC0: 825BBAC0  lwz r18, -0x4540(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17728 as u32) ) } as u64;
	// 825BABC4: 825BB904  lwz r18, -0x46fc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-18172 as u32) ) } as u64;
	// 825BABC8: 825BB94C  lwz r18, -0x46b4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-18100 as u32) ) } as u64;
	// 825BABCC: 825BB9A0  lwz r18, -0x4660(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-18016 as u32) ) } as u64;
	// 825BABD0: 825BBAC0  lwz r18, -0x4540(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17728 as u32) ) } as u64;
	// 825BABD4: 825BBAC0  lwz r18, -0x4540(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17728 as u32) ) } as u64;
	// 825BABD8: 825BBAC0  lwz r18, -0x4540(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17728 as u32) ) } as u64;
	// 825BABDC: 825BBAC0  lwz r18, -0x4540(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17728 as u32) ) } as u64;
	// 825BABE0: 825BAD8C  lwz r18, -0x5274(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21108 as u32) ) } as u64;
	// 825BABE4: 825BAD8C  lwz r18, -0x5274(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21108 as u32) ) } as u64;
	// 825BABE8: 825BAD8C  lwz r18, -0x5274(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21108 as u32) ) } as u64;
	// 825BABEC: 825BAD50  lwz r18, -0x52b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21168 as u32) ) } as u64;
	// 825BABF0: 825BAD50  lwz r18, -0x52b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21168 as u32) ) } as u64;
	// 825BABF4: 825BAD50  lwz r18, -0x52b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21168 as u32) ) } as u64;
	// 825BABF8: 825BAD50  lwz r18, -0x52b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21168 as u32) ) } as u64;
	// 825BABFC: 825BAD50  lwz r18, -0x52b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21168 as u32) ) } as u64;
	// 825BAC00: 825BAD50  lwz r18, -0x52b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21168 as u32) ) } as u64;
	// 825BAC04: 825BAD50  lwz r18, -0x52b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21168 as u32) ) } as u64;
	// 825BAC08: 825BAD50  lwz r18, -0x52b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21168 as u32) ) } as u64;
	// 825BAC0C: 825BAD50  lwz r18, -0x52b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21168 as u32) ) } as u64;
	// 825BAC10: 825BAD50  lwz r18, -0x52b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-21168 as u32) ) } as u64;
	// 825BAC14: 825BBAC0  lwz r18, -0x4540(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17728 as u32) ) } as u64;
	// 825BAC18: 825BBAC0  lwz r18, -0x4540(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17728 as u32) ) } as u64;
	// 825BAC1C: 825BBAC0  lwz r18, -0x4540(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17728 as u32) ) } as u64;
	// 825BAC20: 825BAE3C  lwz r18, -0x51c4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-20932 as u32) ) } as u64;
	// 825BAC24: 825BAE3C  lwz r18, -0x51c4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-20932 as u32) ) } as u64;
	// 825BAC28: 825BAE3C  lwz r18, -0x51c4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-20932 as u32) ) } as u64;
	// 825BAC2C: 825BAEE0  lwz r18, -0x5120(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-20768 as u32) ) } as u64;
	// 825BAC30: 825BAEE0  lwz r18, -0x5120(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-20768 as u32) ) } as u64;
	// 825BAC34: 825BAEE0  lwz r18, -0x5120(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-20768 as u32) ) } as u64;
	// 825BAC38: 825BB624  lwz r18, -0x49dc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-18908 as u32) ) } as u64;
	// 825BAC3C: 825BB624  lwz r18, -0x49dc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-18908 as u32) ) } as u64;
	// 825BAC40: 825BB624  lwz r18, -0x49dc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-18908 as u32) ) } as u64;
	// 825BAC44: 825BB5A0  lwz r18, -0x4a60(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-19040 as u32) ) } as u64;
	// 825BAC48: 825BB5A0  lwz r18, -0x4a60(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-19040 as u32) ) } as u64;
	// 825BAC4C: 825BB5A0  lwz r18, -0x4a60(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-19040 as u32) ) } as u64;
	// 825BAC50: 825BBAC0  lwz r18, -0x4540(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17728 as u32) ) } as u64;
	// 825BAC54: 825BBAC0  lwz r18, -0x4540(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17728 as u32) ) } as u64;
	// 825BAC58: 825BBAC0  lwz r18, -0x4540(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17728 as u32) ) } as u64;
	// 825BAC5C: 825BBAC0  lwz r18, -0x4540(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17728 as u32) ) } as u64;
	// 825BAC60: 825BBB80  lwz r18, -0x4480(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17536 as u32) ) } as u64;
	// 825BAC64: 825BBB80  lwz r18, -0x4480(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17536 as u32) ) } as u64;
	// 825BAC68: 825BBB80  lwz r18, -0x4480(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17536 as u32) ) } as u64;
	// 825BAC6C: 825BBB80  lwz r18, -0x4480(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17536 as u32) ) } as u64;
	// 825BAC70: 825BBB80  lwz r18, -0x4480(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17536 as u32) ) } as u64;
	// 825BAC74: 825BBB80  lwz r18, -0x4480(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17536 as u32) ) } as u64;
	// 825BAC78: 825BBB80  lwz r18, -0x4480(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17536 as u32) ) } as u64;
	// 825BAC7C: 825BBB80  lwz r18, -0x4480(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17536 as u32) ) } as u64;
	// 825BAC80: 825BBB80  lwz r18, -0x4480(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17536 as u32) ) } as u64;
	// 825BAC84: 825BBB80  lwz r18, -0x4480(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17536 as u32) ) } as u64;
	// 825BAC88: 825BBB80  lwz r18, -0x4480(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17536 as u32) ) } as u64;
	// 825BAC8C: 825BBB80  lwz r18, -0x4480(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17536 as u32) ) } as u64;
	// 825BAC90: 825BBB80  lwz r18, -0x4480(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17536 as u32) ) } as u64;
	// 825BAC94: 825BBB80  lwz r18, -0x4480(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17536 as u32) ) } as u64;
	// 825BAC98: 825BBB80  lwz r18, -0x4480(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17536 as u32) ) } as u64;
	// 825BAC9C: 825BBB80  lwz r18, -0x4480(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17536 as u32) ) } as u64;
	// 825BACA0: 825BBB80  lwz r18, -0x4480(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17536 as u32) ) } as u64;
	// 825BACA4: 825BBB80  lwz r18, -0x4480(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17536 as u32) ) } as u64;
	// 825BACA8: 825BBB80  lwz r18, -0x4480(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17536 as u32) ) } as u64;
	// 825BACAC: 825BBB80  lwz r18, -0x4480(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17536 as u32) ) } as u64;
	// 825BACB0: 825BBB80  lwz r18, -0x4480(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17536 as u32) ) } as u64;
	// 825BACB4: 825BBB80  lwz r18, -0x4480(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17536 as u32) ) } as u64;
	// 825BACB8: 825BBB80  lwz r18, -0x4480(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17536 as u32) ) } as u64;
	// 825BACBC: 825BBB80  lwz r18, -0x4480(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17536 as u32) ) } as u64;
	// 825BACC0: 825BBB80  lwz r18, -0x4480(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17536 as u32) ) } as u64;
	// 825BACC4: 825BBB80  lwz r18, -0x4480(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17536 as u32) ) } as u64;
	// 825BACC8: 825BBB80  lwz r18, -0x4480(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17536 as u32) ) } as u64;
	// 825BACCC: 825BBB80  lwz r18, -0x4480(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17536 as u32) ) } as u64;
	// 825BACD0: 825BBB80  lwz r18, -0x4480(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17536 as u32) ) } as u64;
	// 825BACD4: 825BBB80  lwz r18, -0x4480(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17536 as u32) ) } as u64;
	// 825BACD8: 825BBB80  lwz r18, -0x4480(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17536 as u32) ) } as u64;
	// 825BACDC: 825BBB80  lwz r18, -0x4480(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17536 as u32) ) } as u64;
	// 825BACE0: 825BBB18  lwz r18, -0x44e8(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17640 as u32) ) } as u64;
	// 825BACE4: 825BBB20  lwz r18, -0x44e0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17632 as u32) ) } as u64;
	// 825BACE8: 825BBB34  lwz r18, -0x44cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17612 as u32) ) } as u64;
	// 825BACEC: 825BBB54  lwz r18, -0x44ac(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17580 as u32) ) } as u64;
	// 825BACF0: 825BBAC0  lwz r18, -0x4540(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17728 as u32) ) } as u64;
	// 825BACF4: 825BBAC0  lwz r18, -0x4540(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17728 as u32) ) } as u64;
	// 825BACF8: 825BBAC0  lwz r18, -0x4540(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17728 as u32) ) } as u64;
	// 825BACFC: 825BBAC0  lwz r18, -0x4540(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17728 as u32) ) } as u64;
	// 825BAD00: 825BBAC0  lwz r18, -0x4540(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17728 as u32) ) } as u64;
	// 825BAD04: 825BBAC0  lwz r18, -0x4540(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17728 as u32) ) } as u64;
	// 825BAD08: 825BBAC0  lwz r18, -0x4540(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17728 as u32) ) } as u64;
	// 825BAD0C: 825BBAC0  lwz r18, -0x4540(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17728 as u32) ) } as u64;
	// 825BAD10: 825BBAC0  lwz r18, -0x4540(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17728 as u32) ) } as u64;
	// 825BAD14: 825BBAC0  lwz r18, -0x4540(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17728 as u32) ) } as u64;
	// 825BAD18: 825BBAC0  lwz r18, -0x4540(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17728 as u32) ) } as u64;
	// 825BAD1C: 825BBAC0  lwz r18, -0x4540(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17728 as u32) ) } as u64;
	// 825BAD20: 825BBA04  lwz r18, -0x45fc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 825BAD24: 825BBA04  lwz r18, -0x45fc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 825BAD28: 825BBA04  lwz r18, -0x45fc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 825BAD2C: 825BBA04  lwz r18, -0x45fc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 825BAD30: 825BBA20  lwz r18, -0x45e0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17888 as u32) ) } as u64;
	// 825BAD34: 825BBA20  lwz r18, -0x45e0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17888 as u32) ) } as u64;
	// 825BAD38: 825BBA20  lwz r18, -0x45e0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17888 as u32) ) } as u64;
	// 825BAD3C: 825BBA20  lwz r18, -0x45e0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17888 as u32) ) } as u64;
	// 825BAD40: 825BBA48  lwz r18, -0x45b8(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17848 as u32) ) } as u64;
	// 825BAD44: 825BBA48  lwz r18, -0x45b8(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17848 as u32) ) } as u64;
	// 825BAD48: 825BBA48  lwz r18, -0x45b8(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17848 as u32) ) } as u64;
	// 825BAD4C: 825BBA48  lwz r18, -0x45b8(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17848 as u32) ) } as u64;
            }
            0x825BAD50 => {
    //   block [0x825BAD50..0x825BAD8C)
	// 825BAD50: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 825BAD54: 8BDF0003  lbz r30, 3(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	pc = 0x825BAD8C; continue 'dispatch;
            }
            0x825BAD8C => {
    //   block [0x825BAD8C..0x825BAE3C)
	// 825BAD8C: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	pc = 0x825BAE3C; continue 'dispatch;
            }
            0x825BAE3C => {
    //   block [0x825BAE3C..0x825BAEE0)
	// 825BAE3C: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	pc = 0x825BAEE0; continue 'dispatch;
            }
            0x825BAEE0 => {
    //   block [0x825BAEE0..0x825BB5A0)
	// 825BAEE0: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	pc = 0x825BB5A0; continue 'dispatch;
            }
            0x825BB5A0 => {
    //   block [0x825BB5A0..0x825BB624)
	// 825BB5A0: 395F0001  addi r10, r31, 1
	ctx.r[10].s64 = ctx.r[31].s64 + 1;
	// 825BB5A4: C01B0010  lfs f0, 0x10(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BB5A8: 392BFFD7  addi r9, r11, -0x29
	ctx.r[9].s64 = ctx.r[11].s64 + -41;
	// 825BB5AC: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825BB5B0: 5525103A  slwi r5, r9, 2
	ctx.r[5].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 825BB5B4: 3BFF0007  addi r31, r31, 7
	ctx.r[31].s64 = ctx.r[31].s64 + 7;
	// 825BB5B8: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BB5BC: 88EA0001  lbz r7, 1(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BB5C0: 5506403E  rotlwi r6, r8, 8
	ctx.r[6].u64 = ((ctx.r[8].u32).rotate_left(8)) as u64;
	// 825BB5C4: 890A0002  lbz r8, 2(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BB5C8: 39490004  addi r10, r9, 4
	ctx.r[10].s64 = ctx.r[9].s64 + 4;
	// 825BB5CC: 7D273214  add r9, r7, r6
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 825BB5D0: 5547103A  slwi r7, r10, 2
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825BB5D4: 552A402E  slwi r10, r9, 8
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(8);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BB5D8: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 825BB5DC: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825BB5E0: F9410188  std r10, 0x188(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), ctx.r[10].u64 ) };
	// 825BB5E4: C9A10188  lfd f13, 0x188(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(392 as u32) ) };
	// 825BB5E8: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 825BB5EC: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825BB5F0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825BB5F4: 7C05D52E  stfsx f0, r5, r26
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[26].u32), tmp.u32) };
	// 825BB5F8: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BB5FC: 892B0001  lbz r9, 1(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BB600: 5548403E  rotlwi r8, r10, 8
	ctx.r[8].u64 = ((ctx.r[10].u32).rotate_left(8)) as u64;
	// 825BB604: 894B0002  lbz r10, 2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BB608: 7D694214  add r11, r9, r8
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 825BB60C: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BB610: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BB614: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825BB618: F9610160  std r11, 0x160(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), ctx.r[11].u64 ) };
	// 825BB61C: C9A10160  lfd f13, 0x160(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(352 as u32) ) };
	// 825BB620: 48000074  b 0x825bb694
	pc = 0x825BB694; continue 'dispatch;
            }
            0x825BB624 => {
    //   block [0x825BB624..0x825BB840)
	// 825BB624: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BB628: 396BFFDA  addi r11, r11, -0x26
	ctx.r[11].s64 = ctx.r[11].s64 + -38;
	// 825BB62C: 813D0014  lwz r9, 0x14(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BB630: C01B0010  lfs f0, 0x10(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BB634: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825BB638: 7D494830  slw r9, r10, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[10].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 825BB63C: 394B0002  addi r10, r11, 2
	ctx.r[10].s64 = ctx.r[11].s64 + 2;
	// 825BB640: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825BB644: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BB648: 5567103A  slwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825BB64C: 7D6AE82E  lwzx r11, r10, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 825BB650: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825BB654: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825BB658: F9610198  std r11, 0x198(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(408 as u32), ctx.r[11].u64 ) };
	// 825BB65C: C9A10198  lfd f13, 0x198(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(408 as u32) ) };
	// 825BB660: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 825BB664: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825BB668: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825BB66C: 7C08D52E  stfsx f0, r8, r26
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[26].u32), tmp.u32) };
	// 825BB670: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BB674: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825BB678: 813D0014  lwz r9, 0x14(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BB67C: 7D4AE82E  lwzx r10, r10, r29
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 825BB680: 7D6B4830  slw r11, r11, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[11].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 825BB684: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BB688: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825BB68C: F9610170  std r11, 0x170(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(368 as u32), ctx.r[11].u64 ) };
	// 825BB690: C9A10170  lfd f13, 0x170(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(368 as u32) ) };
	// 825BB694: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 825BB698: C01B0010  lfs f0, 0x10(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BB69C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825BB6A0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825BB6A4: 7C07D52E  stfsx f0, r7, r26
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[26].u32), tmp.u32) };
	// 825BB6A8: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BB6AC: 2B0B0026  cmplwi cr6, r11, 0x26
	ctx.cr[6].compare_u32(ctx.r[11].u32, 38 as u32, &mut ctx.xer);
	// 825BB6B0: 4198000C  blt cr6, 0x825bb6bc
	if ctx.cr[6].lt {
	pc = 0x825BB6BC; continue 'dispatch;
	}
	// 825BB6B4: 2B0B002B  cmplwi cr6, r11, 0x2b
	ctx.cr[6].compare_u32(ctx.r[11].u32, 43 as u32, &mut ctx.xer);
	// 825BB6B8: 4099F4C4  ble cr6, 0x825bab7c
	if !ctx.cr[6].gt {
	pc = 0x825BAB7C; continue 'dispatch;
	}
	// 825BB6BC: 3BDB0020  addi r30, r27, 0x20
	ctx.r[30].s64 = ctx.r[27].s64 + 32;
	pc = 0x825BB840; continue 'dispatch;
            }
            0x825BB840 => {
    //   block [0x825BB840..0x825BB850)
	// 825BB840: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BB844: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825BB848: 3BEB0002  addi r31, r11, 2
	ctx.r[31].s64 = ctx.r[11].s64 + 2;
	// 825BB84C: 4BFFF330  b 0x825bab7c
	pc = 0x825BAB7C; continue 'dispatch;
            }
            0x825BB850 => {
    //   block [0x825BB850..0x825BB86C)
	// 825BB850: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BB854: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BB858: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825BB85C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BB860: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825BB864: 3BEB0003  addi r31, r11, 3
	ctx.r[31].s64 = ctx.r[11].s64 + 3;
	// 825BB868: 4BFFF314  b 0x825bab7c
	pc = 0x825BAB7C; continue 'dispatch;
            }
            0x825BB86C => {
    //   block [0x825BB86C..0x825BB894)
	// 825BB86C: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BB870: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BB874: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825BB878: 895F0003  lbz r10, 3(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BB87C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825BB880: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BB884: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BB888: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825BB88C: 3BEB0004  addi r31, r11, 4
	ctx.r[31].s64 = ctx.r[11].s64 + 4;
	// 825BB890: 4BFFF2EC  b 0x825bab7c
	pc = 0x825BAB7C; continue 'dispatch;
            }
            0x825BB894 => {
    //   block [0x825BB894..0x825BB904)
	// 825BB894: 811D0014  lwz r8, 0x14(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BB898: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BB89C: 813D0008  lwz r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BB8A0: 7D4A4030  slw r10, r10, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 825BB8A4: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825BB8A8: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825BB8AC: 811D0014  lwz r8, 0x14(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BB8B0: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BB8B4: 813D000C  lwz r9, 0xc(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BB8B8: 7D4A4030  slw r10, r10, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 825BB8BC: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825BB8C0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 825BB8C4: 895F0003  lbz r10, 3(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BB8C8: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825BB8CC: 811D0014  lwz r8, 0x14(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BB8D0: 813D0010  lwz r9, 0x10(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BB8D4: 7D4A4030  slw r10, r10, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 825BB8D8: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825BB8DC: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825BB8E0: 815D0014  lwz r10, 0x14(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BB8E4: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BB8E8: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825BB8EC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BB8F0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825BB8F4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BB8F8: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 825BB8FC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825BB900: 4BFFF27C  b 0x825bab7c
	pc = 0x825BAB7C; continue 'dispatch;
            }
            0x825BB904 => {
    //   block [0x825BB904..0x825BB94C)
	// 825BB904: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825BB908: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BB90C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825BB910: 419A0028  beq cr6, 0x825bb938
	if ctx.cr[6].eq {
	pc = 0x825BB938; continue 'dispatch;
	}
	// 825BB914: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825BB918: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 825BB91C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825BB920: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BB924: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 825BB928: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BB92C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825BB930: 4200FFF0  bdnz 0x825bb920
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825BB920; continue 'dispatch;
	}
	// 825BB934: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 825BB938: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825BB93C: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 825BB940: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825BB944: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825BB948: 4BFFF234  b 0x825bab7c
	pc = 0x825BAB7C; continue 'dispatch;
            }
            0x825BB94C => {
    //   block [0x825BB94C..0x825BB9A0)
	// 825BB94C: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BB950: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 825BB954: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BB958: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825BB95C: 7F1D4840  cmplw cr6, r29, r9
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825BB960: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BB964: 419A0028  beq cr6, 0x825bb98c
	if ctx.cr[6].eq {
	pc = 0x825BB98C; continue 'dispatch;
	}
	// 825BB968: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825BB96C: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 825BB970: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825BB974: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BB978: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 825BB97C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BB980: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825BB984: 4200FFF0  bdnz 0x825bb974
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825BB974; continue 'dispatch;
	}
	// 825BB988: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 825BB98C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825BB990: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825BB994: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825BB998: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825BB99C: 4BFFF1E0  b 0x825bab7c
	pc = 0x825BAB7C; continue 'dispatch;
            }
            0x825BB9A0 => {
    //   block [0x825BB9A0..0x825BBA04)
	// 825BB9A0: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BB9A4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825BB9A8: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BB9AC: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825BB9B0: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BB9B4: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BB9B8: 7F1D3840  cmplw cr6, r29, r7
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825BB9BC: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825BB9C0: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BB9C4: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825BB9C8: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BB9CC: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BB9D0: 419A0028  beq cr6, 0x825bb9f8
	if ctx.cr[6].eq {
	pc = 0x825BB9F8; continue 'dispatch;
	}
	// 825BB9D4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825BB9D8: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 825BB9DC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825BB9E0: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BB9E4: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 825BB9E8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BB9EC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825BB9F0: 4200FFF0  bdnz 0x825bb9e0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825BB9E0; continue 'dispatch;
	}
	// 825BB9F4: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 825BB9F8: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 825BB9FC: 3BFF0005  addi r31, r31, 5
	ctx.r[31].s64 = ctx.r[31].s64 + 5;
	// 825BBA00: 4BFFF17C  b 0x825bab7c
	pc = 0x825BAB7C; continue 'dispatch;
            }
            0x825BBA04 => {
    //   block [0x825BBA04..0x825BBA20)
	// 825BBA04: 396BFFA0  addi r11, r11, -0x60
	ctx.r[11].s64 = ctx.r[11].s64 + -96;
	// 825BBA08: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BBA0C: 39210054  addi r9, r1, 0x54
	ctx.r[9].s64 = ctx.r[1].s64 + 84;
	// 825BBA10: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BBA14: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 825BBA18: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 825BBA1C: 48000068  b 0x825bba84
	pc = 0x825BBA84; continue 'dispatch;
            }
            0x825BBA20 => {
    //   block [0x825BBA20..0x825BBA48)
	// 825BBA20: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BBA24: 390BFF9C  addi r8, r11, -0x64
	ctx.r[8].s64 = ctx.r[11].s64 + -100;
	// 825BBA28: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BBA2C: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 825BBA30: 552B403E  rotlwi r11, r9, 8
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(8)) as u64;
	// 825BBA34: 5509103A  slwi r9, r8, 2
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825BBA38: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BBA3C: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825BBA40: 7D69392E  stwx r11, r9, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32), ctx.r[11].u32) };
	// 825BBA44: 48000040  b 0x825bba84
	pc = 0x825BBA84; continue 'dispatch;
            }
            0x825BBA48 => {
    //   block [0x825BBA48..0x825BBAC0)
	// 825BBA48: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BBA4C: 38EBFF98  addi r7, r11, -0x68
	ctx.r[7].s64 = ctx.r[11].s64 + -104;
	// 825BBA50: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BBA54: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 825BBA58: 554B403E  rotlwi r11, r10, 8
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(8)) as u64;
	// 825BBA5C: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BBA60: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BBA64: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825BBA68: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825BBA6C: 3BFF0005  addi r31, r31, 5
	ctx.r[31].s64 = ctx.r[31].s64 + 5;
	// 825BBA70: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BBA74: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825BBA78: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BBA7C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BBA80: 7D67312E  stwx r11, r7, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32), ctx.r[11].u32) };
	// 825BBA84: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825BBA88: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825BBA8C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825BBA90: 419A0028  beq cr6, 0x825bbab8
	if ctx.cr[6].eq {
	pc = 0x825BBAB8; continue 'dispatch;
	}
	// 825BBA94: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825BBA98: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 825BBA9C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825BBAA0: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BBAA4: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 825BBAA8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BBAAC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825BBAB0: 4200FFF0  bdnz 0x825bbaa0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825BBAA0; continue 'dispatch;
	}
	// 825BBAB4: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 825BBAB8: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825BBABC: 4BFFF0C0  b 0x825bab7c
	pc = 0x825BAB7C; continue 'dispatch;
            }
            0x825BBAC0 => {
    //   block [0x825BBAC0..0x825BBB18)
	// 825BBAC0: 38A00200  li r5, 0x200
	ctx.r[5].s64 = 512;
	// 825BBAC4: 38810250  addi r4, r1, 0x250
	ctx.r[4].s64 = ctx.r[1].s64 + 592;
	// 825BBAC8: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 825BBACC: 4BEAD32D  bl 0x82468df8
	ctx.lr = 0x825BBAD0;
	sub_82468DF8(ctx, base);
	// 825BBAD0: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 825BBAD4: 7DC47378  mr r4, r14
	ctx.r[4].u64 = ctx.r[14].u64;
	// 825BBAD8: 4BEAC7C9  bl 0x824682a0
	ctx.lr = 0x825BBADC;
	sub_824682A0(ctx, base);
	// 825BBADC: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 825BBAE0: 3CA01298  lis r5, 0x1298
	ctx.r[5].s64 = 311951360;
	// 825BBAE4: 3900012D  li r8, 0x12d
	ctx.r[8].s64 = 301;
	// 825BBAE8: 7DE77B78  mr r7, r15
	ctx.r[7].u64 = ctx.r[15].u64;
	// 825BBAEC: 38C10250  addi r6, r1, 0x250
	ctx.r[6].s64 = ctx.r[1].s64 + 592;
	// 825BBAF0: 806B9190  lwz r3, -0x6e70(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28272 as u32) ) } as u64;
	// 825BBAF4: 60A5FEDD  ori r5, r5, 0xfedd
	ctx.r[5].u64 = ctx.r[5].u64 | 65245;
	// 825BBAF8: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825BBAFC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BBB00: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BBB04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BBB08: 4E800421  bctrl
	ctx.lr = 0x825BBB0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BBB0C: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 825BBB10: 4BEACDD1  bl 0x824688e0
	ctx.lr = 0x825BBB14;
	sub_824688E0(ctx, base);
	// 825BBB14: 4BFFF068  b 0x825bab7c
	pc = 0x825BAB7C; continue 'dispatch;
            }
            0x825BBB18 => {
    //   block [0x825BBB18..0x825BBB20)
	// 825BBB18: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BBB1C: 48000068  b 0x825bbb84
	pc = 0x825BBB84; continue 'dispatch;
            }
            0x825BBB20 => {
    //   block [0x825BBB20..0x825BBB34)
	// 825BBB20: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BBB24: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BBB28: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825BBB2C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BBB30: 48000054  b 0x825bbb84
	pc = 0x825BBB84; continue 'dispatch;
            }
            0x825BBB34 => {
    //   block [0x825BBB34..0x825BBB54)
	// 825BBB34: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BBB38: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BBB3C: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825BBB40: 895F0003  lbz r10, 3(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BBB44: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825BBB48: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BBB4C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BBB50: 48000034  b 0x825bbb84
	pc = 0x825BBB84; continue 'dispatch;
            }
            0x825BBB54 => {
    //   block [0x825BBB54..0x825BBB80)
	// 825BBB54: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BBB58: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BBB5C: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825BBB60: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BBB64: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BBB68: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825BBB6C: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BBB70: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825BBB74: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BBB78: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BBB7C: 48000008  b 0x825bbb84
	pc = 0x825BBB84; continue 'dispatch;
            }
            0x825BBB80 => {
    //   block [0x825BBB80..0x825BBBC8)
	// 825BBB80: 396BFFD0  addi r11, r11, -0x30
	ctx.r[11].s64 = ctx.r[11].s64 + -48;
	// 825BBB84: 83FB0000  lwz r31, 0(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BBB88: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BBB8C: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825BBB90: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BBB94: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BBB98: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825BBB9C: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825BBBA0: 409A0010  bne cr6, 0x825bbbb0
	if !ctx.cr[6].eq {
	pc = 0x825BBBB0; continue 'dispatch;
	}
	// 825BBBA4: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 825BBBA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BBBAC: 4BEB27A5  bl 0x8246e350
	ctx.lr = 0x825BBBB0;
	sub_8246E350(ctx, base);
	// 825BBBB0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BBBB4: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BBBB8: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BBBBC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825BBBC0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825BBBC4: 7FCA492E  stwx r30, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[30].u32) };
	pc = 0x825BBBC8; continue 'dispatch;
            }
            0x825BBBC8 => {
    //   block [0x825BBBC8..0x825BBBD8)
	// 825BBBC8: 38210510  addi r1, r1, 0x510
	ctx.r[1].s64 = ctx.r[1].s64 + 1296;
	// 825BBBCC: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 825BBBD0: 4BF7A465  bl 0x82536034
	ctx.lr = 0x825BBBD4;
	sub_82535FFC(ctx, base);
	// 825BBBD4: 4BF794FC  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BBBD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BBBD8 size=3460
    let mut pc: u32 = 0x825BBBD8;
    'dispatch: loop {
        match pc {
            0x825BBBD8 => {
    //   block [0x825BBBD8..0x825BBDEC)
	// 825BBBD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BBBDC: 4BF794B5  bl 0x82535090
	ctx.lr = 0x825BBBE0;
	sub_82535080(ctx, base);
	// 825BBBE0: 9421FC40  stwu r1, -0x3c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-960 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BBBE4: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 825BBBE8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825BBBEC: 3A8B9190  addi r20, r11, -0x6e70
	ctx.r[20].s64 = ctx.r[11].s64 + -28272;
	// 825BBBF0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825BBBF4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825BBBF8: 3AAB0E30  addi r21, r11, 0xe30
	ctx.r[21].s64 = ctx.r[11].s64 + 3632;
	// 825BBBFC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825BBC00: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825BBC04: 3A6BA2D8  addi r19, r11, -0x5d28
	ctx.r[19].s64 = ctx.r[11].s64 + -23848;
	// 825BBC08: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825BBC0C: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 825BBC10: 3A4BA1D8  addi r18, r11, -0x5e28
	ctx.r[18].s64 = ctx.r[11].s64 + -24104;
	// 825BBC14: 3AC00010  li r22, 0x10
	ctx.r[22].s64 = 16;
	// 825BBC18: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BBC1C: 2B0B006B  cmplwi cr6, r11, 0x6b
	ctx.cr[6].compare_u32(ctx.r[11].u32, 107 as u32, &mut ctx.xer);
	// 825BBC20: 41990C30  bgt cr6, 0x825bc850
	if ctx.cr[6].gt {
	pc = 0x825BC850; continue 'dispatch;
	}
	// 825BBC24: 3D80825C  lis r12, -0x7da4
	ctx.r[12].s64 = -2107899904;
	// 825BBC28: 398CBC3C  addi r12, r12, -0x43c4
	ctx.r[12].s64 = ctx.r[12].s64 + -17348;
	// 825BBC2C: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 825BBC30: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 825BBC34: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 825BBC38: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x825BC954; continue 'dispatch;
		},
		1 => {
	pc = 0x825BC624; continue 'dispatch;
		},
		2 => {
	pc = 0x825BC624; continue 'dispatch;
		},
		3 => {
	pc = 0x825BC624; continue 'dispatch;
		},
		4 => {
	pc = 0x825BC624; continue 'dispatch;
		},
		5 => {
	pc = 0x825BC5D0; continue 'dispatch;
		},
		6 => {
	pc = 0x825BC5E0; continue 'dispatch;
		},
		7 => {
	pc = 0x825BC5FC; continue 'dispatch;
		},
		8 => {
	pc = 0x825BC850; continue 'dispatch;
		},
		9 => {
	pc = 0x825BC694; continue 'dispatch;
		},
		10 => {
	pc = 0x825BC6DC; continue 'dispatch;
		},
		11 => {
	pc = 0x825BC730; continue 'dispatch;
		},
		12 => {
	pc = 0x825BC850; continue 'dispatch;
		},
		13 => {
	pc = 0x825BC850; continue 'dispatch;
		},
		14 => {
	pc = 0x825BC850; continue 'dispatch;
		},
		15 => {
	pc = 0x825BC850; continue 'dispatch;
		},
		16 => {
	pc = 0x825BBE28; continue 'dispatch;
		},
		17 => {
	pc = 0x825BBE28; continue 'dispatch;
		},
		18 => {
	pc = 0x825BBE28; continue 'dispatch;
		},
		19 => {
	pc = 0x825BBDEC; continue 'dispatch;
		},
		20 => {
	pc = 0x825BBDEC; continue 'dispatch;
		},
		21 => {
	pc = 0x825BBDEC; continue 'dispatch;
		},
		22 => {
	pc = 0x825BBDEC; continue 'dispatch;
		},
		23 => {
	pc = 0x825BBDEC; continue 'dispatch;
		},
		24 => {
	pc = 0x825BBDEC; continue 'dispatch;
		},
		25 => {
	pc = 0x825BBDEC; continue 'dispatch;
		},
		26 => {
	pc = 0x825BBDEC; continue 'dispatch;
		},
		27 => {
	pc = 0x825BBDEC; continue 'dispatch;
		},
		28 => {
	pc = 0x825BBDEC; continue 'dispatch;
		},
		29 => {
	pc = 0x825BC850; continue 'dispatch;
		},
		30 => {
	pc = 0x825BC850; continue 'dispatch;
		},
		31 => {
	pc = 0x825BC850; continue 'dispatch;
		},
		32 => {
	pc = 0x825BBED8; continue 'dispatch;
		},
		33 => {
	pc = 0x825BBED8; continue 'dispatch;
		},
		34 => {
	pc = 0x825BBED8; continue 'dispatch;
		},
		35 => {
	pc = 0x825BBF7C; continue 'dispatch;
		},
		36 => {
	pc = 0x825BBF7C; continue 'dispatch;
		},
		37 => {
	pc = 0x825BBF7C; continue 'dispatch;
		},
		38 => {
	pc = 0x825BC4BC; continue 'dispatch;
		},
		39 => {
	pc = 0x825BC4BC; continue 'dispatch;
		},
		40 => {
	pc = 0x825BC4BC; continue 'dispatch;
		},
		41 => {
	pc = 0x825BC438; continue 'dispatch;
		},
		42 => {
	pc = 0x825BC438; continue 'dispatch;
		},
		43 => {
	pc = 0x825BC438; continue 'dispatch;
		},
		44 => {
	pc = 0x825BC850; continue 'dispatch;
		},
		45 => {
	pc = 0x825BC850; continue 'dispatch;
		},
		46 => {
	pc = 0x825BC850; continue 'dispatch;
		},
		47 => {
	pc = 0x825BC850; continue 'dispatch;
		},
		48 => {
	pc = 0x825BC90C; continue 'dispatch;
		},
		49 => {
	pc = 0x825BC90C; continue 'dispatch;
		},
		50 => {
	pc = 0x825BC90C; continue 'dispatch;
		},
		51 => {
	pc = 0x825BC90C; continue 'dispatch;
		},
		52 => {
	pc = 0x825BC90C; continue 'dispatch;
		},
		53 => {
	pc = 0x825BC90C; continue 'dispatch;
		},
		54 => {
	pc = 0x825BC90C; continue 'dispatch;
		},
		55 => {
	pc = 0x825BC90C; continue 'dispatch;
		},
		56 => {
	pc = 0x825BC90C; continue 'dispatch;
		},
		57 => {
	pc = 0x825BC90C; continue 'dispatch;
		},
		58 => {
	pc = 0x825BC90C; continue 'dispatch;
		},
		59 => {
	pc = 0x825BC90C; continue 'dispatch;
		},
		60 => {
	pc = 0x825BC90C; continue 'dispatch;
		},
		61 => {
	pc = 0x825BC90C; continue 'dispatch;
		},
		62 => {
	pc = 0x825BC90C; continue 'dispatch;
		},
		63 => {
	pc = 0x825BC90C; continue 'dispatch;
		},
		64 => {
	pc = 0x825BC90C; continue 'dispatch;
		},
		65 => {
	pc = 0x825BC90C; continue 'dispatch;
		},
		66 => {
	pc = 0x825BC90C; continue 'dispatch;
		},
		67 => {
	pc = 0x825BC90C; continue 'dispatch;
		},
		68 => {
	pc = 0x825BC90C; continue 'dispatch;
		},
		69 => {
	pc = 0x825BC90C; continue 'dispatch;
		},
		70 => {
	pc = 0x825BC90C; continue 'dispatch;
		},
		71 => {
	pc = 0x825BC90C; continue 'dispatch;
		},
		72 => {
	pc = 0x825BC90C; continue 'dispatch;
		},
		73 => {
	pc = 0x825BC90C; continue 'dispatch;
		},
		74 => {
	pc = 0x825BC90C; continue 'dispatch;
		},
		75 => {
	pc = 0x825BC90C; continue 'dispatch;
		},
		76 => {
	pc = 0x825BC90C; continue 'dispatch;
		},
		77 => {
	pc = 0x825BC90C; continue 'dispatch;
		},
		78 => {
	pc = 0x825BC90C; continue 'dispatch;
		},
		79 => {
	pc = 0x825BC90C; continue 'dispatch;
		},
		80 => {
	pc = 0x825BC8A4; continue 'dispatch;
		},
		81 => {
	pc = 0x825BC8AC; continue 'dispatch;
		},
		82 => {
	pc = 0x825BC8C0; continue 'dispatch;
		},
		83 => {
	pc = 0x825BC8E0; continue 'dispatch;
		},
		84 => {
	pc = 0x825BC850; continue 'dispatch;
		},
		85 => {
	pc = 0x825BC850; continue 'dispatch;
		},
		86 => {
	pc = 0x825BC850; continue 'dispatch;
		},
		87 => {
	pc = 0x825BC850; continue 'dispatch;
		},
		88 => {
	pc = 0x825BC850; continue 'dispatch;
		},
		89 => {
	pc = 0x825BC850; continue 'dispatch;
		},
		90 => {
	pc = 0x825BC850; continue 'dispatch;
		},
		91 => {
	pc = 0x825BC850; continue 'dispatch;
		},
		92 => {
	pc = 0x825BC850; continue 'dispatch;
		},
		93 => {
	pc = 0x825BC850; continue 'dispatch;
		},
		94 => {
	pc = 0x825BC850; continue 'dispatch;
		},
		95 => {
	pc = 0x825BC850; continue 'dispatch;
		},
		96 => {
	pc = 0x825BC794; continue 'dispatch;
		},
		97 => {
	pc = 0x825BC794; continue 'dispatch;
		},
		98 => {
	pc = 0x825BC794; continue 'dispatch;
		},
		99 => {
	pc = 0x825BC794; continue 'dispatch;
		},
		100 => {
	pc = 0x825BC7B0; continue 'dispatch;
		},
		101 => {
	pc = 0x825BC7B0; continue 'dispatch;
		},
		102 => {
	pc = 0x825BC7B0; continue 'dispatch;
		},
		103 => {
	pc = 0x825BC7B0; continue 'dispatch;
		},
		104 => {
	pc = 0x825BC7D8; continue 'dispatch;
		},
		105 => {
	pc = 0x825BC7D8; continue 'dispatch;
		},
		106 => {
	pc = 0x825BC7D8; continue 'dispatch;
		},
		107 => {
	pc = 0x825BC7D8; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 825BBC3C: 825BC954  lwz r18, -0x36ac(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-13996 as u32) ) } as u64;
	// 825BBC40: 825BC624  lwz r18, -0x39dc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14812 as u32) ) } as u64;
	// 825BBC44: 825BC624  lwz r18, -0x39dc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14812 as u32) ) } as u64;
	// 825BBC48: 825BC624  lwz r18, -0x39dc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14812 as u32) ) } as u64;
	// 825BBC4C: 825BC624  lwz r18, -0x39dc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14812 as u32) ) } as u64;
	// 825BBC50: 825BC5D0  lwz r18, -0x3a30(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14896 as u32) ) } as u64;
	// 825BBC54: 825BC5E0  lwz r18, -0x3a20(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14880 as u32) ) } as u64;
	// 825BBC58: 825BC5FC  lwz r18, -0x3a04(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14852 as u32) ) } as u64;
	// 825BBC5C: 825BC850  lwz r18, -0x37b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14256 as u32) ) } as u64;
	// 825BBC60: 825BC694  lwz r18, -0x396c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14700 as u32) ) } as u64;
	// 825BBC64: 825BC6DC  lwz r18, -0x3924(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14628 as u32) ) } as u64;
	// 825BBC68: 825BC730  lwz r18, -0x38d0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14544 as u32) ) } as u64;
	// 825BBC6C: 825BC850  lwz r18, -0x37b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14256 as u32) ) } as u64;
	// 825BBC70: 825BC850  lwz r18, -0x37b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14256 as u32) ) } as u64;
	// 825BBC74: 825BC850  lwz r18, -0x37b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14256 as u32) ) } as u64;
	// 825BBC78: 825BC850  lwz r18, -0x37b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14256 as u32) ) } as u64;
	// 825BBC7C: 825BBE28  lwz r18, -0x41d8(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-16856 as u32) ) } as u64;
	// 825BBC80: 825BBE28  lwz r18, -0x41d8(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-16856 as u32) ) } as u64;
	// 825BBC84: 825BBE28  lwz r18, -0x41d8(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-16856 as u32) ) } as u64;
	// 825BBC88: 825BBDEC  lwz r18, -0x4214(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-16916 as u32) ) } as u64;
	// 825BBC8C: 825BBDEC  lwz r18, -0x4214(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-16916 as u32) ) } as u64;
	// 825BBC90: 825BBDEC  lwz r18, -0x4214(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-16916 as u32) ) } as u64;
	// 825BBC94: 825BBDEC  lwz r18, -0x4214(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-16916 as u32) ) } as u64;
	// 825BBC98: 825BBDEC  lwz r18, -0x4214(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-16916 as u32) ) } as u64;
	// 825BBC9C: 825BBDEC  lwz r18, -0x4214(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-16916 as u32) ) } as u64;
	// 825BBCA0: 825BBDEC  lwz r18, -0x4214(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-16916 as u32) ) } as u64;
	// 825BBCA4: 825BBDEC  lwz r18, -0x4214(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-16916 as u32) ) } as u64;
	// 825BBCA8: 825BBDEC  lwz r18, -0x4214(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-16916 as u32) ) } as u64;
	// 825BBCAC: 825BBDEC  lwz r18, -0x4214(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-16916 as u32) ) } as u64;
	// 825BBCB0: 825BC850  lwz r18, -0x37b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14256 as u32) ) } as u64;
	// 825BBCB4: 825BC850  lwz r18, -0x37b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14256 as u32) ) } as u64;
	// 825BBCB8: 825BC850  lwz r18, -0x37b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14256 as u32) ) } as u64;
	// 825BBCBC: 825BBED8  lwz r18, -0x4128(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-16680 as u32) ) } as u64;
	// 825BBCC0: 825BBED8  lwz r18, -0x4128(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-16680 as u32) ) } as u64;
	// 825BBCC4: 825BBED8  lwz r18, -0x4128(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-16680 as u32) ) } as u64;
	// 825BBCC8: 825BBF7C  lwz r18, -0x4084(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-16516 as u32) ) } as u64;
	// 825BBCCC: 825BBF7C  lwz r18, -0x4084(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-16516 as u32) ) } as u64;
	// 825BBCD0: 825BBF7C  lwz r18, -0x4084(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-16516 as u32) ) } as u64;
	// 825BBCD4: 825BC4BC  lwz r18, -0x3b44(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-15172 as u32) ) } as u64;
	// 825BBCD8: 825BC4BC  lwz r18, -0x3b44(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-15172 as u32) ) } as u64;
	// 825BBCDC: 825BC4BC  lwz r18, -0x3b44(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-15172 as u32) ) } as u64;
	// 825BBCE0: 825BC438  lwz r18, -0x3bc8(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-15304 as u32) ) } as u64;
	// 825BBCE4: 825BC438  lwz r18, -0x3bc8(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-15304 as u32) ) } as u64;
	// 825BBCE8: 825BC438  lwz r18, -0x3bc8(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-15304 as u32) ) } as u64;
	// 825BBCEC: 825BC850  lwz r18, -0x37b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14256 as u32) ) } as u64;
	// 825BBCF0: 825BC850  lwz r18, -0x37b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14256 as u32) ) } as u64;
	// 825BBCF4: 825BC850  lwz r18, -0x37b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14256 as u32) ) } as u64;
	// 825BBCF8: 825BC850  lwz r18, -0x37b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14256 as u32) ) } as u64;
	// 825BBCFC: 825BC90C  lwz r18, -0x36f4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14068 as u32) ) } as u64;
	// 825BBD00: 825BC90C  lwz r18, -0x36f4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14068 as u32) ) } as u64;
	// 825BBD04: 825BC90C  lwz r18, -0x36f4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14068 as u32) ) } as u64;
	// 825BBD08: 825BC90C  lwz r18, -0x36f4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14068 as u32) ) } as u64;
	// 825BBD0C: 825BC90C  lwz r18, -0x36f4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14068 as u32) ) } as u64;
	// 825BBD10: 825BC90C  lwz r18, -0x36f4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14068 as u32) ) } as u64;
	// 825BBD14: 825BC90C  lwz r18, -0x36f4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14068 as u32) ) } as u64;
	// 825BBD18: 825BC90C  lwz r18, -0x36f4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14068 as u32) ) } as u64;
	// 825BBD1C: 825BC90C  lwz r18, -0x36f4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14068 as u32) ) } as u64;
	// 825BBD20: 825BC90C  lwz r18, -0x36f4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14068 as u32) ) } as u64;
	// 825BBD24: 825BC90C  lwz r18, -0x36f4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14068 as u32) ) } as u64;
	// 825BBD28: 825BC90C  lwz r18, -0x36f4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14068 as u32) ) } as u64;
	// 825BBD2C: 825BC90C  lwz r18, -0x36f4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14068 as u32) ) } as u64;
	// 825BBD30: 825BC90C  lwz r18, -0x36f4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14068 as u32) ) } as u64;
	// 825BBD34: 825BC90C  lwz r18, -0x36f4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14068 as u32) ) } as u64;
	// 825BBD38: 825BC90C  lwz r18, -0x36f4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14068 as u32) ) } as u64;
	// 825BBD3C: 825BC90C  lwz r18, -0x36f4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14068 as u32) ) } as u64;
	// 825BBD40: 825BC90C  lwz r18, -0x36f4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14068 as u32) ) } as u64;
	// 825BBD44: 825BC90C  lwz r18, -0x36f4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14068 as u32) ) } as u64;
	// 825BBD48: 825BC90C  lwz r18, -0x36f4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14068 as u32) ) } as u64;
	// 825BBD4C: 825BC90C  lwz r18, -0x36f4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14068 as u32) ) } as u64;
	// 825BBD50: 825BC90C  lwz r18, -0x36f4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14068 as u32) ) } as u64;
	// 825BBD54: 825BC90C  lwz r18, -0x36f4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14068 as u32) ) } as u64;
	// 825BBD58: 825BC90C  lwz r18, -0x36f4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14068 as u32) ) } as u64;
	// 825BBD5C: 825BC90C  lwz r18, -0x36f4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14068 as u32) ) } as u64;
	// 825BBD60: 825BC90C  lwz r18, -0x36f4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14068 as u32) ) } as u64;
	// 825BBD64: 825BC90C  lwz r18, -0x36f4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14068 as u32) ) } as u64;
	// 825BBD68: 825BC90C  lwz r18, -0x36f4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14068 as u32) ) } as u64;
	// 825BBD6C: 825BC90C  lwz r18, -0x36f4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14068 as u32) ) } as u64;
	// 825BBD70: 825BC90C  lwz r18, -0x36f4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14068 as u32) ) } as u64;
	// 825BBD74: 825BC90C  lwz r18, -0x36f4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14068 as u32) ) } as u64;
	// 825BBD78: 825BC90C  lwz r18, -0x36f4(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14068 as u32) ) } as u64;
	// 825BBD7C: 825BC8A4  lwz r18, -0x375c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14172 as u32) ) } as u64;
	// 825BBD80: 825BC8AC  lwz r18, -0x3754(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14164 as u32) ) } as u64;
	// 825BBD84: 825BC8C0  lwz r18, -0x3740(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14144 as u32) ) } as u64;
	// 825BBD88: 825BC8E0  lwz r18, -0x3720(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14112 as u32) ) } as u64;
	// 825BBD8C: 825BC850  lwz r18, -0x37b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14256 as u32) ) } as u64;
	// 825BBD90: 825BC850  lwz r18, -0x37b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14256 as u32) ) } as u64;
	// 825BBD94: 825BC850  lwz r18, -0x37b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14256 as u32) ) } as u64;
	// 825BBD98: 825BC850  lwz r18, -0x37b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14256 as u32) ) } as u64;
	// 825BBD9C: 825BC850  lwz r18, -0x37b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14256 as u32) ) } as u64;
	// 825BBDA0: 825BC850  lwz r18, -0x37b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14256 as u32) ) } as u64;
	// 825BBDA4: 825BC850  lwz r18, -0x37b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14256 as u32) ) } as u64;
	// 825BBDA8: 825BC850  lwz r18, -0x37b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14256 as u32) ) } as u64;
	// 825BBDAC: 825BC850  lwz r18, -0x37b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14256 as u32) ) } as u64;
	// 825BBDB0: 825BC850  lwz r18, -0x37b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14256 as u32) ) } as u64;
	// 825BBDB4: 825BC850  lwz r18, -0x37b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14256 as u32) ) } as u64;
	// 825BBDB8: 825BC850  lwz r18, -0x37b0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14256 as u32) ) } as u64;
	// 825BBDBC: 825BC794  lwz r18, -0x386c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14444 as u32) ) } as u64;
	// 825BBDC0: 825BC794  lwz r18, -0x386c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14444 as u32) ) } as u64;
	// 825BBDC4: 825BC794  lwz r18, -0x386c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14444 as u32) ) } as u64;
	// 825BBDC8: 825BC794  lwz r18, -0x386c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14444 as u32) ) } as u64;
	// 825BBDCC: 825BC7B0  lwz r18, -0x3850(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14416 as u32) ) } as u64;
	// 825BBDD0: 825BC7B0  lwz r18, -0x3850(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14416 as u32) ) } as u64;
	// 825BBDD4: 825BC7B0  lwz r18, -0x3850(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14416 as u32) ) } as u64;
	// 825BBDD8: 825BC7B0  lwz r18, -0x3850(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14416 as u32) ) } as u64;
	// 825BBDDC: 825BC7D8  lwz r18, -0x3828(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14376 as u32) ) } as u64;
	// 825BBDE0: 825BC7D8  lwz r18, -0x3828(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14376 as u32) ) } as u64;
	// 825BBDE4: 825BC7D8  lwz r18, -0x3828(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14376 as u32) ) } as u64;
	// 825BBDE8: 825BC7D8  lwz r18, -0x3828(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-14376 as u32) ) } as u64;
            }
            0x825BBDEC => {
    //   block [0x825BBDEC..0x825BBE28)
	// 825BBDEC: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 825BBDF0: 8BBF0003  lbz r29, 3(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	pc = 0x825BBE28; continue 'dispatch;
            }
            0x825BBE28 => {
    //   block [0x825BBE28..0x825BBED8)
	// 825BBE28: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	pc = 0x825BBED8; continue 'dispatch;
            }
            0x825BBED8 => {
    //   block [0x825BBED8..0x825BBF7C)
	// 825BBED8: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	pc = 0x825BBF7C; continue 'dispatch;
            }
            0x825BBF7C => {
    //   block [0x825BBF7C..0x825BC438)
	// 825BBF7C: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	pc = 0x825BC438; continue 'dispatch;
            }
            0x825BC438 => {
    //   block [0x825BC438..0x825BC4BC)
	// 825BC438: 395F0001  addi r10, r31, 1
	ctx.r[10].s64 = ctx.r[31].s64 + 1;
	// 825BC43C: C01B0010  lfs f0, 0x10(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BC440: 392BFFD7  addi r9, r11, -0x29
	ctx.r[9].s64 = ctx.r[11].s64 + -41;
	// 825BC444: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825BC448: 5525103A  slwi r5, r9, 2
	ctx.r[5].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 825BC44C: 3BFF0007  addi r31, r31, 7
	ctx.r[31].s64 = ctx.r[31].s64 + 7;
	// 825BC450: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC454: 88CA0001  lbz r6, 1(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BC458: 5507403E  rotlwi r7, r8, 8
	ctx.r[7].u64 = ((ctx.r[8].u32).rotate_left(8)) as u64;
	// 825BC45C: 890A0002  lbz r8, 2(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BC460: 39490004  addi r10, r9, 4
	ctx.r[10].s64 = ctx.r[9].s64 + 4;
	// 825BC464: 7D273214  add r9, r7, r6
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 825BC468: 5547103A  slwi r7, r10, 2
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825BC46C: 552A402E  slwi r10, r9, 8
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(8);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BC470: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 825BC474: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825BC478: F94100C8  std r10, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[10].u64 ) };
	// 825BC47C: C9A100C8  lfd f13, 0xc8(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) };
	// 825BC480: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 825BC484: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825BC488: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825BC48C: 7C05D52E  stfsx f0, r5, r26
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[26].u32), tmp.u32) };
	// 825BC490: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC494: 890B0001  lbz r8, 1(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BC498: 5549403E  rotlwi r9, r10, 8
	ctx.r[9].u64 = ((ctx.r[10].u32).rotate_left(8)) as u64;
	// 825BC49C: 894B0002  lbz r10, 2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BC4A0: 7D694214  add r11, r9, r8
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 825BC4A4: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BC4A8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BC4AC: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825BC4B0: F96100D8  std r11, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[11].u64 ) };
	// 825BC4B4: C9A100D8  lfd f13, 0xd8(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) };
	// 825BC4B8: 48000074  b 0x825bc52c
	pc = 0x825BC52C; continue 'dispatch;
            }
            0x825BC4BC => {
    //   block [0x825BC4BC..0x825BC5D0)
	// 825BC4BC: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BC4C0: 396BFFDA  addi r11, r11, -0x26
	ctx.r[11].s64 = ctx.r[11].s64 + -38;
	// 825BC4C4: 813E0014  lwz r9, 0x14(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BC4C8: C01B0010  lfs f0, 0x10(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BC4CC: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825BC4D0: 7D494830  slw r9, r10, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[10].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 825BC4D4: 394B0002  addi r10, r11, 2
	ctx.r[10].s64 = ctx.r[11].s64 + 2;
	// 825BC4D8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825BC4DC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BC4E0: 5567103A  slwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825BC4E4: 7D6AF02E  lwzx r11, r10, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825BC4E8: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825BC4EC: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825BC4F0: F96100E8  std r11, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[11].u64 ) };
	// 825BC4F4: C9A100E8  lfd f13, 0xe8(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(232 as u32) ) };
	// 825BC4F8: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 825BC4FC: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825BC500: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825BC504: 7C08D52E  stfsx f0, r8, r26
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[26].u32), tmp.u32) };
	// 825BC508: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BC50C: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825BC510: 813E0014  lwz r9, 0x14(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BC514: 7D4AF02E  lwzx r10, r10, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825BC518: 7D6B4830  slw r11, r11, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[11].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 825BC51C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BC520: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825BC524: F96100F8  std r11, 0xf8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[11].u64 ) };
	// 825BC528: C9A100F8  lfd f13, 0xf8(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(248 as u32) ) };
	// 825BC52C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 825BC530: C01B0010  lfs f0, 0x10(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BC534: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825BC538: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825BC53C: 7C07D52E  stfsx f0, r7, r26
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[26].u32), tmp.u32) };
	// 825BC540: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC544: 2B0B0026  cmplwi cr6, r11, 0x26
	ctx.cr[6].compare_u32(ctx.r[11].u32, 38 as u32, &mut ctx.xer);
	// 825BC548: 4198000C  blt cr6, 0x825bc554
	if ctx.cr[6].lt {
	pc = 0x825BC554; continue 'dispatch;
	}
	// 825BC54C: 2B0B002B  cmplwi cr6, r11, 0x2b
	ctx.cr[6].compare_u32(ctx.r[11].u32, 43 as u32, &mut ctx.xer);
	// 825BC550: 4099F6C8  ble cr6, 0x825bbc18
	if !ctx.cr[6].gt {
	pc = 0x825BBC18; continue 'dispatch;
	}
	pc = 0x825BC5D0; continue 'dispatch;
            }
            0x825BC5D0 => {
    //   block [0x825BC5D0..0x825BC5E0)
	// 825BC5D0: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BC5D4: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825BC5D8: 3BEB0002  addi r31, r11, 2
	ctx.r[31].s64 = ctx.r[11].s64 + 2;
	// 825BC5DC: 4BFFF63C  b 0x825bbc18
	pc = 0x825BBC18; continue 'dispatch;
            }
            0x825BC5E0 => {
    //   block [0x825BC5E0..0x825BC5FC)
	// 825BC5E0: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BC5E4: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BC5E8: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825BC5EC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BC5F0: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825BC5F4: 3BEB0003  addi r31, r11, 3
	ctx.r[31].s64 = ctx.r[11].s64 + 3;
	// 825BC5F8: 4BFFF620  b 0x825bbc18
	pc = 0x825BBC18; continue 'dispatch;
            }
            0x825BC5FC => {
    //   block [0x825BC5FC..0x825BC624)
	// 825BC5FC: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BC600: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BC604: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825BC608: 895F0003  lbz r10, 3(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BC60C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825BC610: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BC614: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BC618: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825BC61C: 3BEB0004  addi r31, r11, 4
	ctx.r[31].s64 = ctx.r[11].s64 + 4;
	// 825BC620: 4BFFF5F8  b 0x825bbc18
	pc = 0x825BBC18; continue 'dispatch;
            }
            0x825BC624 => {
    //   block [0x825BC624..0x825BC694)
	// 825BC624: 811E0014  lwz r8, 0x14(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BC628: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BC62C: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BC630: 7D4A4030  slw r10, r10, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 825BC634: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825BC638: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825BC63C: 811E0014  lwz r8, 0x14(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BC640: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BC644: 813E000C  lwz r9, 0xc(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BC648: 7D4A4030  slw r10, r10, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 825BC64C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825BC650: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 825BC654: 895F0003  lbz r10, 3(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BC658: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825BC65C: 811E0014  lwz r8, 0x14(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BC660: 813E0010  lwz r9, 0x10(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BC664: 7D4A4030  slw r10, r10, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 825BC668: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825BC66C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825BC670: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BC674: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BC678: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825BC67C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BC680: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825BC684: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC688: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825BC68C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825BC690: 4BFFF588  b 0x825bbc18
	pc = 0x825BBC18; continue 'dispatch;
            }
            0x825BC694 => {
    //   block [0x825BC694..0x825BC6DC)
	// 825BC694: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825BC698: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BC69C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825BC6A0: 419A0028  beq cr6, 0x825bc6c8
	if ctx.cr[6].eq {
	pc = 0x825BC6C8; continue 'dispatch;
	}
	// 825BC6A4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825BC6A8: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 825BC6AC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825BC6B0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC6B4: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 825BC6B8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BC6BC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825BC6C0: 4200FFF0  bdnz 0x825bc6b0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825BC6B0; continue 'dispatch;
	}
	// 825BC6C4: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825BC6C8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825BC6CC: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 825BC6D0: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825BC6D4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825BC6D8: 4BFFF540  b 0x825bbc18
	pc = 0x825BBC18; continue 'dispatch;
            }
            0x825BC6DC => {
    //   block [0x825BC6DC..0x825BC730)
	// 825BC6DC: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BC6E0: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 825BC6E4: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BC6E8: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825BC6EC: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825BC6F0: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BC6F4: 419A0028  beq cr6, 0x825bc71c
	if ctx.cr[6].eq {
	pc = 0x825BC71C; continue 'dispatch;
	}
	// 825BC6F8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825BC6FC: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 825BC700: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825BC704: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC708: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 825BC70C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BC710: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825BC714: 4200FFF0  bdnz 0x825bc704
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825BC704; continue 'dispatch;
	}
	// 825BC718: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825BC71C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825BC720: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825BC724: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825BC728: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825BC72C: 4BFFF4EC  b 0x825bbc18
	pc = 0x825BBC18; continue 'dispatch;
            }
            0x825BC730 => {
    //   block [0x825BC730..0x825BC794)
	// 825BC730: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BC734: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825BC738: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BC73C: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825BC740: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BC744: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BC748: 7F1E3840  cmplw cr6, r30, r7
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825BC74C: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825BC750: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BC754: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825BC758: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BC75C: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BC760: 419A0028  beq cr6, 0x825bc788
	if ctx.cr[6].eq {
	pc = 0x825BC788; continue 'dispatch;
	}
	// 825BC764: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825BC768: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 825BC76C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825BC770: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC774: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 825BC778: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BC77C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825BC780: 4200FFF0  bdnz 0x825bc770
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825BC770; continue 'dispatch;
	}
	// 825BC784: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825BC788: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 825BC78C: 3BFF0005  addi r31, r31, 5
	ctx.r[31].s64 = ctx.r[31].s64 + 5;
	// 825BC790: 4BFFF488  b 0x825bbc18
	pc = 0x825BBC18; continue 'dispatch;
            }
            0x825BC794 => {
    //   block [0x825BC794..0x825BC7B0)
	// 825BC794: 396BFFA0  addi r11, r11, -0x60
	ctx.r[11].s64 = ctx.r[11].s64 + -96;
	// 825BC798: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BC79C: 39210054  addi r9, r1, 0x54
	ctx.r[9].s64 = ctx.r[1].s64 + 84;
	// 825BC7A0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BC7A4: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 825BC7A8: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 825BC7AC: 48000068  b 0x825bc814
	pc = 0x825BC814; continue 'dispatch;
            }
            0x825BC7B0 => {
    //   block [0x825BC7B0..0x825BC7D8)
	// 825BC7B0: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BC7B4: 390BFF9C  addi r8, r11, -0x64
	ctx.r[8].s64 = ctx.r[11].s64 + -100;
	// 825BC7B8: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BC7BC: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 825BC7C0: 552B403E  rotlwi r11, r9, 8
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(8)) as u64;
	// 825BC7C4: 5509103A  slwi r9, r8, 2
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825BC7C8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BC7CC: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825BC7D0: 7D69392E  stwx r11, r9, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32), ctx.r[11].u32) };
	// 825BC7D4: 48000040  b 0x825bc814
	pc = 0x825BC814; continue 'dispatch;
            }
            0x825BC7D8 => {
    //   block [0x825BC7D8..0x825BC850)
	// 825BC7D8: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BC7DC: 38EBFF98  addi r7, r11, -0x68
	ctx.r[7].s64 = ctx.r[11].s64 + -104;
	// 825BC7E0: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BC7E4: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 825BC7E8: 554B403E  rotlwi r11, r10, 8
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(8)) as u64;
	// 825BC7EC: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BC7F0: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BC7F4: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825BC7F8: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825BC7FC: 3BFF0005  addi r31, r31, 5
	ctx.r[31].s64 = ctx.r[31].s64 + 5;
	// 825BC800: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BC804: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825BC808: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BC80C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BC810: 7D67312E  stwx r11, r7, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32), ctx.r[11].u32) };
	// 825BC814: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825BC818: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825BC81C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825BC820: 419A0028  beq cr6, 0x825bc848
	if ctx.cr[6].eq {
	pc = 0x825BC848; continue 'dispatch;
	}
	// 825BC824: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825BC828: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 825BC82C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825BC830: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC834: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 825BC838: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BC83C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825BC840: 4200FFF0  bdnz 0x825bc830
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825BC830; continue 'dispatch;
	}
	// 825BC844: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825BC848: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825BC84C: 4BFFF3CC  b 0x825bbc18
	pc = 0x825BBC18; continue 'dispatch;
            }
            0x825BC850 => {
    //   block [0x825BC850..0x825BC8A4)
	// 825BC850: 38A00200  li r5, 0x200
	ctx.r[5].s64 = 512;
	// 825BC854: 38810140  addi r4, r1, 0x140
	ctx.r[4].s64 = ctx.r[1].s64 + 320;
	// 825BC858: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 825BC85C: 4BEAC59D  bl 0x82468df8
	ctx.lr = 0x825BC860;
	sub_82468DF8(ctx, base);
	// 825BC860: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 825BC864: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 825BC868: 4BEABA39  bl 0x824682a0
	ctx.lr = 0x825BC86C;
	sub_824682A0(ctx, base);
	// 825BC86C: 80740000  lwz r3, 0(r20)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC870: 3CA01298  lis r5, 0x1298
	ctx.r[5].s64 = 311951360;
	// 825BC874: 3900012D  li r8, 0x12d
	ctx.r[8].s64 = 301;
	// 825BC878: 7E679B78  mr r7, r19
	ctx.r[7].u64 = ctx.r[19].u64;
	// 825BC87C: 38C10140  addi r6, r1, 0x140
	ctx.r[6].s64 = ctx.r[1].s64 + 320;
	// 825BC880: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC884: 60A5FEDD  ori r5, r5, 0xfedd
	ctx.r[5].u64 = ctx.r[5].u64 | 65245;
	// 825BC888: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825BC88C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BC890: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BC894: 4E800421  bctrl
	ctx.lr = 0x825BC898;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BC898: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 825BC89C: 4BEAC045  bl 0x824688e0
	ctx.lr = 0x825BC8A0;
	sub_824688E0(ctx, base);
	// 825BC8A0: 4BFFF378  b 0x825bbc18
	pc = 0x825BBC18; continue 'dispatch;
            }
            0x825BC8A4 => {
    //   block [0x825BC8A4..0x825BC8AC)
	// 825BC8A4: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BC8A8: 48000068  b 0x825bc910
	pc = 0x825BC910; continue 'dispatch;
            }
            0x825BC8AC => {
    //   block [0x825BC8AC..0x825BC8C0)
	// 825BC8AC: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BC8B0: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BC8B4: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825BC8B8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BC8BC: 48000054  b 0x825bc910
	pc = 0x825BC910; continue 'dispatch;
            }
            0x825BC8C0 => {
    //   block [0x825BC8C0..0x825BC8E0)
	// 825BC8C0: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BC8C4: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BC8C8: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825BC8CC: 895F0003  lbz r10, 3(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BC8D0: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825BC8D4: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BC8D8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BC8DC: 48000034  b 0x825bc910
	pc = 0x825BC910; continue 'dispatch;
            }
            0x825BC8E0 => {
    //   block [0x825BC8E0..0x825BC90C)
	// 825BC8E0: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BC8E4: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BC8E8: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825BC8EC: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BC8F0: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BC8F4: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825BC8F8: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BC8FC: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825BC900: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BC904: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BC908: 48000008  b 0x825bc910
	pc = 0x825BC910; continue 'dispatch;
            }
            0x825BC90C => {
    //   block [0x825BC90C..0x825BC954)
	// 825BC90C: 396BFFD0  addi r11, r11, -0x30
	ctx.r[11].s64 = ctx.r[11].s64 + -48;
	// 825BC910: 83FB0000  lwz r31, 0(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC914: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC918: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825BC91C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BC920: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BC924: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825BC928: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825BC92C: 409A0010  bne cr6, 0x825bc93c
	if !ctx.cr[6].eq {
	pc = 0x825BC93C; continue 'dispatch;
	}
	// 825BC930: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 825BC934: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BC938: 4BEB1A19  bl 0x8246e350
	ctx.lr = 0x825BC93C;
	sub_8246E350(ctx, base);
	// 825BC93C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BC940: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC944: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BC948: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825BC94C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825BC950: 7FCA492E  stwx r30, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[30].u32) };
	pc = 0x825BC954; continue 'dispatch;
            }
            0x825BC954 => {
    //   block [0x825BC954..0x825BC95C)
	// 825BC954: 382103C0  addi r1, r1, 0x3c0
	ctx.r[1].s64 = ctx.r[1].s64 + 960;
	// 825BC958: 4BF78788  b 0x825350e0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BC960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BC960 size=3516
    let mut pc: u32 = 0x825BC960;
    'dispatch: loop {
        match pc {
            0x825BC960 => {
    //   block [0x825BC960..0x825BCB74)
	// 825BC960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BC964: 4BF7872D  bl 0x82535090
	ctx.lr = 0x825BC968;
	sub_82535080(ctx, base);
	// 825BC968: 9421FC40  stwu r1, -0x3c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-960 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BC96C: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 825BC970: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825BC974: 3A8B9190  addi r20, r11, -0x6e70
	ctx.r[20].s64 = ctx.r[11].s64 + -28272;
	// 825BC978: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825BC97C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825BC980: 3AAB0E30  addi r21, r11, 0xe30
	ctx.r[21].s64 = ctx.r[11].s64 + 3632;
	// 825BC984: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825BC988: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825BC98C: 3A6BA2D8  addi r19, r11, -0x5d28
	ctx.r[19].s64 = ctx.r[11].s64 + -23848;
	// 825BC990: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825BC994: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 825BC998: 3A4BA1D8  addi r18, r11, -0x5e28
	ctx.r[18].s64 = ctx.r[11].s64 + -24104;
	// 825BC99C: 3AC00010  li r22, 0x10
	ctx.r[22].s64 = 16;
	// 825BC9A0: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC9A4: 2B0B006B  cmplwi cr6, r11, 0x6b
	ctx.cr[6].compare_u32(ctx.r[11].u32, 107 as u32, &mut ctx.xer);
	// 825BC9A8: 41990C68  bgt cr6, 0x825bd610
	if ctx.cr[6].gt {
	pc = 0x825BD610; continue 'dispatch;
	}
	// 825BC9AC: 3D80825C  lis r12, -0x7da4
	ctx.r[12].s64 = -2107899904;
	// 825BC9B0: 398CC9C4  addi r12, r12, -0x363c
	ctx.r[12].s64 = ctx.r[12].s64 + -13884;
	// 825BC9B4: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 825BC9B8: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 825BC9BC: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 825BC9C0: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x825BD714; continue 'dispatch;
		},
		1 => {
	pc = 0x825BD3E4; continue 'dispatch;
		},
		2 => {
	pc = 0x825BD3E4; continue 'dispatch;
		},
		3 => {
	pc = 0x825BD3E4; continue 'dispatch;
		},
		4 => {
	pc = 0x825BD3E4; continue 'dispatch;
		},
		5 => {
	pc = 0x825BD390; continue 'dispatch;
		},
		6 => {
	pc = 0x825BD3A0; continue 'dispatch;
		},
		7 => {
	pc = 0x825BD3BC; continue 'dispatch;
		},
		8 => {
	pc = 0x825BD610; continue 'dispatch;
		},
		9 => {
	pc = 0x825BD454; continue 'dispatch;
		},
		10 => {
	pc = 0x825BD49C; continue 'dispatch;
		},
		11 => {
	pc = 0x825BD4F0; continue 'dispatch;
		},
		12 => {
	pc = 0x825BD610; continue 'dispatch;
		},
		13 => {
	pc = 0x825BD610; continue 'dispatch;
		},
		14 => {
	pc = 0x825BD610; continue 'dispatch;
		},
		15 => {
	pc = 0x825BD610; continue 'dispatch;
		},
		16 => {
	pc = 0x825BCBB0; continue 'dispatch;
		},
		17 => {
	pc = 0x825BCBB0; continue 'dispatch;
		},
		18 => {
	pc = 0x825BCBB0; continue 'dispatch;
		},
		19 => {
	pc = 0x825BCB74; continue 'dispatch;
		},
		20 => {
	pc = 0x825BCB74; continue 'dispatch;
		},
		21 => {
	pc = 0x825BCB74; continue 'dispatch;
		},
		22 => {
	pc = 0x825BCB74; continue 'dispatch;
		},
		23 => {
	pc = 0x825BCB74; continue 'dispatch;
		},
		24 => {
	pc = 0x825BCB74; continue 'dispatch;
		},
		25 => {
	pc = 0x825BCB74; continue 'dispatch;
		},
		26 => {
	pc = 0x825BCB74; continue 'dispatch;
		},
		27 => {
	pc = 0x825BCB74; continue 'dispatch;
		},
		28 => {
	pc = 0x825BCB74; continue 'dispatch;
		},
		29 => {
	pc = 0x825BD610; continue 'dispatch;
		},
		30 => {
	pc = 0x825BD610; continue 'dispatch;
		},
		31 => {
	pc = 0x825BD610; continue 'dispatch;
		},
		32 => {
	pc = 0x825BCC60; continue 'dispatch;
		},
		33 => {
	pc = 0x825BCC60; continue 'dispatch;
		},
		34 => {
	pc = 0x825BCC60; continue 'dispatch;
		},
		35 => {
	pc = 0x825BCD04; continue 'dispatch;
		},
		36 => {
	pc = 0x825BCD04; continue 'dispatch;
		},
		37 => {
	pc = 0x825BCD04; continue 'dispatch;
		},
		38 => {
	pc = 0x825BD268; continue 'dispatch;
		},
		39 => {
	pc = 0x825BD268; continue 'dispatch;
		},
		40 => {
	pc = 0x825BD268; continue 'dispatch;
		},
		41 => {
	pc = 0x825BD1E4; continue 'dispatch;
		},
		42 => {
	pc = 0x825BD1E4; continue 'dispatch;
		},
		43 => {
	pc = 0x825BD1E4; continue 'dispatch;
		},
		44 => {
	pc = 0x825BD610; continue 'dispatch;
		},
		45 => {
	pc = 0x825BD610; continue 'dispatch;
		},
		46 => {
	pc = 0x825BD610; continue 'dispatch;
		},
		47 => {
	pc = 0x825BD610; continue 'dispatch;
		},
		48 => {
	pc = 0x825BD6CC; continue 'dispatch;
		},
		49 => {
	pc = 0x825BD6CC; continue 'dispatch;
		},
		50 => {
	pc = 0x825BD6CC; continue 'dispatch;
		},
		51 => {
	pc = 0x825BD6CC; continue 'dispatch;
		},
		52 => {
	pc = 0x825BD6CC; continue 'dispatch;
		},
		53 => {
	pc = 0x825BD6CC; continue 'dispatch;
		},
		54 => {
	pc = 0x825BD6CC; continue 'dispatch;
		},
		55 => {
	pc = 0x825BD6CC; continue 'dispatch;
		},
		56 => {
	pc = 0x825BD6CC; continue 'dispatch;
		},
		57 => {
	pc = 0x825BD6CC; continue 'dispatch;
		},
		58 => {
	pc = 0x825BD6CC; continue 'dispatch;
		},
		59 => {
	pc = 0x825BD6CC; continue 'dispatch;
		},
		60 => {
	pc = 0x825BD6CC; continue 'dispatch;
		},
		61 => {
	pc = 0x825BD6CC; continue 'dispatch;
		},
		62 => {
	pc = 0x825BD6CC; continue 'dispatch;
		},
		63 => {
	pc = 0x825BD6CC; continue 'dispatch;
		},
		64 => {
	pc = 0x825BD6CC; continue 'dispatch;
		},
		65 => {
	pc = 0x825BD6CC; continue 'dispatch;
		},
		66 => {
	pc = 0x825BD6CC; continue 'dispatch;
		},
		67 => {
	pc = 0x825BD6CC; continue 'dispatch;
		},
		68 => {
	pc = 0x825BD6CC; continue 'dispatch;
		},
		69 => {
	pc = 0x825BD6CC; continue 'dispatch;
		},
		70 => {
	pc = 0x825BD6CC; continue 'dispatch;
		},
		71 => {
	pc = 0x825BD6CC; continue 'dispatch;
		},
		72 => {
	pc = 0x825BD6CC; continue 'dispatch;
		},
		73 => {
	pc = 0x825BD6CC; continue 'dispatch;
		},
		74 => {
	pc = 0x825BD6CC; continue 'dispatch;
		},
		75 => {
	pc = 0x825BD6CC; continue 'dispatch;
		},
		76 => {
	pc = 0x825BD6CC; continue 'dispatch;
		},
		77 => {
	pc = 0x825BD6CC; continue 'dispatch;
		},
		78 => {
	pc = 0x825BD6CC; continue 'dispatch;
		},
		79 => {
	pc = 0x825BD6CC; continue 'dispatch;
		},
		80 => {
	pc = 0x825BD664; continue 'dispatch;
		},
		81 => {
	pc = 0x825BD66C; continue 'dispatch;
		},
		82 => {
	pc = 0x825BD680; continue 'dispatch;
		},
		83 => {
	pc = 0x825BD6A0; continue 'dispatch;
		},
		84 => {
	pc = 0x825BD610; continue 'dispatch;
		},
		85 => {
	pc = 0x825BD610; continue 'dispatch;
		},
		86 => {
	pc = 0x825BD610; continue 'dispatch;
		},
		87 => {
	pc = 0x825BD610; continue 'dispatch;
		},
		88 => {
	pc = 0x825BD610; continue 'dispatch;
		},
		89 => {
	pc = 0x825BD610; continue 'dispatch;
		},
		90 => {
	pc = 0x825BD610; continue 'dispatch;
		},
		91 => {
	pc = 0x825BD610; continue 'dispatch;
		},
		92 => {
	pc = 0x825BD610; continue 'dispatch;
		},
		93 => {
	pc = 0x825BD610; continue 'dispatch;
		},
		94 => {
	pc = 0x825BD610; continue 'dispatch;
		},
		95 => {
	pc = 0x825BD610; continue 'dispatch;
		},
		96 => {
	pc = 0x825BD554; continue 'dispatch;
		},
		97 => {
	pc = 0x825BD554; continue 'dispatch;
		},
		98 => {
	pc = 0x825BD554; continue 'dispatch;
		},
		99 => {
	pc = 0x825BD554; continue 'dispatch;
		},
		100 => {
	pc = 0x825BD570; continue 'dispatch;
		},
		101 => {
	pc = 0x825BD570; continue 'dispatch;
		},
		102 => {
	pc = 0x825BD570; continue 'dispatch;
		},
		103 => {
	pc = 0x825BD570; continue 'dispatch;
		},
		104 => {
	pc = 0x825BD598; continue 'dispatch;
		},
		105 => {
	pc = 0x825BD598; continue 'dispatch;
		},
		106 => {
	pc = 0x825BD598; continue 'dispatch;
		},
		107 => {
	pc = 0x825BD598; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 825BC9C4: 825BD714  lwz r18, -0x28ec(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10476 as u32) ) } as u64;
	// 825BC9C8: 825BD3E4  lwz r18, -0x2c1c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-11292 as u32) ) } as u64;
	// 825BC9CC: 825BD3E4  lwz r18, -0x2c1c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-11292 as u32) ) } as u64;
	// 825BC9D0: 825BD3E4  lwz r18, -0x2c1c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-11292 as u32) ) } as u64;
	// 825BC9D4: 825BD3E4  lwz r18, -0x2c1c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-11292 as u32) ) } as u64;
	// 825BC9D8: 825BD390  lwz r18, -0x2c70(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-11376 as u32) ) } as u64;
	// 825BC9DC: 825BD3A0  lwz r18, -0x2c60(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-11360 as u32) ) } as u64;
	// 825BC9E0: 825BD3BC  lwz r18, -0x2c44(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-11332 as u32) ) } as u64;
	// 825BC9E4: 825BD610  lwz r18, -0x29f0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10736 as u32) ) } as u64;
	// 825BC9E8: 825BD454  lwz r18, -0x2bac(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-11180 as u32) ) } as u64;
	// 825BC9EC: 825BD49C  lwz r18, -0x2b64(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-11108 as u32) ) } as u64;
	// 825BC9F0: 825BD4F0  lwz r18, -0x2b10(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-11024 as u32) ) } as u64;
	// 825BC9F4: 825BD610  lwz r18, -0x29f0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10736 as u32) ) } as u64;
	// 825BC9F8: 825BD610  lwz r18, -0x29f0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10736 as u32) ) } as u64;
	// 825BC9FC: 825BD610  lwz r18, -0x29f0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10736 as u32) ) } as u64;
	// 825BCA00: 825BD610  lwz r18, -0x29f0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10736 as u32) ) } as u64;
	// 825BCA04: 825BCBB0  lwz r18, -0x3450(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-13392 as u32) ) } as u64;
	// 825BCA08: 825BCBB0  lwz r18, -0x3450(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-13392 as u32) ) } as u64;
	// 825BCA0C: 825BCBB0  lwz r18, -0x3450(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-13392 as u32) ) } as u64;
	// 825BCA10: 825BCB74  lwz r18, -0x348c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-13452 as u32) ) } as u64;
	// 825BCA14: 825BCB74  lwz r18, -0x348c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-13452 as u32) ) } as u64;
	// 825BCA18: 825BCB74  lwz r18, -0x348c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-13452 as u32) ) } as u64;
	// 825BCA1C: 825BCB74  lwz r18, -0x348c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-13452 as u32) ) } as u64;
	// 825BCA20: 825BCB74  lwz r18, -0x348c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-13452 as u32) ) } as u64;
	// 825BCA24: 825BCB74  lwz r18, -0x348c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-13452 as u32) ) } as u64;
	// 825BCA28: 825BCB74  lwz r18, -0x348c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-13452 as u32) ) } as u64;
	// 825BCA2C: 825BCB74  lwz r18, -0x348c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-13452 as u32) ) } as u64;
	// 825BCA30: 825BCB74  lwz r18, -0x348c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-13452 as u32) ) } as u64;
	// 825BCA34: 825BCB74  lwz r18, -0x348c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-13452 as u32) ) } as u64;
	// 825BCA38: 825BD610  lwz r18, -0x29f0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10736 as u32) ) } as u64;
	// 825BCA3C: 825BD610  lwz r18, -0x29f0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10736 as u32) ) } as u64;
	// 825BCA40: 825BD610  lwz r18, -0x29f0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10736 as u32) ) } as u64;
	// 825BCA44: 825BCC60  lwz r18, -0x33a0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-13216 as u32) ) } as u64;
	// 825BCA48: 825BCC60  lwz r18, -0x33a0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-13216 as u32) ) } as u64;
	// 825BCA4C: 825BCC60  lwz r18, -0x33a0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-13216 as u32) ) } as u64;
	// 825BCA50: 825BCD04  lwz r18, -0x32fc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-13052 as u32) ) } as u64;
	// 825BCA54: 825BCD04  lwz r18, -0x32fc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-13052 as u32) ) } as u64;
	// 825BCA58: 825BCD04  lwz r18, -0x32fc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-13052 as u32) ) } as u64;
	// 825BCA5C: 825BD268  lwz r18, -0x2d98(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-11672 as u32) ) } as u64;
	// 825BCA60: 825BD268  lwz r18, -0x2d98(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-11672 as u32) ) } as u64;
	// 825BCA64: 825BD268  lwz r18, -0x2d98(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-11672 as u32) ) } as u64;
	// 825BCA68: 825BD1E4  lwz r18, -0x2e1c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-11804 as u32) ) } as u64;
	// 825BCA6C: 825BD1E4  lwz r18, -0x2e1c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-11804 as u32) ) } as u64;
	// 825BCA70: 825BD1E4  lwz r18, -0x2e1c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-11804 as u32) ) } as u64;
	// 825BCA74: 825BD610  lwz r18, -0x29f0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10736 as u32) ) } as u64;
	// 825BCA78: 825BD610  lwz r18, -0x29f0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10736 as u32) ) } as u64;
	// 825BCA7C: 825BD610  lwz r18, -0x29f0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10736 as u32) ) } as u64;
	// 825BCA80: 825BD610  lwz r18, -0x29f0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10736 as u32) ) } as u64;
	// 825BCA84: 825BD6CC  lwz r18, -0x2934(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10548 as u32) ) } as u64;
	// 825BCA88: 825BD6CC  lwz r18, -0x2934(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10548 as u32) ) } as u64;
	// 825BCA8C: 825BD6CC  lwz r18, -0x2934(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10548 as u32) ) } as u64;
	// 825BCA90: 825BD6CC  lwz r18, -0x2934(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10548 as u32) ) } as u64;
	// 825BCA94: 825BD6CC  lwz r18, -0x2934(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10548 as u32) ) } as u64;
	// 825BCA98: 825BD6CC  lwz r18, -0x2934(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10548 as u32) ) } as u64;
	// 825BCA9C: 825BD6CC  lwz r18, -0x2934(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10548 as u32) ) } as u64;
	// 825BCAA0: 825BD6CC  lwz r18, -0x2934(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10548 as u32) ) } as u64;
	// 825BCAA4: 825BD6CC  lwz r18, -0x2934(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10548 as u32) ) } as u64;
	// 825BCAA8: 825BD6CC  lwz r18, -0x2934(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10548 as u32) ) } as u64;
	// 825BCAAC: 825BD6CC  lwz r18, -0x2934(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10548 as u32) ) } as u64;
	// 825BCAB0: 825BD6CC  lwz r18, -0x2934(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10548 as u32) ) } as u64;
	// 825BCAB4: 825BD6CC  lwz r18, -0x2934(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10548 as u32) ) } as u64;
	// 825BCAB8: 825BD6CC  lwz r18, -0x2934(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10548 as u32) ) } as u64;
	// 825BCABC: 825BD6CC  lwz r18, -0x2934(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10548 as u32) ) } as u64;
	// 825BCAC0: 825BD6CC  lwz r18, -0x2934(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10548 as u32) ) } as u64;
	// 825BCAC4: 825BD6CC  lwz r18, -0x2934(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10548 as u32) ) } as u64;
	// 825BCAC8: 825BD6CC  lwz r18, -0x2934(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10548 as u32) ) } as u64;
	// 825BCACC: 825BD6CC  lwz r18, -0x2934(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10548 as u32) ) } as u64;
	// 825BCAD0: 825BD6CC  lwz r18, -0x2934(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10548 as u32) ) } as u64;
	// 825BCAD4: 825BD6CC  lwz r18, -0x2934(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10548 as u32) ) } as u64;
	// 825BCAD8: 825BD6CC  lwz r18, -0x2934(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10548 as u32) ) } as u64;
	// 825BCADC: 825BD6CC  lwz r18, -0x2934(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10548 as u32) ) } as u64;
	// 825BCAE0: 825BD6CC  lwz r18, -0x2934(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10548 as u32) ) } as u64;
	// 825BCAE4: 825BD6CC  lwz r18, -0x2934(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10548 as u32) ) } as u64;
	// 825BCAE8: 825BD6CC  lwz r18, -0x2934(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10548 as u32) ) } as u64;
	// 825BCAEC: 825BD6CC  lwz r18, -0x2934(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10548 as u32) ) } as u64;
	// 825BCAF0: 825BD6CC  lwz r18, -0x2934(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10548 as u32) ) } as u64;
	// 825BCAF4: 825BD6CC  lwz r18, -0x2934(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10548 as u32) ) } as u64;
	// 825BCAF8: 825BD6CC  lwz r18, -0x2934(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10548 as u32) ) } as u64;
	// 825BCAFC: 825BD6CC  lwz r18, -0x2934(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10548 as u32) ) } as u64;
	// 825BCB00: 825BD6CC  lwz r18, -0x2934(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10548 as u32) ) } as u64;
	// 825BCB04: 825BD664  lwz r18, -0x299c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10652 as u32) ) } as u64;
	// 825BCB08: 825BD66C  lwz r18, -0x2994(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10644 as u32) ) } as u64;
	// 825BCB0C: 825BD680  lwz r18, -0x2980(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10624 as u32) ) } as u64;
	// 825BCB10: 825BD6A0  lwz r18, -0x2960(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10592 as u32) ) } as u64;
	// 825BCB14: 825BD610  lwz r18, -0x29f0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10736 as u32) ) } as u64;
	// 825BCB18: 825BD610  lwz r18, -0x29f0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10736 as u32) ) } as u64;
	// 825BCB1C: 825BD610  lwz r18, -0x29f0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10736 as u32) ) } as u64;
	// 825BCB20: 825BD610  lwz r18, -0x29f0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10736 as u32) ) } as u64;
	// 825BCB24: 825BD610  lwz r18, -0x29f0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10736 as u32) ) } as u64;
	// 825BCB28: 825BD610  lwz r18, -0x29f0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10736 as u32) ) } as u64;
	// 825BCB2C: 825BD610  lwz r18, -0x29f0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10736 as u32) ) } as u64;
	// 825BCB30: 825BD610  lwz r18, -0x29f0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10736 as u32) ) } as u64;
	// 825BCB34: 825BD610  lwz r18, -0x29f0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10736 as u32) ) } as u64;
	// 825BCB38: 825BD610  lwz r18, -0x29f0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10736 as u32) ) } as u64;
	// 825BCB3C: 825BD610  lwz r18, -0x29f0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10736 as u32) ) } as u64;
	// 825BCB40: 825BD610  lwz r18, -0x29f0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10736 as u32) ) } as u64;
	// 825BCB44: 825BD554  lwz r18, -0x2aac(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10924 as u32) ) } as u64;
	// 825BCB48: 825BD554  lwz r18, -0x2aac(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10924 as u32) ) } as u64;
	// 825BCB4C: 825BD554  lwz r18, -0x2aac(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10924 as u32) ) } as u64;
	// 825BCB50: 825BD554  lwz r18, -0x2aac(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10924 as u32) ) } as u64;
	// 825BCB54: 825BD570  lwz r18, -0x2a90(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10896 as u32) ) } as u64;
	// 825BCB58: 825BD570  lwz r18, -0x2a90(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10896 as u32) ) } as u64;
	// 825BCB5C: 825BD570  lwz r18, -0x2a90(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10896 as u32) ) } as u64;
	// 825BCB60: 825BD570  lwz r18, -0x2a90(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10896 as u32) ) } as u64;
	// 825BCB64: 825BD598  lwz r18, -0x2a68(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10856 as u32) ) } as u64;
	// 825BCB68: 825BD598  lwz r18, -0x2a68(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10856 as u32) ) } as u64;
	// 825BCB6C: 825BD598  lwz r18, -0x2a68(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10856 as u32) ) } as u64;
	// 825BCB70: 825BD598  lwz r18, -0x2a68(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10856 as u32) ) } as u64;
            }
            0x825BCB74 => {
    //   block [0x825BCB74..0x825BCBB0)
	// 825BCB74: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 825BCB78: 8BBF0003  lbz r29, 3(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	pc = 0x825BCBB0; continue 'dispatch;
            }
            0x825BCBB0 => {
    //   block [0x825BCBB0..0x825BCC60)
	// 825BCBB0: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	pc = 0x825BCC60; continue 'dispatch;
            }
            0x825BCC60 => {
    //   block [0x825BCC60..0x825BCD04)
	// 825BCC60: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	pc = 0x825BCD04; continue 'dispatch;
            }
            0x825BCD04 => {
    //   block [0x825BCD04..0x825BD1E4)
	// 825BCD04: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	pc = 0x825BD1E4; continue 'dispatch;
            }
            0x825BD1E4 => {
    //   block [0x825BD1E4..0x825BD268)
	// 825BD1E4: 395F0001  addi r10, r31, 1
	ctx.r[10].s64 = ctx.r[31].s64 + 1;
	// 825BD1E8: C01B0010  lfs f0, 0x10(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BD1EC: 392BFFD7  addi r9, r11, -0x29
	ctx.r[9].s64 = ctx.r[11].s64 + -41;
	// 825BD1F0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825BD1F4: 5525103A  slwi r5, r9, 2
	ctx.r[5].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 825BD1F8: 3BFF0007  addi r31, r31, 7
	ctx.r[31].s64 = ctx.r[31].s64 + 7;
	// 825BD1FC: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD200: 88CA0001  lbz r6, 1(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BD204: 5507403E  rotlwi r7, r8, 8
	ctx.r[7].u64 = ((ctx.r[8].u32).rotate_left(8)) as u64;
	// 825BD208: 890A0002  lbz r8, 2(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BD20C: 39490004  addi r10, r9, 4
	ctx.r[10].s64 = ctx.r[9].s64 + 4;
	// 825BD210: 7D273214  add r9, r7, r6
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 825BD214: 5547103A  slwi r7, r10, 2
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825BD218: 552A402E  slwi r10, r9, 8
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(8);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BD21C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 825BD220: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825BD224: F94100C8  std r10, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[10].u64 ) };
	// 825BD228: C9A100C8  lfd f13, 0xc8(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) };
	// 825BD22C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 825BD230: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825BD234: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825BD238: 7C05D52E  stfsx f0, r5, r26
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[26].u32), tmp.u32) };
	// 825BD23C: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD240: 892B0001  lbz r9, 1(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BD244: 5548403E  rotlwi r8, r10, 8
	ctx.r[8].u64 = ((ctx.r[10].u32).rotate_left(8)) as u64;
	// 825BD248: 894B0002  lbz r10, 2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BD24C: 7D694214  add r11, r9, r8
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 825BD250: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BD254: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BD258: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825BD25C: F96100D8  std r11, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[11].u64 ) };
	// 825BD260: C9A100D8  lfd f13, 0xd8(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) };
	// 825BD264: 48000074  b 0x825bd2d8
	pc = 0x825BD2D8; continue 'dispatch;
            }
            0x825BD268 => {
    //   block [0x825BD268..0x825BD390)
	// 825BD268: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BD26C: 396BFFDA  addi r11, r11, -0x26
	ctx.r[11].s64 = ctx.r[11].s64 + -38;
	// 825BD270: 813E0014  lwz r9, 0x14(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BD274: C01B0010  lfs f0, 0x10(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BD278: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825BD27C: 7D494830  slw r9, r10, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[10].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 825BD280: 394B0002  addi r10, r11, 2
	ctx.r[10].s64 = ctx.r[11].s64 + 2;
	// 825BD284: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825BD288: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BD28C: 5567103A  slwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825BD290: 7D6AF02E  lwzx r11, r10, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825BD294: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825BD298: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825BD29C: F96100E8  std r11, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[11].u64 ) };
	// 825BD2A0: C9A100E8  lfd f13, 0xe8(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(232 as u32) ) };
	// 825BD2A4: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 825BD2A8: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825BD2AC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825BD2B0: 7C08D52E  stfsx f0, r8, r26
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[26].u32), tmp.u32) };
	// 825BD2B4: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BD2B8: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825BD2BC: 813E0014  lwz r9, 0x14(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BD2C0: 7D4AF02E  lwzx r10, r10, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825BD2C4: 7D6B4830  slw r11, r11, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[11].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 825BD2C8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BD2CC: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825BD2D0: F96100F8  std r11, 0xf8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[11].u64 ) };
	// 825BD2D4: C9A100F8  lfd f13, 0xf8(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(248 as u32) ) };
	// 825BD2D8: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 825BD2DC: C01B0010  lfs f0, 0x10(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BD2E0: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825BD2E4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825BD2E8: 7C07D52E  stfsx f0, r7, r26
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[26].u32), tmp.u32) };
	// 825BD2EC: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD2F0: 2B0B0026  cmplwi cr6, r11, 0x26
	ctx.cr[6].compare_u32(ctx.r[11].u32, 38 as u32, &mut ctx.xer);
	// 825BD2F4: 4198000C  blt cr6, 0x825bd300
	if ctx.cr[6].lt {
	pc = 0x825BD300; continue 'dispatch;
	}
	// 825BD2F8: 2B0B002B  cmplwi cr6, r11, 0x2b
	ctx.cr[6].compare_u32(ctx.r[11].u32, 43 as u32, &mut ctx.xer);
	// 825BD2FC: 4099F6A4  ble cr6, 0x825bc9a0
	if !ctx.cr[6].gt {
	pc = 0x825BC9A0; continue 'dispatch;
	}
	pc = 0x825BD390; continue 'dispatch;
            }
            0x825BD390 => {
    //   block [0x825BD390..0x825BD3A0)
	// 825BD390: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BD394: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825BD398: 3BEB0002  addi r31, r11, 2
	ctx.r[31].s64 = ctx.r[11].s64 + 2;
	// 825BD39C: 4BFFF604  b 0x825bc9a0
	pc = 0x825BC9A0; continue 'dispatch;
            }
            0x825BD3A0 => {
    //   block [0x825BD3A0..0x825BD3BC)
	// 825BD3A0: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BD3A4: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BD3A8: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825BD3AC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BD3B0: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825BD3B4: 3BEB0003  addi r31, r11, 3
	ctx.r[31].s64 = ctx.r[11].s64 + 3;
	// 825BD3B8: 4BFFF5E8  b 0x825bc9a0
	pc = 0x825BC9A0; continue 'dispatch;
            }
            0x825BD3BC => {
    //   block [0x825BD3BC..0x825BD3E4)
	// 825BD3BC: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BD3C0: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BD3C4: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825BD3C8: 895F0003  lbz r10, 3(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BD3CC: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825BD3D0: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BD3D4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BD3D8: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825BD3DC: 3BEB0004  addi r31, r11, 4
	ctx.r[31].s64 = ctx.r[11].s64 + 4;
	// 825BD3E0: 4BFFF5C0  b 0x825bc9a0
	pc = 0x825BC9A0; continue 'dispatch;
            }
            0x825BD3E4 => {
    //   block [0x825BD3E4..0x825BD454)
	// 825BD3E4: 811E0014  lwz r8, 0x14(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BD3E8: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BD3EC: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BD3F0: 7D4A4030  slw r10, r10, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 825BD3F4: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825BD3F8: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825BD3FC: 811E0014  lwz r8, 0x14(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BD400: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BD404: 813E000C  lwz r9, 0xc(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BD408: 7D4A4030  slw r10, r10, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 825BD40C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825BD410: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 825BD414: 895F0003  lbz r10, 3(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BD418: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825BD41C: 811E0014  lwz r8, 0x14(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BD420: 813E0010  lwz r9, 0x10(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BD424: 7D4A4030  slw r10, r10, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 825BD428: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825BD42C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825BD430: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BD434: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BD438: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825BD43C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BD440: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825BD444: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD448: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825BD44C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825BD450: 4BFFF550  b 0x825bc9a0
	pc = 0x825BC9A0; continue 'dispatch;
            }
            0x825BD454 => {
    //   block [0x825BD454..0x825BD49C)
	// 825BD454: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825BD458: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BD45C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825BD460: 419A0028  beq cr6, 0x825bd488
	if ctx.cr[6].eq {
	pc = 0x825BD488; continue 'dispatch;
	}
	// 825BD464: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825BD468: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 825BD46C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825BD470: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD474: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 825BD478: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BD47C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825BD480: 4200FFF0  bdnz 0x825bd470
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825BD470; continue 'dispatch;
	}
	// 825BD484: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825BD488: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825BD48C: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 825BD490: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825BD494: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825BD498: 4BFFF508  b 0x825bc9a0
	pc = 0x825BC9A0; continue 'dispatch;
            }
            0x825BD49C => {
    //   block [0x825BD49C..0x825BD4F0)
	// 825BD49C: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BD4A0: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 825BD4A4: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BD4A8: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825BD4AC: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825BD4B0: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BD4B4: 419A0028  beq cr6, 0x825bd4dc
	if ctx.cr[6].eq {
	pc = 0x825BD4DC; continue 'dispatch;
	}
	// 825BD4B8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825BD4BC: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 825BD4C0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825BD4C4: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD4C8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 825BD4CC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BD4D0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825BD4D4: 4200FFF0  bdnz 0x825bd4c4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825BD4C4; continue 'dispatch;
	}
	// 825BD4D8: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825BD4DC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825BD4E0: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825BD4E4: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825BD4E8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825BD4EC: 4BFFF4B4  b 0x825bc9a0
	pc = 0x825BC9A0; continue 'dispatch;
            }
            0x825BD4F0 => {
    //   block [0x825BD4F0..0x825BD554)
	// 825BD4F0: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BD4F4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825BD4F8: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BD4FC: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825BD500: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BD504: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BD508: 7F1E3840  cmplw cr6, r30, r7
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825BD50C: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825BD510: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BD514: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825BD518: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BD51C: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BD520: 419A0028  beq cr6, 0x825bd548
	if ctx.cr[6].eq {
	pc = 0x825BD548; continue 'dispatch;
	}
	// 825BD524: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825BD528: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 825BD52C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825BD530: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD534: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 825BD538: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BD53C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825BD540: 4200FFF0  bdnz 0x825bd530
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825BD530; continue 'dispatch;
	}
	// 825BD544: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825BD548: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 825BD54C: 3BFF0005  addi r31, r31, 5
	ctx.r[31].s64 = ctx.r[31].s64 + 5;
	// 825BD550: 4BFFF450  b 0x825bc9a0
	pc = 0x825BC9A0; continue 'dispatch;
            }
            0x825BD554 => {
    //   block [0x825BD554..0x825BD570)
	// 825BD554: 396BFFA0  addi r11, r11, -0x60
	ctx.r[11].s64 = ctx.r[11].s64 + -96;
	// 825BD558: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BD55C: 39210054  addi r9, r1, 0x54
	ctx.r[9].s64 = ctx.r[1].s64 + 84;
	// 825BD560: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BD564: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 825BD568: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 825BD56C: 48000068  b 0x825bd5d4
	pc = 0x825BD5D4; continue 'dispatch;
            }
            0x825BD570 => {
    //   block [0x825BD570..0x825BD598)
	// 825BD570: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BD574: 390BFF9C  addi r8, r11, -0x64
	ctx.r[8].s64 = ctx.r[11].s64 + -100;
	// 825BD578: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BD57C: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 825BD580: 552B403E  rotlwi r11, r9, 8
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(8)) as u64;
	// 825BD584: 5509103A  slwi r9, r8, 2
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825BD588: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BD58C: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825BD590: 7D69392E  stwx r11, r9, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32), ctx.r[11].u32) };
	// 825BD594: 48000040  b 0x825bd5d4
	pc = 0x825BD5D4; continue 'dispatch;
            }
            0x825BD598 => {
    //   block [0x825BD598..0x825BD610)
	// 825BD598: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BD59C: 38EBFF98  addi r7, r11, -0x68
	ctx.r[7].s64 = ctx.r[11].s64 + -104;
	// 825BD5A0: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BD5A4: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 825BD5A8: 554B403E  rotlwi r11, r10, 8
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(8)) as u64;
	// 825BD5AC: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BD5B0: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BD5B4: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825BD5B8: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825BD5BC: 3BFF0005  addi r31, r31, 5
	ctx.r[31].s64 = ctx.r[31].s64 + 5;
	// 825BD5C0: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BD5C4: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825BD5C8: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BD5CC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BD5D0: 7D67312E  stwx r11, r7, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32), ctx.r[11].u32) };
	// 825BD5D4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825BD5D8: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825BD5DC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825BD5E0: 419A0028  beq cr6, 0x825bd608
	if ctx.cr[6].eq {
	pc = 0x825BD608; continue 'dispatch;
	}
	// 825BD5E4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825BD5E8: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 825BD5EC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825BD5F0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD5F4: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 825BD5F8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BD5FC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825BD600: 4200FFF0  bdnz 0x825bd5f0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825BD5F0; continue 'dispatch;
	}
	// 825BD604: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825BD608: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825BD60C: 4BFFF394  b 0x825bc9a0
	pc = 0x825BC9A0; continue 'dispatch;
            }
            0x825BD610 => {
    //   block [0x825BD610..0x825BD664)
	// 825BD610: 38A00200  li r5, 0x200
	ctx.r[5].s64 = 512;
	// 825BD614: 38810140  addi r4, r1, 0x140
	ctx.r[4].s64 = ctx.r[1].s64 + 320;
	// 825BD618: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 825BD61C: 4BEAB7DD  bl 0x82468df8
	ctx.lr = 0x825BD620;
	sub_82468DF8(ctx, base);
	// 825BD620: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 825BD624: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 825BD628: 4BEAAC79  bl 0x824682a0
	ctx.lr = 0x825BD62C;
	sub_824682A0(ctx, base);
	// 825BD62C: 80740000  lwz r3, 0(r20)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD630: 3CA01298  lis r5, 0x1298
	ctx.r[5].s64 = 311951360;
	// 825BD634: 3900012D  li r8, 0x12d
	ctx.r[8].s64 = 301;
	// 825BD638: 7E679B78  mr r7, r19
	ctx.r[7].u64 = ctx.r[19].u64;
	// 825BD63C: 38C10140  addi r6, r1, 0x140
	ctx.r[6].s64 = ctx.r[1].s64 + 320;
	// 825BD640: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD644: 60A5FEDD  ori r5, r5, 0xfedd
	ctx.r[5].u64 = ctx.r[5].u64 | 65245;
	// 825BD648: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825BD64C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BD650: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BD654: 4E800421  bctrl
	ctx.lr = 0x825BD658;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BD658: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 825BD65C: 4BEAB285  bl 0x824688e0
	ctx.lr = 0x825BD660;
	sub_824688E0(ctx, base);
	// 825BD660: 4BFFF340  b 0x825bc9a0
	pc = 0x825BC9A0; continue 'dispatch;
            }
            0x825BD664 => {
    //   block [0x825BD664..0x825BD66C)
	// 825BD664: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BD668: 48000068  b 0x825bd6d0
	pc = 0x825BD6D0; continue 'dispatch;
            }
            0x825BD66C => {
    //   block [0x825BD66C..0x825BD680)
	// 825BD66C: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BD670: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BD674: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825BD678: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BD67C: 48000054  b 0x825bd6d0
	pc = 0x825BD6D0; continue 'dispatch;
            }
            0x825BD680 => {
    //   block [0x825BD680..0x825BD6A0)
	// 825BD680: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BD684: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BD688: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825BD68C: 895F0003  lbz r10, 3(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BD690: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825BD694: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BD698: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BD69C: 48000034  b 0x825bd6d0
	pc = 0x825BD6D0; continue 'dispatch;
            }
            0x825BD6A0 => {
    //   block [0x825BD6A0..0x825BD6CC)
	// 825BD6A0: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BD6A4: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BD6A8: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825BD6AC: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BD6B0: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BD6B4: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825BD6B8: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BD6BC: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825BD6C0: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BD6C4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BD6C8: 48000008  b 0x825bd6d0
	pc = 0x825BD6D0; continue 'dispatch;
            }
            0x825BD6CC => {
    //   block [0x825BD6CC..0x825BD714)
	// 825BD6CC: 396BFFD0  addi r11, r11, -0x30
	ctx.r[11].s64 = ctx.r[11].s64 + -48;
	// 825BD6D0: 83FB0000  lwz r31, 0(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD6D4: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD6D8: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825BD6DC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BD6E0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BD6E4: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825BD6E8: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825BD6EC: 409A0010  bne cr6, 0x825bd6fc
	if !ctx.cr[6].eq {
	pc = 0x825BD6FC; continue 'dispatch;
	}
	// 825BD6F0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 825BD6F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BD6F8: 4BEB0C59  bl 0x8246e350
	ctx.lr = 0x825BD6FC;
	sub_8246E350(ctx, base);
	// 825BD6FC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BD700: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD704: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BD708: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825BD70C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825BD710: 7FCA492E  stwx r30, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[30].u32) };
	pc = 0x825BD714; continue 'dispatch;
            }
            0x825BD714 => {
    //   block [0x825BD714..0x825BD71C)
	// 825BD714: 382103C0  addi r1, r1, 0x3c0
	ctx.r[1].s64 = ctx.r[1].s64 + 960;
	// 825BD718: 4BF779C8  b 0x825350e0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BD720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BD720 size=336
    let mut pc: u32 = 0x825BD720;
    'dispatch: loop {
        match pc {
            0x825BD720 => {
    //   block [0x825BD720..0x825BD7A0)
	// 825BD720: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BD724: 4BF77991  bl 0x825350b4
	ctx.lr = 0x825BD728;
	sub_82535080(ctx, base);
	// 825BD728: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 825BD72C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BD730: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825BD734: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825BD738: 3BA00004  li r29, 4
	ctx.r[29].s64 = 4;
	// 825BD73C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD740: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD744: 3BEB0010  addi r31, r11, 0x10
	ctx.r[31].s64 = ctx.r[11].s64 + 16;
	// 825BD748: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD74C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825BD750: 3B8B0010  addi r28, r11, 0x10
	ctx.r[28].s64 = ctx.r[11].s64 + 16;
	// 825BD754: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825BD758: C3EB2074  lfs f31, 0x2074(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8308 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825BD75C: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD760: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BD764: 2B0B0006  cmplwi cr6, r11, 6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 6 as u32, &mut ctx.xer);
	// 825BD768: 419900D4  bgt cr6, 0x825bd83c
	if ctx.cr[6].gt {
	pc = 0x825BD83C; continue 'dispatch;
	}
	// 825BD76C: 3D80825C  lis r12, -0x7da4
	ctx.r[12].s64 = -2107899904;
	// 825BD770: 398CD784  addi r12, r12, -0x287c
	ctx.r[12].s64 = ctx.r[12].s64 + -10364;
	// 825BD774: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 825BD778: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 825BD77C: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 825BD780: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x825BD834; continue 'dispatch;
		},
		1 => {
	pc = 0x825BD864; continue 'dispatch;
		},
		2 => {
	pc = 0x825BD7A0; continue 'dispatch;
		},
		3 => {
	pc = 0x825BD7A0; continue 'dispatch;
		},
		4 => {
	pc = 0x825BD7E0; continue 'dispatch;
		},
		5 => {
	pc = 0x825BD7E0; continue 'dispatch;
		},
		6 => {
	pc = 0x825BD7A0; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 825BD784: 825BD834  lwz r18, -0x27cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10188 as u32) ) } as u64;
	// 825BD788: 825BD864  lwz r18, -0x279c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10140 as u32) ) } as u64;
	// 825BD78C: 825BD7A0  lwz r18, -0x2860(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10336 as u32) ) } as u64;
	// 825BD790: 825BD7A0  lwz r18, -0x2860(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10336 as u32) ) } as u64;
	// 825BD794: 825BD7E0  lwz r18, -0x2820(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10272 as u32) ) } as u64;
	// 825BD798: 825BD7E0  lwz r18, -0x2820(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10272 as u32) ) } as u64;
	// 825BD79C: 825BD7A0  lwz r18, -0x2860(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-10336 as u32) ) } as u64;
            }
            0x825BD7A0 => {
    //   block [0x825BD7A0..0x825BD7E0)
	// 825BD7A0: 89630001  lbz r11, 1(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BD7A4: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 825BD7A8: 895F0003  lbz r10, 3(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BD7AC: 396B0049  addi r11, r11, 0x49
	ctx.r[11].s64 = ctx.r[11].s64 + 73;
	// 825BD7B0: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD7B4: 7FEAFA14  add r31, r10, r31
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 825BD7B8: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BD7BC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BD7C0: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BD7C4: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 825BD7C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BD7CC: 419A0070  beq cr6, 0x825bd83c
	if ctx.cr[6].eq {
	pc = 0x825BD83C; continue 'dispatch;
	}
	// 825BD7D0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825BD7D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BD7D8: 4E800421  bctrl
	ctx.lr = 0x825BD7DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BD7DC: 48000060  b 0x825bd83c
	pc = 0x825BD83C; continue 'dispatch;
            }
            0x825BD7E0 => {
    //   block [0x825BD7E0..0x825BD834)
	// 825BD7E0: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 825BD7E4: D3FF000C  stfs f31, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 825BD7E8: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	pc = 0x825BD834; continue 'dispatch;
            }
            0x825BD834 => {
    //   block [0x825BD834..0x825BD83C)
	// 825BD834: 897F0003  lbz r11, 3(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BD838: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	pc = 0x825BD83C; continue 'dispatch;
            }
            0x825BD83C => {
    //   block [0x825BD83C..0x825BD864)
	// 825BD83C: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825BD840: 4198FF1C  blt cr6, 0x825bd75c
	if ctx.cr[6].lt {
	pc = 0x825BD75C; continue 'dispatch;
	}
	// 825BD844: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD848: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825BD84C: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 825BD850: 3BEB0010  addi r31, r11, 0x10
	ctx.r[31].s64 = ctx.r[11].s64 + 16;
	// 825BD854: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD858: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825BD85C: 3B8B0010  addi r28, r11, 0x10
	ctx.r[28].s64 = ctx.r[11].s64 + 16;
	// 825BD860: 4BFFFEFC  b 0x825bd75c
	pc = 0x825BD75C; continue 'dispatch;
            }
            0x825BD864 => {
    //   block [0x825BD864..0x825BD870)
	// 825BD864: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825BD868: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 825BD86C: 4BF77898  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BD870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BD870 size=380
    let mut pc: u32 = 0x825BD870;
    'dispatch: loop {
        match pc {
            0x825BD870 => {
    //   block [0x825BD870..0x825BD8BC)
	// 825BD870: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BD874: 4BF77841  bl 0x825350b4
	ctx.lr = 0x825BD878;
	sub_82535080(ctx, base);
	// 825BD878: DBA1FFB8  stfd f29, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[29].u64 ) };
	// 825BD87C: DBC1FFC0  stfd f30, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 825BD880: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 825BD884: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BD888: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825BD88C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 825BD890: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 825BD894: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 825BD898: 3BA00004  li r29, 4
	ctx.r[29].s64 = 4;
	// 825BD89C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD8A0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD8A4: 3BEB0010  addi r31, r11, 0x10
	ctx.r[31].s64 = ctx.r[11].s64 + 16;
	// 825BD8A8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD8AC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825BD8B0: 3B8B0010  addi r28, r11, 0x10
	ctx.r[28].s64 = ctx.r[11].s64 + 16;
	// 825BD8B4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825BD8B8: C3AB2074  lfs f29, 0x2074(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8308 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	pc = 0x825BD8BC; continue 'dispatch;
            }
            0x825BD8BC => {
    //   block [0x825BD8BC..0x825BD900)
	// 825BD8BC: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD8C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BD8C4: 2B0B0006  cmplwi cr6, r11, 6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 6 as u32, &mut ctx.xer);
	// 825BD8C8: 419900E8  bgt cr6, 0x825bd9b0
	if ctx.cr[6].gt {
	pc = 0x825BD9B0; continue 'dispatch;
	}
	// 825BD8CC: 3D80825C  lis r12, -0x7da4
	ctx.r[12].s64 = -2107899904;
	// 825BD8D0: 398CD8E4  addi r12, r12, -0x271c
	ctx.r[12].s64 = ctx.r[12].s64 + -10012;
	// 825BD8D4: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 825BD8D8: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 825BD8DC: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 825BD8E0: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x825BD9A8; continue 'dispatch;
		},
		1 => {
	pc = 0x825BD9D8; continue 'dispatch;
		},
		2 => {
	pc = 0x825BD900; continue 'dispatch;
		},
		3 => {
	pc = 0x825BD900; continue 'dispatch;
		},
		4 => {
	pc = 0x825BD948; continue 'dispatch;
		},
		5 => {
	pc = 0x825BD948; continue 'dispatch;
		},
		6 => {
	pc = 0x825BD900; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 825BD8E4: 825BD9A8  lwz r18, -0x2658(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9816 as u32) ) } as u64;
	// 825BD8E8: 825BD9D8  lwz r18, -0x2628(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9768 as u32) ) } as u64;
	// 825BD8EC: 825BD900  lwz r18, -0x2700(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9984 as u32) ) } as u64;
	// 825BD8F0: 825BD900  lwz r18, -0x2700(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9984 as u32) ) } as u64;
	// 825BD8F4: 825BD948  lwz r18, -0x26b8(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9912 as u32) ) } as u64;
	// 825BD8F8: 825BD948  lwz r18, -0x26b8(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9912 as u32) ) } as u64;
	// 825BD8FC: 825BD900  lwz r18, -0x2700(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9984 as u32) ) } as u64;
            }
            0x825BD900 => {
    //   block [0x825BD900..0x825BD948)
	// 825BD900: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BD904: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 825BD908: 89630001  lbz r11, 1(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BD90C: 7FE9FA14  add r31, r9, r31
	ctx.r[31].u64 = ctx.r[9].u64 + ctx.r[31].u64;
	// 825BD910: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD914: 5569103E  rotlwi r9, r11, 2
	ctx.r[9].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 825BD918: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825BD91C: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BD920: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BD924: 816B16D4  lwz r11, 0x16d4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5844 as u32) ) } as u64;
	// 825BD928: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BD92C: 419A0084  beq cr6, 0x825bd9b0
	if ctx.cr[6].eq {
	pc = 0x825BD9B0; continue 'dispatch;
	}
	// 825BD930: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 825BD934: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 825BD938: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825BD93C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BD940: 4E800421  bctrl
	ctx.lr = 0x825BD944;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BD944: 4800006C  b 0x825bd9b0
	pc = 0x825BD9B0; continue 'dispatch;
            }
            0x825BD948 => {
    //   block [0x825BD948..0x825BD960)
	// 825BD948: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BD94C: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 825BD950: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 825BD954: 409A000C  bne cr6, 0x825bd960
	if !ctx.cr[6].eq {
	pc = 0x825BD960; continue 'dispatch;
	}
	// 825BD958: D3DF000C  stfs f30, 0xc(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 825BD95C: 48000008  b 0x825bd964
	pc = 0x825BD964; continue 'dispatch;
            }
            0x825BD960 => {
    //   block [0x825BD960..0x825BD964)
	// 825BD960: D3BF000C  stfs f29, 0xc(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x825BD964; continue 'dispatch;
            }
            0x825BD964 => {
    //   block [0x825BD964..0x825BD9A8)
	// 825BD964: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BD968: 89630001  lbz r11, 1(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BD96C: 7FE9FA14  add r31, r9, r31
	ctx.r[31].u64 = ctx.r[9].u64 + ctx.r[31].u64;
	// 825BD970: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD974: 5569103E  rotlwi r9, r11, 2
	ctx.r[9].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 825BD978: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825BD97C: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BD980: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BD984: 816B16D4  lwz r11, 0x16d4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5844 as u32) ) } as u64;
	// 825BD988: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BD98C: 419A0024  beq cr6, 0x825bd9b0
	if ctx.cr[6].eq {
	pc = 0x825BD9B0; continue 'dispatch;
	}
	// 825BD990: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 825BD994: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 825BD998: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825BD99C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BD9A0: 4E800421  bctrl
	ctx.lr = 0x825BD9A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BD9A4: 4800000C  b 0x825bd9b0
	pc = 0x825BD9B0; continue 'dispatch;
            }
            0x825BD9A8 => {
    //   block [0x825BD9A8..0x825BD9B0)
	// 825BD9A8: 897F0003  lbz r11, 3(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BD9AC: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	pc = 0x825BD9B0; continue 'dispatch;
            }
            0x825BD9B0 => {
    //   block [0x825BD9B0..0x825BD9D8)
	// 825BD9B0: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825BD9B4: 4198FF08  blt cr6, 0x825bd8bc
	if ctx.cr[6].lt {
	pc = 0x825BD8BC; continue 'dispatch;
	}
	// 825BD9B8: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD9BC: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 825BD9C0: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 825BD9C4: 3BEB0010  addi r31, r11, 0x10
	ctx.r[31].s64 = ctx.r[11].s64 + 16;
	// 825BD9C8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD9CC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825BD9D0: 3B8B0010  addi r28, r11, 0x10
	ctx.r[28].s64 = ctx.r[11].s64 + 16;
	// 825BD9D4: 4BFFFEE8  b 0x825bd8bc
	pc = 0x825BD8BC; continue 'dispatch;
            }
            0x825BD9D8 => {
    //   block [0x825BD9D8..0x825BD9EC)
	// 825BD9D8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825BD9DC: CBA1FFB8  lfd f29, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 825BD9E0: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 825BD9E4: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 825BD9E8: 4BF7771C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BD9F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825BD9F0 size=204
    let mut pc: u32 = 0x825BD9F0;
    'dispatch: loop {
        match pc {
            0x825BD9F0 => {
    //   block [0x825BD9F0..0x825BDA08)
	// 825BD9F0: F8810018  std r4, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.r[4].u64 ) };
	// 825BD9F4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD9F8: 392A0004  addi r9, r10, 4
	ctx.r[9].s64 = ctx.r[10].s64 + 4;
	// 825BD9FC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDA00: 80E1001C  lwz r7, 0x1c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 825BDA04: 80C10018  lwz r6, 0x18(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(24 as u32) ) } as u64;
	pc = 0x825BDA08; continue 'dispatch;
            }
            0x825BDA08 => {
    //   block [0x825BDA08..0x825BDA18)
	// 825BDA08: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDA0C: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 825BDA10: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825BDA14: 390B0010  addi r8, r11, 0x10
	ctx.r[8].s64 = ctx.r[11].s64 + 16;
	pc = 0x825BDA18; continue 'dispatch;
            }
            0x825BDA18 => {
    //   block [0x825BDA18..0x825BDA58)
	// 825BDA18: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDA1C: 2B0B0006  cmplwi cr6, r11, 6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 6 as u32, &mut ctx.xer);
	// 825BDA20: 41990078  bgt cr6, 0x825bda98
	if ctx.cr[6].gt {
	pc = 0x825BDA98; continue 'dispatch;
	}
	// 825BDA24: 3D80825C  lis r12, -0x7da4
	ctx.r[12].s64 = -2107899904;
	// 825BDA28: 398CDA3C  addi r12, r12, -0x25c4
	ctx.r[12].s64 = ctx.r[12].s64 + -9668;
	// 825BDA2C: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 825BDA30: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 825BDA34: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 825BDA38: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x825BDA90; continue 'dispatch;
		},
		1 => {
	pc = 0x825BDAB4; continue 'dispatch;
		},
		2 => {
	pc = 0x825BDA58; continue 'dispatch;
		},
		3 => {
	pc = 0x825BDA58; continue 'dispatch;
		},
		4 => {
	pc = 0x825BDA60; continue 'dispatch;
		},
		5 => {
	pc = 0x825BDA60; continue 'dispatch;
		},
		6 => {
	pc = 0x825BDA58; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 825BDA3C: 825BDA90  lwz r18, -0x2570(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9584 as u32) ) } as u64;
	// 825BDA40: 825BDAB4  lwz r18, -0x254c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 825BDA44: 825BDA58  lwz r18, -0x25a8(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9640 as u32) ) } as u64;
	// 825BDA48: 825BDA58  lwz r18, -0x25a8(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9640 as u32) ) } as u64;
	// 825BDA4C: 825BDA60  lwz r18, -0x25a0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9632 as u32) ) } as u64;
	// 825BDA50: 825BDA60  lwz r18, -0x25a0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9632 as u32) ) } as u64;
	// 825BDA54: 825BDA58  lwz r18, -0x25a8(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9640 as u32) ) } as u64;
            }
            0x825BDA58 => {
    //   block [0x825BDA58..0x825BDA60)
	// 825BDA58: 39430010  addi r10, r3, 0x10
	ctx.r[10].s64 = ctx.r[3].s64 + 16;
	// 825BDA5C: 48000008  b 0x825bda64
	pc = 0x825BDA64; continue 'dispatch;
            }
            0x825BDA60 => {
    //   block [0x825BDA60..0x825BDA64)
	// 825BDA60: 39430020  addi r10, r3, 0x20
	ctx.r[10].s64 = ctx.r[3].s64 + 32;
	pc = 0x825BDA64; continue 'dispatch;
            }
            0x825BDA64 => {
    //   block [0x825BDA64..0x825BDA80)
	// 825BDA64: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BDA68: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825BDA6C: 409A0014  bne cr6, 0x825bda80
	if !ctx.cr[6].eq {
	pc = 0x825BDA80; continue 'dispatch;
	}
	// 825BDA70: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BDA74: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825BDA78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825BDA7C: 419A0008  beq cr6, 0x825bda84
	if ctx.cr[6].eq {
	pc = 0x825BDA84; continue 'dispatch;
	}
	pc = 0x825BDA80; continue 'dispatch;
            }
            0x825BDA80 => {
    //   block [0x825BDA80..0x825BDA84)
	// 825BDA80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825BDA84; continue 'dispatch;
            }
            0x825BDA84 => {
    //   block [0x825BDA84..0x825BDA90)
	// 825BDA84: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BDA88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BDA8C: 409A0020  bne cr6, 0x825bdaac
	if !ctx.cr[6].eq {
	pc = 0x825BDAAC; continue 'dispatch;
	}
	pc = 0x825BDA90; continue 'dispatch;
            }
            0x825BDA90 => {
    //   block [0x825BDA90..0x825BDA98)
	// 825BDA90: 89630003  lbz r11, 3(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BDA94: 7C6B1A14  add r3, r11, r3
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	pc = 0x825BDA98; continue 'dispatch;
            }
            0x825BDA98 => {
    //   block [0x825BDA98..0x825BDAAC)
	// 825BDA98: 7F034040  cmplw cr6, r3, r8
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825BDA9C: 4198FF7C  blt cr6, 0x825bda18
	if ctx.cr[6].lt {
	pc = 0x825BDA18; continue 'dispatch;
	}
	// 825BDAA0: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDAA4: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 825BDAA8: 4BFFFF60  b 0x825bda08
	pc = 0x825BDA08; continue 'dispatch;
            }
            0x825BDAAC => {
    //   block [0x825BDAAC..0x825BDAB4)
	// 825BDAAC: 91450000  stw r10, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BDAB0: 4E800020  blr
	return;
            }
            0x825BDAB4 => {
    //   block [0x825BDAB4..0x825BDABC)
	// 825BDAB4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825BDAB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BDAC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825BDAC0 size=528
    let mut pc: u32 = 0x825BDAC0;
    'dispatch: loop {
        match pc {
            0x825BDAC0 => {
    //   block [0x825BDAC0..0x825BDAF0)
	// 825BDAC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BDAC4: 4BF775DD  bl 0x825350a0
	ctx.lr = 0x825BDAC8;
	sub_82535080(ctx, base);
	// 825BDAC8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BDACC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 825BDAD0: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 825BDAD4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825BDAD8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825BDADC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825BDAE0: 83190000  lwz r24, 0(r25)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDAE4: 7ED7B378  mr r23, r22
	ctx.r[23].u64 = ctx.r[22].u64;
	// 825BDAE8: 7EDBB378  mr r27, r22
	ctx.r[27].u64 = ctx.r[22].u64;
	// 825BDAEC: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825BDAF0; continue 'dispatch;
            }
            0x825BDAF0 => {
    //   block [0x825BDAF0..0x825BDB00)
	// 825BDAF0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDAF4: 3BEB0010  addi r31, r11, 0x10
	ctx.r[31].s64 = ctx.r[11].s64 + 16;
	// 825BDAF8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825BDAFC: 3B4B0010  addi r26, r11, 0x10
	ctx.r[26].s64 = ctx.r[11].s64 + 16;
	pc = 0x825BDB00; continue 'dispatch;
            }
            0x825BDB00 => {
    //   block [0x825BDB00..0x825BDB44)
	// 825BDB00: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDB04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BDB08: 2B0B0006  cmplwi cr6, r11, 6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 6 as u32, &mut ctx.xer);
	// 825BDB0C: 419900B8  bgt cr6, 0x825bdbc4
	if ctx.cr[6].gt {
	pc = 0x825BDBC4; continue 'dispatch;
	}
	// 825BDB10: 3D80825C  lis r12, -0x7da4
	ctx.r[12].s64 = -2107899904;
	// 825BDB14: 398CDB28  addi r12, r12, -0x24d8
	ctx.r[12].s64 = ctx.r[12].s64 + -9432;
	// 825BDB18: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 825BDB1C: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 825BDB20: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 825BDB24: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x825BDBBC; continue 'dispatch;
		},
		1 => {
	pc = 0x825BDC34; continue 'dispatch;
		},
		2 => {
	pc = 0x825BDB44; continue 'dispatch;
		},
		3 => {
	pc = 0x825BDB44; continue 'dispatch;
		},
		4 => {
	pc = 0x825BDB80; continue 'dispatch;
		},
		5 => {
	pc = 0x825BDB80; continue 'dispatch;
		},
		6 => {
	pc = 0x825BDB44; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 825BDB28: 825BDBBC  lwz r18, -0x2444(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9284 as u32) ) } as u64;
	// 825BDB2C: 825BDC34  lwz r18, -0x23cc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9164 as u32) ) } as u64;
	// 825BDB30: 825BDB44  lwz r18, -0x24bc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 825BDB34: 825BDB44  lwz r18, -0x24bc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 825BDB38: 825BDB80  lwz r18, -0x2480(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9344 as u32) ) } as u64;
	// 825BDB3C: 825BDB80  lwz r18, -0x2480(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9344 as u32) ) } as u64;
	// 825BDB40: 825BDB44  lwz r18, -0x24bc(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-9404 as u32) ) } as u64;
            }
            0x825BDB44 => {
    //   block [0x825BDB44..0x825BDB80)
	// 825BDB44: 895F0003  lbz r10, 3(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BDB48: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 825BDB4C: 89630001  lbz r11, 1(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BDB50: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 825BDB54: 7FEAFA14  add r31, r10, r31
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 825BDB58: 556A103E  rotlwi r10, r11, 2
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 825BDB5C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825BDB60: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BDB64: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825BDB68: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BDB6C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 825BDB70: 816B16B4  lwz r11, 0x16b4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5812 as u32) ) } as u64;
	// 825BDB74: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BDB78: 4E800421  bctrl
	ctx.lr = 0x825BDB7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BDB7C: 48000048  b 0x825bdbc4
	pc = 0x825BDBC4; continue 'dispatch;
            }
            0x825BDB80 => {
    //   block [0x825BDB80..0x825BDBBC)
	// 825BDB80: 895F0003  lbz r10, 3(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BDB84: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 825BDB88: 89630001  lbz r11, 1(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BDB8C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 825BDB90: 7FEAFA14  add r31, r10, r31
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 825BDB94: 556A103E  rotlwi r10, r11, 2
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 825BDB98: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825BDB9C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BDBA0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825BDBA4: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BDBA8: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 825BDBAC: 816B16B4  lwz r11, 0x16b4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5812 as u32) ) } as u64;
	// 825BDBB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BDBB4: 4E800421  bctrl
	ctx.lr = 0x825BDBB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BDBB8: 4800000C  b 0x825bdbc4
	pc = 0x825BDBC4; continue 'dispatch;
            }
            0x825BDBBC => {
    //   block [0x825BDBBC..0x825BDBC4)
	// 825BDBBC: 897F0003  lbz r11, 3(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BDBC0: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	pc = 0x825BDBC4; continue 'dispatch;
            }
            0x825BDBC4 => {
    //   block [0x825BDBC4..0x825BDC10)
	// 825BDBC4: 7F1FD040  cmplw cr6, r31, r26
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[26].u32, &mut ctx.xer);
	// 825BDBC8: 4198FF38  blt cr6, 0x825bdb00
	if ctx.cr[6].lt {
	pc = 0x825BDB00; continue 'dispatch;
	}
	// 825BDBCC: 7CBBC02E  lwzx r5, r27, r24
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 825BDBD0: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 825BDBD4: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 825BDBD8: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 825BDBDC: 419A004C  beq cr6, 0x825bdc28
	if ctx.cr[6].eq {
	pc = 0x825BDC28; continue 'dispatch;
	}
	// 825BDBE0: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDBE4: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 825BDBE8: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825BDBEC: 8163009C  lwz r11, 0x9c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(156 as u32) ) } as u64;
	// 825BDBF0: 81430034  lwz r10, 0x34(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 825BDBF4: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825BDBF8: 41980018  blt cr6, 0x825bdc10
	if ctx.cr[6].lt {
	pc = 0x825BDC10; continue 'dispatch;
	}
	// 825BDBFC: 3880000C  li r4, 0xc
	ctx.r[4].s64 = 12;
	// 825BDC00: 4BEA6319  bl 0x82463f18
	ctx.lr = 0x825BDC04;
	sub_82463F18(ctx, base);
	// 825BDC04: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDC08: 7D6BD82E  lwzx r11, r11, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 825BDC0C: 4BFFFEE4  b 0x825bdaf0
	pc = 0x825BDAF0; continue 'dispatch;
            }
            0x825BDC10 => {
    //   block [0x825BDC10..0x825BDC28)
	// 825BDC10: 8163009C  lwz r11, 0x9c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(156 as u32) ) } as u64;
	// 825BDC14: 81430098  lwz r10, 0x98(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(152 as u32) ) } as u64;
	// 825BDC18: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825BDC1C: 9163009C  stw r11, 0x9c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 825BDC20: 91450000  stw r10, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BDC24: 90A30098  stw r5, 0x98(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), ctx.r[5].u32 ) };
	pc = 0x825BDC28; continue 'dispatch;
            }
            0x825BDC28 => {
    //   block [0x825BDC28..0x825BDC34)
	// 825BDC28: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDC2C: 7D6BD82E  lwzx r11, r11, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 825BDC30: 4BFFFEC0  b 0x825bdaf0
	pc = 0x825BDAF0; continue 'dispatch;
            }
            0x825BDC34 => {
    //   block [0x825BDC34..0x825BDC6C)
	// 825BDC34: 56EB103A  slwi r11, r23, 2
	ctx.r[11].u32 = ctx.r[23].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BDC38: 7CABC02E  lwzx r5, r11, r24
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 825BDC3C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 825BDC40: 419A0044  beq cr6, 0x825bdc84
	if ctx.cr[6].eq {
	pc = 0x825BDC84; continue 'dispatch;
	}
	// 825BDC44: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDC48: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 825BDC4C: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825BDC50: 8163009C  lwz r11, 0x9c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(156 as u32) ) } as u64;
	// 825BDC54: 81430034  lwz r10, 0x34(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 825BDC58: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825BDC5C: 41980010  blt cr6, 0x825bdc6c
	if ctx.cr[6].lt {
	pc = 0x825BDC6C; continue 'dispatch;
	}
	// 825BDC60: 3880000C  li r4, 0xc
	ctx.r[4].s64 = 12;
	// 825BDC64: 4BEA62B5  bl 0x82463f18
	ctx.lr = 0x825BDC68;
	sub_82463F18(ctx, base);
	// 825BDC68: 4800001C  b 0x825bdc84
	pc = 0x825BDC84; continue 'dispatch;
            }
            0x825BDC6C => {
    //   block [0x825BDC6C..0x825BDC84)
	// 825BDC6C: 8163009C  lwz r11, 0x9c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(156 as u32) ) } as u64;
	// 825BDC70: 81430098  lwz r10, 0x98(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(152 as u32) ) } as u64;
	// 825BDC74: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825BDC78: 9163009C  stw r11, 0x9c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 825BDC7C: 91450000  stw r10, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BDC80: 90A30098  stw r5, 0x98(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), ctx.r[5].u32 ) };
	pc = 0x825BDC84; continue 'dispatch;
            }
            0x825BDC84 => {
    //   block [0x825BDC84..0x825BDCB0)
	// 825BDC84: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BDC88: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825BDC8C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825BDC90: 409A0020  bne cr6, 0x825bdcb0
	if !ctx.cr[6].eq {
	pc = 0x825BDCB0; continue 'dispatch;
	}
	// 825BDC94: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDC98: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 825BDC9C: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 825BDCA0: 80990000  lwz r4, 0(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDCA4: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 825BDCA8: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825BDCAC: 4BEA640D  bl 0x824640b8
	ctx.lr = 0x825BDCB0;
	sub_824640B8(ctx, base);
	pc = 0x825BDCB0; continue 'dispatch;
            }
            0x825BDCB0 => {
    //   block [0x825BDCB0..0x825BDCD0)
	// 825BDCB0: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BDCB4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825BDCB8: 92D90000  stw r22, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[22].u32 ) };
	// 825BDCBC: 514BF880  rlwimi r11, r10, 0x1f, 2, 0
	ctx.r[11].u64 = (((ctx.r[10].u32).rotate_left(31) as u64) & 0xFFFFFFFFBFFFFFFF) | (ctx.r[11].u64 & 0x0000000040000000);
	// 825BDCC0: 92D90004  stw r22, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[22].u32 ) };
	// 825BDCC4: 91790008  stw r11, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825BDCC8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825BDCCC: 4BF77424  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BDCD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825BDCD0 size=272
    let mut pc: u32 = 0x825BDCD0;
    'dispatch: loop {
        match pc {
            0x825BDCD0 => {
    //   block [0x825BDCD0..0x825BDD10)
	// 825BDCD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BDCD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825BDCD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825BDCDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825BDCE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BDCE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825BDCE8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825BDCEC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BDCF0: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 825BDCF4: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825BDCF8: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 825BDCFC: 40980024  bge cr6, 0x825bdd20
	if !ctx.cr[6].lt {
	pc = 0x825BDD20; continue 'dispatch;
	}
	// 825BDD00: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BDD04: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 825BDD08: 41990008  bgt cr6, 0x825bdd10
	if ctx.cr[6].gt {
	pc = 0x825BDD10; continue 'dispatch;
	}
	// 825BDD0C: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	pc = 0x825BDD10; continue 'dispatch;
            }
            0x825BDD10 => {
    //   block [0x825BDD10..0x825BDD20)
	// 825BDD10: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 825BDD14: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 825BDD18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BDD1C: 4BEB05AD  bl 0x8246e2c8
	ctx.lr = 0x825BDD20;
	sub_8246E2C8(ctx, base);
	pc = 0x825BDD20; continue 'dispatch;
            }
            0x825BDD20 => {
    //   block [0x825BDD20..0x825BDD40)
	// 825BDD20: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BDD24: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BDD28: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825BDD2C: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825BDD30: 409A0010  bne cr6, 0x825bdd40
	if !ctx.cr[6].eq {
	pc = 0x825BDD40; continue 'dispatch;
	}
	// 825BDD34: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 825BDD38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BDD3C: 4BEB0615  bl 0x8246e350
	ctx.lr = 0x825BDD40;
	sub_8246E350(ctx, base);
	pc = 0x825BDD40; continue 'dispatch;
            }
            0x825BDD40 => {
    //   block [0x825BDD40..0x825BDD7C)
	// 825BDD40: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BDD44: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 825BDD48: 812D0000  lwz r9, 0(r13)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDD4C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825BDD50: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825BDD54: 7D4A482E  lwzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 825BDD58: 816A0098  lwz r11, 0x98(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(152 as u32) ) } as u64;
	// 825BDD5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BDD60: 419A001C  beq cr6, 0x825bdd7c
	if ctx.cr[6].eq {
	pc = 0x825BDD7C; continue 'dispatch;
	}
	// 825BDD64: 812A009C  lwz r9, 0x9c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) } as u64;
	// 825BDD68: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 825BDD6C: 912A009C  stw r9, 0x9c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(156 as u32), ctx.r[9].u32 ) };
	// 825BDD70: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDD74: 912A0098  stw r9, 0x98(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(152 as u32), ctx.r[9].u32 ) };
	// 825BDD78: 48000014  b 0x825bdd8c
	pc = 0x825BDD8C; continue 'dispatch;
            }
            0x825BDD7C => {
    //   block [0x825BDD7C..0x825BDD8C)
	// 825BDD7C: 3880000C  li r4, 0xc
	ctx.r[4].s64 = 12;
	// 825BDD80: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 825BDD84: 4BEA60BD  bl 0x82463e40
	ctx.lr = 0x825BDD88;
	sub_82463E40(ctx, base);
	// 825BDD88: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x825BDD8C; continue 'dispatch;
            }
            0x825BDD8C => {
    //   block [0x825BDD8C..0x825BDD9C)
	// 825BDD8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BDD90: 419A000C  beq cr6, 0x825bdd9c
	if ctx.cr[6].eq {
	pc = 0x825BDD9C; continue 'dispatch;
	}
	// 825BDD94: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825BDD98: 48000008  b 0x825bdda0
	pc = 0x825BDDA0; continue 'dispatch;
            }
            0x825BDD9C => {
    //   block [0x825BDD9C..0x825BDDA0)
	// 825BDD9C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x825BDDA0; continue 'dispatch;
            }
            0x825BDDA0 => {
    //   block [0x825BDDA0..0x825BDDE0)
	// 825BDDA0: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDDA4: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 825BDDA8: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 825BDDAC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825BDDB0: 91680000  stw r11, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825BDDB4: 992B0013  stb r9, 0x13(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(19 as u32), ctx.r[9].u8 ) };
	// 825BDDB8: 98EB0010  stb r7, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[7].u8 ) };
	// 825BDDBC: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 825BDDC0: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 825BDDC4: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825BDDC8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825BDDCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825BDDD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825BDDD4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825BDDD8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825BDDDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BDDE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825BDDE0 size=120
    let mut pc: u32 = 0x825BDDE0;
    'dispatch: loop {
        match pc {
            0x825BDDE0 => {
    //   block [0x825BDDE0..0x825BDE58)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BDE58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825BDE58 size=116
    let mut pc: u32 = 0x825BDE58;
    'dispatch: loop {
        match pc {
            0x825BDE58 => {
    //   block [0x825BDE58..0x825BDE74)
	// 825BDE58: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825BDE5C: C14B2968  lfs f10, 0x2968(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10600 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825BDE60: FF0C5000  fcmpu cr6, f12, f10
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[10].f64);
	// 825BDE64: 40990010  ble cr6, 0x825bde74
	if !ctx.cr[6].gt {
	pc = 0x825BDE74; continue 'dispatch;
	}
	// 825BDE68: 81670020  lwz r11, 0x20(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(32 as u32) ) } as u64;
	// 825BDE6C: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 825BDE70: 419AFFE0  beq cr6, 0x825bde50
	if ctx.cr[6].eq {
		sub_825BDDE0(ctx, base);
		return;
	}
	pc = 0x825BDE74; continue 'dispatch;
            }
            0x825BDE74 => {
    //   block [0x825BDE74..0x825BDECC)
	// 825BDE74: 81470020  lwz r10, 0x20(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(32 as u32) ) } as u64;
	// 825BDE78: 2B0AFFFF  cmplwi cr6, r10, 0xffff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 65535 as u32, &mut ctx.xer);
	// 825BDE7C: 409A0050  bne cr6, 0x825bdecc
	if !ctx.cr[6].eq {
		sub_825BDECC(ctx, base);
		return;
	}
	// 825BDE80: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825BDE84: C14B207C  lfs f10, 0x207c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8316 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825BDE88: FF0C5000  fcmpu cr6, f12, f10
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[10].f64);
	// 825BDE8C: 40980040  bge cr6, 0x825bdecc
	if !ctx.cr[6].lt {
		sub_825BDECC(ctx, base);
		return;
	}
	// 825BDE90: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 825BDE94: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825BDE98: C00B8E30  lfs f0, -0x71d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BDE9C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825BDEA0: 4098002C  bge cr6, 0x825bdecc
	if !ctx.cr[6].lt {
		sub_825BDECC(ctx, base);
		return;
	}
	// 825BDEA4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825BDEA8: C1A4001C  lfs f13, 0x1c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825BDEAC: C187001C  lfs f12, 0x1c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825BDEB0: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 825BDEB4: C00B24DC  lfs f0, 0x24dc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9436 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BDEB8: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 825BDEBC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825BDEC0: 4098000C  bge cr6, 0x825bdecc
	if !ctx.cr[6].lt {
		sub_825BDECC(ctx, base);
		return;
	}
	// 825BDEC4: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 825BDEC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BDECC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825BDECC size=64
    let mut pc: u32 = 0x825BDECC;
    'dispatch: loop {
        match pc {
            0x825BDECC => {
    //   block [0x825BDECC..0x825BDEEC)
	// 825BDECC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825BDED0: 2B0AFFFF  cmplwi cr6, r10, 0xffff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 65535 as u32, &mut ctx.xer);
	// 825BDED4: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BDED8: 419A0014  beq cr6, 0x825bdeec
	if ctx.cr[6].eq {
	pc = 0x825BDEEC; continue 'dispatch;
	}
	// 825BDEDC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825BDEE0: C1A50000  lfs f13, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825BDEE4: C00B2954  lfs f0, 0x2954(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10580 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BDEE8: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x825BDEEC; continue 'dispatch;
            }
            0x825BDEEC => {
    //   block [0x825BDEEC..0x825BDF0C)
	// 825BDEEC: C1A7001C  lfs f13, 0x1c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825BDEF0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825BDEF4: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 825BDEF8: C1A4001C  lfs f13, 0x1c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825BDEFC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825BDF00: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 825BDF04: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825BDF08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BDF10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BDF10 size=1780
    let mut pc: u32 = 0x825BDF10;
    'dispatch: loop {
        match pc {
            0x825BDF10 => {
    //   block [0x825BDF10..0x825BE0C8)
	// 825BDF10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BDF14: 4BF7716D  bl 0x82535080
	ctx.lr = 0x825BDF18;
	sub_82535080(ctx, base);
	// 825BDF18: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 825BDF1C: 4BF780C1  bl 0x82535fdc
	ctx.lr = 0x825BDF20;
	sub_82535FB0(ctx, base);
	// 825BDF20: 9421F6B0  stwu r1, -0x950(r1)
	ea = ctx.r[1].u32.wrapping_add(-2384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BDF24: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 825BDF28: 7CB12B78  mr r17, r5
	ctx.r[17].u64 = ctx.r[5].u64;
	// 825BDF2C: 7C922378  mr r18, r4
	ctx.r[18].u64 = ctx.r[4].u64;
	// 825BDF30: 3A600000  li r19, 0
	ctx.r[19].s64 = 0;
	// 825BDF34: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 825BDF38: 81740000  lwz r11, 0(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDF3C: 39C00010  li r14, 0x10
	ctx.r[14].s64 = 16;
	// 825BDF40: 82D13080  lwz r22, 0x3080(r17)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(12416 as u32) ) } as u64;
	// 825BDF44: 9241096C  stw r18, 0x96c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(2412 as u32), ctx.r[18].u32 ) };
	// 825BDF48: 92210974  stw r17, 0x974(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(2420 as u32), ctx.r[17].u32 ) };
	// 825BDF4C: 834B0000  lwz r26, 0(r11)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDF50: 39760408  addi r11, r22, 0x408
	ctx.r[11].s64 = ctx.r[22].s64 + 1032;
	// 825BDF54: 81560000  lwz r10, 0(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDF58: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 825BDF5C: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825BDF60: 4098023C  bge cr6, 0x825be19c
	if !ctx.cr[6].lt {
	pc = 0x825BE19C; continue 'dispatch;
	}
	// 825BDF64: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 825BDF68: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 825BDF6C: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 825BDF70: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 825BDF74: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 825BDF78: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 825BDF7C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 825BDF80: C3252954  lfs f25, 0x2954(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(10580 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 825BDF84: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825BDF88: C3461FF8  lfs f26, 0x1ff8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8184 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 825BDF8C: C36724DC  lfs f27, 0x24dc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(9436 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 825BDF90: 3B360008  addi r25, r22, 8
	ctx.r[25].s64 = ctx.r[22].s64 + 8;
	// 825BDF94: C3C88E30  lfs f30, -0x71d0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-29136 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825BDF98: 3B160004  addi r24, r22, 4
	ctx.r[24].s64 = ctx.r[22].s64 + 4;
	// 825BDF9C: C389207C  lfs f28, 0x207c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8316 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 825BDFA0: 3B940008  addi r28, r20, 8
	ctx.r[28].s64 = ctx.r[20].s64 + 8;
	// 825BDFA4: C3AA2968  lfs f29, 0x2968(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10600 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 825BDFA8: 3BC10280  addi r30, r1, 0x280
	ctx.r[30].s64 = ctx.r[1].s64 + 640;
	// 825BDFAC: C3EB1850  lfs f31, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825BDFB0: 3AA10080  addi r21, r1, 0x80
	ctx.r[21].s64 = ctx.r[1].s64 + 128;
	// 825BDFB4: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 825BDFB8: 80D80000  lwz r6, 0(r24)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDFBC: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 825BDFC0: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDFC4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825BDFC8: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825BDFCC: B17E0000  sth r11, 0(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 825BDFD0: 40980104  bge cr6, 0x825be0d4
	if !ctx.cr[6].lt {
	pc = 0x825BE0D4; continue 'dispatch;
	}
	// 825BDFD4: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDFD8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825BDFDC: 419A00EC  beq cr6, 0x825be0c8
	if ctx.cr[6].eq {
	pc = 0x825BE0C8; continue 'dispatch;
	}
	pc = 0x825BE0C8; continue 'dispatch;
            }
            0x825BE0C8 => {
    //   block [0x825BE0C8..0x825BE0D4)
	// 825BE0C8: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 825BE0CC: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825BE0D0: 4198FF04  blt cr6, 0x825bdfd4
	if ctx.cr[6].lt {
	pc = 0x825BDFD4; continue 'dispatch;
	}
	pc = 0x825BE0D4; continue 'dispatch;
            }
            0x825BE0D4 => {
    //   block [0x825BE0D4..0x825BE19C)
	// 825BE0D4: 7CAB0774  extsb r11, r5
	ctx.r[11].s64 = ctx.r[5].s8 as i64;
	// 825BE0D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825BE0DC: 419A0010  beq cr6, 0x825be0ec
	if ctx.cr[6].eq {
	pc = 0x825BE0EC; continue 'dispatch;
	}
	// 825BE0E0: B2F50000  sth r23, 0(r21)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[23].u16 ) };
	// 825BE0E4: 3A730001  addi r19, r19, 1
	ctx.r[19].s64 = ctx.r[19].s64 + 1;
	// 825BE0E8: 3AB50002  addi r21, r21, 2
	ctx.r[21].s64 = ctx.r[21].s64 + 2;
	// 825BE0EC: 83FD0004  lwz r31, 4(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BE0F0: 38A10480  addi r5, r1, 0x480
	ctx.r[5].s64 = ctx.r[1].s64 + 1152;
	// 825BE0F4: 81720000  lwz r11, 0(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE0F8: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 825BE0FC: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BE100: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BE104: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BE108: 4E800421  bctrl
	ctx.lr = 0x825BE10C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BE10C: 81740004  lwz r11, 4(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BE110: 8154000C  lwz r10, 0xc(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BE114: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825BE118: 80DC0000  lwz r6, 0(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE11C: 7E278B78  mr r7, r17
	ctx.r[7].u64 = ctx.r[17].u64;
	// 825BE120: 80940000  lwz r4, 0(r20)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE124: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 825BE128: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 825BE12C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BE130: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 825BE134: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BE138: 90610070  stw r3, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[3].u32 ) };
	// 825BE13C: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 825BE140: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 825BE144: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE148: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE14C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BE150: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BE154: 4E800421  bctrl
	ctx.lr = 0x825BE158;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BE158: 546B043E  clrlwi r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 825BE15C: B07E0000  sth r3, 0(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u16 ) };
	// 825BE160: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 825BE164: 419A001C  beq cr6, 0x825be180
	if ctx.cr[6].eq {
	pc = 0x825BE180; continue 'dispatch;
	}
	// 825BE168: 8074000C  lwz r3, 0xc(r20)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BE16C: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 825BE170: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE174: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BE178: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BE17C: 4E800421  bctrl
	ctx.lr = 0x825BE180;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BE180: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE184: 3B7B000C  addi r27, r27, 0xc
	ctx.r[27].s64 = ctx.r[27].s64 + 12;
	// 825BE188: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 825BE18C: 3BBD000C  addi r29, r29, 0xc
	ctx.r[29].s64 = ctx.r[29].s64 + 12;
	// 825BE190: 3BDE0002  addi r30, r30, 2
	ctx.r[30].s64 = ctx.r[30].s64 + 2;
	// 825BE194: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825BE198: 4198FE1C  blt cr6, 0x825bdfb4
	if ctx.cr[6].lt {
	pc = 0x825BDFB4; continue 'dispatch;
	}
            }
            0x825BE19C => {
    //   block [0x825BE19C..0x825BE604)
	// 825BE19C: 81740008  lwz r11, 8(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BE1A0: 3A540008  addi r18, r20, 8
	ctx.r[18].s64 = ctx.r[20].s64 + 8;
	// 825BE1A4: 2F130000  cmpwi cr6, r19, 0
	ctx.cr[6].compare_i32(ctx.r[19].s32, 0, &mut ctx.xer);
	// 825BE1A8: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE1AC: 40990060  ble cr6, 0x825be20c
	if !ctx.cr[6].gt {
	pc = 0x825BE20C; continue 'dispatch;
	}
	// 825BE1B0: 3BC10080  addi r30, r1, 0x80
	ctx.r[30].s64 = ctx.r[1].s64 + 128;
	// 825BE1B4: 7E7F9B78  mr r31, r19
	ctx.r[31].u64 = ctx.r[19].u64;
	// 825BE1B8: A17E0000  lhz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE1BC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825BE1C0: 396B0056  addi r11, r11, 0x56
	ctx.r[11].s64 = ctx.r[11].s64 + 86;
	// 825BE1C4: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BE1C8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BE1CC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BE1D0: 7D6BB214  add r11, r11, r22
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[22].u64;
	// 825BE1D4: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BE1D8: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BE1DC: 89630001  lbz r11, 1(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BE1E0: 556A103E  rotlwi r10, r11, 2
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 825BE1E4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BE1E8: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BE1EC: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 825BE1F0: 816B16C4  lwz r11, 0x16c4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5828 as u32) ) } as u64;
	// 825BE1F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BE1F8: 4E800421  bctrl
	ctx.lr = 0x825BE1FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BE1FC: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 825BE200: 3BDE0002  addi r30, r30, 2
	ctx.r[30].s64 = ctx.r[30].s64 + 2;
	// 825BE204: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825BE208: 409AFFB0  bne cr6, 0x825be1b8
	if !ctx.cr[6].eq {
	pc = 0x825BE1B8; continue 'dispatch;
	}
	// 825BE20C: 2F130002  cmpwi cr6, r19, 2
	ctx.cr[6].compare_i32(ctx.r[19].s32, 2, &mut ctx.xer);
	// 825BE210: 41980290  blt cr6, 0x825be4a0
	if ctx.cr[6].lt {
	pc = 0x825BE4A0; continue 'dispatch;
	}
	// 825BE214: 566B083C  slwi r11, r19, 1
	ctx.r[11].u32 = ctx.r[19].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BE218: 810D0000  lwz r8, 0(r13)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE21C: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 825BE220: 39200014  li r9, 0x14
	ctx.r[9].s64 = 20;
	// 825BE224: 7EAB5214  add r21, r11, r10
	ctx.r[21].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BE228: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825BE22C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 825BE230: 3A0B74DC  addi r16, r11, 0x74dc
	ctx.r[16].s64 = ctx.r[11].s64 + 29916;
	// 825BE234: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825BE238: 7E294214  add r17, r9, r8
	ctx.r[17].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 825BE23C: 39EBA340  addi r15, r11, -0x5cc0
	ctx.r[15].s64 = ctx.r[11].s64 + -23744;
	// 825BE240: C3EA2068  lfs f31, 0x2068(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8296 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825BE244: 81510000  lwz r10, 0(r17)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE248: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BE24C: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BE250: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825BE254: 40980018  bge cr6, 0x825be26c
	if !ctx.cr[6].lt {
	pc = 0x825BE26C; continue 'dispatch;
	}
	// 825BE258: 91EB0000  stw r15, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[15].u32 ) };
	// 825BE25C: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 825BE260: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 825BE264: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825BE268: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 825BE26C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825BE270: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 825BE274: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825BE278: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825BE27C: 2F130000  cmpwi cr6, r19, 0
	ctx.cr[6].compare_i32(ctx.r[19].s32, 0, &mut ctx.xer);
	// 825BE280: 4099009C  ble cr6, 0x825be31c
	if !ctx.cr[6].gt {
	pc = 0x825BE31C; continue 'dispatch;
	}
	// 825BE284: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 825BE288: A1650000  lhz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE28C: 38C70001  addi r6, r7, 1
	ctx.r[6].s64 = ctx.r[7].s64 + 1;
	// 825BE290: 396B0056  addi r11, r11, 0x56
	ctx.r[11].s64 = ctx.r[11].s64 + 86;
	// 825BE294: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	// 825BE298: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BE29C: 7F069800  cmpw cr6, r6, r19
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[19].s32, &mut ctx.xer);
	// 825BE2A0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BE2A4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BE2A8: 7D6BB02E  lwzx r11, r11, r22
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 825BE2AC: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 825BE2B0: 4098005C  bge cr6, 0x825be30c
	if !ctx.cr[6].lt {
	pc = 0x825BE30C; continue 'dispatch;
	}
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BE608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825BE608 size=952
    let mut pc: u32 = 0x825BE608;
    'dispatch: loop {
        match pc {
            0x825BE608 => {
    //   block [0x825BE608..0x825BE67C)
	// 825BE608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BE60C: 4BF76A79  bl 0x82535084
	ctx.lr = 0x825BE610;
	sub_82535080(ctx, base);
	// 825BE610: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BE614: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825BE618: 822D0000  lwz r17, 0(r13)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE61C: 3A400010  li r18, 0x10
	ctx.r[18].s64 = 16;
	// 825BE620: 3A000000  li r16, 0
	ctx.r[16].s64 = 0;
	// 825BE624: 7C932378  mr r19, r4
	ctx.r[19].u64 = ctx.r[4].u64;
	// 825BE628: 7CAF2B78  mr r15, r5
	ctx.r[15].u64 = ctx.r[5].u64;
	// 825BE62C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE630: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 825BE634: 7E158378  mr r21, r16
	ctx.r[21].u64 = ctx.r[16].u64;
	// 825BE638: 7E178378  mr r23, r16
	ctx.r[23].u64 = ctx.r[16].u64;
	// 825BE63C: 834B0000  lwz r26, 0(r11)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE640: 7D72882E  lwzx r11, r18, r17
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[18].u32.wrapping_add(ctx.r[17].u32)) } as u64;
	// 825BE644: 3BBA0010  addi r29, r26, 0x10
	ctx.r[29].s64 = ctx.r[26].s64 + 16;
	// 825BE648: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE64C: 7D4AD214  add r10, r10, r26
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 825BE650: 3ACA0010  addi r22, r10, 0x10
	ctx.r[22].s64 = ctx.r[10].s64 + 16;
	// 825BE654: 814B0098  lwz r10, 0x98(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(152 as u32) ) } as u64;
	// 825BE658: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825BE65C: 419A0020  beq cr6, 0x825be67c
	if ctx.cr[6].eq {
	pc = 0x825BE67C; continue 'dispatch;
	}
	// 825BE660: 812B009C  lwz r9, 0x9c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) } as u64;
	// 825BE664: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 825BE668: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 825BE66C: 912B009C  stw r9, 0x9c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), ctx.r[9].u32 ) };
	// 825BE670: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE674: 914B0098  stw r10, 0x98(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(152 as u32), ctx.r[10].u32 ) };
	// 825BE678: 48000010  b 0x825be688
	pc = 0x825BE688; continue 'dispatch;
            }
            0x825BE67C => {
    //   block [0x825BE67C..0x825BE688)
	// 825BE67C: 3880000C  li r4, 0xc
	ctx.r[4].s64 = 12;
	// 825BE680: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825BE684: 4BEA57BD  bl 0x82463e40
	ctx.lr = 0x825BE688;
	sub_82463E40(ctx, base);
	pc = 0x825BE688; continue 'dispatch;
            }
            0x825BE688 => {
    //   block [0x825BE688..0x825BE69C)
	// 825BE688: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825BE68C: 419A0010  beq cr6, 0x825be69c
	if ctx.cr[6].eq {
	pc = 0x825BE69C; continue 'dispatch;
	}
	// 825BE690: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825BE694: 92030000  stw r16, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[16].u32 ) };
	// 825BE698: 48000008  b 0x825be6a0
	pc = 0x825BE6A0; continue 'dispatch;
            }
            0x825BE69C => {
    //   block [0x825BE69C..0x825BE6A0)
	// 825BE69C: 7E1B8378  mr r27, r16
	ctx.r[27].u64 = ctx.r[16].u64;
	pc = 0x825BE6A0; continue 'dispatch;
            }
            0x825BE6A0 => {
    //   block [0x825BE6A0..0x825BE6A8)
	// 825BE6A0: 7E148378  mr r20, r16
	ctx.r[20].u64 = ctx.r[16].u64;
	// 825BE6A4: 3B000004  li r24, 4
	ctx.r[24].s64 = 4;
	pc = 0x825BE6A8; continue 'dispatch;
            }
            0x825BE6A8 => {
    //   block [0x825BE6A8..0x825BE6AC)
	// 825BE6A8: 3BFB0010  addi r31, r27, 0x10
	ctx.r[31].s64 = ctx.r[27].s64 + 16;
	pc = 0x825BE6AC; continue 'dispatch;
            }
            0x825BE6AC => {
    //   block [0x825BE6AC..0x825BE6C4)
	// 825BE6AC: 897D0003  lbz r11, 3(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BE6B0: 556BE13E  srwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BE6B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BE6B8: 395D000C  addi r10, r29, 0xc
	ctx.r[10].s64 = ctx.r[29].s64 + 12;
	// 825BE6BC: 397F0008  addi r11, r31, 8
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	// 825BE6C0: 7D3FE850  subf r9, r31, r29
	ctx.r[9].s64 = ctx.r[29].s64 - ctx.r[31].s64;
	pc = 0x825BE6C4; continue 'dispatch;
            }
            0x825BE6C4 => {
    //   block [0x825BE6C4..0x825BE708)
	// 825BE6C4: 810AFFF4  lwz r8, -0xc(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) } as u64;
	// 825BE6C8: 910BFFF8  stw r8, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[8].u32 ) };
	// 825BE6CC: 810AFFF8  lwz r8, -8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825BE6D0: 910BFFFC  stw r8, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[8].u32 ) };
	// 825BE6D4: 7D09582E  lwzx r8, r9, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825BE6D8: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825BE6DC: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE6E0: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 825BE6E4: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 825BE6E8: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 825BE6EC: 4200FFD8  bdnz 0x825be6c4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825BE6C4; continue 'dispatch;
	}
	// 825BE6F0: 897D0003  lbz r11, 3(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BE6F4: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825BE6F8: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 825BE6FC: 7FABEA14  add r29, r11, r29
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 825BE700: 7E6B9B78  mr r11, r19
	ctx.r[11].u64 = ctx.r[19].u64;
	// 825BE704: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x825BE708; continue 'dispatch;
            }
            0x825BE708 => {
    //   block [0x825BE708..0x825BE760)
	// 825BE708: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE70C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825BE710: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825BE714: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825BE718: 4200FFF0  bdnz 0x825be708
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825BE708; continue 'dispatch;
	}
	// 825BE71C: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE720: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 825BE724: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825BE728: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 825BE72C: 41990058  bgt cr6, 0x825be784
	if ctx.cr[6].gt {
	pc = 0x825BE784; continue 'dispatch;
	}
	// 825BE730: 3D80825C  lis r12, -0x7da4
	ctx.r[12].s64 = -2107899904;
	// 825BE734: 398CE748  addi r12, r12, -0x18b8
	ctx.r[12].s64 = ctx.r[12].s64 + -6328;
	// 825BE738: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 825BE73C: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 825BE740: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 825BE744: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x825BE780; continue 'dispatch;
		},
		1 => {
	pc = 0x825BE764; continue 'dispatch;
		},
		2 => {
	pc = 0x825BE764; continue 'dispatch;
		},
		3 => {
	pc = 0x825BE760; continue 'dispatch;
		},
		4 => {
	pc = 0x825BE760; continue 'dispatch;
		},
		5 => {
	pc = 0x825BE764; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 825BE748: 825BE780  lwz r18, -0x1880(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-6272 as u32) ) } as u64;
	// 825BE74C: 825BE764  lwz r18, -0x189c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-6300 as u32) ) } as u64;
	// 825BE750: 825BE764  lwz r18, -0x189c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-6300 as u32) ) } as u64;
	// 825BE754: 825BE760  lwz r18, -0x18a0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-6304 as u32) ) } as u64;
	// 825BE758: 825BE760  lwz r18, -0x18a0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-6304 as u32) ) } as u64;
	// 825BE75C: 825BE764  lwz r18, -0x189c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-6300 as u32) ) } as u64;
            }
            0x825BE760 => {
    //   block [0x825BE760..0x825BE764)
	// 825BE760: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	pc = 0x825BE764; continue 'dispatch;
            }
            0x825BE764 => {
    //   block [0x825BE764..0x825BE780)
	// 825BE764: 7CAAFA14  add r5, r10, r31
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 825BE768: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825BE76C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825BE770: 7DE903A6  mtctr r15
	ctx.ctr.u64 = ctx.r[15].u64;
	// 825BE774: 4E800421  bctrl
	ctx.lr = 0x825BE778;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BE778: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825BE77C: 48000008  b 0x825be784
	pc = 0x825BE784; continue 'dispatch;
            }
            0x825BE780 => {
    //   block [0x825BE780..0x825BE784)
	// 825BE780: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	pc = 0x825BE784; continue 'dispatch;
            }
            0x825BE784 => {
    //   block [0x825BE784..0x825BE7B8)
	// 825BE784: 7F1DB040  cmplw cr6, r29, r22
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[22].u32, &mut ctx.xer);
	// 825BE788: 409A0078  bne cr6, 0x825be800
	if !ctx.cr[6].eq {
	pc = 0x825BE800; continue 'dispatch;
	}
	// 825BE78C: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 825BE790: 419A0040  beq cr6, 0x825be7d0
	if ctx.cr[6].eq {
	pc = 0x825BE7D0; continue 'dispatch;
	}
	// 825BE794: 7C72882E  lwzx r3, r18, r17
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[18].u32.wrapping_add(ctx.r[17].u32)) } as u64;
	// 825BE798: 8163009C  lwz r11, 0x9c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(156 as u32) ) } as u64;
	// 825BE79C: 81430034  lwz r10, 0x34(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 825BE7A0: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825BE7A4: 41980014  blt cr6, 0x825be7b8
	if ctx.cr[6].lt {
	pc = 0x825BE7B8; continue 'dispatch;
	}
	// 825BE7A8: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 825BE7AC: 3880000C  li r4, 0xc
	ctx.r[4].s64 = 12;
	// 825BE7B0: 4BEA5769  bl 0x82463f18
	ctx.lr = 0x825BE7B4;
	sub_82463F18(ctx, base);
	// 825BE7B4: 4800001C  b 0x825be7d0
	pc = 0x825BE7D0; continue 'dispatch;
            }
            0x825BE7B8 => {
    //   block [0x825BE7B8..0x825BE7D0)
	// 825BE7B8: 8163009C  lwz r11, 0x9c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(156 as u32) ) } as u64;
	// 825BE7BC: 81430098  lwz r10, 0x98(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(152 as u32) ) } as u64;
	// 825BE7C0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825BE7C4: 9163009C  stw r11, 0x9c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 825BE7C8: 91570000  stw r10, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BE7CC: 92E30098  stw r23, 0x98(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), ctx.r[23].u32 ) };
	pc = 0x825BE7D0; continue 'dispatch;
            }
            0x825BE7D0 => {
    //   block [0x825BE7D0..0x825BE800)
	// 825BE7D0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BE7D4: 7F57D378  mr r23, r26
	ctx.r[23].u64 = ctx.r[26].u64;
	// 825BE7D8: 7F195800  cmpw cr6, r25, r11
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825BE7DC: 40980144  bge cr6, 0x825be920
	if !ctx.cr[6].lt {
	pc = 0x825BE920; continue 'dispatch;
	}
	// 825BE7E0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE7E4: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 825BE7E8: 7F4BC02E  lwzx r26, r11, r24
	ctx.r[26].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 825BE7EC: 3B180004  addi r24, r24, 4
	ctx.r[24].s64 = ctx.r[24].s64 + 4;
	// 825BE7F0: 3BBA0010  addi r29, r26, 0x10
	ctx.r[29].s64 = ctx.r[26].s64 + 16;
	// 825BE7F4: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE7F8: 7D6BD214  add r11, r11, r26
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 825BE7FC: 3ACB0010  addi r22, r11, 0x10
	ctx.r[22].s64 = ctx.r[11].s64 + 16;
	pc = 0x825BE800; continue 'dispatch;
            }
            0x825BE800 => {
    //   block [0x825BE800..0x825BE850)
	// 825BE800: 7D7BF850  subf r11, r27, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[27].s64;
	// 825BE804: 895D0003  lbz r10, 3(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BE808: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 825BE80C: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825BE810: 2F0A01A0  cmpwi cr6, r10, 0x1a0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 416, &mut ctx.xer);
	// 825BE814: 4099FE98  ble cr6, 0x825be6ac
	if !ctx.cr[6].gt {
	pc = 0x825BE6AC; continue 'dispatch;
	}
	// 825BE818: 7F15C800  cmpw cr6, r21, r25
	ctx.cr[6].compare_i32(ctx.r[21].s32, ctx.r[25].s32, &mut ctx.xer);
	// 825BE81C: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825BE820: 41980088  blt cr6, 0x825be8a8
	if ctx.cr[6].lt {
	pc = 0x825BE8A8; continue 'dispatch;
	}
	// 825BE824: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BE828: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BE82C: 3BCB0001  addi r30, r11, 1
	ctx.r[30].s64 = ctx.r[11].s64 + 1;
	// 825BE830: 554A00BE  clrlwi r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 825BE834: 7FF95850  subf r31, r25, r11
	ctx.r[31].s64 = ctx.r[11].s64 - ctx.r[25].s64;
	// 825BE838: 7F0AF000  cmpw cr6, r10, r30
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[30].s32, &mut ctx.xer);
	// 825BE83C: 40980024  bge cr6, 0x825be860
	if !ctx.cr[6].lt {
	pc = 0x825BE860; continue 'dispatch;
	}
	// 825BE840: 554B083C  slwi r11, r10, 1
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BE844: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825BE848: 41980008  blt cr6, 0x825be850
	if ctx.cr[6].lt {
	pc = 0x825BE850; continue 'dispatch;
	}
	// 825BE84C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x825BE850; continue 'dispatch;
            }
            0x825BE850 => {
    //   block [0x825BE850..0x825BE860)
	// 825BE850: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 825BE854: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 825BE858: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825BE85C: 4BEAFA6D  bl 0x8246e2c8
	ctx.lr = 0x825BE860;
	sub_8246E2C8(ctx, base);
	pc = 0x825BE860; continue 'dispatch;
            }
            0x825BE860 => {
    //   block [0x825BE860..0x825BE884)
	// 825BE860: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE864: 397FFFFF  addi r11, r31, -1
	ctx.r[11].s64 = ctx.r[31].s64 + -1;
	// 825BE868: 7D4AC214  add r10, r10, r24
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[24].u64;
	// 825BE86C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825BE870: 392A0004  addi r9, r10, 4
	ctx.r[9].s64 = ctx.r[10].s64 + 4;
	// 825BE874: 41980028  blt cr6, 0x825be89c
	if ctx.cr[6].lt {
	pc = 0x825BE89C; continue 'dispatch;
	}
	// 825BE878: 5567103A  slwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825BE87C: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 825BE880: 7D474A14  add r10, r7, r9
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	pc = 0x825BE884; continue 'dispatch;
            }
            0x825BE884 => {
    //   block [0x825BE884..0x825BE89C)
	// 825BE884: 7D28502E  lwzx r9, r8, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825BE888: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825BE88C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825BE890: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825BE894: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 825BE898: 4098FFEC  bge cr6, 0x825be884
	if !ctx.cr[6].lt {
	pc = 0x825BE884; continue 'dispatch;
	}
	pc = 0x825BE89C; continue 'dispatch;
            }
            0x825BE89C => {
    //   block [0x825BE89C..0x825BE8A8)
	// 825BE89C: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 825BE8A0: 93DC0004  stw r30, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 825BE8A4: 3B180004  addi r24, r24, 4
	ctx.r[24].s64 = ctx.r[24].s64 + 4;
	pc = 0x825BE8A8; continue 'dispatch;
            }
            0x825BE8A8 => {
    //   block [0x825BE8A8..0x825BE8CC)
	// 825BE8A8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE8AC: 3AB50001  addi r21, r21, 1
	ctx.r[21].s64 = ctx.r[21].s64 + 1;
	// 825BE8B0: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 825BE8B4: 7F6BA12E  stwx r27, r11, r20
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[20].u32), ctx.r[27].u32) };
	// 825BE8B8: 3A940004  addi r20, r20, 4
	ctx.r[20].s64 = ctx.r[20].s64 + 4;
	// 825BE8BC: 419A0010  beq cr6, 0x825be8cc
	if ctx.cr[6].eq {
	pc = 0x825BE8CC; continue 'dispatch;
	}
	// 825BE8C0: 7EFBBB78  mr r27, r23
	ctx.r[27].u64 = ctx.r[23].u64;
	// 825BE8C4: 7E178378  mr r23, r16
	ctx.r[23].u64 = ctx.r[16].u64;
	// 825BE8C8: 4BFFFDE0  b 0x825be6a8
	pc = 0x825BE6A8; continue 'dispatch;
            }
            0x825BE8CC => {
    //   block [0x825BE8CC..0x825BE8F8)
	// 825BE8CC: 7D72882E  lwzx r11, r18, r17
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[18].u32.wrapping_add(ctx.r[17].u32)) } as u64;
	// 825BE8D0: 814B0098  lwz r10, 0x98(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(152 as u32) ) } as u64;
	// 825BE8D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825BE8D8: 419A0020  beq cr6, 0x825be8f8
	if ctx.cr[6].eq {
	pc = 0x825BE8F8; continue 'dispatch;
	}
	// 825BE8DC: 812B009C  lwz r9, 0x9c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) } as u64;
	// 825BE8E0: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 825BE8E4: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 825BE8E8: 912B009C  stw r9, 0x9c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), ctx.r[9].u32 ) };
	// 825BE8EC: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE8F0: 914B0098  stw r10, 0x98(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(152 as u32), ctx.r[10].u32 ) };
	// 825BE8F4: 48000010  b 0x825be904
	pc = 0x825BE904; continue 'dispatch;
            }
            0x825BE8F8 => {
    //   block [0x825BE8F8..0x825BE904)
	// 825BE8F8: 3880000C  li r4, 0xc
	ctx.r[4].s64 = 12;
	// 825BE8FC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825BE900: 4BEA5541  bl 0x82463e40
	ctx.lr = 0x825BE904;
	sub_82463E40(ctx, base);
	pc = 0x825BE904; continue 'dispatch;
            }
            0x825BE904 => {
    //   block [0x825BE904..0x825BE918)
	// 825BE904: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825BE908: 419A0010  beq cr6, 0x825be918
	if ctx.cr[6].eq {
	pc = 0x825BE918; continue 'dispatch;
	}
	// 825BE90C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825BE910: 92030000  stw r16, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[16].u32 ) };
	// 825BE914: 4BFFFD94  b 0x825be6a8
	pc = 0x825BE6A8; continue 'dispatch;
            }
            0x825BE918 => {
    //   block [0x825BE918..0x825BE920)
	// 825BE918: 7E1B8378  mr r27, r16
	ctx.r[27].u64 = ctx.r[16].u64;
	// 825BE91C: 4BFFFD8C  b 0x825be6a8
	pc = 0x825BE6A8; continue 'dispatch;
            }
            0x825BE920 => {
    //   block [0x825BE920..0x825BE950)
	// 825BE920: 7D7BF850  subf r11, r27, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[27].s64;
	// 825BE924: 3BF50001  addi r31, r21, 1
	ctx.r[31].s64 = ctx.r[21].s64 + 1;
	// 825BE928: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 825BE92C: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825BE930: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BE934: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825BE938: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 825BE93C: 40980024  bge cr6, 0x825be960
	if !ctx.cr[6].lt {
	pc = 0x825BE960; continue 'dispatch;
	}
	// 825BE940: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BE944: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825BE948: 41980008  blt cr6, 0x825be950
	if ctx.cr[6].lt {
	pc = 0x825BE950; continue 'dispatch;
	}
	// 825BE94C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x825BE950; continue 'dispatch;
            }
            0x825BE950 => {
    //   block [0x825BE950..0x825BE960)
	// 825BE950: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 825BE954: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 825BE958: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825BE95C: 4BEAF96D  bl 0x8246e2c8
	ctx.lr = 0x825BE960;
	sub_8246E2C8(ctx, base);
	pc = 0x825BE960; continue 'dispatch;
            }
            0x825BE960 => {
    //   block [0x825BE960..0x825BE9A0)
	// 825BE960: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE964: 56AA103A  slwi r10, r21, 2
	ctx.r[10].u32 = ctx.r[21].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BE968: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825BE96C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 825BE970: 7F6A592E  stwx r27, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[27].u32) };
	// 825BE974: 419A0044  beq cr6, 0x825be9b8
	if ctx.cr[6].eq {
	pc = 0x825BE9B8; continue 'dispatch;
	}
	// 825BE978: 7C72882E  lwzx r3, r18, r17
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[18].u32.wrapping_add(ctx.r[17].u32)) } as u64;
	// 825BE97C: 8163009C  lwz r11, 0x9c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(156 as u32) ) } as u64;
	// 825BE980: 81430034  lwz r10, 0x34(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 825BE984: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825BE988: 41980018  blt cr6, 0x825be9a0
	if ctx.cr[6].lt {
	pc = 0x825BE9A0; continue 'dispatch;
	}
	// 825BE98C: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 825BE990: 3880000C  li r4, 0xc
	ctx.r[4].s64 = 12;
	// 825BE994: 4BEA5585  bl 0x82463f18
	ctx.lr = 0x825BE998;
	sub_82463F18(ctx, base);
	// 825BE998: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 825BE99C: 4BF76738  b 0x825350d4
	sub_825350D0(ctx, base);
	return;
            }
            0x825BE9A0 => {
    //   block [0x825BE9A0..0x825BE9B8)
	// 825BE9A0: 8163009C  lwz r11, 0x9c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(156 as u32) ) } as u64;
	// 825BE9A4: 81430098  lwz r10, 0x98(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(152 as u32) ) } as u64;
	// 825BE9A8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825BE9AC: 9163009C  stw r11, 0x9c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 825BE9B0: 915A0000  stw r10, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BE9B4: 93430098  stw r26, 0x98(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), ctx.r[26].u32 ) };
	pc = 0x825BE9B8; continue 'dispatch;
            }
            0x825BE9B8 => {
    //   block [0x825BE9B8..0x825BE9C0)
	// 825BE9B8: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 825BE9BC: 4BF76718  b 0x825350d4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BE9C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825BE9C0 size=368
    let mut pc: u32 = 0x825BE9C0;
    'dispatch: loop {
        match pc {
            0x825BE9C0 => {
    //   block [0x825BE9C0..0x825BEA90)
	// 825BE9C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BE9C4: 4BF766F1  bl 0x825350b4
	ctx.lr = 0x825BE9C8;
	sub_82535080(ctx, base);
	// 825BE9C8: 9421FD60  stwu r1, -0x2a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-672 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BE9CC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825BE9D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825BE9D4: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 825BE9D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825BE9DC: E97E0004  ld r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	// 825BE9E0: 80BF0010  lwz r5, 0x10(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BE9E4: 811F000C  lwz r8, 0xc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BE9E8: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BE9EC: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE9F0: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 825BE9F4: 80850008  lwz r4, 8(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BE9F8: 83A10064  lwz r29, 0x64(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825BE9FC: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 825BEA00: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BEA04: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BEA08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BEA0C: 4E800421  bctrl
	ctx.lr = 0x825BEA10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BEA10: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BEA14: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BEA18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BEA1C: 897E0001  lbz r11, 1(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BEA20: 419A00D4  beq cr6, 0x825beaf4
	if ctx.cr[6].eq {
	pc = 0x825BEAF4; continue 'dispatch;
	}
	// 825BEA24: 5569103E  rotlwi r9, r11, 2
	ctx.r[9].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 825BEA28: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BEA2C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825BEA30: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BEA34: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BEA38: 838B16C8  lwz r28, 0x16c8(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5832 as u32) ) } as u64;
	// 825BEA3C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825BEA40: 419A00A4  beq cr6, 0x825beae4
	if ctx.cr[6].eq {
	pc = 0x825BEAE4; continue 'dispatch;
	}
	// 825BEA44: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BEA48: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 825BEA4C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BEA50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BEA54: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BEA58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BEA5C: 4E800421  bctrl
	ctx.lr = 0x825BEA60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BEA60: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BEA64: 895E0000  lbz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BEA68: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 825BEA6C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 825BEA70: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BEA74: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 825BEA78: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825BEA7C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 825BEA80: 419A0010  beq cr6, 0x825bea90
	if ctx.cr[6].eq {
	pc = 0x825BEA90; continue 'dispatch;
	}
	// 825BEA84: 2B0A0005  cmplwi cr6, r10, 5
	ctx.cr[6].compare_u32(ctx.r[10].u32, 5 as u32, &mut ctx.xer);
	// 825BEA88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825BEA8C: 409A0008  bne cr6, 0x825bea94
	if !ctx.cr[6].eq {
	pc = 0x825BEA94; continue 'dispatch;
	}
            }
            0x825BEA90 => {
    //   block [0x825BEA90..0x825BEA94)
	// 825BEA90: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x825BEA94; continue 'dispatch;
            }
            0x825BEA94 => {
    //   block [0x825BEA94..0x825BEAD4)
	// 825BEA94: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 825BEA98: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 825BEA9C: 811F0014  lwz r8, 0x14(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BEAA0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825BEAA4: 80FF0010  lwz r7, 0x10(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BEAA8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825BEAAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825BEAB0: 409A0024  bne cr6, 0x825bead4
	if !ctx.cr[6].eq {
	pc = 0x825BEAD4; continue 'dispatch;
	}
	// 825BEAB4: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BEAB8: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 825BEABC: 7F8903A6  mtctr r28
	ctx.ctr.u64 = ctx.r[28].u64;
	// 825BEAC0: 4E800421  bctrl
	ctx.lr = 0x825BEAC4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BEAC4: 897E0003  lbz r11, 3(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BEAC8: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 825BEACC: 382102A0  addi r1, r1, 0x2a0
	ctx.r[1].s64 = ctx.r[1].s64 + 672;
	// 825BEAD0: 4BF76634  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            0x825BEAD4 => {
    //   block [0x825BEAD4..0x825BEAE4)
	// 825BEAD4: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BEAD8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825BEADC: 7F8903A6  mtctr r28
	ctx.ctr.u64 = ctx.r[28].u64;
	// 825BEAE0: 4E800421  bctrl
	ctx.lr = 0x825BEAE4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x825BEAE4 => {
    //   block [0x825BEAE4..0x825BEAF4)
	// 825BEAE4: 897E0003  lbz r11, 3(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BEAE8: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 825BEAEC: 382102A0  addi r1, r1, 0x2a0
	ctx.r[1].s64 = ctx.r[1].s64 + 672;
	// 825BEAF0: 4BF76614  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            0x825BEAF4 => {
    //   block [0x825BEAF4..0x825BEB30)
	// 825BEAF4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BEAF8: 556A103E  rotlwi r10, r11, 2
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 825BEAFC: 80DF0018  lwz r6, 0x18(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 825BEB00: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825BEB04: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BEB08: 80BF0014  lwz r5, 0x14(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BEB0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825BEB10: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BEB14: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 825BEB18: 816B16B4  lwz r11, 0x16b4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5812 as u32) ) } as u64;
	// 825BEB1C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BEB20: 4E800421  bctrl
	ctx.lr = 0x825BEB24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BEB24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825BEB28: 382102A0  addi r1, r1, 0x2a0
	ctx.r[1].s64 = ctx.r[1].s64 + 672;
	// 825BEB2C: 4BF765D8  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BEB30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825BEB30 size=12
    let mut pc: u32 = 0x825BEB30;
    'dispatch: loop {
        match pc {
            0x825BEB30 => {
    //   block [0x825BEB30..0x825BEB3C)
	// 825BEB30: 3D60825C  lis r11, -0x7da4
	ctx.r[11].s64 = -2107899904;
	// 825BEB34: 38ABE9C0  addi r5, r11, -0x1640
	ctx.r[5].s64 = ctx.r[11].s64 + -5696;
	// 825BEB38: 4BFFFAD0  b 0x825be608
	sub_825BE608(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BEB40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825BEB40 size=440
    let mut pc: u32 = 0x825BEB40;
    'dispatch: loop {
        match pc {
            0x825BEB40 => {
    //   block [0x825BEB40..0x825BEC58)
	// 825BEB40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BEB44: 4BF76569  bl 0x825350ac
	ctx.lr = 0x825BEB48;
	sub_82535080(ctx, base);
	// 825BEB48: 9421FB30  stwu r1, -0x4d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-1232 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BEB4C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825BEB50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825BEB54: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 825BEB58: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825BEB5C: E97E0004  ld r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	// 825BEB60: 80BF0010  lwz r5, 0x10(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BEB64: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BEB68: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BEB6C: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BEB70: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 825BEB74: 80850008  lwz r4, 8(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BEB78: 83810074  lwz r28, 0x74(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825BEB7C: 83A10070  lwz r29, 0x70(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 825BEB80: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BEB84: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 825BEB88: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BEB8C: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 825BEB90: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BEB94: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BEB98: 4E800421  bctrl
	ctx.lr = 0x825BEB9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BEB9C: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BEBA0: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BEBA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BEBA8: 897E0001  lbz r11, 1(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BEBAC: 419A0110  beq cr6, 0x825becbc
	if ctx.cr[6].eq {
	pc = 0x825BECBC; continue 'dispatch;
	}
	// 825BEBB0: 5569103E  rotlwi r9, r11, 2
	ctx.r[9].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 825BEBB4: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BEBB8: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825BEBBC: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BEBC0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BEBC4: 834B16C8  lwz r26, 0x16c8(r11)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5832 as u32) ) } as u64;
	// 825BEBC8: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 825BEBCC: 419A00E0  beq cr6, 0x825becac
	if ctx.cr[6].eq {
	pc = 0x825BECAC; continue 'dispatch;
	}
	// 825BEBD0: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BEBD4: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 825BEBD8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825BEBDC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BEBE0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BEBE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BEBE8: 4E800421  bctrl
	ctx.lr = 0x825BEBEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BEBEC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BEBF0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825BEBF4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825BEBF8: 38A10290  addi r5, r1, 0x290
	ctx.r[5].s64 = ctx.r[1].s64 + 656;
	// 825BEBFC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BEC00: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BEC04: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BEC08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BEC0C: 4E800421  bctrl
	ctx.lr = 0x825BEC10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BEC10: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BEC14: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BEC18: 893E0000  lbz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BEC1C: 2B090003  cmplwi cr6, r9, 3
	ctx.cr[6].compare_u32(ctx.r[9].u32, 3 as u32, &mut ctx.xer);
	// 825BEC20: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 825BEC24: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BEC28: 93610080  stw r27, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[27].u32 ) };
	// 825BEC2C: 93810084  stw r28, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[28].u32 ) };
	// 825BEC30: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 825BEC34: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 825BEC38: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BEC3C: 90610070  stw r3, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[3].u32 ) };
	// 825BEC40: 93A10074  stw r29, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[29].u32 ) };
	// 825BEC44: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 825BEC48: 419A0010  beq cr6, 0x825bec58
	if ctx.cr[6].eq {
	pc = 0x825BEC58; continue 'dispatch;
	}
	// 825BEC4C: 2B090005  cmplwi cr6, r9, 5
	ctx.cr[6].compare_u32(ctx.r[9].u32, 5 as u32, &mut ctx.xer);
	// 825BEC50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825BEC54: 409A0008  bne cr6, 0x825bec5c
	if !ctx.cr[6].eq {
	pc = 0x825BEC5C; continue 'dispatch;
	}
            }
            0x825BEC58 => {
    //   block [0x825BEC58..0x825BEC5C)
	// 825BEC58: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x825BEC5C; continue 'dispatch;
            }
            0x825BEC5C => {
    //   block [0x825BEC5C..0x825BEC9C)
	// 825BEC5C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 825BEC60: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 825BEC64: 811F0014  lwz r8, 0x14(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BEC68: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825BEC6C: 80FF0010  lwz r7, 0x10(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BEC70: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825BEC74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825BEC78: 409A0024  bne cr6, 0x825bec9c
	if !ctx.cr[6].eq {
	pc = 0x825BEC9C; continue 'dispatch;
	}
	// 825BEC7C: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 825BEC80: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 825BEC84: 7F4903A6  mtctr r26
	ctx.ctr.u64 = ctx.r[26].u64;
	// 825BEC88: 4E800421  bctrl
	ctx.lr = 0x825BEC8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BEC8C: 897E0003  lbz r11, 3(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BEC90: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 825BEC94: 382104D0  addi r1, r1, 0x4d0
	ctx.r[1].s64 = ctx.r[1].s64 + 1232;
	// 825BEC98: 4BF76464  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            0x825BEC9C => {
    //   block [0x825BEC9C..0x825BECAC)
	// 825BEC9C: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 825BECA0: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 825BECA4: 7F4903A6  mtctr r26
	ctx.ctr.u64 = ctx.r[26].u64;
	// 825BECA8: 4E800421  bctrl
	ctx.lr = 0x825BECAC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x825BECAC => {
    //   block [0x825BECAC..0x825BECBC)
	// 825BECAC: 897E0003  lbz r11, 3(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BECB0: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 825BECB4: 382104D0  addi r1, r1, 0x4d0
	ctx.r[1].s64 = ctx.r[1].s64 + 1232;
	// 825BECB8: 4BF76444  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            0x825BECBC => {
    //   block [0x825BECBC..0x825BECF8)
	// 825BECBC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BECC0: 556A103E  rotlwi r10, r11, 2
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 825BECC4: 80DF0018  lwz r6, 0x18(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 825BECC8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825BECCC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BECD0: 80BF0014  lwz r5, 0x14(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BECD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825BECD8: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BECDC: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 825BECE0: 816B16B4  lwz r11, 0x16b4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5812 as u32) ) } as u64;
	// 825BECE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BECE8: 4E800421  bctrl
	ctx.lr = 0x825BECEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BECEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825BECF0: 382104D0  addi r1, r1, 0x4d0
	ctx.r[1].s64 = ctx.r[1].s64 + 1232;
	// 825BECF4: 4BF76408  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BECF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825BECF8 size=12
    let mut pc: u32 = 0x825BECF8;
    'dispatch: loop {
        match pc {
            0x825BECF8 => {
    //   block [0x825BECF8..0x825BED04)
	// 825BECF8: 3D60825C  lis r11, -0x7da4
	ctx.r[11].s64 = -2107899904;
	// 825BECFC: 38ABEB40  addi r5, r11, -0x14c0
	ctx.r[5].s64 = ctx.r[11].s64 + -5312;
	// 825BED00: 4BFFF908  b 0x825be608
	sub_825BE608(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BED08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825BED08 size=88
    let mut pc: u32 = 0x825BED08;
    'dispatch: loop {
        match pc {
            0x825BED08 => {
    //   block [0x825BED08..0x825BED60)
	// 825BED08: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825BED0C: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 825BED10: 39000060  li r8, 0x60
	ctx.r[8].s64 = 96;
	// 825BED14: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 825BED18: 386A0010  addi r3, r10, 0x10
	ctx.r[3].s64 = ctx.r[10].s64 + 16;
	// 825BED1C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BED20: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825BED24: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BED28: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825BED2C: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BED30: 912A0008  stw r9, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 825BED34: 812B0054  lwz r9, 0x54(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 825BED38: 912A0054  stw r9, 0x54(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825BED3C: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BED40: 912A000C  stw r9, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 825BED44: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BED60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825BED60 size=84
    let mut pc: u32 = 0x825BED60;
    'dispatch: loop {
        match pc {
            0x825BED60 => {
    //   block [0x825BED60..0x825BEDB4)
	// 825BED60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BED64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825BED68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825BED6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825BED70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BED74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825BED78: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825BED7C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 825BED80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825BED84: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BED88: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BED8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BED90: 4E800421  bctrl
	ctx.lr = 0x825BED94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BED94: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 825BED98: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825BED9C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825BEDA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825BEDA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825BEDA8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825BEDAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825BEDB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BEDB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BEDB8 size=192
    let mut pc: u32 = 0x825BEDB8;
    'dispatch: loop {
        match pc {
            0x825BEDB8 => {
    //   block [0x825BEDB8..0x825BEE60)
	// 825BEDB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BEDBC: 4BF762F9  bl 0x825350b4
	ctx.lr = 0x825BEDC0;
	sub_82535080(ctx, base);
	// 825BEDC0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BEDC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825BEDC8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825BEDCC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825BEDD0: 3B9E0020  addi r28, r30, 0x20
	ctx.r[28].s64 = ctx.r[30].s64 + 32;
	// 825BEDD4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BEDD8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825BEDDC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BEDE0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BEDE4: C02A0050  lfs f1, 0x50(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825BEDE8: 386B0040  addi r3, r11, 0x40
	ctx.r[3].s64 = ctx.r[11].s64 + 64;
	// 825BEDEC: 4BFEA5BD  bl 0x825a93a8
	ctx.lr = 0x825BEDF0;
	sub_825A93A8(ctx, base);
	// 825BEDF0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BEDF4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BEDF8: 3B7E0060  addi r27, r30, 0x60
	ctx.r[27].s64 = ctx.r[30].s64 + 96;
	// 825BEDFC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 825BEE00: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BEE04: C02A0050  lfs f1, 0x50(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825BEE08: 386B0040  addi r3, r11, 0x40
	ctx.r[3].s64 = ctx.r[11].s64 + 64;
	// 825BEE0C: 4BFEA59D  bl 0x825a93a8
	ctx.lr = 0x825BEE10;
	sub_825A93A8(ctx, base);
	// 825BEE10: 397E0010  addi r11, r30, 0x10
	ctx.r[11].s64 = ctx.r[30].s64 + 16;
	// 825BEE14: 93DD0000  stw r30, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825BEE18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BEE1C: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825BEE20: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BEE24: 915D000C  stw r10, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 825BEE28: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BEE2C: 915D0008  stw r10, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825BEE30: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BEE34: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BEE38: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BEE3C: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825BEE40: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BEE44: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BEE48: 939E0008  stw r28, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 825BEE4C: 915E000C  stw r10, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 825BEE50: 419A0010  beq cr6, 0x825bee60
	if ctx.cr[6].eq {
	pc = 0x825BEE60; continue 'dispatch;
	}
	// 825BEE54: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BEE58: 936B0008  stw r27, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 825BEE5C: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	pc = 0x825BEE60; continue 'dispatch;
            }
            0x825BEE60 => {
    //   block [0x825BEE60..0x825BEE78)
	// 825BEE60: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 825BEE64: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825BEE68: 387D0010  addi r3, r29, 0x10
	ctx.r[3].s64 = ctx.r[29].s64 + 16;
	// 825BEE6C: 4BFEA2ED  bl 0x825a9158
	ctx.lr = 0x825BEE70;
	sub_825A9158(ctx, base);
	// 825BEE70: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825BEE74: 4BF76290  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BEE78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825BEE78 size=156
    let mut pc: u32 = 0x825BEE78;
    'dispatch: loop {
        match pc {
            0x825BEE78 => {
    //   block [0x825BEE78..0x825BEED4)
	// 825BEE78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BEE7C: 4BF76231  bl 0x825350ac
	ctx.lr = 0x825BEE80;
	sub_82535080(ctx, base);
	// 825BEE80: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BEE84: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825BEE88: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825BEE8C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 825BEE90: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 825BEE94: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	// 825BEE98: 83FC0004  lwz r31, 4(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BEE9C: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	// 825BEEA0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BEEA4: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 825BEEA8: 419A002C  beq cr6, 0x825beed4
	if ctx.cr[6].eq {
	pc = 0x825BEED4; continue 'dispatch;
	}
	// 825BEEAC: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825BEEB0: 7D054378  mr r5, r8
	ctx.r[5].u64 = ctx.r[8].u64;
	// 825BEEB4: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BEEB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825BEEBC: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 825BEEC0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BEEC4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BEEC8: 4E800421  bctrl
	ctx.lr = 0x825BEECC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BEECC: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 825BEED0: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
            }
            0x825BEED4 => {
    //   block [0x825BEED4..0x825BEF0C)
	// 825BEED4: 83FC0000  lwz r31, 0(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BEED8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BEEDC: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 825BEEE0: 419A002C  beq cr6, 0x825bef0c
	if ctx.cr[6].eq {
	pc = 0x825BEF0C; continue 'dispatch;
	}
	// 825BEEE4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825BEEE8: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 825BEEEC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BEEF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825BEEF4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825BEEF8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BEEFC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BEF00: 4E800421  bctrl
	ctx.lr = 0x825BEF04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BEF04: 907A0000  stw r3, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 825BEF08: 93FA0004  stw r31, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
            }
            0x825BEF0C => {
    //   block [0x825BEF0C..0x825BEF14)
	// 825BEF0C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825BEF10: 4BF761EC  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BEF18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BEF18 size=3740
    let mut pc: u32 = 0x825BEF18;
    'dispatch: loop {
        match pc {
            0x825BEF18 => {
    //   block [0x825BEF18..0x825BEFA4)
	// 825BEF18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BEF1C: 4BF76165  bl 0x82535080
	ctx.lr = 0x825BEF20;
	sub_82535080(ctx, base);
	// 825BEF20: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 825BEF24: 4BF770C5  bl 0x82535fe8
	ctx.lr = 0x825BEF28;
	sub_82535FB0(ctx, base);
	// 825BEF28: E981F000  ld r12, -0x1000(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-4096 as u32) ) };
	// 825BEF2C: 9421E8F0  stwu r1, -0x1710(r1)
	ea = ctx.r[1].u32.wrapping_add(-5904 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BEF30: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 825BEF34: 90E11744  stw r7, 0x1744(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(5956 as u32), ctx.r[7].u32 ) };
	// 825BEF38: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825BEF3C: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 825BEF40: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 825BEF44: 81740000  lwz r11, 0(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BEF48: 93A11734  stw r29, 0x1734(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(5940 as u32), ctx.r[29].u32 ) };
	// 825BEF4C: 7C005A2C  dcbt 0, r11
	// 825BEF50: 3BF93080  addi r31, r25, 0x3080
	ctx.r[31].s64 = ctx.r[25].s64 + 12416;
	// 825BEF54: 81793080  lwz r11, 0x3080(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12416 as u32) ) } as u64;
	// 825BEF58: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825BEF5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BEF60: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 825BEF64: 409A0040  bne cr6, 0x825befa4
	if !ctx.cr[6].eq {
	pc = 0x825BEFA4; continue 'dispatch;
	}
	// 825BEF68: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BEF6C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 825BEF70: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 825BEF74: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BEF78: 4E800421  bctrl
	ctx.lr = 0x825BEF7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BEF7C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825BEF80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BEF84: 419A0020  beq cr6, 0x825befa4
	if ctx.cr[6].eq {
	pc = 0x825BEFA4; continue 'dispatch;
	}
	// 825BEF88: 39410A58  addi r10, r1, 0xa58
	ctx.r[10].s64 = ctx.r[1].s64 + 2648;
	// 825BEF8C: 39610650  addi r11, r1, 0x650
	ctx.r[11].s64 = ctx.r[1].s64 + 1616;
	// 825BEF90: 91410650  stw r10, 0x650(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1616 as u32), ctx.r[10].u32 ) };
	// 825BEF94: 39410658  addi r10, r1, 0x658
	ctx.r[10].s64 = ctx.r[1].s64 + 1624;
	// 825BEF98: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825BEF9C: 91410654  stw r10, 0x654(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1620 as u32), ctx.r[10].u32 ) };
	// 825BEFA0: 48000008  b 0x825befa8
	pc = 0x825BEFA8; continue 'dispatch;
            }
            0x825BEFA4 => {
    //   block [0x825BEFA4..0x825BEFA8)
	// 825BEFA4: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	pc = 0x825BEFA8; continue 'dispatch;
            }
            0x825BEFA8 => {
    //   block [0x825BEFA8..0x825BEFBC)
	// 825BEFA8: 390100A8  addi r8, r1, 0xa8
	ctx.r[8].s64 = ctx.r[1].s64 + 168;
	// 825BEFAC: 39200007  li r9, 7
	ctx.r[9].s64 = 7;
	// 825BEFB0: 395D0008  addi r10, r29, 8
	ctx.r[10].s64 = ctx.r[29].s64 + 8;
	// 825BEFB4: 396100A8  addi r11, r1, 0xa8
	ctx.r[11].s64 = ctx.r[1].s64 + 168;
	// 825BEFB8: 7D08E850  subf r8, r8, r29
	ctx.r[8].s64 = ctx.r[29].s64 - ctx.r[8].s64;
	pc = 0x825BEFBC; continue 'dispatch;
            }
            0x825BEFBC => {
    //   block [0x825BEFBC..0x825BF078)
	// 825BEFBC: 7CE8582E  lwzx r7, r8, r11
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825BEFC0: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 825BEFC4: 80CAFFFC  lwz r6, -4(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) } as u64;
	// 825BEFC8: 80AA0000  lwz r5, 0(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BEFCC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825BEFD0: 808A0004  lwz r4, 4(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BEFD4: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 825BEFD8: 90EBFFF8  stw r7, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[7].u32 ) };
	// 825BEFDC: 90CBFFFC  stw r6, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[6].u32 ) };
	// 825BEFE0: 90AB0000  stw r5, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 825BEFE4: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 825BEFE8: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 825BEFEC: 4199FFD0  bgt cr6, 0x825befbc
	if ctx.cr[6].gt {
	pc = 0x825BEFBC; continue 'dispatch;
	}
	// 825BEFF0: 816100A8  lwz r11, 0xa8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 825BEFF4: 81540000  lwz r10, 0(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BEFF8: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 825BEFFC: 834B0000  lwz r26, 0(r11)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF000: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 825BF004: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 825BF008: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BF00C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 825BF010: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 825BF014: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 825BF018: 82CA0000  lwz r22, 0(r10)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF01C: 7C00B22C  dcbt 0, r22
	// 825BF020: 39600080  li r11, 0x80
	ctx.r[11].s64 = 128;
	// 825BF024: 7C0BB22C  dcbt r11, r22
	// 825BF028: 39600100  li r11, 0x100
	ctx.r[11].s64 = 256;
	// 825BF02C: 7C0BB22C  dcbt r11, r22
	// 825BF030: 39600180  li r11, 0x180
	ctx.r[11].s64 = 384;
	// 825BF034: 7C0BB22C  dcbt r11, r22
	// 825BF038: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 825BF03C: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF040: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825BF044: 91410088  stw r10, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 825BF048: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 825BF04C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF050: 814B0098  lwz r10, 0x98(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(152 as u32) ) } as u64;
	// 825BF054: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825BF058: 419A0020  beq cr6, 0x825bf078
	if ctx.cr[6].eq {
	pc = 0x825BF078; continue 'dispatch;
	}
	// 825BF05C: 812B009C  lwz r9, 0x9c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) } as u64;
	// 825BF060: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 825BF064: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 825BF068: 912B009C  stw r9, 0x9c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), ctx.r[9].u32 ) };
	// 825BF06C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF070: 914B0098  stw r10, 0x98(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(152 as u32), ctx.r[10].u32 ) };
	// 825BF074: 48000010  b 0x825bf084
	pc = 0x825BF084; continue 'dispatch;
            }
            0x825BF078 => {
    //   block [0x825BF078..0x825BF084)
	// 825BF078: 3880000C  li r4, 0xc
	ctx.r[4].s64 = 12;
	// 825BF07C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825BF080: 4BEA4DC1  bl 0x82463e40
	ctx.lr = 0x825BF084;
	sub_82463E40(ctx, base);
	pc = 0x825BF084; continue 'dispatch;
            }
            0x825BF084 => {
    //   block [0x825BF084..0x825BF098)
	// 825BF084: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825BF088: 419A0010  beq cr6, 0x825bf098
	if ctx.cr[6].eq {
	pc = 0x825BF098; continue 'dispatch;
	}
	// 825BF08C: 7C721B78  mr r18, r3
	ctx.r[18].u64 = ctx.r[3].u64;
	// 825BF090: 93630000  stw r27, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 825BF094: 48000008  b 0x825bf09c
	pc = 0x825BF09C; continue 'dispatch;
            }
            0x825BF098 => {
    //   block [0x825BF098..0x825BF09C)
	// 825BF098: 7F72DB78  mr r18, r27
	ctx.r[18].u64 = ctx.r[27].u64;
	pc = 0x825BF09C; continue 'dispatch;
            }
            0x825BF09C => {
    //   block [0x825BF09C..0x825BF0F0)
	// 825BF09C: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF0A0: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 825BF0A4: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 825BF0A8: 9B610050  stb r27, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u8 ) };
	// 825BF0AC: 7D6BB214  add r11, r11, r22
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[22].u64;
	// 825BF0B0: 9B610051  stb r27, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[27].u8 ) };
	// 825BF0B4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 825BF0B8: 39CB0010  addi r14, r11, 0x10
	ctx.r[14].s64 = ctx.r[11].s64 + 16;
	// 825BF0BC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825BF0C0: C3C88E30  lfs f30, -0x71d0(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-29136 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825BF0C4: C3A9BFFC  lfs f29, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 825BF0C8: 7F70DB78  mr r16, r27
	ctx.r[16].u64 = ctx.r[27].u64;
	// 825BF0CC: 3AA00001  li r21, 1
	ctx.r[21].s64 = 1;
	// 825BF0D0: C38A2074  lfs f28, 0x2074(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8308 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 825BF0D4: 3AF60010  addi r23, r22, 0x10
	ctx.r[23].s64 = ctx.r[22].s64 + 16;
	// 825BF0D8: 3BF20010  addi r31, r18, 0x10
	ctx.r[31].s64 = ctx.r[18].s64 + 16;
	// 825BF0DC: 3A6B08F0  addi r19, r11, 0x8f0
	ctx.r[19].s64 = ctx.r[11].s64 + 2288;
	// 825BF0E0: 3A20FFFF  li r17, -1
	ctx.r[17].s64 = -1;
	// 825BF0E4: 39E00010  li r15, 0x10
	ctx.r[15].s64 = 16;
	// 825BF0E8: 48000008  b 0x825bf0f0
	pc = 0x825BF0F0; continue 'dispatch;
	// 825BF0EC: 83A11734  lwz r29, 0x1734(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(5940 as u32) ) } as u64;
            }
            0x825BF0F0 => {
    //   block [0x825BF0F0..0x825BF110)
	// 825BF0F0: 80C11744  lwz r6, 0x1744(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(5956 as u32) ) } as u64;
	// 825BF0F4: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 825BF0F8: 409A0058  bne cr6, 0x825bf150
	if !ctx.cr[6].eq {
	pc = 0x825BF150; continue 'dispatch;
	}
	// 825BF0FC: 88F70003  lbz r7, 3(r23)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[23].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BF100: 3957000C  addi r10, r23, 0xc
	ctx.r[10].s64 = ctx.r[23].s64 + 12;
	// 825BF104: 397F0008  addi r11, r31, 8
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	// 825BF108: 7D1FB850  subf r8, r31, r23
	ctx.r[8].s64 = ctx.r[23].s64 - ctx.r[31].s64;
	// 825BF10C: 7CE92670  srawi r9, r7, 4
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[7].s32 >> 4) as i64;
	pc = 0x825BF110; continue 'dispatch;
            }
            0x825BF110 => {
    //   block [0x825BF110..0x825BF150)
	// 825BF110: 80CAFFF4  lwz r6, -0xc(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) } as u64;
	// 825BF114: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 825BF118: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825BF11C: 90CBFFF8  stw r6, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[6].u32 ) };
	// 825BF120: 80CAFFF8  lwz r6, -8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825BF124: 90CBFFFC  stw r6, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[6].u32 ) };
	// 825BF128: 7CC8582E  lwzx r6, r8, r11
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825BF12C: 90CB0000  stw r6, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 825BF130: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF134: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 825BF138: 90CB0004  stw r6, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 825BF13C: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 825BF140: 4199FFD0  bgt cr6, 0x825bf110
	if ctx.cr[6].gt {
	pc = 0x825BF110; continue 'dispatch;
	}
	// 825BF144: 83D70008  lwz r30, 8(r23)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BF148: 7EE7BA14  add r23, r7, r23
	ctx.r[23].u64 = ctx.r[7].u64 + ctx.r[23].u64;
	// 825BF14C: 48000258  b 0x825bf3a4
	pc = 0x825BF3A4; continue 'dispatch;
            }
            0x825BF150 => {
    //   block [0x825BF150..0x825BF178)
	// 825BF150: 81770008  lwz r11, 8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BF154: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 825BF158: 83C60000  lwz r30, 0(r6)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF15C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825BF160: 409A0058  bne cr6, 0x825bf1b8
	if !ctx.cr[6].eq {
	pc = 0x825BF1B8; continue 'dispatch;
	}
	// 825BF164: 88F70003  lbz r7, 3(r23)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[23].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BF168: 3957000C  addi r10, r23, 0xc
	ctx.r[10].s64 = ctx.r[23].s64 + 12;
	// 825BF16C: 397F0008  addi r11, r31, 8
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	// 825BF170: 7D1FB850  subf r8, r31, r23
	ctx.r[8].s64 = ctx.r[23].s64 - ctx.r[31].s64;
	// 825BF174: 7CE92670  srawi r9, r7, 4
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[7].s32 >> 4) as i64;
	pc = 0x825BF178; continue 'dispatch;
            }
            0x825BF178 => {
    //   block [0x825BF178..0x825BF1B8)
	// 825BF178: 80AAFFF4  lwz r5, -0xc(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) } as u64;
	// 825BF17C: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 825BF180: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825BF184: 90ABFFF8  stw r5, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[5].u32 ) };
	// 825BF188: 80AAFFF8  lwz r5, -8(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825BF18C: 90ABFFFC  stw r5, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[5].u32 ) };
	// 825BF190: 7CAB402E  lwzx r5, r11, r8
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 825BF194: 90AB0000  stw r5, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 825BF198: 80AA0000  lwz r5, 0(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF19C: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 825BF1A0: 90AB0004  stw r5, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 825BF1A4: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 825BF1A8: 4199FFD0  bgt cr6, 0x825bf178
	if ctx.cr[6].gt {
	pc = 0x825BF178; continue 'dispatch;
	}
	// 825BF1AC: 7EE7BA14  add r23, r7, r23
	ctx.r[23].u64 = ctx.r[7].u64 + ctx.r[23].u64;
	// 825BF1B0: 39660004  addi r11, r6, 4
	ctx.r[11].s64 = ctx.r[6].s64 + 4;
	// 825BF1B4: 480001EC  b 0x825bf3a0
	pc = 0x825BF3A0; continue 'dispatch;
            }
            0x825BF1B8 => {
    //   block [0x825BF1B8..0x825BF1D4)
	// 825BF1B8: 40990054  ble cr6, 0x825bf20c
	if !ctx.cr[6].gt {
	pc = 0x825BF20C; continue 'dispatch;
	}
	// 825BF1BC: 89770000  lbz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF1C0: 38970020  addi r4, r23, 0x20
	ctx.r[4].s64 = ctx.r[23].s64 + 32;
	// 825BF1C4: 556B073C  rlwinm r11, r11, 0, 0x1c, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825BF1C8: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 825BF1CC: 419A0008  beq cr6, 0x825bf1d4
	if ctx.cr[6].eq {
	pc = 0x825BF1D4; continue 'dispatch;
	}
	// 825BF1D0: 38970010  addi r4, r23, 0x10
	ctx.r[4].s64 = ctx.r[23].s64 + 16;
	pc = 0x825BF1D4; continue 'dispatch;
            }
            0x825BF1D4 => {
    //   block [0x825BF1D4..0x825BF20C)
	// 825BF1D4: 89570003  lbz r10, 3(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[23].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BF1D8: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 825BF1DC: 89630001  lbz r11, 1(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BF1E0: 7EEABA14  add r23, r10, r23
	ctx.r[23].u64 = ctx.r[10].u64 + ctx.r[23].u64;
	// 825BF1E4: 80A100AC  lwz r5, 0xac(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 825BF1E8: 556A103E  rotlwi r10, r11, 2
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 825BF1EC: 80D90004  lwz r6, 4(r25)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BF1F0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BF1F4: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BF1F8: 7D6BD214  add r11, r11, r26
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 825BF1FC: 816B16B4  lwz r11, 0x16b4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5812 as u32) ) } as u64;
	// 825BF200: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BF204: 4E800421  bctrl
	ctx.lr = 0x825BF208;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BF208: 4800022C  b 0x825bf434
	pc = 0x825BF434; continue 'dispatch;
            }
            0x825BF20C => {
    //   block [0x825BF20C..0x825BF2A4)
	// 825BF20C: 80A100A8  lwz r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 825BF210: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 825BF214: 80FD0004  lwz r7, 4(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BF218: 7F08C378  mr r8, r24
	ctx.r[8].u64 = ctx.r[24].u64;
	// 825BF21C: 80DD0000  lwz r6, 0(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF220: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 825BF224: 80850008  lwz r4, 8(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BF228: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF22C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BF230: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BF234: 4E800421  bctrl
	ctx.lr = 0x825BF238;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BF238: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF23C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BF240: 419A0148  beq cr6, 0x825bf388
	if ctx.cr[6].eq {
	pc = 0x825BF388; continue 'dispatch;
	}
	// 825BF244: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF248: 38A10450  addi r5, r1, 0x450
	ctx.r[5].s64 = ctx.r[1].s64 + 1104;
	// 825BF24C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825BF250: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 825BF254: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BF258: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BF25C: 4E800421  bctrl
	ctx.lr = 0x825BF260;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BF260: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 825BF264: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 825BF268: 923F0004  stw r17, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[17].u32 ) };
	// 825BF26C: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 825BF270: 816100A0  lwz r11, 0xa0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 825BF274: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF278: 816100A8  lwz r11, 0xa8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 825BF27C: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BF280: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BF284: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BF288: 554A2834  slwi r10, r10, 5
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BF28C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825BF290: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825BF294: 7D6BD214  add r11, r11, r26
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 825BF298: 419A000C  beq cr6, 0x825bf2a4
	if ctx.cr[6].eq {
	pc = 0x825BF2A4; continue 'dispatch;
	}
	// 825BF29C: 896B12B0  lbz r11, 0x12b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(4784 as u32) ) } as u64;
	// 825BF2A0: 48000008  b 0x825bf2a8
	pc = 0x825BF2A8; continue 'dispatch;
            }
            0x825BF2A4 => {
    //   block [0x825BF2A4..0x825BF2A8)
	// 825BF2A4: 896B0EB0  lbz r11, 0xeb0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3760 as u32) ) } as u64;
	pc = 0x825BF2A8; continue 'dispatch;
            }
            0x825BF2A8 => {
    //   block [0x825BF2A8..0x825BF2F0)
	// 825BF2A8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BF2AC: 9B7F0002  stb r27, 2(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(2 as u32), ctx.r[27].u8 ) };
	// 825BF2B0: 3B8100A0  addi r28, r1, 0xa0
	ctx.r[28].s64 = ctx.r[1].s64 + 160;
	// 825BF2B4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825BF2B8: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 825BF2BC: 997F0001  stb r11, 1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 825BF2C0: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BF2C4: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825BF2C8: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BF2CC: 7D6BD214  add r11, r11, r26
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 825BF2D0: 816B16F0  lwz r11, 0x16f0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5872 as u32) ) } as u64;
	// 825BF2D4: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 825BF2D8: 409A0018  bne cr6, 0x825bf2f0
	if !ctx.cr[6].eq {
	pc = 0x825BF2F0; continue 'dispatch;
	}
	// 825BF2DC: 388103E0  addi r4, r1, 0x3e0
	ctx.r[4].s64 = ctx.r[1].s64 + 992;
	// 825BF2E0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825BF2E4: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 825BF2E8: 3B8103E0  addi r28, r1, 0x3e0
	ctx.r[28].s64 = ctx.r[1].s64 + 992;
	// 825BF2EC: 4BFFFA1D  bl 0x825bed08
	ctx.lr = 0x825BF2F0;
	sub_825BED08(ctx, base);
	pc = 0x825BF2F0; continue 'dispatch;
            }
            0x825BF2F0 => {
    //   block [0x825BF2F0..0x825BF364)
	// 825BF2F0: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BF2F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825BF2F8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825BF2FC: 556A103E  rotlwi r10, r11, 2
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 825BF300: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BF304: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BF308: 7D6BD214  add r11, r11, r26
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 825BF30C: 814B16D8  lwz r10, 0x16d8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5848 as u32) ) } as u64;
	// 825BF310: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825BF314: 419A0050  beq cr6, 0x825bf364
	if ctx.cr[6].eq {
	pc = 0x825BF364; continue 'dispatch;
	}
	// 825BF318: 395D0004  addi r10, r29, 4
	ctx.r[10].s64 = ctx.r[29].s64 + 4;
	// 825BF31C: D39F000C  stfs f28, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 825BF320: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 825BF324: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 825BF328: 995F0000  stb r10, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	pc = 0x825BF364; continue 'dispatch;
            }
            0x825BF364 => {
    //   block [0x825BF364..0x825BF388)
	// 825BF364: 395D0002  addi r10, r29, 2
	ctx.r[10].s64 = ctx.r[29].s64 + 2;
	// 825BF368: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 825BF36C: 995F0000  stb r10, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 825BF370: 816B16B0  lwz r11, 0x16b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5808 as u32) ) } as u64;
	// 825BF374: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BF378: 4E800421  bctrl
	ctx.lr = 0x825BF37C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BF37C: 7D7F1850  subf r11, r31, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[31].s64;
	// 825BF380: 997F0003  stb r11, 3(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 825BF384: 48000014  b 0x825bf398
	pc = 0x825BF398; continue 'dispatch;
            }
            0x825BF388 => {
    //   block [0x825BF388..0x825BF3A0)
	// 825BF388: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 825BF38C: 923F0004  stw r17, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[17].u32 ) };
	// 825BF390: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 825BF394: 99FF0003  stb r15, 3(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(3 as u32), ctx.r[15].u8 ) };
	// 825BF398: 81611744  lwz r11, 0x1744(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(5956 as u32) ) } as u64;
	// 825BF39C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x825BF3A0; continue 'dispatch;
            }
            0x825BF3A0 => {
    //   block [0x825BF3A0..0x825BF3A4)
	// 825BF3A0: 91611744  stw r11, 0x1744(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(5956 as u32), ctx.r[11].u32 ) };
	pc = 0x825BF3A4; continue 'dispatch;
            }
            0x825BF3A4 => {
    //   block [0x825BF3A4..0x825BF3E4)
	// 825BF3A4: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF3A8: 2B0B0006  cmplwi cr6, r11, 6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 6 as u32, &mut ctx.xer);
	// 825BF3AC: 41990088  bgt cr6, 0x825bf434
	if ctx.cr[6].gt {
	pc = 0x825BF434; continue 'dispatch;
	}
	// 825BF3B0: 3D80825C  lis r12, -0x7da4
	ctx.r[12].s64 = -2107899904;
	// 825BF3B4: 398CF3C8  addi r12, r12, -0xc38
	ctx.r[12].s64 = ctx.r[12].s64 + -3128;
	// 825BF3B8: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 825BF3BC: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 825BF3C0: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 825BF3C4: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x825BF430; continue 'dispatch;
		},
		1 => {
	pc = 0x825BF430; continue 'dispatch;
		},
		2 => {
	pc = 0x825BF464; continue 'dispatch;
		},
		3 => {
	pc = 0x825BF4D0; continue 'dispatch;
		},
		4 => {
	pc = 0x825BF8A4; continue 'dispatch;
		},
		5 => {
	pc = 0x825BF5E8; continue 'dispatch;
		},
		6 => {
	pc = 0x825BF3E4; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 825BF3C8: 825BF430  lwz r18, -0xbd0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-3024 as u32) ) } as u64;
	// 825BF3CC: 825BF430  lwz r18, -0xbd0(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-3024 as u32) ) } as u64;
	// 825BF3D0: 825BF464  lwz r18, -0xb9c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-2972 as u32) ) } as u64;
	// 825BF3D4: 825BF4D0  lwz r18, -0xb30(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-2864 as u32) ) } as u64;
	// 825BF3D8: 825BF8A4  lwz r18, -0x75c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-1884 as u32) ) } as u64;
	// 825BF3DC: 825BF5E8  lwz r18, -0xa18(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-2584 as u32) ) } as u64;
	// 825BF3E0: 825BF3E4  lwz r18, -0xc1c(r27)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-3100 as u32) ) } as u64;
            }
            0x825BF3E4 => {
    //   block [0x825BF3E4..0x825BF430)
	// 825BF3E4: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF3E8: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 825BF3EC: 38A10450  addi r5, r1, 0x450
	ctx.r[5].s64 = ctx.r[1].s64 + 1104;
	// 825BF3F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825BF3F4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 825BF3F8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BF3FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BF400: 4E800421  bctrl
	ctx.lr = 0x825BF404;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BF404: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 825BF408: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 825BF40C: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 825BF410: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF414: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825BF418: 80C100A8  lwz r6, 0xa8(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 825BF41C: 808100A0  lwz r4, 0xa0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 825BF420: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF424: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 825BF428: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BF42C: 4E800421  bctrl
	ctx.lr = 0x825BF430;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x825BF430 => {
    //   block [0x825BF430..0x825BF434)
	// 825BF430: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	pc = 0x825BF434; continue 'dispatch;
            }
            0x825BF434 => {
    //   block [0x825BF434..0x825BF464)
	// 825BF434: 7F177040  cmplw cr6, r23, r14
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[14].u32, &mut ctx.xer);
	// 825BF438: 409A0778  bne cr6, 0x825bfbb0
	if !ctx.cr[6].eq {
	pc = 0x825BFBB0; continue 'dispatch;
	}
	// 825BF43C: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 825BF440: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF444: 8163009C  lwz r11, 0x9c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(156 as u32) ) } as u64;
	// 825BF448: 81430034  lwz r10, 0x34(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 825BF44C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825BF450: 4198071C  blt cr6, 0x825bfb6c
	if ctx.cr[6].lt {
	pc = 0x825BFB6C; continue 'dispatch;
	}
	// 825BF454: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 825BF458: 3880000C  li r4, 0xc
	ctx.r[4].s64 = 12;
	// 825BF45C: 4BEA4ABD  bl 0x82463f18
	ctx.lr = 0x825BF460;
	sub_82463F18(ctx, base);
	// 825BF460: 48000724  b 0x825bfb84
	pc = 0x825BFB84; continue 'dispatch;
            }
            0x825BF464 => {
    //   block [0x825BF464..0x825BF4D0)
	// 825BF464: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF468: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 825BF46C: 38A10450  addi r5, r1, 0x450
	ctx.r[5].s64 = ctx.r[1].s64 + 1104;
	// 825BF470: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825BF474: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 825BF478: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BF47C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BF480: 4E800421  bctrl
	ctx.lr = 0x825BF484;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BF484: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 825BF488: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 825BF48C: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 825BF490: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BF494: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825BF498: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 825BF49C: 556A103E  rotlwi r10, r11, 2
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 825BF4A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825BF4A4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BF4A8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825BF4AC: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BF4B0: 7D6BD214  add r11, r11, r26
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 825BF4B4: 816B16DC  lwz r11, 0x16dc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5852 as u32) ) } as u64;
	// 825BF4B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BF4BC: 4E800421  bctrl
	ctx.lr = 0x825BF4C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BF4C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825BF4C4: 7D7DF850  subf r11, r29, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[29].s64;
	// 825BF4C8: 997D0003  stb r11, 3(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 825BF4CC: 4BFFFF68  b 0x825bf434
	pc = 0x825BF434; continue 'dispatch;
            }
            0x825BF4D0 => {
    //   block [0x825BF4D0..0x825BF5E8)
	// 825BF4D0: 39610100  addi r11, r1, 0x100
	ctx.r[11].s64 = ctx.r[1].s64 + 256;
	pc = 0x825BF5E8; continue 'dispatch;
            }
            0x825BF5E8 => {
    //   block [0x825BF5E8..0x825BF8A4)
	// 825BF5E8: 39610100  addi r11, r1, 0x100
	ctx.r[11].s64 = ctx.r[1].s64 + 256;
	pc = 0x825BF8A4; continue 'dispatch;
            }
            0x825BF8A4 => {
    //   block [0x825BF8A4..0x825BFDB4)
	// 825BF8A4: 80E100A8  lwz r7, 0xa8(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 825BF8A8: C1BF000C  lfs f13, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825BF8AC: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 825BF8B0: 3B7F000C  addi r27, r31, 0xc
	ctx.r[27].s64 = ctx.r[31].s64 + 12;
	// 825BF8B4: C0070050  lfs f0, 0x50(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BF8B8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825BF8BC: 419A01E8  beq cr6, 0x825bfaa4
	if ctx.cr[6].eq {
	pc = 0x825BFAA4; continue 'dispatch;
	}
	// 825BF8C0: C0070054  lfs f0, 0x54(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BF8C4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825BF8C8: 419800B8  blt cr6, 0x825bf980
	if ctx.cr[6].lt {
	pc = 0x825BF980; continue 'dispatch;
	}
	// 825BF8CC: 816100A0  lwz r11, 0xa0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 825BF8D0: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 825BF8D4: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 825BF8D8: 38C10078  addi r6, r1, 0x78
	ctx.r[6].s64 = ctx.r[1].s64 + 120;
	// 825BF8DC: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BFDB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BFDB8 size=4240
    let mut pc: u32 = 0x825BFDB8;
    'dispatch: loop {
        match pc {
            0x825BFDB8 => {
    //   block [0x825BFDB8..0x825BFE08)
	// 825BFDB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BFDBC: 4BF752C5  bl 0x82535080
	ctx.lr = 0x825BFDC0;
	sub_82535080(ctx, base);
	// 825BFDC0: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 825BFDC4: 4BF76225  bl 0x82535fe8
	ctx.lr = 0x825BFDC8;
	sub_82535FB0(ctx, base);
	// 825BFDC8: 9421F6D0  stwu r1, -0x930(r1)
	ea = ctx.r[1].u32.wrapping_add(-2352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BFDCC: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 825BFDD0: 7C701B78  mr r16, r3
	ctx.r[16].u64 = ctx.r[3].u64;
	// 825BFDD4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825BFDD8: 7CD43378  mr r20, r6
	ctx.r[20].u64 = ctx.r[6].u64;
	// 825BFDDC: 7CF13B78  mr r17, r7
	ctx.r[17].u64 = ctx.r[7].u64;
	// 825BFDE0: 9361096C  stw r27, 0x96c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(2412 as u32), ctx.r[27].u32 ) };
	// 825BFDE4: 7D384B78  mr r24, r9
	ctx.r[24].u64 = ctx.r[9].u64;
	// 825BFDE8: 81100000  lwz r8, 0(r16)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BFDEC: 93A10954  stw r29, 0x954(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(2388 as u32), ctx.r[29].u32 ) };
	// 825BFDF0: 7C00422C  dcbt 0, r8
	// 825BFDF4: 38E100C8  addi r7, r1, 0xc8
	ctx.r[7].s64 = ctx.r[1].s64 + 200;
	// 825BFDF8: 39200007  li r9, 7
	ctx.r[9].s64 = 7;
	// 825BFDFC: 395D0008  addi r10, r29, 8
	ctx.r[10].s64 = ctx.r[29].s64 + 8;
	// 825BFE00: 396100C8  addi r11, r1, 0xc8
	ctx.r[11].s64 = ctx.r[1].s64 + 200;
	// 825BFE04: 7CE7E850  subf r7, r7, r29
	ctx.r[7].s64 = ctx.r[29].s64 - ctx.r[7].s64;
	pc = 0x825BFE08; continue 'dispatch;
            }
            0x825BFE08 => {
    //   block [0x825BFE08..0x825BFEE8)
	// 825BFE08: 7CC7582E  lwzx r6, r7, r11
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825BFE0C: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 825BFE10: 80AAFFFC  lwz r5, -4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) } as u64;
	// 825BFE14: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BFE18: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825BFE1C: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BFE20: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 825BFE24: 90CBFFF8  stw r6, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[6].u32 ) };
	// 825BFE28: 90ABFFFC  stw r5, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[5].u32 ) };
	// 825BFE2C: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 825BFE30: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 825BFE34: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 825BFE38: 4199FFD0  bgt cr6, 0x825bfe08
	if ctx.cr[6].gt {
	pc = 0x825BFE08; continue 'dispatch;
	}
	// 825BFE3C: 816100C8  lwz r11, 0xc8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 825BFE40: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825BFE44: 832B0000  lwz r25, 0(r11)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BFE48: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 825BFE4C: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 825BFE50: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 825BFE54: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BFE58: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 825BFE5C: 816100C0  lwz r11, 0xc0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 825BFE60: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 825BFE64: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BFE68: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 825BFE6C: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 825BFE70: 916100C4  stw r11, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 825BFE74: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 825BFE78: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 825BFE7C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 825BFE80: 82C80000  lwz r22, 0(r8)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BFE84: 7D735B78  mr r19, r11
	ctx.r[19].u64 = ctx.r[11].u64;
	// 825BFE88: 7D755B78  mr r21, r11
	ctx.r[21].u64 = ctx.r[11].u64;
	// 825BFE8C: 7C00B22C  dcbt 0, r22
	// 825BFE90: 39600080  li r11, 0x80
	ctx.r[11].s64 = 128;
	// 825BFE94: 7C0BB22C  dcbt r11, r22
	// 825BFE98: 39600100  li r11, 0x100
	ctx.r[11].s64 = 256;
	// 825BFE9C: 7C0BB22C  dcbt r11, r22
	// 825BFEA0: 39600180  li r11, 0x180
	ctx.r[11].s64 = 384;
	// 825BFEA4: 7C0BB22C  dcbt r11, r22
	// 825BFEA8: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BFEAC: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 825BFEB0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825BFEB4: 914100B0  stw r10, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[10].u32 ) };
	// 825BFEB8: 9161009C  stw r11, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 825BFEBC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BFEC0: 814B0098  lwz r10, 0x98(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(152 as u32) ) } as u64;
	// 825BFEC4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825BFEC8: 419A0020  beq cr6, 0x825bfee8
	if ctx.cr[6].eq {
	pc = 0x825BFEE8; continue 'dispatch;
	}
	// 825BFECC: 812B009C  lwz r9, 0x9c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) } as u64;
	// 825BFED0: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 825BFED4: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 825BFED8: 912B009C  stw r9, 0x9c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), ctx.r[9].u32 ) };
	// 825BFEDC: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BFEE0: 914B0098  stw r10, 0x98(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(152 as u32), ctx.r[10].u32 ) };
	// 825BFEE4: 48000010  b 0x825bfef4
	pc = 0x825BFEF4; continue 'dispatch;
            }
            0x825BFEE8 => {
    //   block [0x825BFEE8..0x825BFEF4)
	// 825BFEE8: 3880000C  li r4, 0xc
	ctx.r[4].s64 = 12;
	// 825BFEEC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825BFEF0: 4BEA3F51  bl 0x82463e40
	ctx.lr = 0x825BFEF4;
	sub_82463E40(ctx, base);
	pc = 0x825BFEF4; continue 'dispatch;
            }
            0x825BFEF4 => {
    //   block [0x825BFEF4..0x825BFF08)
	// 825BFEF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825BFEF8: 419A0010  beq cr6, 0x825bff08
	if ctx.cr[6].eq {
	pc = 0x825BFF08; continue 'dispatch;
	}
	// 825BFEFC: 7C6F1B78  mr r15, r3
	ctx.r[15].u64 = ctx.r[3].u64;
	// 825BFF00: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825BFF04: 48000008  b 0x825bff0c
	pc = 0x825BFF0C; continue 'dispatch;
            }
            0x825BFF08 => {
    //   block [0x825BFF08..0x825BFF0C)
	// 825BFF08: 7FCFF378  mr r15, r30
	ctx.r[15].u64 = ctx.r[30].u64;
	pc = 0x825BFF0C; continue 'dispatch;
            }
            0x825BFF0C => {
    //   block [0x825BFF0C..0x825BFF64)
	// 825BFF0C: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BFF10: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 825BFF14: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 825BFF18: 93C10098  stw r30, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[30].u32 ) };
	// 825BFF1C: 7D6BB214  add r11, r11, r22
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[22].u64;
	// 825BFF20: 9BC10060  stb r30, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u8 ) };
	// 825BFF24: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 825BFF28: 9BC10061  stb r30, 0x61(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(97 as u32), ctx.r[30].u8 ) };
	// 825BFF2C: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 825BFF30: C3C88E30  lfs f30, -0x71d0(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-29136 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825BFF34: 3A400001  li r18, 1
	ctx.r[18].s64 = 1;
	// 825BFF38: C3A9BFFC  lfs f29, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 825BFF3C: 3AF60010  addi r23, r22, 0x10
	ctx.r[23].s64 = ctx.r[22].s64 + 16;
	// 825BFF40: 3BEF0010  addi r31, r15, 0x10
	ctx.r[31].s64 = ctx.r[15].s64 + 16;
	// 825BFF44: C38A2074  lfs f28, 0x2074(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8308 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 825BFF48: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 825BFF4C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825BFF50: 39CB08F0  addi r14, r11, 0x8f0
	ctx.r[14].s64 = ctx.r[11].s64 + 2288;
	// 825BFF54: 48000010  b 0x825bff64
	pc = 0x825BFF64; continue 'dispatch;
	// 825BFF58: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825BFF5C: 8361096C  lwz r27, 0x96c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(2412 as u32) ) } as u64;
	// 825BFF60: 83A10954  lwz r29, 0x954(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(2388 as u32) ) } as u64;
            }
            0x825BFF64 => {
    //   block [0x825BFF64..0x825BFF80)
	// 825BFF64: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 825BFF68: 409A0060  bne cr6, 0x825bffc8
	if !ctx.cr[6].eq {
	pc = 0x825BFFC8; continue 'dispatch;
	}
	// 825BFF6C: 88F70003  lbz r7, 3(r23)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[23].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BFF70: 3957000C  addi r10, r23, 0xc
	ctx.r[10].s64 = ctx.r[23].s64 + 12;
	// 825BFF74: 397F0008  addi r11, r31, 8
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	// 825BFF78: 7D1FB850  subf r8, r31, r23
	ctx.r[8].s64 = ctx.r[23].s64 - ctx.r[31].s64;
	// 825BFF7C: 7CE92670  srawi r9, r7, 4
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[7].s32 >> 4) as i64;
	pc = 0x825BFF80; continue 'dispatch;
            }
            0x825BFF80 => {
    //   block [0x825BFF80..0x825BFFC8)
	// 825BFF80: 80CAFFF4  lwz r6, -0xc(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) } as u64;
	// 825BFF84: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 825BFF88: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825BFF8C: 90CBFFF8  stw r6, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[6].u32 ) };
	// 825BFF90: 80CAFFF8  lwz r6, -8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825BFF94: 90CBFFFC  stw r6, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[6].u32 ) };
	// 825BFF98: 7CC8582E  lwzx r6, r8, r11
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825BFF9C: 90CB0000  stw r6, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 825BFFA0: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BFFA4: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 825BFFA8: 90CB0004  stw r6, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 825BFFAC: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 825BFFB0: 4199FFD0  bgt cr6, 0x825bff80
	if ctx.cr[6].gt {
	pc = 0x825BFF80; continue 'dispatch;
	}
	// 825BFFB4: 39770004  addi r11, r23, 4
	ctx.r[11].s64 = ctx.r[23].s64 + 4;
	// 825BFFB8: 7EE7BA14  add r23, r7, r23
	ctx.r[23].u64 = ctx.r[7].u64 + ctx.r[23].u64;
	// 825BFFBC: 834B0000  lwz r26, 0(r11)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BFFC0: 838B0004  lwz r28, 4(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BFFC4: 480002E0  b 0x825c02a4
	pc = 0x825C02A4; continue 'dispatch;
            }
            0x825BFFC8 => {
    //   block [0x825BFFC8..0x825BFFF0)
	// 825BFFC8: 839B0004  lwz r28, 4(r27)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BFFCC: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 825BFFD0: 81770008  lwz r11, 8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BFFD4: 835B0000  lwz r26, 0(r27)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BFFD8: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825BFFDC: 409A0014  bne cr6, 0x825bfff0
	if !ctx.cr[6].eq {
	pc = 0x825BFFF0; continue 'dispatch;
	}
	// 825BFFE0: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BFFE4: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825BFFE8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825BFFEC: 419A0008  beq cr6, 0x825bfff4
	if ctx.cr[6].eq {
	pc = 0x825BFFF4; continue 'dispatch;
	}
	pc = 0x825BFFF0; continue 'dispatch;
            }
            0x825BFFF0 => {
    //   block [0x825BFFF0..0x825BFFF4)
	// 825BFFF0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x825BFFF4; continue 'dispatch;
            }
            0x825BFFF4 => {
    //   block [0x825BFFF4..0x825C0014)
	// 825BFFF4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BFFF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BFFFC: 419A0054  beq cr6, 0x825c0050
	if ctx.cr[6].eq {
	pc = 0x825C0050; continue 'dispatch;
	}
	// 825C0000: 88F70003  lbz r7, 3(r23)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[23].u32.wrapping_add(3 as u32) ) } as u64;
	// 825C0004: 3957000C  addi r10, r23, 0xc
	ctx.r[10].s64 = ctx.r[23].s64 + 12;
	// 825C0008: 397F0008  addi r11, r31, 8
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	// 825C000C: 7D1FB850  subf r8, r31, r23
	ctx.r[8].s64 = ctx.r[23].s64 - ctx.r[31].s64;
	// 825C0010: 7CE92670  srawi r9, r7, 4
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[7].s32 >> 4) as i64;
	pc = 0x825C0014; continue 'dispatch;
            }
            0x825C0014 => {
    //   block [0x825C0014..0x825C0050)
	// 825C0014: 80CAFFF4  lwz r6, -0xc(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) } as u64;
	// 825C0018: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 825C001C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825C0020: 90CBFFF8  stw r6, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[6].u32 ) };
	// 825C0024: 80CAFFF8  lwz r6, -8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825C0028: 90CBFFFC  stw r6, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[6].u32 ) };
	// 825C002C: 7CCB402E  lwzx r6, r11, r8
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 825C0030: 90CB0000  stw r6, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 825C0034: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C0038: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 825C003C: 90CB0004  stw r6, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 825C0040: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 825C0044: 4199FFD0  bgt cr6, 0x825c0014
	if ctx.cr[6].gt {
	pc = 0x825C0014; continue 'dispatch;
	}
	// 825C0048: 7EE7BA14  add r23, r7, r23
	ctx.r[23].u64 = ctx.r[7].u64 + ctx.r[23].u64;
	// 825C004C: 48000250  b 0x825c029c
	pc = 0x825C029C; continue 'dispatch;
            }
            0x825C0050 => {
    //   block [0x825C0050..0x825C006C)
	// 825C0050: 81770008  lwz r11, 8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C0054: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825C0058: 4199001C  bgt cr6, 0x825c0074
	if ctx.cr[6].gt {
	pc = 0x825C0074; continue 'dispatch;
	}
	// 825C005C: 409A0010  bne cr6, 0x825c006c
	if !ctx.cr[6].eq {
	pc = 0x825C006C; continue 'dispatch;
	}
	// 825C0060: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C0064: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825C0068: 4199000C  bgt cr6, 0x825c0074
	if ctx.cr[6].gt {
	pc = 0x825C0074; continue 'dispatch;
	}
	pc = 0x825C006C; continue 'dispatch;
            }
            0x825C006C => {
    //   block [0x825C006C..0x825C0074)
	// 825C006C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 825C0070: 48000008  b 0x825c0078
	pc = 0x825C0078; continue 'dispatch;
            }
            0x825C0074 => {
    //   block [0x825C0074..0x825C0078)
	// 825C0074: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x825C0078; continue 'dispatch;
            }
            0x825C0078 => {
    //   block [0x825C0078..0x825C009C)
	// 825C0078: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825C007C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C0080: 419A0054  beq cr6, 0x825c00d4
	if ctx.cr[6].eq {
	pc = 0x825C00D4; continue 'dispatch;
	}
	// 825C0084: 89770000  lbz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C0088: 38970020  addi r4, r23, 0x20
	ctx.r[4].s64 = ctx.r[23].s64 + 32;
	// 825C008C: 556B073C  rlwinm r11, r11, 0, 0x1c, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825C0090: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 825C0094: 419A0008  beq cr6, 0x825c009c
	if ctx.cr[6].eq {
	pc = 0x825C009C; continue 'dispatch;
	}
	// 825C0098: 38970010  addi r4, r23, 0x10
	ctx.r[4].s64 = ctx.r[23].s64 + 16;
	pc = 0x825C009C; continue 'dispatch;
            }
            0x825C009C => {
    //   block [0x825C009C..0x825C00D4)
	// 825C009C: 89570003  lbz r10, 3(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[23].u32.wrapping_add(3 as u32) ) } as u64;
	// 825C00A0: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 825C00A4: 89630001  lbz r11, 1(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C00A8: 7EEABA14  add r23, r10, r23
	ctx.r[23].u64 = ctx.r[10].u64 + ctx.r[23].u64;
	// 825C00AC: 80A100CC  lwz r5, 0xcc(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 825C00B0: 556A103E  rotlwi r10, r11, 2
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 825C00B4: 80D80004  lwz r6, 4(r24)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C00B8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825C00BC: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C00C0: 7D6BCA14  add r11, r11, r25
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 825C00C4: 816B16B4  lwz r11, 0x16b4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5812 as u32) ) } as u64;
	// 825C00C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825C00CC: 4E800421  bctrl
	ctx.lr = 0x825C00D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825C00D0: 480002A0  b 0x825c0370
	pc = 0x825C0370; continue 'dispatch;
            }
            0x825C00D4 => {
    //   block [0x825C00D4..0x825C0144)
	// 825C00D4: 80A100C8  lwz r5, 0xc8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 825C00D8: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 825C00DC: 80FD0004  lwz r7, 4(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C00E0: 7E298B78  mr r9, r17
	ctx.r[9].u64 = ctx.r[17].u64;
	// 825C00E4: 80DD0000  lwz r6, 0(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C00E8: 7E88A378  mr r8, r20
	ctx.r[8].u64 = ctx.r[20].u64;
	// 825C00EC: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 825C00F0: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 825C00F4: 80850008  lwz r4, 8(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C00F8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C00FC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C0100: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825C0104: 4E800421  bctrl
	ctx.lr = 0x825C0108;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825C0108: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C010C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C0110: 419A0178  beq cr6, 0x825c0288
	if ctx.cr[6].eq {
	pc = 0x825C0288; continue 'dispatch;
	}
	// 825C0114: 7F15E040  cmplw cr6, r21, r28
	ctx.cr[6].compare_u32(ctx.r[21].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825C0118: 419A002C  beq cr6, 0x825c0144
	if ctx.cr[6].eq {
	pc = 0x825C0144; continue 'dispatch;
	}
	// 825C011C: 81710000  lwz r11, 0(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C0120: 7F95E378  mr r21, r28
	ctx.r[21].u64 = ctx.r[28].u64;
	// 825C0124: 38A10470  addi r5, r1, 0x470
	ctx.r[5].s64 = ctx.r[1].s64 + 1136;
	// 825C0128: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825C012C: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 825C0130: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825C0134: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825C0138: 4E800421  bctrl
	ctx.lr = 0x825C013C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825C013C: 90610070  stw r3, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[3].u32 ) };
	// 825C0140: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
            }
            0x825C0144 => {
    //   block [0x825C0144..0x825C0174)
	// 825C0144: 7F13D040  cmplw cr6, r19, r26
	ctx.cr[6].compare_u32(ctx.r[19].u32, ctx.r[26].u32, &mut ctx.xer);
	// 825C0148: 419A002C  beq cr6, 0x825c0174
	if ctx.cr[6].eq {
	pc = 0x825C0174; continue 'dispatch;
	}
	// 825C014C: 81740000  lwz r11, 0(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C0150: 7F53D378  mr r19, r26
	ctx.r[19].u64 = ctx.r[26].u64;
	// 825C0154: 38A10670  addi r5, r1, 0x670
	ctx.r[5].s64 = ctx.r[1].s64 + 1648;
	// 825C0158: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825C015C: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 825C0160: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825C0164: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825C0168: 4E800421  bctrl
	ctx.lr = 0x825C016C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825C016C: 90610080  stw r3, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[3].u32 ) };
	// 825C0170: 93410084  stw r26, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[26].u32 ) };
            }
            0x825C0174 => {
    //   block [0x825C0174..0x825C01B0)
	// 825C0174: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 825C0178: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 825C017C: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 825C0180: 935F0004  stw r26, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 825C0184: 812100C8  lwz r9, 0xc8(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 825C0188: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825C018C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825C0190: 554A2834  slwi r10, r10, 5
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825C0194: 81290010  lwz r9, 0x10(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 825C0198: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825C019C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825C01A0: 7D6BCA14  add r11, r11, r25
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 825C01A4: 419A000C  beq cr6, 0x825c01b0
	if ctx.cr[6].eq {
	pc = 0x825C01B0; continue 'dispatch;
	}
	// 825C01A8: 896B12B0  lbz r11, 0x12b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(4784 as u32) ) } as u64;
	// 825C01AC: 48000008  b 0x825c01b4
	pc = 0x825C01B4; continue 'dispatch;
            }
            0x825C01B0 => {
    //   block [0x825C01B0..0x825C01B4)
	// 825C01B0: 896B0EB0  lbz r11, 0xeb0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3760 as u32) ) } as u64;
	pc = 0x825C01B4; continue 'dispatch;
            }
            0x825C01B4 => {
    //   block [0x825C01B4..0x825C01F8)
	// 825C01B4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825C01B8: 9BDF0002  stb r30, 2(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(2 as u32), ctx.r[30].u8 ) };
	// 825C01BC: 3BA100C0  addi r29, r1, 0xc0
	ctx.r[29].s64 = ctx.r[1].s64 + 192;
	// 825C01C0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825C01C4: 997F0001  stb r11, 1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 825C01C8: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C01CC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825C01D0: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C01D4: 7D6BCA14  add r11, r11, r25
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 825C01D8: 816B16F0  lwz r11, 0x16f0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5872 as u32) ) } as u64;
	// 825C01DC: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 825C01E0: 409A0018  bne cr6, 0x825c01f8
	if !ctx.cr[6].eq {
	pc = 0x825C01F8; continue 'dispatch;
	}
	// 825C01E4: 38810400  addi r4, r1, 0x400
	ctx.r[4].s64 = ctx.r[1].s64 + 1024;
	// 825C01E8: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 825C01EC: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 825C01F0: 3BA10400  addi r29, r1, 0x400
	ctx.r[29].s64 = ctx.r[1].s64 + 1024;
	// 825C01F4: 4BFFEB15  bl 0x825bed08
	ctx.lr = 0x825C01F8;
	sub_825BED08(ctx, base);
	pc = 0x825C01F8; continue 'dispatch;
            }
            0x825C01F8 => {
    //   block [0x825C01F8..0x825C0268)
	// 825C01F8: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C01FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825C0200: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825C0204: 556A103E  rotlwi r10, r11, 2
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 825C0208: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825C020C: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C0210: 7D6BCA14  add r11, r11, r25
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 825C0214: 814B16D8  lwz r10, 0x16d8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5848 as u32) ) } as u64;
	// 825C0218: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825C021C: 419A004C  beq cr6, 0x825c0268
	if ctx.cr[6].eq {
	pc = 0x825C0268; continue 'dispatch;
	}
	// 825C0220: 395E0004  addi r10, r30, 4
	ctx.r[10].s64 = ctx.r[30].s64 + 4;
	// 825C0224: D39F000C  stfs f28, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 825C0228: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 825C022C: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 825C0230: 995F0000  stb r10, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	pc = 0x825C0268; continue 'dispatch;
            }
            0x825C0268 => {
    //   block [0x825C0268..0x825C0288)
	// 825C0268: 395E0002  addi r10, r30, 2
	ctx.r[10].s64 = ctx.r[30].s64 + 2;
	// 825C026C: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 825C0270: 995F0000  stb r10, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 825C0274: 816B16B0  lwz r11, 0x16b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5808 as u32) ) } as u64;
	// 825C0278: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825C027C: 4E800421  bctrl
	ctx.lr = 0x825C0280;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825C0280: 7D7F1850  subf r11, r31, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[31].s64;
	// 825C0284: 48000014  b 0x825c0298
	pc = 0x825C0298; continue 'dispatch;
            }
            0x825C0288 => {
    //   block [0x825C0288..0x825C029C)
	// 825C0288: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825C028C: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 825C0290: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 825C0294: 935F0004  stw r26, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 825C0298: 997F0003  stb r11, 3(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	pc = 0x825C029C; continue 'dispatch;
            }
            0x825C029C => {
    //   block [0x825C029C..0x825C02A4)
	// 825C029C: 397B0008  addi r11, r27, 8
	ctx.r[11].s64 = ctx.r[27].s64 + 8;
	// 825C02A0: 9161096C  stw r11, 0x96c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(2412 as u32), ctx.r[11].u32 ) };
	pc = 0x825C02A4; continue 'dispatch;
            }
            0x825C02A4 => {
    //   block [0x825C02A4..0x825C02E4)
	// 825C02A4: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C02A8: 2B0B0006  cmplwi cr6, r11, 6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 6 as u32, &mut ctx.xer);
	// 825C02AC: 419900C4  bgt cr6, 0x825c0370
	if ctx.cr[6].gt {
	pc = 0x825C0370; continue 'dispatch;
	}
	// 825C02B0: 3D80825C  lis r12, -0x7da4
	ctx.r[12].s64 = -2107899904;
	// 825C02B4: 398C02C8  addi r12, r12, 0x2c8
	ctx.r[12].s64 = ctx.r[12].s64 + 712;
	// 825C02B8: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 825C02BC: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 825C02C0: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 825C02C4: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x825C036C; continue 'dispatch;
		},
		1 => {
	pc = 0x825C036C; continue 'dispatch;
		},
		2 => {
	pc = 0x825C03A4; continue 'dispatch;
		},
		3 => {
	pc = 0x825C044C; continue 'dispatch;
		},
		4 => {
	pc = 0x825C08E4; continue 'dispatch;
		},
		5 => {
	pc = 0x825C05A0; continue 'dispatch;
		},
		6 => {
	pc = 0x825C02E4; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 825C02C8: 825C036C  lwz r18, 0x36c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(876 as u32) ) } as u64;
	// 825C02CC: 825C036C  lwz r18, 0x36c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(876 as u32) ) } as u64;
	// 825C02D0: 825C03A4  lwz r18, 0x3a4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(932 as u32) ) } as u64;
	// 825C02D4: 825C044C  lwz r18, 0x44c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1100 as u32) ) } as u64;
	// 825C02D8: 825C08E4  lwz r18, 0x8e4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(2276 as u32) ) } as u64;
	// 825C02DC: 825C05A0  lwz r18, 0x5a0(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1440 as u32) ) } as u64;
	// 825C02E0: 825C02E4  lwz r18, 0x2e4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(740 as u32) ) } as u64;
            }
            0x825C02E4 => {
    //   block [0x825C02E4..0x825C036C)
	// 825C02E4: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 825C02E8: 7F15E040  cmplw cr6, r21, r28
	ctx.cr[6].compare_u32(ctx.r[21].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825C02EC: 419A002C  beq cr6, 0x825c0318
	if ctx.cr[6].eq {
	pc = 0x825C0318; continue 'dispatch;
	}
	// 825C02F0: 81710000  lwz r11, 0(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C02F4: 7F95E378  mr r21, r28
	ctx.r[21].u64 = ctx.r[28].u64;
	// 825C02F8: 38A10470  addi r5, r1, 0x470
	ctx.r[5].s64 = ctx.r[1].s64 + 1136;
	// 825C02FC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825C0300: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 825C0304: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825C0308: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825C030C: 4E800421  bctrl
	ctx.lr = 0x825C0310;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825C0310: 90610070  stw r3, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[3].u32 ) };
	// 825C0314: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 825C0318: 7F13D040  cmplw cr6, r19, r26
	ctx.cr[6].compare_u32(ctx.r[19].u32, ctx.r[26].u32, &mut ctx.xer);
	// 825C031C: 419A002C  beq cr6, 0x825c0348
	if ctx.cr[6].eq {
	pc = 0x825C0348; continue 'dispatch;
	}
	// 825C0320: 81740000  lwz r11, 0(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C0324: 7F53D378  mr r19, r26
	ctx.r[19].u64 = ctx.r[26].u64;
	// 825C0328: 38A10670  addi r5, r1, 0x670
	ctx.r[5].s64 = ctx.r[1].s64 + 1648;
	// 825C032C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825C0330: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 825C0334: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825C0338: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825C033C: 4E800421  bctrl
	ctx.lr = 0x825C0340;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825C0340: 90610080  stw r3, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[3].u32 ) };
	// 825C0344: 93410084  stw r26, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[26].u32 ) };
	// 825C0348: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C034C: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 825C0350: 80C100C8  lwz r6, 0xc8(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 825C0354: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 825C0358: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 825C035C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C0360: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 825C0364: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825C0368: 4E800421  bctrl
	ctx.lr = 0x825C036C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x825C036C => {
    //   block [0x825C036C..0x825C0370)
	// 825C036C: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	pc = 0x825C0370; continue 'dispatch;
            }
            0x825C0370 => {
    //   block [0x825C0370..0x825C03A4)
	// 825C0370: 816100A0  lwz r11, 0xa0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 825C0374: 7F175840  cmplw cr6, r23, r11
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825C0378: 409A08FC  bne cr6, 0x825c0c74
	if !ctx.cr[6].eq {
	pc = 0x825C0C74; continue 'dispatch;
	}
	// 825C037C: 8161009C  lwz r11, 0x9c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 825C0380: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C0384: 8163009C  lwz r11, 0x9c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(156 as u32) ) } as u64;
	// 825C0388: 81430034  lwz r10, 0x34(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 825C038C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825C0390: 4198089C  blt cr6, 0x825c0c2c
	if ctx.cr[6].lt {
	pc = 0x825C0C2C; continue 'dispatch;
	}
	// 825C0394: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 825C0398: 3880000C  li r4, 0xc
	ctx.r[4].s64 = 12;
	// 825C039C: 4BEA3B7D  bl 0x82463f18
	ctx.lr = 0x825C03A0;
	sub_82463F18(ctx, base);
	// 825C03A0: 480008A4  b 0x825c0c44
	pc = 0x825C0C44; continue 'dispatch;
            }
            0x825C03A4 => {
    //   block [0x825C03A4..0x825C044C)
	// 825C03A4: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 825C03A8: 7F15E040  cmplw cr6, r21, r28
	ctx.cr[6].compare_u32(ctx.r[21].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825C03AC: 419A002C  beq cr6, 0x825c03d8
	if ctx.cr[6].eq {
	pc = 0x825C03D8; continue 'dispatch;
	}
	// 825C03B0: 81710000  lwz r11, 0(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C03B4: 7F95E378  mr r21, r28
	ctx.r[21].u64 = ctx.r[28].u64;
	// 825C03B8: 38A10470  addi r5, r1, 0x470
	ctx.r[5].s64 = ctx.r[1].s64 + 1136;
	// 825C03BC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825C03C0: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 825C03C4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825C03C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825C03CC: 4E800421  bctrl
	ctx.lr = 0x825C03D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825C03D0: 90610070  stw r3, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[3].u32 ) };
	// 825C03D4: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 825C03D8: 7F13D040  cmplw cr6, r19, r26
	ctx.cr[6].compare_u32(ctx.r[19].u32, ctx.r[26].u32, &mut ctx.xer);
	// 825C03DC: 419A002C  beq cr6, 0x825c0408
	if ctx.cr[6].eq {
	pc = 0x825C0408; continue 'dispatch;
	}
	// 825C03E0: 81740000  lwz r11, 0(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C03E4: 7F53D378  mr r19, r26
	ctx.r[19].u64 = ctx.r[26].u64;
	// 825C03E8: 38A10670  addi r5, r1, 0x670
	ctx.r[5].s64 = ctx.r[1].s64 + 1648;
	// 825C03EC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825C03F0: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 825C03F4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825C03F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825C03FC: 4E800421  bctrl
	ctx.lr = 0x825C0400;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825C0400: 90610080  stw r3, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[3].u32 ) };
	// 825C0404: 93410084  stw r26, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[26].u32 ) };
	// 825C0408: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C040C: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 825C0410: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825C0414: 556A103E  rotlwi r10, r11, 2
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 825C0418: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 825C041C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825C0420: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825C0424: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C0428: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 825C042C: 7D6BCA14  add r11, r11, r25
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 825C0430: 816B16DC  lwz r11, 0x16dc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5852 as u32) ) } as u64;
	// 825C0434: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825C0438: 4E800421  bctrl
	ctx.lr = 0x825C043C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825C043C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825C0440: 7D7EF850  subf r11, r30, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 825C0444: 997E0003  stb r11, 3(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 825C0448: 4BFFFF28  b 0x825c0370
	pc = 0x825C0370; continue 'dispatch;
            }
            0x825C044C => {
    //   block [0x825C044C..0x825C05A0)
	// 825C044C: 39610120  addi r11, r1, 0x120
	ctx.r[11].s64 = ctx.r[1].s64 + 288;
	pc = 0x825C05A0; continue 'dispatch;
            }
            0x825C05A0 => {
    //   block [0x825C05A0..0x825C08E4)
	// 825C05A0: 39610120  addi r11, r1, 0x120
	ctx.r[11].s64 = ctx.r[1].s64 + 288;
	pc = 0x825C08E4; continue 'dispatch;
            }
            0x825C08E4 => {
    //   block [0x825C08E4..0x825C0E48)
	// 825C08E4: 80E100C8  lwz r7, 0xc8(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 825C08E8: C1BF000C  lfs f13, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C08EC: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 825C08F0: 3B7F000C  addi r27, r31, 0xc
	ctx.r[27].s64 = ctx.r[31].s64 + 12;
	// 825C08F4: C0070050  lfs f0, 0x50(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C08F8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825C08FC: 419A0270  beq cr6, 0x825c0b6c
	if ctx.cr[6].eq {
	pc = 0x825C0B6C; continue 'dispatch;
	}
	// 825C0900: C0070054  lfs f0, 0x54(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C0904: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825C0908: 419800BC  blt cr6, 0x825c09c4
	if ctx.cr[6].lt {
	pc = 0x825C09C4; continue 'dispatch;
	}
	// 825C090C: 816100C0  lwz r11, 0xc0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 825C0910: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 825C0914: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 825C0918: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 825C091C: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 825C0920: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 825C0924: 386100AC  addi r3, r1, 0xac
	ctx.r[3].s64 = ctx.r[1].s64 + 172;
	// 825C0928: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C0E48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825C0E48 size=4640
    let mut pc: u32 = 0x825C0E48;
    'dispatch: loop {
        match pc {
            0x825C0E48 => {
    //   block [0x825C0E48..0x825C0EB0)
	// 825C0E48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C0E4C: 4BF7423D  bl 0x82535088
	ctx.lr = 0x825C0E50;
	sub_82535080(ctx, base);
	// 825C0E50: 3981FF78  addi r12, r1, -0x88
	ctx.r[12].s64 = ctx.r[1].s64 + -136;
	// 825C0E54: 4BF75181  bl 0x82535fd4
	ctx.lr = 0x825C0E58;
	sub_82535FB0(ctx, base);
	// 825C0E58: 9421FB00  stwu r1, -0x500(r1)
	ea = ctx.r[1].u32.wrapping_add(-1280 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C0E5C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825C0E60: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 825C0E64: 3ACB9F60  addi r22, r11, -0x60a0
	ctx.r[22].s64 = ctx.r[11].s64 + -24736;
	// 825C0E68: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825C0E6C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825C0E70: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 825C0E74: 3A6BA360  addi r19, r11, -0x5ca0
	ctx.r[19].s64 = ctx.r[11].s64 + -23712;
	// 825C0E78: C3081FF8  lfs f24, 0x1ff8(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8184 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 825C0E7C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825C0E80: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 825C0E84: C2E91850  lfs f23, 0x1850(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(6224 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 825C0E88: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825C0E8C: C32A2068  lfs f25, 0x2068(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8296 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 825C0E90: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825C0E94: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 825C0E98: 7CF43B78  mr r20, r7
	ctx.r[20].u64 = ctx.r[7].u64;
	// 825C0E9C: 3E208293  lis r17, -0x7d6d
	ctx.r[17].s64 = -2104295424;
	// 825C0EA0: 3A4BA1D8  addi r18, r11, -0x5e28
	ctx.r[18].s64 = ctx.r[11].s64 + -24104;
	// 825C0EA4: 3AE00010  li r23, 0x10
	ctx.r[23].s64 = 16;
	// 825C0EA8: 3AA00028  li r21, 0x28
	ctx.r[21].s64 = 40;
	// 825C0EAC: 3A000001  li r16, 1
	ctx.r[16].s64 = 1;
	pc = 0x825C0EB0; continue 'dispatch;
            }
            0x825C0EB0 => {
    //   block [0x825C0EB0..0x825C1088)
	// 825C0EB0: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C0EB4: 3B4003E7  li r26, 0x3e7
	ctx.r[26].s64 = 999;
	// 825C0EB8: 2B0B006B  cmplwi cr6, r11, 0x6b
	ctx.cr[6].compare_u32(ctx.r[11].u32, 107 as u32, &mut ctx.xer);
	// 825C0EBC: 41990FD4  bgt cr6, 0x825c1e90
	if ctx.cr[6].gt {
	pc = 0x825C1E90; continue 'dispatch;
	}
	// 825C0EC0: 3D80825C  lis r12, -0x7da4
	ctx.r[12].s64 = -2107899904;
	// 825C0EC4: 398C0ED8  addi r12, r12, 0xed8
	ctx.r[12].s64 = ctx.r[12].s64 + 3800;
	// 825C0EC8: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 825C0ECC: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 825C0ED0: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 825C0ED4: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x825C2058; continue 'dispatch;
		},
		1 => {
	pc = 0x825C1B38; continue 'dispatch;
		},
		2 => {
	pc = 0x825C1B38; continue 'dispatch;
		},
		3 => {
	pc = 0x825C1B38; continue 'dispatch;
		},
		4 => {
	pc = 0x825C1B38; continue 'dispatch;
		},
		5 => {
	pc = 0x825C1AC0; continue 'dispatch;
		},
		6 => {
	pc = 0x825C1AD0; continue 'dispatch;
		},
		7 => {
	pc = 0x825C1AEC; continue 'dispatch;
		},
		8 => {
	pc = 0x825C1E90; continue 'dispatch;
		},
		9 => {
	pc = 0x825C1C54; continue 'dispatch;
		},
		10 => {
	pc = 0x825C1CBC; continue 'dispatch;
		},
		11 => {
	pc = 0x825C1D30; continue 'dispatch;
		},
		12 => {
	pc = 0x825C1B14; continue 'dispatch;
		},
		13 => {
	pc = 0x825C1DAC; continue 'dispatch;
		},
		14 => {
	pc = 0x825C1E90; continue 'dispatch;
		},
		15 => {
	pc = 0x825C1E90; continue 'dispatch;
		},
		16 => {
	pc = 0x825C1588; continue 'dispatch;
		},
		17 => {
	pc = 0x825C1588; continue 'dispatch;
		},
		18 => {
	pc = 0x825C1588; continue 'dispatch;
		},
		19 => {
	pc = 0x825C1088; continue 'dispatch;
		},
		20 => {
	pc = 0x825C10EC; continue 'dispatch;
		},
		21 => {
	pc = 0x825C1158; continue 'dispatch;
		},
		22 => {
	pc = 0x825C11BC; continue 'dispatch;
		},
		23 => {
	pc = 0x825C1228; continue 'dispatch;
		},
		24 => {
	pc = 0x825C128C; continue 'dispatch;
		},
		25 => {
	pc = 0x825C12F8; continue 'dispatch;
		},
		26 => {
	pc = 0x825C1368; continue 'dispatch;
		},
		27 => {
	pc = 0x825C13E0; continue 'dispatch;
		},
		28 => {
	pc = 0x825C1458; continue 'dispatch;
		},
		29 => {
	pc = 0x825C1E90; continue 'dispatch;
		},
		30 => {
	pc = 0x825C1E90; continue 'dispatch;
		},
		31 => {
	pc = 0x825C1E90; continue 'dispatch;
		},
		32 => {
	pc = 0x825C14D0; continue 'dispatch;
		},
		33 => {
	pc = 0x825C14D0; continue 'dispatch;
		},
		34 => {
	pc = 0x825C14D0; continue 'dispatch;
		},
		35 => {
	pc = 0x825C1514; continue 'dispatch;
		},
		36 => {
	pc = 0x825C1514; continue 'dispatch;
		},
		37 => {
	pc = 0x825C1514; continue 'dispatch;
		},
		38 => {
	pc = 0x825C1968; continue 'dispatch;
		},
		39 => {
	pc = 0x825C1968; continue 'dispatch;
		},
		40 => {
	pc = 0x825C1968; continue 'dispatch;
		},
		41 => {
	pc = 0x825C18C0; continue 'dispatch;
		},
		42 => {
	pc = 0x825C18C0; continue 'dispatch;
		},
		43 => {
	pc = 0x825C18C0; continue 'dispatch;
		},
		44 => {
	pc = 0x825C1E90; continue 'dispatch;
		},
		45 => {
	pc = 0x825C1E90; continue 'dispatch;
		},
		46 => {
	pc = 0x825C1E90; continue 'dispatch;
		},
		47 => {
	pc = 0x825C1E90; continue 'dispatch;
		},
		48 => {
	pc = 0x825C1F4C; continue 'dispatch;
		},
		49 => {
	pc = 0x825C1F4C; continue 'dispatch;
		},
		50 => {
	pc = 0x825C1F4C; continue 'dispatch;
		},
		51 => {
	pc = 0x825C1F4C; continue 'dispatch;
		},
		52 => {
	pc = 0x825C1F4C; continue 'dispatch;
		},
		53 => {
	pc = 0x825C1F4C; continue 'dispatch;
		},
		54 => {
	pc = 0x825C1F4C; continue 'dispatch;
		},
		55 => {
	pc = 0x825C1F4C; continue 'dispatch;
		},
		56 => {
	pc = 0x825C1F4C; continue 'dispatch;
		},
		57 => {
	pc = 0x825C1F4C; continue 'dispatch;
		},
		58 => {
	pc = 0x825C1F4C; continue 'dispatch;
		},
		59 => {
	pc = 0x825C1F4C; continue 'dispatch;
		},
		60 => {
	pc = 0x825C1F4C; continue 'dispatch;
		},
		61 => {
	pc = 0x825C1F4C; continue 'dispatch;
		},
		62 => {
	pc = 0x825C1F4C; continue 'dispatch;
		},
		63 => {
	pc = 0x825C1F4C; continue 'dispatch;
		},
		64 => {
	pc = 0x825C1F4C; continue 'dispatch;
		},
		65 => {
	pc = 0x825C1F4C; continue 'dispatch;
		},
		66 => {
	pc = 0x825C1F4C; continue 'dispatch;
		},
		67 => {
	pc = 0x825C1F4C; continue 'dispatch;
		},
		68 => {
	pc = 0x825C1F4C; continue 'dispatch;
		},
		69 => {
	pc = 0x825C1F4C; continue 'dispatch;
		},
		70 => {
	pc = 0x825C1F4C; continue 'dispatch;
		},
		71 => {
	pc = 0x825C1F4C; continue 'dispatch;
		},
		72 => {
	pc = 0x825C1F4C; continue 'dispatch;
		},
		73 => {
	pc = 0x825C1F4C; continue 'dispatch;
		},
		74 => {
	pc = 0x825C1F4C; continue 'dispatch;
		},
		75 => {
	pc = 0x825C1F4C; continue 'dispatch;
		},
		76 => {
	pc = 0x825C1F4C; continue 'dispatch;
		},
		77 => {
	pc = 0x825C1F4C; continue 'dispatch;
		},
		78 => {
	pc = 0x825C1F4C; continue 'dispatch;
		},
		79 => {
	pc = 0x825C1F4C; continue 'dispatch;
		},
		80 => {
	pc = 0x825C1EE4; continue 'dispatch;
		},
		81 => {
	pc = 0x825C1EEC; continue 'dispatch;
		},
		82 => {
	pc = 0x825C1F00; continue 'dispatch;
		},
		83 => {
	pc = 0x825C1F20; continue 'dispatch;
		},
		84 => {
	pc = 0x825C1E90; continue 'dispatch;
		},
		85 => {
	pc = 0x825C1E90; continue 'dispatch;
		},
		86 => {
	pc = 0x825C1E90; continue 'dispatch;
		},
		87 => {
	pc = 0x825C1E90; continue 'dispatch;
		},
		88 => {
	pc = 0x825C1E90; continue 'dispatch;
		},
		89 => {
	pc = 0x825C1E90; continue 'dispatch;
		},
		90 => {
	pc = 0x825C1E90; continue 'dispatch;
		},
		91 => {
	pc = 0x825C1E90; continue 'dispatch;
		},
		92 => {
	pc = 0x825C1E90; continue 'dispatch;
		},
		93 => {
	pc = 0x825C1E90; continue 'dispatch;
		},
		94 => {
	pc = 0x825C1E90; continue 'dispatch;
		},
		95 => {
	pc = 0x825C1E90; continue 'dispatch;
		},
		96 => {
	pc = 0x825C1DB4; continue 'dispatch;
		},
		97 => {
	pc = 0x825C1DB4; continue 'dispatch;
		},
		98 => {
	pc = 0x825C1DB4; continue 'dispatch;
		},
		99 => {
	pc = 0x825C1DB4; continue 'dispatch;
		},
		100 => {
	pc = 0x825C1DD0; continue 'dispatch;
		},
		101 => {
	pc = 0x825C1DD0; continue 'dispatch;
		},
		102 => {
	pc = 0x825C1DD0; continue 'dispatch;
		},
		103 => {
	pc = 0x825C1DD0; continue 'dispatch;
		},
		104 => {
	pc = 0x825C1DF8; continue 'dispatch;
		},
		105 => {
	pc = 0x825C1DF8; continue 'dispatch;
		},
		106 => {
	pc = 0x825C1DF8; continue 'dispatch;
		},
		107 => {
	pc = 0x825C1DF8; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 825C0ED8: 825C2058  lwz r18, 0x2058(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8280 as u32) ) } as u64;
	// 825C0EDC: 825C1B38  lwz r18, 0x1b38(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(6968 as u32) ) } as u64;
	// 825C0EE0: 825C1B38  lwz r18, 0x1b38(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(6968 as u32) ) } as u64;
	// 825C0EE4: 825C1B38  lwz r18, 0x1b38(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(6968 as u32) ) } as u64;
	// 825C0EE8: 825C1B38  lwz r18, 0x1b38(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(6968 as u32) ) } as u64;
	// 825C0EEC: 825C1AC0  lwz r18, 0x1ac0(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(6848 as u32) ) } as u64;
	// 825C0EF0: 825C1AD0  lwz r18, 0x1ad0(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(6864 as u32) ) } as u64;
	// 825C0EF4: 825C1AEC  lwz r18, 0x1aec(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(6892 as u32) ) } as u64;
	// 825C0EF8: 825C1E90  lwz r18, 0x1e90(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7824 as u32) ) } as u64;
	// 825C0EFC: 825C1C54  lwz r18, 0x1c54(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7252 as u32) ) } as u64;
	// 825C0F00: 825C1CBC  lwz r18, 0x1cbc(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7356 as u32) ) } as u64;
	// 825C0F04: 825C1D30  lwz r18, 0x1d30(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7472 as u32) ) } as u64;
	// 825C0F08: 825C1B14  lwz r18, 0x1b14(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(6932 as u32) ) } as u64;
	// 825C0F0C: 825C1DAC  lwz r18, 0x1dac(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7596 as u32) ) } as u64;
	// 825C0F10: 825C1E90  lwz r18, 0x1e90(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7824 as u32) ) } as u64;
	// 825C0F14: 825C1E90  lwz r18, 0x1e90(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7824 as u32) ) } as u64;
	// 825C0F18: 825C1588  lwz r18, 0x1588(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(5512 as u32) ) } as u64;
	// 825C0F1C: 825C1588  lwz r18, 0x1588(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(5512 as u32) ) } as u64;
	// 825C0F20: 825C1588  lwz r18, 0x1588(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(5512 as u32) ) } as u64;
	// 825C0F24: 825C1088  lwz r18, 0x1088(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4232 as u32) ) } as u64;
	// 825C0F28: 825C10EC  lwz r18, 0x10ec(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4332 as u32) ) } as u64;
	// 825C0F2C: 825C1158  lwz r18, 0x1158(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4440 as u32) ) } as u64;
	// 825C0F30: 825C11BC  lwz r18, 0x11bc(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4540 as u32) ) } as u64;
	// 825C0F34: 825C1228  lwz r18, 0x1228(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4648 as u32) ) } as u64;
	// 825C0F38: 825C128C  lwz r18, 0x128c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4748 as u32) ) } as u64;
	// 825C0F3C: 825C12F8  lwz r18, 0x12f8(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4856 as u32) ) } as u64;
	// 825C0F40: 825C1368  lwz r18, 0x1368(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4968 as u32) ) } as u64;
	// 825C0F44: 825C13E0  lwz r18, 0x13e0(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(5088 as u32) ) } as u64;
	// 825C0F48: 825C1458  lwz r18, 0x1458(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(5208 as u32) ) } as u64;
	// 825C0F4C: 825C1E90  lwz r18, 0x1e90(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7824 as u32) ) } as u64;
	// 825C0F50: 825C1E90  lwz r18, 0x1e90(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7824 as u32) ) } as u64;
	// 825C0F54: 825C1E90  lwz r18, 0x1e90(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7824 as u32) ) } as u64;
	// 825C0F58: 825C14D0  lwz r18, 0x14d0(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(5328 as u32) ) } as u64;
	// 825C0F5C: 825C14D0  lwz r18, 0x14d0(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(5328 as u32) ) } as u64;
	// 825C0F60: 825C14D0  lwz r18, 0x14d0(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(5328 as u32) ) } as u64;
	// 825C0F64: 825C1514  lwz r18, 0x1514(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(5396 as u32) ) } as u64;
	// 825C0F68: 825C1514  lwz r18, 0x1514(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(5396 as u32) ) } as u64;
	// 825C0F6C: 825C1514  lwz r18, 0x1514(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(5396 as u32) ) } as u64;
	// 825C0F70: 825C1968  lwz r18, 0x1968(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(6504 as u32) ) } as u64;
	// 825C0F74: 825C1968  lwz r18, 0x1968(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(6504 as u32) ) } as u64;
	// 825C0F78: 825C1968  lwz r18, 0x1968(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(6504 as u32) ) } as u64;
	// 825C0F7C: 825C18C0  lwz r18, 0x18c0(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(6336 as u32) ) } as u64;
	// 825C0F80: 825C18C0  lwz r18, 0x18c0(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(6336 as u32) ) } as u64;
	// 825C0F84: 825C18C0  lwz r18, 0x18c0(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(6336 as u32) ) } as u64;
	// 825C0F88: 825C1E90  lwz r18, 0x1e90(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7824 as u32) ) } as u64;
	// 825C0F8C: 825C1E90  lwz r18, 0x1e90(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7824 as u32) ) } as u64;
	// 825C0F90: 825C1E90  lwz r18, 0x1e90(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7824 as u32) ) } as u64;
	// 825C0F94: 825C1E90  lwz r18, 0x1e90(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7824 as u32) ) } as u64;
	// 825C0F98: 825C1F4C  lwz r18, 0x1f4c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8012 as u32) ) } as u64;
	// 825C0F9C: 825C1F4C  lwz r18, 0x1f4c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8012 as u32) ) } as u64;
	// 825C0FA0: 825C1F4C  lwz r18, 0x1f4c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8012 as u32) ) } as u64;
	// 825C0FA4: 825C1F4C  lwz r18, 0x1f4c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8012 as u32) ) } as u64;
	// 825C0FA8: 825C1F4C  lwz r18, 0x1f4c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8012 as u32) ) } as u64;
	// 825C0FAC: 825C1F4C  lwz r18, 0x1f4c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8012 as u32) ) } as u64;
	// 825C0FB0: 825C1F4C  lwz r18, 0x1f4c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8012 as u32) ) } as u64;
	// 825C0FB4: 825C1F4C  lwz r18, 0x1f4c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8012 as u32) ) } as u64;
	// 825C0FB8: 825C1F4C  lwz r18, 0x1f4c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8012 as u32) ) } as u64;
	// 825C0FBC: 825C1F4C  lwz r18, 0x1f4c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8012 as u32) ) } as u64;
	// 825C0FC0: 825C1F4C  lwz r18, 0x1f4c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8012 as u32) ) } as u64;
	// 825C0FC4: 825C1F4C  lwz r18, 0x1f4c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8012 as u32) ) } as u64;
	// 825C0FC8: 825C1F4C  lwz r18, 0x1f4c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8012 as u32) ) } as u64;
	// 825C0FCC: 825C1F4C  lwz r18, 0x1f4c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8012 as u32) ) } as u64;
	// 825C0FD0: 825C1F4C  lwz r18, 0x1f4c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8012 as u32) ) } as u64;
	// 825C0FD4: 825C1F4C  lwz r18, 0x1f4c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8012 as u32) ) } as u64;
	// 825C0FD8: 825C1F4C  lwz r18, 0x1f4c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8012 as u32) ) } as u64;
	// 825C0FDC: 825C1F4C  lwz r18, 0x1f4c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8012 as u32) ) } as u64;
	// 825C0FE0: 825C1F4C  lwz r18, 0x1f4c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8012 as u32) ) } as u64;
	// 825C0FE4: 825C1F4C  lwz r18, 0x1f4c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8012 as u32) ) } as u64;
	// 825C0FE8: 825C1F4C  lwz r18, 0x1f4c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8012 as u32) ) } as u64;
	// 825C0FEC: 825C1F4C  lwz r18, 0x1f4c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8012 as u32) ) } as u64;
	// 825C0FF0: 825C1F4C  lwz r18, 0x1f4c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8012 as u32) ) } as u64;
	// 825C0FF4: 825C1F4C  lwz r18, 0x1f4c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8012 as u32) ) } as u64;
	// 825C0FF8: 825C1F4C  lwz r18, 0x1f4c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8012 as u32) ) } as u64;
	// 825C0FFC: 825C1F4C  lwz r18, 0x1f4c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8012 as u32) ) } as u64;
	// 825C1000: 825C1F4C  lwz r18, 0x1f4c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8012 as u32) ) } as u64;
	// 825C1004: 825C1F4C  lwz r18, 0x1f4c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8012 as u32) ) } as u64;
	// 825C1008: 825C1F4C  lwz r18, 0x1f4c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8012 as u32) ) } as u64;
	// 825C100C: 825C1F4C  lwz r18, 0x1f4c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8012 as u32) ) } as u64;
	// 825C1010: 825C1F4C  lwz r18, 0x1f4c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8012 as u32) ) } as u64;
	// 825C1014: 825C1F4C  lwz r18, 0x1f4c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8012 as u32) ) } as u64;
	// 825C1018: 825C1EE4  lwz r18, 0x1ee4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7908 as u32) ) } as u64;
	// 825C101C: 825C1EEC  lwz r18, 0x1eec(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7916 as u32) ) } as u64;
	// 825C1020: 825C1F00  lwz r18, 0x1f00(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7936 as u32) ) } as u64;
	// 825C1024: 825C1F20  lwz r18, 0x1f20(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7968 as u32) ) } as u64;
	// 825C1028: 825C1E90  lwz r18, 0x1e90(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7824 as u32) ) } as u64;
	// 825C102C: 825C1E90  lwz r18, 0x1e90(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7824 as u32) ) } as u64;
	// 825C1030: 825C1E90  lwz r18, 0x1e90(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7824 as u32) ) } as u64;
	// 825C1034: 825C1E90  lwz r18, 0x1e90(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7824 as u32) ) } as u64;
	// 825C1038: 825C1E90  lwz r18, 0x1e90(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7824 as u32) ) } as u64;
	// 825C103C: 825C1E90  lwz r18, 0x1e90(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7824 as u32) ) } as u64;
	// 825C1040: 825C1E90  lwz r18, 0x1e90(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7824 as u32) ) } as u64;
	// 825C1044: 825C1E90  lwz r18, 0x1e90(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7824 as u32) ) } as u64;
	// 825C1048: 825C1E90  lwz r18, 0x1e90(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7824 as u32) ) } as u64;
	// 825C104C: 825C1E90  lwz r18, 0x1e90(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7824 as u32) ) } as u64;
	// 825C1050: 825C1E90  lwz r18, 0x1e90(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7824 as u32) ) } as u64;
	// 825C1054: 825C1E90  lwz r18, 0x1e90(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7824 as u32) ) } as u64;
	// 825C1058: 825C1DB4  lwz r18, 0x1db4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7604 as u32) ) } as u64;
	// 825C105C: 825C1DB4  lwz r18, 0x1db4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7604 as u32) ) } as u64;
	// 825C1060: 825C1DB4  lwz r18, 0x1db4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7604 as u32) ) } as u64;
	// 825C1064: 825C1DB4  lwz r18, 0x1db4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7604 as u32) ) } as u64;
	// 825C1068: 825C1DD0  lwz r18, 0x1dd0(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7632 as u32) ) } as u64;
	// 825C106C: 825C1DD0  lwz r18, 0x1dd0(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7632 as u32) ) } as u64;
	// 825C1070: 825C1DD0  lwz r18, 0x1dd0(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7632 as u32) ) } as u64;
	// 825C1074: 825C1DD0  lwz r18, 0x1dd0(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7632 as u32) ) } as u64;
	// 825C1078: 825C1DF8  lwz r18, 0x1df8(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7672 as u32) ) } as u64;
	// 825C107C: 825C1DF8  lwz r18, 0x1df8(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7672 as u32) ) } as u64;
	// 825C1080: 825C1DF8  lwz r18, 0x1df8(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7672 as u32) ) } as u64;
	// 825C1084: 825C1DF8  lwz r18, 0x1df8(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7672 as u32) ) } as u64;
            }
            0x825C1088 => {
    //   block [0x825C1088..0x825C10EC)
	// 825C1088: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C108C: C01D0018  lfs f0, 0x18(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C1090: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C1094: C1BD0014  lfs f13, 0x14(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C1098: 556B083E  rotlwi r11, r11, 1
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 825C109C: ED80682A  fadds f12, f0, f13
	ctx.f[12].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 825C10A0: 554A083E  rotlwi r10, r10, 1
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 825C10A4: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C10A8: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825C10AC: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C10B0: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825C10B4: C17E0018  lfs f11, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825C10B8: C15E0014  lfs f10, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825C10BC: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 825C10C0: EDAB502A  fadds f13, f11, f10
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[10].f64) as f32) as f64;
	// 825C10C4: F9610148  std r11, 0x148(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(328 as u32), ctx.r[11].u64 ) };
	// 825C10C8: F9410188  std r10, 0x188(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), ctx.r[10].u64 ) };
	// 825C10CC: ED8C0672  fmuls f12, f12, f25
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[25].f64) as f32) as f64);
	// 825C10D0: C9610148  lfd f11, 0x148(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(328 as u32) ) };
	// 825C10D4: C9410188  lfd f10, 0x188(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(392 as u32) ) };
	// 825C10D8: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 825C10DC: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 825C10E0: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825C10E4: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 825C10E8: 480004E4  b 0x825c15cc
	pc = 0x825C15CC; continue 'dispatch;
            }
            0x825C10EC => {
    //   block [0x825C10EC..0x825C1158)
	// 825C10EC: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C10F0: C01D0018  lfs f0, 0x18(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C10F4: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C10F8: C1BD0014  lfs f13, 0x14(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C10FC: 556A083E  rotlwi r10, r11, 1
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 825C1100: ED80682A  fadds f12, f0, f13
	ctx.f[12].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 825C1104: 552B083E  rotlwi r11, r9, 1
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 825C1108: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C110C: 394AFF01  addi r10, r10, -0xff
	ctx.r[10].s64 = ctx.r[10].s64 + -255;
	// 825C1110: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C1114: 396BFF01  addi r11, r11, -0xff
	ctx.r[11].s64 = ctx.r[11].s64 + -255;
	// 825C1118: C17E0014  lfs f11, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825C111C: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825C1120: C15E0018  lfs f10, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825C1124: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825C1128: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 825C112C: EDAB5028  fsubs f13, f11, f10
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 825C1130: F9410198  std r10, 0x198(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(408 as u32), ctx.r[10].u64 ) };
	// 825C1134: F96101C8  std r11, 0x1c8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(456 as u32), ctx.r[11].u64 ) };
	// 825C1138: ED8C0672  fmuls f12, f12, f25
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[25].f64) as f32) as f64);
	// 825C113C: C9610198  lfd f11, 0x198(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(408 as u32) ) };
	// 825C1140: C94101C8  lfd f10, 0x1c8(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(456 as u32) ) };
	// 825C1144: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 825C1148: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 825C114C: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825C1150: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 825C1154: 48000478  b 0x825c15cc
	pc = 0x825C15CC; continue 'dispatch;
            }
            0x825C1158 => {
    //   block [0x825C1158..0x825C11BC)
	// 825C1158: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C115C: C01D0018  lfs f0, 0x18(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C1160: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C1164: C1BD0010  lfs f13, 0x10(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C1168: 556B083E  rotlwi r11, r11, 1
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 825C116C: ED80682A  fadds f12, f0, f13
	ctx.f[12].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 825C1170: 554A083E  rotlwi r10, r10, 1
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 825C1174: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C1178: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825C117C: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C1180: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825C1184: C17E0018  lfs f11, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825C1188: C15E0010  lfs f10, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825C118C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 825C1190: EDAB502A  fadds f13, f11, f10
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[10].f64) as f32) as f64;
	// 825C1194: F96101D0  std r11, 0x1d0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(464 as u32), ctx.r[11].u64 ) };
	// 825C1198: F94100D8  std r10, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[10].u64 ) };
	// 825C119C: ED8C0672  fmuls f12, f12, f25
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[25].f64) as f32) as f64);
	// 825C11A0: C96101D0  lfd f11, 0x1d0(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(464 as u32) ) };
	// 825C11A4: C94100D8  lfd f10, 0xd8(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) };
	// 825C11A8: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 825C11AC: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 825C11B0: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825C11B4: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 825C11B8: 48000414  b 0x825c15cc
	pc = 0x825C15CC; continue 'dispatch;
            }
            0x825C11BC => {
    //   block [0x825C11BC..0x825C1228)
	// 825C11BC: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C11C0: C01D0018  lfs f0, 0x18(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C11C4: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C11C8: C1BD0010  lfs f13, 0x10(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C11CC: 556A083E  rotlwi r10, r11, 1
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 825C11D0: ED80682A  fadds f12, f0, f13
	ctx.f[12].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 825C11D4: 552B083E  rotlwi r11, r9, 1
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 825C11D8: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C11DC: 394AFF01  addi r10, r10, -0xff
	ctx.r[10].s64 = ctx.r[10].s64 + -255;
	// 825C11E0: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C11E4: 396BFF01  addi r11, r11, -0xff
	ctx.r[11].s64 = ctx.r[11].s64 + -255;
	// 825C11E8: C17E0010  lfs f11, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825C11EC: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825C11F0: C15E0018  lfs f10, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825C11F4: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825C11F8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 825C11FC: EDAB5028  fsubs f13, f11, f10
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 825C1200: F9410168  std r10, 0x168(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(360 as u32), ctx.r[10].u64 ) };
	// 825C1204: F96100E8  std r11, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[11].u64 ) };
	// 825C1208: ED8C0672  fmuls f12, f12, f25
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[25].f64) as f32) as f64);
	// 825C120C: C9610168  lfd f11, 0x168(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(360 as u32) ) };
	// 825C1210: C94100E8  lfd f10, 0xe8(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(232 as u32) ) };
	// 825C1214: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 825C1218: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 825C121C: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825C1220: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 825C1224: 480003A8  b 0x825c15cc
	pc = 0x825C15CC; continue 'dispatch;
            }
            0x825C1228 => {
    //   block [0x825C1228..0x825C128C)
	// 825C1228: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C122C: C01D0014  lfs f0, 0x14(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C1230: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C1234: C1BD0010  lfs f13, 0x10(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C1238: 556B083E  rotlwi r11, r11, 1
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 825C123C: ED80682A  fadds f12, f0, f13
	ctx.f[12].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 825C1240: 554A083E  rotlwi r10, r10, 1
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 825C1244: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C1248: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825C124C: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C1250: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825C1254: C17E0014  lfs f11, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825C1258: C15E0010  lfs f10, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825C125C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 825C1260: EDAB502A  fadds f13, f11, f10
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[10].f64) as f32) as f64;
	// 825C1264: F96101B8  std r11, 0x1b8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(440 as u32), ctx.r[11].u64 ) };
	// 825C1268: F94100F8  std r10, 0xf8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[10].u64 ) };
	// 825C126C: ED8C0672  fmuls f12, f12, f25
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[25].f64) as f32) as f64);
	// 825C1270: C96101B8  lfd f11, 0x1b8(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(440 as u32) ) };
	// 825C1274: C94100F8  lfd f10, 0xf8(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(248 as u32) ) };
	// 825C1278: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 825C127C: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 825C1280: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825C1284: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 825C1288: 48000344  b 0x825c15cc
	pc = 0x825C15CC; continue 'dispatch;
            }
            0x825C128C => {
    //   block [0x825C128C..0x825C12F8)
	// 825C128C: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C1290: C01D0014  lfs f0, 0x14(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C1294: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C1298: C1BD0010  lfs f13, 0x10(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C129C: 556A083E  rotlwi r10, r11, 1
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 825C12A0: ED80682A  fadds f12, f0, f13
	ctx.f[12].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 825C12A4: 552B083E  rotlwi r11, r9, 1
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 825C12A8: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C12AC: 394AFF01  addi r10, r10, -0xff
	ctx.r[10].s64 = ctx.r[10].s64 + -255;
	// 825C12B0: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C12B4: 396BFF01  addi r11, r11, -0xff
	ctx.r[11].s64 = ctx.r[11].s64 + -255;
	// 825C12B8: C17E0010  lfs f11, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825C12BC: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825C12C0: C15E0014  lfs f10, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825C12C4: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825C12C8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 825C12CC: EDAB5028  fsubs f13, f11, f10
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 825C12D0: F9410180  std r10, 0x180(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[10].u64 ) };
	// 825C12D4: F9610108  std r11, 0x108(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[11].u64 ) };
	// 825C12D8: ED8C0672  fmuls f12, f12, f25
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[25].f64) as f32) as f64);
	// 825C12DC: C9610180  lfd f11, 0x180(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(384 as u32) ) };
	// 825C12E0: C9410108  lfd f10, 0x108(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(264 as u32) ) };
	// 825C12E4: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 825C12E8: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 825C12EC: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825C12F0: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 825C12F4: 480002D8  b 0x825c15cc
	pc = 0x825C15CC; continue 'dispatch;
            }
            0x825C12F8 => {
    //   block [0x825C12F8..0x825C1368)
	// 825C12F8: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C12FC: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C1300: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C1304: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C1308: 5568083E  rotlwi r8, r11, 1
	ctx.r[8].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 825C130C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 825C1310: 5549083E  rotlwi r9, r10, 1
	ctx.r[9].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 825C1314: C17E0018  lfs f11, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825C1318: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825C131C: C1BE0014  lfs f13, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C1320: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825C1324: EDAB682A  fadds f13, f11, f13
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 825C1328: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825C132C: C17E0000  lfs f11, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825C1330: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825C1334: C15E0010  lfs f10, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825C1338: C19D0020  lfs f12, 0x20(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825C133C: F96101A8  std r11, 0x1a8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(424 as u32), ctx.r[11].u64 ) };
	// 825C1340: F9410118  std r10, 0x118(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[10].u64 ) };
	// 825C1344: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 825C1348: EDAD502A  fadds f13, f13, f10
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64;
	// 825C134C: C96101A8  lfd f11, 0x1a8(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(424 as u32) ) };
	// 825C1350: C9410118  lfd f10, 0x118(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(280 as u32) ) };
	// 825C1354: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 825C1358: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 825C135C: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825C1360: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 825C1364: 48000268  b 0x825c15cc
	pc = 0x825C15CC; continue 'dispatch;
            }
            0x825C1368 => {
    //   block [0x825C1368..0x825C13E0)
	// 825C1368: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C136C: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C1370: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C1374: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C1378: 396BFFAB  addi r11, r11, -0x55
	ctx.r[11].s64 = ctx.r[11].s64 + -85;
	// 825C137C: C17E0014  lfs f11, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825C1380: 394AFFAB  addi r10, r10, -0x55
	ctx.r[10].s64 = ctx.r[10].s64 + -85;
	// 825C1384: C15E0010  lfs f10, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825C1388: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825C138C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 825C1390: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825C1394: EDAB502A  fadds f13, f11, f10
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[10].f64) as f32) as f64;
	// 825C1398: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825C139C: C17E0008  lfs f11, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825C13A0: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825C13A4: C15E0018  lfs f10, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825C13A8: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825C13AC: C19D0020  lfs f12, 0x20(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825C13B0: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825C13B4: F9610190  std r11, 0x190(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(400 as u32), ctx.r[11].u64 ) };
	// 825C13B8: F9410128  std r10, 0x128(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), ctx.r[10].u64 ) };
	// 825C13BC: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 825C13C0: EDAD5028  fsubs f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 825C13C4: C9610190  lfd f11, 0x190(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(400 as u32) ) };
	// 825C13C8: C9410128  lfd f10, 0x128(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(296 as u32) ) };
	// 825C13CC: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 825C13D0: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 825C13D4: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825C13D8: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 825C13DC: 480001F0  b 0x825c15cc
	pc = 0x825C15CC; continue 'dispatch;
            }
            0x825C13E0 => {
    //   block [0x825C13E0..0x825C1458)
	// 825C13E0: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C13E4: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C13E8: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C13EC: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C13F0: 396BFFAB  addi r11, r11, -0x55
	ctx.r[11].s64 = ctx.r[11].s64 + -85;
	// 825C13F4: C17E0010  lfs f11, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825C13F8: 394AFFAB  addi r10, r10, -0x55
	ctx.r[10].s64 = ctx.r[10].s64 + -85;
	// 825C13FC: C15E0014  lfs f10, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825C1400: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825C1404: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 825C1408: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825C140C: EDAB5028  fsubs f13, f11, f10
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 825C1410: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825C1414: C17E0008  lfs f11, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825C1418: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825C141C: C15E0018  lfs f10, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825C1420: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825C1424: C19D0020  lfs f12, 0x20(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825C1428: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825C142C: F96101B0  std r11, 0x1b0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(432 as u32), ctx.r[11].u64 ) };
	// 825C1430: F9410138  std r10, 0x138(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), ctx.r[10].u64 ) };
	// 825C1434: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 825C1438: EDAD502A  fadds f13, f13, f10
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64;
	// 825C143C: C96101B0  lfd f11, 0x1b0(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(432 as u32) ) };
	// 825C1440: C9410138  lfd f10, 0x138(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(312 as u32) ) };
	// 825C1444: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 825C1448: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 825C144C: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825C1450: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 825C1454: 48000178  b 0x825c15cc
	pc = 0x825C15CC; continue 'dispatch;
            }
            0x825C1458 => {
    //   block [0x825C1458..0x825C14D0)
	// 825C1458: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C145C: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C1460: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C1464: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C1468: 396BFF56  addi r11, r11, -0xaa
	ctx.r[11].s64 = ctx.r[11].s64 + -170;
	// 825C146C: C17E0010  lfs f11, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825C1470: 394AFF56  addi r10, r10, -0xaa
	ctx.r[10].s64 = ctx.r[10].s64 + -170;
	// 825C1474: C15E0014  lfs f10, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825C1478: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825C147C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 825C1480: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825C1484: EDAB5028  fsubs f13, f11, f10
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 825C1488: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825C148C: C17E0008  lfs f11, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825C1490: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825C1494: C15E0018  lfs f10, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825C1498: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825C149C: C19D0020  lfs f12, 0x20(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825C14A0: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825C14A4: F96101A0  std r11, 0x1a0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(416 as u32), ctx.r[11].u64 ) };
	// 825C14A8: F94100C0  std r10, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[10].u64 ) };
	// 825C14AC: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 825C14B0: EDAD5028  fsubs f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 825C14B4: C96101A0  lfd f11, 0x1a0(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(416 as u32) ) };
	// 825C14B8: C94100C0  lfd f10, 0xc0(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) };
	// 825C14BC: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 825C14C0: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 825C14C4: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825C14C8: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 825C14CC: 48000100  b 0x825c15cc
	pc = 0x825C15CC; continue 'dispatch;
            }
            0x825C14D0 => {
    //   block [0x825C14D0..0x825C1514)
	// 825C14D0: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C14D4: 3B4BFFE0  addi r26, r11, -0x20
	ctx.r[26].s64 = ctx.r[11].s64 + -32;
	// 825C14D8: 397F0003  addi r11, r31, 3
	ctx.r[11].s64 = ctx.r[31].s64 + 3;
	// 825C14DC: 5749103A  slwi r9, r26, 2
	ctx.r[9].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825C14E0: F94101C0  std r10, 0x1c0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(448 as u32), ctx.r[10].u64 ) };
	// 825C14E4: 395A0004  addi r10, r26, 4
	ctx.r[10].s64 = ctx.r[26].s64 + 4;
	// 825C14E8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825C14EC: 7C09F42E  lfsx f0, r9, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C14F0: 7D6AEC2E  lfsx f11, r10, r29
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[29].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825C14F4: C9A101C0  lfd f13, 0x1c0(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(448 as u32) ) };
	// 825C14F8: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 825C14FC: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825C1500: 7DAAF42E  lfsx f13, r10, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C1504: ED4CB82A  fadds f10, f12, f23
	ctx.f[10].f64 = ((ctx.f[12].f64 + ctx.f[23].f64) as f32) as f64;
	// 825C1508: EFEC5828  fsubs f31, f12, f11
	ctx.f[31].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 825C150C: EFCB502A  fadds f30, f11, f10
	ctx.f[30].f64 = ((ctx.f[11].f64 + ctx.f[10].f64) as f32) as f64;
	// 825C1510: 480000C8  b 0x825c15d8
	pc = 0x825C15D8; continue 'dispatch;
            }
            0x825C1514 => {
    //   block [0x825C1514..0x825C1588)
	// 825C1514: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C1518: 3B4BFFDD  addi r26, r11, -0x23
	ctx.r[26].s64 = ctx.r[11].s64 + -35;
	// 825C151C: 88DF0001  lbz r6, 1(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C1520: 397F0007  addi r11, r31, 7
	ctx.r[11].s64 = ctx.r[31].s64 + 7;
	// 825C1524: 88FF0003  lbz r7, 3(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825C1528: 893F0004  lbz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C152C: 54EA403E  rotlwi r10, r7, 8
	ctx.r[10].u64 = ((ctx.r[7].u32).rotate_left(8)) as u64;
	// 825C1530: F9010158  std r8, 0x158(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(344 as u32), ctx.r[8].u64 ) };
	// 825C1534: 5747103A  slwi r7, r26, 2
	ctx.r[7].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825C1538: F8C100C8  std r6, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[6].u64 ) };
	// 825C153C: 7F2A4A14  add r25, r10, r9
	ctx.r[25].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825C1540: 395A0004  addi r10, r26, 4
	ctx.r[10].s64 = ctx.r[26].s64 + 4;
	// 825C1544: 892BFFFE  lbz r9, -2(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-2 as u32) ) } as u64;
	// 825C1548: 890BFFFF  lbz r8, -1(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825C154C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825C1550: 5529403E  rotlwi r9, r9, 8
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(8)) as u64;
	// 825C1554: 7C07F42E  lfsx f0, r7, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C1558: 7F694214  add r27, r9, r8
	ctx.r[27].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 825C155C: C9A10158  lfd f13, 0x158(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(344 as u32) ) };
	// 825C1560: C98100C8  lfd f12, 0xc8(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) };
	// 825C1564: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 825C1568: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 825C156C: FD606818  frsp f11, f13
	ctx.f[11].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825C1570: 7DAAF42E  lfsx f13, r10, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C1574: FD406018  frsp f10, f12
	ctx.f[10].f64 = (ctx.f[12].f64 as f32) as f64;
	// 825C1578: 7D8AEC2E  lfsx f12, r10, r29
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[29].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825C157C: EFEB6028  fsubs f31, f11, f12
	ctx.f[31].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 825C1580: EFCA602A  fadds f30, f10, f12
	ctx.f[30].f64 = ((ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64;
	// 825C1584: 4800005C  b 0x825c15e0
	pc = 0x825C15E0; continue 'dispatch;
            }
            0x825C1588 => {
    //   block [0x825C1588..0x825C15CC)
	// 825C1588: 3B4BFFF0  addi r26, r11, -0x10
	ctx.r[26].s64 = ctx.r[11].s64 + -16;
	// 825C158C: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C1590: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C1594: F94100E0  std r10, 0xe0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[10].u64 ) };
	// 825C1598: 574A103A  slwi r10, r26, 2
	ctx.r[10].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825C159C: F96100D0  std r11, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u64 ) };
	// 825C15A0: 397A0004  addi r11, r26, 4
	ctx.r[11].s64 = ctx.r[26].s64 + 4;
	// 825C15A4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C15A8: 7C0AF42E  lfsx f0, r10, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C15AC: C98100E0  lfd f12, 0xe0(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) };
	// 825C15B0: C9A100D0  lfd f13, 0xd0(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) };
	// 825C15B4: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 825C15B8: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 825C15BC: FD406018  frsp f10, f12
	ctx.f[10].f64 = (ctx.f[12].f64 as f32) as f64;
	// 825C15C0: 7D8BEC2E  lfsx f12, r11, r29
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825C15C4: FD606818  frsp f11, f13
	ctx.f[11].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825C15C8: 7DABF42E  lfsx f13, r11, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x825C15CC; continue 'dispatch;
            }
            0x825C15CC => {
    //   block [0x825C15CC..0x825C15D8)
	// 825C15CC: EFEB6028  fsubs f31, f11, f12
	ctx.f[31].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 825C15D0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825C15D4: EFCA602A  fadds f30, f10, f12
	ctx.f[30].f64 = ((ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64;
	pc = 0x825C15D8; continue 'dispatch;
            }
            0x825C15D8 => {
    //   block [0x825C15D8..0x825C15E0)
	// 825C15D8: 8B6BFFFF  lbz r27, -1(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825C15DC: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	pc = 0x825C15E0; continue 'dispatch;
            }
            0x825C15E0 => {
    //   block [0x825C15E0..0x825C15F8)
	// 825C15E0: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 825C15E4: 40980014  bge cr6, 0x825c15f8
	if !ctx.cr[6].lt {
	pc = 0x825C15F8; continue 'dispatch;
	}
	// 825C15E8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 825C15EC: 4098000C  bge cr6, 0x825c15f8
	if !ctx.cr[6].lt {
	pc = 0x825C15F8; continue 'dispatch;
	}
	// 825C15F0: 7FF95A14  add r31, r25, r11
	ctx.r[31].u64 = ctx.r[25].u64 + ctx.r[11].u64;
	// 825C15F4: 4BFFF8BC  b 0x825c0eb0
	pc = 0x825C0EB0; continue 'dispatch;
            }
            0x825C15F8 => {
    //   block [0x825C15F8..0x825C160C)
	// 825C15F8: 7FFB5A14  add r31, r27, r11
	ctx.r[31].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 825C15FC: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 825C1600: 4099000C  ble cr6, 0x825c160c
	if !ctx.cr[6].gt {
	pc = 0x825C160C; continue 'dispatch;
	}
	// 825C1604: FF0DF000  fcmpu cr6, f13, f30
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[30].f64);
	// 825C1608: 4199F8A8  bgt cr6, 0x825c0eb0
	if ctx.cr[6].gt {
	pc = 0x825C0EB0; continue 'dispatch;
	}
	pc = 0x825C160C; continue 'dispatch;
            }
            0x825C160C => {
    //   block [0x825C160C..0x825C18C0)
	// 825C160C: 396101F0  addi r11, r1, 0x1f0
	ctx.r[11].s64 = ctx.r[1].s64 + 496;
	// 825C1610: EFA0F028  fsubs f29, f0, f30
	ctx.f[29].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 825C1614: EF8DF028  fsubs f28, f13, f30
	ctx.f[28].f64 = (((ctx.f[13].f64 - ctx.f[30].f64) as f32) as f64);
	pc = 0x825C18C0; continue 'dispatch;
            }
            0x825C18C0 => {
    //   block [0x825C18C0..0x825C1968)
	// 825C18C0: 395F0001  addi r10, r31, 1
	ctx.r[10].s64 = ctx.r[31].s64 + 1;
	// 825C18C4: C0180014  lfs f0, 0x14(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C18C8: 393F0004  addi r9, r31, 4
	ctx.r[9].s64 = ctx.r[31].s64 + 4;
	// 825C18CC: C1BD0028  lfs f13, 0x28(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C18D0: 396BFFD7  addi r11, r11, -0x29
	ctx.r[11].s64 = ctx.r[11].s64 + -41;
	// 825C18D4: 3BFF0007  addi r31, r31, 7
	ctx.r[31].s64 = ctx.r[31].s64 + 7;
	// 825C18D8: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C18DC: 88890000  lbz r4, 0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C18E0: 88EA0001  lbz r7, 1(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C18E4: 5505403E  rotlwi r5, r8, 8
	ctx.r[5].u64 = ((ctx.r[8].u32).rotate_left(8)) as u64;
	// 825C18E8: 88C90001  lbz r6, 1(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C18EC: 5488403E  rotlwi r8, r4, 8
	ctx.r[8].u64 = ((ctx.r[4].u32).rotate_left(8)) as u64;
	// 825C18F0: 7CA72A14  add r5, r7, r5
	ctx.r[5].u64 = ctx.r[7].u64 + ctx.r[5].u64;
	// 825C18F4: 88EA0002  lbz r7, 2(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C18F8: 7D483214  add r10, r8, r6
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[6].u64;
	// 825C18FC: 89290002  lbz r9, 2(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C1900: 54A8402E  slwi r8, r5, 8
	ctx.r[8].u32 = ctx.r[5].u32.wrapping_shl(8);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825C1904: 554A402E  slwi r10, r10, 8
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(8);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825C1908: 7D083A14  add r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 825C190C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825C1910: 7D0807B4  extsw r8, r8
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 825C1914: 7D4707B4  extsw r7, r10
	ctx.r[7].s64 = ctx.r[10].s32 as i64;
	// 825C1918: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 825C191C: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825C1920: F90100F0  std r8, 0xf0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[8].u64 ) };
	// 825C1924: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825C1928: F8E10100  std r7, 0x100(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[7].u64 ) };
	// 825C192C: 7D6AEC2E  lfsx f11, r10, r29
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[29].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825C1930: 7D89EC2E  lfsx f12, r9, r29
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[29].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825C1934: C94100F0  lfd f10, 0xf0(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(240 as u32) ) };
	// 825C1938: C9210100  lfd f9, 0x100(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 825C193C: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 825C1940: FD204E9C  fcfid f9, f9
	ctx.f[9].f64 = (ctx.f[9].s64 as f64);
	// 825C1944: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 825C1948: FD204818  frsp f9, f9
	ctx.f[9].f64 = (ctx.f[9].f64 as f32) as f64;
	// 825C194C: ED4A0032  fmuls f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 825C1950: EC090032  fmuls f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 825C1954: ED4A6378  fmsubs f10, f10, f13, f12
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 825C1958: EC006378  fmsubs f0, f0, f13, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 825C195C: ED4A5828  fsubs f10, f10, f11
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 825C1960: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 825C1964: 48000048  b 0x825c19ac
	pc = 0x825C19AC; continue 'dispatch;
            }
            0x825C1968 => {
    //   block [0x825C1968..0x825C1AC0)
	// 825C1968: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C196C: 396BFFDA  addi r11, r11, -0x26
	ctx.r[11].s64 = ctx.r[11].s64 + -38;
	// 825C1970: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C1974: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825C1978: F9410110  std r10, 0x110(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[10].u64 ) };
	// 825C197C: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 825C1980: F9210120  std r9, 0x120(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[9].u64 ) };
	// 825C1984: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825C1988: C8010110  lfd f0, 0x110(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(272 as u32) ) };
	// 825C198C: C9A10120  lfd f13, 0x120(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(288 as u32) ) };
	// 825C1990: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 825C1994: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 825C1998: FD800018  frsp f12, f0
	ctx.f[12].f64 = (ctx.f[0].f64 as f32) as f64;
	// 825C199C: 7C0AEC2E  lfsx f0, r10, r29
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[29].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C19A0: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825C19A4: ED4C0028  fsubs f10, f12, f0
	ctx.f[10].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 825C19A8: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 825C19AC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C19B0: 7D8AF42E  lfsx f12, r10, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825C19B4: 7D6BF42E  lfsx f11, r11, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825C19B8: FF0B6000  fcmpu cr6, f11, f12
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[12].f64);
	// 825C19BC: 4098001C  bge cr6, 0x825c19d8
	if !ctx.cr[6].lt {
	pc = 0x825C19D8; continue 'dispatch;
	}
	// 825C19C0: FF0C5000  fcmpu cr6, f12, f10
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[10].f64);
	// 825C19C4: 41980694  blt cr6, 0x825c2058
	if ctx.cr[6].lt {
	pc = 0x825C2058; continue 'dispatch;
	}
	// 825C19C8: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 825C19CC: 4199068C  bgt cr6, 0x825c2058
	if ctx.cr[6].gt {
	pc = 0x825C2058; continue 'dispatch;
	}
	// 825C19D0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825C19D4: 48000018  b 0x825c19ec
	pc = 0x825C19EC; continue 'dispatch;
	// 825C19D8: FF0B5000  fcmpu cr6, f11, f10
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[10].f64);
	// 825C19DC: 4198067C  blt cr6, 0x825c2058
	if ctx.cr[6].lt {
	pc = 0x825C2058; continue 'dispatch;
	}
	// 825C19E0: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 825C19E4: 41990674  bgt cr6, 0x825c2058
	if ctx.cr[6].gt {
	pc = 0x825C2058; continue 'dispatch;
	}
	// 825C19E8: 7E088378  mr r8, r16
	ctx.r[8].u64 = ctx.r[16].u64;
	// 825C19EC: 397E0010  addi r11, r30, 0x10
	ctx.r[11].s64 = ctx.r[30].s64 + 16;
	// 825C19F0: EDAB0028  fsubs f13, f11, f0
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 825C19F4: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 825C19F8: E8FE0000  ld r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 825C19FC: 39410210  addi r10, r1, 0x210
	ctx.r[10].s64 = ctx.r[1].s64 + 528;
	// 825C1A00: E8BE0008  ld r5, 8(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 825C1A04: 39210220  addi r9, r1, 0x220
	ctx.r[9].s64 = ctx.r[1].s64 + 544;
	// 825C1A08: E8CB0000  ld r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 825C1A0C: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 825C1A10: F8EA0000  std r7, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u64 ) };
	// 825C1A14: F8AA0008  std r5, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[5].u64 ) };
	// 825C1A18: F8C90000  std r6, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 825C1A1C: F9690008  std r11, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 825C1A20: 39610210  addi r11, r1, 0x210
	ctx.r[11].s64 = ctx.r[1].s64 + 528;
	// 825C1A24: ED200372  fmuls f9, f0, f13
	ctx.f[9].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
            }
            0x825C1AC0 => {
    //   block [0x825C1AC0..0x825C1AD0)
	// 825C1AC0: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C1AC4: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825C1AC8: 3BEB0002  addi r31, r11, 2
	ctx.r[31].s64 = ctx.r[11].s64 + 2;
	// 825C1ACC: 4BFFF3E4  b 0x825c0eb0
	pc = 0x825C0EB0; continue 'dispatch;
            }
            0x825C1AD0 => {
    //   block [0x825C1AD0..0x825C1AEC)
	// 825C1AD0: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C1AD4: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C1AD8: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825C1ADC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825C1AE0: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825C1AE4: 3BEB0003  addi r31, r11, 3
	ctx.r[31].s64 = ctx.r[11].s64 + 3;
	// 825C1AE8: 4BFFF3C8  b 0x825c0eb0
	pc = 0x825C0EB0; continue 'dispatch;
            }
            0x825C1AEC => {
    //   block [0x825C1AEC..0x825C1B14)
	// 825C1AEC: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C1AF0: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C1AF4: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825C1AF8: 895F0003  lbz r10, 3(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825C1AFC: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825C1B00: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C1B04: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825C1B08: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825C1B0C: 3BEB0004  addi r31, r11, 4
	ctx.r[31].s64 = ctx.r[11].s64 + 4;
	// 825C1B10: 4BFFF3A0  b 0x825c0eb0
	pc = 0x825C0EB0; continue 'dispatch;
            }
            0x825C1B14 => {
    //   block [0x825C1B14..0x825C1B38)
	// 825C1B14: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C1B18: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C1B1C: 81380010  lwz r9, 0x10(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 825C1B20: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825C1B24: 7D745378  or r20, r11, r10
	ctx.r[20].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 825C1B28: 568A482C  slwi r10, r20, 9
	ctx.r[10].u32 = ctx.r[20].u32.wrapping_shl(9);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825C1B2C: 81690020  lwz r11, 0x20(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 825C1B30: 7FEB5214  add r31, r11, r10
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825C1B34: 4BFFF37C  b 0x825c0eb0
	pc = 0x825C0EB0; continue 'dispatch;
            }
            0x825C1B38 => {
    //   block [0x825C1B38..0x825C1C54)
	// 825C1B38: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C1B3C: D30100AC  stfs f24, 0xac(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 825C1B40: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	pc = 0x825C1C54; continue 'dispatch;
            }
            0x825C1C54 => {
    //   block [0x825C1C54..0x825C1CBC)
	// 825C1C54: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 825C1C58: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C1C5C: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825C1C60: 419A0048  beq cr6, 0x825c1ca8
	if ctx.cr[6].eq {
	pc = 0x825C1CA8; continue 'dispatch;
	}
	// 825C1C64: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	pc = 0x825C1CBC; continue 'dispatch;
            }
            0x825C1CBC => {
    //   block [0x825C1CBC..0x825C1D30)
	// 825C1CBC: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C1CC0: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 825C1CC4: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C1CC8: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825C1CCC: 7F1D4840  cmplw cr6, r29, r9
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825C1CD0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825C1CD4: 419A0048  beq cr6, 0x825c1d1c
	if ctx.cr[6].eq {
	pc = 0x825C1D1C; continue 'dispatch;
	}
	// 825C1CD8: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	pc = 0x825C1D30; continue 'dispatch;
            }
            0x825C1D30 => {
    //   block [0x825C1D30..0x825C1DAC)
	// 825C1D30: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C1D34: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 825C1D38: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C1D3C: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825C1D40: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825C1D44: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C1D48: 7F1D3840  cmplw cr6, r29, r7
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825C1D4C: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825C1D50: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C1D54: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825C1D58: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C1D5C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825C1D60: 419A0048  beq cr6, 0x825c1da8
	if ctx.cr[6].eq {
	pc = 0x825C1DA8; continue 'dispatch;
	}
	// 825C1D64: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	pc = 0x825C1DAC; continue 'dispatch;
            }
            0x825C1DAC => {
    //   block [0x825C1DAC..0x825C1DB4)
	// 825C1DAC: 3BFF0005  addi r31, r31, 5
	ctx.r[31].s64 = ctx.r[31].s64 + 5;
	// 825C1DB0: 4BFFF100  b 0x825c0eb0
	pc = 0x825C0EB0; continue 'dispatch;
            }
            0x825C1DB4 => {
    //   block [0x825C1DB4..0x825C1DD0)
	// 825C1DB4: 396BFFA0  addi r11, r11, -0x60
	ctx.r[11].s64 = ctx.r[11].s64 + -96;
	// 825C1DB8: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C1DBC: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 825C1DC0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C1DC4: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 825C1DC8: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 825C1DCC: 48000068  b 0x825c1e34
	pc = 0x825C1E34; continue 'dispatch;
            }
            0x825C1DD0 => {
    //   block [0x825C1DD0..0x825C1DF8)
	// 825C1DD0: 893F0001  lbz r9, 1(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C1DD4: 390BFF9C  addi r8, r11, -0x64
	ctx.r[8].s64 = ctx.r[11].s64 + -100;
	// 825C1DD8: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C1DDC: 38E10090  addi r7, r1, 0x90
	ctx.r[7].s64 = ctx.r[1].s64 + 144;
	// 825C1DE0: 552B403E  rotlwi r11, r9, 8
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(8)) as u64;
	// 825C1DE4: 5509103A  slwi r9, r8, 2
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825C1DE8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825C1DEC: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 825C1DF0: 7D69392E  stwx r11, r9, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32), ctx.r[11].u32) };
	// 825C1DF4: 48000040  b 0x825c1e34
	pc = 0x825C1E34; continue 'dispatch;
            }
            0x825C1DF8 => {
    //   block [0x825C1DF8..0x825C1E90)
	// 825C1DF8: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C1DFC: 38EBFF98  addi r7, r11, -0x68
	ctx.r[7].s64 = ctx.r[11].s64 + -104;
	// 825C1E00: 891F0002  lbz r8, 2(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C1E04: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 825C1E08: 554B403E  rotlwi r11, r10, 8
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(8)) as u64;
	// 825C1E0C: 893F0003  lbz r9, 3(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825C1E10: 895F0004  lbz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C1E14: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825C1E18: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825C1E1C: 3BFF0005  addi r31, r31, 5
	ctx.r[31].s64 = ctx.r[31].s64 + 5;
	// 825C1E20: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C1E24: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825C1E28: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C1E2C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825C1E30: 7D67312E  stwx r11, r7, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32), ctx.r[11].u32) };
	// 825C1E34: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 825C1E38: 81610090  lwz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 825C1E3C: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825C1E40: 419A0048  beq cr6, 0x825c1e88
	if ctx.cr[6].eq {
	pc = 0x825C1E88; continue 'dispatch;
	}
	// 825C1E44: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	pc = 0x825C1E90; continue 'dispatch;
            }
            0x825C1E90 => {
    //   block [0x825C1E90..0x825C1EE4)
	// 825C1E90: 38A00200  li r5, 0x200
	ctx.r[5].s64 = 512;
	// 825C1E94: 38810230  addi r4, r1, 0x230
	ctx.r[4].s64 = ctx.r[1].s64 + 560;
	// 825C1E98: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 825C1E9C: 4BEA6F5D  bl 0x82468df8
	ctx.lr = 0x825C1EA0;
	sub_82468DF8(ctx, base);
	// 825C1EA0: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 825C1EA4: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 825C1EA8: 4BEA63F9  bl 0x824682a0
	ctx.lr = 0x825C1EAC;
	sub_824682A0(ctx, base);
	// 825C1EAC: 80719190  lwz r3, -0x6e70(r17)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(-28272 as u32) ) } as u64;
	// 825C1EB0: 3CA01298  lis r5, 0x1298
	ctx.r[5].s64 = 311951360;
	// 825C1EB4: 390001FA  li r8, 0x1fa
	ctx.r[8].s64 = 506;
	// 825C1EB8: 7E679B78  mr r7, r19
	ctx.r[7].u64 = ctx.r[19].u64;
	// 825C1EBC: 38C10230  addi r6, r1, 0x230
	ctx.r[6].s64 = ctx.r[1].s64 + 560;
	// 825C1EC0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C1EC4: 60A5FEDD  ori r5, r5, 0xfedd
	ctx.r[5].u64 = ctx.r[5].u64 | 65245;
	// 825C1EC8: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825C1ECC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825C1ED0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825C1ED4: 4E800421  bctrl
	ctx.lr = 0x825C1ED8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825C1ED8: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 825C1EDC: 4BEA6A05  bl 0x824688e0
	ctx.lr = 0x825C1EE0;
	sub_824688E0(ctx, base);
	// 825C1EE0: 4BFFEFD0  b 0x825c0eb0
	pc = 0x825C0EB0; continue 'dispatch;
            }
            0x825C1EE4 => {
    //   block [0x825C1EE4..0x825C1EEC)
	// 825C1EE4: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C1EE8: 48000068  b 0x825c1f50
	pc = 0x825C1F50; continue 'dispatch;
            }
            0x825C1EEC => {
    //   block [0x825C1EEC..0x825C1F00)
	// 825C1EEC: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C1EF0: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C1EF4: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825C1EF8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825C1EFC: 48000054  b 0x825c1f50
	pc = 0x825C1F50; continue 'dispatch;
            }
            0x825C1F00 => {
    //   block [0x825C1F00..0x825C1F20)
	// 825C1F00: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C1F04: 893F0002  lbz r9, 2(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C1F08: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825C1F0C: 895F0003  lbz r10, 3(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825C1F10: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825C1F14: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C1F18: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825C1F1C: 48000034  b 0x825c1f50
	pc = 0x825C1F50; continue 'dispatch;
            }
            0x825C1F20 => {
    //   block [0x825C1F20..0x825C1F4C)
	// 825C1F20: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C1F24: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C1F28: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 825C1F2C: 891F0003  lbz r8, 3(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(3 as u32) ) } as u64;
	// 825C1F30: 893F0004  lbz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C1F34: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825C1F38: 550A403E  rotlwi r10, r8, 8
	ctx.r[10].u64 = ((ctx.r[8].u32).rotate_left(8)) as u64;
	// 825C1F3C: 556B801E  slwi r11, r11, 0x10
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(16);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C1F40: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825C1F44: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825C1F48: 48000008  b 0x825c1f50
	pc = 0x825C1F50; continue 'dispatch;
            }
            0x825C1F4C => {
    //   block [0x825C1F4C..0x825C2058)
	// 825C1F4C: 396BFFD0  addi r11, r11, -0x30
	ctx.r[11].s64 = ctx.r[11].s64 + -48;
	// 825C1F50: 8138002C  lwz r9, 0x2c(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(44 as u32) ) } as u64;
	// 825C1F54: 5688402E  slwi r8, r20, 8
	ctx.r[8].u32 = ctx.r[20].u32.wrapping_shl(8);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825C1F58: 815D002C  lwz r10, 0x2c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 825C1F5C: 80F80030  lwz r7, 0x30(r24)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(48 as u32) ) } as u64;
	// 825C1F60: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825C1F64: 7CE84038  and r8, r7, r8
	ctx.r[8].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 825C1F68: 81490038  lwz r10, 0x38(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(56 as u32) ) } as u64;
	// 825C1F6C: 7D1E5B78  or r30, r8, r11
	ctx.r[30].u64 = ctx.r[8].u64 | ctx.r[11].u64;
	// 825C1F70: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C1F74: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 825C1F78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C1F7C: 3BAB0010  addi r29, r11, 0x10
	ctx.r[29].s64 = ctx.r[11].s64 + 16;
	// 825C1F80: 409A0008  bne cr6, 0x825c1f88
	if !ctx.cr[6].eq {
	pc = 0x825C1F88; continue 'dispatch;
	}
	// 825C1F84: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825C1F88: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C1F8C: 38A10230  addi r5, r1, 0x230
	ctx.r[5].s64 = ctx.r[1].s64 + 560;
	// 825C1F90: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C1F94: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825C1F98: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825C1F9C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825C1FA0: 4E800421  bctrl
	ctx.lr = 0x825C1FA4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825C1FA4: 8178002C  lwz r11, 0x2c(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(44 as u32) ) } as u64;
	// 825C1FA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825C1FAC: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 825C1FB0: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 825C1FB4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825C1FB8: 80AB0030  lwz r5, 0x30(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 825C1FBC: 80EB0038  lwz r7, 0x38(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 825C1FC0: 80CB0034  lwz r6, 0x34(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 825C1FC4: 80850008  lwz r4, 8(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C1FC8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C1FCC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C1FD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825C1FD4: 4E800421  bctrl
	ctx.lr = 0x825C1FD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825C1FD8: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C1FDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C1FE0: 419A0078  beq cr6, 0x825c2058
	if ctx.cr[6].eq {
	pc = 0x825C2058; continue 'dispatch;
	}
	// 825C1FE4: 81580018  lwz r10, 0x18(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(24 as u32) ) } as u64;
	// 825C1FE8: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 825C1FEC: 8178002C  lwz r11, 0x2c(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(44 as u32) ) } as u64;
	// 825C1FF0: 394A000D  addi r10, r10, 0xd
	ctx.r[10].s64 = ctx.r[10].s64 + 13;
	// 825C1FF4: 80F80028  lwz r7, 0x28(r24)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(40 as u32) ) } as u64;
	// 825C1FF8: 80D80024  lwz r6, 0x24(r24)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(36 as u32) ) } as u64;
	// 825C1FFC: 55492834  slwi r9, r10, 5
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825C2000: 814B0038  lwz r10, 0x38(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 825C2004: 914100BC  stw r10, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[10].u32 ) };
	// 825C2008: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C200C: 93E100B0  stw r31, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[31].u32 ) };
	// 825C2010: 93C100B4  stw r30, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[30].u32 ) };
	// 825C2014: 914100B8  stw r10, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[10].u32 ) };
	// 825C2018: 80AB0030  lwz r5, 0x30(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 825C201C: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825C2020: 806B0034  lwz r3, 0x34(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 825C2024: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 825C2028: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C202C: 7D4A58AE  lbzx r10, r10, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825C2030: 5549103E  rotlwi r9, r10, 2
	ctx.r[9].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 825C2034: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825C2038: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825C203C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825C2040: 816B09AC  lwz r11, 0x9ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2476 as u32) ) } as u64;
	// 825C2044: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825C2048: 4E800421  bctrl
	ctx.lr = 0x825C204C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825C204C: 81780024  lwz r11, 0x24(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(36 as u32) ) } as u64;
	// 825C2050: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C2054: D018001C  stfs f0, 0x1c(r24)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(28 as u32), tmp.u32 ) };
            }
            0x825C2058 => {
    //   block [0x825C2058..0x825C2068)
	// 825C2058: 38210500  addi r1, r1, 0x500
	ctx.r[1].s64 = ctx.r[1].s64 + 1280;
	// 825C205C: 3981FF78  addi r12, r1, -0x88
	ctx.r[12].s64 = ctx.r[1].s64 + -136;
	// 825C2060: 4BF73FC1  bl 0x82536020
	ctx.lr = 0x825C2064;
	sub_82535FFC(ctx, base);
	// 825C2064: 4BF73074  b 0x825350d8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C2068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C2068 size=428
    let mut pc: u32 = 0x825C2068;
    'dispatch: loop {
        match pc {
            0x825C2068 => {
    //   block [0x825C2068..0x825C20AC)
	// 825C2068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C206C: 4BF73041  bl 0x825350ac
	ctx.lr = 0x825C2070;
	sub_82535080(ctx, base);
	// 825C2070: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C2074: 3F60829A  lis r27, -0x7d66
	ctx.r[27].s64 = -2103836672;
	// 825C2078: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825C207C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825C2080: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825C2084: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825C2088: 897B3E86  lbz r11, 0x3e86(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(16006 as u32) ) } as u64;
	// 825C208C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C2090: 409A001C  bne cr6, 0x825c20ac
	if !ctx.cr[6].eq {
	pc = 0x825C20AC; continue 'dispatch;
	}
	// 825C2094: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 825C2098: 4BF370A9  bl 0x824f9140
	ctx.lr = 0x825C209C;
	sub_824F9140(ctx, base);
	// 825C209C: 7C6B0774  extsb r11, r3
	ctx.r[11].s64 = ctx.r[3].s8 as i64;
	// 825C20A0: 987B3E86  stb r3, 0x3e86(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(16006 as u32), ctx.r[3].u8 ) };
	// 825C20A4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C20A8: 419A0164  beq cr6, 0x825c220c
	if ctx.cr[6].eq {
	pc = 0x825C220C; continue 'dispatch;
	}
	pc = 0x825C20AC; continue 'dispatch;
            }
            0x825C20AC => {
    //   block [0x825C20AC..0x825C220C)
	// 825C20AC: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 825C20B0: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 825C20B4: 811E0038  lwz r8, 0x38(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 825C20B8: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 825C20BC: 392100A8  addi r9, r1, 0xa8
	ctx.r[9].s64 = ctx.r[1].s64 + 168;
	// 825C20C0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825C20C4: 3B4100A8  addi r26, r1, 0xa8
	ctx.r[26].s64 = ctx.r[1].s64 + 168;
	pc = 0x825C220C; continue 'dispatch;
            }
            0x825C220C => {
    //   block [0x825C220C..0x825C2214)
	// 825C220C: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 825C2210: 4BF72EEC  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C2218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C2218 size=500
    let mut pc: u32 = 0x825C2218;
    'dispatch: loop {
        match pc {
            0x825C2218 => {
    //   block [0x825C2218..0x825C240C)
	// 825C2218: 89640004  lbz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C221C: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 825C2220: 89440005  lbz r10, 5(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(5 as u32) ) } as u64;
	// 825C2224: 38C1FFC0  addi r6, r1, -0x40
	ctx.r[6].s64 = ctx.r[1].s64 + -64;
	// 825C2228: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 825C222C: 89240006  lbz r9, 6(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(6 as u32) ) } as u64;
	// 825C2230: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 825C2234: 89040007  lbz r8, 7(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(7 as u32) ) } as u64;
	// 825C2238: 7D291A14  add r9, r9, r3
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[3].u64;
	// 825C223C: 7D081A14  add r8, r8, r3
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C240C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C240C size=12
    let mut pc: u32 = 0x825C240C;
    'dispatch: loop {
        match pc {
            0x825C240C => {
    //   block [0x825C240C..0x825C2418)
	// 825C240C: 7D4B50F8  nor r11, r10, r10
	ctx.r[11].u64 = !(ctx.r[10].u64 | ctx.r[10].u64);
	// 825C2410: 5563073C  rlwinm r3, r11, 0, 0x1c, 0x1e
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825C2414: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C2418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C2418 size=516
    let mut pc: u32 = 0x825C2418;
    'dispatch: loop {
        match pc {
            0x825C2418 => {
    //   block [0x825C2418..0x825C261C)
	// 825C2418: 89640007  lbz r11, 7(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(7 as u32) ) } as u64;
	// 825C241C: 39450010  addi r10, r5, 0x10
	ctx.r[10].s64 = ctx.r[5].s64 + 16;
	// 825C2420: 89240004  lbz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C2424: 38C1FFC0  addi r6, r1, -0x40
	ctx.r[6].s64 = ctx.r[1].s64 + -64;
	// 825C2428: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 825C242C: 89040005  lbz r8, 5(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(5 as u32) ) } as u64;
	// 825C2430: 7D291A14  add r9, r9, r3
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[3].u64;
	// 825C2434: 88E40006  lbz r7, 6(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(6 as u32) ) } as u64;
	// 825C2438: 7D081A14  add r8, r8, r3
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[3].u64;
	// 825C243C: 7CE71A14  add r7, r7, r3
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[3].u64;
	// 825C2440: 3881FFC0  addi r4, r1, -0x40
	ctx.r[4].s64 = ctx.r[1].s64 + -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C261C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C261C size=12
    let mut pc: u32 = 0x825C261C;
    'dispatch: loop {
        match pc {
            0x825C261C => {
    //   block [0x825C261C..0x825C2628)
	// 825C261C: 7D4B50F8  nor r11, r10, r10
	ctx.r[11].u64 = !(ctx.r[10].u64 | ctx.r[10].u64);
	// 825C2620: 5563073C  rlwinm r3, r11, 0, 0x1c, 0x1e
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825C2624: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C2628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C2628 size=364
    let mut pc: u32 = 0x825C2628;
    'dispatch: loop {
        match pc {
            0x825C2628 => {
    //   block [0x825C2628..0x825C2794)
	// 825C2628: 89640004  lbz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C262C: 38E00100  li r7, 0x100
	ctx.r[7].s64 = 256;
	// 825C2630: 89440005  lbz r10, 5(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(5 as u32) ) } as u64;
	// 825C2634: 38C00020  li r6, 0x20
	ctx.r[6].s64 = 32;
	// 825C2638: 89240006  lbz r9, 6(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(6 as u32) ) } as u64;
	// 825C263C: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 825C2640: 89040007  lbz r8, 7(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(7 as u32) ) } as u64;
	// 825C2644: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 825C2648: 7D291A14  add r9, r9, r3
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[3].u64;
	// 825C264C: 7D081A14  add r8, r8, r3
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C2794(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C2794 size=152
    let mut pc: u32 = 0x825C2794;
    'dispatch: loop {
        match pc {
            0x825C2794 => {
    //   block [0x825C2794..0x825C282C)
	// 825C2794: 1160028C  vspltw v11, v0, 0
	for i in 0..4 {
		ctx.v[11].u32[i] = ctx.v[0].u32[3];
	}
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C2830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C2830 size=488
    let mut pc: u32 = 0x825C2830;
    'dispatch: loop {
        match pc {
            0x825C2830 => {
    //   block [0x825C2830..0x825C2854)
	// 825C2830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C2834: 4BF72889  bl 0x825350bc
	ctx.lr = 0x825C2838;
	sub_82535080(ctx, base);
	// 825C2838: 89030002  lbz r8, 2(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C283C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825C2840: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825C2844: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 825C2848: 419A00D0  beq cr6, 0x825c2918
	if ctx.cr[6].eq {
	pc = 0x825C2918; continue 'dispatch;
	}
	// 825C284C: 88C40008  lbz r6, 8(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C2850: 39630008  addi r11, r3, 8
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	pc = 0x825C2854; continue 'dispatch;
            }
            0x825C2854 => {
    //   block [0x825C2854..0x825C28E0)
	// 825C2854: 894BFFFC  lbz r10, -4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 825C2858: 7F065040  cmplw cr6, r6, r10
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825C285C: 409A00AC  bne cr6, 0x825c2908
	if !ctx.cr[6].eq {
	pc = 0x825C2908; continue 'dispatch;
	}
	// 825C2860: 89240009  lbz r9, 9(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(9 as u32) ) } as u64;
	// 825C2864: 894BFFFD  lbz r10, -3(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-3 as u32) ) } as u64;
	// 825C2868: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825C286C: 409A009C  bne cr6, 0x825c2908
	if !ctx.cr[6].eq {
	pc = 0x825C2908; continue 'dispatch;
	}
	// 825C2870: 8BCB0000  lbz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C2874: 7CE93214  add r7, r9, r6
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[6].u64;
	// 825C2878: 550A1838  slwi r10, r8, 3
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825C287C: A3A40000  lhz r29, 0(r4)
	ctx.r[29].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C2880: 57C9E8FE  srwi r9, r30, 3
	ctx.r[9].u32 = ctx.r[30].u32.wrapping_shr(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825C2884: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 825C2888: 7D291A14  add r9, r9, r3
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[3].u64;
	// 825C288C: A1290004  lhz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C2890: 7F1D4840  cmplw cr6, r29, r9
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825C2894: 409A0074  bne cr6, 0x825c2908
	if !ctx.cr[6].eq {
	pc = 0x825C2908; continue 'dispatch;
	}
	// 825C2898: 892B0001  lbz r9, 1(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C289C: A3C40002  lhz r30, 2(r4)
	ctx.r[30].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C28A0: 5529E8FE  srwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shr(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825C28A4: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 825C28A8: 7D291A14  add r9, r9, r3
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[3].u64;
	// 825C28AC: A1290004  lhz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C28B0: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825C28B4: 409A0054  bne cr6, 0x825c2908
	if !ctx.cr[6].eq {
	pc = 0x825C2908; continue 'dispatch;
	}
	// 825C28B8: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 825C28BC: 40990024  ble cr6, 0x825c28e0
	if !ctx.cr[6].gt {
	pc = 0x825C28E0; continue 'dispatch;
	}
	// 825C28C0: 892B0002  lbz r9, 2(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C28C4: A3C40004  lhz r30, 4(r4)
	ctx.r[30].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C28C8: 5529E8FE  srwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shr(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825C28CC: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 825C28D0: 7D291A14  add r9, r9, r3
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[3].u64;
	// 825C28D4: A1290004  lhz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C28D8: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825C28DC: 409A002C  bne cr6, 0x825c2908
	if !ctx.cr[6].eq {
	pc = 0x825C2908; continue 'dispatch;
	}
	pc = 0x825C28E0; continue 'dispatch;
            }
            0x825C28E0 => {
    //   block [0x825C28E0..0x825C2908)
	// 825C28E0: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 825C28E4: 409900F4  ble cr6, 0x825c29d8
	if !ctx.cr[6].gt {
	pc = 0x825C29D8; continue 'dispatch;
	}
	// 825C28E8: 892B0003  lbz r9, 3(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 825C28EC: A0E40006  lhz r7, 6(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(6 as u32) ) } as u64;
	// 825C28F0: 5529E8FE  srwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shr(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825C28F4: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 825C28F8: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 825C28FC: A14A0004  lhz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C2900: 7F075040  cmplw cr6, r7, r10
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825C2904: 419A00D4  beq cr6, 0x825c29d8
	if ctx.cr[6].eq {
	pc = 0x825C29D8; continue 'dispatch;
	}
	pc = 0x825C2908; continue 'dispatch;
            }
            0x825C2908 => {
    //   block [0x825C2908..0x825C2918)
	// 825C2908: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 825C290C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 825C2910: 7F054040  cmplw cr6, r5, r8
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825C2914: 4198FF40  blt cr6, 0x825c2854
	if ctx.cr[6].lt {
	pc = 0x825C2854; continue 'dispatch;
	}
	pc = 0x825C2918; continue 'dispatch;
            }
            0x825C2918 => {
    //   block [0x825C2918..0x825C2930)
	// 825C2918: 88E40008  lbz r7, 8(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C291C: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 825C2920: 419A0010  beq cr6, 0x825c2930
	if ctx.cr[6].eq {
	pc = 0x825C2930; continue 'dispatch;
	}
	// 825C2924: 89640009  lbz r11, 9(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(9 as u32) ) } as u64;
	// 825C2928: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 825C292C: 409A00E4  bne cr6, 0x825c2a10
	if !ctx.cr[6].eq {
	pc = 0x825C2A10; continue 'dispatch;
	}
	pc = 0x825C2930; continue 'dispatch;
            }
            0x825C2930 => {
    //   block [0x825C2930..0x825C2940)
	// 825C2930: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 825C2934: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 825C2938: 419A00D8  beq cr6, 0x825c2a10
	if ctx.cr[6].eq {
	pc = 0x825C2A10; continue 'dispatch;
	}
	// 825C293C: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	pc = 0x825C2940; continue 'dispatch;
            }
            0x825C2940 => {
    //   block [0x825C2940..0x825C2978)
	// 825C2940: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 825C2944: 409A0034  bne cr6, 0x825c2978
	if !ctx.cr[6].eq {
	pc = 0x825C2978; continue 'dispatch;
	}
	// 825C2948: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C294C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 825C2950: 409A0028  bne cr6, 0x825c2978
	if !ctx.cr[6].eq {
	pc = 0x825C2978; continue 'dispatch;
	}
	// 825C2954: 894B0004  lbz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C2958: 55091838  slwi r9, r8, 3
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825C295C: A0A40000  lhz r5, 0(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C2960: 554AE8FE  srwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825C2964: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825C2968: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 825C296C: A14A0004  lhz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C2970: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 825C2974: 419A0094  beq cr6, 0x825c2a08
	if ctx.cr[6].eq {
	pc = 0x825C2A08; continue 'dispatch;
	}
	pc = 0x825C2978; continue 'dispatch;
            }
            0x825C2978 => {
    //   block [0x825C2978..0x825C29C0)
	// 825C2978: 89440009  lbz r10, 9(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(9 as u32) ) } as u64;
	// 825C297C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 825C2980: 409A0040  bne cr6, 0x825c29c0
	if !ctx.cr[6].eq {
	pc = 0x825C29C0; continue 'dispatch;
	}
	// 825C2984: 894B0001  lbz r10, 1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C2988: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 825C298C: 409A0034  bne cr6, 0x825c29c0
	if !ctx.cr[6].eq {
	pc = 0x825C29C0; continue 'dispatch;
	}
	// 825C2990: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C2994: 55091838  slwi r9, r8, 3
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825C2998: 54E5083C  slwi r5, r7, 1
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 825C299C: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825C29A0: 7CA5222E  lhzx r5, r5, r4
	ctx.r[5].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 825C29A4: 894A0004  lbz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C29A8: 554AE8FE  srwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825C29AC: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825C29B0: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 825C29B4: A14A0004  lhz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C29B8: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 825C29BC: 419A004C  beq cr6, 0x825c2a08
	if ctx.cr[6].eq {
	pc = 0x825C2A08; continue 'dispatch;
	}
	pc = 0x825C29C0; continue 'dispatch;
            }
            0x825C29C0 => {
    //   block [0x825C29C0..0x825C29D8)
	// 825C29C0: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 825C29C4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 825C29C8: 7F064040  cmplw cr6, r6, r8
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825C29CC: 4198FF74  blt cr6, 0x825c2940
	if ctx.cr[6].lt {
	pc = 0x825C2940; continue 'dispatch;
	}
	// 825C29D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825C29D4: 4BF72738  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x825C29D8 => {
    //   block [0x825C29D8..0x825C2A00)
	// 825C29D8: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 825C29DC: 419A0024  beq cr6, 0x825c2a00
	if ctx.cr[6].eq {
	pc = 0x825C2A00; continue 'dispatch;
	}
	// 825C29E0: 54AB1838  slwi r11, r5, 3
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C29E4: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C29E8: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 825C29EC: E94B0004  ld r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	// 825C29F0: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825C29F4: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C29F8: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 825C29FC: F9430004  std r10, 4(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u64 ) };
	pc = 0x825C2A00; continue 'dispatch;
            }
            0x825C2A00 => {
    //   block [0x825C2A00..0x825C2A08)
	// 825C2A00: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825C2A04: 4BF72708  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x825C2A08 => {
    //   block [0x825C2A08..0x825C2A10)
	// 825C2A08: 9BEB0001  stb r31, 1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1 as u32), ctx.r[31].u8 ) };
	// 825C2A0C: 9BEB0000  stb r31, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u8 ) };
	pc = 0x825C2A10; continue 'dispatch;
            }
            0x825C2A10 => {
    //   block [0x825C2A10..0x825C2A18)
	// 825C2A10: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825C2A14: 4BF726F8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C2A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C2A18 size=124
    let mut pc: u32 = 0x825C2A18;
    'dispatch: loop {
        match pc {
            0x825C2A18 => {
    //   block [0x825C2A18..0x825C2A48)
	// 825C2A18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C2A1C: 4BF72695  bl 0x825350b0
	ctx.lr = 0x825C2A20;
	sub_82535080(ctx, base);
	// 825C2A20: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C2A24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825C2A28: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 825C2A2C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 825C2A30: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 825C2A34: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 825C2A38: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C2A3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C2A40: 419A0040  beq cr6, 0x825c2a80
	if ctx.cr[6].eq {
	pc = 0x825C2A80; continue 'dispatch;
	}
	// 825C2A44: 3BDF0006  addi r30, r31, 6
	ctx.r[30].s64 = ctx.r[31].s64 + 6;
	pc = 0x825C2A48; continue 'dispatch;
            }
            0x825C2A48 => {
    //   block [0x825C2A48..0x825C2A6C)
	// 825C2A48: A09E0000  lhz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C2A4C: 2B04FFFF  cmplwi cr6, r4, 0xffff
	ctx.cr[6].compare_u32(ctx.r[4].u32, 65535 as u32, &mut ctx.xer);
	// 825C2A50: 419A001C  beq cr6, 0x825c2a6c
	if ctx.cr[6].eq {
	pc = 0x825C2A6C; continue 'dispatch;
	}
	// 825C2A54: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C2A58: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 825C2A5C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825C2A60: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825C2A64: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825C2A68: 4E800421  bctrl
	ctx.lr = 0x825C2A6C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x825C2A6C => {
    //   block [0x825C2A6C..0x825C2A80)
	// 825C2A6C: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C2A70: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 825C2A74: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 825C2A78: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825C2A7C: 4198FFCC  blt cr6, 0x825c2a48
	if ctx.cr[6].lt {
	pc = 0x825C2A48; continue 'dispatch;
	}
	pc = 0x825C2A80; continue 'dispatch;
            }
            0x825C2A80 => {
    //   block [0x825C2A80..0x825C2A94)
	// 825C2A80: 9B5F0002  stb r26, 2(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(2 as u32), ctx.r[26].u8 ) };
	// 825C2A84: 9B5F0000  stb r26, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u8 ) };
	// 825C2A88: 9B5F0001  stb r26, 1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1 as u32), ctx.r[26].u8 ) };
	// 825C2A8C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825C2A90: 4BF72670  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C2A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C2A98 size=64
    let mut pc: u32 = 0x825C2A98;
    'dispatch: loop {
        match pc {
            0x825C2A98 => {
    //   block [0x825C2A98..0x825C2AD8)
	// 825C2A98: 89440004  lbz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C2A9C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825C2AA0: 89040005  lbz r8, 5(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(5 as u32) ) } as u64;
	// 825C2AA4: 3921FFF0  addi r9, r1, -0x10
	ctx.r[9].s64 = ctx.r[1].s64 + -16;
	// 825C2AA8: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C2AD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C2AD8 size=40
    let mut pc: u32 = 0x825C2AD8;
    'dispatch: loop {
        match pc {
            0x825C2AD8 => {
    //   block [0x825C2AD8..0x825C2B00)
	// 825C2AD8: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 825C2ADC: 39000100  li r8, 0x100
	ctx.r[8].s64 = 256;
	// 825C2AE0: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 825C2AE4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C2B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C2B00 size=384
    let mut pc: u32 = 0x825C2B00;
    'dispatch: loop {
        match pc {
            0x825C2B00 => {
    //   block [0x825C2B00..0x825C2C80)
	// 825C2B00: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 825C2B04: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 825C2B08: 89640004  lbz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C2B0C: 39000100  li r8, 0x100
	ctx.r[8].s64 = 256;
	// 825C2B10: 89440005  lbz r10, 5(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(5 as u32) ) } as u64;
	// 825C2B14: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 825C2B18: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 825C2B1C: 89240006  lbz r9, 6(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(6 as u32) ) } as u64;
	// 825C2B20: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 825C2B24: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 825C2B28: 7D291A14  add r9, r9, r3
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[3].u64;
	// 825C2B2C: 38C1FFD0  addi r6, r1, -0x30
	ctx.r[6].s64 = ctx.r[1].s64 + -48;
	// 825C2B30: 3881FFD0  addi r4, r1, -0x30
	ctx.r[4].s64 = ctx.r[1].s64 + -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C2C80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C2C80 size=352
    let mut pc: u32 = 0x825C2C80;
    'dispatch: loop {
        match pc {
            0x825C2C80 => {
    //   block [0x825C2C80..0x825C2DE0)
	// 825C2C80: 89440004  lbz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C2C84: 39000100  li r8, 0x100
	ctx.r[8].s64 = 256;
	// 825C2C88: 89240005  lbz r9, 5(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(5 as u32) ) } as u64;
	// 825C2C8C: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 825C2C90: 89640006  lbz r11, 6(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(6 as u32) ) } as u64;
	// 825C2C94: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 825C2C98: 7D291A14  add r9, r9, r3
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[3].u64;
	// 825C2C9C: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 825C2CA0: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C2DE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C2DE0 size=8
    let mut pc: u32 = 0x825C2DE0;
    'dispatch: loop {
        match pc {
            0x825C2DE0 => {
    //   block [0x825C2DE0..0x825C2DE8)
	// 825C2DE0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825C2DE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C2DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C2DE8 size=2508
    let mut pc: u32 = 0x825C2DE8;
    'dispatch: loop {
        match pc {
            0x825C2DE8 => {
    //   block [0x825C2DE8..0x825C2E5C)
	// 825C2DE8: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 825C2DEC: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 825C2DF0: 89440000  lbz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C2DF4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825C2DF8: 89240001  lbz r9, 1(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C2DFC: 554A103E  rotlwi r10, r10, 2
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 825C2E00: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825C2E04: 2B0A000D  cmplwi cr6, r10, 0xd
	ctx.cr[6].compare_u32(ctx.r[10].u32, 13 as u32, &mut ctx.xer);
	// 825C2E08: 4199099C  bgt cr6, 0x825c37a4
	if ctx.cr[6].gt {
	pc = 0x825C37A4; continue 'dispatch;
	}
	// 825C2E0C: 3D80825C  lis r12, -0x7da4
	ctx.r[12].s64 = -2107899904;
	// 825C2E10: 398C2E24  addi r12, r12, 0x2e24
	ctx.r[12].s64 = ctx.r[12].s64 + 11812;
	// 825C2E14: 5540103A  slwi r0, r10, 2
	ctx.r[0].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 825C2E18: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 825C2E1C: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 825C2E20: 4E800420  bctr
	match ctx.r[10].u64 {
		0 => {
	pc = 0x825C37A4; continue 'dispatch;
		},
		1 => {
	pc = 0x825C37A4; continue 'dispatch;
		},
		2 => {
	pc = 0x825C37A4; continue 'dispatch;
		},
		3 => {
	pc = 0x825C37A4; continue 'dispatch;
		},
		4 => {
	pc = 0x825C37A4; continue 'dispatch;
		},
		5 => {
	pc = 0x825C2E5C; continue 'dispatch;
		},
		6 => {
	pc = 0x825C2EC0; continue 'dispatch;
		},
		7 => {
	pc = 0x825C302C; continue 'dispatch;
		},
		8 => {
	pc = 0x825C37A4; continue 'dispatch;
		},
		9 => {
	pc = 0x825C3228; continue 'dispatch;
		},
		10 => {
	pc = 0x825C3394; continue 'dispatch;
		},
		11 => {
	pc = 0x825C37A4; continue 'dispatch;
		},
		12 => {
	pc = 0x825C37A4; continue 'dispatch;
		},
		13 => {
	pc = 0x825C3598; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 825C2E24: 825C37A4  lwz r18, 0x37a4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(14244 as u32) ) } as u64;
	// 825C2E28: 825C37A4  lwz r18, 0x37a4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(14244 as u32) ) } as u64;
	// 825C2E2C: 825C37A4  lwz r18, 0x37a4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(14244 as u32) ) } as u64;
	// 825C2E30: 825C37A4  lwz r18, 0x37a4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(14244 as u32) ) } as u64;
	// 825C2E34: 825C37A4  lwz r18, 0x37a4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(14244 as u32) ) } as u64;
	// 825C2E38: 825C2E5C  lwz r18, 0x2e5c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(11868 as u32) ) } as u64;
	// 825C2E3C: 825C2EC0  lwz r18, 0x2ec0(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(11968 as u32) ) } as u64;
	// 825C2E40: 825C302C  lwz r18, 0x302c(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12332 as u32) ) } as u64;
	// 825C2E44: 825C37A4  lwz r18, 0x37a4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(14244 as u32) ) } as u64;
	// 825C2E48: 825C3228  lwz r18, 0x3228(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12840 as u32) ) } as u64;
	// 825C2E4C: 825C3394  lwz r18, 0x3394(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(13204 as u32) ) } as u64;
	// 825C2E50: 825C37A4  lwz r18, 0x37a4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(14244 as u32) ) } as u64;
	// 825C2E54: 825C37A4  lwz r18, 0x37a4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(14244 as u32) ) } as u64;
	// 825C2E58: 825C3598  lwz r18, 0x3598(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(13720 as u32) ) } as u64;
            }
            0x825C2E5C => {
    //   block [0x825C2E5C..0x825C2EC0)
	// 825C2E5C: 89440004  lbz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C2E60: 3921FFB0  addi r9, r1, -0x50
	ctx.r[9].s64 = ctx.r[1].s64 + -80;
	// 825C2E64: 89040005  lbz r8, 5(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(5 as u32) ) } as u64;
	// 825C2E68: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x825C2EC0; continue 'dispatch;
            }
            0x825C2EC0 => {
    //   block [0x825C2EC0..0x825C302C)
	// 825C2EC0: 89440004  lbz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C2EC4: 38E00100  li r7, 0x100
	ctx.r[7].s64 = 256;
	// 825C2EC8: 89240005  lbz r9, 5(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(5 as u32) ) } as u64;
	// 825C2ECC: 38C00020  li r6, 0x20
	ctx.r[6].s64 = 32;
	// 825C2ED0: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825C2ED4: 89040006  lbz r8, 6(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(6 as u32) ) } as u64;
	// 825C2ED8: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825C2EDC: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 825C2EE0: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 825C2EE4: 3881FFB0  addi r4, r1, -0x50
	ctx.r[4].s64 = ctx.r[1].s64 + -80;
	// 825C2EE8: 3861FFB0  addi r3, r1, -0x50
	ctx.r[3].s64 = ctx.r[1].s64 + -80;
	pc = 0x825C302C; continue 'dispatch;
            }
            0x825C302C => {
    //   block [0x825C302C..0x825C3228)
	// 825C302C: 89440004  lbz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C3030: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 825C3034: 89240005  lbz r9, 5(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(5 as u32) ) } as u64;
	// 825C3038: 3861FFB0  addi r3, r1, -0x50
	ctx.r[3].s64 = ctx.r[1].s64 + -80;
	// 825C303C: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825C3040: 89040006  lbz r8, 6(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(6 as u32) ) } as u64;
	// 825C3044: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825C3048: 88E40007  lbz r7, 7(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(7 as u32) ) } as u64;
	// 825C304C: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 825C3050: 7CE75A14  add r7, r7, r11
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	pc = 0x825C3228; continue 'dispatch;
            }
            0x825C3228 => {
    //   block [0x825C3228..0x825C3394)
	// 825C3228: 89240004  lbz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C322C: 38E00100  li r7, 0x100
	ctx.r[7].s64 = 256;
	// 825C3230: 89040005  lbz r8, 5(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(5 as u32) ) } as u64;
	// 825C3234: 38C00020  li r6, 0x20
	ctx.r[6].s64 = 32;
	// 825C3238: 89440006  lbz r10, 6(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(6 as u32) ) } as u64;
	// 825C323C: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825C3240: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 825C3244: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 825C3248: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x825C3394; continue 'dispatch;
            }
            0x825C3394 => {
    //   block [0x825C3394..0x825C3598)
	// 825C3394: 89440004  lbz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C3398: 38C00100  li r6, 0x100
	ctx.r[6].s64 = 256;
	// 825C339C: 89240005  lbz r9, 5(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(5 as u32) ) } as u64;
	// 825C33A0: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 825C33A4: 89040006  lbz r8, 6(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(6 as u32) ) } as u64;
	// 825C33A8: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825C33AC: 88E40007  lbz r7, 7(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(7 as u32) ) } as u64;
	// 825C33B0: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825C33B4: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 825C33B8: 7CE75A14  add r7, r7, r11
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	pc = 0x825C3598; continue 'dispatch;
            }
            0x825C3598 => {
    //   block [0x825C3598..0x825C37A4)
	// 825C3598: 89440007  lbz r10, 7(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(7 as u32) ) } as u64;
	// 825C359C: 39250010  addi r9, r5, 0x10
	ctx.r[9].s64 = ctx.r[5].s64 + 16;
	// 825C35A0: 89040004  lbz r8, 4(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C35A4: 3861FFB0  addi r3, r1, -0x50
	ctx.r[3].s64 = ctx.r[1].s64 + -80;
	// 825C35A8: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825C35AC: 88E40005  lbz r7, 5(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(5 as u32) ) } as u64;
	// 825C35B0: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 825C35B4: 88C40006  lbz r6, 6(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(6 as u32) ) } as u64;
	// 825C35B8: 7CE75A14  add r7, r7, r11
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 825C35BC: 7CC65A14  add r6, r6, r11
	ctx.r[6].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 825C35C0: 3881FFB0  addi r4, r1, -0x50
	ctx.r[4].s64 = ctx.r[1].s64 + -80;
	pc = 0x825C37A4; continue 'dispatch;
            }
            0x825C37A4 => {
    //   block [0x825C37A4..0x825C37B4)
	// 825C37A4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825C37A8: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825C37AC: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 825C37B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C37B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C37B8 size=432
    let mut pc: u32 = 0x825C37B8;
    'dispatch: loop {
        match pc {
            0x825C37B8 => {
    //   block [0x825C37B8..0x825C3968)
	// 825C37B8: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 825C37BC: 3961FFA0  addi r11, r1, -0x60
	ctx.r[11].s64 = ctx.r[1].s64 + -96;
	// 825C37C0: 88C30002  lbz r6, 2(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C37C4: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C3968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C3968 size=124
    let mut pc: u32 = 0x825C3968;
    'dispatch: loop {
        match pc {
            0x825C3968 => {
    //   block [0x825C3968..0x825C39C8)
	// 825C3968: 548A1838  slwi r10, r4, 3
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825C396C: 89630002  lbz r11, 2(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C3970: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 825C3974: 392A0004  addi r9, r10, 4
	ctx.r[9].s64 = ctx.r[10].s64 + 4;
	// 825C3978: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 825C397C: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 825C3980: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 825C3984: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 825C3988: 99430002  stb r10, 2(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(2 as u32), ctx.r[10].u8 ) };
	// 825C398C: 554B1838  slwi r11, r10, 3
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C3990: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 825C3994: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825C3998: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C399C: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825C39A0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C39A4: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825C39A8: 89430001  lbz r10, 1(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C39AC: 89230000  lbz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C39B0: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825C39B4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 825C39B8: 7D4A0E70  srawi r10, r10, 1
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 1) as i64;
	// 825C39BC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825C39C0: 41980020  blt cr6, 0x825c39e0
	if ctx.cr[6].lt {
	pc = 0x825C39E0; continue 'dispatch;
	}
	// 825C39C4: 7D2B4050  subf r9, r11, r8
	ctx.r[9].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	pc = 0x825C39C8; continue 'dispatch;
            }
            0x825C39C8 => {
    //   block [0x825C39C8..0x825C39E0)
	// 825C39C8: 7D09582E  lwzx r8, r9, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825C39CC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 825C39D0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825C39D4: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825C39D8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825C39DC: 4098FFEC  bge cr6, 0x825c39c8
	if !ctx.cr[6].lt {
	pc = 0x825C39C8; continue 'dispatch;
	}
	pc = 0x825C39E0; continue 'dispatch;
            }
            0x825C39E0 => {
    //   block [0x825C39E0..0x825C39E4)
	// 825C39E0: 4BFFFDD8  b 0x825c37b8
	sub_825C37B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C39E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C39E8 size=2588
    //   switch @ 0x825C3AE8: r11 with 14 label(s)
    //       case  0  0x825C4330
    //       case  1  0x825C4330
    //       case  2  0x825C4330
    //       case  3  0x825C4330
    //       case  4  0x825C4330
    //       case  5  0x825C3B24
    //       case  6  0x825C3B74
    //       case  7  0x825C3C9C
    //       case  8  0x825C4330
    //       case  9  0x825C3E30
    //       case 10  0x825C3F58
    //       case 11  0x825C4330
    //       case 12  0x825C4330
    //       case 13  0x825C4108
    let mut pc: u32 = 0x825C39E8;
    'dispatch: loop {
        match pc {
            0x825C39E8 => {
    //   block [0x825C39E8..0x825C3B24)
	// 825C39E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C39EC: 4BF7169D  bl 0x82535088
	ctx.lr = 0x825C39F0;
	sub_82535080(ctx, base);
	// 825C39F0: 3981FF78  addi r12, r1, -0x88
	ctx.r[12].s64 = ctx.r[1].s64 + -136;
	// 825C39F4: 4BF725F1  bl 0x82535fe4
	ctx.lr = 0x825C39F8;
	sub_82535FB0(ctx, base);
	// 825C39F8: 3980FF20  li r12, -0xe0
	ctx.r[12].s64 = -224;
	pc = 0x825C3B24; continue 'dispatch;
            }
            0x825C3B24 => {
    //   block [0x825C3B24..0x825C3B74)
	// 825C3B24: 897E0004  lbz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C3B28: 3941009C  addi r10, r1, 0x9c
	ctx.r[10].s64 = ctx.r[1].s64 + 156;
	// 825C3B2C: 893E0005  lbz r9, 5(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(5 as u32) ) } as u64;
	// 825C3B30: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	pc = 0x825C3B74; continue 'dispatch;
            }
            0x825C3B74 => {
    //   block [0x825C3B74..0x825C3C9C)
	// 825C3B74: 897E0004  lbz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C3B78: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 825C3B7C: 895E0005  lbz r10, 5(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(5 as u32) ) } as u64;
	// 825C3B80: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 825C3B84: 893E0006  lbz r9, 6(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) } as u64;
	// 825C3B88: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825C3B8C: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	pc = 0x825C3C9C; continue 'dispatch;
            }
            0x825C3C9C => {
    //   block [0x825C3C9C..0x825C3E30)
	// 825C3C9C: 897E0005  lbz r11, 5(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(5 as u32) ) } as u64;
	// 825C3CA0: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 825C3CA4: 895E0006  lbz r10, 6(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) } as u64;
	// 825C3CA8: 893E0007  lbz r9, 7(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(7 as u32) ) } as u64;
	// 825C3CAC: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825C3CB0: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 825C3CB4: 891E0004  lbz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C3CB8: 7D29FA14  add r9, r9, r31
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[31].u64;
	// 825C3CBC: 7D08FA14  add r8, r8, r31
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[31].u64;
	pc = 0x825C3E30; continue 'dispatch;
            }
            0x825C3E30 => {
    //   block [0x825C3E30..0x825C3F58)
	// 825C3E30: 897E0004  lbz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C3E34: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 825C3E38: 895E0005  lbz r10, 5(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(5 as u32) ) } as u64;
	// 825C3E3C: 39010078  addi r8, r1, 0x78
	ctx.r[8].s64 = ctx.r[1].s64 + 120;
	// 825C3E40: 893E0006  lbz r9, 6(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) } as u64;
	// 825C3E44: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825C3E48: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	pc = 0x825C3F58; continue 'dispatch;
            }
            0x825C3F58 => {
    //   block [0x825C3F58..0x825C4108)
	// 825C3F58: 897E0004  lbz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C3F5C: 38C10064  addi r6, r1, 0x64
	ctx.r[6].s64 = ctx.r[1].s64 + 100;
	// 825C3F60: 895E0005  lbz r10, 5(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(5 as u32) ) } as u64;
	// 825C3F64: 38A1006C  addi r5, r1, 0x6c
	ctx.r[5].s64 = ctx.r[1].s64 + 108;
	// 825C3F68: 893E0006  lbz r9, 6(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) } as u64;
	// 825C3F6C: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825C3F70: 891E0007  lbz r8, 7(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(7 as u32) ) } as u64;
	// 825C3F74: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 825C3F78: 7D29FA14  add r9, r9, r31
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[31].u64;
	pc = 0x825C4108; continue 'dispatch;
            }
            0x825C4108 => {
    //   block [0x825C4108..0x825C4330)
	// 825C4108: 897E0004  lbz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C410C: 38C10084  addi r6, r1, 0x84
	ctx.r[6].s64 = ctx.r[1].s64 + 132;
	// 825C4110: 893E0006  lbz r9, 6(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) } as u64;
	// 825C4114: 895E0005  lbz r10, 5(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(5 as u32) ) } as u64;
	// 825C4118: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825C411C: 7D29FA14  add r9, r9, r31
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[31].u64;
	// 825C4120: 891E0007  lbz r8, 7(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(7 as u32) ) } as u64;
	// 825C4124: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 825C4128: 7D08FA14  add r8, r8, r31
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[31].u64;
	pc = 0x825C4330; continue 'dispatch;
            }
            0x825C4330 => {
    //   block [0x825C4330..0x825C4404)
	// 825C4330: A09E0002  lhz r4, 2(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C4334: 2B04FFFF  cmplwi cr6, r4, 0xffff
	ctx.cr[6].compare_u32(ctx.r[4].u32, 65535 as u32, &mut ctx.xer);
	// 825C4338: 419A001C  beq cr6, 0x825c4354
	if ctx.cr[6].eq {
	pc = 0x825C4354; continue 'dispatch;
	}
	// 825C433C: 81720000  lwz r11, 0(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C4340: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 825C4344: 80B90004  lwz r5, 4(r25)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C4348: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825C434C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825C4350: 4E800421  bctrl
	ctx.lr = 0x825C4354;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825C4354: 3AF7FFF8  addi r23, r23, -8
	ctx.r[23].s64 = ctx.r[23].s64 + -8;
	// 825C4358: 3B18FFFF  addi r24, r24, -1
	ctx.r[24].s64 = ctx.r[24].s64 + -1;
	// 825C435C: 3AD6FFFF  addi r22, r22, -1
	ctx.r[22].s64 = ctx.r[22].s64 + -1;
	// 825C4360: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C4364: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825C4368: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C436C: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825C4370: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 825C4374: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	// 825C4378: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 825C437C: 7F16C040  cmplw cr6, r22, r24
	ctx.cr[6].compare_u32(ctx.r[22].u32, ctx.r[24].u32, &mut ctx.xer);
	// 825C4380: 4198F738  blt cr6, 0x825c3ab8
	if ctx.cr[6].lt {
	pc = 0x825C3AB8; continue 'dispatch;
	}
	// 825C4384: 7F15C040  cmplw cr6, r21, r24
	ctx.cr[6].compare_u32(ctx.r[21].u32, ctx.r[24].u32, &mut ctx.xer);
	// 825C4388: 40990054  ble cr6, 0x825c43dc
	if !ctx.cr[6].gt {
	pc = 0x825C43DC; continue 'dispatch;
	}
	// 825C438C: 893B0000  lbz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C4390: 570B1838  slwi r11, r24, 3
	ctx.r[11].u32 = ctx.r[24].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C4394: 895B0001  lbz r10, 1(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C4398: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 825C439C: 9B100000  stb r24, 0(r16)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[16].u32.wrapping_add(0 as u32), ctx.r[24].u8 ) };
	// 825C43A0: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825C43A4: 392AFFFF  addi r9, r10, -1
	ctx.r[9].s64 = ctx.r[10].s64 + -1;
	// 825C43A8: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 825C43AC: 7D2B0E70  srawi r11, r9, 1
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 1) as i64;
	// 825C43B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C43B4: 41980020  blt cr6, 0x825c43d4
	if ctx.cr[6].lt {
	pc = 0x825C43D4; continue 'dispatch;
	}
	// 825C43B8: 7D2A8850  subf r9, r10, r17
	ctx.r[9].s64 = ctx.r[17].s64 - ctx.r[10].s64;
	// 825C43BC: 7D09502E  lwzx r8, r9, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825C43C0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825C43C4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C43C8: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825C43CC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825C43D0: 4098FFEC  bge cr6, 0x825c43bc
	if !ctx.cr[6].lt {
	pc = 0x825C43BC; continue 'dispatch;
	}
	// 825C43D4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825C43D8: 4BFFF3E1  bl 0x825c37b8
	ctx.lr = 0x825C43DC;
	sub_825C37B8(ctx, base);
	// 825C43DC: 382102E0  addi r1, r1, 0x2e0
	ctx.r[1].s64 = ctx.r[1].s64 + 736;
	// 825C43E0: 3800FF20  li r0, -0xe0
	ctx.r[0].s64 = -224;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C4408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825C4408 size=904
    let mut pc: u32 = 0x825C4408;
    'dispatch: loop {
        match pc {
            0x825C4408 => {
    //   block [0x825C4408..0x825C4790)
	// 825C4408: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 825C440C: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 825C4410: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 825C4414: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825C4418: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825C441C: 38EB00C0  addi r7, r11, 0xc0
	ctx.r[7].s64 = ctx.r[11].s64 + 192;
	// 825C4420: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 825C4424: C12A1FF8  lfs f9, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 825C4428: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825C442C: FDA04890  fmr f13, f9
	ctx.f[13].f64 = ctx.f[9].f64;
	// 825C4430: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 825C4434: 9061FFD0  stw r3, -0x30(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[3].u32 ) };
	// 825C4438: 38A1FFC0  addi r5, r1, -0x40
	ctx.r[5].s64 = ctx.r[1].s64 + -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C4790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C4790 size=1204
    let mut pc: u32 = 0x825C4790;
    'dispatch: loop {
        match pc {
            0x825C4790 => {
    //   block [0x825C4790..0x825C47EC)
	// 825C4790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C4794: 4BF70909  bl 0x8253509c
	ctx.lr = 0x825C4798;
	sub_82535080(ctx, base);
	// 825C4798: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C479C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825C47A0: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 825C47A4: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 825C47A8: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 825C47AC: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 825C47B0: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C47B4: 7D154378  mr r21, r8
	ctx.r[21].u64 = ctx.r[8].u64;
	// 825C47B8: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 825C47BC: 7D565378  mr r22, r10
	ctx.r[22].u64 = ctx.r[10].u64;
	// 825C47C0: 3B600004  li r27, 4
	ctx.r[27].s64 = 4;
	// 825C47C4: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 825C47C8: 409A0194  bne cr6, 0x825c495c
	if !ctx.cr[6].eq {
	pc = 0x825C495C; continue 'dispatch;
	}
	// 825C47CC: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 825C47D0: 4BFFFC39  bl 0x825c4408
	ctx.lr = 0x825C47D4;
	sub_825C4408(ctx, base);
	// 825C47D4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825C47D8: 2F1A0004  cmpwi cr6, r26, 4
	ctx.cr[6].compare_i32(ctx.r[26].s32, 4, &mut ctx.xer);
	// 825C47DC: 409A0010  bne cr6, 0x825c47ec
	if !ctx.cr[6].eq {
	pc = 0x825C47EC; continue 'dispatch;
	}
	// 825C47E0: 38600005  li r3, 5
	ctx.r[3].s64 = 5;
	// 825C47E4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825C47E8: 4BF70904  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            0x825C47EC => {
    //   block [0x825C47EC..0x825C4824)
	// 825C47EC: 83A10104  lwz r29, 0x104(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 825C47F0: 574B1838  slwi r11, r26, 3
	ctx.r[11].u32 = ctx.r[26].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C47F4: 80BC0004  lwz r5, 4(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C47F8: 7F6BFA14  add r27, r11, r31
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825C47FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825C4800: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C4804: A09B0006  lhz r4, 6(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[27].u32.wrapping_add(6 as u32) ) } as u64;
	// 825C4808: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 825C480C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825C4810: 4E800421  bctrl
	ctx.lr = 0x825C4814;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825C4814: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 825C4818: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825C481C: 409A0008  bne cr6, 0x825c4824
	if !ctx.cr[6].eq {
	pc = 0x825C4824; continue 'dispatch;
	}
	// 825C4820: 397F000C  addi r11, r31, 0xc
	ctx.r[11].s64 = ctx.r[31].s64 + 12;
            }
            0x825C4824 => {
    //   block [0x825C4824..0x825C48D0)
	// 825C4824: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C4828: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C482C: 915B0004  stw r10, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825C4830: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C4834: 917B0008  stw r11, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825C4838: 4BFFEF81  bl 0x825c37b8
	ctx.lr = 0x825C483C;
	sub_825C37B8(ctx, base);
	// 825C483C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C4840: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 825C4844: 7EA8AB78  mr r8, r21
	ctx.r[8].u64 = ctx.r[21].u64;
	// 825C4848: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 825C484C: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 825C4850: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 825C4854: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825C4858: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825C485C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825C4860: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825C4864: 4E800421  bctrl
	ctx.lr = 0x825C4868;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825C4868: 546B043E  clrlwi r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 825C486C: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 825C4870: 409A00B4  bne cr6, 0x825c4924
	if !ctx.cr[6].eq {
	pc = 0x825C4924; continue 'dispatch;
	}
	// 825C4874: 391F001C  addi r8, r31, 0x1c
	ctx.r[8].s64 = ctx.r[31].s64 + 28;
	// 825C4878: 893F0000  lbz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C487C: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C4880: 38FF0004  addi r7, r31, 4
	ctx.r[7].s64 = ctx.r[31].s64 + 4;
	// 825C4884: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C4888: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825C488C: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C4890: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825C4894: 81080004  lwz r8, 4(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C4898: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825C489C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C48A0: 91270000  stw r9, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825C48A4: 392AFFFF  addi r9, r10, -1
	ctx.r[9].s64 = ctx.r[10].s64 + -1;
	// 825C48A8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825C48AC: 91070004  stw r8, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 825C48B0: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 825C48B4: 390A0004  addi r8, r10, 4
	ctx.r[8].s64 = ctx.r[10].s64 + 4;
	// 825C48B8: 993F0002  stb r9, 2(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(2 as u32), ctx.r[9].u8 ) };
	// 825C48BC: 552A1838  slwi r10, r9, 3
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825C48C0: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 825C48C4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825C48C8: 41980020  blt cr6, 0x825c48e8
	if ctx.cr[6].lt {
	pc = 0x825C48E8; continue 'dispatch;
	}
	// 825C48CC: 7D2A4050  subf r9, r10, r8
	ctx.r[9].s64 = ctx.r[8].s64 - ctx.r[10].s64;
            }
            0x825C48D0 => {
    //   block [0x825C48D0..0x825C48E8)
	// 825C48D0: 7D09502E  lwzx r8, r9, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825C48D4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825C48D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C48DC: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825C48E0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825C48E4: 4098FFEC  bge cr6, 0x825c48d0
	if !ctx.cr[6].lt {
	pc = 0x825C48D0; continue 'dispatch;
	}
	pc = 0x825C48E8; continue 'dispatch;
            }
            0x825C48E8 => {
    //   block [0x825C48E8..0x825C4924)
	// 825C48E8: 5749083C  slwi r9, r26, 1
	ctx.r[9].u32 = ctx.r[26].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825C48EC: 39760090  addi r11, r22, 0x90
	ctx.r[11].s64 = ctx.r[22].s64 + 144;
	// 825C48F0: 7D3A4A14  add r9, r26, r9
	ctx.r[9].u64 = ctx.r[26].u64 + ctx.r[9].u64;
	// 825C48F4: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 825C48F8: 55292036  slwi r9, r9, 4
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825C48FC: 38600006  li r3, 6
	ctx.r[3].s64 = 6;
	// 825C4900: 7D29B214  add r9, r9, r22
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[22].u64;
	pc = 0x825C4924; continue 'dispatch;
            }
            0x825C4924 => {
    //   block [0x825C4924..0x825C495C)
	// 825C4924: 917E0020  stw r11, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 825C4928: 574B083C  slwi r11, r26, 1
	ctx.r[11].u32 = ctx.r[26].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C492C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	pc = 0x825C495C; continue 'dispatch;
            }
            0x825C495C => {
    //   block [0x825C495C..0x825C4C44)
	// 825C495C: 8161010C  lwz r11, 0x10c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) } as u64;
	// 825C4960: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C4964: 419A0018  beq cr6, 0x825c497c
	if ctx.cr[6].eq {
	pc = 0x825C497C; continue 'dispatch;
	}
	// 825C4968: 89750009  lbz r11, 9(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[21].u32.wrapping_add(9 as u32) ) } as u64;
	// 825C496C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 825C4970: 419A000C  beq cr6, 0x825c497c
	if ctx.cr[6].eq {
	pc = 0x825C497C; continue 'dispatch;
	}
	// 825C4974: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 825C4978: 4800003C  b 0x825c49b4
	pc = 0x825C49B4; continue 'dispatch;
	// 825C497C: 80610104  lwz r3, 0x104(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 825C4980: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 825C4984: 7EA8AB78  mr r8, r21
	ctx.r[8].u64 = ctx.r[21].u64;
	// 825C4988: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 825C498C: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 825C4990: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 825C4994: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C4998: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825C499C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825C49A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825C49A4: 4E800421  bctrl
	ctx.lr = 0x825C49A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825C49A8: 546B043E  clrlwi r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 825C49AC: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 825C49B0: 419AFE30  beq cr6, 0x825c47e0
	if ctx.cr[6].eq {
	pc = 0x825C47E0; continue 'dispatch;
	}
	// 825C49B4: 546B043E  clrlwi r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 825C49B8: 917E0020  stw r11, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 825C49BC: 893F0000  lbz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C49C0: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C49C4: 895F0002  lbz r10, 2(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C49C8: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825C49CC: 38EA0001  addi r7, r10, 1
	ctx.r[7].s64 = ctx.r[10].s64 + 1;
	// 825C49D0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825C49D4: 5549083E  rotlwi r9, r10, 1
	ctx.r[9].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 825C49D8: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825C49DC: 54E8083C  slwi r8, r7, 1
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825C49E0: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825C49E4: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 825C49E8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825C49EC: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 825C49F0: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825C49F4: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825C49F8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C49FC: 7D29FA14  add r9, r9, r31
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[31].u64;
	// 825C4A00: 7D08FA14  add r8, r8, r31
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[31].u64;
	// 825C4A04: 41980020  blt cr6, 0x825c4a24
	if ctx.cr[6].lt {
	pc = 0x825C4A24; continue 'dispatch;
	}
	// 825C4A08: 80C90000  lwz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C4A0C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825C4A10: 3929FFFC  addi r9, r9, -4
	ctx.r[9].s64 = ctx.r[9].s64 + -4;
	// 825C4A14: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C4A18: 90C80000  stw r6, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 825C4A1C: 3908FFFC  addi r8, r8, -4
	ctx.r[8].s64 = ctx.r[8].s64 + -4;
	// 825C4A20: 4098FFE8  bge cr6, 0x825c4a08
	if !ctx.cr[6].lt {
	pc = 0x825C4A08; continue 'dispatch;
	}
	// 825C4A24: 393F0004  addi r9, r31, 4
	ctx.r[9].s64 = ctx.r[31].s64 + 4;
	// 825C4A28: 554B1838  slwi r11, r10, 3
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C4A2C: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825C4A30: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C4A34: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825C4A38: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825C4A3C: 81290004  lwz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C4A40: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825C4A44: 98FF0002  stb r7, 2(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(2 as u32), ctx.r[7].u8 ) };
	// 825C4A48: 89750008  lbz r11, 8(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C4A4C: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 825C4A50: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825C4A54: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825C4A58: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825C4A5C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825C4A60: 997D0000  stb r11, 0(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825C4A64: 89750009  lbz r11, 9(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[21].u32.wrapping_add(9 as u32) ) } as u64;
	// 825C4A68: B07D0002  sth r3, 2(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(2 as u32), ctx.r[3].u16 ) };
	// 825C4A6C: 915D0004  stw r10, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825C4A70: 997D0001  stb r11, 1(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 825C4A74: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C4A78: 89550008  lbz r10, 8(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C4A7C: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 825C4A80: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825C4A84: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825C4A88: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 825C4A8C: 419A0118  beq cr6, 0x825c4ba4
	if ctx.cr[6].eq {
	pc = 0x825C4BA4; continue 'dispatch;
	}
	// 825C4A90: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 825C4A94: 893F0000  lbz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C4A98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825C4A9C: A0E50000  lhz r7, 0(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C4AA0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825C4AA4: 419A002C  beq cr6, 0x825c4ad0
	if ctx.cr[6].eq {
	pc = 0x825C4AD0; continue 'dispatch;
	}
	// 825C4AA8: 54E8043E  clrlwi r8, r7, 0x10
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x0000FFFFu64;
	// 825C4AAC: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 825C4AB0: A38A0000  lhz r28, 0(r10)
	ctx.r[28].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C4AB4: 7F1C4040  cmplw cr6, r28, r8
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825C4AB8: 419A0064  beq cr6, 0x825c4b1c
	if ctx.cr[6].eq {
	pc = 0x825C4B1C; continue 'dispatch;
	}
	// 825C4ABC: 8B9F0000  lbz r28, 0(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C4AC0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825C4AC4: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 825C4AC8: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825C4ACC: 4198FFE4  blt cr6, 0x825c4ab0
	if ctx.cr[6].lt {
	pc = 0x825C4AB0; continue 'dispatch;
	}
	// 825C4AD0: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C4AD4: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825C4AD8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825C4ADC: 40990028  ble cr6, 0x825c4b04
	if !ctx.cr[6].gt {
	pc = 0x825C4B04; continue 'dispatch;
	}
	// 825C4AE0: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825C4AE4: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825C4AE8: 7D481A14  add r10, r8, r3
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[3].u64;
	// 825C4AEC: A10AFFFE  lhz r8, -2(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(-2 as u32) ) } as u64;
	// 825C4AF0: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 825C4AF4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825C4AF8: B10A0000  sth r8, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 825C4AFC: 394AFFFE  addi r10, r10, -2
	ctx.r[10].s64 = ctx.r[10].s64 + -2;
	// 825C4B00: 409AFFEC  bne cr6, 0x825c4aec
	if !ctx.cr[6].eq {
	pc = 0x825C4AEC; continue 'dispatch;
	}
	// 825C4B04: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825C4B08: 38840010  addi r4, r4, 0x10
	ctx.r[4].s64 = ctx.r[4].s64 + 16;
	// 825C4B0C: 7CEA1B2E  sthx r7, r10, r3
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[3].u32), ctx.r[7].u16) };
	// 825C4B10: 895F0000  lbz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C4B14: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825C4B18: 995F0000  stb r10, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 825C4B1C: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C4B20: 38A50002  addi r5, r5, 2
	ctx.r[5].s64 = ctx.r[5].s64 + 2;
	// 825C4B24: 7D7E31AE  stbx r11, r30, r6
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[6].u32), ctx.r[11].u8) };
	// 825C4B28: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 825C4B2C: 89750008  lbz r11, 8(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C4B30: 7F065800  cmpw cr6, r6, r11
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825C4B34: 4198FF60  blt cr6, 0x825c4a94
	if ctx.cr[6].lt {
	pc = 0x825C4A94; continue 'dispatch;
	}
	// 825C4B38: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 825C4B3C: 419A0068  beq cr6, 0x825c4ba4
	if ctx.cr[6].eq {
	pc = 0x825C4BA4; continue 'dispatch;
	}
	// 825C4B40: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C4B44: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 825C4B48: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825C4B4C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 825C4B50: 40990054  ble cr6, 0x825c4ba4
	if !ctx.cr[6].gt {
	pc = 0x825C4BA4; continue 'dispatch;
	}
	// 825C4B54: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C4B58: 892A0001  lbz r9, 1(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C4B5C: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825C4B60: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825C4B64: 4098002C  bge cr6, 0x825c4b90
	if !ctx.cr[6].lt {
	pc = 0x825C4B90; continue 'dispatch;
	}
	// 825C4B68: 392A0004  addi r9, r10, 4
	ctx.r[9].s64 = ctx.r[10].s64 + 4;
	// 825C4B6C: 7D0958AE  lbzx r8, r9, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825C4B70: 7D082214  add r8, r8, r4
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[4].u64;
	// 825C4B74: 7D0959AE  stbx r8, r9, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[8].u8) };
	// 825C4B78: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825C4B7C: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C4B80: 88EA0001  lbz r7, 1(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C4B84: 7D083A14  add r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 825C4B88: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825C4B8C: 4198FFE0  blt cr6, 0x825c4b6c
	if ctx.cr[6].lt {
	pc = 0x825C4B6C; continue 'dispatch;
	}
	// 825C4B90: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C4B94: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 825C4B98: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825C4B9C: 7F065840  cmplw cr6, r6, r11
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825C4BA0: 4198FFB4  blt cr6, 0x825c4b54
	if ctx.cr[6].lt {
	pc = 0x825C4B54; continue 'dispatch;
	}
	// 825C4BA4: 89750009  lbz r11, 9(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[21].u32.wrapping_add(9 as u32) ) } as u64;
	// 825C4BA8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825C4BAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C4BB0: 419A0088  beq cr6, 0x825c4c38
	if ctx.cr[6].eq {
	pc = 0x825C4C38; continue 'dispatch;
	}
	// 825C4BB4: 89350008  lbz r9, 8(r21)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C4BB8: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C4BBC: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 825C4BC0: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C4BC4: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825C4BC8: 7CE9AA2E  lhzx r7, r9, r21
	ctx.r[7].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[21].u32)) } as u64;
	// 825C4BCC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825C4BD0: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825C4BD4: 4098002C  bge cr6, 0x825c4c00
	if !ctx.cr[6].lt {
	pc = 0x825C4C00; continue 'dispatch;
	}
	// 825C4BD8: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825C4BDC: 54E6043E  clrlwi r6, r7, 0x10
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000FFFFu64;
	// 825C4BE0: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 825C4BE4: A0AA0000  lhz r5, 0(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C4BE8: 7F053040  cmplw cr6, r5, r6
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825C4BEC: 419A0028  beq cr6, 0x825c4c14
	if ctx.cr[6].eq {
	pc = 0x825C4C14; continue 'dispatch;
	}
	// 825C4BF0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825C4BF4: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 825C4BF8: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825C4BFC: 4198FFE8  blt cr6, 0x825c4be4
	if ctx.cr[6].lt {
	pc = 0x825C4BE4; continue 'dispatch;
	}
	// 825C4C00: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825C4C04: 7CEA1B2E  sthx r7, r10, r3
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[3].u32), ctx.r[7].u16) };
	// 825C4C08: 895F0001  lbz r10, 1(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 825C4C0C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825C4C10: 995F0001  stb r10, 1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1 as u32), ctx.r[10].u8 ) };
	// 825C4C14: 89550008  lbz r10, 8(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C4C18: 55692036  slwi r9, r11, 4
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825C4C1C: 7D6A4214  add r11, r10, r8
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 825C4C20: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 825C4C24: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 825C4C28: 992B0004  stb r9, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u8 ) };
	// 825C4C2C: 89750009  lbz r11, 9(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[21].u32.wrapping_add(9 as u32) ) } as u64;
	// 825C4C30: 7F085800  cmpw cr6, r8, r11
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825C4C34: 4198FF80  blt cr6, 0x825c4bb4
	if ctx.cr[6].lt {
	pc = 0x825C4BB4; continue 'dispatch;
	}
	// 825C4C38: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825C4C3C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825C4C40: 4BF704AC  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C4C48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C4C48 size=488
    let mut pc: u32 = 0x825C4C48;
    'dispatch: loop {
        match pc {
            0x825C4C48 => {
    //   block [0x825C4C48..0x825C4E30)
	// 825C4C48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C4C4C: 4BF70461  bl 0x825350ac
	ctx.lr = 0x825C4C50;
	sub_82535080(ctx, base);
	// 825C4C50: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C4E30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C4E30 size=540
    let mut pc: u32 = 0x825C4E30;
    'dispatch: loop {
        match pc {
            0x825C4E30 => {
    //   block [0x825C4E30..0x825C504C)
	// 825C4E30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C4E34: 4BF70269  bl 0x8253509c
	ctx.lr = 0x825C4E38;
	sub_82535080(ctx, base);
	// 825C4E38: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C5050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C5050 size=4
    let mut pc: u32 = 0x825C5050;
    'dispatch: loop {
        match pc {
            0x825C5050 => {
    //   block [0x825C5050..0x825C5054)
	// 825C5050: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C5058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C5058 size=4
    let mut pc: u32 = 0x825C5058;
    'dispatch: loop {
        match pc {
            0x825C5058 => {
    //   block [0x825C5058..0x825C505C)
	// 825C5058: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C5060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C5060 size=44
    let mut pc: u32 = 0x825C5060;
    'dispatch: loop {
        match pc {
            0x825C5060 => {
    //   block [0x825C5060..0x825C508C)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C5090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C5090 size=4
    let mut pc: u32 = 0x825C5090;
    'dispatch: loop {
        match pc {
            0x825C5090 => {
    //   block [0x825C5090..0x825C5094)
	// 825C5090: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C5098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C5098 size=32
    let mut pc: u32 = 0x825C5098;
    'dispatch: loop {
        match pc {
            0x825C5098 => {
    //   block [0x825C5098..0x825C50B8)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C50B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825C50B8 size=352
    let mut pc: u32 = 0x825C50B8;
    'dispatch: loop {
        match pc {
            0x825C50B8 => {
    //   block [0x825C50B8..0x825C51A4)
	// 825C50B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C50BC: 4BF6FFE9  bl 0x825350a4
	ctx.lr = 0x825C50C0;
	sub_82535080(ctx, base);
	// 825C50C0: DBC1FFA0  stfd f30, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[30].u64 ) };
	// 825C50C4: DBE1FFA8  stfd f31, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 825C50C8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C50CC: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 825C50D0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 825C50D4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825C50D8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825C50DC: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 825C50E0: C3C92074  lfs f30, 0x2074(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8308 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825C50E4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825C50E8: C3EA1FF8  lfs f31, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825C50EC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825C50F0: 7FD9F378  mr r25, r30
	ctx.r[25].u64 = ctx.r[30].u64;
	// 825C50F4: 3B4BA430  addi r26, r11, -0x5bd0
	ctx.r[26].s64 = ctx.r[11].s64 + -23504;
	// 825C50F8: 3AE00030  li r23, 0x30
	ctx.r[23].s64 = 48;
	// 825C50FC: 7D7BD214  add r11, r27, r26
	ctx.r[11].u64 = ctx.r[27].u64 + ctx.r[26].u64;
	// 825C5100: 894B0002  lbz r10, 2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 825C5104: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C5108: 7D4B0774  extsb r11, r10
	ctx.r[11].s64 = ctx.r[10].s8 as i64;
	// 825C510C: 7D2A0774  extsb r10, r9
	ctx.r[10].s64 = ctx.r[9].s8 as i64;
	// 825C5110: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825C5114: 7FE9EA14  add r31, r9, r29
	ctx.r[31].u64 = ctx.r[9].u64 + ctx.r[29].u64;
	// 825C5118: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C511C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 825C5120: 41980084  blt cr6, 0x825c51a4
	if ctx.cr[6].lt {
	pc = 0x825C51A4; continue 'dispatch;
	}
	// 825C5124: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825C5128: 7F89EA14  add r28, r9, r29
	ctx.r[28].u64 = ctx.r[9].u64 + ctx.r[29].u64;
	// 825C512C: C01C0000  lfs f0, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C5130: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 825C5134: 41980070  blt cr6, 0x825c51a4
	if ctx.cr[6].lt {
	pc = 0x825C51A4; continue 'dispatch;
	}
	// 825C5138: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	pc = 0x825C51A4; continue 'dispatch;
            }
            0x825C51A4 => {
    //   block [0x825C51A4..0x825C5218)
	// 825C51A4: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 825C51A8: 3B390010  addi r25, r25, 0x10
	ctx.r[25].s64 = ctx.r[25].s64 + 16;
	// 825C51AC: 2F1B0003  cmpwi cr6, r27, 3
	ctx.cr[6].compare_i32(ctx.r[27].s32, 3, &mut ctx.xer);
	// 825C51B0: 4198FF4C  blt cr6, 0x825c50fc
	if ctx.cr[6].lt {
	pc = 0x825C50FC; continue 'dispatch;
	}
	// 825C51B4: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C51B8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 825C51BC: 40990018  ble cr6, 0x825c51d4
	if !ctx.cr[6].gt {
	pc = 0x825C51D4; continue 'dispatch;
	}
	// 825C51C0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825C51C4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825C51C8: CBC1FFA0  lfd f30, -0x60(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 825C51CC: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 825C51D0: 4BF6FF24  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
	// 825C51D4: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C51D8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 825C51DC: 40990018  ble cr6, 0x825c51f4
	if !ctx.cr[6].gt {
	pc = 0x825C51F4; continue 'dispatch;
	}
	// 825C51E0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825C51E4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825C51E8: CBC1FFA0  lfd f30, -0x60(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 825C51EC: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 825C51F0: 4BF6FF04  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
	// 825C51F4: C01D0008  lfs f0, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C51F8: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 825C51FC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 825C5200: 41990008  bgt cr6, 0x825c5208
	if ctx.cr[6].gt {
	pc = 0x825C5208; continue 'dispatch;
	}
	// 825C5204: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 825C5208: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825C520C: CBC1FFA0  lfd f30, -0x60(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 825C5210: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 825C5214: 4BF6FEE0  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C5218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C5218 size=560
    let mut pc: u32 = 0x825C5218;
    'dispatch: loop {
        match pc {
            0x825C5218 => {
    //   block [0x825C5218..0x825C5448)
	// 825C5218: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C521C: 4BF6FEA1  bl 0x825350bc
	ctx.lr = 0x825C5220;
	sub_82535080(ctx, base);
	// 825C5220: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C5448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825C5448 size=576
    let mut pc: u32 = 0x825C5448;
    'dispatch: loop {
        match pc {
            0x825C5448 => {
    //   block [0x825C5448..0x825C5688)
	// 825C5448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C544C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825C5450: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C5454: 38E100F4  addi r7, r1, 0xf4
	ctx.r[7].s64 = ctx.r[1].s64 + 244;
	// 825C5458: D02100F4  stfs f1, 0xf4(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 825C545C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C5688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C5688 size=172
    let mut pc: u32 = 0x825C5688;
    'dispatch: loop {
        match pc {
            0x825C5688 => {
    //   block [0x825C5688..0x825C5734)
	// 825C5688: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C5738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C5738 size=372
    let mut pc: u32 = 0x825C5738;
    'dispatch: loop {
        match pc {
            0x825C5738 => {
    //   block [0x825C5738..0x825C58AC)
	// 825C5738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C573C: 4BF6F979  bl 0x825350b4
	ctx.lr = 0x825C5740;
	sub_82535080(ctx, base);
	// 825C5740: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C5744: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825C5748: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 825C574C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825C5750: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825C5754: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C58B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C58B0 size=1100
    let mut pc: u32 = 0x825C58B0;
    'dispatch: loop {
        match pc {
            0x825C58B0 => {
    //   block [0x825C58B0..0x825C5940)
	// 825C58B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C58B4: 4BF6F801  bl 0x825350b4
	ctx.lr = 0x825C58B8;
	sub_82535080(ctx, base);
	// 825C58B8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C58BC: 54AB1838  slwi r11, r5, 3
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C58C0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825C58C4: 7D6B3378  or r11, r11, r6
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[6].u64;
	// 825C58C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825C58CC: 394BFFF7  addi r10, r11, -9
	ctx.r[10].s64 = ctx.r[11].s64 + -9;
	// 825C58D0: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 825C58D4: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 825C58D8: 7D3F4B78  mr r31, r9
	ctx.r[31].u64 = ctx.r[9].u64;
	// 825C58DC: 2B0A0010  cmplwi cr6, r10, 0x10
	ctx.cr[6].compare_u32(ctx.r[10].u32, 16 as u32, &mut ctx.xer);
	// 825C58E0: 41990414  bgt cr6, 0x825c5cf4
	if ctx.cr[6].gt {
	pc = 0x825C5CF4; continue 'dispatch;
	}
	// 825C58E4: 3D80825C  lis r12, -0x7da4
	ctx.r[12].s64 = -2107899904;
	// 825C58E8: 398C58FC  addi r12, r12, 0x58fc
	ctx.r[12].s64 = ctx.r[12].s64 + 22780;
	// 825C58EC: 5540103A  slwi r0, r10, 2
	ctx.r[0].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 825C58F0: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 825C58F4: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 825C58F8: 4E800420  bctr
	match ctx.r[10].u64 {
		0 => {
	pc = 0x825C5940; continue 'dispatch;
		},
		1 => {
	pc = 0x825C5A08; continue 'dispatch;
		},
		2 => {
	pc = 0x825C5AA0; continue 'dispatch;
		},
		3 => {
	pc = 0x825C5CF4; continue 'dispatch;
		},
		4 => {
	pc = 0x825C5CF4; continue 'dispatch;
		},
		5 => {
	pc = 0x825C5CF4; continue 'dispatch;
		},
		6 => {
	pc = 0x825C5CF4; continue 'dispatch;
		},
		7 => {
	pc = 0x825C5CF4; continue 'dispatch;
		},
		8 => {
	pc = 0x825C5A40; continue 'dispatch;
		},
		9 => {
	pc = 0x825C5BA0; continue 'dispatch;
		},
		10 => {
	pc = 0x825C5CF4; continue 'dispatch;
		},
		11 => {
	pc = 0x825C5CF4; continue 'dispatch;
		},
		12 => {
	pc = 0x825C5CF4; continue 'dispatch;
		},
		13 => {
	pc = 0x825C5CF4; continue 'dispatch;
		},
		14 => {
	pc = 0x825C5CF4; continue 'dispatch;
		},
		15 => {
	pc = 0x825C5CF4; continue 'dispatch;
		},
		16 => {
	pc = 0x825C5A94; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 825C58FC: 825C5940  lwz r18, 0x5940(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(22848 as u32) ) } as u64;
	// 825C5900: 825C5A08  lwz r18, 0x5a08(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(23048 as u32) ) } as u64;
	// 825C5904: 825C5AA0  lwz r18, 0x5aa0(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(23200 as u32) ) } as u64;
	// 825C5908: 825C5CF4  lwz r18, 0x5cf4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(23796 as u32) ) } as u64;
	// 825C590C: 825C5CF4  lwz r18, 0x5cf4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(23796 as u32) ) } as u64;
	// 825C5910: 825C5CF4  lwz r18, 0x5cf4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(23796 as u32) ) } as u64;
	// 825C5914: 825C5CF4  lwz r18, 0x5cf4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(23796 as u32) ) } as u64;
	// 825C5918: 825C5CF4  lwz r18, 0x5cf4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(23796 as u32) ) } as u64;
	// 825C591C: 825C5A40  lwz r18, 0x5a40(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(23104 as u32) ) } as u64;
	// 825C5920: 825C5BA0  lwz r18, 0x5ba0(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(23456 as u32) ) } as u64;
	// 825C5924: 825C5CF4  lwz r18, 0x5cf4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(23796 as u32) ) } as u64;
	// 825C5928: 825C5CF4  lwz r18, 0x5cf4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(23796 as u32) ) } as u64;
	// 825C592C: 825C5CF4  lwz r18, 0x5cf4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(23796 as u32) ) } as u64;
	// 825C5930: 825C5CF4  lwz r18, 0x5cf4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(23796 as u32) ) } as u64;
	// 825C5934: 825C5CF4  lwz r18, 0x5cf4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(23796 as u32) ) } as u64;
	// 825C5938: 825C5CF4  lwz r18, 0x5cf4(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(23796 as u32) ) } as u64;
	// 825C593C: 825C5A94  lwz r18, 0x5a94(r28)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(23188 as u32) ) } as u64;
            }
            0x825C5940 => {
    //   block [0x825C5940..0x825C5A08)
	pc = 0x825C5A08; continue 'dispatch;
            }
            0x825C5A08 => {
    //   block [0x825C5A08..0x825C5A40)
	pc = 0x825C5A40; continue 'dispatch;
            }
            0x825C5A40 => {
    //   block [0x825C5A40..0x825C5A94)
	pc = 0x825C5A94; continue 'dispatch;
            }
            0x825C5A94 => {
    //   block [0x825C5A94..0x825C5AA0)
	// 825C5A94: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 825C5A98: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 825C5A9C: 7D5E5378  mr r30, r10
	ctx.r[30].u64 = ctx.r[10].u64;
	pc = 0x825C5AA0; continue 'dispatch;
            }
            0x825C5AA0 => {
    //   block [0x825C5AA0..0x825C5BA0)
	// 825C5AA0: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	pc = 0x825C5BA0; continue 'dispatch;
            }
            0x825C5BA0 => {
    //   block [0x825C5BA0..0x825C5CF4)
	// 825C5BA0: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	pc = 0x825C5CF4; continue 'dispatch;
            }
            0x825C5CF4 => {
    //   block [0x825C5CF4..0x825C5CFC)
	// 825C5CF4: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825C5CF8: 4BF6F40C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C5D00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C5D00 size=196
    let mut pc: u32 = 0x825C5D00;
    'dispatch: loop {
        match pc {
            0x825C5D00 => {
    //   block [0x825C5D00..0x825C5DC4)
	// 825C5D00: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C5DC4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C5DC4 size=36
    let mut pc: u32 = 0x825C5DC4;
    'dispatch: loop {
        match pc {
            0x825C5DC4 => {
    //   block [0x825C5DC4..0x825C5DE8)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C5DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C5DE8 size=64
    let mut pc: u32 = 0x825C5DE8;
    'dispatch: loop {
        match pc {
            0x825C5DE8 => {
    //   block [0x825C5DE8..0x825C5E04)
	// 825C5DE8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825C5DEC: 419A0018  beq cr6, 0x825c5e04
	if ctx.cr[6].eq {
	pc = 0x825C5E04; continue 'dispatch;
	}
	// 825C5DF0: 39600050  li r11, 0x50
	ctx.r[11].s64 = 80;
	pc = 0x825C5E04; continue 'dispatch;
            }
            0x825C5E04 => {
    //   block [0x825C5E04..0x825C5E28)
	// 825C5E04: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C5E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C5E28 size=12
    let mut pc: u32 = 0x825C5E28;
    'dispatch: loop {
        match pc {
            0x825C5E28 => {
    //   block [0x825C5E28..0x825C5E34)
	// 825C5E28: 1000584A  vsubfp v0, v0, v11
	ctx.fpscr.enable_flush_mode_unconditional();
	for i in 0..4 {
		ctx.v[0].f32[i] = ctx.v[0].f32[i] - ctx.v[11].f32[i];
	}
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C5E38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C5E38 size=1156
    let mut pc: u32 = 0x825C5E38;
    'dispatch: loop {
        match pc {
            0x825C5E38 => {
    //   block [0x825C5E38..0x825C62BC)
	// 825C5E38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C5E3C: 4BF6F26D  bl 0x825350a8
	ctx.lr = 0x825C5E40;
	sub_82535080(ctx, base);
	// 825C5E40: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C5E44: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825C5E48: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825C5E4C: 3BBF0010  addi r29, r31, 0x10
	ctx.r[29].s64 = ctx.r[31].s64 + 16;
	// 825C5E50: 7D0B0774  extsb r11, r8
	ctx.r[11].s64 = ctx.r[8].s8 as i64;
	// 825C5E54: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C62C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C62C0 size=332
    let mut pc: u32 = 0x825C62C0;
    'dispatch: loop {
        match pc {
            0x825C62C0 => {
    //   block [0x825C62C0..0x825C630C)
	// 825C62C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C62C4: 99640008  stb r11, 8(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u8 ) };
	// 825C62C8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C62CC: 99640009  stb r11, 9(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(9 as u32), ctx.r[11].u8 ) };
	// 825C62D0: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C62D4: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 825C62D8: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 825C62DC: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 825C62E0: 41980078  blt cr6, 0x825c6358
	if ctx.cr[6].lt {
	pc = 0x825C6358; continue 'dispatch;
	}
	// 825C62E4: 8143003C  lwz r10, 0x3c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 825C62E8: 5566043E  clrlwi r6, r11, 0x10
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 825C62EC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825C62F0: 5549043E  clrlwi r9, r10, 0x10
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 825C62F4: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 825C62F8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825C62FC: 40990010  ble cr6, 0x825c630c
	if !ctx.cr[6].gt {
	pc = 0x825C630C; continue 'dispatch;
	}
	// 825C6300: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 825C6304: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825C6308: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x825C630C; continue 'dispatch;
            }
            0x825C630C => {
    //   block [0x825C630C..0x825C633C)
	// 825C630C: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 825C6310: 40990044  ble cr6, 0x825c6354
	if !ctx.cr[6].gt {
	pc = 0x825C6354; continue 'dispatch;
	}
	// 825C6314: 8143004C  lwz r10, 0x4c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 825C6318: 5567043E  clrlwi r7, r11, 0x10
	ctx.r[7].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 825C631C: 554A043E  clrlwi r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 825C6320: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 825C6324: 7F063840  cmplw cr6, r6, r7
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825C6328: 40990014  ble cr6, 0x825c633c
	if !ctx.cr[6].gt {
	pc = 0x825C633C; continue 'dispatch;
	}
	// 825C632C: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 825C6330: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825C6334: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 825C6338: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	pc = 0x825C633C; continue 'dispatch;
            }
            0x825C633C => {
    //   block [0x825C633C..0x825C6350)
	// 825C633C: 2F080001  cmpwi cr6, r8, 1
	ctx.cr[6].compare_i32(ctx.r[8].s32, 1, &mut ctx.xer);
	// 825C6340: 409A0010  bne cr6, 0x825c6350
	if !ctx.cr[6].eq {
	pc = 0x825C6350; continue 'dispatch;
	}
	// 825C6344: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 825C6348: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 825C634C: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	pc = 0x825C6350; continue 'dispatch;
            }
            0x825C6350 => {
    //   block [0x825C6350..0x825C6354)
	// 825C6350: B1440004  sth r10, 4(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[10].u16 ) };
	pc = 0x825C6354; continue 'dispatch;
            }
            0x825C6354 => {
    //   block [0x825C6354..0x825C6358)
	// 825C6354: B1240002  sth r9, 2(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(2 as u32), ctx.r[9].u16 ) };
	pc = 0x825C6358; continue 'dispatch;
            }
            0x825C6358 => {
    //   block [0x825C6358..0x825C6398)
	// 825C6358: B1640000  sth r11, 0(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 825C635C: 80E30004  lwz r7, 4(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C6360: 816300EC  lwz r11, 0xec(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(236 as u32) ) } as u64;
	// 825C6364: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 825C6368: 556A043E  clrlwi r10, r11, 0x10
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 825C636C: 41980090  blt cr6, 0x825c63fc
	if ctx.cr[6].lt {
	pc = 0x825C63FC; continue 'dispatch;
	}
	// 825C6370: 816300FC  lwz r11, 0xfc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(252 as u32) ) } as u64;
	// 825C6374: 5546043E  clrlwi r6, r10, 0x10
	ctx.r[6].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 825C6378: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825C637C: 5569043E  clrlwi r9, r11, 0x10
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 825C6380: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 825C6384: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825C6388: 40990010  ble cr6, 0x825c6398
	if !ctx.cr[6].gt {
	pc = 0x825C6398; continue 'dispatch;
	}
	// 825C638C: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 825C6390: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825C6394: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x825C6398; continue 'dispatch;
            }
            0x825C6398 => {
    //   block [0x825C6398..0x825C63C8)
	// 825C6398: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 825C639C: 40990050  ble cr6, 0x825c63ec
	if !ctx.cr[6].gt {
	pc = 0x825C63EC; continue 'dispatch;
	}
	// 825C63A0: 8163010C  lwz r11, 0x10c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 825C63A4: 5547043E  clrlwi r7, r10, 0x10
	ctx.r[7].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 825C63A8: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 825C63AC: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 825C63B0: 7F063840  cmplw cr6, r6, r7
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825C63B4: 40990014  ble cr6, 0x825c63c8
	if !ctx.cr[6].gt {
	pc = 0x825C63C8; continue 'dispatch;
	}
	// 825C63B8: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 825C63BC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 825C63C0: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 825C63C4: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	pc = 0x825C63C8; continue 'dispatch;
            }
            0x825C63C8 => {
    //   block [0x825C63C8..0x825C63DC)
	// 825C63C8: 2F080001  cmpwi cr6, r8, 1
	ctx.cr[6].compare_i32(ctx.r[8].s32, 1, &mut ctx.xer);
	// 825C63CC: 409A0010  bne cr6, 0x825c63dc
	if !ctx.cr[6].eq {
	pc = 0x825C63DC; continue 'dispatch;
	}
	// 825C63D0: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 825C63D4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 825C63D8: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	pc = 0x825C63DC; continue 'dispatch;
            }
            0x825C63DC => {
    //   block [0x825C63DC..0x825C63EC)
	// 825C63DC: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C63E0: 39080002  addi r8, r8, 2
	ctx.r[8].s64 = ctx.r[8].s64 + 2;
	// 825C63E4: 5508083C  slwi r8, r8, 1
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825C63E8: 7D68232E  sthx r11, r8, r4
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[4].u32), ctx.r[11].u16) };
	pc = 0x825C63EC; continue 'dispatch;
            }
            0x825C63EC => {
    //   block [0x825C63EC..0x825C63FC)
	// 825C63EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C63F0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825C63F4: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C63F8: 7D2B232E  sthx r9, r11, r4
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32), ctx.r[9].u16) };
	pc = 0x825C63FC; continue 'dispatch;
            }
            0x825C63FC => {
    //   block [0x825C63FC..0x825C640C)
	// 825C63FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C6400: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C6404: 7D4B232E  sthx r10, r11, r4
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32), ctx.r[10].u16) };
	// 825C6408: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C6410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825C6410 size=48
    let mut pc: u32 = 0x825C6410;
    'dispatch: loop {
        match pc {
            0x825C6410 => {
    //   block [0x825C6410..0x825C6440)
	// 825C6410: C004000C  lfs f0, 0xc(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C6414: D0050020  stfs f0, 0x20(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(32 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C6440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C6440 size=48
    let mut pc: u32 = 0x825C6440;
    'dispatch: loop {
        match pc {
            0x825C6440 => {
    //   block [0x825C6440..0x825C6470)
	// 825C6440: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C6444: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825C6448: 409A0028  bne cr6, 0x825c6470
	if !ctx.cr[6].eq {
		sub_825C6470(ctx, base);
		return;
	}
	// 825C644C: 396000A0  li r11, 0xa0
	ctx.r[11].s64 = 160;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C6470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C6470 size=20
    let mut pc: u32 = 0x825C6470;
    'dispatch: loop {
        match pc {
            0x825C6470 => {
    //   block [0x825C6470..0x825C6484)
	// 825C6470: 39600130  li r11, 0x130
	ctx.r[11].s64 = 304;
	// 825C6474: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C6488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825C6488 size=680
    let mut pc: u32 = 0x825C6488;
    'dispatch: loop {
        match pc {
            0x825C6488 => {
    //   block [0x825C6488..0x825C64C4)
	// 825C6488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C648C: 4BF6EC11  bl 0x8253509c
	ctx.lr = 0x825C6490;
	sub_82535080(ctx, base);
	// 825C6490: DBE1FF98  stfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 825C6494: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C6498: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825C649C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C64A0: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 825C64A4: 409A004C  bne cr6, 0x825c64f0
	if !ctx.cr[6].eq {
	pc = 0x825C64F0; continue 'dispatch;
	}
	// 825C64A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C64AC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825C64B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C64B4: 4099003C  ble cr6, 0x825c64f0
	if !ctx.cr[6].gt {
	pc = 0x825C64F0; continue 'dispatch;
	}
	// 825C64B8: 3B9F0020  addi r28, r31, 0x20
	ctx.r[28].s64 = ctx.r[31].s64 + 32;
	// 825C64BC: 38BF00A0  addi r5, r31, 0xa0
	ctx.r[5].s64 = ctx.r[31].s64 + 160;
	// 825C64C0: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	pc = 0x825C64C4; continue 'dispatch;
            }
            0x825C64C4 => {
    //   block [0x825C64C4..0x825C64F0)
	// 825C64C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825C64C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C64CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C64D0: 4BFFED49  bl 0x825c5218
	ctx.lr = 0x825C64D4;
	sub_825C5218(ctx, base);
	// 825C64D4: 2F03000E  cmpwi cr6, r3, 0xe
	ctx.cr[6].compare_i32(ctx.r[3].s32, 14, &mut ctx.xer);
	// 825C64D8: 419A01FC  beq cr6, 0x825c66d4
	if ctx.cr[6].eq {
	pc = 0x825C66D4; continue 'dispatch;
	}
	// 825C64DC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C64E0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 825C64E4: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 825C64E8: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825C64EC: 4198FFD8  blt cr6, 0x825c64c4
	if ctx.cr[6].lt {
	pc = 0x825C64C4; continue 'dispatch;
	}
	pc = 0x825C64F0; continue 'dispatch;
            }
            0x825C64F0 => {
    //   block [0x825C64F0..0x825C6518)
	// 825C64F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C64F4: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 825C64F8: 409A005C  bne cr6, 0x825c6554
	if !ctx.cr[6].eq {
	pc = 0x825C6554; continue 'dispatch;
	}
	// 825C64FC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C6500: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825C6504: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C6508: 4099003C  ble cr6, 0x825c6544
	if !ctx.cr[6].gt {
	pc = 0x825C6544; continue 'dispatch;
	}
	// 825C650C: 3B9F00A0  addi r28, r31, 0xa0
	ctx.r[28].s64 = ctx.r[31].s64 + 160;
	// 825C6510: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 825C6514: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	pc = 0x825C6518; continue 'dispatch;
            }
            0x825C6518 => {
    //   block [0x825C6518..0x825C6544)
	// 825C6518: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825C651C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C6520: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C6524: 4BFFECF5  bl 0x825c5218
	ctx.lr = 0x825C6528;
	sub_825C5218(ctx, base);
	// 825C6528: 2F03000E  cmpwi cr6, r3, 0xe
	ctx.cr[6].compare_i32(ctx.r[3].s32, 14, &mut ctx.xer);
	// 825C652C: 419A01CC  beq cr6, 0x825c66f8
	if ctx.cr[6].eq {
	pc = 0x825C66F8; continue 'dispatch;
	}
	// 825C6530: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C6534: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 825C6538: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 825C653C: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825C6540: 4198FFD8  blt cr6, 0x825c6518
	if ctx.cr[6].lt {
	pc = 0x825C6518; continue 'dispatch;
	}
	pc = 0x825C6544; continue 'dispatch;
            }
            0x825C6544 => {
    //   block [0x825C6544..0x825C6554)
	// 825C6544: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C6548: 3AA00003  li r21, 3
	ctx.r[21].s64 = 3;
	// 825C654C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 825C6550: 419A0008  beq cr6, 0x825c6558
	if ctx.cr[6].eq {
	pc = 0x825C6558; continue 'dispatch;
	}
	pc = 0x825C6554; continue 'dispatch;
            }
            0x825C6554 => {
    //   block [0x825C6554..0x825C6558)
	// 825C6554: 3AA00001  li r21, 1
	ctx.r[21].s64 = 1;
	pc = 0x825C6558; continue 'dispatch;
            }
            0x825C6558 => {
    //   block [0x825C6558..0x825C656C)
	// 825C6558: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C655C: 3AC00003  li r22, 3
	ctx.r[22].s64 = 3;
	// 825C6560: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 825C6564: 419A0008  beq cr6, 0x825c656c
	if ctx.cr[6].eq {
	pc = 0x825C656C; continue 'dispatch;
	}
	// 825C6568: 3AC00001  li r22, 1
	ctx.r[22].s64 = 1;
	pc = 0x825C656C; continue 'dispatch;
            }
            0x825C656C => {
    //   block [0x825C656C..0x825C6634)
	// 825C656C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825C6570: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 825C6574: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 825C6578: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825C657C: 2F150000  cmpwi cr6, r21, 0
	ctx.cr[6].compare_i32(ctx.r[21].s32, 0, &mut ctx.xer);
	// 825C6580: C3EB8CB4  lfs f31, -0x734c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825C6584: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825C6588: 3B4BA430  addi r26, r11, -0x5bd0
	ctx.r[26].s64 = ctx.r[11].s64 + -23504;
	// 825C658C: 409900B8  ble cr6, 0x825c6644
	if !ctx.cr[6].gt {
	pc = 0x825C6644; continue 'dispatch;
	}
	// 825C6590: 3B7F0020  addi r27, r31, 0x20
	ctx.r[27].s64 = ctx.r[31].s64 + 32;
	// 825C6594: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825C6598: 2F160000  cmpwi cr6, r22, 0
	ctx.cr[6].compare_i32(ctx.r[22].s32, 0, &mut ctx.xer);
	// 825C659C: 40990098  ble cr6, 0x825c6634
	if !ctx.cr[6].gt {
	pc = 0x825C6634; continue 'dispatch;
	}
	// 825C65A0: 3BDF00A0  addi r30, r31, 0xa0
	ctx.r[30].s64 = ctx.r[31].s64 + 160;
	// 825C65A4: 3B3A0002  addi r25, r26, 2
	ctx.r[25].s64 = ctx.r[26].s64 + 2;
	// 825C65A8: 7D7CC8AE  lbzx r11, r28, r25
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 825C65AC: 395A0002  addi r10, r26, 2
	ctx.r[10].s64 = ctx.r[26].s64 + 2;
	pc = 0x825C6634; continue 'dispatch;
            }
            0x825C6634 => {
    //   block [0x825C6634..0x825C6644)
	// 825C6634: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 825C6638: 3B7B0010  addi r27, r27, 0x10
	ctx.r[27].s64 = ctx.r[27].s64 + 16;
	// 825C663C: 7F1CA800  cmpw cr6, r28, r21
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[21].s32, &mut ctx.xer);
	// 825C6640: 4198FF54  blt cr6, 0x825c6594
	if ctx.cr[6].lt {
	pc = 0x825C6594; continue 'dispatch;
	}
	pc = 0x825C6644; continue 'dispatch;
            }
            0x825C6644 => {
    //   block [0x825C6644..0x825C66D4)
	// 825C6644: 2F150003  cmpwi cr6, r21, 3
	ctx.cr[6].compare_i32(ctx.r[21].s32, 3, &mut ctx.xer);
	// 825C6648: 409A0030  bne cr6, 0x825c6678
	if !ctx.cr[6].eq {
	pc = 0x825C6678; continue 'dispatch;
	}
	// 825C664C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C6650: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825C6654: 394B0002  addi r10, r11, 2
	ctx.r[10].s64 = ctx.r[11].s64 + 2;
	// 825C6658: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825C665C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825C6660: 7D78D0AE  lbzx r11, r24, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 825C6664: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	pc = 0x825C66D4; continue 'dispatch;
            }
            0x825C66D4 => {
    //   block [0x825C66D4..0x825C66F8)
	// 825C66D4: 397D0002  addi r11, r29, 2
	ctx.r[11].s64 = ctx.r[29].s64 + 2;
	// 825C66D8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825C66DC: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	pc = 0x825C66F8; continue 'dispatch;
            }
            0x825C66F8 => {
    //   block [0x825C66F8..0x825C6730)
	// 825C66F8: 397D000E  addi r11, r29, 0xe
	ctx.r[11].s64 = ctx.r[29].s64 + 14;
	// 825C66FC: 395D000A  addi r10, r29, 0xa
	ctx.r[10].s64 = ctx.r[29].s64 + 10;
	// 825C6700: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C6704: 392000E0  li r9, 0xe0
	ctx.r[9].s64 = 224;
	// 825C6708: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825C670C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C6730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825C6730 size=3152
    //   switch @ 0x825C6B38: r11 with 25 label(s)
    //       case  0  0x825C6F8C
    //       case  1  0x825C7044
    //       case  2  0x825C6D04
    //       case  3  0x825C6CB8
    //       case  4  0x825C7330
    //       case  5  0x825C7330
    //       case  6  0x825C7330
    //       case  7  0x825C7330
    //       case  8  0x825C7164
    //       case  9  0x825C6C00
    //       case 10  0x825C6BA0
    //       case 11  0x825C7330
    //       case 12  0x825C7330
    //       case 13  0x825C7330
    //       case 14  0x825C7330
    //       case 15  0x825C7330
    //       case 16  0x825C6E70
    //       case 17  0x825C6BB8
    //       case 18  0x825C7330
    //       case 19  0x825C7330
    //       case 20  0x825C7330
    //       case 21  0x825C7330
    //       case 22  0x825C7330
    //       case 23  0x825C7330
    //       case 24  0x825C6E3C
    let mut pc: u32 = 0x825C6730;
    'dispatch: loop {
        match pc {
            0x825C6730 => {
    //   block [0x825C6730..0x825C6BA0)
	// 825C6730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C6734: 4BF6E94D  bl 0x82535080
	ctx.lr = 0x825C6738;
	sub_82535080(ctx, base);
	// 825C6738: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 825C673C: 4BF6F8A1  bl 0x82535fdc
	ctx.lr = 0x825C6740;
	sub_82535FB0(ctx, base);
	// 825C6740: 3981FF30  addi r12, r1, -0xd0
	ctx.r[12].s64 = ctx.r[1].s64 + -208;
	// 825C6744: 4BF72C61  bl 0x825393a4
	ctx.lr = 0x825C6748;
	sub_82539130(ctx, base);
	// 825C6748: 9421FDA0  stwu r1, -0x260(r1)
	ea = ctx.r[1].u32.wrapping_add(-608 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C674C: 39C00010  li r14, 0x10
	ctx.r[14].s64 = 16;
	// 825C6750: 90610274  stw r3, 0x274(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(628 as u32), ctx.r[3].u32 ) };
	// 825C6754: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	pc = 0x825C6BA0; continue 'dispatch;
            }
            0x825C6BA0 => {
    //   block [0x825C6BA0..0x825C6BB8)
	// 825C6BA0: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 825C6BA4: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 825C6BA8: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 825C6BAC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 825C6BB0: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 825C6BB4: 48000018  b 0x825c6bcc
	pc = 0x825C6BCC; continue 'dispatch;
            }
            0x825C6BB8 => {
    //   block [0x825C6BB8..0x825C6C00)
	// 825C6BB8: 3920FFF8  li r9, -8
	ctx.r[9].s64 = -8;
	// 825C6BBC: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 825C6BC0: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 825C6BC4: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 825C6BC8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825C6BCC: 815F0170  lwz r10, 0x170(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 825C6BD0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825C6BD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C6BD8: 394AFFFE  addi r10, r10, -2
	ctx.r[10].s64 = ctx.r[10].s64 + -2;
	// 825C6BDC: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 825C6BE0: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 825C6BE4: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 825C6BE8: 890B0000  lbz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C6BEC: 4BFFF24D  bl 0x825c5e38
	ctx.lr = 0x825C6BF0;
	sub_825C5E38(ctx, base);
	// 825C6BF0: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 825C6BF4: 419A073C  beq cr6, 0x825c7330
	if ctx.cr[6].eq {
	pc = 0x825C7330; continue 'dispatch;
	}
	// 825C6BF8: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 825C6BFC: 409A0650  bne cr6, 0x825c724c
	if !ctx.cr[6].eq {
	pc = 0x825C724C; continue 'dispatch;
	}
	pc = 0x825C6C00; continue 'dispatch;
            }
            0x825C6C00 => {
    //   block [0x825C6C00..0x825C6CB8)
	// 825C6C00: 3BDF0020  addi r30, r31, 0x20
	ctx.r[30].s64 = ctx.r[31].s64 + 32;
	pc = 0x825C6CB8; continue 'dispatch;
            }
            0x825C6CB8 => {
    //   block [0x825C6CB8..0x825C6D04)
	// 825C6CB8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825C6CBC: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 825C6CC0: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 825C6CC4: 4BFFE785  bl 0x825c5448
	ctx.lr = 0x825C6CC8;
	sub_825C5448(ctx, base);
	// 825C6CC8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825C6CCC: 41980664  blt cr6, 0x825c7330
	if ctx.cr[6].lt {
	pc = 0x825C7330; continue 'dispatch;
	}
	// 825C6CD0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C6CD4: 3943000A  addi r10, r3, 0xa
	ctx.r[10].s64 = ctx.r[3].s64 + 10;
	// 825C6CD8: 3923000E  addi r9, r3, 0xe
	ctx.r[9].s64 = ctx.r[3].s64 + 14;
	// 825C6CDC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825C6CE0: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825C6CE4: 55292036  slwi r9, r9, 4
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825C6CE8: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825C6CEC: 396000D0  li r11, 0xd0
	ctx.r[11].s64 = 208;
	pc = 0x825C6D04; continue 'dispatch;
            }
            0x825C6D04 => {
    //   block [0x825C6D04..0x825C6E3C)
	// 825C6D04: 3BDF0020  addi r30, r31, 0x20
	ctx.r[30].s64 = ctx.r[31].s64 + 32;
	// 825C6D08: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 825C6D0C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 825C6D10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C6D14: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C6D18: 4BFFE501  bl 0x825c5218
	ctx.lr = 0x825C6D1C;
	sub_825C5218(ctx, base);
	// 825C6D1C: 2F03000E  cmpwi cr6, r3, 0xe
	ctx.cr[6].compare_i32(ctx.r[3].s32, 14, &mut ctx.xer);
	// 825C6D20: 419A052C  beq cr6, 0x825c724c
	if ctx.cr[6].eq {
	pc = 0x825C724C; continue 'dispatch;
	}
	// 825C6D24: 7D6378AE  lbzx r11, r3, r15
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[15].u32)) } as u64;
	// 825C6D28: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 825C6D2C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C6D30: 419802D8  blt cr6, 0x825c7008
	if ctx.cr[6].lt {
	pc = 0x825C7008; continue 'dispatch;
	}
	// 825C6D34: 394B000A  addi r10, r11, 0xa
	ctx.r[10].s64 = ctx.r[11].s64 + 10;
	pc = 0x825C6E3C; continue 'dispatch;
            }
            0x825C6E3C => {
    //   block [0x825C6E3C..0x825C6E70)
	// 825C6E3C: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 825C6E40: FC20D090  fmr f1, f26
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[26].f64;
	// 825C6E44: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825C6E48: 4BFFE601  bl 0x825c5448
	ctx.lr = 0x825C6E4C;
	sub_825C5448(ctx, base);
	// 825C6E4C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825C6E50: 419804E0  blt cr6, 0x825c7330
	if ctx.cr[6].lt {
	pc = 0x825C7330; continue 'dispatch;
	}
	// 825C6E54: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C6E58: 39430002  addi r10, r3, 2
	ctx.r[10].s64 = ctx.r[3].s64 + 2;
	pc = 0x825C6E70; continue 'dispatch;
            }
            0x825C6E70 => {
    //   block [0x825C6E70..0x825C6F8C)
	// 825C6E70: 38C0FFF8  li r6, -8
	ctx.r[6].s64 = -8;
	// 825C6E74: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 825C6E78: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825C6E7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C6E80: 4BFFE399  bl 0x825c5218
	ctx.lr = 0x825C6E84;
	sub_825C5218(ctx, base);
	// 825C6E84: 2F03000E  cmpwi cr6, r3, 0xe
	ctx.cr[6].compare_i32(ctx.r[3].s32, 14, &mut ctx.xer);
	// 825C6E88: 419A03C4  beq cr6, 0x825c724c
	if ctx.cr[6].eq {
	pc = 0x825C724C; continue 'dispatch;
	}
	// 825C6E8C: 7D6378AE  lbzx r11, r3, r15
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[15].u32)) } as u64;
	// 825C6E90: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 825C6E94: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C6E98: 419802A0  blt cr6, 0x825c7138
	if ctx.cr[6].lt {
	pc = 0x825C7138; continue 'dispatch;
	}
	// 825C6E9C: 394B0002  addi r10, r11, 2
	ctx.r[10].s64 = ctx.r[11].s64 + 2;
	pc = 0x825C6F8C; continue 'dispatch;
            }
            0x825C6F8C => {
    //   block [0x825C6F8C..0x825C7044)
	pc = 0x825C7044; continue 'dispatch;
            }
            0x825C7044 => {
    //   block [0x825C7044..0x825C7164)
	// 825C7044: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 825C7048: 393F0020  addi r9, r31, 0x20
	ctx.r[9].s64 = ctx.r[31].s64 + 32;
	// 825C704C: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 825C7050: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 825C7054: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	pc = 0x825C7164; continue 'dispatch;
            }
            0x825C7164 => {
    //   block [0x825C7164..0x825C7330)
	// 825C7164: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 825C7168: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 825C716C: 39410078  addi r10, r1, 0x78
	ctx.r[10].s64 = ctx.r[1].s64 + 120;
	// 825C7170: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 825C7174: 39000008  li r8, 8
	ctx.r[8].s64 = 8;
	pc = 0x825C7330; continue 'dispatch;
            }
            0x825C7330 => {
    //   block [0x825C7330..0x825C7380)
	// 825C7330: 816102A4  lwz r11, 0x2a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(676 as u32) ) } as u64;
	// 825C7334: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C7338: FF1C0000  fcmpu cr6, f28, f0
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[0].f64);
	// 825C733C: 40980024  bge cr6, 0x825c7360
	if !ctx.cr[6].lt {
	pc = 0x825C7360; continue 'dispatch;
	}
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C7380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C7380 size=1028
    let mut pc: u32 = 0x825C7380;
    'dispatch: loop {
        match pc {
            0x825C7380 => {
    //   block [0x825C7380..0x825C73D4)
	// 825C7380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C7384: 4BF6DD19  bl 0x8253509c
	ctx.lr = 0x825C7388;
	sub_82535080(ctx, base);
	// 825C7388: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C738C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825C7390: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825C7394: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 825C7398: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 825C739C: 3BC00004  li r30, 4
	ctx.r[30].s64 = 4;
	// 825C73A0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C73A4: 3B000030  li r24, 0x30
	ctx.r[24].s64 = 48;
	// 825C73A8: 3AE00001  li r23, 1
	ctx.r[23].s64 = 1;
	// 825C73AC: 3B2000B0  li r25, 0xb0
	ctx.r[25].s64 = 176;
	// 825C73B0: 3B400003  li r26, 3
	ctx.r[26].s64 = 3;
	// 825C73B4: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 825C73B8: 41980078  blt cr6, 0x825c7430
	if ctx.cr[6].lt {
	pc = 0x825C7430; continue 'dispatch;
	}
	// 825C73BC: 40990018  ble cr6, 0x825c73d4
	if !ctx.cr[6].gt {
	pc = 0x825C73D4; continue 'dispatch;
	}
	// 825C73C0: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 825C73C4: 39400050  li r10, 0x50
	ctx.r[10].s64 = 80;
	pc = 0x825C73D4; continue 'dispatch;
            }
            0x825C73D4 => {
    //   block [0x825C73D4..0x825C7430)
	// 825C73D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C73D8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825C73DC: 40990034  ble cr6, 0x825c7410
	if !ctx.cr[6].gt {
	pc = 0x825C7410; continue 'dispatch;
	}
	// 825C73E0: 39600050  li r11, 0x50
	ctx.r[11].s64 = 80;
	pc = 0x825C7430; continue 'dispatch;
            }
            0x825C7430 => {
    //   block [0x825C7430..0x825C7784)
	// 825C7430: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C7434: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 825C7438: 4198009C  blt cr6, 0x825c74d4
	if ctx.cr[6].lt {
	pc = 0x825C74D4; continue 'dispatch;
	}
	// 825C743C: 392000F0  li r9, 0xf0
	ctx.r[9].s64 = 240;
	// 825C7440: 40990028  ble cr6, 0x825c7468
	if !ctx.cr[6].gt {
	pc = 0x825C7468; continue 'dispatch;
	}
	// 825C7444: 396000E0  li r11, 0xe0
	ctx.r[11].s64 = 224;
	// 825C7448: 39400110  li r10, 0x110
	ctx.r[10].s64 = 272;
	// 825C744C: 390000A0  li r8, 0xa0
	ctx.r[8].s64 = 160;
	// 825C7450: 38E000D0  li r7, 0xd0
	ctx.r[7].s64 = 208;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C7788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C7788 size=424
    let mut pc: u32 = 0x825C7788;
    'dispatch: loop {
        match pc {
            0x825C7788 => {
    //   block [0x825C7788..0x825C77D8)
	// 825C7788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C778C: 4BF6D92D  bl 0x825350b8
	ctx.lr = 0x825C7790;
	sub_82535080(ctx, base);
	// 825C7790: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C7794: 83AD0000  lwz r29, 0(r13)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C7798: 3BC00014  li r30, 0x14
	ctx.r[30].s64 = 20;
	// 825C779C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825C77A0: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	// 825C77A4: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 825C77A8: 7D7EE82E  lwzx r11, r30, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 825C77AC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C77B0: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825C77B4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825C77B8: 40980020  bge cr6, 0x825c77d8
	if !ctx.cr[6].lt {
	pc = 0x825C77D8; continue 'dispatch;
	}
	// 825C77BC: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825C77C0: 3929A3F8  addi r9, r9, -0x5c08
	ctx.r[9].s64 = ctx.r[9].s64 + -23560;
	// 825C77C4: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825C77C8: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 825C77CC: 38EA000C  addi r7, r10, 0xc
	ctx.r[7].s64 = ctx.r[10].s64 + 12;
	// 825C77D0: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825C77D4: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	pc = 0x825C77D8; continue 'dispatch;
            }
            0x825C77D8 => {
    //   block [0x825C77D8..0x825C7930)
	// 825C77D8: 396100E0  addi r11, r1, 0xe0
	ctx.r[11].s64 = ctx.r[1].s64 + 224;
	// 825C77DC: 38E100B0  addi r7, r1, 0xb0
	ctx.r[7].s64 = ctx.r[1].s64 + 176;
	// 825C77E0: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 825C77E4: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C7930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C7930 size=3720
    //   switch @ 0x825C7AFC: r11 with 25 label(s)
    //       case  0  0x825C80F8
    //       case  1  0x825C81DC
    //       case  2  0x825C7CCC
    //       case  3  0x825C7C80
    //       case  4  0x825C7F5C
    //       case  5  0x825C7F5C
    //       case  6  0x825C7F5C
    //       case  7  0x825C7F5C
    //       case  8  0x825C831C
    //       case  9  0x825C7BC4
    //       case 10  0x825C7B64
    //       case 11  0x825C7F5C
    //       case 12  0x825C7F5C
    //       case 13  0x825C7F5C
    //       case 14  0x825C7F5C
    //       case 15  0x825C7F5C
    //       case 16  0x825C7E40
    //       case 17  0x825C7B7C
    //       case 18  0x825C7F5C
    //       case 19  0x825C7F5C
    //       case 20  0x825C7F5C
    //       case 21  0x825C7F5C
    //       case 22  0x825C7F5C
    //       case 23  0x825C7F5C
    //       case 24  0x825C7E08
    let mut pc: u32 = 0x825C7930;
    'dispatch: loop {
        match pc {
            0x825C7930 => {
    //   block [0x825C7930..0x825C7B64)
	// 825C7930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C7934: 4BF6D74D  bl 0x82535080
	ctx.lr = 0x825C7938;
	sub_82535080(ctx, base);
	// 825C7938: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 825C793C: 4BF6E6A5  bl 0x82535fe0
	ctx.lr = 0x825C7940;
	sub_82535FB0(ctx, base);
	// 825C7940: 9421FE20  stwu r1, -0x1e0(r1)
	ea = ctx.r[1].u32.wrapping_add(-480 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C7944: 7CD53378  mr r21, r6
	ctx.r[21].u64 = ctx.r[6].u64;
	// 825C7948: 90A10204  stw r5, 0x204(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(516 as u32), ctx.r[5].u32 ) };
	// 825C794C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 825C7950: 90E10214  stw r7, 0x214(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(532 as u32), ctx.r[7].u32 ) };
	// 825C7954: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825C7958: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 825C795C: 39F50010  addi r15, r21, 0x10
	ctx.r[15].s64 = ctx.r[21].s64 + 16;
	// 825C7960: E8950000  ld r4, 0(r21)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) };
	// 825C7964: 392100E0  addi r9, r1, 0xe0
	ctx.r[9].s64 = ctx.r[1].s64 + 224;
	// 825C7968: E8750008  ld r3, 8(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) };
	// 825C796C: 39D50020  addi r14, r21, 0x20
	ctx.r[14].s64 = ctx.r[21].s64 + 32;
	// 825C7970: 390100D0  addi r8, r1, 0xd0
	ctx.r[8].s64 = ctx.r[1].s64 + 208;
	// 825C7974: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C7978: 38B50030  addi r5, r21, 0x30
	ctx.r[5].s64 = ctx.r[21].s64 + 48;
	// 825C797C: 936101FC  stw r27, 0x1fc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(508 as u32), ctx.r[27].u32 ) };
	// 825C7980: EBCF0008  ld r30, 8(r15)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[15].u32.wrapping_add(8 as u32) ) };
	// 825C7984: 38E100F0  addi r7, r1, 0xf0
	ctx.r[7].s64 = ctx.r[1].s64 + 240;
	// 825C7988: F88A0000  std r4, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[4].u64 ) };
	// 825C798C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825C7990: F86A0008  std r3, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[3].u64 ) };
	// 825C7994: 3B5F0004  addi r26, r31, 4
	ctx.r[26].s64 = ctx.r[31].s64 + 4;
	// 825C7998: E94F0000  ld r10, 0(r15)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[15].u32.wrapping_add(0 as u32) ) };
	// 825C799C: 38CB000E  addi r6, r11, 0xe
	ctx.r[6].s64 = ctx.r[11].s64 + 14;
	// 825C79A0: E88E0000  ld r4, 0(r14)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[14].u32.wrapping_add(0 as u32) ) };
	// 825C79A4: EBAE0008  ld r29, 8(r14)
	ctx.r[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[14].u32.wrapping_add(8 as u32) ) };
	// 825C79A8: 54C62036  slwi r6, r6, 4
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shl(4);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 825C79AC: E8650000  ld r3, 0(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	// 825C79B0: E8A50008  ld r5, 8(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	// 825C79B4: 7CC6FA14  add r6, r6, r31
	ctx.r[6].u64 = ctx.r[6].u64 + ctx.r[31].u64;
	// 825C79B8: F9490000  std r10, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 825C79BC: 3940FFC0  li r10, -0x40
	ctx.r[10].s64 = -64;
	// 825C79C0: FBC90008  std r30, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[30].u64 ) };
	// 825C79C4: 392100B0  addi r9, r1, 0xb0
	ctx.r[9].s64 = ctx.r[1].s64 + 176;
	// 825C79C8: F8880000  std r4, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[4].u64 ) };
	// 825C79CC: FBA80008  std r29, 8(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[29].u64 ) };
	// 825C79D0: F8670000  std r3, 0(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[3].u64 ) };
	// 825C79D4: F8A70008  std r5, 8(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[5].u64 ) };
	pc = 0x825C7B64; continue 'dispatch;
            }
            0x825C7B64 => {
    //   block [0x825C7B64..0x825C7B7C)
	// 825C7B64: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 825C7B68: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 825C7B6C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 825C7B70: 38BF00A0  addi r5, r31, 0xa0
	ctx.r[5].s64 = ctx.r[31].s64 + 160;
	// 825C7B74: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 825C7B78: 48000018  b 0x825c7b90
	pc = 0x825C7B90; continue 'dispatch;
            }
            0x825C7B7C => {
    //   block [0x825C7B7C..0x825C7BC4)
	// 825C7B7C: 3920FFF8  li r9, -8
	ctx.r[9].s64 = -8;
	// 825C7B80: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 825C7B84: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 825C7B88: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 825C7B8C: 389F00A0  addi r4, r31, 0xa0
	ctx.r[4].s64 = ctx.r[31].s64 + 160;
	// 825C7B90: 815F0170  lwz r10, 0x170(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 825C7B94: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825C7B98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C7B9C: 394AFFFE  addi r10, r10, -2
	ctx.r[10].s64 = ctx.r[10].s64 + -2;
	// 825C7BA0: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 825C7BA4: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 825C7BA8: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 825C7BAC: 890B0000  lbz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C7BB0: 4BFFE289  bl 0x825c5e38
	ctx.lr = 0x825C7BB4;
	sub_825C5E38(ctx, base);
	// 825C7BB4: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 825C7BB8: 419A03A4  beq cr6, 0x825c7f5c
	if ctx.cr[6].eq {
	pc = 0x825C7F5C; continue 'dispatch;
	}
	// 825C7BBC: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 825C7BC0: 409A085C  bne cr6, 0x825c841c
	if !ctx.cr[6].eq {
	pc = 0x825C841C; continue 'dispatch;
	}
	pc = 0x825C7BC4; continue 'dispatch;
            }
            0x825C7BC4 => {
    //   block [0x825C7BC4..0x825C7C80)
	// 825C7BC4: 3BDF0020  addi r30, r31, 0x20
	ctx.r[30].s64 = ctx.r[31].s64 + 32;
	// 825C7BC8: 3B9F0030  addi r28, r31, 0x30
	ctx.r[28].s64 = ctx.r[31].s64 + 48;
	// 825C7BCC: 3BBF00A0  addi r29, r31, 0xa0
	ctx.r[29].s64 = ctx.r[31].s64 + 160;
	// 825C7BD0: 3B7F00B0  addi r27, r31, 0xb0
	ctx.r[27].s64 = ctx.r[31].s64 + 176;
	// 825C7BD4: 396100F0  addi r11, r1, 0xf0
	ctx.r[11].s64 = ctx.r[1].s64 + 240;
	pc = 0x825C7C80; continue 'dispatch;
            }
            0x825C7C80 => {
    //   block [0x825C7C80..0x825C7CCC)
	// 825C7C80: 389F00A0  addi r4, r31, 0xa0
	ctx.r[4].s64 = ctx.r[31].s64 + 160;
	// 825C7C84: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 825C7C88: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 825C7C8C: 4BFFD7BD  bl 0x825c5448
	ctx.lr = 0x825C7C90;
	sub_825C5448(ctx, base);
	// 825C7C90: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825C7C94: 419802C8  blt cr6, 0x825c7f5c
	if ctx.cr[6].lt {
	pc = 0x825C7F5C; continue 'dispatch;
	}
	// 825C7C98: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C7C9C: 3943000A  addi r10, r3, 0xa
	ctx.r[10].s64 = ctx.r[3].s64 + 10;
	// 825C7CA0: 3923000E  addi r9, r3, 0xe
	ctx.r[9].s64 = ctx.r[3].s64 + 14;
	// 825C7CA4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825C7CA8: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825C7CAC: 55292036  slwi r9, r9, 4
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825C7CB0: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825C7CB4: 396000D0  li r11, 0xd0
	ctx.r[11].s64 = 208;
	pc = 0x825C7CCC; continue 'dispatch;
            }
            0x825C7CCC => {
    //   block [0x825C7CCC..0x825C7E08)
	// 825C7CCC: 3BDF0020  addi r30, r31, 0x20
	ctx.r[30].s64 = ctx.r[31].s64 + 32;
	// 825C7CD0: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 825C7CD4: 38BF00A0  addi r5, r31, 0xa0
	ctx.r[5].s64 = ctx.r[31].s64 + 160;
	// 825C7CD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C7CDC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C7CE0: 4BFFD539  bl 0x825c5218
	ctx.lr = 0x825C7CE4;
	sub_825C5218(ctx, base);
	// 825C7CE4: 2F03000E  cmpwi cr6, r3, 0xe
	ctx.cr[6].compare_i32(ctx.r[3].s32, 14, &mut ctx.xer);
	// 825C7CE8: 419A0734  beq cr6, 0x825c841c
	if ctx.cr[6].eq {
	pc = 0x825C841C; continue 'dispatch;
	}
	// 825C7CEC: 816100A8  lwz r11, 0xa8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 825C7CF0: 7D6358AE  lbzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825C7CF4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 825C7CF8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C7CFC: 419804A4  blt cr6, 0x825c81a0
	if ctx.cr[6].lt {
	pc = 0x825C81A0; continue 'dispatch;
	}
	// 825C7D00: 394B000A  addi r10, r11, 0xa
	ctx.r[10].s64 = ctx.r[11].s64 + 10;
	pc = 0x825C7E08; continue 'dispatch;
            }
            0x825C7E08 => {
    //   block [0x825C7E08..0x825C7E40)
	// 825C7E08: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 825C7E0C: FC20D090  fmr f1, f26
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[26].f64;
	// 825C7E10: 387F00A0  addi r3, r31, 0xa0
	ctx.r[3].s64 = ctx.r[31].s64 + 160;
	// 825C7E14: 4BFFD635  bl 0x825c5448
	ctx.lr = 0x825C7E18;
	sub_825C5448(ctx, base);
	// 825C7E18: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825C7E1C: 41980140  blt cr6, 0x825c7f5c
	if ctx.cr[6].lt {
	pc = 0x825C7F5C; continue 'dispatch;
	}
	// 825C7E20: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C7E24: 39430002  addi r10, r3, 2
	ctx.r[10].s64 = ctx.r[3].s64 + 2;
	// 825C7E28: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825C7E2C: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825C7E30: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825C7E34: 39600050  li r11, 0x50
	ctx.r[11].s64 = 80;
	pc = 0x825C7E40; continue 'dispatch;
            }
            0x825C7E40 => {
    //   block [0x825C7E40..0x825C7F5C)
	// 825C7E40: 3BDF00A0  addi r30, r31, 0xa0
	ctx.r[30].s64 = ctx.r[31].s64 + 160;
	// 825C7E44: 38C0FFF8  li r6, -8
	ctx.r[6].s64 = -8;
	// 825C7E48: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 825C7E4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C7E50: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C7E54: 4BFFD3C5  bl 0x825c5218
	ctx.lr = 0x825C7E58;
	sub_825C5218(ctx, base);
	// 825C7E58: 2F03000E  cmpwi cr6, r3, 0xe
	ctx.cr[6].compare_i32(ctx.r[3].s32, 14, &mut ctx.xer);
	// 825C7E5C: 419A05C0  beq cr6, 0x825c841c
	if ctx.cr[6].eq {
	pc = 0x825C841C; continue 'dispatch;
	}
	// 825C7E60: 816100A8  lwz r11, 0xa8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 825C7E64: 7D6358AE  lbzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825C7E68: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 825C7E6C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C7E70: 41980480  blt cr6, 0x825c82f0
	if ctx.cr[6].lt {
	pc = 0x825C82F0; continue 'dispatch;
	}
	// 825C7E74: 394B0002  addi r10, r11, 2
	ctx.r[10].s64 = ctx.r[11].s64 + 2;
	pc = 0x825C7F5C; continue 'dispatch;
            }
            0x825C7F5C => {
    //   block [0x825C7F5C..0x825C80F8)
	// 825C7F5C: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 825C7F60: 3BDF0120  addi r30, r31, 0x120
	ctx.r[30].s64 = ctx.r[31].s64 + 288;
	// 825C7F64: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 825C7F68: 390000A0  li r8, 0xa0
	ctx.r[8].s64 = 160;
	// 825C7F6C: 3BBF0020  addi r29, r31, 0x20
	ctx.r[29].s64 = ctx.r[31].s64 + 32;
	// 825C7F70: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	pc = 0x825C80F8; continue 'dispatch;
            }
            0x825C80F8 => {
    //   block [0x825C80F8..0x825C81DC)
	// 825C80F8: 396000A0  li r11, 0xa0
	ctx.r[11].s64 = 160;
	// 825C80FC: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825C81DC; continue 'dispatch;
            }
            0x825C81DC => {
    //   block [0x825C81DC..0x825C831C)
	// 825C81DC: 397F00A0  addi r11, r31, 0xa0
	ctx.r[11].s64 = ctx.r[31].s64 + 160;
	// 825C81E0: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 825C81E4: 393F0020  addi r9, r31, 0x20
	ctx.r[9].s64 = ctx.r[31].s64 + 32;
	// 825C81E8: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 825C81EC: 38DF0120  addi r6, r31, 0x120
	ctx.r[6].s64 = ctx.r[31].s64 + 288;
	pc = 0x825C831C; continue 'dispatch;
            }
            0x825C831C => {
    //   block [0x825C831C..0x825C87B8)
	// 825C831C: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 825C8320: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 825C8324: 391F00A0  addi r8, r31, 0xa0
	ctx.r[8].s64 = ctx.r[31].s64 + 160;
	// 825C8328: 39410078  addi r10, r1, 0x78
	ctx.r[10].s64 = ctx.r[1].s64 + 120;
	// 825C832C: 38FF0120  addi r7, r31, 0x120
	ctx.r[7].s64 = ctx.r[31].s64 + 288;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C87B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825C87B8 size=464
    let mut pc: u32 = 0x825C87B8;
    'dispatch: loop {
        match pc {
            0x825C87B8 => {
    //   block [0x825C87B8..0x825C8878)
	// 825C87B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C87BC: 4BF6C8F9  bl 0x825350b4
	ctx.lr = 0x825C87C0;
	sub_82535080(ctx, base);
	// 825C87C0: 9421FDE0  stwu r1, -0x220(r1)
	ea = ctx.r[1].u32.wrapping_add(-544 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C87C4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825C87C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825C87CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825C87D0: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825C87D4: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 825C87D8: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 825C87DC: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 825C87E0: 91410084  stw r10, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 825C87E4: 895E0009  lbz r10, 9(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(9 as u32) ) } as u64;
	// 825C87E8: 897E000A  lbz r11, 0xa(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(10 as u32) ) } as u64;
	// 825C87EC: 88BE0008  lbz r5, 8(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C87F0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C87F4: 83BF000C  lwz r29, 0xc(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825C87F8: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 825C87FC: 556AE13E  srwi r10, r11, 4
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825C8800: 556B073E  clrlwi r11, r11, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 825C8804: 90A10070  stw r5, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[5].u32 ) };
	// 825C8808: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 825C880C: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 825C8810: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C8814: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 825C8818: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825C881C: 4E800421  bctrl
	ctx.lr = 0x825C8820;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825C8820: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 825C8824: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C8828: 38C10150  addi r6, r1, 0x150
	ctx.r[6].s64 = ctx.r[1].s64 + 336;
	// 825C882C: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C8830: 80A10074  lwz r5, 0x74(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825C8834: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825C8838: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 825C883C: 816A0034  lwz r11, 0x34(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) } as u64;
	// 825C8840: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825C8844: 4E800421  bctrl
	ctx.lr = 0x825C8848;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825C8848: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 825C884C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825C8850: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C8854: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825C8858: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C885C: 4BFFF0D5  bl 0x825c7930
	ctx.lr = 0x825C8860;
	sub_825C7930(ctx, base);
	// 825C8860: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 825C8864: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C8868: 419A0010  beq cr6, 0x825c8878
	if ctx.cr[6].eq {
	pc = 0x825C8878; continue 'dispatch;
	}
	// 825C886C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C8870: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825C8874: 4BFFDA4D  bl 0x825c62c0
	ctx.lr = 0x825C8878;
	sub_825C62C0(ctx, base);
            }
            0x825C8878 => {
    //   block [0x825C8878..0x825C8988)
	// 825C8878: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 825C887C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C8880: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 825C8884: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C8888: C1A1006C  lfs f13, 0x6c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C888C: 80FF000C  lwz r7, 0xc(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C8988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C8988 size=412
    let mut pc: u32 = 0x825C8988;
    'dispatch: loop {
        match pc {
            0x825C8988 => {
    //   block [0x825C8988..0x825C8B24)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C8B28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C8B28 size=76
    let mut pc: u32 = 0x825C8B28;
    'dispatch: loop {
        match pc {
            0x825C8B28 => {
    //   block [0x825C8B28..0x825C8B74)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C8B74(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825C8B74 size=28
    let mut pc: u32 = 0x825C8B74;
    'dispatch: loop {
        match pc {
            0x825C8B74 => {
    //   block [0x825C8B74..0x825C8B90)
	// 825C8B74: C1A1FFF4  lfs f13, -0xc(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C8B78: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 825C8B7C: 41980014  blt cr6, 0x825c8b90
	if ctx.cr[6].lt {
		sub_825C8B90(ctx, base);
		return;
	}
	// 825C8B80: 100D000A  vaddfp v0, v13, v0
	ctx.fpscr.enable_flush_mode_unconditional();
	for i in 0..4 {
		ctx.v[0].f32[i] = ctx.v[13].f32[i] + ctx.v[0].f32[i];
	}
	// 825C8B84: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C8B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825C8B90 size=36
    let mut pc: u32 = 0x825C8B90;
    'dispatch: loop {
        match pc {
            0x825C8B90 => {
    //   block [0x825C8B90..0x825C8BB4)
	// 825C8B90: 3961FFF4  addi r11, r1, -0xc
	ctx.r[11].s64 = ctx.r[1].s64 + -12;
	// 825C8B94: EC006824  fdivs f0, f0, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 825C8B98: D001FFF4  stfs f0, -0xc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 825C8B9C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C8BB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C8BB8 size=212
    let mut pc: u32 = 0x825C8BB8;
    'dispatch: loop {
        match pc {
            0x825C8BB8 => {
    //   block [0x825C8BB8..0x825C8C8C)
	// 825C8BB8: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C8C90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C8C90 size=188
    let mut pc: u32 = 0x825C8C90;
    'dispatch: loop {
        match pc {
            0x825C8C90 => {
    //   block [0x825C8C90..0x825C8D4C)
	// 825C8C90: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C8D50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C8D50 size=324
    let mut pc: u32 = 0x825C8D50;
    'dispatch: loop {
        match pc {
            0x825C8D50 => {
    //   block [0x825C8D50..0x825C8E94)
	// 825C8D50: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C8E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C8E98 size=196
    let mut pc: u32 = 0x825C8E98;
    'dispatch: loop {
        match pc {
            0x825C8E98 => {
    //   block [0x825C8E98..0x825C8F5C)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C8F5C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C8F5C size=104
    let mut pc: u32 = 0x825C8F5C;
    'dispatch: loop {
        match pc {
            0x825C8F5C => {
    //   block [0x825C8F5C..0x825C8FC4)
	// 825C8F5C: 114A584A  vsubfp v10, v10, v11
	ctx.fpscr.enable_flush_mode_unconditional();
	for i in 0..4 {
		ctx.v[10].f32[i] = ctx.v[10].f32[i] - ctx.v[11].f32[i];
	}
	// 825C8F60: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 825C8F64: FF0A6800  fcmpu cr6, f10, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[13].f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C8FC4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825C8FC4 size=12
    let mut pc: u32 = 0x825C8FC4;
    'dispatch: loop {
        match pc {
            0x825C8FC4 => {
    //   block [0x825C8FC4..0x825C8FD0)
	// 825C8FC4: D0070000  stfs f0, 0(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825C8FC8: D0070008  stfs f0, 8(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 825C8FCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C8FD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C8FD0 size=56
    let mut pc: u32 = 0x825C8FD0;
    'dispatch: loop {
        match pc {
            0x825C8FD0 => {
    //   block [0x825C8FD0..0x825C9008)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C9008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825C9008 size=68
    let mut pc: u32 = 0x825C9008;
    'dispatch: loop {
        match pc {
            0x825C9008 => {
    //   block [0x825C9008..0x825C904C)
	// 825C9008: C181FFF0  lfs f12, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825C900C: 3961FFF8  addi r11, r1, -8
	ctx.r[11].s64 = ctx.r[1].s64 + -8;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C904C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C904C size=48
    let mut pc: u32 = 0x825C904C;
    'dispatch: loop {
        match pc {
            0x825C904C => {
    //   block [0x825C904C..0x825C907C)
	// 825C904C: 1000604A  vsubfp v0, v0, v12
	ctx.fpscr.enable_flush_mode_unconditional();
	for i in 0..4 {
		ctx.v[0].f32[i] = ctx.v[0].f32[i] - ctx.v[12].f32[i];
	}
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C9080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C9080 size=896
    let mut pc: u32 = 0x825C9080;
    'dispatch: loop {
        match pc {
            0x825C9080 => {
    //   block [0x825C9080..0x825C9400)
	// 825C9080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C9084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825C9088: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825C908C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825C9090: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C9094: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 825C9098: 113F038C  vspltisw v9, -1
	for i in 0..4 {
		ctx.v[9].u32[i] = 4294967295;
	}
	// 825C909C: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 825C90A0: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 825C90A4: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 825C90A8: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C9400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C9400 size=1380
    let mut pc: u32 = 0x825C9400;
    'dispatch: loop {
        match pc {
            0x825C9400 => {
    //   block [0x825C9400..0x825C9964)
	// 825C9400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C9404: 4BF6BCB5  bl 0x825350b8
	ctx.lr = 0x825C9408;
	sub_82535080(ctx, base);
	// 825C9408: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 825C940C: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 825C9410: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 825C9414: 3BE50010  addi r31, r5, 0x10
	ctx.r[31].s64 = ctx.r[5].s64 + 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C9968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C9968 size=324
    let mut pc: u32 = 0x825C9968;
    'dispatch: loop {
        match pc {
            0x825C9968 => {
    //   block [0x825C9968..0x825C9AAC)
	// 825C9968: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C9AB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C9AB0 size=588
    let mut pc: u32 = 0x825C9AB0;
    'dispatch: loop {
        match pc {
            0x825C9AB0 => {
    //   block [0x825C9AB0..0x825C9CFC)
	// 825C9AB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C9AB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825C9AB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825C9ABC: DBA1FFD8  stfd f29, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[29].u64 ) };
	// 825C9AC0: DBC1FFE0  stfd f30, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 825C9AC4: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 825C9AC8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C9ACC: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C9D00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C9D00 size=2656
    let mut pc: u32 = 0x825C9D00;
    'dispatch: loop {
        match pc {
            0x825C9D00 => {
    //   block [0x825C9D00..0x825CA760)
	// 825C9D00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C9D04: 4BF6B389  bl 0x8253508c
	ctx.lr = 0x825C9D08;
	sub_82535080(ctx, base);
	// 825C9D08: 3981FF80  addi r12, r1, -0x80
	ctx.r[12].s64 = ctx.r[1].s64 + -128;
	// 825C9D0C: 4BF6C2D9  bl 0x82535fe4
	ctx.lr = 0x825C9D10;
	sub_82535FB0(ctx, base);
	// 825C9D10: 3980FF40  li r12, -0xc0
	ctx.r[12].s64 = -192;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825CA760 size=36
    let mut pc: u32 = 0x825CA760;
    'dispatch: loop {
        match pc {
            0x825CA760 => {
    //   block [0x825CA760..0x825CA784)
	// 825CA760: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825CA764: 546AE000  rlwinm r10, r3, 0x1c, 0, 0
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x0000000Fu64;
	// 825CA768: C00B1850  lfs f0, 0x1850(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825CA76C: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 825CA770: 8161FFF0  lwz r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 825CA774: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 825CA778: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 825CA77C: C021FFF0  lfs f1, -0x10(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825CA780: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CA788 size=200
    let mut pc: u32 = 0x825CA788;
    'dispatch: loop {
        match pc {
            0x825CA788 => {
    //   block [0x825CA788..0x825CA7DC)
	// 825CA788: 7C8B2670  srawi r11, r4, 4
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[4].s32 >> 4) as i64;
	// 825CA78C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 825CA790: 7D6A58F8  nor r10, r11, r11
	ctx.r[10].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 825CA794: 7D6958F8  nor r9, r11, r11
	ctx.r[9].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 825CA798: 7D6B58F8  nor r11, r11, r11
	ctx.r[11].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 825CA79C: 5547EFFE  rlwinm r7, r10, 0x1d, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 825CA7A0: 5526F7FE  rlwinm r6, r9, 0x1e, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 825CA7A4: 556BFFFE  rlwinm r11, r11, 0x1f, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 825CA7A8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825CA7AC: 419A0030  beq cr6, 0x825ca7dc
	if ctx.cr[6].eq {
	pc = 0x825CA7DC; continue 'dispatch;
	}
	// 825CA7B0: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825CA7B4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA7B8: 7D293214  add r9, r9, r6
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[6].u64;
	// 825CA7BC: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825CA7C0: 7D094830  slw r9, r8, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[8].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 825CA7C4: 5524083C  slwi r4, r9, 1
	ctx.r[4].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 825CA7C8: 7C845038  and r4, r4, r10
	ctx.r[4].u64 = ctx.r[4].u64 & ctx.r[10].u64;
	// 825CA7CC: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 825CA7D0: 409A000C  bne cr6, 0x825ca7dc
	if !ctx.cr[6].eq {
	pc = 0x825CA7DC; continue 'dispatch;
	}
	// 825CA7D4: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825CA7D8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x825CA7DC; continue 'dispatch;
            }
            0x825CA7DC => {
    //   block [0x825CA7DC..0x825CA814)
	// 825CA7DC: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 825CA7E0: 419A0034  beq cr6, 0x825ca814
	if ctx.cr[6].eq {
	pc = 0x825CA814; continue 'dispatch;
	}
	// 825CA7E4: 394B0002  addi r10, r11, 2
	ctx.r[10].s64 = ctx.r[11].s64 + 2;
	// 825CA7E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA7EC: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825CA7F0: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 825CA7F4: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825CA7F8: 7D0A5030  slw r10, r8, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[8].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 825CA7FC: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825CA800: 7D295838  and r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 & ctx.r[11].u64;
	// 825CA804: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825CA808: 409A000C  bne cr6, 0x825ca814
	if !ctx.cr[6].eq {
	pc = 0x825CA814; continue 'dispatch;
	}
	// 825CA80C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825CA810: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x825CA814; continue 'dispatch;
            }
            0x825CA814 => {
    //   block [0x825CA814..0x825CA850)
	// 825CA814: 2F050002  cmpwi cr6, r5, 2
	ctx.cr[6].compare_i32(ctx.r[5].s32, 2, &mut ctx.xer);
	// 825CA818: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 825CA81C: 39460004  addi r10, r6, 4
	ctx.r[10].s64 = ctx.r[6].s64 + 4;
	// 825CA820: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA824: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825CA828: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 825CA82C: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825CA830: 7D0A5030  slw r10, r8, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[8].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 825CA834: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825CA838: 7D295838  and r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 & ctx.r[11].u64;
	// 825CA83C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825CA840: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 825CA844: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825CA848: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CA84C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CA850 size=92
    let mut pc: u32 = 0x825CA850;
    'dispatch: loop {
        match pc {
            0x825CA850 => {
    //   block [0x825CA850..0x825CA8AC)
	// 825CA850: 7C8B2670  srawi r11, r4, 4
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[4].s32 >> 4) as i64;
	// 825CA854: 5488073E  clrlwi r8, r4, 0x1c
	ctx.r[8].u64 = ctx.r[4].u32 as u64 & 0x0000000Fu64;
	// 825CA858: 7D6A58F8  nor r10, r11, r11
	ctx.r[10].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 825CA85C: 7D6958F8  nor r9, r11, r11
	ctx.r[9].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 825CA860: 7D6758F8  nor r7, r11, r11
	ctx.r[7].u64 = !(ctx.r[11].u64 | ctx.r[11].u64);
	// 825CA864: 554BEFFE  rlwinm r11, r10, 0x1d, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 825CA868: 552AF7FE  rlwinm r10, r9, 0x1e, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 825CA86C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 825CA870: 54E9FFFE  rlwinm r9, r7, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 825CA874: 409A0038  bne cr6, 0x825ca8ac
	if !ctx.cr[6].eq {
		sub_825CA8AC(ctx, base);
		return;
	}
	// 825CA878: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825CA87C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA880: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825CA884: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 825CA888: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825CA88C: 7D0A5030  slw r10, r8, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[8].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 825CA890: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825CA894: 7D295838  and r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 & ctx.r[11].u64;
	// 825CA898: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825CA89C: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 825CA8A0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825CA8A4: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CA8A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA8AC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CA8AC size=68
    let mut pc: u32 = 0x825CA8AC;
    'dispatch: loop {
        match pc {
            0x825CA8AC => {
    //   block [0x825CA8AC..0x825CA8C0)
	// 825CA8AC: 2F080001  cmpwi cr6, r8, 1
	ctx.cr[6].compare_i32(ctx.r[8].s32, 1, &mut ctx.xer);
	// 825CA8B0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825CA8B4: 39290002  addi r9, r9, 2
	ctx.r[9].s64 = ctx.r[9].s64 + 2;
	// 825CA8B8: 419A0008  beq cr6, 0x825ca8c0
	if ctx.cr[6].eq {
	pc = 0x825CA8C0; continue 'dispatch;
	}
	// 825CA8BC: 392A0004  addi r9, r10, 4
	ctx.r[9].s64 = ctx.r[10].s64 + 4;
	pc = 0x825CA8C0; continue 'dispatch;
            }
            0x825CA8C0 => {
    //   block [0x825CA8C0..0x825CA8F0)
	// 825CA8C0: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825CA8C4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA8C8: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825CA8CC: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825CA8D0: 7D0B5830  slw r11, r8, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[8].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 825CA8D4: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825CA8D8: 7D295038  and r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 & ctx.r[10].u64;
	// 825CA8DC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825CA8E0: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 825CA8E4: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825CA8E8: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CA8EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


