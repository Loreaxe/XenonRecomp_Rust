pub fn sub_828F9AE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F9AE0 size=60
    let mut pc: u32 = 0x828F9AE0;
    'dispatch: loop {
        match pc {
            0x828F9AE0 => {
    //   block [0x828F9AE0..0x828F9B1C)
	// 828F9AE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F9AE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F9AE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F9AEC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F9AF0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828F9AF4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828F9AF8: 388B93C8  addi r4, r11, -0x6c38
	ctx.r[4].s64 = ctx.r[11].s64 + -27704;
	// 828F9AFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F9B00: 4B9333D1  bl 0x8222ced0
	ctx.lr = 0x828F9B04;
	sub_8222CED0(ctx, base);
	// 828F9B04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F9B08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F9B0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F9B10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F9B14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F9B18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F9B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F9B20 size=124
    let mut pc: u32 = 0x828F9B20;
    'dispatch: loop {
        match pc {
            0x828F9B20 => {
    //   block [0x828F9B20..0x828F9B48)
	// 828F9B20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F9B24: 483AF8E9  bl 0x82ca940c
	ctx.lr = 0x828F9B28;
	sub_82CA93D0(ctx, base);
	// 828F9B28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F9B2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F9B30: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828F9B34: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 828F9B38: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828F9B3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F9B40: 419A0008  beq cr6, 0x828f9b48
	if ctx.cr[6].eq {
	pc = 0x828F9B48; continue 'dispatch;
	}
	// 828F9B44: 4B9221F5  bl 0x8221bd38
	ctx.lr = 0x828F9B48;
	sub_8221BD38(ctx, base);
	pc = 0x828F9B48; continue 'dispatch;
            }
            0x828F9B48 => {
    //   block [0x828F9B48..0x828F9B64)
	// 828F9B48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F9B4C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F9B50: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828F9B54: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828F9B58: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 828F9B5C: 419A0008  beq cr6, 0x828f9b64
	if ctx.cr[6].eq {
	pc = 0x828F9B64; continue 'dispatch;
	}
	// 828F9B60: 397F000C  addi r11, r31, 0xc
	ctx.r[11].s64 = ctx.r[31].s64 + 12;
	pc = 0x828F9B64; continue 'dispatch;
            }
            0x828F9B64 => {
    //   block [0x828F9B64..0x828F9B94)
	// 828F9B64: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 828F9B68: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 828F9B6C: 390A388C  addi r8, r10, 0x388c
	ctx.r[8].s64 = ctx.r[10].s64 + 14476;
	// 828F9B70: 38E92850  addi r7, r9, 0x2850
	ctx.r[7].s64 = ctx.r[9].s64 + 10320;
	// 828F9B74: 57A607FE  clrlwi r6, r29, 0x1f
	ctx.r[6].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	// 828F9B78: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828F9B7C: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 828F9B80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F9B84: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 828F9B88: 419A000C  beq cr6, 0x828f9b94
	if ctx.cr[6].eq {
	pc = 0x828F9B94; continue 'dispatch;
	}
	// 828F9B8C: 4B9221AD  bl 0x8221bd38
	ctx.lr = 0x828F9B90;
	sub_8221BD38(ctx, base);
	// 828F9B90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x828F9B94; continue 'dispatch;
            }
            0x828F9B94 => {
    //   block [0x828F9B94..0x828F9B9C)
	// 828F9B94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F9B98: 483AF8C4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F9BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F9BA0 size=1004
    let mut pc: u32 = 0x828F9BA0;
    'dispatch: loop {
        match pc {
            0x828F9BA0 => {
    //   block [0x828F9BA0..0x828F9BFC)
	// 828F9BA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F9BA4: 483AF82D  bl 0x82ca93d0
	ctx.lr = 0x828F9BA8;
	sub_82CA93D0(ctx, base);
	// 828F9BA8: DBC1FF58  stfd f30, -0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.f[30].u64 ) };
	// 828F9BAC: DBE1FF60  stfd f31, -0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 828F9BB0: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F9BB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F9BB8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828F9BBC: 93E101A4  stw r31, 0x1a4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(420 as u32), ctx.r[31].u32 ) };
	// 828F9BC0: 7FCFF378  mr r15, r30
	ctx.r[15].u64 = ctx.r[30].u64;
	// 828F9BC4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F9BC8: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F9BCC: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 828F9BD0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828F9BD4: 419A00D8  beq cr6, 0x828f9cac
	if ctx.cr[6].eq {
	pc = 0x828F9CAC; continue 'dispatch;
	}
	// 828F9BD8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F9BDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F9BE0: 419A001C  beq cr6, 0x828f9bfc
	if ctx.cr[6].eq {
	pc = 0x828F9BFC; continue 'dispatch;
	}
	// 828F9BE4: 894A0003  lbz r10, 3(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(3 as u32) ) } as u64;
	// 828F9BE8: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F9BEC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828F9BF0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828F9BF4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F9BF8: 480000B0  b 0x828f9ca8
	pc = 0x828F9CA8; continue 'dispatch;
            }
            0x828F9BFC => {
    //   block [0x828F9BFC..0x828F9C18)
	// 828F9BFC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F9C00: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 828F9C04: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828F9C08: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828F9C0C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828F9C10: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F9C14: 40810054  ble 0x828f9c68
	if !ctx.cr[0].gt {
	pc = 0x828F9C68; continue 'dispatch;
	}
	pc = 0x828F9C18; continue 'dispatch;
            }
            0x828F9C18 => {
    //   block [0x828F9C18..0x828F9C38)
	// 828F9C18: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828F9C1C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828F9C20: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828F9C24: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F9C28: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 828F9C2C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828F9C30: 41980008  blt cr6, 0x828f9c38
	if ctx.cr[6].lt {
	pc = 0x828F9C38; continue 'dispatch;
	}
	// 828F9C34: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x828F9C38; continue 'dispatch;
            }
            0x828F9C38 => {
    //   block [0x828F9C38..0x828F9C54)
	// 828F9C38: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828F9C3C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828F9C40: 419A0014  beq cr6, 0x828f9c54
	if ctx.cr[6].eq {
	pc = 0x828F9C54; continue 'dispatch;
	}
	// 828F9C44: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828F9C48: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828F9C4C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828F9C50: 4800000C  b 0x828f9c5c
	pc = 0x828F9C5C; continue 'dispatch;
            }
            0x828F9C54 => {
    //   block [0x828F9C54..0x828F9C5C)
	// 828F9C54: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828F9C58: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828F9C5C; continue 'dispatch;
            }
            0x828F9C5C => {
    //   block [0x828F9C5C..0x828F9C68)
	// 828F9C5C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F9C60: 4199FFB8  bgt cr6, 0x828f9c18
	if ctx.cr[6].gt {
	pc = 0x828F9C18; continue 'dispatch;
	}
	// 828F9C64: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x828F9C68; continue 'dispatch;
            }
            0x828F9C68 => {
    //   block [0x828F9C68..0x828F9C84)
	// 828F9C68: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828F9C6C: 419A0034  beq cr6, 0x828f9ca0
	if ctx.cr[6].eq {
	pc = 0x828F9CA0; continue 'dispatch;
	}
	// 828F9C70: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F9C74: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 828F9C78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F9C7C: 41990008  bgt cr6, 0x828f9c84
	if ctx.cr[6].gt {
	pc = 0x828F9C84; continue 'dispatch;
	}
	// 828F9C80: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x828F9C84; continue 'dispatch;
            }
            0x828F9C84 => {
    //   block [0x828F9C84..0x828F9CA0)
	// 828F9C84: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F9C88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F9C8C: 409A0014  bne cr6, 0x828f9ca0
	if !ctx.cr[6].eq {
	pc = 0x828F9CA0; continue 'dispatch;
	}
	// 828F9C90: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828F9C94: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828F9C98: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F9C9C: 48000008  b 0x828f9ca4
	pc = 0x828F9CA4; continue 'dispatch;
            }
            0x828F9CA0 => {
    //   block [0x828F9CA0..0x828F9CA4)
	// 828F9CA0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x828F9CA4; continue 'dispatch;
            }
            0x828F9CA4 => {
    //   block [0x828F9CA4..0x828F9CA8)
	// 828F9CA4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x828F9CA8; continue 'dispatch;
            }
            0x828F9CA8 => {
    //   block [0x828F9CA8..0x828F9CAC)
	// 828F9CA8: 7D6F5B78  mr r15, r11
	ctx.r[15].u64 = ctx.r[11].u64;
	pc = 0x828F9CAC; continue 'dispatch;
            }
            0x828F9CAC => {
    //   block [0x828F9CAC..0x828F9CBC)
	// 828F9CAC: 396F0024  addi r11, r15, 0x24
	ctx.r[11].s64 = ctx.r[15].s64 + 36;
	// 828F9CB0: 394100C0  addi r10, r1, 0xc0
	ctx.r[10].s64 = ctx.r[1].s64 + 192;
	// 828F9CB4: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
	// 828F9CB8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x828F9CBC; continue 'dispatch;
            }
            0x828F9CBC => {
    //   block [0x828F9CBC..0x828F9D60)
	// 828F9CBC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F9CC0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828F9CC4: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828F9CC8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 828F9CCC: 4200FFF0  bdnz 0x828f9cbc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828F9CBC; continue 'dispatch;
	}
	// 828F9CD0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828F9CD4: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828F9CD8: 388B4C90  addi r4, r11, 0x4c90
	ctx.r[4].s64 = ctx.r[11].s64 + 19600;
	// 828F9CDC: 4B9AFD0D  bl 0x822a99e8
	ctx.lr = 0x828F9CE0;
	sub_822A99E8(ctx, base);
	// 828F9CE0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F9CE4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828F9CE8: 419A0270  beq cr6, 0x828f9f58
	if ctx.cr[6].eq {
	pc = 0x828F9F58; continue 'dispatch;
	}
	// 828F9CEC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828F9CF0: 48106CA1  bl 0x82a00990
	ctx.lr = 0x828F9CF4;
	sub_82A00990(ctx, base);
	// 828F9CF4: 3BBF0010  addi r29, r31, 0x10
	ctx.r[29].s64 = ctx.r[31].s64 + 16;
	// 828F9CF8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F9CFC: 8201006C  lwz r16, 0x6c(r1)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828F9D00: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 828F9D04: 480014A5  bl 0x828fb1a8
	ctx.lr = 0x828F9D08;
	sub_828FB1A8(ctx, base);
	// 828F9D08: 83810070  lwz r28, 0x70(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828F9D0C: 82410068  lwz r18, 0x68(r1)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828F9D10: 7F1C8040  cmplw cr6, r28, r16
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[16].u32, &mut ctx.xer);
	// 828F9D14: 419A023C  beq cr6, 0x828f9f50
	if ctx.cr[6].eq {
	pc = 0x828F9F50; continue 'dispatch;
	}
	// 828F9D18: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828F9D1C: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 828F9D20: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828F9D24: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 828F9D28: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828F9D2C: C3CB9484  lfs f30, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828F9D30: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828F9D34: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828F9D38: 3AA0FFFF  li r21, -1
	ctx.r[21].s64 = -1;
	// 828F9D3C: 3EC08349  lis r22, -0x7cb7
	ctx.r[22].s64 = -2092367872;
	// 828F9D40: 3A202000  li r17, 0x2000
	ctx.r[17].s64 = 8192;
	// 828F9D44: 3E60834A  lis r19, -0x7cb6
	ctx.r[19].s64 = -2092302336;
	// 828F9D48: 3A87E460  addi r20, r7, -0x1ba0
	ctx.r[20].s64 = ctx.r[7].s64 + -7072;
	// 828F9D4C: 3B464CE4  addi r26, r6, 0x4ce4
	ctx.r[26].s64 = ctx.r[6].s64 + 19684;
	// 828F9D50: 3B285F1C  addi r25, r8, 0x5f1c
	ctx.r[25].s64 = ctx.r[8].s64 + 24348;
	// 828F9D54: 3B094CC0  addi r24, r9, 0x4cc0
	ctx.r[24].s64 = ctx.r[9].s64 + 19648;
	// 828F9D58: 3AEA4CA8  addi r23, r10, 0x4ca8
	ctx.r[23].s64 = ctx.r[10].s64 + 19624;
	// 828F9D5C: 3B6B4C9C  addi r27, r11, 0x4c9c
	ctx.r[27].s64 = ctx.r[11].s64 + 19612;
	pc = 0x828F9D60; continue 'dispatch;
            }
            0x828F9D60 => {
    //   block [0x828F9D60..0x828F9D9C)
	// 828F9D60: 578B083C  slwi r11, r28, 1
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828F9D64: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 828F9D68: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828F9D6C: 7D6B9214  add r11, r11, r18
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[18].u64;
	// 828F9D70: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F9D74: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F9D78: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 828F9D7C: 419A0020  beq cr6, 0x828f9d9c
	if ctx.cr[6].eq {
	pc = 0x828F9D9C; continue 'dispatch;
	}
	// 828F9D80: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 828F9D84: 409A0018  bne cr6, 0x828f9d9c
	if !ctx.cr[6].eq {
	pc = 0x828F9D9C; continue 'dispatch;
	}
	// 828F9D88: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F9D8C: 8133E454  lwz r9, -0x1bac(r19)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 828F9D90: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828F9D94: 409A0008  bne cr6, 0x828f9d9c
	if !ctx.cr[6].eq {
	pc = 0x828F9D9C; continue 'dispatch;
	}
	// 828F9D98: 7E8AA378  mr r10, r20
	ctx.r[10].u64 = ctx.r[20].u64;
	pc = 0x828F9D9C; continue 'dispatch;
            }
            0x828F9D9C => {
    //   block [0x828F9D9C..0x828F9E00)
	// 828F9D9C: 80766DA0  lwz r3, 0x6da0(r22)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(28064 as u32) ) } as u64;
	// 828F9DA0: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F9DA4: 4B8EA4AD  bl 0x821e4250
	ctx.lr = 0x828F9DA8;
	sub_821E4250(ctx, base);
	// 828F9DA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F9DAC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F9DB0: 419A0190  beq cr6, 0x828f9f40
	if ctx.cr[6].eq {
	pc = 0x828F9F40; continue 'dispatch;
	}
	// 828F9DB4: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 828F9DB8: 93C1008C  stw r30, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[30].u32 ) };
	// 828F9DBC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828F9DC0: 93C100B8  stw r30, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[30].u32 ) };
	// 828F9DC4: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 828F9DC8: 9BC100BC  stb r30, 0xbc(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[30].u8 ) };
	// 828F9DCC: 92A10080  stw r21, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[21].u32 ) };
	// 828F9DD0: 39C10058  addi r14, r1, 0x58
	ctx.r[14].s64 = ctx.r[1].s64 + 88;
	// 828F9DD4: 4B8F9F85  bl 0x821f3d58
	ctx.lr = 0x828F9DD8;
	sub_821F3D58(ctx, base);
	// 828F9DD8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F9DDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F9DE0: 7DC57378  mr r5, r14
	ctx.r[5].u64 = ctx.r[14].u64;
	// 828F9DE4: 4B8EBC25  bl 0x821e5a08
	ctx.lr = 0x828F9DE8;
	sub_821E5A08(ctx, base);
	// 828F9DE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F9DEC: 419A0014  beq cr6, 0x828f9e00
	if ctx.cr[6].eq {
	pc = 0x828F9E00; continue 'dispatch;
	}
	// 828F9DF0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F9DF4: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 828F9DF8: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828F9DFC: 693E0001  xori r30, r9, 1
	ctx.r[30].u64 = ctx.r[9].u64 ^ 1;
	pc = 0x828F9E00; continue 'dispatch;
            }
            0x828F9E00 => {
    //   block [0x828F9E00..0x828F9E18)
	// 828F9E00: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 828F9E04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F9E08: 419A0010  beq cr6, 0x828f9e18
	if ctx.cr[6].eq {
	pc = 0x828F9E18; continue 'dispatch;
	}
	// 828F9E0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F9E10: 922100B8  stw r17, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[17].u32 ) };
	// 828F9E14: 996100BC  stb r11, 0xbc(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[11].u8 ) };
	pc = 0x828F9E18; continue 'dispatch;
            }
            0x828F9E18 => {
    //   block [0x828F9E18..0x828F9E28)
	// 828F9E18: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 828F9E1C: 396100C0  addi r11, r1, 0xc0
	ctx.r[11].s64 = ctx.r[1].s64 + 192;
	// 828F9E20: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
	// 828F9E24: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x828F9E28; continue 'dispatch;
            }
            0x828F9E28 => {
    //   block [0x828F9E28..0x828F9E64)
	// 828F9E28: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F9E2C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828F9E30: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828F9E34: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 828F9E38: 4200FFF0  bdnz 0x828f9e28
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828F9E28; continue 'dispatch;
	}
	// 828F9E3C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 828F9E40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F9E44: 4B89CD3D  bl 0x82196b80
	ctx.lr = 0x828F9E48;
	sub_82196B80(ctx, base);
	// 828F9E48: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828F9E4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F9E50: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828F9E54: 4B89CD2D  bl 0x82196b80
	ctx.lr = 0x828F9E58;
	sub_82196B80(ctx, base);
	// 828F9E58: FF1FF000  fcmpu cr6, f31, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 828F9E5C: 40990008  ble cr6, 0x828f9e64
	if !ctx.cr[6].gt {
	pc = 0x828F9E64; continue 'dispatch;
	}
	// 828F9E60: D3E10094  stfs f31, 0x94(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	pc = 0x828F9E64; continue 'dispatch;
            }
            0x828F9E64 => {
    //   block [0x828F9E64..0x828F9E78)
	// 828F9E64: 894100BC  lbz r10, 0xbc(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 828F9E68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828F9E6C: 419A000C  beq cr6, 0x828f9e78
	if ctx.cr[6].eq {
	pc = 0x828F9E78; continue 'dispatch;
	}
	// 828F9E70: D3C10090  stfs f30, 0x90(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 828F9E74: 48000010  b 0x828f9e84
	pc = 0x828F9E84; continue 'dispatch;
            }
            0x828F9E78 => {
    //   block [0x828F9E78..0x828F9E84)
	// 828F9E78: FF01F000  fcmpu cr6, f1, f30
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[30].f64);
	// 828F9E7C: 41980008  blt cr6, 0x828f9e84
	if ctx.cr[6].lt {
	pc = 0x828F9E84; continue 'dispatch;
	}
	// 828F9E80: D0210090  stfs f1, 0x90(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	pc = 0x828F9E84; continue 'dispatch;
            }
            0x828F9E84 => {
    //   block [0x828F9E84..0x828F9ED0)
	// 828F9E84: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 828F9E88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F9E8C: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 828F9E90: 4BE89589  bl 0x82783418
	ctx.lr = 0x828F9E94;
	sub_82783418(ctx, base);
	// 828F9E94: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F9E98: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 828F9E9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F9EA0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F9EA4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F9EA8: 91410084  stw r10, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 828F9EAC: 4BE8956D  bl 0x82783418
	ctx.lr = 0x828F9EB0;
	sub_82783418(ctx, base);
	// 828F9EB0: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F9EB4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828F9EB8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F9EBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F9EC0: 91210088  stw r9, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[9].u32 ) };
	// 828F9EC4: 409A000C  bne cr6, 0x828f9ed0
	if !ctx.cr[6].eq {
	pc = 0x828F9ED0; continue 'dispatch;
	}
	// 828F9EC8: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 828F9ECC: 48000010  b 0x828f9edc
	pc = 0x828F9EDC; continue 'dispatch;
            }
            0x828F9ED0 => {
    //   block [0x828F9ED0..0x828F9EDC)
	// 828F9ED0: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F9ED4: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828F9ED8: 7D293670  srawi r9, r9, 6
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 6) as i64;
	pc = 0x828F9EDC; continue 'dispatch;
            }
            0x828F9EDC => {
    //   block [0x828F9EDC..0x828F9F14)
	// 828F9EDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F9EE0: 419A0034  beq cr6, 0x828f9f14
	if ctx.cr[6].eq {
	pc = 0x828F9F14; continue 'dispatch;
	}
	// 828F9EE4: 815D000C  lwz r10, 0xc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 828F9EE8: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828F9EEC: 7D0A3670  srawi r10, r8, 6
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 6) as i64;
	// 828F9EF0: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828F9EF4: 40980020  bge cr6, 0x828f9f14
	if !ctx.cr[6].lt {
	pc = 0x828F9F14; continue 'dispatch;
	}
	// 828F9EF8: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 828F9EFC: 809D0008  lwz r4, 8(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F9F00: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828F9F04: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F9F08: 48001469  bl 0x828fb370
	ctx.lr = 0x828F9F0C;
	sub_828FB370(ctx, base);
	// 828F9F0C: 907D0008  stw r3, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 828F9F10: 48000030  b 0x828f9f40
	pc = 0x828F9F40; continue 'dispatch;
            }
            0x828F9F14 => {
    //   block [0x828F9F14..0x828F9F24)
	// 828F9F14: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F9F18: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828F9F1C: 40990008  ble cr6, 0x828f9f24
	if !ctx.cr[6].gt {
	pc = 0x828F9F24; continue 'dispatch;
	}
	// 828F9F20: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828F9F24; continue 'dispatch;
            }
            0x828F9F24 => {
    //   block [0x828F9F24..0x828F9F40)
	// 828F9F24: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 828F9F28: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F9F2C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F9F30: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828F9F34: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828F9F38: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828F9F3C: 48001355  bl 0x828fb290
	ctx.lr = 0x828F9F40;
	sub_828FB290(ctx, base);
	pc = 0x828F9F40; continue 'dispatch;
            }
            0x828F9F40 => {
    //   block [0x828F9F40..0x828F9F50)
	// 828F9F40: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 828F9F44: 7F1C8040  cmplw cr6, r28, r16
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[16].u32, &mut ctx.xer);
	// 828F9F48: 409AFE18  bne cr6, 0x828f9d60
	if !ctx.cr[6].eq {
	pc = 0x828F9D60; continue 'dispatch;
	}
	// 828F9F4C: 83E101A4  lwz r31, 0x1a4(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(420 as u32) ) } as u64;
	pc = 0x828F9F50; continue 'dispatch;
            }
            0x828F9F50 => {
    //   block [0x828F9F50..0x828F9F58)
	// 828F9F50: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 828F9F54: 4B921DE5  bl 0x8221bd38
	ctx.lr = 0x828F9F58;
	sub_8221BD38(ctx, base);
	pc = 0x828F9F58; continue 'dispatch;
            }
            0x828F9F58 => {
    //   block [0x828F9F58..0x828F9F8C)
	// 828F9F58: 397F000C  addi r11, r31, 0xc
	ctx.r[11].s64 = ctx.r[31].s64 + 12;
	// 828F9F5C: 814F0010  lwz r10, 0x10(r15)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(16 as u32) ) } as u64;
	// 828F9F60: 386F000C  addi r3, r15, 0xc
	ctx.r[3].s64 = ctx.r[15].s64 + 12;
	// 828F9F64: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828F9F68: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828F9F6C: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828F9F70: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828F9F74: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828F9F78: 4819D3F1  bl 0x82a97368
	ctx.lr = 0x828F9F7C;
	sub_82A97368(ctx, base);
	// 828F9F7C: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 828F9F80: CBC1FF58  lfd f30, -0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-168 as u32) ) };
	// 828F9F84: CBE1FF60  lfd f31, -0xa0(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 828F9F88: 483AF498  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F9F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F9F90 size=1960
    let mut pc: u32 = 0x828F9F90;
    'dispatch: loop {
        match pc {
            0x828F9F90 => {
    //   block [0x828F9F90..0x828F9FE4)
	// 828F9F90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F9F94: 483AF449  bl 0x82ca93dc
	ctx.lr = 0x828F9F98;
	sub_82CA93D0(ctx, base);
	// 828F9F98: 9421FE10  stwu r1, -0x1f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-496 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F9F9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F9FA0: 7C922378  mr r18, r4
	ctx.r[18].u64 = ctx.r[4].u64;
	// 828F9FA4: 7CB32B78  mr r19, r5
	ctx.r[19].u64 = ctx.r[5].u64;
	// 828F9FA8: 3B1E0004  addi r24, r30, 4
	ctx.r[24].s64 = ctx.r[30].s64 + 4;
	// 828F9FAC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F9FB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F9FB4: 419A077C  beq cr6, 0x828fa730
	if ctx.cr[6].eq {
	pc = 0x828FA730; continue 'dispatch;
	}
	// 828F9FB8: 81580008  lwz r10, 8(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F9FBC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828F9FC0: 7D2B3671  srawi. r11, r9, 6
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 6) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F9FC4: 4182076C  beq 0x828fa730
	if ctx.cr[0].eq {
	pc = 0x828FA730; continue 'dispatch;
	}
	// 828F9FC8: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F9FCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F9FD0: 419A0014  beq cr6, 0x828f9fe4
	if ctx.cr[6].eq {
	pc = 0x828F9FE4; continue 'dispatch;
	}
	// 828F9FD4: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828F9FD8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828F9FDC: 7D2A3671  srawi. r10, r9, 6
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 6) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828F9FE0: 40820008  bne 0x828f9fe8
	if !ctx.cr[0].eq {
	pc = 0x828F9FE8; continue 'dispatch;
	}
	pc = 0x828F9FE4; continue 'dispatch;
            }
            0x828F9FE4 => {
    //   block [0x828F9FE4..0x828F9FE8)
	// 828F9FE4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828F9FE8; continue 'dispatch;
            }
            0x828F9FE8 => {
    //   block [0x828F9FE8..0x828FA024)
	// 828F9FE8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F9FEC: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 828F9FF0: 419A0444  beq cr6, 0x828fa434
	if ctx.cr[6].eq {
	pc = 0x828FA434; continue 'dispatch;
	}
	// 828F9FF4: 81730030  lwz r11, 0x30(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(48 as u32) ) } as u64;
	// 828F9FF8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828F9FFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FA000: 409A0434  bne cr6, 0x828fa434
	if !ctx.cr[6].eq {
	pc = 0x828FA434; continue 'dispatch;
	}
	// 828FA004: 556B07BE  clrlwi r11, r11, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 828FA008: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FA00C: 419A0080  beq cr6, 0x828fa08c
	if ctx.cr[6].eq {
	pc = 0x828FA08C; continue 'dispatch;
	}
	// 828FA010: 83F80004  lwz r31, 4(r24)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FA014: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FA018: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FA01C: 40990008  ble cr6, 0x828fa024
	if !ctx.cr[6].gt {
	pc = 0x828FA024; continue 'dispatch;
	}
	// 828FA020: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FA024; continue 'dispatch;
            }
            0x828FA024 => {
    //   block [0x828FA024..0x828FA03C)
	// 828FA024: 3B600010  li r27, 0x10
	ctx.r[27].s64 = 16;
	// 828FA028: 81580008  lwz r10, 8(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FA02C: 81380004  lwz r9, 4(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FA030: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FA034: 40990008  ble cr6, 0x828fa03c
	if !ctx.cr[6].gt {
	pc = 0x828FA03C; continue 'dispatch;
	}
	// 828FA038: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FA03C; continue 'dispatch;
            }
            0x828FA03C => {
    //   block [0x828FA03C..0x828FA048)
	// 828FA03C: 7F18C040  cmplw cr6, r24, r24
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[24].u32, &mut ctx.xer);
	// 828FA040: 419A0008  beq cr6, 0x828fa048
	if ctx.cr[6].eq {
	pc = 0x828FA048; continue 'dispatch;
	}
	// 828FA044: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FA048; continue 'dispatch;
            }
            0x828FA048 => {
    //   block [0x828FA048..0x828FA05C)
	// 828FA048: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FA04C: 419A0040  beq cr6, 0x828fa08c
	if ctx.cr[6].eq {
	pc = 0x828FA08C; continue 'dispatch;
	}
	// 828FA050: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FA054: 41980008  blt cr6, 0x828fa05c
	if ctx.cr[6].lt {
	pc = 0x828FA05C; continue 'dispatch;
	}
	// 828FA058: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FA05C; continue 'dispatch;
            }
            0x828FA05C => {
    //   block [0x828FA05C..0x828FA08C)
	// 828FA05C: 38B30020  addi r5, r19, 0x20
	ctx.r[5].s64 = ctx.r[19].s64 + 32;
	// 828FA060: 80D30030  lwz r6, 0x30(r19)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(48 as u32) ) } as u64;
	// 828FA064: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	pc = 0x828FA08C; continue 'dispatch;
            }
            0x828FA08C => {
    //   block [0x828FA08C..0x828FA434)
	// 828FA08C: 81730030  lwz r11, 0x30(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(48 as u32) ) } as u64;
	// 828FA090: 556A06F6  rlwinm r10, r11, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828FA094: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FA098: 419A0070  beq cr6, 0x828fa108
	if ctx.cr[6].eq {
	pc = 0x828FA108; continue 'dispatch;
	}
	// 828FA09C: 83F80004  lwz r31, 4(r24)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FA0A0: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FA0A4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FA0A8: 40990008  ble cr6, 0x828fa0b0
	if !ctx.cr[6].gt {
	pc = 0x828FA0B0; continue 'dispatch;
	}
	// 828FA0AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA0B0: 81580008  lwz r10, 8(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FA0B4: 81380004  lwz r9, 4(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FA0B8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FA0BC: 40990008  ble cr6, 0x828fa0c4
	if !ctx.cr[6].gt {
	pc = 0x828FA0C4; continue 'dispatch;
	}
	// 828FA0C0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA0C4: 7F18C040  cmplw cr6, r24, r24
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[24].u32, &mut ctx.xer);
	// 828FA0C8: 419A0008  beq cr6, 0x828fa0d0
	if ctx.cr[6].eq {
	pc = 0x828FA0D0; continue 'dispatch;
	}
	// 828FA0CC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA0D0: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FA0D4: 419A0034  beq cr6, 0x828fa108
	if ctx.cr[6].eq {
	pc = 0x828FA108; continue 'dispatch;
	}
	// 828FA0D8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FA0DC: 41980008  blt cr6, 0x828fa0e4
	if ctx.cr[6].lt {
	pc = 0x828FA0E4; continue 'dispatch;
	}
	// 828FA0E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA0E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FA0E8: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 828FA0EC: 4BC7896D  bl 0x82572a58
	ctx.lr = 0x828FA0F0;
	sub_82572A58(ctx, base);
	// 828FA0F0: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FA0F4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FA0F8: 41980008  blt cr6, 0x828fa100
	if ctx.cr[6].lt {
	pc = 0x828FA100; continue 'dispatch;
	}
	// 828FA0FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA100: 3BFF0040  addi r31, r31, 0x40
	ctx.r[31].s64 = ctx.r[31].s64 + 64;
	// 828FA104: 4BFFFFAC  b 0x828fa0b0
	pc = 0x828FA0B0; continue 'dispatch;
	// 828FA108: 81730030  lwz r11, 0x30(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(48 as u32) ) } as u64;
	// 828FA10C: 556A06B4  rlwinm r10, r11, 0, 0x1a, 0x1a
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828FA110: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FA114: 419A0070  beq cr6, 0x828fa184
	if ctx.cr[6].eq {
	pc = 0x828FA184; continue 'dispatch;
	}
	// 828FA118: 83F80004  lwz r31, 4(r24)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FA11C: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FA120: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FA124: 40990008  ble cr6, 0x828fa12c
	if !ctx.cr[6].gt {
	pc = 0x828FA12C; continue 'dispatch;
	}
	// 828FA128: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA12C: 81580008  lwz r10, 8(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FA130: 81380004  lwz r9, 4(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FA134: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FA138: 40990008  ble cr6, 0x828fa140
	if !ctx.cr[6].gt {
	pc = 0x828FA140; continue 'dispatch;
	}
	// 828FA13C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA140: 7F18C040  cmplw cr6, r24, r24
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[24].u32, &mut ctx.xer);
	// 828FA144: 419A0008  beq cr6, 0x828fa14c
	if ctx.cr[6].eq {
	pc = 0x828FA14C; continue 'dispatch;
	}
	// 828FA148: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA14C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FA150: 419A0034  beq cr6, 0x828fa184
	if ctx.cr[6].eq {
	pc = 0x828FA184; continue 'dispatch;
	}
	// 828FA154: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FA158: 41980008  blt cr6, 0x828fa160
	if ctx.cr[6].lt {
	pc = 0x828FA160; continue 'dispatch;
	}
	// 828FA15C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA160: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FA164: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 828FA168: 4BC78941  bl 0x82572aa8
	ctx.lr = 0x828FA16C;
	sub_82572AA8(ctx, base);
	// 828FA16C: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FA170: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FA174: 41980008  blt cr6, 0x828fa17c
	if ctx.cr[6].lt {
	pc = 0x828FA17C; continue 'dispatch;
	}
	// 828FA178: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA17C: 3BFF0040  addi r31, r31, 0x40
	ctx.r[31].s64 = ctx.r[31].s64 + 64;
	// 828FA180: 4BFFFFAC  b 0x828fa12c
	pc = 0x828FA12C; continue 'dispatch;
	// 828FA184: 81530030  lwz r10, 0x30(r19)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(48 as u32) ) } as u64;
	// 828FA188: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 828FA18C: 554905EE  rlwinm r9, r10, 0, 0x17, 0x17
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828FA190: 3B2B44B0  addi r25, r11, 0x44b0
	ctx.r[25].s64 = ctx.r[11].s64 + 17584;
	// 828FA194: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828FA198: 419A008C  beq cr6, 0x828fa224
	if ctx.cr[6].eq {
	pc = 0x828FA224; continue 'dispatch;
	}
	// 828FA19C: 83F80004  lwz r31, 4(r24)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FA1A0: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FA1A4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FA1A8: 40990008  ble cr6, 0x828fa1b0
	if !ctx.cr[6].gt {
	pc = 0x828FA1B0; continue 'dispatch;
	}
	// 828FA1AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA1B0: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 828FA1B4: 3BCA375C  addi r30, r10, 0x375c
	ctx.r[30].s64 = ctx.r[10].s64 + 14172;
	// 828FA1B8: 81580008  lwz r10, 8(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FA1BC: 81380004  lwz r9, 4(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FA1C0: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FA1C4: 40990008  ble cr6, 0x828fa1cc
	if !ctx.cr[6].gt {
	pc = 0x828FA1CC; continue 'dispatch;
	}
	// 828FA1C8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA1CC: 7F18C040  cmplw cr6, r24, r24
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[24].u32, &mut ctx.xer);
	// 828FA1D0: 419A0008  beq cr6, 0x828fa1d8
	if ctx.cr[6].eq {
	pc = 0x828FA1D8; continue 'dispatch;
	}
	// 828FA1D4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA1D8: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FA1DC: 419A0048  beq cr6, 0x828fa224
	if ctx.cr[6].eq {
	pc = 0x828FA224; continue 'dispatch;
	}
	// 828FA1E0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FA1E4: 41980008  blt cr6, 0x828fa1ec
	if ctx.cr[6].lt {
	pc = 0x828FA1EC; continue 'dispatch;
	}
	// 828FA1E8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA1EC: 897200C4  lbz r11, 0xc4(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[18].u32.wrapping_add(196 as u32) ) } as u64;
	// 828FA1F0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828FA1F4: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 828FA1F8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828FA1FC: 9961005C  stb r11, 0x5c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u8 ) };
	// 828FA200: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FA204: 4B9308C5  bl 0x8222aac8
	ctx.lr = 0x828FA208;
	sub_8222AAC8(ctx, base);
	// 828FA208: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FA20C: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 828FA210: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FA214: 41980008  blt cr6, 0x828fa21c
	if ctx.cr[6].lt {
	pc = 0x828FA21C; continue 'dispatch;
	}
	// 828FA218: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA21C: 3BFF0040  addi r31, r31, 0x40
	ctx.r[31].s64 = ctx.r[31].s64 + 64;
	// 828FA220: 4BFFFF98  b 0x828fa1b8
	pc = 0x828FA1B8; continue 'dispatch;
	// 828FA224: 81530030  lwz r10, 0x30(r19)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(48 as u32) ) } as u64;
	// 828FA228: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828FA22C: 554905AC  rlwinm r9, r10, 0, 0x16, 0x16
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828FA230: 3B4BF9B0  addi r26, r11, -0x650
	ctx.r[26].s64 = ctx.r[11].s64 + -1616;
	// 828FA234: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828FA238: 419A00E8  beq cr6, 0x828fa320
	if ctx.cr[6].eq {
	pc = 0x828FA320; continue 'dispatch;
	}
	// 828FA23C: 83D80004  lwz r30, 4(r24)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FA240: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FA244: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FA248: 40990008  ble cr6, 0x828fa250
	if !ctx.cr[6].gt {
	pc = 0x828FA250; continue 'dispatch;
	}
	// 828FA24C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA250: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 828FA254: 3B8A6EFC  addi r28, r10, 0x6efc
	ctx.r[28].s64 = ctx.r[10].s64 + 28412;
	// 828FA258: 81580008  lwz r10, 8(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FA25C: 81380004  lwz r9, 4(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FA260: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FA264: 40990008  ble cr6, 0x828fa26c
	if !ctx.cr[6].gt {
	pc = 0x828FA26C; continue 'dispatch;
	}
	// 828FA268: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA26C: 7F18C040  cmplw cr6, r24, r24
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[24].u32, &mut ctx.xer);
	// 828FA270: 419A0008  beq cr6, 0x828fa278
	if ctx.cr[6].eq {
	pc = 0x828FA278; continue 'dispatch;
	}
	// 828FA274: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA278: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FA27C: 419A00A4  beq cr6, 0x828fa320
	if ctx.cr[6].eq {
	pc = 0x828FA320; continue 'dispatch;
	}
	// 828FA280: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FA284: 41980008  blt cr6, 0x828fa28c
	if ctx.cr[6].lt {
	pc = 0x828FA28C; continue 'dispatch;
	}
	// 828FA288: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA28C: E9720050  ld r11, 0x50(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[18].u32.wrapping_add(80 as u32) ) };
	// 828FA290: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 828FA294: E9320058  ld r9, 0x58(r18)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[18].u32.wrapping_add(88 as u32) ) };
	// 828FA298: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 828FA29C: 93810080  stw r28, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[28].u32 ) };
	// 828FA2A0: 39120050  addi r8, r18, 0x50
	ctx.r[8].s64 = ctx.r[18].s64 + 80;
	// 828FA2A4: 83FA0004  lwz r31, 4(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FA2A8: F96A0000  std r11, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828FA2AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FA2B0: F92A0008  std r9, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 828FA2B4: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FA2B8: 4B9308C1  bl 0x8222ab78
	ctx.lr = 0x828FA2BC;
	sub_8222AB78(ctx, base);
	// 828FA2BC: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828FA2C0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 828FA2C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FA2C8: 4B930919  bl 0x8222abe0
	ctx.lr = 0x828FA2CC;
	sub_8222ABE0(ctx, base);
	// 828FA2CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FA2D0: 419A0008  beq cr6, 0x828fa2d8
	if ctx.cr[6].eq {
	pc = 0x828FA2D8; continue 'dispatch;
	}
	// 828FA2D4: 93A30000  stw r29, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828FA2D8: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 828FA2DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FA2E0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828FA2E4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FA2E8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FA2EC: 4E800421  bctrl
	ctx.lr = 0x828FA2F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FA2F0: 813F002C  lwz r9, 0x2c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 828FA2F4: 811F0020  lwz r8, 0x20(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 828FA2F8: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828FA2FC: 80FF0020  lwz r7, 0x20(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 828FA300: 90FF0028  stw r7, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[7].u32 ) };
	// 828FA304: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FA308: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FA30C: 93210080  stw r25, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[25].u32 ) };
	// 828FA310: 41980008  blt cr6, 0x828fa318
	if ctx.cr[6].lt {
	pc = 0x828FA318; continue 'dispatch;
	}
	// 828FA314: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA318: 3BDE0040  addi r30, r30, 0x40
	ctx.r[30].s64 = ctx.r[30].s64 + 64;
	// 828FA31C: 4BFFFF3C  b 0x828fa258
	pc = 0x828FA258; continue 'dispatch;
	// 828FA320: 81730030  lwz r11, 0x30(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(48 as u32) ) } as u64;
	// 828FA324: 556A056A  rlwinm r10, r11, 0, 0x15, 0x15
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828FA328: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FA32C: 419A0404  beq cr6, 0x828fa730
	if ctx.cr[6].eq {
	pc = 0x828FA730; continue 'dispatch;
	}
	// 828FA330: 83D80004  lwz r30, 4(r24)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FA334: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FA338: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FA33C: 40990008  ble cr6, 0x828fa344
	if !ctx.cr[6].gt {
	pc = 0x828FA344; continue 'dispatch;
	}
	// 828FA340: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA344: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 828FA348: 3B600006  li r27, 6
	ctx.r[27].s64 = 6;
	// 828FA34C: 3B8A6F14  addi r28, r10, 0x6f14
	ctx.r[28].s64 = ctx.r[10].s64 + 28436;
	// 828FA350: 81580008  lwz r10, 8(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FA354: 81380004  lwz r9, 4(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FA358: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FA35C: 40990008  ble cr6, 0x828fa364
	if !ctx.cr[6].gt {
	pc = 0x828FA364; continue 'dispatch;
	}
	// 828FA360: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA364: 7F18C040  cmplw cr6, r24, r24
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[24].u32, &mut ctx.xer);
	// 828FA368: 419A0008  beq cr6, 0x828fa370
	if ctx.cr[6].eq {
	pc = 0x828FA370; continue 'dispatch;
	}
	// 828FA36C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA370: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FA374: 419A03BC  beq cr6, 0x828fa730
	if ctx.cr[6].eq {
	pc = 0x828FA730; continue 'dispatch;
	}
	// 828FA378: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FA37C: 41980008  blt cr6, 0x828fa384
	if ctx.cr[6].lt {
	pc = 0x828FA384; continue 'dispatch;
	}
	// 828FA380: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA384: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828FA388: C012006C  lfs f0, 0x6c(r18)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FA38C: 83FA0004  lwz r31, 4(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FA390: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828FA394: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828FA398: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 828FA39C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FA3A0: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 828FA3A4: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FA3A8: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 828FA3AC: 4B930835  bl 0x8222abe0
	ctx.lr = 0x828FA3B0;
	sub_8222ABE0(ctx, base);
	// 828FA3B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FA3B4: 419A0008  beq cr6, 0x828fa3bc
	if ctx.cr[6].eq {
	pc = 0x828FA3BC; continue 'dispatch;
	}
	// 828FA3B8: 93630000  stw r27, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 828FA3BC: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828FA3C0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 828FA3C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FA3C8: 4B930819  bl 0x8222abe0
	ctx.lr = 0x828FA3CC;
	sub_8222ABE0(ctx, base);
	// 828FA3CC: 907F002C  stw r3, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[3].u32 ) };
	// 828FA3D0: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828FA3D4: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 828FA3D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FA3DC: 4B930805  bl 0x8222abe0
	ctx.lr = 0x828FA3E0;
	sub_8222ABE0(ctx, base);
	// 828FA3E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FA3E4: 419A0008  beq cr6, 0x828fa3ec
	if ctx.cr[6].eq {
	pc = 0x828FA3EC; continue 'dispatch;
	}
	// 828FA3E8: 93A30000  stw r29, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828FA3EC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FA3F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FA3F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FA3F8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FA3FC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FA400: 4E800421  bctrl
	ctx.lr = 0x828FA404;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FA404: 813F002C  lwz r9, 0x2c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 828FA408: 811F0020  lwz r8, 0x20(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 828FA40C: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828FA410: 80FF0020  lwz r7, 0x20(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 828FA414: 90FF0028  stw r7, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[7].u32 ) };
	// 828FA418: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FA41C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FA420: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 828FA424: 41980008  blt cr6, 0x828fa42c
	if ctx.cr[6].lt {
	pc = 0x828FA42C; continue 'dispatch;
	}
	// 828FA428: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA42C: 3BDE0040  addi r30, r30, 0x40
	ctx.r[30].s64 = ctx.r[30].s64 + 64;
	// 828FA430: 4BFFFF20  b 0x828fa350
	pc = 0x828FA350; continue 'dispatch;
            }
            0x828FA434 => {
    //   block [0x828FA434..0x828FA730)
	// 828FA434: 83F80004  lwz r31, 4(r24)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FA438: 80D80008  lwz r6, 8(r24)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FA43C: 82B2008C  lwz r21, 0x8c(r18)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(140 as u32) ) } as u64;
	// 828FA440: 7F1F3040  cmplw cr6, r31, r6
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828FA444: 40990008  ble cr6, 0x828fa44c
	if !ctx.cr[6].gt {
	pc = 0x828FA44C; continue 'dispatch;
	}
	// 828FA448: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA44C: 3CE0820F  lis r7, -0x7df1
	ctx.r[7].s64 = -2112946176;
	// 828FA450: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 828FA454: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 828FA458: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828FA45C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 828FA460: 3B600010  li r27, 0x10
	ctx.r[27].s64 = 16;
	// 828FA464: 3AE00001  li r23, 1
	ctx.r[23].s64 = 1;
	// 828FA468: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 828FA46C: 3A8744B0  addi r20, r7, 0x44b0
	ctx.r[20].s64 = ctx.r[7].s64 + 17584;
	// 828FA470: 3B483774  addi r26, r8, 0x3774
	ctx.r[26].s64 = ctx.r[8].s64 + 14196;
	// 828FA474: 3AC96A70  addi r22, r9, 0x6a70
	ctx.r[22].s64 = ctx.r[9].s64 + 27248;
	// 828FA478: 3B8A6A70  addi r28, r10, 0x6a70
	ctx.r[28].s64 = ctx.r[10].s64 + 27248;
	// 828FA47C: 3B2B4734  addi r25, r11, 0x4734
	ctx.r[25].s64 = ctx.r[11].s64 + 18228;
	// 828FA480: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FA484: 81580004  lwz r10, 4(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FA488: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FA48C: 40990008  ble cr6, 0x828fa494
	if !ctx.cr[6].gt {
	pc = 0x828FA494; continue 'dispatch;
	}
	// 828FA490: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA494: 7F18C040  cmplw cr6, r24, r24
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[24].u32, &mut ctx.xer);
	// 828FA498: 419A0008  beq cr6, 0x828fa4a0
	if ctx.cr[6].eq {
	pc = 0x828FA4A0; continue 'dispatch;
	}
	// 828FA49C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA4A0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FA4A4: 419A028C  beq cr6, 0x828fa730
	if ctx.cr[6].eq {
	pc = 0x828FA730; continue 'dispatch;
	}
	// 828FA4A8: 7F1F3040  cmplw cr6, r31, r6
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828FA4AC: 41980008  blt cr6, 0x828fa4b4
	if ctx.cr[6].lt {
	pc = 0x828FA4B4; continue 'dispatch;
	}
	// 828FA4B0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA4B4: 813EFFF8  lwz r9, -8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FA4B8: 7F1F3040  cmplw cr6, r31, r6
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828FA4BC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FA4C0: 8113003C  lwz r8, 0x3c(r19)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(60 as u32) ) } as u64;
	// 828FA4C4: 796A07E6  rldicr r10, r11, 0x20, 0x3f
	ctx.r[10].u64 = (ctx.r[11].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 828FA4C8: 8169001C  lwz r11, 0x1c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 828FA4CC: 7CEB5214  add r7, r11, r10
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828FA4D0: 41980008  blt cr6, 0x828fa4d8
	if ctx.cr[6].lt {
	pc = 0x828FA4D8; continue 'dispatch;
	}
	// 828FA4D4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA4D8: 897F003C  lbz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 828FA4DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FA4E0: 419A0040  beq cr6, 0x828fa520
	if ctx.cr[6].eq {
	pc = 0x828FA520; continue 'dispatch;
	}
	// 828FA4E4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828FA4E8: 419A0018  beq cr6, 0x828fa500
	if ctx.cr[6].eq {
	pc = 0x828FA500; continue 'dispatch;
	}
	// 828FA4EC: 89690090  lbz r11, 0x90(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(144 as u32) ) } as u64;
	// 828FA4F0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828FA4F4: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 828FA4F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FA4FC: 409A0008  bne cr6, 0x828fa504
	if !ctx.cr[6].eq {
	pc = 0x828FA504; continue 'dispatch;
	}
	// 828FA500: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828FA504: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FA508: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FA50C: 409A000C  bne cr6, 0x828fa518
	if !ctx.cr[6].eq {
	pc = 0x828FA518; continue 'dispatch;
	}
	// 828FA510: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 828FA514: 4800000C  b 0x828fa520
	pc = 0x828FA520; continue 'dispatch;
	// 828FA518: 8169001C  lwz r11, 0x1c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 828FA51C: 5568007E  clrlwi r8, r11, 1
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 828FA520: 7F1F3040  cmplw cr6, r31, r6
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828FA524: 41980008  blt cr6, 0x828fa52c
	if ctx.cr[6].lt {
	pc = 0x828FA52C; continue 'dispatch;
	}
	// 828FA528: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA52C: C012006C  lfs f0, 0x6c(r18)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FA530: 7F1F3040  cmplw cr6, r31, r6
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828FA534: 41980014  blt cr6, 0x828fa548
	if ctx.cr[6].lt {
	pc = 0x828FA548; continue 'dispatch;
	}
	// 828FA538: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA53C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA540: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA544: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FA548: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 828FA54C: 39410100  addi r10, r1, 0x100
	ctx.r[10].s64 = ctx.r[1].s64 + 256;
	// 828FA550: E9330020  ld r9, 0x20(r19)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[19].u32.wrapping_add(32 as u32) ) };
	// 828FA554: 38A100F0  addi r5, r1, 0xf0
	ctx.r[5].s64 = ctx.r[1].s64 + 240;
	// 828FA558: E8930028  ld r4, 0x28(r19)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[19].u32.wrapping_add(40 as u32) ) };
	// 828FA55C: 7D63AB78  or r3, r11, r21
	ctx.r[3].u64 = ctx.r[11].u64 | ctx.r[21].u64;
            }
            0x828FA730 => {
    //   block [0x828FA730..0x828FA738)
	// 828FA730: 382101F0  addi r1, r1, 0x1f0
	ctx.r[1].s64 = ctx.r[1].s64 + 496;
	// 828FA734: 483AECF8  b 0x82ca942c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FA738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FA738 size=152
    let mut pc: u32 = 0x828FA738;
    'dispatch: loop {
        match pc {
            0x828FA738 => {
    //   block [0x828FA738..0x828FA764)
	// 828FA738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FA73C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FA740: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828FA744: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FA748: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FA74C: 83E30008  lwz r31, 8(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FA750: 3BC30004  addi r30, r3, 4
	ctx.r[30].s64 = ctx.r[3].s64 + 4;
	// 828FA754: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FA758: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FA75C: 40990008  ble cr6, 0x828fa764
	if !ctx.cr[6].gt {
	pc = 0x828FA764; continue 'dispatch;
	}
	// 828FA760: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FA764; continue 'dispatch;
            }
            0x828FA764 => {
    //   block [0x828FA764..0x828FA778)
	// 828FA764: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FA768: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FA76C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FA770: 40990008  ble cr6, 0x828fa778
	if !ctx.cr[6].gt {
	pc = 0x828FA778; continue 'dispatch;
	}
	// 828FA774: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FA778; continue 'dispatch;
            }
            0x828FA778 => {
    //   block [0x828FA778..0x828FA784)
	// 828FA778: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828FA77C: 419A0008  beq cr6, 0x828fa784
	if ctx.cr[6].eq {
	pc = 0x828FA784; continue 'dispatch;
	}
	// 828FA780: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FA784; continue 'dispatch;
            }
            0x828FA784 => {
    //   block [0x828FA784..0x828FA798)
	// 828FA784: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FA788: 419A0030  beq cr6, 0x828fa7b8
	if ctx.cr[6].eq {
	pc = 0x828FA7B8; continue 'dispatch;
	}
	// 828FA78C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FA790: 41980008  blt cr6, 0x828fa798
	if ctx.cr[6].lt {
	pc = 0x828FA798; continue 'dispatch;
	}
	// 828FA794: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FA798; continue 'dispatch;
            }
            0x828FA798 => {
    //   block [0x828FA798..0x828FA7B0)
	// 828FA798: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FA79C: 4B8F3B1D  bl 0x821ee2b8
	ctx.lr = 0x828FA7A0;
	sub_821EE2B8(ctx, base);
	// 828FA7A0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FA7A4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FA7A8: 41980008  blt cr6, 0x828fa7b0
	if ctx.cr[6].lt {
	pc = 0x828FA7B0; continue 'dispatch;
	}
	// 828FA7AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FA7B0; continue 'dispatch;
            }
            0x828FA7B0 => {
    //   block [0x828FA7B0..0x828FA7B8)
	// 828FA7B0: 3BFF0040  addi r31, r31, 0x40
	ctx.r[31].s64 = ctx.r[31].s64 + 64;
	// 828FA7B4: 4BFFFFB0  b 0x828fa764
	pc = 0x828FA764; continue 'dispatch;
            }
            0x828FA7B8 => {
    //   block [0x828FA7B8..0x828FA7D0)
	// 828FA7B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FA7BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FA7C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FA7C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828FA7C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FA7CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FA7D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FA7D0 size=136
    let mut pc: u32 = 0x828FA7D0;
    'dispatch: loop {
        match pc {
            0x828FA7D0 => {
    //   block [0x828FA7D0..0x828FA7F8)
	// 828FA7D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FA7D4: 483AEC39  bl 0x82ca940c
	ctx.lr = 0x828FA7D8;
	sub_82CA93D0(ctx, base);
	// 828FA7D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FA7DC: 83E30008  lwz r31, 8(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FA7E0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828FA7E4: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FA7E8: 3BC30004  addi r30, r3, 4
	ctx.r[30].s64 = ctx.r[3].s64 + 4;
	// 828FA7EC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FA7F0: 40990008  ble cr6, 0x828fa7f8
	if !ctx.cr[6].gt {
	pc = 0x828FA7F8; continue 'dispatch;
	}
	// 828FA7F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FA7F8; continue 'dispatch;
            }
            0x828FA7F8 => {
    //   block [0x828FA7F8..0x828FA80C)
	// 828FA7F8: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FA7FC: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FA800: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FA804: 40990008  ble cr6, 0x828fa80c
	if !ctx.cr[6].gt {
	pc = 0x828FA80C; continue 'dispatch;
	}
	// 828FA808: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FA80C; continue 'dispatch;
            }
            0x828FA80C => {
    //   block [0x828FA80C..0x828FA818)
	// 828FA80C: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828FA810: 419A0008  beq cr6, 0x828fa818
	if ctx.cr[6].eq {
	pc = 0x828FA818; continue 'dispatch;
	}
	// 828FA814: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FA818; continue 'dispatch;
            }
            0x828FA818 => {
    //   block [0x828FA818..0x828FA82C)
	// 828FA818: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FA81C: 419A0034  beq cr6, 0x828fa850
	if ctx.cr[6].eq {
	pc = 0x828FA850; continue 'dispatch;
	}
	// 828FA820: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FA824: 41980008  blt cr6, 0x828fa82c
	if ctx.cr[6].lt {
	pc = 0x828FA82C; continue 'dispatch;
	}
	// 828FA828: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FA82C; continue 'dispatch;
            }
            0x828FA82C => {
    //   block [0x828FA82C..0x828FA848)
	// 828FA82C: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 828FA830: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FA834: 4BC84BF5  bl 0x8257f428
	ctx.lr = 0x828FA838;
	sub_8257F428(ctx, base);
	// 828FA838: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FA83C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FA840: 41980008  blt cr6, 0x828fa848
	if ctx.cr[6].lt {
	pc = 0x828FA848; continue 'dispatch;
	}
	// 828FA844: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FA848; continue 'dispatch;
            }
            0x828FA848 => {
    //   block [0x828FA848..0x828FA850)
	// 828FA848: 3BFF0040  addi r31, r31, 0x40
	ctx.r[31].s64 = ctx.r[31].s64 + 64;
	// 828FA84C: 4BFFFFAC  b 0x828fa7f8
	pc = 0x828FA7F8; continue 'dispatch;
            }
            0x828FA850 => {
    //   block [0x828FA850..0x828FA858)
	// 828FA850: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FA854: 483AEC08  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FA858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FA858 size=360
    let mut pc: u32 = 0x828FA858;
    'dispatch: loop {
        match pc {
            0x828FA858 => {
    //   block [0x828FA858..0x828FA880)
	// 828FA858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FA85C: 483AEBA5  bl 0x82ca9400
	ctx.lr = 0x828FA860;
	sub_82CA93D0(ctx, base);
	// 828FA860: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FA864: 83C30008  lwz r30, 8(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FA868: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828FA86C: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FA870: 3BA30004  addi r29, r3, 4
	ctx.r[29].s64 = ctx.r[3].s64 + 4;
	// 828FA874: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FA878: 40990008  ble cr6, 0x828fa880
	if !ctx.cr[6].gt {
	pc = 0x828FA880; continue 'dispatch;
	}
	// 828FA87C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FA880; continue 'dispatch;
            }
            0x828FA880 => {
    //   block [0x828FA880..0x828FA888)
	// 828FA880: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828FA884: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	pc = 0x828FA888; continue 'dispatch;
            }
            0x828FA888 => {
    //   block [0x828FA888..0x828FA89C)
	// 828FA888: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FA88C: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FA890: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FA894: 40990008  ble cr6, 0x828fa89c
	if !ctx.cr[6].gt {
	pc = 0x828FA89C; continue 'dispatch;
	}
	// 828FA898: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FA89C; continue 'dispatch;
            }
            0x828FA89C => {
    //   block [0x828FA89C..0x828FA8A8)
	// 828FA89C: 7F1DE840  cmplw cr6, r29, r29
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828FA8A0: 419A0008  beq cr6, 0x828fa8a8
	if ctx.cr[6].eq {
	pc = 0x828FA8A8; continue 'dispatch;
	}
	// 828FA8A4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FA8A8; continue 'dispatch;
            }
            0x828FA8A8 => {
    //   block [0x828FA8A8..0x828FA8CC)
	// 828FA8A8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FA8AC: 419A0108  beq cr6, 0x828fa9b4
	if ctx.cr[6].eq {
	pc = 0x828FA9B4; continue 'dispatch;
	}
	// 828FA8B0: 817C6AB8  lwz r11, 0x6ab8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828FA8B4: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FA8B8: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828FA8BC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FA8C0: 806B0070  lwz r3, 0x70(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 828FA8C4: 41980008  blt cr6, 0x828fa8cc
	if ctx.cr[6].lt {
	pc = 0x828FA8CC; continue 'dispatch;
	}
	// 828FA8C8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FA8CC; continue 'dispatch;
            }
            0x828FA8CC => {
    //   block [0x828FA8CC..0x828FA900)
	// 828FA8CC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828FA8D0: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 828FA8D4: 4B944925  bl 0x8223f1f8
	ctx.lr = 0x828FA8D8;
	sub_8223F1F8(ctx, base);
	// 828FA8D8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828FA8DC: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FA8E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FA8E4: 419A001C  beq cr6, 0x828fa900
	if ctx.cr[6].eq {
	pc = 0x828FA900; continue 'dispatch;
	}
	// 828FA8E8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828FA8EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FA8F0: 4BFC18B1  bl 0x828bc1a0
	ctx.lr = 0x828FA8F4;
	sub_828BC1A0(ctx, base);
	// 828FA8F4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828FA8F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FA8FC: 409A0064  bne cr6, 0x828fa960
	if !ctx.cr[6].eq {
	pc = 0x828FA960; continue 'dispatch;
	}
	pc = 0x828FA900; continue 'dispatch;
            }
            0x828FA900 => {
    //   block [0x828FA900..0x828FA90C)
	// 828FA900: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828FA904: 419A0044  beq cr6, 0x828fa948
	if ctx.cr[6].eq {
	pc = 0x828FA948; continue 'dispatch;
	}
	// 828FA908: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	pc = 0x828FA90C; continue 'dispatch;
            }
            0x828FA90C => {
    //   block [0x828FA90C..0x828FA948)
	// 828FA90C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828FA910: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FA914: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828FA918: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828FA91C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828FA920: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FA924: 4082FFE8  bne 0x828fa90c
	if !ctx.cr[0].eq {
	pc = 0x828FA90C; continue 'dispatch;
	}
	// 828FA928: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 828FA92C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FA930: 409A0018  bne cr6, 0x828fa948
	if !ctx.cr[6].eq {
	pc = 0x828FA948; continue 'dispatch;
	}
	// 828FA934: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FA938: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FA93C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FA940: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FA944: 4E800421  bctrl
	ctx.lr = 0x828FA948;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828FA948 => {
    //   block [0x828FA948..0x828FA958)
	// 828FA948: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FA94C: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FA950: 41980008  blt cr6, 0x828fa958
	if ctx.cr[6].lt {
	pc = 0x828FA958; continue 'dispatch;
	}
	// 828FA954: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FA958; continue 'dispatch;
            }
            0x828FA958 => {
    //   block [0x828FA958..0x828FA960)
	// 828FA958: 3BDE0040  addi r30, r30, 0x40
	ctx.r[30].s64 = ctx.r[30].s64 + 64;
	// 828FA95C: 4BFFFF2C  b 0x828fa888
	pc = 0x828FA888; continue 'dispatch;
            }
            0x828FA960 => {
    //   block [0x828FA960..0x828FA96C)
	// 828FA960: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828FA964: 419A0044  beq cr6, 0x828fa9a8
	if ctx.cr[6].eq {
	pc = 0x828FA9A8; continue 'dispatch;
	}
	// 828FA968: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	pc = 0x828FA96C; continue 'dispatch;
            }
            0x828FA96C => {
    //   block [0x828FA96C..0x828FA9A8)
	// 828FA96C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828FA970: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FA974: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828FA978: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828FA97C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828FA980: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FA984: 4082FFE8  bne 0x828fa96c
	if !ctx.cr[0].eq {
	pc = 0x828FA96C; continue 'dispatch;
	}
	// 828FA988: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 828FA98C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FA990: 409A0018  bne cr6, 0x828fa9a8
	if !ctx.cr[6].eq {
	pc = 0x828FA9A8; continue 'dispatch;
	}
	// 828FA994: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FA998: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FA99C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FA9A0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FA9A4: 4E800421  bctrl
	ctx.lr = 0x828FA9A8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828FA9A8 => {
    //   block [0x828FA9A8..0x828FA9B4)
	// 828FA9A8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828FA9AC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828FA9B0: 483AEAA0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x828FA9B4 => {
    //   block [0x828FA9B4..0x828FA9C0)
	// 828FA9B4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828FA9B8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828FA9BC: 483AEA94  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FA9C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FA9C0 size=156
    let mut pc: u32 = 0x828FA9C0;
    'dispatch: loop {
        match pc {
            0x828FA9C0 => {
    //   block [0x828FA9C0..0x828FAA50)
	// 828FA9C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FA9C4: 483AEA49  bl 0x82ca940c
	ctx.lr = 0x828FA9C8;
	sub_82CA93D0(ctx, base);
	// 828FA9C8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FA9CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FA9D0: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 828FA9D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FA9D8: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 828FA9DC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FA9E0: 4E800421  bctrl
	ctx.lr = 0x828FA9E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FA9E4: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828FA9E8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828FA9EC: 419A0064  beq cr6, 0x828faa50
	if ctx.cr[6].eq {
	pc = 0x828FAA50; continue 'dispatch;
	}
	// 828FA9F0: 817FFFF8  lwz r11, -8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FA9F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FA9F8: 83EB007C  lwz r31, 0x7c(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 828FA9FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FAA00: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FAA04: 812A0044  lwz r9, 0x44(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) } as u64;
	// 828FAA08: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828FAA0C: 4E800421  bctrl
	ctx.lr = 0x828FAA10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FAA10: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FAA14: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828FAA18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FAA1C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FAA20: 80E80040  lwz r7, 0x40(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(64 as u32) ) } as u64;
	// 828FAA24: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 828FAA28: 4E800421  bctrl
	ctx.lr = 0x828FAA2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FAA2C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828FAA30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FAA34: E89D0000  ld r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 828FAA38: E8BD0008  ld r5, 8(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
            }
            0x828FAA50 => {
    //   block [0x828FAA50..0x828FAA5C)
	// 828FAA50: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828FAA54: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828FAA58: 483AEA04  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FAA60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FAA60 size=412
    let mut pc: u32 = 0x828FAA60;
    'dispatch: loop {
        match pc {
            0x828FAA60 => {
    //   block [0x828FAA60..0x828FAA94)
	// 828FAA60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FAA64: 483AE995  bl 0x82ca93f8
	ctx.lr = 0x828FAA68;
	sub_82CA93D0(ctx, base);
	// 828FAA68: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FAA6C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FAA70: D02100D4  stfs f1, 0xd4(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 828FAA74: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FAA78: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 828FAA7C: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 828FAA80: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 828FAA84: 3BA30004  addi r29, r3, 4
	ctx.r[29].s64 = ctx.r[3].s64 + 4;
	// 828FAA88: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FAA8C: 40990008  ble cr6, 0x828faa94
	if !ctx.cr[6].gt {
	pc = 0x828FAA94; continue 'dispatch;
	}
	// 828FAA90: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FAA94; continue 'dispatch;
            }
            0x828FAA94 => {
    //   block [0x828FAA94..0x828FAAA0)
	// 828FAA94: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 828FAA98: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828FAA9C: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	pc = 0x828FAAA0; continue 'dispatch;
            }
            0x828FAAA0 => {
    //   block [0x828FAAA0..0x828FAAB4)
	// 828FAAA0: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FAAA4: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FAAA8: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FAAAC: 40990008  ble cr6, 0x828faab4
	if !ctx.cr[6].gt {
	pc = 0x828FAAB4; continue 'dispatch;
	}
	// 828FAAB0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FAAB4; continue 'dispatch;
            }
            0x828FAAB4 => {
    //   block [0x828FAAB4..0x828FAAC0)
	// 828FAAB4: 7F1DE840  cmplw cr6, r29, r29
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828FAAB8: 419A0008  beq cr6, 0x828faac0
	if ctx.cr[6].eq {
	pc = 0x828FAAC0; continue 'dispatch;
	}
	// 828FAABC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FAAC0; continue 'dispatch;
            }
            0x828FAAC0 => {
    //   block [0x828FAAC0..0x828FAAE4)
	// 828FAAC0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FAAC4: 419A012C  beq cr6, 0x828fabf0
	if ctx.cr[6].eq {
	pc = 0x828FABF0; continue 'dispatch;
	}
	// 828FAAC8: 817C6AB8  lwz r11, 0x6ab8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828FAACC: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FAAD0: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828FAAD4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FAAD8: 806B0070  lwz r3, 0x70(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 828FAADC: 41980008  blt cr6, 0x828faae4
	if ctx.cr[6].lt {
	pc = 0x828FAAE4; continue 'dispatch;
	}
	// 828FAAE0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FAAE4; continue 'dispatch;
            }
            0x828FAAE4 => {
    //   block [0x828FAAE4..0x828FAB20)
	// 828FAAE4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828FAAE8: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 828FAAEC: 4B94470D  bl 0x8223f1f8
	ctx.lr = 0x828FAAF0;
	sub_8223F1F8(ctx, base);
	// 828FAAF0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828FAAF4: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FAAF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FAAFC: 419A0024  beq cr6, 0x828fab20
	if ctx.cr[6].eq {
	pc = 0x828FAB20; continue 'dispatch;
	}
	// 828FAB00: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 828FAB04: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 828FAB08: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828FAB0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FAB10: 4B96A591  bl 0x822650a0
	ctx.lr = 0x828FAB14;
	sub_822650A0(ctx, base);
	// 828FAB14: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828FAB18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FAB1C: 409A0064  bne cr6, 0x828fab80
	if !ctx.cr[6].eq {
	pc = 0x828FAB80; continue 'dispatch;
	}
	pc = 0x828FAB20; continue 'dispatch;
            }
            0x828FAB20 => {
    //   block [0x828FAB20..0x828FAB2C)
	// 828FAB20: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828FAB24: 419A0044  beq cr6, 0x828fab68
	if ctx.cr[6].eq {
	pc = 0x828FAB68; continue 'dispatch;
	}
	// 828FAB28: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	pc = 0x828FAB2C; continue 'dispatch;
            }
            0x828FAB2C => {
    //   block [0x828FAB2C..0x828FAB68)
	// 828FAB2C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828FAB30: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FAB34: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828FAB38: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828FAB3C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828FAB40: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FAB44: 4082FFE8  bne 0x828fab2c
	if !ctx.cr[0].eq {
	pc = 0x828FAB2C; continue 'dispatch;
	}
	// 828FAB48: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 828FAB4C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FAB50: 409A0018  bne cr6, 0x828fab68
	if !ctx.cr[6].eq {
	pc = 0x828FAB68; continue 'dispatch;
	}
	// 828FAB54: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FAB58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FAB5C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FAB60: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FAB64: 4E800421  bctrl
	ctx.lr = 0x828FAB68;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828FAB68 => {
    //   block [0x828FAB68..0x828FAB78)
	// 828FAB68: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FAB6C: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FAB70: 41980008  blt cr6, 0x828fab78
	if ctx.cr[6].lt {
	pc = 0x828FAB78; continue 'dispatch;
	}
	// 828FAB74: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FAB78; continue 'dispatch;
            }
            0x828FAB78 => {
    //   block [0x828FAB78..0x828FAB80)
	// 828FAB78: 3BDE0040  addi r30, r30, 0x40
	ctx.r[30].s64 = ctx.r[30].s64 + 64;
	// 828FAB7C: 4BFFFF24  b 0x828faaa0
	pc = 0x828FAAA0; continue 'dispatch;
            }
            0x828FAB80 => {
    //   block [0x828FAB80..0x828FABF0)
	// 828FAB80: 394100D4  addi r10, r1, 0xd4
	ctx.r[10].s64 = ctx.r[1].s64 + 212;
	// 828FAB84: 397A0020  addi r11, r26, 0x20
	ctx.r[11].s64 = ctx.r[26].s64 + 32;
	// 828FAB88: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	pc = 0x828FABF0; continue 'dispatch;
            }
            0x828FABF0 => {
    //   block [0x828FABF0..0x828FABFC)
	// 828FABF0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828FABF4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828FABF8: 483AE850  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FAC00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FAC00 size=260
    let mut pc: u32 = 0x828FAC00;
    'dispatch: loop {
        match pc {
            0x828FAC00 => {
    //   block [0x828FAC00..0x828FAC28)
	// 828FAC00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FAC04: 483AE7FD  bl 0x82ca9400
	ctx.lr = 0x828FAC08;
	sub_82CA93D0(ctx, base);
	// 828FAC08: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FAC0C: 83E30008  lwz r31, 8(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FAC10: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828FAC14: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FAC18: 3BA30004  addi r29, r3, 4
	ctx.r[29].s64 = ctx.r[3].s64 + 4;
	// 828FAC1C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FAC20: 40990008  ble cr6, 0x828fac28
	if !ctx.cr[6].gt {
	pc = 0x828FAC28; continue 'dispatch;
	}
	// 828FAC24: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FAC28; continue 'dispatch;
            }
            0x828FAC28 => {
    //   block [0x828FAC28..0x828FAC30)
	// 828FAC28: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828FAC2C: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	pc = 0x828FAC30; continue 'dispatch;
            }
            0x828FAC30 => {
    //   block [0x828FAC30..0x828FAC44)
	// 828FAC30: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FAC34: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FAC38: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FAC3C: 40990008  ble cr6, 0x828fac44
	if !ctx.cr[6].gt {
	pc = 0x828FAC44; continue 'dispatch;
	}
	// 828FAC40: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FAC44; continue 'dispatch;
            }
            0x828FAC44 => {
    //   block [0x828FAC44..0x828FAC50)
	// 828FAC44: 7F1DE840  cmplw cr6, r29, r29
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828FAC48: 419A0008  beq cr6, 0x828fac50
	if ctx.cr[6].eq {
	pc = 0x828FAC50; continue 'dispatch;
	}
	// 828FAC4C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FAC50; continue 'dispatch;
            }
            0x828FAC50 => {
    //   block [0x828FAC50..0x828FAC74)
	// 828FAC50: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FAC54: 419A00A8  beq cr6, 0x828facfc
	if ctx.cr[6].eq {
	pc = 0x828FACFC; continue 'dispatch;
	}
	// 828FAC58: 817C6AB8  lwz r11, 0x6ab8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828FAC5C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FAC60: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828FAC64: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FAC68: 806B0070  lwz r3, 0x70(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 828FAC6C: 41980008  blt cr6, 0x828fac74
	if ctx.cr[6].lt {
	pc = 0x828FAC74; continue 'dispatch;
	}
	// 828FAC70: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FAC74; continue 'dispatch;
            }
            0x828FAC74 => {
    //   block [0x828FAC74..0x828FAC9C)
	// 828FAC74: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828FAC78: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 828FAC7C: 4B94457D  bl 0x8223f1f8
	ctx.lr = 0x828FAC80;
	sub_8223F1F8(ctx, base);
	// 828FAC80: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828FAC84: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FAC88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FAC8C: 419A0010  beq cr6, 0x828fac9c
	if ctx.cr[6].eq {
	pc = 0x828FAC9C; continue 'dispatch;
	}
	// 828FAC90: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828FAC94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FAC98: 4BFC1581  bl 0x828bc218
	ctx.lr = 0x828FAC9C;
	sub_828BC218(ctx, base);
	pc = 0x828FAC9C; continue 'dispatch;
            }
            0x828FAC9C => {
    //   block [0x828FAC9C..0x828FACA8)
	// 828FAC9C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828FACA0: 419A0044  beq cr6, 0x828face4
	if ctx.cr[6].eq {
	pc = 0x828FACE4; continue 'dispatch;
	}
	// 828FACA4: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	pc = 0x828FACA8; continue 'dispatch;
            }
            0x828FACA8 => {
    //   block [0x828FACA8..0x828FACE4)
	// 828FACA8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828FACAC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FACB0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828FACB4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828FACB8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828FACBC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FACC0: 4082FFE8  bne 0x828faca8
	if !ctx.cr[0].eq {
	pc = 0x828FACA8; continue 'dispatch;
	}
	// 828FACC4: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 828FACC8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FACCC: 409A0018  bne cr6, 0x828face4
	if !ctx.cr[6].eq {
	pc = 0x828FACE4; continue 'dispatch;
	}
	// 828FACD0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FACD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FACD8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FACDC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FACE0: 4E800421  bctrl
	ctx.lr = 0x828FACE4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828FACE4 => {
    //   block [0x828FACE4..0x828FACF4)
	// 828FACE4: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FACE8: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FACEC: 41980008  blt cr6, 0x828facf4
	if ctx.cr[6].lt {
	pc = 0x828FACF4; continue 'dispatch;
	}
	// 828FACF0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FACF4; continue 'dispatch;
            }
            0x828FACF4 => {
    //   block [0x828FACF4..0x828FACFC)
	// 828FACF4: 3BFF0040  addi r31, r31, 0x40
	ctx.r[31].s64 = ctx.r[31].s64 + 64;
	// 828FACF8: 4BFFFF38  b 0x828fac30
	pc = 0x828FAC30; continue 'dispatch;
            }
            0x828FACFC => {
    //   block [0x828FACFC..0x828FAD04)
	// 828FACFC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828FAD00: 483AE750  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FAD08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FAD08 size=516
    let mut pc: u32 = 0x828FAD08;
    'dispatch: loop {
        match pc {
            0x828FAD08 => {
    //   block [0x828FAD08..0x828FAD38)
	// 828FAD08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FAD0C: 483AE6F1  bl 0x82ca93fc
	ctx.lr = 0x828FAD10;
	sub_82CA93D0(ctx, base);
	// 828FAD10: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FAD14: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828FAD18: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 828FAD1C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828FAD20: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 828FAD24: 83FA0008  lwz r31, 8(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FAD28: 815A000C  lwz r10, 0xc(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FAD2C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FAD30: 40990008  ble cr6, 0x828fad38
	if !ctx.cr[6].gt {
	pc = 0x828FAD38; continue 'dispatch;
	}
	// 828FAD34: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FAD38; continue 'dispatch;
            }
            0x828FAD38 => {
    //   block [0x828FAD38..0x828FAD40)
	// 828FAD38: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828FAD3C: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	pc = 0x828FAD40; continue 'dispatch;
            }
            0x828FAD40 => {
    //   block [0x828FAD40..0x828FAD54)
	// 828FAD40: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FAD44: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FAD48: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FAD4C: 40990008  ble cr6, 0x828fad54
	if !ctx.cr[6].gt {
	pc = 0x828FAD54; continue 'dispatch;
	}
	// 828FAD50: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FAD54; continue 'dispatch;
            }
            0x828FAD54 => {
    //   block [0x828FAD54..0x828FAD60)
	// 828FAD54: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828FAD58: 419A0008  beq cr6, 0x828fad60
	if ctx.cr[6].eq {
	pc = 0x828FAD60; continue 'dispatch;
	}
	// 828FAD5C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FAD60; continue 'dispatch;
            }
            0x828FAD60 => {
    //   block [0x828FAD60..0x828FAD74)
	// 828FAD60: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FAD64: 419A019C  beq cr6, 0x828faf00
	if ctx.cr[6].eq {
	pc = 0x828FAF00; continue 'dispatch;
	}
	// 828FAD68: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FAD6C: 41980008  blt cr6, 0x828fad74
	if ctx.cr[6].lt {
	pc = 0x828FAD74; continue 'dispatch;
	}
	// 828FAD70: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FAD74; continue 'dispatch;
            }
            0x828FAD74 => {
    //   block [0x828FAD74..0x828FADA0)
	// 828FAD74: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FAD78: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 828FAD7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FAD80: 4099007C  ble cr6, 0x828fadfc
	if !ctx.cr[6].gt {
	pc = 0x828FADFC; continue 'dispatch;
	}
	// 828FAD84: 817C6AB8  lwz r11, 0x6ab8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828FAD88: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FAD8C: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828FAD90: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FAD94: 806B0070  lwz r3, 0x70(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 828FAD98: 41980008  blt cr6, 0x828fada0
	if ctx.cr[6].lt {
	pc = 0x828FADA0; continue 'dispatch;
	}
	// 828FAD9C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FADA0; continue 'dispatch;
            }
            0x828FADA0 => {
    //   block [0x828FADA0..0x828FADC4)
	// 828FADA0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828FADA4: 4B944455  bl 0x8223f1f8
	ctx.lr = 0x828FADA8;
	sub_8223F1F8(ctx, base);
	// 828FADA8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828FADAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FADB0: 409A0064  bne cr6, 0x828fae14
	if !ctx.cr[6].eq {
	pc = 0x828FAE14; continue 'dispatch;
	}
	// 828FADB4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FADB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FADBC: 419A0040  beq cr6, 0x828fadfc
	if ctx.cr[6].eq {
	pc = 0x828FADFC; continue 'dispatch;
	}
	// 828FADC0: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	pc = 0x828FADC4; continue 'dispatch;
            }
            0x828FADC4 => {
    //   block [0x828FADC4..0x828FADFC)
	// 828FADC4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828FADC8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FADCC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828FADD0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828FADD4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828FADD8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FADDC: 4082FFE8  bne 0x828fadc4
	if !ctx.cr[0].eq {
	pc = 0x828FADC4; continue 'dispatch;
	}
	// 828FADE0: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 828FADE4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FADE8: 409A0014  bne cr6, 0x828fadfc
	if !ctx.cr[6].eq {
	pc = 0x828FADFC; continue 'dispatch;
	}
	// 828FADEC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FADF0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FADF4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FADF8: 4E800421  bctrl
	ctx.lr = 0x828FADFC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828FADFC => {
    //   block [0x828FADFC..0x828FAE0C)
	// 828FADFC: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FAE00: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FAE04: 41980008  blt cr6, 0x828fae0c
	if ctx.cr[6].lt {
	pc = 0x828FAE0C; continue 'dispatch;
	}
	// 828FAE08: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FAE0C; continue 'dispatch;
            }
            0x828FAE0C => {
    //   block [0x828FAE0C..0x828FAE14)
	// 828FAE0C: 3BFF0040  addi r31, r31, 0x40
	ctx.r[31].s64 = ctx.r[31].s64 + 64;
	// 828FAE10: 4BFFFF30  b 0x828fad40
	pc = 0x828FAD40; continue 'dispatch;
            }
            0x828FAE14 => {
    //   block [0x828FAE14..0x828FAF00)
	// 828FAE14: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FAE18: 572B2036  slwi r11, r25, 4
	ctx.r[11].u32 = ctx.r[25].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828FAE1C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828FAE20: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828FAE24: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FAE28: 815F0040  lwz r10, 0x40(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 828FAE2C: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828FAE30: 4BEFD779  bl 0x827f85a8
	ctx.lr = 0x828FAE34;
	sub_827F85A8(ctx, base);
	// 828FAE34: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FAE38: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FAE3C: 4BF52285  bl 0x8284d0c0
	ctx.lr = 0x828FAE40;
	sub_8284D0C0(ctx, base);
	// 828FAE40: 817AFFF8  lwz r11, -8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FAE44: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828FAE48: 83CB007C  lwz r30, 0x7c(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 828FAE4C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FAE50: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FAE54: 812A0044  lwz r9, 0x44(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) } as u64;
	// 828FAE58: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828FAE5C: 4E800421  bctrl
	ctx.lr = 0x828FAE60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FAE60: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 828FAE64: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 828FAE68: 80DE0000  lwz r6, 0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FAE6C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FAE70: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828FAE74: E8A80000  ld r5, 0(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	// 828FAE78: E9680008  ld r11, 8(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	// 828FAE7C: 81460040  lwz r10, 0x40(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(64 as u32) ) } as u64;
	// 828FAE80: F8A70000  std r5, 0(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 828FAE84: F9670008  std r11, 8(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828FAE88: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FAE8C: 4E800421  bctrl
	ctx.lr = 0x828FAE90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FAE90: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 828FAE94: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828FAE98: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828FAE9C: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
            }
            0x828FAF00 => {
    //   block [0x828FAF00..0x828FAF0C)
	// 828FAF00: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828FAF04: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 828FAF08: 483AE544  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FAF10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FAF10 size=364
    let mut pc: u32 = 0x828FAF10;
    'dispatch: loop {
        match pc {
            0x828FAF10 => {
    //   block [0x828FAF10..0x828FAF34)
	// 828FAF10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FAF14: 483AE4F5  bl 0x82ca9408
	ctx.lr = 0x828FAF18;
	sub_82CA93D0(ctx, base);
	// 828FAF18: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FAF1C: 83E30008  lwz r31, 8(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FAF20: 3BC30004  addi r30, r3, 4
	ctx.r[30].s64 = ctx.r[3].s64 + 4;
	// 828FAF24: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FAF28: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FAF2C: 40990008  ble cr6, 0x828faf34
	if !ctx.cr[6].gt {
	pc = 0x828FAF34; continue 'dispatch;
	}
	// 828FAF30: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FAF34; continue 'dispatch;
            }
            0x828FAF34 => {
    //   block [0x828FAF34..0x828FAF3C)
	// 828FAF34: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828FAF38: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	pc = 0x828FAF3C; continue 'dispatch;
            }
            0x828FAF3C => {
    //   block [0x828FAF3C..0x828FAF50)
	// 828FAF3C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FAF40: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FAF44: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FAF48: 40990008  ble cr6, 0x828faf50
	if !ctx.cr[6].gt {
	pc = 0x828FAF50; continue 'dispatch;
	}
	// 828FAF4C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FAF50; continue 'dispatch;
            }
            0x828FAF50 => {
    //   block [0x828FAF50..0x828FAF5C)
	// 828FAF50: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828FAF54: 419A0008  beq cr6, 0x828faf5c
	if ctx.cr[6].eq {
	pc = 0x828FAF5C; continue 'dispatch;
	}
	// 828FAF58: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FAF5C; continue 'dispatch;
            }
            0x828FAF5C => {
    //   block [0x828FAF5C..0x828FAF70)
	// 828FAF5C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FAF60: 419A0110  beq cr6, 0x828fb070
	if ctx.cr[6].eq {
	pc = 0x828FB070; continue 'dispatch;
	}
	// 828FAF64: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FAF68: 41980008  blt cr6, 0x828faf70
	if ctx.cr[6].lt {
	pc = 0x828FAF70; continue 'dispatch;
	}
	// 828FAF6C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FAF70; continue 'dispatch;
            }
            0x828FAF70 => {
    //   block [0x828FAF70..0x828FAF9C)
	// 828FAF70: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FAF74: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 828FAF78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FAF7C: 4099007C  ble cr6, 0x828faff8
	if !ctx.cr[6].gt {
	pc = 0x828FAFF8; continue 'dispatch;
	}
	// 828FAF80: 817D6AB8  lwz r11, 0x6ab8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828FAF84: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FAF88: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828FAF8C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FAF90: 806B0070  lwz r3, 0x70(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 828FAF94: 41980008  blt cr6, 0x828faf9c
	if ctx.cr[6].lt {
	pc = 0x828FAF9C; continue 'dispatch;
	}
	// 828FAF98: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FAF9C; continue 'dispatch;
            }
            0x828FAF9C => {
    //   block [0x828FAF9C..0x828FAFC0)
	// 828FAF9C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828FAFA0: 4B944259  bl 0x8223f1f8
	ctx.lr = 0x828FAFA4;
	sub_8223F1F8(ctx, base);
	// 828FAFA4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828FAFA8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FAFAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FAFB0: 409A0060  bne cr6, 0x828fb010
	if !ctx.cr[6].eq {
	pc = 0x828FB010; continue 'dispatch;
	}
	// 828FAFB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FAFB8: 419A0040  beq cr6, 0x828faff8
	if ctx.cr[6].eq {
	pc = 0x828FAFF8; continue 'dispatch;
	}
	// 828FAFBC: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	pc = 0x828FAFC0; continue 'dispatch;
            }
            0x828FAFC0 => {
    //   block [0x828FAFC0..0x828FAFF8)
	// 828FAFC0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828FAFC4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FAFC8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828FAFCC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828FAFD0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828FAFD4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FAFD8: 4082FFE8  bne 0x828fafc0
	if !ctx.cr[0].eq {
	pc = 0x828FAFC0; continue 'dispatch;
	}
	// 828FAFDC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 828FAFE0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FAFE4: 409A0014  bne cr6, 0x828faff8
	if !ctx.cr[6].eq {
	pc = 0x828FAFF8; continue 'dispatch;
	}
	// 828FAFE8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FAFEC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FAFF0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FAFF4: 4E800421  bctrl
	ctx.lr = 0x828FAFF8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828FAFF8 => {
    //   block [0x828FAFF8..0x828FB008)
	// 828FAFF8: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FAFFC: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FB000: 41980008  blt cr6, 0x828fb008
	if ctx.cr[6].lt {
	pc = 0x828FB008; continue 'dispatch;
	}
	// 828FB004: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FB008; continue 'dispatch;
            }
            0x828FB008 => {
    //   block [0x828FB008..0x828FB010)
	// 828FB008: 3BFF0040  addi r31, r31, 0x40
	ctx.r[31].s64 = ctx.r[31].s64 + 64;
	// 828FB00C: 4BFFFF30  b 0x828faf3c
	pc = 0x828FAF3C; continue 'dispatch;
            }
            0x828FB010 => {
    //   block [0x828FB010..0x828FB02C)
	// 828FB010: 81630044  lwz r11, 0x44(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) } as u64;
	// 828FB014: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FB018: 81430040  lwz r10, 0x40(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 828FB01C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828FB020: 7D3F2670  srawi r31, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[9].s32 >> 4) as i64;
	// 828FB024: 419A0040  beq cr6, 0x828fb064
	if ctx.cr[6].eq {
	pc = 0x828FB064; continue 'dispatch;
	}
	// 828FB028: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	pc = 0x828FB02C; continue 'dispatch;
            }
            0x828FB02C => {
    //   block [0x828FB02C..0x828FB064)
	// 828FB02C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828FB030: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FB034: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828FB038: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 828FB03C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828FB040: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828FB044: 4082FFE8  bne 0x828fb02c
	if !ctx.cr[0].eq {
	pc = 0x828FB02C; continue 'dispatch;
	}
	// 828FB048: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 828FB04C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FB050: 409A0014  bne cr6, 0x828fb064
	if !ctx.cr[6].eq {
	pc = 0x828FB064; continue 'dispatch;
	}
	// 828FB054: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FB058: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FB05C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FB060: 4E800421  bctrl
	ctx.lr = 0x828FB064;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828FB064 => {
    //   block [0x828FB064..0x828FB070)
	// 828FB064: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FB068: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828FB06C: 483AE3EC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x828FB070 => {
    //   block [0x828FB070..0x828FB07C)
	// 828FB070: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828FB074: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828FB078: 483AE3E0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FB080 size=296
    let mut pc: u32 = 0x828FB080;
    'dispatch: loop {
        match pc {
            0x828FB080 => {
    //   block [0x828FB080..0x828FB0AC)
	// 828FB080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FB084: 483AE37D  bl 0x82ca9400
	ctx.lr = 0x828FB088;
	sub_82CA93D0(ctx, base);
	// 828FB088: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FB08C: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 828FB090: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828FB094: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FB098: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828FB09C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828FB0A0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828FB0A4: 3BAA44B0  addi r29, r10, 0x44b0
	ctx.r[29].s64 = ctx.r[10].s64 + 17584;
	// 828FB0A8: 3B8B113C  addi r28, r11, 0x113c
	ctx.r[28].s64 = ctx.r[11].s64 + 4412;
	pc = 0x828FB0AC; continue 'dispatch;
            }
            0x828FB0AC => {
    //   block [0x828FB0AC..0x828FB0EC)
	// 828FB0AC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FB0B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FB0B4: 419A00EC  beq cr6, 0x828fb1a0
	if ctx.cr[6].eq {
	pc = 0x828FB1A0; continue 'dispatch;
	}
	// 828FB0B8: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FB0BC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828FB0C0: 7D2B3670  srawi r11, r9, 6
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 6) as i64;
	// 828FB0C4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FB0C8: 409800D8  bge cr6, 0x828fb1a0
	if !ctx.cr[6].lt {
	pc = 0x828FB1A0; continue 'dispatch;
	}
	// 828FB0CC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FB0D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FB0D4: 419A0018  beq cr6, 0x828fb0ec
	if ctx.cr[6].eq {
	pc = 0x828FB0EC; continue 'dispatch;
	}
	// 828FB0D8: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828FB0DC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828FB0E0: 7D2A3670  srawi r10, r9, 6
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 6) as i64;
	// 828FB0E4: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FB0E8: 41980008  blt cr6, 0x828fb0f0
	if ctx.cr[6].lt {
	pc = 0x828FB0F0; continue 'dispatch;
	}
	pc = 0x828FB0EC; continue 'dispatch;
            }
            0x828FB0EC => {
    //   block [0x828FB0EC..0x828FB0F0)
	// 828FB0EC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FB0F0; continue 'dispatch;
            }
            0x828FB0F0 => {
    //   block [0x828FB0F0..0x828FB120)
	// 828FB0F0: 7D3B5A14  add r9, r27, r11
	ctx.r[9].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 828FB0F4: 8969003C  lbz r11, 0x3c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(60 as u32) ) } as u64;
	// 828FB0F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FB0FC: 419A0074  beq cr6, 0x828fb170
	if ctx.cr[6].eq {
	pc = 0x828FB170; continue 'dispatch;
	}
	// 828FB100: 815FFFF8  lwz r10, -8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FB104: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FB108: 419A0018  beq cr6, 0x828fb120
	if ctx.cr[6].eq {
	pc = 0x828FB120; continue 'dispatch;
	}
	// 828FB10C: 896A0090  lbz r11, 0x90(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(144 as u32) ) } as u64;
	// 828FB110: 55680672  rlwinm r8, r11, 0, 0x19, 0x19
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828FB114: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FB118: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828FB11C: 409A0008  bne cr6, 0x828fb124
	if !ctx.cr[6].eq {
	pc = 0x828FB124; continue 'dispatch;
	}
	pc = 0x828FB120; continue 'dispatch;
            }
            0x828FB120 => {
    //   block [0x828FB120..0x828FB124)
	// 828FB120: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828FB124; continue 'dispatch;
            }
            0x828FB124 => {
    //   block [0x828FB124..0x828FB138)
	// 828FB124: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FB128: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FB12C: 409A000C  bne cr6, 0x828fb138
	if !ctx.cr[6].eq {
	pc = 0x828FB138; continue 'dispatch;
	}
	// 828FB130: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FB134: 4800000C  b 0x828fb140
	pc = 0x828FB140; continue 'dispatch;
            }
            0x828FB138 => {
    //   block [0x828FB138..0x828FB140)
	// 828FB138: 816A001C  lwz r11, 0x1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 828FB13C: 556B007E  clrlwi r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	pc = 0x828FB140; continue 'dispatch;
            }
            0x828FB140 => {
    //   block [0x828FB140..0x828FB170)
	// 828FB140: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FB144: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 828FB148: 419A004C  beq cr6, 0x828fb194
	if ctx.cr[6].eq {
	pc = 0x828FB194; continue 'dispatch;
	}
	// 828FB14C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828FB150: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828FB154: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828FB158: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FB15C: 4B92F96D  bl 0x8222aac8
	ctx.lr = 0x828FB160;
	sub_8222AAC8(ctx, base);
	// 828FB160: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828FB164: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828FB168: 3B7B0040  addi r27, r27, 0x40
	ctx.r[27].s64 = ctx.r[27].s64 + 64;
	// 828FB16C: 4BFFFF40  b 0x828fb0ac
	pc = 0x828FB0AC; continue 'dispatch;
            }
            0x828FB170 => {
    //   block [0x828FB170..0x828FB194)
	// 828FB170: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FB174: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 828FB178: 419A001C  beq cr6, 0x828fb194
	if ctx.cr[6].eq {
	pc = 0x828FB194; continue 'dispatch;
	}
	// 828FB17C: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 828FB180: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828FB184: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 828FB188: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828FB18C: 4B92F93D  bl 0x8222aac8
	ctx.lr = 0x828FB190;
	sub_8222AAC8(ctx, base);
	// 828FB190: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	pc = 0x828FB194; continue 'dispatch;
            }
            0x828FB194 => {
    //   block [0x828FB194..0x828FB1A0)
	// 828FB194: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828FB198: 3B7B0040  addi r27, r27, 0x40
	ctx.r[27].s64 = ctx.r[27].s64 + 64;
	// 828FB19C: 4BFFFF10  b 0x828fb0ac
	pc = 0x828FB0AC; continue 'dispatch;
            }
            0x828FB1A0 => {
    //   block [0x828FB1A0..0x828FB1A8)
	// 828FB1A0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828FB1A4: 483AE2AC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB1A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FB1A8 size=228
    let mut pc: u32 = 0x828FB1A8;
    'dispatch: loop {
        match pc {
            0x828FB1A8 => {
    //   block [0x828FB1A8..0x828FB1D8)
	// 828FB1A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FB1AC: 483AE25D  bl 0x82ca9408
	ctx.lr = 0x828FB1B0;
	sub_82CA93D0(ctx, base);
	// 828FB1B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FB1B4: 3D6003FF  lis r11, 0x3ff
	ctx.r[11].s64 = 67043328;
	// 828FB1B8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828FB1BC: 616AFFFF  ori r10, r11, 0xffff
	ctx.r[10].u64 = ctx.r[11].u64 | 65535;
	// 828FB1C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FB1C4: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FB1C8: 40990010  ble cr6, 0x828fb1d8
	if !ctx.cr[6].gt {
	pc = 0x828FB1D8; continue 'dispatch;
	}
	// 828FB1CC: 4BBF9905  bl 0x824f4ad0
	ctx.lr = 0x828FB1D0;
	sub_824F4AD0(ctx, base);
	// 828FB1D0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828FB1D4: 483AE284  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x828FB1D8 => {
    //   block [0x828FB1D8..0x828FB1F0)
	// 828FB1D8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FB1DC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828FB1E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FB1E4: 409A000C  bne cr6, 0x828fb1f0
	if !ctx.cr[6].eq {
	pc = 0x828FB1F0; continue 'dispatch;
	}
	// 828FB1E8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 828FB1EC: 48000010  b 0x828fb1fc
	pc = 0x828FB1FC; continue 'dispatch;
            }
            0x828FB1F0 => {
    //   block [0x828FB1F0..0x828FB1FC)
	// 828FB1F0: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FB1F4: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828FB1F8: 7D2B3670  srawi r11, r9, 6
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 6) as i64;
	pc = 0x828FB1FC; continue 'dispatch;
            }
            0x828FB1FC => {
    //   block [0x828FB1FC..0x828FB22C)
	// 828FB1FC: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828FB200: 40980084  bge cr6, 0x828fb284
	if !ctx.cr[6].lt {
	pc = 0x828FB284; continue 'dispatch;
	}
	// 828FB204: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828FB208: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FB20C: 480D3A25  bl 0x829cec30
	ctx.lr = 0x828FB210;
	sub_829CEC30(ctx, base);
	// 828FB210: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FB214: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FB218: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FB21C: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 828FB220: 4099000C  ble cr6, 0x828fb22c
	if !ctx.cr[6].gt {
	pc = 0x828FB22C; continue 'dispatch;
	}
	// 828FB224: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 828FB228: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FB22C; continue 'dispatch;
            }
            0x828FB22C => {
    //   block [0x828FB22C..0x828FB268)
	// 828FB22C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 828FB230: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FB234: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828FB238: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828FB23C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828FB240: 9BAA0000  stb r29, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828FB244: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FB248: 48000561  bl 0x828fb7a8
	ctx.lr = 0x828FB24C;
	sub_828FB7A8(ctx, base);
	// 828FB24C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FB250: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FB254: 419A0014  beq cr6, 0x828fb268
	if ctx.cr[6].eq {
	pc = 0x828FB268; continue 'dispatch;
	}
	// 828FB258: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FB25C: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 828FB260: 7D5D3670  srawi r29, r10, 6
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[10].s32 >> 6) as i64;
	// 828FB264: 4B920AD5  bl 0x8221bd38
	ctx.lr = 0x828FB268;
	sub_8221BD38(ctx, base);
	pc = 0x828FB268; continue 'dispatch;
            }
            0x828FB268 => {
    //   block [0x828FB268..0x828FB284)
	// 828FB268: 578A3032  slwi r10, r28, 6
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828FB26C: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828FB270: 57AB3032  slwi r11, r29, 6
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828FB274: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 828FB278: 7D2BF214  add r9, r11, r30
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 828FB27C: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 828FB280: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x828FB284; continue 'dispatch;
            }
            0x828FB284 => {
    //   block [0x828FB284..0x828FB28C)
	// 828FB284: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828FB288: 483AE1D0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FB290 size=220
    let mut pc: u32 = 0x828FB290;
    'dispatch: loop {
        match pc {
            0x828FB290 => {
    //   block [0x828FB290..0x828FB2C8)
	// 828FB290: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FB294: 483AE179  bl 0x82ca940c
	ctx.lr = 0x828FB298;
	sub_82CA93D0(ctx, base);
	// 828FB298: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FB29C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828FB2A0: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828FB2A4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828FB2A8: F88100A0  std r4, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[4].u64 ) };
	// 828FB2AC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FB2B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FB2B4: 419A0014  beq cr6, 0x828fb2c8
	if ctx.cr[6].eq {
	pc = 0x828FB2C8; continue 'dispatch;
	}
	// 828FB2B8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FB2BC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828FB2C0: 7D293671  srawi. r9, r9, 6
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 6) as i64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FB2C4: 4082000C  bne 0x828fb2d0
	if !ctx.cr[0].eq {
	pc = 0x828FB2D0; continue 'dispatch;
	}
	pc = 0x828FB2C8; continue 'dispatch;
            }
            0x828FB2C8 => {
    //   block [0x828FB2C8..0x828FB2D0)
	// 828FB2C8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828FB2CC: 48000034  b 0x828fb300
	pc = 0x828FB300; continue 'dispatch;
            }
            0x828FB2D0 => {
    //   block [0x828FB2D0..0x828FB2DC)
	// 828FB2D0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FB2D4: 40990008  ble cr6, 0x828fb2dc
	if !ctx.cr[6].gt {
	pc = 0x828FB2DC; continue 'dispatch;
	}
	// 828FB2D8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FB2DC; continue 'dispatch;
            }
            0x828FB2DC => {
    //   block [0x828FB2DC..0x828FB2F0)
	// 828FB2DC: 814100A0  lwz r10, 0xa0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 828FB2E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FB2E4: 419A000C  beq cr6, 0x828fb2f0
	if ctx.cr[6].eq {
	pc = 0x828FB2F0; continue 'dispatch;
	}
	// 828FB2E8: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828FB2EC: 419A0008  beq cr6, 0x828fb2f4
	if ctx.cr[6].eq {
	pc = 0x828FB2F4; continue 'dispatch;
	}
	pc = 0x828FB2F0; continue 'dispatch;
            }
            0x828FB2F0 => {
    //   block [0x828FB2F0..0x828FB2F4)
	// 828FB2F0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FB2F4; continue 'dispatch;
            }
            0x828FB2F4 => {
    //   block [0x828FB2F4..0x828FB300)
	// 828FB2F4: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 828FB2F8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828FB2FC: 7D3E3670  srawi r30, r9, 6
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[9].s32 >> 6) as i64;
	pc = 0x828FB300; continue 'dispatch;
            }
            0x828FB300 => {
    //   block [0x828FB300..0x828FB320)
	// 828FB300: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828FB304: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FB308: 480000F1  bl 0x828fb3f8
	ctx.lr = 0x828FB30C;
	sub_828FB3F8(ctx, base);
	// 828FB30C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FB310: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FB314: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FB318: 40990008  ble cr6, 0x828fb320
	if !ctx.cr[6].gt {
	pc = 0x828FB320; continue 'dispatch;
	}
	// 828FB31C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FB320; continue 'dispatch;
            }
            0x828FB320 => {
    //   block [0x828FB320..0x828FB350)
	// 828FB320: 57CA3032  slwi r10, r30, 6
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828FB324: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FB328: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828FB32C: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828FB330: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828FB334: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828FB338: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828FB33C: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 828FB340: 41990010  bgt cr6, 0x828fb350
	if ctx.cr[6].gt {
	pc = 0x828FB350; continue 'dispatch;
	}
	// 828FB344: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FB348: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FB34C: 40980008  bge cr6, 0x828fb354
	if !ctx.cr[6].lt {
	pc = 0x828FB354; continue 'dispatch;
	}
	pc = 0x828FB350; continue 'dispatch;
            }
            0x828FB350 => {
    //   block [0x828FB350..0x828FB354)
	// 828FB350: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FB354; continue 'dispatch;
            }
            0x828FB354 => {
    //   block [0x828FB354..0x828FB36C)
	// 828FB354: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828FB358: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FB35C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828FB360: F97D0000  std r11, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828FB364: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828FB368: 483AE0F4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FB370 size=132
    let mut pc: u32 = 0x828FB370;
    'dispatch: loop {
        match pc {
            0x828FB370 => {
    //   block [0x828FB370..0x828FB380)
	// 828FB370: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 828FB374: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 828FB378: 419A0070  beq cr6, 0x828fb3e8
	if ctx.cr[6].eq {
	pc = 0x828FB3E8; continue 'dispatch;
	}
	// 828FB37C: 39640008  addi r11, r4, 8
	ctx.r[11].s64 = ctx.r[4].s64 + 8;
	pc = 0x828FB380; continue 'dispatch;
            }
            0x828FB380 => {
    //   block [0x828FB380..0x828FB3B8)
	// 828FB380: 354BFFF8  addic. r10, r11, -8
	ctx.xer.ca = (ctx.r[11].u32 > (!(-8 as u32)));
	ctx.r[10].s64 = ctx.r[11].s64 + -8;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828FB384: 41820058  beq 0x828fb3dc
	if ctx.cr[0].eq {
	pc = 0x828FB3DC; continue 'dispatch;
	}
	// 828FB388: 80660000  lwz r3, 0(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FB38C: 39460010  addi r10, r6, 0x10
	ctx.r[10].s64 = ctx.r[6].s64 + 16;
	// 828FB390: 392B0008  addi r9, r11, 8
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	// 828FB394: 3900000A  li r8, 0xa
	ctx.r[8].s64 = 10;
	// 828FB398: 906BFFF8  stw r3, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[3].u32 ) };
	// 828FB39C: 80660004  lwz r3, 4(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FB3A0: 906BFFFC  stw r3, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[3].u32 ) };
	// 828FB3A4: 80660008  lwz r3, 8(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FB3A8: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 828FB3AC: 8066000C  lwz r3, 0xc(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FB3B0: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 828FB3B4: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x828FB3B8; continue 'dispatch;
            }
            0x828FB3B8 => {
    //   block [0x828FB3B8..0x828FB3DC)
	// 828FB3B8: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FB3BC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 828FB3C0: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828FB3C4: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 828FB3C8: 4200FFF0  bdnz 0x828fb3b8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828FB3B8; continue 'dispatch;
	}
	// 828FB3CC: 81460038  lwz r10, 0x38(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(56 as u32) ) } as u64;
	// 828FB3D0: 914B0030  stw r10, 0x30(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 828FB3D4: 8926003C  lbz r9, 0x3c(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(60 as u32) ) } as u64;
	// 828FB3D8: 992B0034  stb r9, 0x34(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), ctx.r[9].u8 ) };
	pc = 0x828FB3DC; continue 'dispatch;
            }
            0x828FB3DC => {
    //   block [0x828FB3DC..0x828FB3E8)
	// 828FB3DC: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 828FB3E0: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 828FB3E4: 4082FF9C  bne 0x828fb380
	if !ctx.cr[0].eq {
	pc = 0x828FB380; continue 'dispatch;
	}
	pc = 0x828FB3E8; continue 'dispatch;
            }
            0x828FB3E8 => {
    //   block [0x828FB3E8..0x828FB3F4)
	// 828FB3E8: 54AB3032  slwi r11, r5, 6
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828FB3EC: 7C6B2214  add r3, r11, r4
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 828FB3F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB3F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FB3F8 size=820
    let mut pc: u32 = 0x828FB3F8;
    'dispatch: loop {
        match pc {
            0x828FB3F8 => {
    //   block [0x828FB3F8..0x828FB43C)
	// 828FB3F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FB3FC: 483AE009  bl 0x82ca9404
	ctx.lr = 0x828FB400;
	sub_82CA93D0(ctx, base);
	// 828FB400: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FB404: F88100E8  std r4, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[4].u64 ) };
	// 828FB408: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FB40C: 81060000  lwz r8, 0(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FB410: 39660010  addi r11, r6, 0x10
	ctx.r[11].s64 = ctx.r[6].s64 + 16;
	// 828FB414: 80E60004  lwz r7, 4(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FB418: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 828FB41C: 80A60008  lwz r5, 8(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FB420: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
	// 828FB424: 8086000C  lwz r4, 0xc(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FB428: 91010060  stw r8, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 828FB42C: 90E10064  stw r7, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[7].u32 ) };
	// 828FB430: 90A10068  stw r5, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[5].u32 ) };
	// 828FB434: 9081006C  stw r4, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[4].u32 ) };
	// 828FB438: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x828FB43C; continue 'dispatch;
            }
            0x828FB43C => {
    //   block [0x828FB43C..0x828FB478)
	// 828FB43C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FB440: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828FB444: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828FB448: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 828FB44C: 4200FFF0  bdnz 0x828fb43c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828FB43C; continue 'dispatch;
	}
	// 828FB450: 81660038  lwz r11, 0x38(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(56 as u32) ) } as u64;
	// 828FB454: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828FB458: 8926003C  lbz r9, 0x3c(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(60 as u32) ) } as u64;
	// 828FB45C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FB460: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FB464: 91610098  stw r11, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 828FB468: 9921009C  stb r9, 0x9c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[9].u8 ) };
	// 828FB46C: 409A000C  bne cr6, 0x828fb478
	if !ctx.cr[6].eq {
	pc = 0x828FB478; continue 'dispatch;
	}
	// 828FB470: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 828FB474: 48000010  b 0x828fb484
	pc = 0x828FB484; continue 'dispatch;
            }
            0x828FB478 => {
    //   block [0x828FB478..0x828FB484)
	// 828FB478: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FB47C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828FB480: 7D293670  srawi r9, r9, 6
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 6) as i64;
	pc = 0x828FB484; continue 'dispatch;
            }
            0x828FB484 => {
    //   block [0x828FB484..0x828FB494)
	// 828FB484: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FB488: 409A000C  bne cr6, 0x828fb494
	if !ctx.cr[6].eq {
	pc = 0x828FB494; continue 'dispatch;
	}
	// 828FB48C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828FB490: 48000010  b 0x828fb4a0
	pc = 0x828FB4A0; continue 'dispatch;
            }
            0x828FB494 => {
    //   block [0x828FB494..0x828FB4A0)
	// 828FB494: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FB498: 7D0A5850  subf r8, r10, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828FB49C: 7D0B3670  srawi r11, r8, 6
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 6) as i64;
	pc = 0x828FB4A0; continue 'dispatch;
            }
            0x828FB4A0 => {
    //   block [0x828FB4A0..0x828FB4C0)
	// 828FB4A0: 3D0003FF  lis r8, 0x3ff
	ctx.r[8].s64 = 67043328;
	// 828FB4A4: 6108FFFF  ori r8, r8, 0xffff
	ctx.r[8].u64 = ctx.r[8].u64 | 65535;
	// 828FB4A8: 7CEB4050  subf r7, r11, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 828FB4AC: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 828FB4B0: 40980010  bge cr6, 0x828fb4c0
	if !ctx.cr[6].lt {
	pc = 0x828FB4C0; continue 'dispatch;
	}
	// 828FB4B4: 4BBF961D  bl 0x824f4ad0
	ctx.lr = 0x828FB4B8;
	sub_824F4AD0(ctx, base);
	// 828FB4B8: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828FB4BC: 483ADF98  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x828FB4C0 => {
    //   block [0x828FB4C0..0x828FB4D0)
	// 828FB4C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FB4C4: 409A000C  bne cr6, 0x828fb4d0
	if !ctx.cr[6].eq {
	pc = 0x828FB4D0; continue 'dispatch;
	}
	// 828FB4C8: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828FB4CC: 48000010  b 0x828fb4dc
	pc = 0x828FB4DC; continue 'dispatch;
            }
            0x828FB4D0 => {
    //   block [0x828FB4D0..0x828FB4DC)
	// 828FB4D0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FB4D4: 7CEA5850  subf r7, r10, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828FB4D8: 7CEB3670  srawi r11, r7, 6
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> 6) as i64;
	pc = 0x828FB4DC; continue 'dispatch;
            }
            0x828FB4DC => {
    //   block [0x828FB4DC..0x828FB500)
	// 828FB4DC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828FB4E0: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FB4E4: 4098012C  bge cr6, 0x828fb610
	if !ctx.cr[6].lt {
	pc = 0x828FB610; continue 'dispatch;
	}
	// 828FB4E8: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828FB4EC: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 828FB4F0: 7D0B4050  subf r8, r11, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 828FB4F4: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828FB4F8: 41980008  blt cr6, 0x828fb500
	if ctx.cr[6].lt {
	pc = 0x828FB500; continue 'dispatch;
	}
	// 828FB4FC: 7F8B4A14  add r28, r11, r9
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x828FB500; continue 'dispatch;
            }
            0x828FB500 => {
    //   block [0x828FB500..0x828FB510)
	// 828FB500: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FB504: 409A000C  bne cr6, 0x828fb510
	if !ctx.cr[6].eq {
	pc = 0x828FB510; continue 'dispatch;
	}
	// 828FB508: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828FB50C: 48000010  b 0x828fb51c
	pc = 0x828FB51C; continue 'dispatch;
            }
            0x828FB510 => {
    //   block [0x828FB510..0x828FB51C)
	// 828FB510: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FB514: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828FB518: 7D2B3670  srawi r11, r9, 6
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 6) as i64;
	pc = 0x828FB51C; continue 'dispatch;
            }
            0x828FB51C => {
    //   block [0x828FB51C..0x828FB538)
	// 828FB51C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828FB520: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FB524: 40980024  bge cr6, 0x828fb548
	if !ctx.cr[6].lt {
	pc = 0x828FB548; continue 'dispatch;
	}
	// 828FB528: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FB52C: 409A000C  bne cr6, 0x828fb538
	if !ctx.cr[6].eq {
	pc = 0x828FB538; continue 'dispatch;
	}
	// 828FB530: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828FB534: 48000010  b 0x828fb544
	pc = 0x828FB544; continue 'dispatch;
            }
            0x828FB538 => {
    //   block [0x828FB538..0x828FB544)
	// 828FB538: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FB53C: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828FB540: 7D4B3670  srawi r11, r10, 6
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 6) as i64;
	pc = 0x828FB544; continue 'dispatch;
            }
            0x828FB544 => {
    //   block [0x828FB544..0x828FB548)
	// 828FB544: 3B8B0001  addi r28, r11, 1
	ctx.r[28].s64 = ctx.r[11].s64 + 1;
	pc = 0x828FB548; continue 'dispatch;
            }
            0x828FB548 => {
    //   block [0x828FB548..0x828FB5D0)
	// 828FB548: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828FB54C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FB550: 480D36E1  bl 0x829cec30
	ctx.lr = 0x828FB554;
	sub_829CEC30(ctx, base);
	// 828FB554: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828FB558: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FB55C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FB560: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FB564: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828FB568: 83A100EC  lwz r29, 0xec(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 828FB56C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828FB570: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 828FB574: 9B6B0000  stb r27, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u8 ) };
	// 828FB578: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828FB57C: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FB580: 48000229  bl 0x828fb7a8
	ctx.lr = 0x828FB584;
	sub_828FB7A8(ctx, base);
	// 828FB584: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FB588: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828FB58C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828FB590: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FB594: 4BFFFDDD  bl 0x828fb370
	ctx.lr = 0x828FB598;
	sub_828FB370(ctx, base);
	// 828FB598: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 828FB59C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FB5A0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828FB5A4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828FB5A8: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FB5AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FB5B0: 9B690000  stb r27, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[27].u8 ) };
	// 828FB5B4: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FB5B8: 480001F1  bl 0x828fb7a8
	ctx.lr = 0x828FB5BC;
	sub_828FB7A8(ctx, base);
	// 828FB5BC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FB5C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FB5C4: 409A000C  bne cr6, 0x828fb5d0
	if !ctx.cr[6].eq {
	pc = 0x828FB5D0; continue 'dispatch;
	}
	// 828FB5C8: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828FB5CC: 48000010  b 0x828fb5dc
	pc = 0x828FB5DC; continue 'dispatch;
            }
            0x828FB5D0 => {
    //   block [0x828FB5D0..0x828FB5DC)
	// 828FB5D0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FB5D4: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 828FB5D8: 7D4B3670  srawi r11, r10, 6
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 6) as i64;
	pc = 0x828FB5DC; continue 'dispatch;
            }
            0x828FB5DC => {
    //   block [0x828FB5DC..0x828FB5EC)
	// 828FB5DC: 3BAB0001  addi r29, r11, 1
	ctx.r[29].s64 = ctx.r[11].s64 + 1;
	// 828FB5E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FB5E4: 419A0008  beq cr6, 0x828fb5ec
	if ctx.cr[6].eq {
	pc = 0x828FB5EC; continue 'dispatch;
	}
	// 828FB5E8: 4B920751  bl 0x8221bd38
	ctx.lr = 0x828FB5EC;
	sub_8221BD38(ctx, base);
	pc = 0x828FB5EC; continue 'dispatch;
            }
            0x828FB5EC => {
    //   block [0x828FB5EC..0x828FB610)
	// 828FB5EC: 578B3032  slwi r11, r28, 6
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828FB5F0: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828FB5F4: 57AA3032  slwi r10, r29, 6
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828FB5F8: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 828FB5FC: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 828FB600: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 828FB604: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828FB608: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828FB60C: 483ADE48  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x828FB610 => {
    //   block [0x828FB610..0x828FB688)
	// 828FB610: 83A100EC  lwz r29, 0xec(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 828FB614: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828FB618: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FB61C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FB620: 7D7D2050  subf r11, r29, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[29].s64;
	// 828FB624: 7D6A3670  srawi r10, r11, 6
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 6) as i64;
	// 828FB628: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828FB62C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 828FB630: 9B6B0000  stb r27, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u8 ) };
	// 828FB634: 40980054  bge cr6, 0x828fb688
	if !ctx.cr[6].lt {
	pc = 0x828FB688; continue 'dispatch;
	}
	// 828FB638: 38BD0040  addi r5, r29, 0x40
	ctx.r[5].s64 = ctx.r[29].s64 + 64;
	// 828FB63C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FB640: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FB644: 48000165  bl 0x828fb7a8
	ctx.lr = 0x828FB648;
	sub_828FB7A8(ctx, base);
	// 828FB648: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FB64C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828FB650: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FB654: 7D5D2050  subf r10, r29, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[29].s64;
	// 828FB658: 7D493670  srawi r9, r10, 6
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 6) as i64;
	// 828FB65C: 20A90001  subfic r5, r9, 1
	ctx.xer.ca = ctx.r[9].u32 <= 1 as u32;
	ctx.r[5].s64 = (1 as i64) - ctx.r[9].s64;
	// 828FB660: 4BFFFD11  bl 0x828fb370
	ctx.lr = 0x828FB664;
	sub_828FB370(ctx, base);
	// 828FB664: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FB668: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828FB66C: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 828FB670: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FB674: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828FB678: 388BFFC0  addi r4, r11, -0x40
	ctx.r[4].s64 = ctx.r[11].s64 + -64;
	// 828FB67C: 480000B5  bl 0x828fb730
	ctx.lr = 0x828FB680;
	sub_828FB730(ctx, base);
	// 828FB680: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828FB684: 483ADDD0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x828FB688 => {
    //   block [0x828FB688..0x828FB6B0)
	// 828FB688: 3BC4FFC0  addi r30, r4, -0x40
	ctx.r[30].s64 = ctx.r[4].s64 + -64;
	// 828FB68C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 828FB690: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FB694: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FB698: 48000111  bl 0x828fb7a8
	ctx.lr = 0x828FB69C;
	sub_828FB7A8(ctx, base);
	// 828FB69C: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 828FB6A0: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 828FB6A4: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828FB6A8: 419A006C  beq cr6, 0x828fb714
	if ctx.cr[6].eq {
	pc = 0x828FB714; continue 'dispatch;
	}
	// 828FB6AC: 396A0048  addi r11, r10, 0x48
	ctx.r[11].s64 = ctx.r[10].s64 + 72;
	pc = 0x828FB6B0; continue 'dispatch;
            }
            0x828FB6B0 => {
    //   block [0x828FB6B0..0x828FB6E8)
	// 828FB6B0: 394AFFC0  addi r10, r10, -0x40
	ctx.r[10].s64 = ctx.r[10].s64 + -64;
	// 828FB6B4: 396BFFC0  addi r11, r11, -0x40
	ctx.r[11].s64 = ctx.r[11].s64 + -64;
	// 828FB6B8: 38E0000A  li r7, 0xa
	ctx.r[7].s64 = 10;
	// 828FB6BC: 392BFFC8  addi r9, r11, -0x38
	ctx.r[9].s64 = ctx.r[11].s64 + -56;
	// 828FB6C0: 390B0008  addi r8, r11, 8
	ctx.r[8].s64 = ctx.r[11].s64 + 8;
	// 828FB6C4: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FB6C8: 90CBFFF8  stw r6, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[6].u32 ) };
	// 828FB6CC: 80ABFFBC  lwz r5, -0x44(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-68 as u32) ) } as u64;
	// 828FB6D0: 90ABFFFC  stw r5, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[5].u32 ) };
	// 828FB6D4: 808BFFC0  lwz r4, -0x40(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-64 as u32) ) } as u64;
	// 828FB6D8: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 828FB6DC: 806BFFC4  lwz r3, -0x3c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-60 as u32) ) } as u64;
	// 828FB6E0: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 828FB6E4: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	pc = 0x828FB6E8; continue 'dispatch;
            }
            0x828FB6E8 => {
    //   block [0x828FB6E8..0x828FB714)
	// 828FB6E8: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FB6EC: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 828FB6F0: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 828FB6F4: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 828FB6F8: 4200FFF0  bdnz 0x828fb6e8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828FB6E8; continue 'dispatch;
	}
	// 828FB6FC: 812BFFF0  lwz r9, -0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) } as u64;
	// 828FB700: 7F0AE840  cmplw cr6, r10, r29
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828FB704: 912B0030  stw r9, 0x30(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[9].u32 ) };
	// 828FB708: 890BFFF4  lbz r8, -0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) } as u64;
	// 828FB70C: 990B0034  stb r8, 0x34(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), ctx.r[8].u8 ) };
	// 828FB710: 409AFFA0  bne cr6, 0x828fb6b0
	if !ctx.cr[6].eq {
	pc = 0x828FB6B0; continue 'dispatch;
	}
	pc = 0x828FB714; continue 'dispatch;
            }
            0x828FB714 => {
    //   block [0x828FB714..0x828FB72C)
	// 828FB714: 389D0040  addi r4, r29, 0x40
	ctx.r[4].s64 = ctx.r[29].s64 + 64;
	// 828FB718: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828FB71C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FB720: 48000011  bl 0x828fb730
	ctx.lr = 0x828FB724;
	sub_828FB730(ctx, base);
	// 828FB724: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828FB728: 483ADD2C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FB730 size=120
    let mut pc: u32 = 0x828FB730;
    'dispatch: loop {
        match pc {
            0x828FB730 => {
    //   block [0x828FB730..0x828FB740)
	// 828FB730: 7F032040  cmplw cr6, r3, r4
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[4].u32, &mut ctx.xer);
	// 828FB734: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 828FB738: 38E50010  addi r7, r5, 0x10
	ctx.r[7].s64 = ctx.r[5].s64 + 16;
	// 828FB73C: 39630008  addi r11, r3, 8
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	pc = 0x828FB740; continue 'dispatch;
            }
            0x828FB740 => {
    //   block [0x828FB740..0x828FB770)
	// 828FB740: 80C50000  lwz r6, 0(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FB744: 392B0008  addi r9, r11, 8
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	// 828FB748: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 828FB74C: 3900000A  li r8, 0xa
	ctx.r[8].s64 = 10;
	// 828FB750: 90CBFFF8  stw r6, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[6].u32 ) };
	// 828FB754: 80650004  lwz r3, 4(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FB758: 906BFFFC  stw r3, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[3].u32 ) };
	// 828FB75C: 80C50008  lwz r6, 8(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FB760: 90CB0000  stw r6, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 828FB764: 8065000C  lwz r3, 0xc(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FB768: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 828FB76C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x828FB770; continue 'dispatch;
            }
            0x828FB770 => {
    //   block [0x828FB770..0x828FB7A8)
	// 828FB770: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FB774: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 828FB778: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828FB77C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 828FB780: 4200FFF0  bdnz 0x828fb770
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828FB770; continue 'dispatch;
	}
	// 828FB784: 81450038  lwz r10, 0x38(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(56 as u32) ) } as u64;
	// 828FB788: 914B0030  stw r10, 0x30(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 828FB78C: 8925003C  lbz r9, 0x3c(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(60 as u32) ) } as u64;
	// 828FB790: 992B0034  stb r9, 0x34(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), ctx.r[9].u8 ) };
	// 828FB794: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 828FB798: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 828FB79C: 7F082040  cmplw cr6, r8, r4
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[4].u32, &mut ctx.xer);
	// 828FB7A0: 409AFFA0  bne cr6, 0x828fb740
	if !ctx.cr[6].eq {
	pc = 0x828FB740; continue 'dispatch;
	}
	// 828FB7A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB7A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FB7A8 size=136
    let mut pc: u32 = 0x828FB7A8;
    'dispatch: loop {
        match pc {
            0x828FB7A8 => {
    //   block [0x828FB7A8..0x828FB7B8)
	// 828FB7A8: 7F032040  cmplw cr6, r3, r4
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[4].u32, &mut ctx.xer);
	// 828FB7AC: 419A007C  beq cr6, 0x828fb828
	if ctx.cr[6].eq {
	pc = 0x828FB828; continue 'dispatch;
	}
	// 828FB7B0: 39630008  addi r11, r3, 8
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	// 828FB7B4: 7CE32850  subf r7, r3, r5
	ctx.r[7].s64 = ctx.r[5].s64 - ctx.r[3].s64;
	pc = 0x828FB7B8; continue 'dispatch;
            }
            0x828FB7B8 => {
    //   block [0x828FB7B8..0x828FB7F0)
	// 828FB7B8: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 828FB7BC: 419A0058  beq cr6, 0x828fb814
	if ctx.cr[6].eq {
	pc = 0x828FB814; continue 'dispatch;
	}
	// 828FB7C0: 80CBFFF8  lwz r6, -8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FB7C4: 394B0008  addi r10, r11, 8
	ctx.r[10].s64 = ctx.r[11].s64 + 8;
	// 828FB7C8: 39250010  addi r9, r5, 0x10
	ctx.r[9].s64 = ctx.r[5].s64 + 16;
	// 828FB7CC: 3900000A  li r8, 0xa
	ctx.r[8].s64 = 10;
	// 828FB7D0: 90C50000  stw r6, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 828FB7D4: 806BFFFC  lwz r3, -4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 828FB7D8: 90650004  stw r3, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 828FB7DC: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FB7E0: 7CC7592E  stwx r6, r7, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u32) };
	// 828FB7E4: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FB7E8: 9065000C  stw r3, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 828FB7EC: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x828FB7F0; continue 'dispatch;
            }
            0x828FB7F0 => {
    //   block [0x828FB7F0..0x828FB814)
	// 828FB7F0: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FB7F4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 828FB7F8: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828FB7FC: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 828FB800: 4200FFF0  bdnz 0x828fb7f0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828FB7F0; continue 'dispatch;
	}
	// 828FB804: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828FB808: 91450038  stw r10, 0x38(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 828FB80C: 892B0034  lbz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828FB810: 9925003C  stb r9, 0x3c(r5)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[5].u32.wrapping_add(60 as u32), ctx.r[9].u8 ) };
	pc = 0x828FB814; continue 'dispatch;
            }
            0x828FB814 => {
    //   block [0x828FB814..0x828FB828)
	// 828FB814: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 828FB818: 38A50040  addi r5, r5, 0x40
	ctx.r[5].s64 = ctx.r[5].s64 + 64;
	// 828FB81C: 394BFFF8  addi r10, r11, -8
	ctx.r[10].s64 = ctx.r[11].s64 + -8;
	// 828FB820: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 828FB824: 409AFF94  bne cr6, 0x828fb7b8
	if !ctx.cr[6].eq {
	pc = 0x828FB7B8; continue 'dispatch;
	}
	pc = 0x828FB828; continue 'dispatch;
            }
            0x828FB828 => {
    //   block [0x828FB828..0x828FB830)
	// 828FB828: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 828FB82C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FB830 size=8
    let mut pc: u32 = 0x828FB830;
    'dispatch: loop {
        match pc {
            0x828FB830 => {
    //   block [0x828FB830..0x828FB838)
	// 828FB830: 3863FFF4  addi r3, r3, -0xc
	ctx.r[3].s64 = ctx.r[3].s64 + -12;
	// 828FB834: 4BFFE2EC  b 0x828f9b20
	sub_828F9B20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FB838 size=256
    let mut pc: u32 = 0x828FB838;
    'dispatch: loop {
        match pc {
            0x828FB838 => {
    //   block [0x828FB838..0x828FB91C)
	// 828FB838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FB83C: 483ADBC9  bl 0x82ca9404
	ctx.lr = 0x828FB840;
	sub_82CA93D0(ctx, base);
	// 828FB840: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FB844: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FB848: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FB84C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828FB850: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828FB854: 483912FD  bl 0x82c8cb50
	ctx.lr = 0x828FB858;
	sub_82C8CB50(ctx, base);
	// 828FB858: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FB85C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FB860: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828FB864: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FB868: 4E800421  bctrl
	ctx.lr = 0x828FB86C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FB86C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828FB870: 4B9239E9  bl 0x8221f258
	ctx.lr = 0x828FB874;
	sub_8221F258(ctx, base);
	// 828FB874: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FB878: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FB87C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828FB880: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FB884: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828FB888: 8109000C  lwz r8, 0xc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FB88C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FB890: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 828FB894: 4E800421  bctrl
	ctx.lr = 0x828FB898;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FB898: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828FB89C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FB8A0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FB8A4: 48390EDD  bl 0x82c8c780
	ctx.lr = 0x828FB8A8;
	sub_82C8C780(ctx, base);
	// 828FB8A8: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 828FB8AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FB8B0: 38874A6C  addi r4, r7, 0x4a6c
	ctx.r[4].s64 = ctx.r[7].s64 + 19052;
	// 828FB8B4: 483917F5  bl 0x82c8d0a8
	ctx.lr = 0x828FB8B8;
	sub_82C8D0A8(ctx, base);
	// 828FB8B8: 5466063E  clrlwi r6, r3, 0x18
	ctx.r[6].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828FB8BC: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 828FB8C0: 419A005C  beq cr6, 0x828fb91c
	if ctx.cr[6].eq {
	pc = 0x828FB91C; continue 'dispatch;
	}
	// 828FB8C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828FB8C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FB8CC: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 828FB8D0: 4838D409  bl 0x82c88cd8
	ctx.lr = 0x828FB8D4;
	sub_82C88CD8(ctx, base);
	// 828FB8D4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828FB8D8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828FB8DC: 388A2DF8  addi r4, r10, 0x2df8
	ctx.r[4].s64 = ctx.r[10].s64 + 11768;
	// 828FB8E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FB8E4: 483915ED  bl 0x82c8ced0
	ctx.lr = 0x828FB8E8;
	sub_82C8CED0(ctx, base);
	// 828FB8E8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828FB8EC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828FB8F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FB8F4: 48000045  bl 0x828fb938
	ctx.lr = 0x828FB8F8;
	sub_828FB938(ctx, base);
	// 828FB8F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FB8FC: 4839140D  bl 0x82c8cd08
	ctx.lr = 0x828FB900;
	sub_82C8CD08(ctx, base);
	// 828FB900: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FB904: 4B920435  bl 0x8221bd38
	ctx.lr = 0x828FB908;
	sub_8221BD38(ctx, base);
	// 828FB908: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FB90C: 48391295  bl 0x82c8cba0
	ctx.lr = 0x828FB910;
	sub_82C8CBA0(ctx, base);
	// 828FB910: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828FB914: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828FB918: 483ADB3C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x828FB91C => {
    //   block [0x828FB91C..0x828FB938)
	// 828FB91C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FB920: 4B920419  bl 0x8221bd38
	ctx.lr = 0x828FB924;
	sub_8221BD38(ctx, base);
	// 828FB924: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FB928: 48391279  bl 0x82c8cba0
	ctx.lr = 0x828FB92C;
	sub_82C8CBA0(ctx, base);
	// 828FB92C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828FB930: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828FB934: 483ADB20  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FB938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FB938 size=912
    let mut pc: u32 = 0x828FB938;
    'dispatch: loop {
        match pc {
            0x828FB938 => {
    //   block [0x828FB938..0x828FB9C4)
	// 828FB938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FB93C: 483ADAB5  bl 0x82ca93f0
	ctx.lr = 0x828FB940;
	sub_82CA93D0(ctx, base);
	// 828FB940: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FB944: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828FB948: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 828FB94C: 3BCB0CA0  addi r30, r11, 0xca0
	ctx.r[30].s64 = ctx.r[11].s64 + 3232;
	// 828FB950: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828FB954: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FB958: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FB95C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 828FB960: 4838D379  bl 0x82c88cd8
	ctx.lr = 0x828FB964;
	sub_82C88CD8(ctx, base);
	// 828FB964: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FB968: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FB96C: 4838D36D  bl 0x82c88cd8
	ctx.lr = 0x828FB970;
	sub_82C88CD8(ctx, base);
	// 828FB970: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FB974: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828FB978: 4838D361  bl 0x82c88cd8
	ctx.lr = 0x828FB97C;
	sub_82C88CD8(ctx, base);
	// 828FB97C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FB980: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FB984: 812A0048  lwz r9, 0x48(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(72 as u32) ) } as u64;
	// 828FB988: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828FB98C: 4E800421  bctrl
	ctx.lr = 0x828FB990;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FB990: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828FB994: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828FB998: 419A0324  beq cr6, 0x828fbcbc
	if ctx.cr[6].eq {
	pc = 0x828FBCBC; continue 'dispatch;
	}
	// 828FB99C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828FB9A0: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828FB9A4: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 828FB9A8: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 828FB9AC: 3CE0820E  lis r7, -0x7df2
	ctx.r[7].s64 = -2113011712;
	// 828FB9B0: 3AEB86B4  addi r23, r11, -0x794c
	ctx.r[23].s64 = ctx.r[11].s64 + -31052;
	// 828FB9B4: 3B4A4D6C  addi r26, r10, 0x4d6c
	ctx.r[26].s64 = ctx.r[10].s64 + 19820;
	// 828FB9B8: 3B2970A8  addi r25, r9, 0x70a8
	ctx.r[25].s64 = ctx.r[9].s64 + 28840;
	// 828FB9BC: 3B882DF8  addi r28, r8, 0x2df8
	ctx.r[28].s64 = ctx.r[8].s64 + 11768;
	// 828FB9C0: 3B074D64  addi r24, r7, 0x4d64
	ctx.r[24].s64 = ctx.r[7].s64 + 19812;
            }
            0x828FB9C4 => {
    //   block [0x828FB9C4..0x828FB9E0)
	// 828FB9C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FB9C8: 48391649  bl 0x82c8d010
	ctx.lr = 0x828FB9CC;
	sub_82C8D010(ctx, base);
	// 828FB9CC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828FB9D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FB9D4: 419A0284  beq cr6, 0x828fbc58
	if ctx.cr[6].eq {
	pc = 0x828FBC58; continue 'dispatch;
	}
	// 828FB9D8: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 828FB9DC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x828FB9E0; continue 'dispatch;
            }
            0x828FB9E0 => {
    //   block [0x828FB9E0..0x828FBA04)
	// 828FB9E0: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FB9E4: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FB9E8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FB9EC: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828FB9F0: 419A0014  beq cr6, 0x828fba04
	if ctx.cr[6].eq {
	pc = 0x828FBA04; continue 'dispatch;
	}
	// 828FB9F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828FB9F8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828FB9FC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FBA00: 419AFFE0  beq cr6, 0x828fb9e0
	if ctx.cr[6].eq {
	pc = 0x828FB9E0; continue 'dispatch;
	}
	pc = 0x828FBA04; continue 'dispatch;
            }
            0x828FBA04 => {
    //   block [0x828FBA04..0x828FBA68)
	// 828FBA04: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FBA08: 409A0060  bne cr6, 0x828fba68
	if !ctx.cr[6].eq {
	pc = 0x828FBA68; continue 'dispatch;
	}
	// 828FBA0C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBA10: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828FBA14: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828FBA18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FBA1C: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828FBA20: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FBA24: 4E800421  bctrl
	ctx.lr = 0x828FBA28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FBA28: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828FBA2C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828FBA30: 419A0038  beq cr6, 0x828fba68
	if ctx.cr[6].eq {
	pc = 0x828FBA68; continue 'dispatch;
	}
	// 828FBA34: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828FBA38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FBA3C: 480003DD  bl 0x828fbe18
	ctx.lr = 0x828FBA40;
	sub_828FBE18(ctx, base);
	// 828FBA40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FBA44: 4838CD15  bl 0x82c88758
	ctx.lr = 0x828FBA48;
	sub_82C88758(ctx, base);
	// 828FBA48: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FBA4C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FBA50: 4838CD09  bl 0x82c88758
	ctx.lr = 0x828FBA54;
	sub_82C88758(ctx, base);
	// 828FBA54: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FBA58: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828FBA5C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828FBA60: 485B40C1  bl 0x82eafb20
	ctx.lr = 0x828FBA64;
	sub_82EAFB20(ctx, base);
	// 828FBA64: 480001B0  b 0x828fbc14
	pc = 0x828FBC14; continue 'dispatch;
            }
            0x828FBA68 => {
    //   block [0x828FBA68..0x828FBA70)
	// 828FBA68: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 828FBA6C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x828FBA70; continue 'dispatch;
            }
            0x828FBA70 => {
    //   block [0x828FBA70..0x828FBA94)
	// 828FBA70: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBA74: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBA78: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FBA7C: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828FBA80: 419A0014  beq cr6, 0x828fba94
	if ctx.cr[6].eq {
	pc = 0x828FBA94; continue 'dispatch;
	}
	// 828FBA84: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828FBA88: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828FBA8C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FBA90: 419AFFE0  beq cr6, 0x828fba70
	if ctx.cr[6].eq {
	pc = 0x828FBA70; continue 'dispatch;
	}
	pc = 0x828FBA94; continue 'dispatch;
            }
            0x828FBA94 => {
    //   block [0x828FBA94..0x828FBAF8)
	// 828FBA94: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FBA98: 409A0060  bne cr6, 0x828fbaf8
	if !ctx.cr[6].eq {
	pc = 0x828FBAF8; continue 'dispatch;
	}
	// 828FBA9C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBAA0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828FBAA4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828FBAA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FBAAC: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828FBAB0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FBAB4: 4E800421  bctrl
	ctx.lr = 0x828FBAB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FBAB8: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828FBABC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828FBAC0: 419A0038  beq cr6, 0x828fbaf8
	if ctx.cr[6].eq {
	pc = 0x828FBAF8; continue 'dispatch;
	}
	// 828FBAC4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828FBAC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FBACC: 4800034D  bl 0x828fbe18
	ctx.lr = 0x828FBAD0;
	sub_828FBE18(ctx, base);
	// 828FBAD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FBAD4: 4838CC85  bl 0x82c88758
	ctx.lr = 0x828FBAD8;
	sub_82C88758(ctx, base);
	// 828FBAD8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FBADC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FBAE0: 4838CC79  bl 0x82c88758
	ctx.lr = 0x828FBAE4;
	sub_82C88758(ctx, base);
	// 828FBAE4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FBAE8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828FBAEC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828FBAF0: 485B3F71  bl 0x82eafa60
	ctx.lr = 0x828FBAF4;
	sub_82EAFA60(ctx, base);
	// 828FBAF4: 48000120  b 0x828fbc14
	pc = 0x828FBC14; continue 'dispatch;
            }
            0x828FBAF8 => {
    //   block [0x828FBAF8..0x828FBB00)
	// 828FBAF8: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 828FBAFC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x828FBB00; continue 'dispatch;
            }
            0x828FBB00 => {
    //   block [0x828FBB00..0x828FBB24)
	// 828FBB00: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBB04: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBB08: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FBB0C: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828FBB10: 419A0014  beq cr6, 0x828fbb24
	if ctx.cr[6].eq {
	pc = 0x828FBB24; continue 'dispatch;
	}
	// 828FBB14: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828FBB18: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828FBB1C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FBB20: 419AFFE0  beq cr6, 0x828fbb00
	if ctx.cr[6].eq {
	pc = 0x828FBB00; continue 'dispatch;
	}
	pc = 0x828FBB24; continue 'dispatch;
            }
            0x828FBB24 => {
    //   block [0x828FBB24..0x828FBBA4)
	// 828FBB24: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FBB28: 409A007C  bne cr6, 0x828fbba4
	if !ctx.cr[6].eq {
	pc = 0x828FBBA4; continue 'dispatch;
	}
	// 828FBB2C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBB30: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828FBB34: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828FBB38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FBB3C: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828FBB40: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FBB44: 4E800421  bctrl
	ctx.lr = 0x828FBB48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FBB48: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828FBB4C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828FBB50: 419A0054  beq cr6, 0x828fbba4
	if ctx.cr[6].eq {
	pc = 0x828FBBA4; continue 'dispatch;
	}
	// 828FBB54: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBB58: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828FBB5C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828FBB60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FBB64: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828FBB68: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FBB6C: 4E800421  bctrl
	ctx.lr = 0x828FBB70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FBB70: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828FBB74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FBB78: 480002A1  bl 0x828fbe18
	ctx.lr = 0x828FBB7C;
	sub_828FBE18(ctx, base);
	// 828FBB7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FBB80: 4838CBD9  bl 0x82c88758
	ctx.lr = 0x828FBB84;
	sub_82C88758(ctx, base);
	// 828FBB84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FBB88: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FBB8C: 4838CBCD  bl 0x82c88758
	ctx.lr = 0x828FBB90;
	sub_82C88758(ctx, base);
	// 828FBB90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FBB94: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828FBB98: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828FBB9C: 485B3F25  bl 0x82eafac0
	ctx.lr = 0x828FBBA0;
	sub_82EAFAC0(ctx, base);
	// 828FBBA0: 48000074  b 0x828fbc14
	pc = 0x828FBC14; continue 'dispatch;
            }
            0x828FBBA4 => {
    //   block [0x828FBBA4..0x828FBBF8)
	// 828FBBA4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBBA8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828FBBAC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828FBBB0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828FBBB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FBBB8: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828FBBBC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FBBC0: 4E800421  bctrl
	ctx.lr = 0x828FBBC4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FBBC4: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828FBBC8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828FBBCC: 409A002C  bne cr6, 0x828fbbf8
	if !ctx.cr[6].eq {
	pc = 0x828FBBF8; continue 'dispatch;
	}
	// 828FBBD0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBBD4: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 828FBBD8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828FBBDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FBBE0: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828FBBE4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FBBE8: 4E800421  bctrl
	ctx.lr = 0x828FBBEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FBBEC: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828FBBF0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828FBBF4: 419A0010  beq cr6, 0x828fbc04
	if ctx.cr[6].eq {
	pc = 0x828FBC04; continue 'dispatch;
	}
            }
            0x828FBBF8 => {
    //   block [0x828FBBF8..0x828FBC04)
	// 828FBBF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FBBFC: 4838CB5D  bl 0x82c88758
	ctx.lr = 0x828FBC00;
	sub_82C88758(ctx, base);
	// 828FBC00: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	pc = 0x828FBC04; continue 'dispatch;
            }
            0x828FBC04 => {
    //   block [0x828FBC04..0x828FBC14)
	// 828FBC04: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828FBC08: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828FBC0C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828FBC10: 485B3E29  bl 0x82eafa38
	ctx.lr = 0x828FBC14;
	sub_82EAFA38(ctx, base);
	pc = 0x828FBC14; continue 'dispatch;
            }
            0x828FBC14 => {
    //   block [0x828FBC14..0x828FBC58)
	// 828FBC14: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828FBC18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FBC1C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 828FBC20: 4BFFFD19  bl 0x828fb938
	ctx.lr = 0x828FBC24;
	sub_828FB938(ctx, base);
	// 828FBC24: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBC28: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828FBC2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FBC30: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 828FBC34: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FBC38: 553EDFFE  rlwinm r30, r9, 0x1b, 0x1f, 0x1f
	ctx.r[30].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 828FBC3C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 828FBC40: 4E800421  bctrl
	ctx.lr = 0x828FBC44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FBC44: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828FBC48: 419A0054  beq cr6, 0x828fbc9c
	if ctx.cr[6].eq {
	pc = 0x828FBC9C; continue 'dispatch;
	}
	// 828FBC4C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828FBC50: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828FBC54: 483AD7EC  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x828FBC58 => {
    //   block [0x828FBC58..0x828FBC9C)
	// 828FBC58: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBC5C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828FBC60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FBC64: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828FBC68: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FBC6C: 4E800421  bctrl
	ctx.lr = 0x828FBC70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FBC70: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FBC74: 4838CAE5  bl 0x82c88758
	ctx.lr = 0x828FBC78;
	sub_82C88758(ctx, base);
	// 828FBC78: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828FBC7C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828FBC80: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828FBC84: 485B3DCD  bl 0x82eafa50
	ctx.lr = 0x828FBC88;
	sub_82EAFA50(ctx, base);
	// 828FBC88: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBC8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FBC90: 8109000C  lwz r8, 0xc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FBC94: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 828FBC98: 4E800421  bctrl
	ctx.lr = 0x828FBC9C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828FBC9C => {
    //   block [0x828FBC9C..0x828FBCBC)
	// 828FBC9C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBCA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FBCA4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828FBCA8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FBCAC: 4E800421  bctrl
	ctx.lr = 0x828FBCB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FBCB0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828FBCB4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828FBCB8: 409AFD0C  bne cr6, 0x828fb9c4
	if !ctx.cr[6].eq {
	pc = 0x828FB9C4; continue 'dispatch;
	}
            }
            0x828FBCBC => {
    //   block [0x828FBCBC..0x828FBCC8)
	// 828FBCBC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828FBCC0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828FBCC4: 483AD77C  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FBCC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FBCC8 size=128
    let mut pc: u32 = 0x828FBCC8;
    'dispatch: loop {
        match pc {
            0x828FBCC8 => {
    //   block [0x828FBCC8..0x828FBD24)
	// 828FBCC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FBCCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FBCD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828FBCD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FBCD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FBCDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FBCE0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828FBCE4: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828FBCE8: 3BCB6B38  addi r30, r11, 0x6b38
	ctx.r[30].s64 = ctx.r[11].s64 + 27448;
	// 828FBCEC: 4801201D  bl 0x8290dd08
	ctx.lr = 0x828FBCF0;
	sub_8290DD08(ctx, base);
	// 828FBCF0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FBCF4: 48000195  bl 0x828fbe88
	ctx.lr = 0x828FBCF8;
	sub_828FBE88(ctx, base);
	// 828FBCF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FBCFC: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 828FBD00: 419A0024  beq cr6, 0x828fbd24
	if ctx.cr[6].eq {
	pc = 0x828FBD24; continue 'dispatch;
	}
	// 828FBD04: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBD08: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828FBD0C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FBD10: 4E800421  bctrl
	ctx.lr = 0x828FBD14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FBD14: 2F03000A  cmpwi cr6, r3, 0xa
	ctx.cr[6].compare_i32(ctx.r[3].s32, 10, &mut ctx.xer);
	// 828FBD18: 409A0014  bne cr6, 0x828fbd2c
	if !ctx.cr[6].eq {
	pc = 0x828FBD2C; continue 'dispatch;
	}
	// 828FBD1C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FBD20: 48000669  bl 0x828fc388
	ctx.lr = 0x828FBD24;
	sub_828FC388(ctx, base);
            }
            0x828FBD24 => {
    //   block [0x828FBD24..0x828FBD2C)
	// 828FBD24: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828FBD28: 48000008  b 0x828fbd30
	pc = 0x828FBD30; continue 'dispatch;
            }
            0x828FBD2C => {
    //   block [0x828FBD2C..0x828FBD30)
	// 828FBD2C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x828FBD30; continue 'dispatch;
            }
            0x828FBD30 => {
    //   block [0x828FBD30..0x828FBD48)
	// 828FBD30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FBD34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FBD38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FBD3C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828FBD40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FBD44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FBD48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FBD48 size=76
    let mut pc: u32 = 0x828FBD48;
    'dispatch: loop {
        match pc {
            0x828FBD48 => {
    //   block [0x828FBD48..0x828FBD94)
	// 828FBD48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FBD4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FBD50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FBD54: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FBD58: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FBD5C: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 828FBD60: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828FBD64: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828FBD68: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828FBD6C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBD70: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FBD74: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FBD78: 4E800421  bctrl
	ctx.lr = 0x828FBD7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FBD7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FBD80: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828FBD84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FBD88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FBD8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FBD90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FBD98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FBD98 size=104
    let mut pc: u32 = 0x828FBD98;
    'dispatch: loop {
        match pc {
            0x828FBD98 => {
    //   block [0x828FBD98..0x828FBE00)
	// 828FBD98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FBD9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FBDA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828FBDA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FBDA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FBDAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FBDB0: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FBDB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FBDB8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBDBC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FBDC0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FBDC4: 4E800421  bctrl
	ctx.lr = 0x828FBDC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FBDC8: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBDCC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828FBDD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FBDD4: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBDD8: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 828FBDDC: 4E800421  bctrl
	ctx.lr = 0x828FBDE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FBDE0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828FBDE4: 90FF0004  stw r7, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 828FBDE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FBDEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FBDF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FBDF4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828FBDF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FBDFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FBE00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FBE00 size=20
    let mut pc: u32 = 0x828FBE00;
    'dispatch: loop {
        match pc {
            0x828FBE00 => {
    //   block [0x828FBE00..0x828FBE14)
	// 828FBE00: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FBE04: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBE08: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828FBE0C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FBE10: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FBE18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FBE18 size=104
    let mut pc: u32 = 0x828FBE18;
    'dispatch: loop {
        match pc {
            0x828FBE18 => {
    //   block [0x828FBE18..0x828FBE74)
	// 828FBE18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FBE1C: 483AD5F1  bl 0x82ca940c
	ctx.lr = 0x828FBE20;
	sub_82CA93D0(ctx, base);
	// 828FBE20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FBE24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FBE28: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828FBE2C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBE30: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 828FBE34: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FBE38: 4E800421  bctrl
	ctx.lr = 0x828FBE3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FBE3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FBE40: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828FBE44: 419A0030  beq cr6, 0x828fbe74
	if ctx.cr[6].eq {
	pc = 0x828FBE74; continue 'dispatch;
	}
	// 828FBE48: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBE4C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828FBE50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FBE54: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828FBE58: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FBE5C: 4E800421  bctrl
	ctx.lr = 0x828FBE60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FBE60: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBE64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FBE68: 8109000C  lwz r8, 0xc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FBE6C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 828FBE70: 4E800421  bctrl
	ctx.lr = 0x828FBE74;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828FBE74 => {
    //   block [0x828FBE74..0x828FBE80)
	// 828FBE74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FBE78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FBE7C: 483AD5E0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FBE80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FBE80 size=8
    let mut pc: u32 = 0x828FBE80;
    'dispatch: loop {
        match pc {
            0x828FBE80 => {
    //   block [0x828FBE80..0x828FBE88)
	// 828FBE80: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828FBE84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FBE88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FBE88 size=1276
    let mut pc: u32 = 0x828FBE88;
    'dispatch: loop {
        match pc {
            0x828FBE88 => {
    //   block [0x828FBE88..0x828FBED0)
	// 828FBE88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FBE8C: 483AD575  bl 0x82ca9400
	ctx.lr = 0x828FBE90;
	sub_82CA93D0(ctx, base);
	// 828FBE90: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FBE94: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828FBE98: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 828FBE9C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828FBEA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FBEA4: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 828FBEA8: 3B800003  li r28, 3
	ctx.r[28].s64 = 3;
	// 828FBEAC: 4B931025  bl 0x8222ced0
	ctx.lr = 0x828FBEB0;
	sub_8222CED0(ctx, base);
	// 828FBEB0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828FBEB4: 3BCB0CA0  addi r30, r11, 0xca0
	ctx.r[30].s64 = ctx.r[11].s64 + 3232;
	// 828FBEB8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828FBEBC: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FBEC0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828FBEC4: 409A003C  bne cr6, 0x828fbf00
	if !ctx.cr[6].eq {
	pc = 0x828FBF00; continue 'dispatch;
	}
	// 828FBEC8: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 828FBECC: 396B8E90  addi r11, r11, -0x7170
	ctx.r[11].s64 = ctx.r[11].s64 + -29040;
	pc = 0x828FBED0; continue 'dispatch;
            }
            0x828FBED0 => {
    //   block [0x828FBED0..0x828FBEF4)
	// 828FBED0: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBED4: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBED8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FBEDC: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828FBEE0: 419A0014  beq cr6, 0x828fbef4
	if ctx.cr[6].eq {
	pc = 0x828FBEF4; continue 'dispatch;
	}
	// 828FBEE4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828FBEE8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828FBEEC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FBEF0: 419AFFE0  beq cr6, 0x828fbed0
	if ctx.cr[6].eq {
	pc = 0x828FBED0; continue 'dispatch;
	}
	pc = 0x828FBEF4; continue 'dispatch;
            }
            0x828FBEF4 => {
    //   block [0x828FBEF4..0x828FBF00)
	// 828FBEF4: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 828FBEF8: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828FBEFC: 48000018  b 0x828fbf14
	pc = 0x828FBF14; continue 'dispatch;
            }
            0x828FBF00 => {
    //   block [0x828FBF00..0x828FBF14)
	// 828FBF00: 388B8E90  addi r4, r11, -0x7170
	ctx.r[4].s64 = ctx.r[11].s64 + -29040;
	// 828FBF04: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBF08: 4B9718F1  bl 0x8226d7f8
	ctx.lr = 0x828FBF0C;
	sub_8226D7F8(ctx, base);
	// 828FBF0C: 7C6A0034  cntlzw r10, r3
	ctx.r[10].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 828FBF10: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	pc = 0x828FBF14; continue 'dispatch;
            }
            0x828FBF14 => {
    //   block [0x828FBF14..0x828FBF34)
	// 828FBF14: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FBF18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FBF1C: 409A02D0  bne cr6, 0x828fc1ec
	if !ctx.cr[6].eq {
	pc = 0x828FC1EC; continue 'dispatch;
	}
	// 828FBF20: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828FBF24: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828FBF28: 409A003C  bne cr6, 0x828fbf64
	if !ctx.cr[6].eq {
	pc = 0x828FBF64; continue 'dispatch;
	}
	// 828FBF2C: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 828FBF30: 396B6B38  addi r11, r11, 0x6b38
	ctx.r[11].s64 = ctx.r[11].s64 + 27448;
	pc = 0x828FBF34; continue 'dispatch;
            }
            0x828FBF34 => {
    //   block [0x828FBF34..0x828FBF58)
	// 828FBF34: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBF38: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBF3C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FBF40: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828FBF44: 419A0014  beq cr6, 0x828fbf58
	if ctx.cr[6].eq {
	pc = 0x828FBF58; continue 'dispatch;
	}
	// 828FBF48: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828FBF4C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828FBF50: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FBF54: 419AFFE0  beq cr6, 0x828fbf34
	if ctx.cr[6].eq {
	pc = 0x828FBF34; continue 'dispatch;
	}
	pc = 0x828FBF58; continue 'dispatch;
            }
            0x828FBF58 => {
    //   block [0x828FBF58..0x828FBF64)
	// 828FBF58: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 828FBF5C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828FBF60: 48000018  b 0x828fbf78
	pc = 0x828FBF78; continue 'dispatch;
            }
            0x828FBF64 => {
    //   block [0x828FBF64..0x828FBF78)
	// 828FBF64: 388B6B38  addi r4, r11, 0x6b38
	ctx.r[4].s64 = ctx.r[11].s64 + 27448;
	// 828FBF68: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBF6C: 4B97188D  bl 0x8226d7f8
	ctx.lr = 0x828FBF70;
	sub_8226D7F8(ctx, base);
	// 828FBF70: 7C6A0034  cntlzw r10, r3
	ctx.r[10].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 828FBF74: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	pc = 0x828FBF78; continue 'dispatch;
            }
            0x828FBF78 => {
    //   block [0x828FBF78..0x828FBF98)
	// 828FBF78: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FBF7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FBF80: 409A026C  bne cr6, 0x828fc1ec
	if !ctx.cr[6].eq {
	pc = 0x828FC1EC; continue 'dispatch;
	}
	// 828FBF84: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828FBF88: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828FBF8C: 409A003C  bne cr6, 0x828fbfc8
	if !ctx.cr[6].eq {
	pc = 0x828FBFC8; continue 'dispatch;
	}
	// 828FBF90: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 828FBF94: 396B8E94  addi r11, r11, -0x716c
	ctx.r[11].s64 = ctx.r[11].s64 + -29036;
	pc = 0x828FBF98; continue 'dispatch;
            }
            0x828FBF98 => {
    //   block [0x828FBF98..0x828FBFBC)
	// 828FBF98: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBF9C: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBFA0: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FBFA4: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828FBFA8: 419A0014  beq cr6, 0x828fbfbc
	if ctx.cr[6].eq {
	pc = 0x828FBFBC; continue 'dispatch;
	}
	// 828FBFAC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828FBFB0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828FBFB4: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FBFB8: 419AFFE0  beq cr6, 0x828fbf98
	if ctx.cr[6].eq {
	pc = 0x828FBF98; continue 'dispatch;
	}
	pc = 0x828FBFBC; continue 'dispatch;
            }
            0x828FBFBC => {
    //   block [0x828FBFBC..0x828FBFC8)
	// 828FBFBC: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 828FBFC0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828FBFC4: 48000018  b 0x828fbfdc
	pc = 0x828FBFDC; continue 'dispatch;
            }
            0x828FBFC8 => {
    //   block [0x828FBFC8..0x828FBFDC)
	// 828FBFC8: 388B8E94  addi r4, r11, -0x716c
	ctx.r[4].s64 = ctx.r[11].s64 + -29036;
	// 828FBFCC: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FBFD0: 4B971829  bl 0x8226d7f8
	ctx.lr = 0x828FBFD4;
	sub_8226D7F8(ctx, base);
	// 828FBFD4: 7C6A0034  cntlzw r10, r3
	ctx.r[10].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 828FBFD8: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	pc = 0x828FBFDC; continue 'dispatch;
            }
            0x828FBFDC => {
    //   block [0x828FBFDC..0x828FBFFC)
	// 828FBFDC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FBFE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FBFE4: 409A0200  bne cr6, 0x828fc1e4
	if !ctx.cr[6].eq {
	pc = 0x828FC1E4; continue 'dispatch;
	}
	// 828FBFE8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828FBFEC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828FBFF0: 409A003C  bne cr6, 0x828fc02c
	if !ctx.cr[6].eq {
	pc = 0x828FC02C; continue 'dispatch;
	}
	// 828FBFF4: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 828FBFF8: 396B8E98  addi r11, r11, -0x7168
	ctx.r[11].s64 = ctx.r[11].s64 + -29032;
	pc = 0x828FBFFC; continue 'dispatch;
            }
            0x828FBFFC => {
    //   block [0x828FBFFC..0x828FC020)
	// 828FBFFC: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC000: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC004: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FC008: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828FC00C: 419A0014  beq cr6, 0x828fc020
	if ctx.cr[6].eq {
	pc = 0x828FC020; continue 'dispatch;
	}
	// 828FC010: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828FC014: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828FC018: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FC01C: 419AFFE0  beq cr6, 0x828fbffc
	if ctx.cr[6].eq {
	pc = 0x828FBFFC; continue 'dispatch;
	}
	pc = 0x828FC020; continue 'dispatch;
            }
            0x828FC020 => {
    //   block [0x828FC020..0x828FC02C)
	// 828FC020: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 828FC024: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828FC028: 48000018  b 0x828fc040
	pc = 0x828FC040; continue 'dispatch;
            }
            0x828FC02C => {
    //   block [0x828FC02C..0x828FC040)
	// 828FC02C: 388B8E98  addi r4, r11, -0x7168
	ctx.r[4].s64 = ctx.r[11].s64 + -29032;
	// 828FC030: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC034: 4B9717C5  bl 0x8226d7f8
	ctx.lr = 0x828FC038;
	sub_8226D7F8(ctx, base);
	// 828FC038: 7C6A0034  cntlzw r10, r3
	ctx.r[10].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 828FC03C: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	pc = 0x828FC040; continue 'dispatch;
            }
            0x828FC040 => {
    //   block [0x828FC040..0x828FC060)
	// 828FC040: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FC044: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FC048: 409A019C  bne cr6, 0x828fc1e4
	if !ctx.cr[6].eq {
	pc = 0x828FC1E4; continue 'dispatch;
	}
	// 828FC04C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828FC050: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828FC054: 409A003C  bne cr6, 0x828fc090
	if !ctx.cr[6].eq {
	pc = 0x828FC090; continue 'dispatch;
	}
	// 828FC058: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 828FC05C: 396B8E9C  addi r11, r11, -0x7164
	ctx.r[11].s64 = ctx.r[11].s64 + -29028;
	pc = 0x828FC060; continue 'dispatch;
            }
            0x828FC060 => {
    //   block [0x828FC060..0x828FC084)
	// 828FC060: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC064: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC068: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FC06C: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828FC070: 419A0014  beq cr6, 0x828fc084
	if ctx.cr[6].eq {
	pc = 0x828FC084; continue 'dispatch;
	}
	// 828FC074: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828FC078: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828FC07C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FC080: 419AFFE0  beq cr6, 0x828fc060
	if ctx.cr[6].eq {
	pc = 0x828FC060; continue 'dispatch;
	}
	pc = 0x828FC084; continue 'dispatch;
            }
            0x828FC084 => {
    //   block [0x828FC084..0x828FC090)
	// 828FC084: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 828FC088: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828FC08C: 48000018  b 0x828fc0a4
	pc = 0x828FC0A4; continue 'dispatch;
            }
            0x828FC090 => {
    //   block [0x828FC090..0x828FC0A4)
	// 828FC090: 388B8E9C  addi r4, r11, -0x7164
	ctx.r[4].s64 = ctx.r[11].s64 + -29028;
	// 828FC094: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC098: 4B971761  bl 0x8226d7f8
	ctx.lr = 0x828FC09C;
	sub_8226D7F8(ctx, base);
	// 828FC09C: 7C6A0034  cntlzw r10, r3
	ctx.r[10].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 828FC0A0: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	pc = 0x828FC0A4; continue 'dispatch;
            }
            0x828FC0A4 => {
    //   block [0x828FC0A4..0x828FC0C4)
	// 828FC0A4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FC0A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FC0AC: 409A0130  bne cr6, 0x828fc1dc
	if !ctx.cr[6].eq {
	pc = 0x828FC1DC; continue 'dispatch;
	}
	// 828FC0B0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828FC0B4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828FC0B8: 409A003C  bne cr6, 0x828fc0f4
	if !ctx.cr[6].eq {
	pc = 0x828FC0F4; continue 'dispatch;
	}
	// 828FC0BC: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 828FC0C0: 396B8EA0  addi r11, r11, -0x7160
	ctx.r[11].s64 = ctx.r[11].s64 + -29024;
	pc = 0x828FC0C4; continue 'dispatch;
            }
            0x828FC0C4 => {
    //   block [0x828FC0C4..0x828FC0E8)
	// 828FC0C4: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC0C8: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC0CC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FC0D0: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828FC0D4: 419A0014  beq cr6, 0x828fc0e8
	if ctx.cr[6].eq {
	pc = 0x828FC0E8; continue 'dispatch;
	}
	// 828FC0D8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828FC0DC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828FC0E0: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FC0E4: 419AFFE0  beq cr6, 0x828fc0c4
	if ctx.cr[6].eq {
	pc = 0x828FC0C4; continue 'dispatch;
	}
	pc = 0x828FC0E8; continue 'dispatch;
            }
            0x828FC0E8 => {
    //   block [0x828FC0E8..0x828FC0F4)
	// 828FC0E8: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 828FC0EC: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828FC0F0: 48000018  b 0x828fc108
	pc = 0x828FC108; continue 'dispatch;
            }
            0x828FC0F4 => {
    //   block [0x828FC0F4..0x828FC108)
	// 828FC0F4: 388B8EA0  addi r4, r11, -0x7160
	ctx.r[4].s64 = ctx.r[11].s64 + -29024;
	// 828FC0F8: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC0FC: 4B9716FD  bl 0x8226d7f8
	ctx.lr = 0x828FC100;
	sub_8226D7F8(ctx, base);
	// 828FC100: 7C6A0034  cntlzw r10, r3
	ctx.r[10].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 828FC104: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	pc = 0x828FC108; continue 'dispatch;
            }
            0x828FC108 => {
    //   block [0x828FC108..0x828FC128)
	// 828FC108: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FC10C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FC110: 409A00CC  bne cr6, 0x828fc1dc
	if !ctx.cr[6].eq {
	pc = 0x828FC1DC; continue 'dispatch;
	}
	// 828FC114: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828FC118: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828FC11C: 409A003C  bne cr6, 0x828fc158
	if !ctx.cr[6].eq {
	pc = 0x828FC158; continue 'dispatch;
	}
	// 828FC120: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 828FC124: 396B8EA4  addi r11, r11, -0x715c
	ctx.r[11].s64 = ctx.r[11].s64 + -29020;
	pc = 0x828FC128; continue 'dispatch;
            }
            0x828FC128 => {
    //   block [0x828FC128..0x828FC14C)
	// 828FC128: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC12C: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC130: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FC134: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828FC138: 419A0014  beq cr6, 0x828fc14c
	if ctx.cr[6].eq {
	pc = 0x828FC14C; continue 'dispatch;
	}
	// 828FC13C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828FC140: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828FC144: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FC148: 419AFFE0  beq cr6, 0x828fc128
	if ctx.cr[6].eq {
	pc = 0x828FC128; continue 'dispatch;
	}
	pc = 0x828FC14C; continue 'dispatch;
            }
            0x828FC14C => {
    //   block [0x828FC14C..0x828FC158)
	// 828FC14C: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 828FC150: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828FC154: 48000018  b 0x828fc16c
	pc = 0x828FC16C; continue 'dispatch;
            }
            0x828FC158 => {
    //   block [0x828FC158..0x828FC16C)
	// 828FC158: 388B8EA4  addi r4, r11, -0x715c
	ctx.r[4].s64 = ctx.r[11].s64 + -29020;
	// 828FC15C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC160: 4B971699  bl 0x8226d7f8
	ctx.lr = 0x828FC164;
	sub_8226D7F8(ctx, base);
	// 828FC164: 7C6A0034  cntlzw r10, r3
	ctx.r[10].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 828FC168: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	pc = 0x828FC16C; continue 'dispatch;
            }
            0x828FC16C => {
    //   block [0x828FC16C..0x828FC18C)
	// 828FC16C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FC170: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FC174: 409A0068  bne cr6, 0x828fc1dc
	if !ctx.cr[6].eq {
	pc = 0x828FC1DC; continue 'dispatch;
	}
	// 828FC178: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828FC17C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828FC180: 409A003C  bne cr6, 0x828fc1bc
	if !ctx.cr[6].eq {
	pc = 0x828FC1BC; continue 'dispatch;
	}
	// 828FC184: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 828FC188: 396B8EA8  addi r11, r11, -0x7158
	ctx.r[11].s64 = ctx.r[11].s64 + -29016;
	pc = 0x828FC18C; continue 'dispatch;
            }
            0x828FC18C => {
    //   block [0x828FC18C..0x828FC1B0)
	// 828FC18C: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC190: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC194: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FC198: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828FC19C: 419A0014  beq cr6, 0x828fc1b0
	if ctx.cr[6].eq {
	pc = 0x828FC1B0; continue 'dispatch;
	}
	// 828FC1A0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828FC1A4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828FC1A8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FC1AC: 419AFFE0  beq cr6, 0x828fc18c
	if ctx.cr[6].eq {
	pc = 0x828FC18C; continue 'dispatch;
	}
	pc = 0x828FC1B0; continue 'dispatch;
            }
            0x828FC1B0 => {
    //   block [0x828FC1B0..0x828FC1BC)
	// 828FC1B0: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 828FC1B4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828FC1B8: 48000018  b 0x828fc1d0
	pc = 0x828FC1D0; continue 'dispatch;
            }
            0x828FC1BC => {
    //   block [0x828FC1BC..0x828FC1D0)
	// 828FC1BC: 388B8EA8  addi r4, r11, -0x7158
	ctx.r[4].s64 = ctx.r[11].s64 + -29016;
	// 828FC1C0: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC1C4: 4B971635  bl 0x8226d7f8
	ctx.lr = 0x828FC1C8;
	sub_8226D7F8(ctx, base);
	// 828FC1C8: 7C6A0034  cntlzw r10, r3
	ctx.r[10].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 828FC1CC: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	pc = 0x828FC1D0; continue 'dispatch;
            }
            0x828FC1D0 => {
    //   block [0x828FC1D0..0x828FC1DC)
	// 828FC1D0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FC1D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FC1D8: 419A0018  beq cr6, 0x828fc1f0
	if ctx.cr[6].eq {
	pc = 0x828FC1F0; continue 'dispatch;
	}
	pc = 0x828FC1DC; continue 'dispatch;
            }
            0x828FC1DC => {
    //   block [0x828FC1DC..0x828FC1E4)
	// 828FC1DC: 3B800004  li r28, 4
	ctx.r[28].s64 = 4;
	// 828FC1E0: 48000010  b 0x828fc1f0
	pc = 0x828FC1F0; continue 'dispatch;
            }
            0x828FC1E4 => {
    //   block [0x828FC1E4..0x828FC1EC)
	// 828FC1E4: 3B800002  li r28, 2
	ctx.r[28].s64 = 2;
	// 828FC1E8: 48000008  b 0x828fc1f0
	pc = 0x828FC1F0; continue 'dispatch;
            }
            0x828FC1EC => {
    //   block [0x828FC1EC..0x828FC1F0)
	// 828FC1EC: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	pc = 0x828FC1F0; continue 'dispatch;
            }
            0x828FC1F0 => {
    //   block [0x828FC1F0..0x828FC234)
	// 828FC1F0: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828FC1F4: 4B923065  bl 0x8221f258
	ctx.lr = 0x828FC1F8;
	sub_8221F258(ctx, base);
	// 828FC1F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FC1FC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828FC200: 419A0034  beq cr6, 0x828fc234
	if ctx.cr[6].eq {
	pc = 0x828FC234; continue 'dispatch;
	}
	// 828FC204: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828FC208: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828FC20C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FC210: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 828FC214: 4B930CBD  bl 0x8222ced0
	ctx.lr = 0x828FC218;
	sub_8222CED0(ctx, base);
	// 828FC218: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FC21C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FC220: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828FC224: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 828FC228: 48373649  bl 0x82c6f870
	ctx.lr = 0x828FC22C;
	sub_82C6F870(ctx, base);
	// 828FC22C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FC230: 48000008  b 0x828fc238
	pc = 0x828FC238; continue 'dispatch;
            }
            0x828FC234 => {
    //   block [0x828FC234..0x828FC238)
	// 828FC234: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x828FC238; continue 'dispatch;
            }
            0x828FC238 => {
    //   block [0x828FC238..0x828FC24C)
	// 828FC238: 574B07FE  clrlwi r11, r26, 0x1f
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x00000001u64;
	// 828FC23C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FC240: 419A000C  beq cr6, 0x828fc24c
	if ctx.cr[6].eq {
	pc = 0x828FC24C; continue 'dispatch;
	}
	// 828FC244: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828FC248: 4B918B91  bl 0x82214dd8
	ctx.lr = 0x828FC24C;
	sub_82214DD8(ctx, base);
	pc = 0x828FC24C; continue 'dispatch;
            }
            0x828FC24C => {
    //   block [0x828FC24C..0x828FC280)
	// 828FC24C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC250: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FC254: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828FC258: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FC25C: 4E800421  bctrl
	ctx.lr = 0x828FC260;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FC260: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828FC264: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828FC268: 419A0108  beq cr6, 0x828fc370
	if ctx.cr[6].eq {
	pc = 0x828FC370; continue 'dispatch;
	}
	// 828FC26C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828FC270: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828FC274: 409A003C  bne cr6, 0x828fc2b0
	if !ctx.cr[6].eq {
	pc = 0x828FC2B0; continue 'dispatch;
	}
	// 828FC278: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 828FC27C: 396B4D94  addi r11, r11, 0x4d94
	ctx.r[11].s64 = ctx.r[11].s64 + 19860;
            }
            0x828FC280 => {
    //   block [0x828FC280..0x828FC2A4)
	// 828FC280: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC284: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC288: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FC28C: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828FC290: 419A0014  beq cr6, 0x828fc2a4
	if ctx.cr[6].eq {
	pc = 0x828FC2A4; continue 'dispatch;
	}
	// 828FC294: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828FC298: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828FC29C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FC2A0: 419AFFE0  beq cr6, 0x828fc280
	if ctx.cr[6].eq {
	pc = 0x828FC280; continue 'dispatch;
	}
	pc = 0x828FC2A4; continue 'dispatch;
            }
            0x828FC2A4 => {
    //   block [0x828FC2A4..0x828FC2B0)
	// 828FC2A4: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 828FC2A8: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828FC2AC: 48000018  b 0x828fc2c4
	pc = 0x828FC2C4; continue 'dispatch;
            }
            0x828FC2B0 => {
    //   block [0x828FC2B0..0x828FC2C4)
	// 828FC2B0: 388B4D94  addi r4, r11, 0x4d94
	ctx.r[4].s64 = ctx.r[11].s64 + 19860;
	// 828FC2B4: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC2B8: 4B971541  bl 0x8226d7f8
	ctx.lr = 0x828FC2BC;
	sub_8226D7F8(ctx, base);
	// 828FC2BC: 7C6A0034  cntlzw r10, r3
	ctx.r[10].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 828FC2C0: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	pc = 0x828FC2C4; continue 'dispatch;
            }
            0x828FC2C4 => {
    //   block [0x828FC2C4..0x828FC2E4)
	// 828FC2C4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FC2C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FC2CC: 409A0068  bne cr6, 0x828fc334
	if !ctx.cr[6].eq {
	pc = 0x828FC334; continue 'dispatch;
	}
	// 828FC2D0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828FC2D4: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828FC2D8: 409A003C  bne cr6, 0x828fc314
	if !ctx.cr[6].eq {
	pc = 0x828FC314; continue 'dispatch;
	}
	// 828FC2DC: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 828FC2E0: 396B4D98  addi r11, r11, 0x4d98
	ctx.r[11].s64 = ctx.r[11].s64 + 19864;
	pc = 0x828FC2E4; continue 'dispatch;
            }
            0x828FC2E4 => {
    //   block [0x828FC2E4..0x828FC308)
	// 828FC2E4: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC2E8: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC2EC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FC2F0: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828FC2F4: 419A0014  beq cr6, 0x828fc308
	if ctx.cr[6].eq {
	pc = 0x828FC308; continue 'dispatch;
	}
	// 828FC2F8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828FC2FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828FC300: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828FC304: 419AFFE0  beq cr6, 0x828fc2e4
	if ctx.cr[6].eq {
	pc = 0x828FC2E4; continue 'dispatch;
	}
	pc = 0x828FC308; continue 'dispatch;
            }
            0x828FC308 => {
    //   block [0x828FC308..0x828FC314)
	// 828FC308: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 828FC30C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828FC310: 48000018  b 0x828fc328
	pc = 0x828FC328; continue 'dispatch;
            }
            0x828FC314 => {
    //   block [0x828FC314..0x828FC328)
	// 828FC314: 388B4D98  addi r4, r11, 0x4d98
	ctx.r[4].s64 = ctx.r[11].s64 + 19864;
	// 828FC318: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC31C: 4B9714DD  bl 0x8226d7f8
	ctx.lr = 0x828FC320;
	sub_8226D7F8(ctx, base);
	// 828FC320: 7C6A0034  cntlzw r10, r3
	ctx.r[10].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 828FC324: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	pc = 0x828FC328; continue 'dispatch;
            }
            0x828FC328 => {
    //   block [0x828FC328..0x828FC334)
	// 828FC328: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FC32C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FC330: 419A002C  beq cr6, 0x828fc35c
	if ctx.cr[6].eq {
	pc = 0x828FC35C; continue 'dispatch;
	}
	pc = 0x828FC334; continue 'dispatch;
            }
            0x828FC334 => {
    //   block [0x828FC334..0x828FC35C)
	// 828FC334: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC338: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FC33C: 817E0024  lwz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 828FC340: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FC344: 4E800421  bctrl
	ctx.lr = 0x828FC348;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FC348: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FC34C: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828FC350: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FC354: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FC358: 4E800421  bctrl
	ctx.lr = 0x828FC35C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828FC35C => {
    //   block [0x828FC35C..0x828FC370)
	// 828FC35C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FC360: 4B918A79  bl 0x82214dd8
	ctx.lr = 0x828FC364;
	sub_82214DD8(ctx, base);
	// 828FC364: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FC368: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828FC36C: 483AD0E4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x828FC370 => {
    //   block [0x828FC370..0x828FC384)
	// 828FC370: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FC374: 4B918A65  bl 0x82214dd8
	ctx.lr = 0x828FC378;
	sub_82214DD8(ctx, base);
	// 828FC378: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828FC37C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828FC380: 483AD0D0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FC388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FC388 size=84
    let mut pc: u32 = 0x828FC388;
    'dispatch: loop {
        match pc {
            0x828FC388 => {
    //   block [0x828FC388..0x828FC3DC)
	// 828FC388: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FC38C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FC390: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FC394: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FC398: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FC39C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC3A0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FC3A4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FC3A8: 4E800421  bctrl
	ctx.lr = 0x828FC3AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FC3AC: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC3B0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828FC3B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FC3B8: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC3BC: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 828FC3C0: 4E800421  bctrl
	ctx.lr = 0x828FC3C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FC3C4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828FC3C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828FC3CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FC3D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FC3D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FC3D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FC3E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FC3E0 size=100
    let mut pc: u32 = 0x828FC3E0;
    'dispatch: loop {
        match pc {
            0x828FC3E0 => {
    //   block [0x828FC3E0..0x828FC444)
	// 828FC3E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FC3E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FC3E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828FC3EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FC3F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FC3F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FC3F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC3FC: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828FC400: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FC404: 4E800421  bctrl
	ctx.lr = 0x828FC408;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FC408: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC40C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FC410: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FC414: 8109001C  lwz r8, 0x1c(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 828FC418: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 828FC41C: 4E800421  bctrl
	ctx.lr = 0x828FC420;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FC420: 7CE3F050  subf r7, r3, r30
	ctx.r[7].s64 = ctx.r[30].s64 - ctx.r[3].s64;
	// 828FC424: 7CE60034  cntlzw r6, r7
	ctx.r[6].u64 = if ctx.r[7].u32 == 0 { 32 } else { ctx.r[7].u32.leading_zeros() as u64 };
	// 828FC428: 54C3DFFE  rlwinm r3, r6, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[6].u32 as u64 & 0x0000001Fu64;
	// 828FC42C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FC430: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FC434: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FC438: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828FC43C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FC440: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FC448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FC448 size=196
    let mut pc: u32 = 0x828FC448;
    'dispatch: loop {
        match pc {
            0x828FC448 => {
    //   block [0x828FC448..0x828FC470)
	// 828FC448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FC44C: 483ACFB1  bl 0x82ca93fc
	ctx.lr = 0x828FC450;
	sub_82CA93D0(ctx, base);
	// 828FC450: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FC454: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828FC458: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828FC45C: 3784FFFF  addic. r28, r4, -1
	ctx.xer.ca = (ctx.r[4].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[4].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 828FC460: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828FC464: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 828FC468: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828FC46C: 4081007C  ble 0x828fc4e8
	if !ctx.cr[0].gt {
	pc = 0x828FC4E8; continue 'dispatch;
	}
	pc = 0x828FC470; continue 'dispatch;
            }
            0x828FC470 => {
    //   block [0x828FC470..0x828FC4E4)
	// 828FC470: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC474: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FC478: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828FC47C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FC480: 4E800421  bctrl
	ctx.lr = 0x828FC484;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FC484: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC488: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828FC48C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FC490: 8109001C  lwz r8, 0x1c(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 828FC494: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 828FC498: 4E800421  bctrl
	ctx.lr = 0x828FC49C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FC49C: 7F03C800  cmpw cr6, r3, r25
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[25].s32, &mut ctx.xer);
	// 828FC4A0: 419A0044  beq cr6, 0x828fc4e4
	if ctx.cr[6].eq {
	pc = 0x828FC4E4; continue 'dispatch;
	}
	// 828FC4A4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC4A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828FC4AC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828FC4B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FC4B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FC4B8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FC4BC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FC4C0: 4E800421  bctrl
	ctx.lr = 0x828FC4C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FC4C4: 893F0000  lbz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC4C8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828FC4CC: 2B09000A  cmplwi cr6, r9, 0xa
	ctx.cr[6].compare_u32(ctx.r[9].u32, 10 as u32, &mut ctx.xer);
	// 828FC4D0: 419A0018  beq cr6, 0x828fc4e8
	if ctx.cr[6].eq {
	pc = 0x828FC4E8; continue 'dispatch;
	}
	// 828FC4D4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828FC4D8: 7F1EE000  cmpw cr6, r30, r28
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[28].s32, &mut ctx.xer);
	// 828FC4DC: 4198FF94  blt cr6, 0x828fc470
	if ctx.cr[6].lt {
	pc = 0x828FC470; continue 'dispatch;
	}
	// 828FC4E0: 48000008  b 0x828fc4e8
	pc = 0x828FC4E8; continue 'dispatch;
            }
            0x828FC4E4 => {
    //   block [0x828FC4E4..0x828FC4E8)
	// 828FC4E4: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	pc = 0x828FC4E8; continue 'dispatch;
            }
            0x828FC4E8 => {
    //   block [0x828FC4E8..0x828FC504)
	// 828FC4E8: 576B063E  clrlwi r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 828FC4EC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828FC4F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FC4F4: 995F0000  stb r10, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828FC4F8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828FC4FC: 409A0008  bne cr6, 0x828fc504
	if !ctx.cr[6].eq {
	pc = 0x828FC504; continue 'dispatch;
	}
	// 828FC500: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	pc = 0x828FC504; continue 'dispatch;
            }
            0x828FC504 => {
    //   block [0x828FC504..0x828FC50C)
	// 828FC504: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828FC508: 483ACF44  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FC510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FC510 size=80
    let mut pc: u32 = 0x828FC510;
    'dispatch: loop {
        match pc {
            0x828FC510 => {
    //   block [0x828FC510..0x828FC560)
	// 828FC510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FC514: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FC518: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FC51C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FC520: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828FC524: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 828FC528: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828FC52C: 7CA4F9D6  mullw r5, r4, r31
	ctx.r[5].s32 = ((ctx.r[4].s32 as i64 * ctx.r[31].s32 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 828FC530: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC534: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 828FC538: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FC53C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828FC540: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828FC544: 4E800421  bctrl
	ctx.lr = 0x828FC548;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FC548: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FC54C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828FC550: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FC554: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FC558: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FC55C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FC560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FC560 size=148
    let mut pc: u32 = 0x828FC560;
    'dispatch: loop {
        match pc {
            0x828FC560 => {
    //   block [0x828FC560..0x828FC5C4)
	// 828FC560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FC564: 483ACEA1  bl 0x82ca9404
	ctx.lr = 0x828FC568;
	sub_82CA93D0(ctx, base);
	// 828FC568: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FC56C: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 828FC570: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828FC574: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828FC578: 7FBE29D6  mullw r29, r30, r5
	ctx.r[29].s32 = ((ctx.r[30].s32 as i64 * ctx.r[5].s32 as i64) as i32);
	ctx.r[29].s64 = ctx.r[29].s32 as i64;
	// 828FC57C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC580: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828FC584: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828FC588: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FC58C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FC590: 4E800421  bctrl
	ctx.lr = 0x828FC594;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FC594: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC598: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828FC59C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FC5A0: 8109001C  lwz r8, 0x1c(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 828FC5A4: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 828FC5A8: 4E800421  bctrl
	ctx.lr = 0x828FC5AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FC5AC: 7D63D850  subf r11, r3, r27
	ctx.r[11].s64 = ctx.r[27].s64 - ctx.r[3].s64;
	// 828FC5B0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828FC5B4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FC5B8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828FC5BC: 41980008  blt cr6, 0x828fc5c4
	if ctx.cr[6].lt {
	pc = 0x828FC5C4; continue 'dispatch;
	}
	// 828FC5C0: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
            }
            0x828FC5C4 => {
    //   block [0x828FC5C4..0x828FC5F4)
	// 828FC5C4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC5C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828FC5CC: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC5D0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828FC5D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FC5D8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828FC5DC: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FC5E0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828FC5E4: 4E800421  bctrl
	ctx.lr = 0x828FC5E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FC5E8: 7C7DF396  divwu r3, r29, r30
	ctx.r[3].u32 = ctx.r[29].u32 / ctx.r[30].u32;
	// 828FC5EC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828FC5F0: 483ACE64  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FC5F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FC5F8 size=124
    let mut pc: u32 = 0x828FC5F8;
    'dispatch: loop {
        match pc {
            0x828FC5F8 => {
    //   block [0x828FC5F8..0x828FC638)
	// 828FC5F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FC5FC: 483ACE11  bl 0x82ca940c
	ctx.lr = 0x828FC600;
	sub_82CA93D0(ctx, base);
	// 828FC600: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FC604: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FC608: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828FC60C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828FC610: 419A0028  beq cr6, 0x828fc638
	if ctx.cr[6].eq {
	pc = 0x828FC638; continue 'dispatch;
	}
	// 828FC614: 2F050002  cmpwi cr6, r5, 2
	ctx.cr[6].compare_i32(ctx.r[5].s32, 2, &mut ctx.xer);
	// 828FC618: 409A0038  bne cr6, 0x828fc650
	if !ctx.cr[6].eq {
	pc = 0x828FC650; continue 'dispatch;
	}
	// 828FC61C: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC620: 817D0024  lwz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 828FC624: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828FC628: 4E800421  bctrl
	ctx.lr = 0x828FC62C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FC62C: 815D0014  lwz r10, 0x14(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 828FC630: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FC634: 48000010  b 0x828fc644
	pc = 0x828FC644; continue 'dispatch;
            }
            0x828FC638 => {
    //   block [0x828FC638..0x828FC644)
	// 828FC638: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC63C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828FC640: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	pc = 0x828FC644; continue 'dispatch;
            }
            0x828FC644 => {
    //   block [0x828FC644..0x828FC650)
	// 828FC644: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FC648: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FC64C: 4E800421  bctrl
	ctx.lr = 0x828FC650;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828FC650 => {
    //   block [0x828FC650..0x828FC674)
	// 828FC650: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FC654: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FC658: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FC65C: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 828FC660: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FC664: 4E800421  bctrl
	ctx.lr = 0x828FC668;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FC668: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828FC66C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FC670: 483ACDEC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FC678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FC678 size=1028
    let mut pc: u32 = 0x828FC678;
    'dispatch: loop {
        match pc {
            0x828FC678 => {
    //   block [0x828FC678..0x828FCA7C)
	// 828FC678: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FC67C: 483ACD8D  bl 0x82ca9408
	ctx.lr = 0x828FC680;
	sub_82CA93D0(ctx, base);
	// 828FC680: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828FC684: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FCA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FCA80 size=12
    let mut pc: u32 = 0x828FCA80;
    'dispatch: loop {
        match pc {
            0x828FCA80 => {
    //   block [0x828FCA80..0x828FCA8C)
	// 828FCA80: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828FCA84: 386BC918  addi r3, r11, -0x36e8
	ctx.r[3].s64 = ctx.r[11].s64 + -14056;
	// 828FCA88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FCA90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FCA90 size=140
    let mut pc: u32 = 0x828FCA90;
    'dispatch: loop {
        match pc {
            0x828FCA90 => {
    //   block [0x828FCA90..0x828FCB04)
	// 828FCA90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FCA94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FCA98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FCA9C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FCAA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FCAA4: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 828FCAA8: 4BD19E81  bl 0x82616928
	ctx.lr = 0x828FCAAC;
	sub_82616928(ctx, base);
	// 828FCAAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FCAB0: 419A0054  beq cr6, 0x828fcb04
	if ctx.cr[6].eq {
	pc = 0x828FCB04; continue 'dispatch;
	}
	// 828FCAB4: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828FCAB8: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 828FCABC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828FCAC0: 392A4DB4  addi r9, r10, 0x4db4
	ctx.r[9].s64 = ctx.r[10].s64 + 19892;
	// 828FCAC4: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828FCAC8: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828FCACC: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 828FCAD0: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 828FCAD4: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 828FCAD8: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 828FCADC: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 828FCAE0: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 828FCAE4: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 828FCAE8: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 828FCAEC: 9163002C  stw r11, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 828FCAF0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828FCAF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FCAF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FCAFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FCB00: 4E800020  blr
	return;
            }
            0x828FCB04 => {
    //   block [0x828FCB04..0x828FCB1C)
	// 828FCB04: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828FCB08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828FCB0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FCB10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FCB14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FCB18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FCB20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FCB20 size=92
    let mut pc: u32 = 0x828FCB20;
    'dispatch: loop {
        match pc {
            0x828FCB20 => {
    //   block [0x828FCB20..0x828FCB64)
	// 828FCB20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FCB24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FCB28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828FCB2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FCB30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FCB34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FCB38: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828FCB3C: 48000045  bl 0x828fcb80
	ctx.lr = 0x828FCB40;
	sub_828FCB80(ctx, base);
	// 828FCB40: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 828FCB44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FCB48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FCB4C: 419A0018  beq cr6, 0x828fcb64
	if ctx.cr[6].eq {
	pc = 0x828FCB64; continue 'dispatch;
	}
	// 828FCB50: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 828FCB54: 814BDAB4  lwz r10, -0x254c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 828FCB58: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FCB5C: 4E800421  bctrl
	ctx.lr = 0x828FCB60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FCB60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            0x828FCB64 => {
    //   block [0x828FCB64..0x828FCB7C)
	// 828FCB64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FCB68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FCB6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FCB70: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828FCB74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FCB78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FCB80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FCB80 size=236
    let mut pc: u32 = 0x828FCB80;
    'dispatch: loop {
        match pc {
            0x828FCB80 => {
    //   block [0x828FCB80..0x828FCBAC)
	// 828FCB80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FCB84: 483AC885  bl 0x82ca9408
	ctx.lr = 0x828FCB88;
	sub_82CA93D0(ctx, base);
	// 828FCB88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FCB8C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828FCB90: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828FCB94: 394B4DB4  addi r10, r11, 0x4db4
	ctx.r[10].s64 = ctx.r[11].s64 + 19892;
	// 828FCB98: 807C000C  lwz r3, 0xc(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FCB9C: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828FCBA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FCBA4: 419A0008  beq cr6, 0x828fcbac
	if ctx.cr[6].eq {
	pc = 0x828FCBAC; continue 'dispatch;
	}
	// 828FCBA8: 4B91F191  bl 0x8221bd38
	ctx.lr = 0x828FCBAC;
	sub_8221BD38(ctx, base);
	pc = 0x828FCBAC; continue 'dispatch;
            }
            0x828FCBAC => {
    //   block [0x828FCBAC..0x828FCBBC)
	// 828FCBAC: 807C0010  lwz r3, 0x10(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 828FCBB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FCBB4: 419A0008  beq cr6, 0x828fcbbc
	if ctx.cr[6].eq {
	pc = 0x828FCBBC; continue 'dispatch;
	}
	// 828FCBB8: 4B91F181  bl 0x8221bd38
	ctx.lr = 0x828FCBBC;
	sub_8221BD38(ctx, base);
	pc = 0x828FCBBC; continue 'dispatch;
            }
            0x828FCBBC => {
    //   block [0x828FCBBC..0x828FCBCC)
	// 828FCBBC: 807C0014  lwz r3, 0x14(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 828FCBC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FCBC4: 419A0008  beq cr6, 0x828fcbcc
	if ctx.cr[6].eq {
	pc = 0x828FCBCC; continue 'dispatch;
	}
	// 828FCBC8: 4B91F171  bl 0x8221bd38
	ctx.lr = 0x828FCBCC;
	sub_8221BD38(ctx, base);
	pc = 0x828FCBCC; continue 'dispatch;
            }
            0x828FCBCC => {
    //   block [0x828FCBCC..0x828FCBDC)
	// 828FCBCC: 807C001C  lwz r3, 0x1c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 828FCBD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FCBD4: 419A0008  beq cr6, 0x828fcbdc
	if ctx.cr[6].eq {
	pc = 0x828FCBDC; continue 'dispatch;
	}
	// 828FCBD8: 4B91F161  bl 0x8221bd38
	ctx.lr = 0x828FCBDC;
	sub_8221BD38(ctx, base);
	pc = 0x828FCBDC; continue 'dispatch;
            }
            0x828FCBDC => {
    //   block [0x828FCBDC..0x828FCBEC)
	// 828FCBDC: 807C0020  lwz r3, 0x20(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 828FCBE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FCBE4: 419A0008  beq cr6, 0x828fcbec
	if ctx.cr[6].eq {
	pc = 0x828FCBEC; continue 'dispatch;
	}
	// 828FCBE8: 4B91F151  bl 0x8221bd38
	ctx.lr = 0x828FCBEC;
	sub_8221BD38(ctx, base);
	pc = 0x828FCBEC; continue 'dispatch;
            }
            0x828FCBEC => {
    //   block [0x828FCBEC..0x828FCBFC)
	// 828FCBEC: 807C0024  lwz r3, 0x24(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 828FCBF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FCBF4: 419A0008  beq cr6, 0x828fcbfc
	if ctx.cr[6].eq {
	pc = 0x828FCBFC; continue 'dispatch;
	}
	// 828FCBF8: 4B91F141  bl 0x8221bd38
	ctx.lr = 0x828FCBFC;
	sub_8221BD38(ctx, base);
	pc = 0x828FCBFC; continue 'dispatch;
            }
            0x828FCBFC => {
    //   block [0x828FCBFC..0x828FCC24)
	// 828FCBFC: 817C002C  lwz r11, 0x2c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 828FCC00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FCC04: 419A0054  beq cr6, 0x828fcc58
	if ctx.cr[6].eq {
	pc = 0x828FCC58; continue 'dispatch;
	}
	// 828FCC08: 812BFFF0  lwz r9, -0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) } as u64;
	// 828FCC0C: 3BABFFF0  addi r29, r11, -0x10
	ctx.r[29].s64 = ctx.r[11].s64 + -16;
	// 828FCC10: 552A3032  slwi r10, r9, 6
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828FCC14: 37C9FFFF  addic. r30, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828FCC18: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828FCC1C: 41800034  blt 0x828fcc50
	if ctx.cr[0].lt {
	pc = 0x828FCC50; continue 'dispatch;
	}
	// 828FCC20: 3BEB0038  addi r31, r11, 0x38
	ctx.r[31].s64 = ctx.r[11].s64 + 56;
	pc = 0x828FCC24; continue 'dispatch;
            }
            0x828FCC24 => {
    //   block [0x828FCC24..0x828FCC38)
	// 828FCC24: 3BFFFFC0  addi r31, r31, -0x40
	ctx.r[31].s64 = ctx.r[31].s64 + -64;
	// 828FCC28: 807FFFF8  lwz r3, -8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FCC2C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FCC30: 419A0008  beq cr6, 0x828fcc38
	if ctx.cr[6].eq {
	pc = 0x828FCC38; continue 'dispatch;
	}
	// 828FCC34: 4B91F105  bl 0x8221bd38
	ctx.lr = 0x828FCC38;
	sub_8221BD38(ctx, base);
	pc = 0x828FCC38; continue 'dispatch;
            }
            0x828FCC38 => {
    //   block [0x828FCC38..0x828FCC48)
	// 828FCC38: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FCC3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FCC40: 419A0008  beq cr6, 0x828fcc48
	if ctx.cr[6].eq {
	pc = 0x828FCC48; continue 'dispatch;
	}
	// 828FCC44: 4B91F0F5  bl 0x8221bd38
	ctx.lr = 0x828FCC48;
	sub_8221BD38(ctx, base);
	pc = 0x828FCC48; continue 'dispatch;
            }
            0x828FCC48 => {
    //   block [0x828FCC48..0x828FCC50)
	// 828FCC48: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828FCC4C: 4080FFD8  bge 0x828fcc24
	if !ctx.cr[0].lt {
	pc = 0x828FCC24; continue 'dispatch;
	}
	pc = 0x828FCC50; continue 'dispatch;
            }
            0x828FCC50 => {
    //   block [0x828FCC50..0x828FCC58)
	// 828FCC50: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FCC54: 4B91F0E5  bl 0x8221bd38
	ctx.lr = 0x828FCC58;
	sub_8221BD38(ctx, base);
	pc = 0x828FCC58; continue 'dispatch;
            }
            0x828FCC58 => {
    //   block [0x828FCC58..0x828FCC6C)
	// 828FCC58: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828FCC5C: 394B9128  addi r10, r11, -0x6ed8
	ctx.r[10].s64 = ctx.r[11].s64 + -28376;
	// 828FCC60: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828FCC64: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828FCC68: 483AC7F0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FCC70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FCC70 size=2092
    let mut pc: u32 = 0x828FCC70;
    'dispatch: loop {
        match pc {
            0x828FCC70 => {
    //   block [0x828FCC70..0x828FCCDC)
	// 828FCC70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FCC74: 483AC761  bl 0x82ca93d4
	ctx.lr = 0x828FCC78;
	sub_82CA93D0(ctx, base);
	// 828FCC78: DBE1FF68  stfd f31, -0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.f[31].u64 ) };
	// 828FCC7C: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FCC80: 7C942378  mr r20, r4
	ctx.r[20].u64 = ctx.r[4].u64;
	// 828FCC84: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828FCC88: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FCC8C: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 828FCC90: 388B4DAC  addi r4, r11, 0x4dac
	ctx.r[4].s64 = ctx.r[11].s64 + 19884;
	// 828FCC94: 48587285  bl 0x82e83f18
	ctx.lr = 0x828FCC98;
	sub_82E83F18(ctx, base);
	// 828FCC98: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 828FCC9C: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 828FCCA0: 419A07EC  beq cr6, 0x828fd48c
	if ctx.cr[6].eq {
	pc = 0x828FD48C; continue 'dispatch;
	}
	// 828FCCA4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FCCA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FCCAC: 419A07E0  beq cr6, 0x828fd48c
	if ctx.cr[6].eq {
	pc = 0x828FD48C; continue 'dispatch;
	}
	// 828FCCB0: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828FCCB4: 3D403FFF  lis r10, 0x3fff
	ctx.r[10].s64 = 1073676288;
	// 828FCCB8: 3AA0FFFF  li r21, -1
	ctx.r[21].s64 = -1;
	// 828FCCBC: 615FFFFF  ori r31, r10, 0xffff
	ctx.r[31].u64 = ctx.r[10].u64 | 65535;
	// 828FCCC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FCCC4: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828FCCC8: 419A0044  beq cr6, 0x828fcd0c
	if ctx.cr[6].eq {
	pc = 0x828FCD0C; continue 'dispatch;
	}
	// 828FCCCC: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828FCCD0: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 828FCCD4: 40990008  ble cr6, 0x828fccdc
	if !ctx.cr[6].gt {
	pc = 0x828FCCDC; continue 'dispatch;
	}
	// 828FCCD8: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	pc = 0x828FCCDC; continue 'dispatch;
            }
            0x828FCCDC => {
    //   block [0x828FCCDC..0x828FCCF8)
	// 828FCCDC: 4B92257D  bl 0x8221f258
	ctx.lr = 0x828FCCE0;
	sub_8221F258(ctx, base);
	// 828FCCE0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FCCE4: 907E000C  stw r3, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 828FCCE8: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828FCCEC: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 828FCCF0: 40990008  ble cr6, 0x828fccf8
	if !ctx.cr[6].gt {
	pc = 0x828FCCF8; continue 'dispatch;
	}
	// 828FCCF4: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	pc = 0x828FCCF8; continue 'dispatch;
            }
            0x828FCCF8 => {
    //   block [0x828FCCF8..0x828FCD0C)
	// 828FCCF8: 4B922561  bl 0x8221f258
	ctx.lr = 0x828FCCFC;
	sub_8221F258(ctx, base);
	// 828FCCFC: 907E0010  stw r3, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 828FCD00: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FCD04: 4B922555  bl 0x8221f258
	ctx.lr = 0x828FCD08;
	sub_8221F258(ctx, base);
	// 828FCD08: 907E0014  stw r3, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	pc = 0x828FCD0C; continue 'dispatch;
            }
            0x828FCD0C => {
    //   block [0x828FCD0C..0x828FCD30)
	// 828FCD0C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FCD10: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 828FCD14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FCD18: 917E0018  stw r11, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 828FCD1C: 419A0044  beq cr6, 0x828fcd60
	if ctx.cr[6].eq {
	pc = 0x828FCD60; continue 'dispatch;
	}
	// 828FCD20: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828FCD24: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 828FCD28: 40990008  ble cr6, 0x828fcd30
	if !ctx.cr[6].gt {
	pc = 0x828FCD30; continue 'dispatch;
	}
	// 828FCD2C: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	pc = 0x828FCD30; continue 'dispatch;
            }
            0x828FCD30 => {
    //   block [0x828FCD30..0x828FCD4C)
	// 828FCD30: 4B922529  bl 0x8221f258
	ctx.lr = 0x828FCD34;
	sub_8221F258(ctx, base);
	// 828FCD34: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 828FCD38: 907E001C  stw r3, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[3].u32 ) };
	// 828FCD3C: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828FCD40: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 828FCD44: 40990008  ble cr6, 0x828fcd4c
	if !ctx.cr[6].gt {
	pc = 0x828FCD4C; continue 'dispatch;
	}
	// 828FCD48: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	pc = 0x828FCD4C; continue 'dispatch;
            }
            0x828FCD4C => {
    //   block [0x828FCD4C..0x828FCD60)
	// 828FCD4C: 4B92250D  bl 0x8221f258
	ctx.lr = 0x828FCD50;
	sub_8221F258(ctx, base);
	// 828FCD50: 907E0020  stw r3, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 828FCD54: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FCD58: 4B922501  bl 0x8221f258
	ctx.lr = 0x828FCD5C;
	sub_8221F258(ctx, base);
	// 828FCD5C: 907E0024  stw r3, 0x24(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	pc = 0x828FCD60; continue 'dispatch;
            }
            0x828FCD60 => {
    //   block [0x828FCD60..0x828FCE70)
	// 828FCD60: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 828FCD64: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 828FCD68: 838B0004  lwz r28, 4(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FCD6C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828FCD70: 419A071C  beq cr6, 0x828fd48c
	if ctx.cr[6].eq {
	pc = 0x828FD48C; continue 'dispatch;
	}
	// 828FCD74: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FCD78: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 828FCD7C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FCD80: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FCD84: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FCD88: 4E800421  bctrl
	ctx.lr = 0x828FCD8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FCD8C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828FCD90: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828FCD94: 419A06F8  beq cr6, 0x828fd48c
	if ctx.cr[6].eq {
	pc = 0x828FD48C; continue 'dispatch;
	}
	// 828FCD98: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 828FCD9C: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 828FCDA0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828FCDA4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828FCDA8: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FCDAC: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 828FCDB0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FCDB4: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FCDB8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828FCDBC: 4E800421  bctrl
	ctx.lr = 0x828FCDC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FCDC0: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 828FCDC4: 409A06B0  bne cr6, 0x828fd474
	if !ctx.cr[6].eq {
	pc = 0x828FD474; continue 'dispatch;
	}
	// 828FCDC8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FCDCC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828FCDD0: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 828FCDD4: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 828FCDD8: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 828FCDDC: 5548C43E  rlwinm r8, r10, 0x18, 0x10, 0x1f
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828FCDE0: 5527401E  rlwinm r7, r9, 8, 0, 0xf
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 828FCDE4: 7D0B3B78  or r11, r8, r7
	ctx.r[11].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 828FCDE8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828FCDEC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 828FCDF0: 41980684  blt cr6, 0x828fd474
	if ctx.cr[6].lt {
	pc = 0x828FD474; continue 'dispatch;
	}
	// 828FCDF4: 41990680  bgt cr6, 0x828fd474
	if ctx.cr[6].gt {
	pc = 0x828FD474; continue 'dispatch;
	}
	// 828FCDF8: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FCDFC: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 828FCE00: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FCE04: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FCE08: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 828FCE0C: 80BE000C  lwz r5, 0xc(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FCE10: 555D103A  slwi r29, r10, 2
	ctx.r[29].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 828FCE14: 5526103A  slwi r6, r9, 2
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 828FCE18: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FCE1C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 828FCE20: 4E800421  bctrl
	ctx.lr = 0x828FCE24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FCE24: 7F03E840  cmplw cr6, r3, r29
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828FCE28: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FCE2C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FCE30: 409A064C  bne cr6, 0x828fd47c
	if !ctx.cr[6].eq {
	pc = 0x828FD47C; continue 'dispatch;
	}
	// 828FCE34: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FCE38: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828FCE3C: 80BE0010  lwz r5, 0x10(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828FCE40: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 828FCE44: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FCE48: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FCE4C: 4E800421  bctrl
	ctx.lr = 0x828FCE50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FCE50: 57E9103A  slwi r9, r31, 2
	ctx.r[9].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828FCE54: 7F034840  cmplw cr6, r3, r9
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828FCE58: 409A061C  bne cr6, 0x828fd474
	if !ctx.cr[6].eq {
	pc = 0x828FD474; continue 'dispatch;
	}
	// 828FCE5C: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 828FCE60: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828FCE64: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 828FCE68: 419A0074  beq cr6, 0x828fcedc
	if ctx.cr[6].eq {
	pc = 0x828FCEDC; continue 'dispatch;
	}
	// 828FCE6C: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
            }
            0x828FCE70 => {
    //   block [0x828FCE70..0x828FCEDC)
	// 828FCE70: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FCE74: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828FCE78: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828FCE7C: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FCE80: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 828FCE84: 7D064378  mr r6, r8
	ctx.r[6].u64 = ctx.r[8].u64;
	// 828FCE88: 5107843E  rlwimi r7, r8, 0x10, 0x10, 0x1f
	ctx.r[7].u64 = (((ctx.r[8].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF0000);
	// 828FCE8C: 5106801E  rlwimi r6, r8, 0x10, 0, 0xf
	ctx.r[6].u64 = (((ctx.r[8].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[6].u64 & 0xFFFFFFFF0000FFFF);
	// 828FCE90: 54E5C43E  rlwinm r5, r7, 0x18, 0x10, 0x1f
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828FCE94: 54C4401E  rlwinm r4, r6, 8, 0, 0xf
	ctx.r[4].u64 = ctx.r[6].u32 as u64 & 0x00FFFFFFu64;
	// 828FCE98: 7CA32378  or r3, r5, r4
	ctx.r[3].u64 = ctx.r[5].u64 | ctx.r[4].u64;
	// 828FCE9C: 906A0000  stw r3, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 828FCEA0: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828FCEA4: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828FCEA8: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FCEAC: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 828FCEB0: 7D064378  mr r6, r8
	ctx.r[6].u64 = ctx.r[8].u64;
	// 828FCEB4: 5107843E  rlwimi r7, r8, 0x10, 0x10, 0x1f
	ctx.r[7].u64 = (((ctx.r[8].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF0000);
	// 828FCEB8: 5106801E  rlwimi r6, r8, 0x10, 0, 0xf
	ctx.r[6].u64 = (((ctx.r[8].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[6].u64 & 0xFFFFFFFF0000FFFF);
	// 828FCEBC: 54E5C43E  rlwinm r5, r7, 0x18, 0x10, 0x1f
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828FCEC0: 54C4401E  rlwinm r4, r6, 8, 0, 0xf
	ctx.r[4].u64 = ctx.r[6].u32 as u64 & 0x00FFFFFFu64;
	// 828FCEC4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828FCEC8: 7CA32378  or r3, r5, r4
	ctx.r[3].u64 = ctx.r[5].u64 | ctx.r[4].u64;
	// 828FCECC: 906A0000  stw r3, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 828FCED0: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FCED4: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FCED8: 4198FF98  blt cr6, 0x828fce70
	if ctx.cr[6].lt {
	pc = 0x828FCE70; continue 'dispatch;
	}
	pc = 0x828FCEDC; continue 'dispatch;
            }
            0x828FCEDC => {
    //   block [0x828FCEDC..0x828FCF7C)
	// 828FCEDC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FCEE0: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 828FCEE4: 80DE0008  lwz r6, 8(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FCEE8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FCEEC: 80BE0014  lwz r5, 0x14(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 828FCEF0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FCEF4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FCEF8: 4E800421  bctrl
	ctx.lr = 0x828FCEFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FCEFC: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FCF00: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FCF04: 7F034840  cmplw cr6, r3, r9
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828FCF08: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FCF0C: 409A0570  bne cr6, 0x828fd47c
	if !ctx.cr[6].eq {
	pc = 0x828FD47C; continue 'dispatch;
	}
	// 828FCF10: 815E0018  lwz r10, 0x18(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 828FCF14: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 828FCF18: 80BE001C  lwz r5, 0x1c(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 828FCF1C: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 828FCF20: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FCF24: 555D103A  slwi r29, r10, 2
	ctx.r[29].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 828FCF28: 5526103A  slwi r6, r9, 2
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 828FCF2C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 828FCF30: 4E800421  bctrl
	ctx.lr = 0x828FCF34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FCF34: 7F03E840  cmplw cr6, r3, r29
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828FCF38: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FCF3C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FCF40: 409A053C  bne cr6, 0x828fd47c
	if !ctx.cr[6].eq {
	pc = 0x828FD47C; continue 'dispatch;
	}
	// 828FCF44: 83FE0018  lwz r31, 0x18(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 828FCF48: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828FCF4C: 80BE0020  lwz r5, 0x20(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 828FCF50: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 828FCF54: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FCF58: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FCF5C: 4E800421  bctrl
	ctx.lr = 0x828FCF60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FCF60: 57E9103A  slwi r9, r31, 2
	ctx.r[9].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828FCF64: 7F034840  cmplw cr6, r3, r9
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828FCF68: 409A050C  bne cr6, 0x828fd474
	if !ctx.cr[6].eq {
	pc = 0x828FD474; continue 'dispatch;
	}
	// 828FCF6C: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 828FCF70: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828FCF74: 419A0074  beq cr6, 0x828fcfe8
	if ctx.cr[6].eq {
	pc = 0x828FCFE8; continue 'dispatch;
	}
	// 828FCF78: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
            }
            0x828FCF7C => {
    //   block [0x828FCF7C..0x828FCFE8)
	// 828FCF7C: 815E001C  lwz r10, 0x1c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 828FCF80: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828FCF84: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828FCF88: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FCF8C: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 828FCF90: 7D064378  mr r6, r8
	ctx.r[6].u64 = ctx.r[8].u64;
	// 828FCF94: 5107843E  rlwimi r7, r8, 0x10, 0x10, 0x1f
	ctx.r[7].u64 = (((ctx.r[8].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF0000);
	// 828FCF98: 5106801E  rlwimi r6, r8, 0x10, 0, 0xf
	ctx.r[6].u64 = (((ctx.r[8].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[6].u64 & 0xFFFFFFFF0000FFFF);
	// 828FCF9C: 54E5C43E  rlwinm r5, r7, 0x18, 0x10, 0x1f
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828FCFA0: 54C4401E  rlwinm r4, r6, 8, 0, 0xf
	ctx.r[4].u64 = ctx.r[6].u32 as u64 & 0x00FFFFFFu64;
	// 828FCFA4: 7CA32378  or r3, r5, r4
	ctx.r[3].u64 = ctx.r[5].u64 | ctx.r[4].u64;
	// 828FCFA8: 906A0000  stw r3, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 828FCFAC: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 828FCFB0: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828FCFB4: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FCFB8: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 828FCFBC: 7D064378  mr r6, r8
	ctx.r[6].u64 = ctx.r[8].u64;
	// 828FCFC0: 5107843E  rlwimi r7, r8, 0x10, 0x10, 0x1f
	ctx.r[7].u64 = (((ctx.r[8].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF0000);
	// 828FCFC4: 5106801E  rlwimi r6, r8, 0x10, 0, 0xf
	ctx.r[6].u64 = (((ctx.r[8].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[6].u64 & 0xFFFFFFFF0000FFFF);
	// 828FCFC8: 54E5C43E  rlwinm r5, r7, 0x18, 0x10, 0x1f
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828FCFCC: 54C4401E  rlwinm r4, r6, 8, 0, 0xf
	ctx.r[4].u64 = ctx.r[6].u32 as u64 & 0x00FFFFFFu64;
	// 828FCFD0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828FCFD4: 7CA32378  or r3, r5, r4
	ctx.r[3].u64 = ctx.r[5].u64 | ctx.r[4].u64;
	// 828FCFD8: 906A0000  stw r3, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 828FCFDC: 815E0018  lwz r10, 0x18(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 828FCFE0: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FCFE4: 4198FF98  blt cr6, 0x828fcf7c
	if ctx.cr[6].lt {
	pc = 0x828FCF7C; continue 'dispatch;
	}
	pc = 0x828FCFE8; continue 'dispatch;
            }
            0x828FCFE8 => {
    //   block [0x828FCFE8..0x828FD09C)
	// 828FCFE8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FCFEC: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 828FCFF0: 80DE0018  lwz r6, 0x18(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 828FCFF4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FCFF8: 80BE0024  lwz r5, 0x24(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 828FCFFC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FD000: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FD004: 4E800421  bctrl
	ctx.lr = 0x828FD008;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FD008: 813E0018  lwz r9, 0x18(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 828FD00C: 7F034840  cmplw cr6, r3, r9
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828FD010: 409A0464  bne cr6, 0x828fd474
	if !ctx.cr[6].eq {
	pc = 0x828FD474; continue 'dispatch;
	}
	// 828FD014: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FD018: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 828FD01C: 41980430  blt cr6, 0x828fd44c
	if ctx.cr[6].lt {
	pc = 0x828FD44C; continue 'dispatch;
	}
	// 828FD020: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FD024: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 828FD028: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828FD02C: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 828FD030: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FD034: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FD038: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FD03C: 4E800421  bctrl
	ctx.lr = 0x828FD040;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FD040: 2B030004  cmplwi cr6, r3, 4
	ctx.cr[6].compare_u32(ctx.r[3].u32, 4 as u32, &mut ctx.xer);
	// 828FD044: 409A0430  bne cr6, 0x828fd474
	if !ctx.cr[6].eq {
	pc = 0x828FD474; continue 'dispatch;
	}
	// 828FD048: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FD04C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828FD050: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 828FD054: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 828FD058: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 828FD05C: 5548C43E  rlwinm r8, r10, 0x18, 0x10, 0x1f
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828FD060: 5527401E  rlwinm r7, r9, 8, 0, 0xf
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 828FD064: 7D063B78  or r6, r8, r7
	ctx.r[6].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 828FD068: 54DF003E  slwi r31, r6, 0
	ctx.r[31].u32 = ctx.r[6].u32.wrapping_shl(0);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 828FD06C: 90DE0028  stw r6, 0x28(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[6].u32 ) };
	// 828FD070: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828FD074: 419A03D8  beq cr6, 0x828fd44c
	if ctx.cr[6].eq {
	pc = 0x828FD44C; continue 'dispatch;
	}
	// 828FD078: 3D6003FF  lis r11, 0x3ff
	ctx.r[11].s64 = 67043328;
	// 828FD07C: 6178FFFF  ori r24, r11, 0xffff
	ctx.r[24].u64 = ctx.r[11].u64 | 65535;
	// 828FD080: 7F1FC040  cmplw cr6, r31, r24
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[24].u32, &mut ctx.xer);
	// 828FD084: 41990018  bgt cr6, 0x828fd09c
	if ctx.cr[6].gt {
	pc = 0x828FD09C; continue 'dispatch;
	}
	// 828FD088: 57EB3032  slwi r11, r31, 6
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828FD08C: 3940FFEF  li r10, -0x11
	ctx.r[10].s64 = -17;
	// 828FD090: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 828FD094: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FD098: 40990008  ble cr6, 0x828fd0a0
	if !ctx.cr[6].gt {
	pc = 0x828FD0A0; continue 'dispatch;
	}
            }
            0x828FD09C => {
    //   block [0x828FD09C..0x828FD0A0)
	// 828FD09C: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	pc = 0x828FD0A0; continue 'dispatch;
            }
            0x828FD0A0 => {
    //   block [0x828FD0A0..0x828FD0C0)
	// 828FD0A0: 4B9221B9  bl 0x8221f258
	ctx.lr = 0x828FD0A4;
	sub_8221F258(ctx, base);
	// 828FD0A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FD0A8: 419A0048  beq cr6, 0x828fd0f0
	if ctx.cr[6].eq {
	pc = 0x828FD0F0; continue 'dispatch;
	}
	// 828FD0AC: 355FFFFF  addic. r10, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828FD0B0: 93E30000  stw r31, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828FD0B4: 39230010  addi r9, r3, 0x10
	ctx.r[9].s64 = ctx.r[3].s64 + 16;
	// 828FD0B8: 41800030  blt 0x828fd0e8
	if ctx.cr[0].lt {
	pc = 0x828FD0E8; continue 'dispatch;
	}
	// 828FD0BC: 39690024  addi r11, r9, 0x24
	ctx.r[11].s64 = ctx.r[9].s64 + 36;
	pc = 0x828FD0C0; continue 'dispatch;
            }
            0x828FD0C0 => {
    //   block [0x828FD0C0..0x828FD0E8)
	// 828FD0C0: 92EBFFFC  stw r23, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[23].u32 ) };
	// 828FD0C4: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828FD0C8: 92EB0000  stw r23, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 828FD0CC: 92EB0004  stw r23, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[23].u32 ) };
	// 828FD0D0: 92EB0008  stw r23, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[23].u32 ) };
	// 828FD0D4: 92EB000C  stw r23, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[23].u32 ) };
	// 828FD0D8: 92EB0010  stw r23, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[23].u32 ) };
	// 828FD0DC: 92EB0014  stw r23, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[23].u32 ) };
	// 828FD0E0: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 828FD0E4: 4080FFDC  bge 0x828fd0c0
	if !ctx.cr[0].lt {
	pc = 0x828FD0C0; continue 'dispatch;
	}
	pc = 0x828FD0E8; continue 'dispatch;
            }
            0x828FD0E8 => {
    //   block [0x828FD0E8..0x828FD0F0)
	// 828FD0E8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 828FD0EC: 48000008  b 0x828fd0f4
	pc = 0x828FD0F4; continue 'dispatch;
            }
            0x828FD0F0 => {
    //   block [0x828FD0F0..0x828FD0F4)
	// 828FD0F0: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x828FD0F4; continue 'dispatch;
            }
            0x828FD0F4 => {
    //   block [0x828FD0F4..0x828FD44C)
	// 828FD0F4: 815E0028  lwz r10, 0x28(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 828FD0F8: 7EF9BB78  mr r25, r23
	ctx.r[25].u64 = ctx.r[23].u64;
	// 828FD0FC: 917E002C  stw r11, 0x2c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 828FD100: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FD104: 40990348  ble cr6, 0x828fd44c
	if !ctx.cr[6].gt {
	pc = 0x828FD44C; continue 'dispatch;
	}
	// 828FD108: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828FD10C: 3D407FFF  lis r10, 0x7fff
	ctx.r[10].s64 = 2147418112;
	// 828FD110: 7EFABB78  mr r26, r23
	ctx.r[26].u64 = ctx.r[23].u64;
	// 828FD114: 3B600010  li r27, 0x10
	ctx.r[27].s64 = 16;
	// 828FD118: 615DFFFF  ori r29, r10, 0xffff
	ctx.r[29].u64 = ctx.r[10].u64 | 65535;
	// 828FD11C: C3EB9484  lfs f31, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828FD120: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FD124: 38C0002C  li r6, 0x2c
	ctx.r[6].s64 = 44;
	// 828FD128: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 828FD12C: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 828FD130: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 828FD134: 7FFA5A14  add r31, r26, r11
	ctx.r[31].u64 = ctx.r[26].u64 + ctx.r[11].u64;
	// 828FD138: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FD13C: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FD140: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828FD144: 4E800421  bctrl
	ctx.lr = 0x828FD148;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FD148: 2B03002C  cmplwi cr6, r3, 0x2c
	ctx.cr[6].compare_u32(ctx.r[3].u32, 44 as u32, &mut ctx.xer);
	// 828FD14C: 409A0328  bne cr6, 0x828fd474
	if !ctx.cr[6].eq {
	pc = 0x828FD474; continue 'dispatch;
	}
	// 828FD150: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 828FD154: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 828FD158: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 828FD15C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828FD160: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828FD164: 80E10088  lwz r7, 0x88(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 828FD168: 7D735B78  mr r19, r11
	ctx.r[19].u64 = ctx.r[11].u64;
	// 828FD16C: 80C10094  lwz r6, 0x94(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 828FD170: 7D525378  mr r18, r10
	ctx.r[18].u64 = ctx.r[10].u64;
	// 828FD174: D3E10068  stfs f31, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828FD178: 7D515378  mr r17, r10
	ctx.r[17].u64 = ctx.r[10].u64;
	// 828FD17C: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828FD180: 5163801E  rlwimi r3, r11, 0x10, 0, 0xf
	ctx.r[3].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[3].u64 & 0xFFFFFFFF0000FFFF);
	// 828FD184: 8121008C  lwz r9, 0x8c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 828FD188: 5173843E  rlwimi r19, r11, 0x10, 0x10, 0x1f
	ctx.r[19].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[19].u64 & 0xFFFFFFFFFFFF0000);
	// 828FD18C: 81010090  lwz r8, 0x90(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 828FD190: 5152801E  rlwimi r18, r10, 0x10, 0, 0xf
	ctx.r[18].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[18].u64 & 0xFFFFFFFF0000FFFF);
	// 828FD194: 5151843E  rlwimi r17, r10, 0x10, 0x10, 0x1f
	ctx.r[17].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[17].u64 & 0xFFFFFFFFFFFF0000);
	// 828FD198: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 828FD19C: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 828FD1A0: 7CD03378  mr r16, r6
	ctx.r[16].u64 = ctx.r[6].u64;
	// 828FD1A4: 7CCF3378  mr r15, r6
	ctx.r[15].u64 = ctx.r[6].u64;
	// 828FD1A8: 5463401E  rlwinm r3, r3, 8, 0, 0xf
	ctx.r[3].u64 = ctx.r[3].u32 as u64 & 0x00FFFFFFu64;
	// 828FD1AC: 5673C43E  rlwinm r19, r19, 0x18, 0x10, 0x1f
	ctx.r[19].u64 = ctx.r[19].u32 as u64 & 0x000000FFu64;
	// 828FD1B0: 5652401E  rlwinm r18, r18, 8, 0, 0xf
	ctx.r[18].u64 = ctx.r[18].u32 as u64 & 0x00FFFFFFu64;
	// 828FD1B4: 5631C43E  rlwinm r17, r17, 0x18, 0x10, 0x1f
	ctx.r[17].u64 = ctx.r[17].u32 as u64 & 0x000000FFu64;
	// 828FD1B8: 50EB801E  rlwimi r11, r7, 0x10, 0, 0xf
	ctx.r[11].u64 = (((ctx.r[7].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[11].u64 & 0xFFFFFFFF0000FFFF);
	// 828FD1BC: 50EA843E  rlwimi r10, r7, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[7].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 828FD1C0: 50D0801E  rlwimi r16, r6, 0x10, 0, 0xf
	ctx.r[16].u64 = (((ctx.r[6].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[16].u64 & 0xFFFFFFFF0000FFFF);
	// 828FD1C4: 50CF843E  rlwimi r15, r6, 0x10, 0x10, 0x1f
	ctx.r[15].u64 = (((ctx.r[6].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[15].u64 & 0xFFFFFFFFFFFF0000);
	// 828FD1C8: 7C679B78  or r7, r3, r19
	ctx.r[7].u64 = ctx.r[3].u64 | ctx.r[19].u64;
	// 828FD1CC: 7E468B78  or r6, r18, r17
	ctx.r[6].u64 = ctx.r[18].u64 | ctx.r[17].u64;
	// 828FD1D0: 5563401E  rlwinm r3, r11, 8, 0, 0xf
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x00FFFFFFu64;
	// 828FD1D4: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 828FD1D8: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828FD1DC: 90C1005C  stw r6, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[6].u32 ) };
            }
            0x828FD44C => {
    //   block [0x828FD44C..0x828FD474)
	// 828FD44C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FD450: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 828FD454: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828FD458: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828FD45C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FD460: 4E800421  bctrl
	ctx.lr = 0x828FD464;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828FD464: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828FD468: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 828FD46C: CBE1FF68  lfd f31, -0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 828FD470: 483ABFB4  b 0x82ca9424
	sub_82CA9420(ctx, base);
	return;
            }
            0x828FD474 => {
    //   block [0x828FD474..0x828FD47C)
	// 828FD474: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FD478: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	pc = 0x828FD47C; continue 'dispatch;
            }
            0x828FD47C => {
    //   block [0x828FD47C..0x828FD48C)
	// 828FD47C: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828FD480: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 828FD484: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828FD488: 4E800421  bctrl
	ctx.lr = 0x828FD48C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x828FD48C => {
    //   block [0x828FD48C..0x828FD49C)
	// 828FD48C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828FD490: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 828FD494: CBE1FF68  lfd f31, -0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 828FD498: 483ABF8C  b 0x82ca9424
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FD4A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828FD4A0 size=8
    let mut pc: u32 = 0x828FD4A0;
    'dispatch: loop {
        match pc {
            0x828FD4A0 => {
    //   block [0x828FD4A0..0x828FD4A8)
	// 828FD4A0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828FD4A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FD4A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828FD4A8 size=444
    let mut pc: u32 = 0x828FD4A8;
    'dispatch: loop {
        match pc {
            0x828FD4A8 => {
    //   block [0x828FD4A8..0x828FD538)
	// 828FD4A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FD4AC: 483ABF61  bl 0x82ca940c
	ctx.lr = 0x828FD4B0;
	sub_82CA93D0(ctx, base);
	// 828FD4B0: 81230028  lwz r9, 0x28(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 828FD4B4: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FD4B8: C1A40008  lfs f13, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828FD4BC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828FD4C0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828FD4C4: 419A0074  beq cr6, 0x828fd538
	if ctx.cr[6].eq {
	pc = 0x828FD538; continue 'dispatch;
	}
	// 828FD4C8: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 828FD4CC: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 828FD4D0: 38E1FFA0  addi r7, r1, -0x60
	ctx.r[7].s64 = ctx.r[1].s64 + -96;
	pc = 0x828FD538; continue 'dispatch;
            }
            0x828FD538 => {
    //   block [0x828FD538..0x828FD664)
	// 828FD538: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828FD53C: 483ABF20  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 828FD540: 3941FFD0  addi r10, r1, -0x30
	ctx.r[10].s64 = ctx.r[1].s64 + -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FD668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FD668 size=392
    let mut pc: u32 = 0x828FD668;
    'dispatch: loop {
        match pc {
            0x828FD668 => {
    //   block [0x828FD668..0x828FD7F0)
	// 828FD668: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FD66C: 483ABD9D  bl 0x82ca9408
	ctx.lr = 0x828FD670;
	sub_82CA93D0(ctx, base);
	// 828FD670: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 828FD674: 483B0659  bl 0x82cadccc
	ctx.lr = 0x828FD678;
	sub_82CADCA0(ctx, base);
	// 828FD678: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FD67C: C1040004  lfs f8, 4(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 828FD680: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 828FD684: C0E40008  lfs f7, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 828FD688: FC404090  fmr f2, f8
	ctx.f[2].f64 = ctx.f[8].f64;
	// 828FD68C: FFE04090  fmr f31, f8
	ctx.f[31].f64 = ctx.f[8].f64;
	// 828FD690: C1640000  lfs f11, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828FD694: FC203890  fmr f1, f7
	ctx.f[1].f64 = ctx.f[7].f64;
	// 828FD698: 3FA0820A  lis r29, -0x7df6
	ctx.r[29].s64 = -2113273856;
	// 828FD69C: FFA03890  fmr f29, f7
	ctx.f[29].f64 = ctx.f[7].f64;
	// 828FD6A0: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 828FD6A4: FF604090  fmr f27, f8
	ctx.f[27].f64 = ctx.f[8].f64;
	// 828FD6A8: C14B0004  lfs f10, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828FD6AC: FF203890  fmr f25, f7
	ctx.f[25].f64 = ctx.f[7].f64;
	// 828FD6B0: C12B0008  lfs f9, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 828FD6B4: C0AB0000  lfs f5, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 828FD6B8: ECCA4028  fsubs f6, f10, f8
	ctx.f[6].f64 = (((ctx.f[10].f64 - ctx.f[8].f64) as f32) as f64);
	// 828FD6BC: EC655828  fsubs f3, f5, f11
	ctx.f[3].f64 = (((ctx.f[5].f64 - ctx.f[11].f64) as f32) as f64);
	// 828FD6C0: 393DB730  addi r9, r29, -0x48d0
	ctx.r[9].s64 = ctx.r[29].s64 + -18640;
	// 828FD6C4: EC893828  fsubs f4, f9, f7
	ctx.f[4].f64 = (((ctx.f[9].f64 - ctx.f[7].f64) as f32) as f64);
	// 828FD6C8: C18A12F4  lfs f12, 0x12f4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4852 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828FD6CC: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 828FD6D0: ECAA1028  fsubs f5, f10, f2
	ctx.f[5].f64 = (((ctx.f[10].f64 - ctx.f[2].f64) as f32) as f64);
	// 828FD6D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FD6D8: EF8AF828  fsubs f28, f10, f31
	ctx.f[28].f64 = (((ctx.f[10].f64 - ctx.f[31].f64) as f32) as f64);
	// 828FD6DC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828FD6E0: EFC90828  fsubs f30, f9, f1
	ctx.f[30].f64 = (((ctx.f[9].f64 - ctx.f[1].f64) as f32) as f64);
	// 828FD6E4: C009DD54  lfs f0, -0x22ac(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8876 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FD6E8: EF49E828  fsubs f26, f9, f29
	ctx.f[26].f64 = (((ctx.f[9].f64 - ctx.f[29].f64) as f32) as f64);
	// 828FD6EC: C1A9277C  lfs f13, 0x277c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(10108 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828FD6F0: ED4AD828  fsubs f10, f10, f27
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[27].f64) as f32) as f64);
	// 828FD6F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FD6F8: ED29C828  fsubs f9, f9, f25
	ctx.f[9].f64 = (((ctx.f[9].f64 - ctx.f[25].f64) as f32) as f64);
	// 828FD6FC: ED08302A  fadds f8, f8, f6
	ctx.f[8].f64 = ((ctx.f[8].f64 + ctx.f[6].f64) as f32) as f64;
	// 828FD700: D1010054  stfs f8, 0x54(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828FD704: ECCB182A  fadds f6, f11, f3
	ctx.f[6].f64 = ((ctx.f[11].f64 + ctx.f[3].f64) as f32) as f64;
	// 828FD708: D0C10050  stfs f6, 0x50(r1)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828FD70C: ECE7202A  fadds f7, f7, f4
	ctx.f[7].f64 = ((ctx.f[7].f64 + ctx.f[4].f64) as f32) as f64;
	// 828FD710: D0E10058  stfs f7, 0x58(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828FD714: ECA50032  fmuls f5, f5, f0
	ctx.f[5].f64 = (((ctx.f[5].f64 * ctx.f[0].f64) as f32) as f64);
	// 828FD718: ED1C0372  fmuls f8, f28, f13
	ctx.f[8].f64 = (((ctx.f[28].f64 * ctx.f[13].f64) as f32) as f64);
	// 828FD71C: EC9E0032  fmuls f4, f30, f0
	ctx.f[4].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 828FD720: ECFA0372  fmuls f7, f26, f13
	ctx.f[7].f64 = (((ctx.f[26].f64 * ctx.f[13].f64) as f32) as f64);
	// 828FD724: ECCA0332  fmuls f6, f10, f12
	ctx.f[6].f64 = (((ctx.f[10].f64 * ctx.f[12].f64) as f32) as f64);
	// 828FD728: ED490332  fmuls f10, f9, f12
	ctx.f[10].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 828FD72C: ED230032  fmuls f9, f3, f0
	ctx.f[9].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 828FD730: EC030372  fmuls f0, f3, f13
	ctx.f[0].f64 = (((ctx.f[3].f64 * ctx.f[13].f64) as f32) as f64);
	// 828FD734: EDA30332  fmuls f13, f3, f12
	ctx.f[13].f64 = (((ctx.f[3].f64 * ctx.f[12].f64) as f32) as f64);
	// 828FD738: ED82282A  fadds f12, f2, f5
	ctx.f[12].f64 = ((ctx.f[2].f64 + ctx.f[5].f64) as f32) as f64;
	// 828FD73C: D1810084  stfs f12, 0x84(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 828FD740: ECA1202A  fadds f5, f1, f4
	ctx.f[5].f64 = ((ctx.f[1].f64 + ctx.f[4].f64) as f32) as f64;
	// 828FD744: D0A10088  stfs f5, 0x88(r1)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 828FD748: EC9F402A  fadds f4, f31, f8
	ctx.f[4].f64 = ((ctx.f[31].f64 + ctx.f[8].f64) as f32) as f64;
	// 828FD74C: D0810074  stfs f4, 0x74(r1)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 828FD750: EC7D382A  fadds f3, f29, f7
	ctx.f[3].f64 = ((ctx.f[29].f64 + ctx.f[7].f64) as f32) as f64;
	// 828FD754: D0610078  stfs f3, 0x78(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 828FD758: EC39502A  fadds f1, f25, f10
	ctx.f[1].f64 = ((ctx.f[25].f64 + ctx.f[10].f64) as f32) as f64;
	// 828FD75C: D0210068  stfs f1, 0x68(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828FD760: ED8B482A  fadds f12, f11, f9
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[9].f64) as f32) as f64;
	// 828FD764: D1810080  stfs f12, 0x80(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 828FD768: EC5B302A  fadds f2, f27, f6
	ctx.f[2].f64 = ((ctx.f[27].f64 + ctx.f[6].f64) as f32) as f64;
	// 828FD76C: D0410064  stfs f2, 0x64(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828FD770: ED4B002A  fadds f10, f11, f0
	ctx.f[10].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 828FD774: D1410070  stfs f10, 0x70(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828FD778: ED2B682A  fadds f9, f11, f13
	ctx.f[9].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 828FD77C: D1210060  stfs f9, 0x60(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828FD780: 4BFFFD29  bl 0x828fd4a8
	ctx.lr = 0x828FD784;
	sub_828FD4A8(ctx, base);
	// 828FD784: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828FD788: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828FD78C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FD790: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828FD794: 4BFFFD15  bl 0x828fd4a8
	ctx.lr = 0x828FD798;
	sub_828FD4A8(ctx, base);
	// 828FD798: 7F9C1A14  add r28, r28, r3
	ctx.r[28].u64 = ctx.r[28].u64 + ctx.r[3].u64;
	// 828FD79C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828FD7A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FD7A4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828FD7A8: 4BFFFD01  bl 0x828fd4a8
	ctx.lr = 0x828FD7AC;
	sub_828FD4A8(ctx, base);
	// 828FD7AC: 7F9C1A14  add r28, r28, r3
	ctx.r[28].u64 = ctx.r[28].u64 + ctx.r[3].u64;
	// 828FD7B0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828FD7B4: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 828FD7B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FD7BC: 4BFFFCED  bl 0x828fd4a8
	ctx.lr = 0x828FD7C0;
	sub_828FD4A8(ctx, base);
	// 828FD7C0: 7D1C1A14  add r8, r28, r3
	ctx.r[8].u64 = ctx.r[28].u64 + ctx.r[3].u64;
	// 828FD7C4: C01DB730  lfs f0, -0x48d0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-18640 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FD7C8: 7D0707B4  extsw r7, r8
	ctx.r[7].s64 = ctx.r[8].s32 as i64;
	// 828FD7CC: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 828FD7D0: C9010050  lfd f8, 0x50(r1)
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828FD7D4: FCE0469C  fcfid f7, f8
	ctx.f[7].f64 = (ctx.f[8].s64 as f64);
	// 828FD7D8: FCC03818  frsp f6, f7
	ctx.f[6].f64 = (ctx.f[7].f64 as f32) as f64;
	// 828FD7DC: EC260032  fmuls f1, f6, f0
	ctx.f[1].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 828FD7E0: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 828FD7E4: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 828FD7E8: 483B0531  bl 0x82cadd18
	ctx.lr = 0x828FD7EC;
	sub_82CADCEC(ctx, base);
	// 828FD7EC: 483ABC6C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FD7F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FD7F0 size=108
    let mut pc: u32 = 0x828FD7F0;
    'dispatch: loop {
        match pc {
            0x828FD7F0 => {
    //   block [0x828FD7F0..0x828FD820)
	// 828FD7F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FD7F4: 483ABC19  bl 0x82ca940c
	ctx.lr = 0x828FD7F8;
	sub_82CA93D0(ctx, base);
	// 828FD7F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FD7FC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828FD800: 3BEBC908  addi r31, r11, -0x36f8
	ctx.r[31].s64 = ctx.r[11].s64 + -14072;
	// 828FD804: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FD808: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FD80C: 419A0030  beq cr6, 0x828fd83c
	if ctx.cr[6].eq {
	pc = 0x828FD83C; continue 'dispatch;
	}
	// 828FD810: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FD814: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FD818: 7F03E840  cmplw cr6, r3, r29
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828FD81C: 419A001C  beq cr6, 0x828fd838
	if ctx.cr[6].eq {
	pc = 0x828FD838; continue 'dispatch;
	}
	pc = 0x828FD820; continue 'dispatch;
            }
            0x828FD820 => {
    //   block [0x828FD820..0x828FD838)
	// 828FD820: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 828FD824: 4B8BA2F5  bl 0x821b7b18
	ctx.lr = 0x828FD828;
	sub_821B7B18(ctx, base);
	// 828FD828: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 828FD82C: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828FD830: 409AFFF0  bne cr6, 0x828fd820
	if !ctx.cr[6].eq {
	pc = 0x828FD820; continue 'dispatch;
	}
	// 828FD834: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x828FD838; continue 'dispatch;
            }
            0x828FD838 => {
    //   block [0x828FD838..0x828FD83C)
	// 828FD838: 4B91E501  bl 0x8221bd38
	ctx.lr = 0x828FD83C;
	sub_8221BD38(ctx, base);
	pc = 0x828FD83C; continue 'dispatch;
            }
            0x828FD83C => {
    //   block [0x828FD83C..0x828FD85C)
	// 828FD83C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828FD840: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828FD844: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828FD848: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828FD84C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828FD850: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 828FD854: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FD858: 483ABC04  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FD860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FD860 size=88
    let mut pc: u32 = 0x828FD860;
    'dispatch: loop {
        match pc {
            0x828FD860 => {
    //   block [0x828FD860..0x828FD8A4)
	// 828FD860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FD864: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FD868: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FD86C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828FD870: 4BD190B9  bl 0x82616928
	ctx.lr = 0x828FD874;
	sub_82616928(ctx, base);
	// 828FD874: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FD878: 419A002C  beq cr6, 0x828fd8a4
	if ctx.cr[6].eq {
	pc = 0x828FD8A4; continue 'dispatch;
	}
	// 828FD87C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828FD880: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828FD884: 392A1BBC  addi r9, r10, 0x1bbc
	ctx.r[9].s64 = ctx.r[10].s64 + 7100;
	// 828FD888: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828FD88C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828FD890: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828FD894: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828FD898: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FD89C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FD8A0: 4E800020  blr
	return;
            }
            0x828FD8A4 => {
    //   block [0x828FD8A4..0x828FD8B8)
	// 828FD8A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828FD8A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828FD8AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FD8B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FD8B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FD8B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FD8B8 size=1540
    let mut pc: u32 = 0x828FD8B8;
    'dispatch: loop {
        match pc {
            0x828FD8B8 => {
    //   block [0x828FD8B8..0x828FD8FC)
	// 828FD8B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FD8BC: 483ABB39  bl 0x82ca93f4
	ctx.lr = 0x828FD8C0;
	sub_82CA93D0(ctx, base);
	// 828FD8C0: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 828FD8C4: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FD8C8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828FD8CC: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 828FD8D0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828FD8D4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828FD8D8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828FD8DC: 388B8D14  addi r4, r11, -0x72ec
	ctx.r[4].s64 = ctx.r[11].s64 + -29420;
	// 828FD8E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FD8E4: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 828FD8E8: 4B902E89  bl 0x82200770
	ctx.lr = 0x828FD8EC;
	sub_82200770(ctx, base);
	// 828FD8EC: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828FD8F0: 892A6D87  lbz r9, 0x6d87(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(28039 as u32) ) } as u64;
	// 828FD8F4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828FD8F8: 419A00AC  beq cr6, 0x828fd9a4
	if ctx.cr[6].eq {
	pc = 0x828FD9A4; continue 'dispatch;
	}
	pc = 0x828FD8FC; continue 'dispatch;
            }
            0x828FD8FC => {
    //   block [0x828FD8FC..0x828FD994)
	// 828FD8FC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FD900: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FD904: 88E10054  lbz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FD908: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828FD90C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828FD910: 808B0038  lwz r4, 0x38(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828FD914: 80AB003C  lwz r5, 0x3c(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 828FD918: 80EB0018  lwz r7, 0x18(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 828FD91C: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 828FD920: 7D44402E  lwzx r10, r4, r8
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 828FD924: 7D65402E  lwzx r11, r5, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 828FD928: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828FD92C: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828FD930: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828FD934: 7C6B4A14  add r3, r11, r9
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 828FD938: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828FD93C: 546B103A  slwi r11, r3, 2
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828FD940: 7D4A3214  add r10, r10, r6
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[6].u64;
	// 828FD944: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 828FD948: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 828FD94C: 392A0004  addi r9, r10, 4
	ctx.r[9].s64 = ctx.r[10].s64 + 4;
	// 828FD950: C1AA0004  lfs f13, 4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828FD954: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FD958: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 828FD95C: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828FD960: C14A0008  lfs f10, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828FD964: ED2B5028  fsubs f9, f11, f10
	ctx.f[9].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 828FD968: C10B000C  lfs f8, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 828FD96C: C0EA000C  lfs f7, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 828FD970: ECC83828  fsubs f6, f8, f7
	ctx.f[6].f64 = (((ctx.f[8].f64 - ctx.f[7].f64) as f32) as f64);
	// 828FD974: ECAC0332  fmuls f5, f12, f12
	ctx.f[5].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 828FD978: EC892A7A  fmadds f4, f9, f9, f5
	ctx.f[4].f64 = (((ctx.f[9].f64 * ctx.f[9].f64 + ctx.f[5].f64) as f32) as f64);
	// 828FD97C: EC6621BA  fmadds f3, f6, f6, f4
	ctx.f[3].f64 = (((ctx.f[6].f64 * ctx.f[6].f64 + ctx.f[4].f64) as f32) as f64);
	// 828FD980: EC40182C  fsqrts f2, f3
	ctx.f[2].f64 = ((ctx.f[3].f64).sqrt() as f32) as f64;
	// 828FD984: D05A0000  stfs f2, 0(r26)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828FD988: 419A000C  beq cr6, 0x828fd994
	if ctx.cr[6].eq {
	pc = 0x828FD994; continue 'dispatch;
	}
	// 828FD98C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FD990: 489BBFC5  bl 0x832b9954
	ctx.lr = 0x828FD994;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x828FD994; continue 'dispatch;
            }
            0x828FD994 => {
    //   block [0x828FD994..0x828FD9A4)
	// 828FD994: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828FD998: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828FD99C: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 828FD9A0: 483ABAA4  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x828FD9A4 => {
    //   block [0x828FD9A4..0x828FD9F0)
	// 828FD9A4: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FD9A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FD9AC: 419A04EC  beq cr6, 0x828fde98
	if ctx.cr[6].eq {
	pc = 0x828FDE98; continue 'dispatch;
	}
	// 828FD9B0: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FD9B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FD9B8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828FD9BC: 409A0034  bne cr6, 0x828fd9f0
	if !ctx.cr[6].eq {
	pc = 0x828FD9F0; continue 'dispatch;
	}
	// 828FD9C0: 392BBC68  addi r9, r11, -0x4398
	ctx.r[9].s64 = ctx.r[11].s64 + -17304;
	// 828FD9C4: 89010054  lbz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FD9C8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828FD9CC: C009D828  lfs f0, -0x27d8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10200 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FD9D0: D01A0000  stfs f0, 0(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828FD9D4: 419AFFC0  beq cr6, 0x828fd994
	if ctx.cr[6].eq {
	pc = 0x828FD994; continue 'dispatch;
	}
	// 828FD9D8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FD9DC: 489BBF79  bl 0x832b9954
	ctx.lr = 0x828FD9E0;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 828FD9E0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828FD9E4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828FD9E8: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 828FD9EC: 483ABA58  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x828FD9F0 => {
    //   block [0x828FD9F0..0x828FDA2C)
	// 828FD9F0: 3AEBBC68  addi r23, r11, -0x4398
	ctx.r[23].s64 = ctx.r[11].s64 + -17304;
	// 828FD9F4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828FD9F8: C3F7D828  lfs f31, -0x27d8(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-10200 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828FD9FC: 419A049C  beq cr6, 0x828fde98
	if ctx.cr[6].eq {
	pc = 0x828FDE98; continue 'dispatch;
	}
	// 828FDA00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FDA04: 4BD1BFCD  bl 0x826199d0
	ctx.lr = 0x828FDA08;
	sub_826199D0(ctx, base);
	// 828FDA08: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828FDA0C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828FDA10: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828FDA14: 419A0018  beq cr6, 0x828fda2c
	if ctx.cr[6].eq {
	pc = 0x828FDA2C; continue 'dispatch;
	}
	// 828FDA18: 897B0090  lbz r11, 0x90(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(144 as u32) ) } as u64;
	// 828FDA1C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828FDA20: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FDA24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FDA28: 409A0008  bne cr6, 0x828fda30
	if !ctx.cr[6].eq {
	pc = 0x828FDA30; continue 'dispatch;
	}
	pc = 0x828FDA2C; continue 'dispatch;
            }
            0x828FDA2C => {
    //   block [0x828FDA2C..0x828FDA30)
	// 828FDA2C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x828FDA30; continue 'dispatch;
            }
            0x828FDA30 => {
    //   block [0x828FDA30..0x828FDA84)
	// 828FDA30: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FDA34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FDA38: 419A0460  beq cr6, 0x828fde98
	if ctx.cr[6].eq {
	pc = 0x828FDE98; continue 'dispatch;
	}
	// 828FDA3C: 817B0028  lwz r11, 0x28(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 828FDA40: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 828FDA44: 815B0038  lwz r10, 0x38(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(56 as u32) ) } as u64;
	// 828FDA48: 556927FE  rlwinm r9, r11, 4, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x0FFFFFFFu64;
	// 828FDA4C: 5559F7FE  rlwinm r25, r10, 0x1e, 0x1f, 0x1f
	ctx.r[25].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 828FDA50: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828FDA54: 419A00F4  beq cr6, 0x828fdb48
	if ctx.cr[6].eq {
	pc = 0x828FDB48; continue 'dispatch;
	}
	// 828FDA58: 817B008C  lwz r11, 0x8c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(140 as u32) ) } as u64;
	// 828FDA5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FDA60: 419A0024  beq cr6, 0x828fda84
	if ctx.cr[6].eq {
	pc = 0x828FDA84; continue 'dispatch;
	}
	// 828FDA64: 894B003C  lbz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 828FDA68: 817B0048  lwz r11, 0x48(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 828FDA6C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828FDA70: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828FDA74: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FDA78: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828FDA7C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FDA80: 480000CC  b 0x828fdb4c
	pc = 0x828FDB4C; continue 'dispatch;
            }
            0x828FDA84 => {
    //   block [0x828FDA84..0x828FDAA0)
	// 828FDA84: 815B0048  lwz r10, 0x48(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 828FDA88: 80DB004C  lwz r6, 0x4c(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(76 as u32) ) } as u64;
	// 828FDA8C: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 828FDA90: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828FDA94: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828FDA98: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FDA9C: 40810054  ble 0x828fdaf0
	if !ctx.cr[0].gt {
	pc = 0x828FDAF0; continue 'dispatch;
	}
	pc = 0x828FDAA0; continue 'dispatch;
            }
            0x828FDAA0 => {
    //   block [0x828FDAA0..0x828FDAC0)
	// 828FDAA0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828FDAA4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828FDAA8: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828FDAAC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FDAB0: 2F07003C  cmpwi cr6, r7, 0x3c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 60, &mut ctx.xer);
	// 828FDAB4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828FDAB8: 41980008  blt cr6, 0x828fdac0
	if ctx.cr[6].lt {
	pc = 0x828FDAC0; continue 'dispatch;
	}
	// 828FDABC: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x828FDAC0; continue 'dispatch;
            }
            0x828FDAC0 => {
    //   block [0x828FDAC0..0x828FDADC)
	// 828FDAC0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828FDAC4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828FDAC8: 419A0014  beq cr6, 0x828fdadc
	if ctx.cr[6].eq {
	pc = 0x828FDADC; continue 'dispatch;
	}
	// 828FDACC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828FDAD0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828FDAD4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828FDAD8: 4800000C  b 0x828fdae4
	pc = 0x828FDAE4; continue 'dispatch;
            }
            0x828FDADC => {
    //   block [0x828FDADC..0x828FDAE4)
	// 828FDADC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828FDAE0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828FDAE4; continue 'dispatch;
            }
            0x828FDAE4 => {
    //   block [0x828FDAE4..0x828FDAF0)
	// 828FDAE4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FDAE8: 4199FFB8  bgt cr6, 0x828fdaa0
	if ctx.cr[6].gt {
	pc = 0x828FDAA0; continue 'dispatch;
	}
	// 828FDAEC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x828FDAF0; continue 'dispatch;
            }
            0x828FDAF0 => {
    //   block [0x828FDAF0..0x828FDB0C)
	// 828FDAF0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828FDAF4: 419A0040  beq cr6, 0x828fdb34
	if ctx.cr[6].eq {
	pc = 0x828FDB34; continue 'dispatch;
	}
	// 828FDAF8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FDAFC: 2F0B003C  cmpwi cr6, r11, 0x3c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 60, &mut ctx.xer);
	// 828FDB00: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FDB04: 41990008  bgt cr6, 0x828fdb0c
	if ctx.cr[6].gt {
	pc = 0x828FDB0C; continue 'dispatch;
	}
	// 828FDB08: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x828FDB0C; continue 'dispatch;
            }
            0x828FDB0C => {
    //   block [0x828FDB0C..0x828FDB34)
	// 828FDB0C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FDB10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FDB14: 409A0020  bne cr6, 0x828fdb34
	if !ctx.cr[6].eq {
	pc = 0x828FDB34; continue 'dispatch;
	}
	// 828FDB18: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828FDB1C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828FDB20: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828FDB24: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FDB28: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828FDB2C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FDB30: 4800001C  b 0x828fdb4c
	pc = 0x828FDB4C; continue 'dispatch;
            }
            0x828FDB34 => {
    //   block [0x828FDB34..0x828FDB48)
	// 828FDB34: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828FDB38: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FDB3C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 828FDB40: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FDB44: 48000008  b 0x828fdb4c
	pc = 0x828FDB4C; continue 'dispatch;
            }
            0x828FDB48 => {
    //   block [0x828FDB48..0x828FDB4C)
	// 828FDB48: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x828FDB4C; continue 'dispatch;
            }
            0x828FDB4C => {
    //   block [0x828FDB4C..0x828FDB78)
	// 828FDB4C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FDB50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FDB54: 419A0238  beq cr6, 0x828fdd8c
	if ctx.cr[6].eq {
	pc = 0x828FDD8C; continue 'dispatch;
	}
	// 828FDB58: 81580008  lwz r10, 8(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FDB5C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FDB60: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FDB64: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828FDB68: 40980010  bge cr6, 0x828fdb78
	if !ctx.cr[6].lt {
	pc = 0x828FDB78; continue 'dispatch;
	}
	// 828FDB6C: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 828FDB70: 7D4A58AE  lbzx r10, r10, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828FDB74: 48000008  b 0x828fdb7c
	pc = 0x828FDB7C; continue 'dispatch;
            }
            0x828FDB78 => {
    //   block [0x828FDB78..0x828FDB7C)
	// 828FDB78: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	pc = 0x828FDB7C; continue 'dispatch;
            }
            0x828FDB7C => {
    //   block [0x828FDB7C..0x828FDC2C)
	// 828FDB7C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828FDB80: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FDB84: 419A01F4  beq cr6, 0x828fdd78
	if ctx.cr[6].eq {
	pc = 0x828FDD78; continue 'dispatch;
	}
	// 828FDB88: 895D00B9  lbz r10, 0xb9(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(185 as u32) ) } as u64;
	// 828FDB8C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FDB90: 409A009C  bne cr6, 0x828fdc2c
	if !ctx.cr[6].eq {
	pc = 0x828FDC2C; continue 'dispatch;
	}
	// 828FDB94: 895D0285  lbz r10, 0x285(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(645 as u32) ) } as u64;
	// 828FDB98: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FDB9C: 419A02FC  beq cr6, 0x828fde98
	if ctx.cr[6].eq {
	pc = 0x828FDE98; continue 'dispatch;
	}
	// 828FDBA0: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FDBA4: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828FDBA8: 88E10054  lbz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FDBAC: C0170000  lfs f0, 0(r23)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FDBB0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828FDBB4: 80AA003C  lwz r5, 0x3c(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) } as u64;
	// 828FDBB8: 808A0038  lwz r4, 0x38(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) } as u64;
	// 828FDBBC: 80EA0018  lwz r7, 0x18(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 828FDBC0: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 828FDBC4: 7D65482E  lwzx r11, r5, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 828FDBC8: 7D44482E  lwzx r10, r4, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 828FDBCC: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828FDBD0: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828FDBD4: 7C6B4A14  add r3, r11, r9
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 828FDBD8: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828FDBDC: 546B103A  slwi r11, r3, 2
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828FDBE0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828FDBE4: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 828FDBE8: 7D4A3214  add r10, r10, r6
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[6].u64;
	// 828FDBEC: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828FDBF0: C18A0004  lfs f12, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828FDBF4: ED6D6028  fsubs f11, f13, f12
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 828FDBF8: C14B0008  lfs f10, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828FDBFC: C12A0008  lfs f9, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 828FDC00: ED0A4828  fsubs f8, f10, f9
	ctx.f[8].f64 = (((ctx.f[10].f64 - ctx.f[9].f64) as f32) as f64);
	// 828FDC04: C0EB000C  lfs f7, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 828FDC08: C0CA000C  lfs f6, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 828FDC0C: ECA73028  fsubs f5, f7, f6
	ctx.f[5].f64 = (((ctx.f[7].f64 - ctx.f[6].f64) as f32) as f64);
	// 828FDC10: EC8B02F2  fmuls f4, f11, f11
	ctx.f[4].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 828FDC14: EC68223A  fmadds f3, f8, f8, f4
	ctx.f[3].f64 = (((ctx.f[8].f64 * ctx.f[8].f64 + ctx.f[4].f64) as f32) as f64);
	// 828FDC18: EC45197A  fmadds f2, f5, f5, f3
	ctx.f[2].f64 = (((ctx.f[5].f64 * ctx.f[5].f64 + ctx.f[3].f64) as f32) as f64);
	// 828FDC1C: EC20102C  fsqrts f1, f2
	ctx.f[1].f64 = ((ctx.f[2].f64).sqrt() as f32) as f64;
	// 828FDC20: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 828FDC24: D01A0000  stfs f0, 0(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828FDC28: 4800024C  b 0x828fde74
	pc = 0x828FDE74; continue 'dispatch;
            }
            0x828FDC2C => {
    //   block [0x828FDC2C..0x828FDC94)
	// 828FDC2C: 572B063E  clrlwi r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 828FDC30: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 828FDC34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FDC38: 419A0140  beq cr6, 0x828fdd78
	if ctx.cr[6].eq {
	pc = 0x828FDD78; continue 'dispatch;
	}
	// 828FDC3C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828FDC40: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828FDC44: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FDC48: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828FDC4C: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FDC50: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FDC54: 4B92E565  bl 0x8222c1b8
	ctx.lr = 0x828FDC58;
	sub_8222C1B8(ctx, base);
	// 828FDC58: 80E30034  lwz r7, 0x34(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 828FDC5C: 54E6BFFE  rlwinm r6, r7, 0x17, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x000001FFu64;
	// 828FDC60: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 828FDC64: 419A00F4  beq cr6, 0x828fdd58
	if ctx.cr[6].eq {
	pc = 0x828FDD58; continue 'dispatch;
	}
	// 828FDC68: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828FDC6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FDC70: 419A0024  beq cr6, 0x828fdc94
	if ctx.cr[6].eq {
	pc = 0x828FDC94; continue 'dispatch;
	}
	// 828FDC74: 894B0089  lbz r10, 0x89(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(137 as u32) ) } as u64;
	// 828FDC78: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828FDC7C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828FDC80: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828FDC84: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FDC88: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828FDC8C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FDC90: 480000CC  b 0x828fdd5c
	pc = 0x828FDD5C; continue 'dispatch;
            }
            0x828FDC94 => {
    //   block [0x828FDC94..0x828FDCB0)
	// 828FDC94: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828FDC98: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828FDC9C: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 828FDCA0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828FDCA4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828FDCA8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FDCAC: 40810054  ble 0x828fdd00
	if !ctx.cr[0].gt {
	pc = 0x828FDD00; continue 'dispatch;
	}
	pc = 0x828FDCB0; continue 'dispatch;
            }
            0x828FDCB0 => {
    //   block [0x828FDCB0..0x828FDCD0)
	// 828FDCB0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828FDCB4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828FDCB8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828FDCBC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FDCC0: 2F070089  cmpwi cr6, r7, 0x89
	ctx.cr[6].compare_i32(ctx.r[7].s32, 137, &mut ctx.xer);
	// 828FDCC4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828FDCC8: 41980008  blt cr6, 0x828fdcd0
	if ctx.cr[6].lt {
	pc = 0x828FDCD0; continue 'dispatch;
	}
	// 828FDCCC: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x828FDCD0; continue 'dispatch;
            }
            0x828FDCD0 => {
    //   block [0x828FDCD0..0x828FDCEC)
	// 828FDCD0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828FDCD4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828FDCD8: 419A0014  beq cr6, 0x828fdcec
	if ctx.cr[6].eq {
	pc = 0x828FDCEC; continue 'dispatch;
	}
	// 828FDCDC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828FDCE0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828FDCE4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828FDCE8: 4800000C  b 0x828fdcf4
	pc = 0x828FDCF4; continue 'dispatch;
            }
            0x828FDCEC => {
    //   block [0x828FDCEC..0x828FDCF4)
	// 828FDCEC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828FDCF0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828FDCF4; continue 'dispatch;
            }
            0x828FDCF4 => {
    //   block [0x828FDCF4..0x828FDD00)
	// 828FDCF4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FDCF8: 4199FFB8  bgt cr6, 0x828fdcb0
	if ctx.cr[6].gt {
	pc = 0x828FDCB0; continue 'dispatch;
	}
	// 828FDCFC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x828FDD00; continue 'dispatch;
            }
            0x828FDD00 => {
    //   block [0x828FDD00..0x828FDD1C)
	// 828FDD00: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828FDD04: 419A0040  beq cr6, 0x828fdd44
	if ctx.cr[6].eq {
	pc = 0x828FDD44; continue 'dispatch;
	}
	// 828FDD08: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FDD0C: 2F0B0089  cmpwi cr6, r11, 0x89
	ctx.cr[6].compare_i32(ctx.r[11].s32, 137, &mut ctx.xer);
	// 828FDD10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FDD14: 41990008  bgt cr6, 0x828fdd1c
	if ctx.cr[6].gt {
	pc = 0x828FDD1C; continue 'dispatch;
	}
	// 828FDD18: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x828FDD1C; continue 'dispatch;
            }
            0x828FDD1C => {
    //   block [0x828FDD1C..0x828FDD44)
	// 828FDD1C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FDD20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FDD24: 409A0020  bne cr6, 0x828fdd44
	if !ctx.cr[6].eq {
	pc = 0x828FDD44; continue 'dispatch;
	}
	// 828FDD28: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828FDD2C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828FDD30: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828FDD34: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FDD38: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828FDD3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FDD40: 4800001C  b 0x828fdd5c
	pc = 0x828FDD5C; continue 'dispatch;
            }
            0x828FDD44 => {
    //   block [0x828FDD44..0x828FDD58)
	// 828FDD44: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828FDD48: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FDD4C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828FDD50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FDD54: 48000008  b 0x828fdd5c
	pc = 0x828FDD5C; continue 'dispatch;
            }
            0x828FDD58 => {
    //   block [0x828FDD58..0x828FDD5C)
	// 828FDD58: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x828FDD5C; continue 'dispatch;
            }
            0x828FDD5C => {
    //   block [0x828FDD5C..0x828FDD78)
	// 828FDD5C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FDD60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FDD64: 419A0014  beq cr6, 0x828fdd78
	if ctx.cr[6].eq {
	pc = 0x828FDD78; continue 'dispatch;
	}
	// 828FDD68: 897F0049  lbz r11, 0x49(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(73 as u32) ) } as u64;
	// 828FDD6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FDD70: 409A0008  bne cr6, 0x828fdd78
	if !ctx.cr[6].eq {
	pc = 0x828FDD78; continue 'dispatch;
	}
	// 828FDD74: C3F7F818  lfs f31, -0x7e8(r23)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-2024 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x828FDD78; continue 'dispatch;
            }
            0x828FDD78 => {
    //   block [0x828FDD78..0x828FDD8C)
	// 828FDD78: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FDD7C: 4BD67E8D  bl 0x82665c08
	ctx.lr = 0x828FDD80;
	sub_82665C08(ctx, base);
	// 828FDD80: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828FDD84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FDD88: 409AFB74  bne cr6, 0x828fd8fc
	if !ctx.cr[6].eq {
	pc = 0x828FD8FC; continue 'dispatch;
	}
	pc = 0x828FDD8C; continue 'dispatch;
            }
            0x828FDD8C => {
    //   block [0x828FDD8C..0x828FDDBC)
	// 828FDD8C: 572B063E  clrlwi r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 828FDD90: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FDD94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FDD98: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FDD9C: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FDDA0: 419A001C  beq cr6, 0x828fddbc
	if ctx.cr[6].eq {
	pc = 0x828FDDBC; continue 'dispatch;
	}
	// 828FDDA4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828FDDA8: 4098002C  bge cr6, 0x828fddd4
	if !ctx.cr[6].lt {
	pc = 0x828FDDD4; continue 'dispatch;
	}
	// 828FDDAC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828FDDB0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828FDDB4: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828FDDB8: 48000020  b 0x828fddd8
	pc = 0x828FDDD8; continue 'dispatch;
            }
            0x828FDDBC => {
    //   block [0x828FDDBC..0x828FDDD4)
	// 828FDDBC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828FDDC0: 40980014  bge cr6, 0x828fddd4
	if !ctx.cr[6].lt {
	pc = 0x828FDDD4; continue 'dispatch;
	}
	// 828FDDC4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FDDC8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828FDDCC: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828FDDD0: 48000008  b 0x828fddd8
	pc = 0x828FDDD8; continue 'dispatch;
            }
            0x828FDDD4 => {
    //   block [0x828FDDD4..0x828FDDD8)
	// 828FDDD4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	pc = 0x828FDDD8; continue 'dispatch;
            }
            0x828FDDD8 => {
    //   block [0x828FDDD8..0x828FDE74)
	// 828FDDD8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828FDDDC: 4800109D  bl 0x828fee78
	ctx.lr = 0x828FDDE0;
	sub_828FEE78(ctx, base);
	// 828FDDE0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FDDE4: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FDDE8: C017D828  lfs f0, -0x27d8(r23)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-10200 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FDDEC: 88C10054  lbz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FDDF0: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 828FDDF4: 5547103A  slwi r7, r10, 2
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 828FDDF8: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 828FDDFC: 808B0038  lwz r4, 0x38(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828FDE00: 80AB003C  lwz r5, 0x3c(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 828FDE04: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 828FDE08: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 828FDE0C: 7D44382E  lwzx r10, r4, r7
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 828FDE10: 7D65382E  lwzx r11, r5, r7
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 828FDE14: 5546103A  slwi r6, r10, 2
	ctx.r[6].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 828FDE18: 5567103A  slwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 828FDE1C: 7D4A3214  add r10, r10, r6
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[6].u64;
	// 828FDE20: 7C6B3A14  add r3, r11, r7
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 828FDE24: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828FDE28: 546B103A  slwi r11, r3, 2
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828FDE2C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 828FDE30: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 828FDE34: C18A0004  lfs f12, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828FDE38: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828FDE3C: ED6D6028  fsubs f11, f13, f12
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 828FDE40: C14B0008  lfs f10, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828FDE44: C12A0008  lfs f9, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 828FDE48: ED0A4828  fsubs f8, f10, f9
	ctx.f[8].f64 = (((ctx.f[10].f64 - ctx.f[9].f64) as f32) as f64);
	// 828FDE4C: C0EB000C  lfs f7, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 828FDE50: C0CA000C  lfs f6, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 828FDE54: ECA73028  fsubs f5, f7, f6
	ctx.f[5].f64 = (((ctx.f[7].f64 - ctx.f[6].f64) as f32) as f64);
	// 828FDE58: EC8B02F2  fmuls f4, f11, f11
	ctx.f[4].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 828FDE5C: EC68223A  fmadds f3, f8, f8, f4
	ctx.f[3].f64 = (((ctx.f[8].f64 * ctx.f[8].f64 + ctx.f[4].f64) as f32) as f64);
	// 828FDE60: EC45197A  fmadds f2, f5, f5, f3
	ctx.f[2].f64 = (((ctx.f[5].f64 * ctx.f[5].f64 + ctx.f[3].f64) as f32) as f64);
	// 828FDE64: EC20102C  fsqrts f1, f2
	ctx.f[1].f64 = ((ctx.f[2].f64).sqrt() as f32) as f64;
	// 828FDE68: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 828FDE6C: EDA007F2  fmuls f13, f0, f31
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 828FDE70: D1BA0000  stfs f13, 0(r26)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x828FDE74; continue 'dispatch;
            }
            0x828FDE74 => {
    //   block [0x828FDE74..0x828FDE98)
	// 828FDE74: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 828FDE78: 392A0004  addi r9, r10, 4
	ctx.r[9].s64 = ctx.r[10].s64 + 4;
	// 828FDE7C: 419AFB18  beq cr6, 0x828fd994
	if ctx.cr[6].eq {
	pc = 0x828FD994; continue 'dispatch;
	}
	// 828FDE80: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FDE84: 489BBAD1  bl 0x832b9954
	ctx.lr = 0x828FDE88;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 828FDE88: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828FDE8C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828FDE90: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 828FDE94: 483AB5B0  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x828FDE98 => {
    //   block [0x828FDE98..0x828FDEAC)
	// 828FDE98: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FDE9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FDEA0: 419A000C  beq cr6, 0x828fdeac
	if ctx.cr[6].eq {
	pc = 0x828FDEAC; continue 'dispatch;
	}
	// 828FDEA4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FDEA8: 489BBAAD  bl 0x832b9954
	ctx.lr = 0x828FDEAC;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x828FDEAC; continue 'dispatch;
            }
            0x828FDEAC => {
    //   block [0x828FDEAC..0x828FDEBC)
	// 828FDEAC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828FDEB0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828FDEB4: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 828FDEB8: 483AB58C  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FDEC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FDEC0 size=4024
    let mut pc: u32 = 0x828FDEC0;
    'dispatch: loop {
        match pc {
            0x828FDEC0 => {
    //   block [0x828FDEC0..0x828FDF0C)
	// 828FDEC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FDEC4: 483AB515  bl 0x82ca93d8
	ctx.lr = 0x828FDEC8;
	sub_82CA93D0(ctx, base);
	// 828FDEC8: 3981FF78  addi r12, r1, -0x88
	ctx.r[12].s64 = ctx.r[1].s64 + -136;
	// 828FDECC: 483AFDF1  bl 0x82cadcbc
	ctx.lr = 0x828FDED0;
	sub_82CADCA0(ctx, base);
	// 828FDED0: 9421FE20  stwu r1, -0x1e0(r1)
	ea = ctx.r[1].u32.wrapping_add(-480 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FDED4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828FDED8: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 828FDEDC: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 828FDEE0: 7CB22B78  mr r18, r5
	ctx.r[18].u64 = ctx.r[5].u64;
	// 828FDEE4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828FDEE8: 388B8D14  addi r4, r11, -0x72ec
	ctx.r[4].s64 = ctx.r[11].s64 + -29420;
	// 828FDEEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FDEF0: 7CD13378  mr r17, r6
	ctx.r[17].u64 = ctx.r[6].u64;
	// 828FDEF4: 7CF03B78  mr r16, r7
	ctx.r[16].u64 = ctx.r[7].u64;
	// 828FDEF8: 4B902879  bl 0x82200770
	ctx.lr = 0x828FDEFC;
	sub_82200770(ctx, base);
	// 828FDEFC: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828FDF00: 892A6D87  lbz r9, 0x6d87(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(28039 as u32) ) } as u64;
	// 828FDF04: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828FDF08: 419A0064  beq cr6, 0x828fdf6c
	if ctx.cr[6].eq {
	pc = 0x828FDF6C; continue 'dispatch;
	}
	pc = 0x828FDF0C; continue 'dispatch;
            }
            0x828FDF0C => {
    //   block [0x828FDF0C..0x828FDF58)
	// 828FDF0C: C0110000  lfs f0, 0(r17)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FDF10: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FDF14: C1B20000  lfs f13, 0(r18)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828FDF18: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 828FDF1C: C1710004  lfs f11, 4(r17)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828FDF20: C1520004  lfs f10, 4(r18)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828FDF24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FDF28: ED2B5028  fsubs f9, f11, f10
	ctx.f[9].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 828FDF2C: C1110008  lfs f8, 8(r17)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 828FDF30: C0F20008  lfs f7, 8(r18)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 828FDF34: ECC83828  fsubs f6, f8, f7
	ctx.f[6].f64 = (((ctx.f[8].f64 - ctx.f[7].f64) as f32) as f64);
	// 828FDF38: ECAC0332  fmuls f5, f12, f12
	ctx.f[5].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 828FDF3C: EC892A7A  fmadds f4, f9, f9, f5
	ctx.f[4].f64 = (((ctx.f[9].f64 * ctx.f[9].f64 + ctx.f[5].f64) as f32) as f64);
	// 828FDF40: EC6621BA  fmadds f3, f6, f6, f4
	ctx.f[3].f64 = (((ctx.f[6].f64 * ctx.f[6].f64 + ctx.f[4].f64) as f32) as f64);
	// 828FDF44: EC40182C  fsqrts f2, f3
	ctx.f[2].f64 = ((ctx.f[3].f64).sqrt() as f32) as f64;
	// 828FDF48: D0500000  stfs f2, 0(r16)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[16].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828FDF4C: 419A000C  beq cr6, 0x828fdf58
	if ctx.cr[6].eq {
	pc = 0x828FDF58; continue 'dispatch;
	}
	// 828FDF50: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FDF54: 489BBA01  bl 0x832b9954
	ctx.lr = 0x828FDF58;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x828FDF58; continue 'dispatch;
            }
            0x828FDF58 => {
    //   block [0x828FDF58..0x828FDF6C)
	// 828FDF58: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828FDF5C: 382101E0  addi r1, r1, 0x1e0
	ctx.r[1].s64 = ctx.r[1].s64 + 480;
	// 828FDF60: 3981FF78  addi r12, r1, -0x88
	ctx.r[12].s64 = ctx.r[1].s64 + -136;
	// 828FDF64: 483AFDA5  bl 0x82cadd08
	ctx.lr = 0x828FDF68;
	sub_82CADCEC(ctx, base);
	// 828FDF68: 483AB4C0  b 0x82ca9428
	sub_82CA9420(ctx, base);
	return;
            }
            0x828FDF6C => {
    //   block [0x828FDF6C..0x828FDF74)
	// 828FDF6C: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 828FDF70: 409A0010  bne cr6, 0x828fdf80
	if !ctx.cr[6].eq {
	pc = 0x828FDF80; continue 'dispatch;
	}
	pc = 0x828FDF74; continue 'dispatch;
            }
            0x828FDF74 => {
    //   block [0x828FDF74..0x828FDF78)
	// 828FDF74: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x828FDF78; continue 'dispatch;
            }
            0x828FDF78 => {
    //   block [0x828FDF78..0x828FDF80)
	// 828FDF78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FDF7C: 48000EDC  b 0x828fee58
	pc = 0x828FEE58; continue 'dispatch;
            }
            0x828FDF80 => {
    //   block [0x828FDF80..0x828FDFAC)
	// 828FDF80: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 828FDF84: 4BD1BA4D  bl 0x826199d0
	ctx.lr = 0x828FDF88;
	sub_826199D0(ctx, base);
	// 828FDF88: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 828FDF8C: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 828FDF90: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 828FDF94: 419A0018  beq cr6, 0x828fdfac
	if ctx.cr[6].eq {
	pc = 0x828FDFAC; continue 'dispatch;
	}
	// 828FDF98: 89740090  lbz r11, 0x90(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[20].u32.wrapping_add(144 as u32) ) } as u64;
	// 828FDF9C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828FDFA0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FDFA4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FDFA8: 409A0008  bne cr6, 0x828fdfb0
	if !ctx.cr[6].eq {
	pc = 0x828FDFB0; continue 'dispatch;
	}
	pc = 0x828FDFAC; continue 'dispatch;
            }
            0x828FDFAC => {
    //   block [0x828FDFAC..0x828FDFB0)
	// 828FDFAC: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	pc = 0x828FDFB0; continue 'dispatch;
            }
            0x828FDFB0 => {
    //   block [0x828FDFB0..0x828FDFC8)
	// 828FDFB0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FDFB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FDFB8: 409A0010  bne cr6, 0x828fdfc8
	if !ctx.cr[6].eq {
	pc = 0x828FDFC8; continue 'dispatch;
	}
	// 828FDFBC: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FDFC0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FDFC4: 48000E94  b 0x828fee58
	pc = 0x828FEE58; continue 'dispatch;
            }
            0x828FDFC8 => {
    //   block [0x828FDFC8..0x828FDFE4)
	// 828FDFC8: 81740038  lwz r11, 0x38(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(56 as u32) ) } as u64;
	// 828FDFCC: 557EF7FE  rlwinm r30, r11, 0x1e, 0x1f, 0x1f
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 828FDFD0: 7FD3F378  mr r19, r30
	ctx.r[19].u64 = ctx.r[30].u64;
	// 828FDFD4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828FDFD8: 419A000C  beq cr6, 0x828fdfe4
	if ctx.cr[6].eq {
	pc = 0x828FDFE4; continue 'dispatch;
	}
	// 828FDFDC: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	// 828FDFE0: 48000150  b 0x828fe130
	pc = 0x828FE130; continue 'dispatch;
            }
            0x828FDFE4 => {
    //   block [0x828FDFE4..0x828FDFFC)
	// 828FDFE4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828FDFE8: 816B6CEC  lwz r11, 0x6cec(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27884 as u32) ) } as u64;
	// 828FDFEC: 7F175840  cmplw cr6, r23, r11
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828FDFF0: 409A000C  bne cr6, 0x828fdffc
	if !ctx.cr[6].eq {
	pc = 0x828FDFFC; continue 'dispatch;
	}
	// 828FDFF4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FDFF8: 48000138  b 0x828fe130
	pc = 0x828FE130; continue 'dispatch;
            }
            0x828FDFFC => {
    //   block [0x828FDFFC..0x828FE034)
	// 828FDFFC: 81740024  lwz r11, 0x24(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(36 as u32) ) } as u64;
	// 828FE000: 556AEFFE  rlwinm r10, r11, 0x1d, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 828FE004: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FE008: 419A00E8  beq cr6, 0x828fe0f0
	if ctx.cr[6].eq {
	pc = 0x828FE0F0; continue 'dispatch;
	}
	// 828FE00C: 8174008C  lwz r11, 0x8c(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(140 as u32) ) } as u64;
	// 828FE010: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FE014: 419A0020  beq cr6, 0x828fe034
	if ctx.cr[6].eq {
	pc = 0x828FE034; continue 'dispatch;
	}
	// 828FE018: 894B0003  lbz r10, 3(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 828FE01C: 81740048  lwz r11, 0x48(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(72 as u32) ) } as u64;
	// 828FE020: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828FE024: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828FE028: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828FE02C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FE030: 480000C8  b 0x828fe0f8
	pc = 0x828FE0F8; continue 'dispatch;
            }
            0x828FE034 => {
    //   block [0x828FE034..0x828FE050)
	// 828FE034: 81540048  lwz r10, 0x48(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(72 as u32) ) } as u64;
	// 828FE038: 80D4004C  lwz r6, 0x4c(r20)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(76 as u32) ) } as u64;
	// 828FE03C: 92A10058  stw r21, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[21].u32 ) };
	// 828FE040: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828FE044: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828FE048: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FE04C: 40810054  ble 0x828fe0a0
	if !ctx.cr[0].gt {
	pc = 0x828FE0A0; continue 'dispatch;
	}
	pc = 0x828FE050; continue 'dispatch;
            }
            0x828FE050 => {
    //   block [0x828FE050..0x828FE070)
	// 828FE050: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828FE054: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828FE058: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828FE05C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FE060: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 828FE064: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828FE068: 41980008  blt cr6, 0x828fe070
	if ctx.cr[6].lt {
	pc = 0x828FE070; continue 'dispatch;
	}
	// 828FE06C: 7EA7AB78  mr r7, r21
	ctx.r[7].u64 = ctx.r[21].u64;
	pc = 0x828FE070; continue 'dispatch;
            }
            0x828FE070 => {
    //   block [0x828FE070..0x828FE08C)
	// 828FE070: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828FE074: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828FE078: 419A0014  beq cr6, 0x828fe08c
	if ctx.cr[6].eq {
	pc = 0x828FE08C; continue 'dispatch;
	}
	// 828FE07C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828FE080: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828FE084: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828FE088: 4800000C  b 0x828fe094
	pc = 0x828FE094; continue 'dispatch;
            }
            0x828FE08C => {
    //   block [0x828FE08C..0x828FE094)
	// 828FE08C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828FE090: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828FE094; continue 'dispatch;
            }
            0x828FE094 => {
    //   block [0x828FE094..0x828FE0A0)
	// 828FE094: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FE098: 4199FFB8  bgt cr6, 0x828fe050
	if ctx.cr[6].gt {
	pc = 0x828FE050; continue 'dispatch;
	}
	// 828FE09C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x828FE0A0; continue 'dispatch;
            }
            0x828FE0A0 => {
    //   block [0x828FE0A0..0x828FE0BC)
	// 828FE0A0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828FE0A4: 419A003C  beq cr6, 0x828fe0e0
	if ctx.cr[6].eq {
	pc = 0x828FE0E0; continue 'dispatch;
	}
	// 828FE0A8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FE0AC: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 828FE0B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FE0B4: 41990008  bgt cr6, 0x828fe0bc
	if ctx.cr[6].gt {
	pc = 0x828FE0BC; continue 'dispatch;
	}
	// 828FE0B8: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	pc = 0x828FE0BC; continue 'dispatch;
            }
            0x828FE0BC => {
    //   block [0x828FE0BC..0x828FE0E0)
	// 828FE0BC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FE0C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FE0C4: 409A001C  bne cr6, 0x828fe0e0
	if !ctx.cr[6].eq {
	pc = 0x828FE0E0; continue 'dispatch;
	}
	// 828FE0C8: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828FE0CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828FE0D0: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 828FE0D4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828FE0D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FE0DC: 4800001C  b 0x828fe0f8
	pc = 0x828FE0F8; continue 'dispatch;
            }
            0x828FE0E0 => {
    //   block [0x828FE0E0..0x828FE0F0)
	// 828FE0E0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828FE0E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828FE0E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FE0EC: 4800000C  b 0x828fe0f8
	pc = 0x828FE0F8; continue 'dispatch;
            }
            0x828FE0F0 => {
    //   block [0x828FE0F0..0x828FE0F8)
	// 828FE0F0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828FE0F4: 7EAAAB78  mr r10, r21
	ctx.r[10].u64 = ctx.r[21].u64;
	pc = 0x828FE0F8; continue 'dispatch;
            }
            0x828FE0F8 => {
    //   block [0x828FE0F8..0x828FE128)
	// 828FE0F8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828FE0FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FE100: 419A0028  beq cr6, 0x828fe128
	if ctx.cr[6].eq {
	pc = 0x828FE128; continue 'dispatch;
	}
	// 828FE104: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 828FE108: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828FE10C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828FE110: C02A8EF0  lfs f1, -0x7110(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28944 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828FE114: 4B9161D5  bl 0x822142e8
	ctx.lr = 0x828FE118;
	sub_822142E8(ctx, base);
	// 828FE118: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828FE11C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FE120: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828FE124: 419A0008  beq cr6, 0x828fe12c
	if ctx.cr[6].eq {
	pc = 0x828FE12C; continue 'dispatch;
	}
	pc = 0x828FE128; continue 'dispatch;
            }
            0x828FE128 => {
    //   block [0x828FE128..0x828FE12C)
	// 828FE128: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	pc = 0x828FE12C; continue 'dispatch;
            }
            0x828FE12C => {
    //   block [0x828FE12C..0x828FE130)
	// 828FE12C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	pc = 0x828FE130; continue 'dispatch;
            }
            0x828FE130 => {
    //   block [0x828FE130..0x828FE19C)
	// 828FE130: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FE134: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FE138: 419A0064  beq cr6, 0x828fe19c
	if ctx.cr[6].eq {
	pc = 0x828FE19C; continue 'dispatch;
	}
	// 828FE13C: C0110008  lfs f0, 8(r17)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FE140: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FE144: C1B20008  lfs f13, 8(r18)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828FE148: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 828FE14C: C1710004  lfs f11, 4(r17)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828FE150: C1520004  lfs f10, 4(r18)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828FE154: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FE158: ED2B5028  fsubs f9, f11, f10
	ctx.f[9].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 828FE15C: C1110000  lfs f8, 0(r17)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 828FE160: C0F20000  lfs f7, 0(r18)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 828FE164: ECC83828  fsubs f6, f8, f7
	ctx.f[6].f64 = (((ctx.f[8].f64 - ctx.f[7].f64) as f32) as f64);
	// 828FE168: ECAC0332  fmuls f5, f12, f12
	ctx.f[5].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 828FE16C: EC892A7A  fmadds f4, f9, f9, f5
	ctx.f[4].f64 = (((ctx.f[9].f64 * ctx.f[9].f64 + ctx.f[5].f64) as f32) as f64);
	// 828FE170: EC6621BA  fmadds f3, f6, f6, f4
	ctx.f[3].f64 = (((ctx.f[6].f64 * ctx.f[6].f64 + ctx.f[4].f64) as f32) as f64);
	// 828FE174: EC40182C  fsqrts f2, f3
	ctx.f[2].f64 = ((ctx.f[3].f64).sqrt() as f32) as f64;
	// 828FE178: D0500000  stfs f2, 0(r16)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[16].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828FE17C: 419AFDDC  beq cr6, 0x828fdf58
	if ctx.cr[6].eq {
	pc = 0x828FDF58; continue 'dispatch;
	}
	// 828FE180: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FE184: 489BB7D1  bl 0x832b9954
	ctx.lr = 0x828FE188;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 828FE188: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828FE18C: 382101E0  addi r1, r1, 0x1e0
	ctx.r[1].s64 = ctx.r[1].s64 + 480;
	// 828FE190: 3981FF78  addi r12, r1, -0x88
	ctx.r[12].s64 = ctx.r[1].s64 + -136;
	// 828FE194: 483AFB75  bl 0x82cadd08
	ctx.lr = 0x828FE198;
	sub_82CADCEC(ctx, base);
	// 828FE198: 483AB290  b 0x82ca9428
	sub_82CA9420(ctx, base);
	return;
            }
            0x828FE19C => {
    //   block [0x828FE19C..0x828FE1EC)
	// 828FE19C: 80980004  lwz r4, 4(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FE1A0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828FE1A4: 419A0C9C  beq cr6, 0x828fee40
	if ctx.cr[6].eq {
	pc = 0x828FEE40; continue 'dispatch;
	}
	// 828FE1A8: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FE1AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FE1B0: 409A003C  bne cr6, 0x828fe1ec
	if !ctx.cr[6].eq {
	pc = 0x828FE1EC; continue 'dispatch;
	}
	// 828FE1B4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828FE1B8: 89010054  lbz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FE1BC: 392B92D4  addi r9, r11, -0x6d2c
	ctx.r[9].s64 = ctx.r[11].s64 + -27948;
	// 828FE1C0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828FE1C4: C00901BC  lfs f0, 0x1bc(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(444 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FE1C8: D0100000  stfs f0, 0(r16)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[16].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828FE1CC: 419AFD8C  beq cr6, 0x828fdf58
	if ctx.cr[6].eq {
	pc = 0x828FDF58; continue 'dispatch;
	}
	// 828FE1D0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FE1D4: 489BB781  bl 0x832b9954
	ctx.lr = 0x828FE1D8;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 828FE1D8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828FE1DC: 382101E0  addi r1, r1, 0x1e0
	ctx.r[1].s64 = ctx.r[1].s64 + 480;
	// 828FE1E0: 3981FF78  addi r12, r1, -0x88
	ctx.r[12].s64 = ctx.r[1].s64 + -136;
	// 828FE1E4: 483AFB25  bl 0x82cadd08
	ctx.lr = 0x828FE1E8;
	sub_82CADCEC(ctx, base);
	// 828FE1E8: 483AB240  b 0x82ca9428
	sub_82CA9420(ctx, base);
	return;
            }
            0x828FE1EC => {
    //   block [0x828FE1EC..0x828FE26C)
	// 828FE1EC: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 828FE1F0: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 828FE1F4: 4BD2CC3D  bl 0x8262ae30
	ctx.lr = 0x828FE1F8;
	sub_8262AE30(ctx, base);
	// 828FE1F8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828FE1FC: 7E258B78  mr r5, r17
	ctx.r[5].u64 = ctx.r[17].u64;
	// 828FE200: 80980004  lwz r4, 4(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FE204: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 828FE208: 4BD2CC29  bl 0x8262ae30
	ctx.lr = 0x828FE20C;
	sub_8262AE30(ctx, base);
	// 828FE20C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828FE210: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828FE214: 419AFD60  beq cr6, 0x828fdf74
	if ctx.cr[6].eq {
	pc = 0x828FDF74; continue 'dispatch;
	}
	// 828FE218: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828FE21C: 419AFD58  beq cr6, 0x828fdf74
	if ctx.cr[6].eq {
	pc = 0x828FDF74; continue 'dispatch;
	}
	// 828FE220: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828FE224: 81540028  lwz r10, 0x28(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(40 as u32) ) } as u64;
	// 828FE228: 7EBAAB78  mr r26, r21
	ctx.r[26].u64 = ctx.r[21].u64;
	// 828FE22C: 3ACB92D4  addi r22, r11, -0x6d2c
	ctx.r[22].s64 = ctx.r[11].s64 + -27948;
	// 828FE230: 554927FE  rlwinm r9, r10, 4, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0FFFFFFFu64;
	// 828FE234: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828FE238: C2D601BC  lfs f22, 0x1bc(r22)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(444 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 828FE23C: 419A00F4  beq cr6, 0x828fe330
	if ctx.cr[6].eq {
	pc = 0x828FE330; continue 'dispatch;
	}
	// 828FE240: 8174008C  lwz r11, 0x8c(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(140 as u32) ) } as u64;
	// 828FE244: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FE248: 419A0024  beq cr6, 0x828fe26c
	if ctx.cr[6].eq {
	pc = 0x828FE26C; continue 'dispatch;
	}
	// 828FE24C: 894B003C  lbz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 828FE250: 81740048  lwz r11, 0x48(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(72 as u32) ) } as u64;
	// 828FE254: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828FE258: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828FE25C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FE260: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 828FE264: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FE268: 480000CC  b 0x828fe334
	pc = 0x828FE334; continue 'dispatch;
            }
            0x828FE26C => {
    //   block [0x828FE26C..0x828FE288)
	// 828FE26C: 81540048  lwz r10, 0x48(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(72 as u32) ) } as u64;
	// 828FE270: 80D4004C  lwz r6, 0x4c(r20)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(76 as u32) ) } as u64;
	// 828FE274: 92A10058  stw r21, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[21].u32 ) };
	// 828FE278: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828FE27C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828FE280: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FE284: 40810054  ble 0x828fe2d8
	if !ctx.cr[0].gt {
	pc = 0x828FE2D8; continue 'dispatch;
	}
	pc = 0x828FE288; continue 'dispatch;
            }
            0x828FE288 => {
    //   block [0x828FE288..0x828FE2A8)
	// 828FE288: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828FE28C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828FE290: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828FE294: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FE298: 2F07003C  cmpwi cr6, r7, 0x3c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 60, &mut ctx.xer);
	// 828FE29C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828FE2A0: 41980008  blt cr6, 0x828fe2a8
	if ctx.cr[6].lt {
	pc = 0x828FE2A8; continue 'dispatch;
	}
	// 828FE2A4: 7EA7AB78  mr r7, r21
	ctx.r[7].u64 = ctx.r[21].u64;
	pc = 0x828FE2A8; continue 'dispatch;
            }
            0x828FE2A8 => {
    //   block [0x828FE2A8..0x828FE2C4)
	// 828FE2A8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828FE2AC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828FE2B0: 419A0014  beq cr6, 0x828fe2c4
	if ctx.cr[6].eq {
	pc = 0x828FE2C4; continue 'dispatch;
	}
	// 828FE2B4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828FE2B8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828FE2BC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828FE2C0: 4800000C  b 0x828fe2cc
	pc = 0x828FE2CC; continue 'dispatch;
            }
            0x828FE2C4 => {
    //   block [0x828FE2C4..0x828FE2CC)
	// 828FE2C4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828FE2C8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828FE2CC; continue 'dispatch;
            }
            0x828FE2CC => {
    //   block [0x828FE2CC..0x828FE2D8)
	// 828FE2CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FE2D0: 4199FFB8  bgt cr6, 0x828fe288
	if ctx.cr[6].gt {
	pc = 0x828FE288; continue 'dispatch;
	}
	// 828FE2D4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x828FE2D8; continue 'dispatch;
            }
            0x828FE2D8 => {
    //   block [0x828FE2D8..0x828FE2F4)
	// 828FE2D8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828FE2DC: 419A0040  beq cr6, 0x828fe31c
	if ctx.cr[6].eq {
	pc = 0x828FE31C; continue 'dispatch;
	}
	// 828FE2E0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FE2E4: 2F0B003C  cmpwi cr6, r11, 0x3c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 60, &mut ctx.xer);
	// 828FE2E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FE2EC: 41990008  bgt cr6, 0x828fe2f4
	if ctx.cr[6].gt {
	pc = 0x828FE2F4; continue 'dispatch;
	}
	// 828FE2F0: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	pc = 0x828FE2F4; continue 'dispatch;
            }
            0x828FE2F4 => {
    //   block [0x828FE2F4..0x828FE31C)
	// 828FE2F4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FE2F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FE2FC: 409A0020  bne cr6, 0x828fe31c
	if !ctx.cr[6].eq {
	pc = 0x828FE31C; continue 'dispatch;
	}
	// 828FE300: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828FE304: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 828FE308: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828FE30C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FE310: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 828FE314: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FE318: 4800001C  b 0x828fe334
	pc = 0x828FE334; continue 'dispatch;
            }
            0x828FE31C => {
    //   block [0x828FE31C..0x828FE330)
	// 828FE31C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828FE320: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FE324: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 828FE328: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FE32C: 48000008  b 0x828fe334
	pc = 0x828FE334; continue 'dispatch;
            }
            0x828FE330 => {
    //   block [0x828FE330..0x828FE334)
	// 828FE330: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	pc = 0x828FE334; continue 'dispatch;
            }
            0x828FE334 => {
    //   block [0x828FE334..0x828FE370)
	// 828FE334: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FE338: 3F208349  lis r25, -0x7cb7
	ctx.r[25].s64 = -2092367872;
	// 828FE33C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FE340: 419A024C  beq cr6, 0x828fe58c
	if ctx.cr[6].eq {
	pc = 0x828FE58C; continue 'dispatch;
	}
	// 828FE344: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FE348: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FE34C: 409A0038  bne cr6, 0x828fe384
	if !ctx.cr[6].eq {
	pc = 0x828FE384; continue 'dispatch;
	}
	// 828FE350: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FE354: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FE358: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 828FE35C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828FE360: 40980010  bge cr6, 0x828fe370
	if !ctx.cr[6].lt {
	pc = 0x828FE370; continue 'dispatch;
	}
	// 828FE364: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828FE368: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828FE36C: 48000008  b 0x828fe374
	pc = 0x828FE374; continue 'dispatch;
            }
            0x828FE370 => {
    //   block [0x828FE370..0x828FE374)
	// 828FE370: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x828FE374; continue 'dispatch;
            }
            0x828FE374 => {
    //   block [0x828FE374..0x828FE384)
	// 828FE374: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FE378: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FE37C: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	// 828FE380: 419A0008  beq cr6, 0x828fe388
	if ctx.cr[6].eq {
	pc = 0x828FE388; continue 'dispatch;
	}
	pc = 0x828FE384; continue 'dispatch;
            }
            0x828FE384 => {
    //   block [0x828FE384..0x828FE388)
	// 828FE384: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x828FE388; continue 'dispatch;
            }
            0x828FE388 => {
    //   block [0x828FE388..0x828FE3A4)
	// 828FE388: 81580008  lwz r10, 8(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FE38C: 812A0018  lwz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 828FE390: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828FE394: 40980010  bge cr6, 0x828fe3a4
	if !ctx.cr[6].lt {
	pc = 0x828FE3A4; continue 'dispatch;
	}
	// 828FE398: 814A0024  lwz r10, 0x24(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 828FE39C: 7D6A58AE  lbzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828FE3A0: 48000008  b 0x828fe3a8
	pc = 0x828FE3A8; continue 'dispatch;
            }
            0x828FE3A4 => {
    //   block [0x828FE3A4..0x828FE3A8)
	// 828FE3A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x828FE3A8; continue 'dispatch;
            }
            0x828FE3A8 => {
    //   block [0x828FE3A8..0x828FE434)
	// 828FE3A8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FE3AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FE3B0: 419A01C8  beq cr6, 0x828fe578
	if ctx.cr[6].eq {
	pc = 0x828FE578; continue 'dispatch;
	}
	// 828FE3B4: 897A00B9  lbz r11, 0xb9(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(185 as u32) ) } as u64;
	// 828FE3B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FE3BC: 409A0078  bne cr6, 0x828fe434
	if !ctx.cr[6].eq {
	pc = 0x828FE434; continue 'dispatch;
	}
	// 828FE3C0: 897A0285  lbz r11, 0x285(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(645 as u32) ) } as u64;
	// 828FE3C4: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FE3C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FE3CC: 419AFBAC  beq cr6, 0x828fdf78
	if ctx.cr[6].eq {
	pc = 0x828FDF78; continue 'dispatch;
	}
	// 828FE3D0: C0110000  lfs f0, 0(r17)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FE3D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FE3D8: C1B20000  lfs f13, 0(r18)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828FE3DC: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 828FE3E0: C1710004  lfs f11, 4(r17)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828FE3E4: C1520004  lfs f10, 4(r18)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828FE3E8: ED2B5028  fsubs f9, f11, f10
	ctx.f[9].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 828FE3EC: C1110008  lfs f8, 8(r17)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 828FE3F0: C0F20008  lfs f7, 8(r18)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 828FE3F4: ECC83828  fsubs f6, f8, f7
	ctx.f[6].f64 = (((ctx.f[8].f64 - ctx.f[7].f64) as f32) as f64);
	// 828FE3F8: C0162994  lfs f0, 0x2994(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(10644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FE3FC: ECAC0332  fmuls f5, f12, f12
	ctx.f[5].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 828FE400: EC892A7A  fmadds f4, f9, f9, f5
	ctx.f[4].f64 = (((ctx.f[9].f64 * ctx.f[9].f64 + ctx.f[5].f64) as f32) as f64);
	// 828FE404: EC6621BA  fmadds f3, f6, f6, f4
	ctx.f[3].f64 = (((ctx.f[6].f64 * ctx.f[6].f64 + ctx.f[4].f64) as f32) as f64);
	// 828FE408: EC40182C  fsqrts f2, f3
	ctx.f[2].f64 = ((ctx.f[3].f64).sqrt() as f32) as f64;
	// 828FE40C: EC220032  fmuls f1, f2, f0
	ctx.f[1].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 828FE410: D0300000  stfs f1, 0(r16)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[16].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828FE414: 419AFB44  beq cr6, 0x828fdf58
	if ctx.cr[6].eq {
	pc = 0x828FDF58; continue 'dispatch;
	}
	// 828FE418: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FE41C: 489BB539  bl 0x832b9954
	ctx.lr = 0x828FE420;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 828FE420: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828FE424: 382101E0  addi r1, r1, 0x1e0
	ctx.r[1].s64 = ctx.r[1].s64 + 480;
	// 828FE428: 3981FF78  addi r12, r1, -0x88
	ctx.r[12].s64 = ctx.r[1].s64 + -136;
	// 828FE42C: 483AF8DD  bl 0x82cadd08
	ctx.lr = 0x828FE430;
	sub_82CADCEC(ctx, base);
	// 828FE430: 483AAFF8  b 0x82ca9428
	sub_82CA9420(ctx, base);
	return;
            }
            0x828FE434 => {
    //   block [0x828FE434..0x828FE494)
	// 828FE434: 7EBFAB78  mr r31, r21
	ctx.r[31].u64 = ctx.r[21].u64;
	// 828FE438: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 828FE43C: 419A013C  beq cr6, 0x828fe578
	if ctx.cr[6].eq {
	pc = 0x828FE578; continue 'dispatch;
	}
	// 828FE440: 81796AB8  lwz r11, 0x6ab8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828FE444: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FE448: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828FE44C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FE450: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FE454: 4B92DD65  bl 0x8222c1b8
	ctx.lr = 0x828FE458;
	sub_8222C1B8(ctx, base);
	// 828FE458: 81030034  lwz r8, 0x34(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 828FE45C: 5507BFFE  rlwinm r7, r8, 0x17, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x000001FFu64;
	// 828FE460: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828FE464: 419A00F4  beq cr6, 0x828fe558
	if ctx.cr[6].eq {
	pc = 0x828FE558; continue 'dispatch;
	}
	// 828FE468: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828FE46C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FE470: 419A0024  beq cr6, 0x828fe494
	if ctx.cr[6].eq {
	pc = 0x828FE494; continue 'dispatch;
	}
	// 828FE474: 894B0089  lbz r10, 0x89(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(137 as u32) ) } as u64;
	// 828FE478: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828FE47C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828FE480: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828FE484: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FE488: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828FE48C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FE490: 480000CC  b 0x828fe55c
	pc = 0x828FE55C; continue 'dispatch;
            }
            0x828FE494 => {
    //   block [0x828FE494..0x828FE4B0)
	// 828FE494: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828FE498: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828FE49C: 92A10058  stw r21, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[21].u32 ) };
	// 828FE4A0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828FE4A4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 828FE4A8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FE4AC: 40810054  ble 0x828fe500
	if !ctx.cr[0].gt {
	pc = 0x828FE500; continue 'dispatch;
	}
	pc = 0x828FE4B0; continue 'dispatch;
            }
            0x828FE4B0 => {
    //   block [0x828FE4B0..0x828FE4D0)
	// 828FE4B0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828FE4B4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828FE4B8: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828FE4BC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FE4C0: 2F070089  cmpwi cr6, r7, 0x89
	ctx.cr[6].compare_i32(ctx.r[7].s32, 137, &mut ctx.xer);
	// 828FE4C4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828FE4C8: 41980008  blt cr6, 0x828fe4d0
	if ctx.cr[6].lt {
	pc = 0x828FE4D0; continue 'dispatch;
	}
	// 828FE4CC: 7EA7AB78  mr r7, r21
	ctx.r[7].u64 = ctx.r[21].u64;
	pc = 0x828FE4D0; continue 'dispatch;
            }
            0x828FE4D0 => {
    //   block [0x828FE4D0..0x828FE4EC)
	// 828FE4D0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828FE4D4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828FE4D8: 419A0014  beq cr6, 0x828fe4ec
	if ctx.cr[6].eq {
	pc = 0x828FE4EC; continue 'dispatch;
	}
	// 828FE4DC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828FE4E0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828FE4E4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828FE4E8: 4800000C  b 0x828fe4f4
	pc = 0x828FE4F4; continue 'dispatch;
            }
            0x828FE4EC => {
    //   block [0x828FE4EC..0x828FE4F4)
	// 828FE4EC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828FE4F0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828FE4F4; continue 'dispatch;
            }
            0x828FE4F4 => {
    //   block [0x828FE4F4..0x828FE500)
	// 828FE4F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FE4F8: 4199FFB8  bgt cr6, 0x828fe4b0
	if ctx.cr[6].gt {
	pc = 0x828FE4B0; continue 'dispatch;
	}
	// 828FE4FC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x828FE500; continue 'dispatch;
            }
            0x828FE500 => {
    //   block [0x828FE500..0x828FE51C)
	// 828FE500: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828FE504: 419A0040  beq cr6, 0x828fe544
	if ctx.cr[6].eq {
	pc = 0x828FE544; continue 'dispatch;
	}
	// 828FE508: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FE50C: 2F0B0089  cmpwi cr6, r11, 0x89
	ctx.cr[6].compare_i32(ctx.r[11].s32, 137, &mut ctx.xer);
	// 828FE510: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FE514: 41990008  bgt cr6, 0x828fe51c
	if ctx.cr[6].gt {
	pc = 0x828FE51C; continue 'dispatch;
	}
	// 828FE518: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	pc = 0x828FE51C; continue 'dispatch;
            }
            0x828FE51C => {
    //   block [0x828FE51C..0x828FE544)
	// 828FE51C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FE520: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FE524: 409A0020  bne cr6, 0x828fe544
	if !ctx.cr[6].eq {
	pc = 0x828FE544; continue 'dispatch;
	}
	// 828FE528: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828FE52C: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 828FE530: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828FE534: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FE538: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828FE53C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FE540: 4800001C  b 0x828fe55c
	pc = 0x828FE55C; continue 'dispatch;
            }
            0x828FE544 => {
    //   block [0x828FE544..0x828FE558)
	// 828FE544: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828FE548: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FE54C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828FE550: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FE554: 48000008  b 0x828fe55c
	pc = 0x828FE55C; continue 'dispatch;
            }
            0x828FE558 => {
    //   block [0x828FE558..0x828FE55C)
	// 828FE558: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	pc = 0x828FE55C; continue 'dispatch;
            }
            0x828FE55C => {
    //   block [0x828FE55C..0x828FE578)
	// 828FE55C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FE560: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FE564: 419A0014  beq cr6, 0x828fe578
	if ctx.cr[6].eq {
	pc = 0x828FE578; continue 'dispatch;
	}
	// 828FE568: 897F0049  lbz r11, 0x49(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(73 as u32) ) } as u64;
	// 828FE56C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FE570: 409A0008  bne cr6, 0x828fe578
	if !ctx.cr[6].eq {
	pc = 0x828FE578; continue 'dispatch;
	}
	// 828FE574: C2D621AC  lfs f22, 0x21ac(r22)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8620 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	pc = 0x828FE578; continue 'dispatch;
            }
            0x828FE578 => {
    //   block [0x828FE578..0x828FE58C)
	// 828FE578: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828FE57C: 4BD6768D  bl 0x82665c08
	ctx.lr = 0x828FE580;
	sub_82665C08(ctx, base);
	// 828FE580: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828FE584: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FE588: 409AF984  bne cr6, 0x828fdf0c
	if !ctx.cr[6].eq {
	pc = 0x828FDF0C; continue 'dispatch;
	}
	pc = 0x828FE58C; continue 'dispatch;
            }
            0x828FE58C => {
    //   block [0x828FE58C..0x828FE5D4)
	// 828FE58C: 80BB0000  lwz r5, 0(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FE590: C2B601B0  lfs f21, 0x1b0(r22)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(432 as u32) ) };
	ctx.f[21].f64 = (tmp.f32 as f64);
	// 828FE594: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FE598: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 828FE59C: 409A005C  bne cr6, 0x828fe5f8
	if !ctx.cr[6].eq {
	pc = 0x828FE5F8; continue 'dispatch;
	}
	// 828FE5A0: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FE5A4: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 828FE5A8: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 828FE5AC: 419A0028  beq cr6, 0x828fe5d4
	if ctx.cr[6].eq {
	pc = 0x828FE5D4; continue 'dispatch;
	}
	// 828FE5B0: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FE5B4: 409800B0  bge cr6, 0x828fe664
	if !ctx.cr[6].lt {
	pc = 0x828FE664; continue 'dispatch;
	}
	// 828FE5B8: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828FE5BC: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828FE5C0: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 828FE5C4: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828FE5C8: 480008B1  bl 0x828fee78
	ctx.lr = 0x828FE5CC;
	sub_828FEE78(ctx, base);
	// 828FE5CC: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828FE5D0: 480007EC  b 0x828fedbc
	pc = 0x828FEDBC; continue 'dispatch;
            }
            0x828FE5D4 => {
    //   block [0x828FE5D4..0x828FE5F8)
	// 828FE5D4: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FE5D8: 4098008C  bge cr6, 0x828fe664
	if !ctx.cr[6].lt {
	pc = 0x828FE664; continue 'dispatch;
	}
	// 828FE5DC: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 828FE5E0: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828FE5E4: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 828FE5E8: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828FE5EC: 4800088D  bl 0x828fee78
	ctx.lr = 0x828FE5F0;
	sub_828FEE78(ctx, base);
	// 828FE5F0: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828FE5F4: 480007C8  b 0x828fedbc
	pc = 0x828FEDBC; continue 'dispatch;
            }
            0x828FE5F8 => {
    //   block [0x828FE5F8..0x828FE640)
	// 828FE5F8: 80780004  lwz r3, 4(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FE5FC: 48592755  bl 0x82e90d50
	ctx.lr = 0x828FE600;
	sub_82E90D50(ctx, base);
	// 828FE600: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FE604: 419A0074  beq cr6, 0x828fe678
	if ctx.cr[6].eq {
	pc = 0x828FE678; continue 'dispatch;
	}
	// 828FE608: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FE60C: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 828FE610: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FE614: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FE618: 419A0028  beq cr6, 0x828fe640
	if ctx.cr[6].eq {
	pc = 0x828FE640; continue 'dispatch;
	}
	// 828FE61C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828FE620: 40980044  bge cr6, 0x828fe664
	if !ctx.cr[6].lt {
	pc = 0x828FE664; continue 'dispatch;
	}
	// 828FE624: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828FE628: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828FE62C: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 828FE630: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828FE634: 48000845  bl 0x828fee78
	ctx.lr = 0x828FE638;
	sub_828FEE78(ctx, base);
	// 828FE638: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828FE63C: 48000780  b 0x828fedbc
	pc = 0x828FEDBC; continue 'dispatch;
            }
            0x828FE640 => {
    //   block [0x828FE640..0x828FE664)
	// 828FE640: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828FE644: 40980020  bge cr6, 0x828fe664
	if !ctx.cr[6].lt {
	pc = 0x828FE664; continue 'dispatch;
	}
	// 828FE648: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FE64C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828FE650: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 828FE654: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828FE658: 48000821  bl 0x828fee78
	ctx.lr = 0x828FE65C;
	sub_828FEE78(ctx, base);
	// 828FE65C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828FE660: 4800075C  b 0x828fedbc
	pc = 0x828FEDBC; continue 'dispatch;
            }
            0x828FE664 => {
    //   block [0x828FE664..0x828FE678)
	// 828FE664: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 828FE668: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 828FE66C: 4800080D  bl 0x828fee78
	ctx.lr = 0x828FE670;
	sub_828FEE78(ctx, base);
	// 828FE670: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828FE674: 48000748  b 0x828fedbc
	pc = 0x828FEDBC; continue 'dispatch;
            }
            0x828FE678 => {
    //   block [0x828FE678..0x828FE6A4)
	// 828FE678: 80780008  lwz r3, 8(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FE67C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FE680: 419A0024  beq cr6, 0x828fe6a4
	if ctx.cr[6].eq {
	pc = 0x828FE6A4; continue 'dispatch;
	}
	// 828FE684: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 828FE688: 38BB0004  addi r5, r27, 4
	ctx.r[5].s64 = ctx.r[27].s64 + 4;
	// 828FE68C: 389D0004  addi r4, r29, 4
	ctx.r[4].s64 = ctx.r[29].s64 + 4;
	// 828FE690: 4BFFEFD9  bl 0x828fd668
	ctx.lr = 0x828FE694;
	sub_828FD668(ctx, base);
	// 828FE694: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 828FE698: 48000921  bl 0x828fefb8
	ctx.lr = 0x828FE69C;
	sub_828FEFB8(ctx, base);
	// 828FE69C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828FE6A0: 4800071C  b 0x828fedbc
	pc = 0x828FEDBC; continue 'dispatch;
            }
            0x828FE6A4 => {
    //   block [0x828FE6A4..0x828FE6BC)
	// 828FE6A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FE6A8: FF00A890  fmr f24, f21
	ctx.f[24].f64 = ctx.f[21].f64;
	// 828FE6AC: 4BA224DD  bl 0x82320b88
	ctx.lr = 0x828FE6B0;
	sub_82320B88(ctx, base);
	// 828FE6B0: C2F62994  lfs f23, 0x2994(r22)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(10644 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 828FE6B4: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828FE6B8: 419A0488  beq cr6, 0x828feb40
	if ctx.cr[6].eq {
	pc = 0x828FEB40; continue 'dispatch;
	}
	pc = 0x828FE6BC; continue 'dispatch;
            }
            0x828FE6BC => {
    //   block [0x828FE6BC..0x828FE7CC)
	// 828FE6BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FE6C0: 4BD26141  bl 0x82624800
	ctx.lr = 0x828FE6C4;
	sub_82624800(ctx, base);
	// 828FE6C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FE6C8: 419A0474  beq cr6, 0x828feb3c
	if ctx.cr[6].eq {
	pc = 0x828FEB3C; continue 'dispatch;
	}
	// 828FE6CC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828FE6D0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FE6D4: 4BD165F5  bl 0x82614cc8
	ctx.lr = 0x828FE6D8;
	sub_82614CC8(ctx, base);
	// 828FE6D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828FE6DC: C01B0004  lfs f0, 4(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FE6E0: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 828FE6E4: C1BB0008  lfs f13, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828FE6E8: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 828FE6EC: C19B000C  lfs f12, 0xc(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828FE6F0: 3BFD0004  addi r31, r29, 4
	ctx.r[31].s64 = ctx.r[29].s64 + 4;
	// 828FE6F4: C17D0004  lfs f11, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828FE6F8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FE6FC: C15D0008  lfs f10, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828FE700: C13D000C  lfs f9, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 828FE704: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FE708: ED005828  fsubs f8, f0, f11
	ctx.f[8].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 828FE70C: D10100B0  stfs f8, 0xb0(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 828FE710: ECED5028  fsubs f7, f13, f10
	ctx.f[7].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 828FE714: D0E100B4  stfs f7, 0xb4(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 828FE718: ECCC4828  fsubs f6, f12, f9
	ctx.f[6].f64 = (((ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 828FE71C: D0C100B8  stfs f6, 0xb8(r1)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 828FE720: 810A003C  lwz r8, 0x3c(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) } as u64;
	// 828FE724: 5527103A  slwi r7, r9, 2
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 828FE728: 812A0018  lwz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 828FE72C: 7D67402E  lwzx r11, r7, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 828FE730: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828FE734: 7CCB5214  add r6, r11, r10
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828FE738: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828FE73C: 7F8B4A14  add r28, r11, r9
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 828FE740: 4B980B29  bl 0x8227f268
	ctx.lr = 0x828FE744;
	sub_8227F268(ctx, base);
	// 828FE744: C0BC0004  lfs f5, 4(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 828FE748: C09D0004  lfs f4, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 828FE74C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828FE750: C07C0008  lfs f3, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 828FE754: EC452028  fsubs f2, f5, f4
	ctx.f[2].f64 = (((ctx.f[5].f64 - ctx.f[4].f64) as f32) as f64);
	// 828FE758: C03D0008  lfs f1, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828FE75C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 828FE760: C01C000C  lfs f0, 0xc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FE764: EDA30828  fsubs f13, f3, f1
	ctx.f[13].f64 = (((ctx.f[3].f64 - ctx.f[1].f64) as f32) as f64);
	// 828FE768: C19D000C  lfs f12, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828FE76C: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 828FE770: ED606028  fsubs f11, f0, f12
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 828FE774: D0410080  stfs f2, 0x80(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 828FE778: D1A10084  stfs f13, 0x84(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 828FE77C: D1610088  stfs f11, 0x88(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 828FE780: C3C50000  lfs f30, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828FE784: C3A50004  lfs f29, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828FE788: C3850008  lfs f28, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 828FE78C: 4B980ADD  bl 0x8227f268
	ctx.lr = 0x828FE790;
	sub_8227F268(ctx, base);
	// 828FE790: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FE794: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FE798: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 828FE79C: C1440008  lfs f10, 8(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828FE7A0: ED2A0732  fmuls f9, f10, f28
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[28].f64) as f32) as f64);
	// 828FE7A4: C1040000  lfs f8, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 828FE7A8: C0E40004  lfs f7, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 828FE7AC: ECC84FBA  fmadds f6, f8, f30, f9
	ctx.f[6].f64 = (((ctx.f[8].f64 * ctx.f[30].f64 + ctx.f[9].f64) as f32) as f64);
	// 828FE7B0: EFE7377A  fmadds f31, f7, f29, f6
	ctx.f[31].f64 = (((ctx.f[7].f64 * ctx.f[29].f64 + ctx.f[6].f64) as f32) as f64);
	// 828FE7B4: 4BD2604D  bl 0x82624800
	ctx.lr = 0x828FE7B8;
	sub_82624800(ctx, base);
	// 828FE7B8: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 828FE7BC: 409900B4  ble cr6, 0x828fe870
	if !ctx.cr[6].gt {
	pc = 0x828FE870; continue 'dispatch;
	}
	// 828FE7C0: C37F0000  lfs f27, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 828FE7C4: C35F0004  lfs f26, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 828FE7C8: C33F0008  lfs f25, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	pc = 0x828FE7CC; continue 'dispatch;
            }
            0x828FE7CC => {
    //   block [0x828FE7CC..0x828FE85C)
	// 828FE7CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FE7D0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FE7D4: 4BD164F5  bl 0x82614cc8
	ctx.lr = 0x828FE7D8;
	sub_82614CC8(ctx, base);
	// 828FE7D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828FE7DC: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 828FE7E0: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 828FE7E4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FE7E8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FE7EC: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828FE7F0: 80EA003C  lwz r7, 0x3c(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) } as u64;
	// 828FE7F4: 812A0018  lwz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 828FE7F8: 7D67402E  lwzx r11, r7, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 828FE7FC: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828FE800: 7CCB5214  add r6, r11, r10
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828FE804: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828FE808: 7FEB4A14  add r31, r11, r9
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 828FE80C: C01F0004  lfs f0, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FE810: C1BF0008  lfs f13, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828FE814: ED80D828  fsubs f12, f0, f27
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[27].f64) as f32) as f64);
	// 828FE818: C17F000C  lfs f11, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828FE81C: ED4DD028  fsubs f10, f13, f26
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[26].f64) as f32) as f64);
	// 828FE820: ED2BC828  fsubs f9, f11, f25
	ctx.f[9].f64 = (((ctx.f[11].f64 - ctx.f[25].f64) as f32) as f64);
	// 828FE824: D1810080  stfs f12, 0x80(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 828FE828: D1410084  stfs f10, 0x84(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 828FE82C: D1210088  stfs f9, 0x88(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 828FE830: 4B980A39  bl 0x8227f268
	ctx.lr = 0x828FE834;
	sub_8227F268(ctx, base);
	// 828FE834: C1030008  lfs f8, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 828FE838: ECE80732  fmuls f7, f8, f28
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[28].f64) as f32) as f64);
	// 828FE83C: C0C30000  lfs f6, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 828FE840: C0A30004  lfs f5, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 828FE844: EC863FBA  fmadds f4, f6, f30, f7
	ctx.f[4].f64 = (((ctx.f[6].f64 * ctx.f[30].f64 + ctx.f[7].f64) as f32) as f64);
	// 828FE848: EC05277A  fmadds f0, f5, f29, f4
	ctx.f[0].f64 = (((ctx.f[5].f64 * ctx.f[29].f64 + ctx.f[4].f64) as f32) as f64);
	// 828FE84C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 828FE850: 4099000C  ble cr6, 0x828fe85c
	if !ctx.cr[6].gt {
	pc = 0x828FE85C; continue 'dispatch;
	}
	// 828FE854: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828FE858: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	pc = 0x828FE85C; continue 'dispatch;
            }
            0x828FE85C => {
    //   block [0x828FE85C..0x828FE870)
	// 828FE85C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FE860: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828FE864: 4BD25F9D  bl 0x82624800
	ctx.lr = 0x828FE868;
	sub_82624800(ctx, base);
	// 828FE868: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 828FE86C: 4198FF60  blt cr6, 0x828fe7cc
	if ctx.cr[6].lt {
	pc = 0x828FE7CC; continue 'dispatch;
	}
	pc = 0x828FE870; continue 'dispatch;
            }
            0x828FE870 => {
    //   block [0x828FE870..0x828FE894)
	// 828FE870: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FE874: C3F601BC  lfs f31, 0x1bc(r22)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(444 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828FE878: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FE87C: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 828FE880: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828FE884: 40980010  bge cr6, 0x828fe894
	if !ctx.cr[6].lt {
	pc = 0x828FE894; continue 'dispatch;
	}
	// 828FE888: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828FE88C: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828FE890: 48000008  b 0x828fe898
	pc = 0x828FE898; continue 'dispatch;
            }
            0x828FE894 => {
    //   block [0x828FE894..0x828FE898)
	// 828FE894: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x828FE898; continue 'dispatch;
            }
            0x828FE898 => {
    //   block [0x828FE898..0x828FE8C0)
	// 828FE898: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FE89C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FE8A0: 419A0164  beq cr6, 0x828fea04
	if ctx.cr[6].eq {
	pc = 0x828FEA04; continue 'dispatch;
	}
	// 828FE8A4: 897A00B9  lbz r11, 0xb9(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(185 as u32) ) } as u64;
	// 828FE8A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FE8AC: 409A0014  bne cr6, 0x828fe8c0
	if !ctx.cr[6].eq {
	pc = 0x828FE8C0; continue 'dispatch;
	}
	// 828FE8B0: 897A0285  lbz r11, 0x285(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(645 as u32) ) } as u64;
	// 828FE8B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FE8B8: 419A0264  beq cr6, 0x828feb1c
	if ctx.cr[6].eq {
	pc = 0x828FEB1C; continue 'dispatch;
	}
	// 828FE8BC: FFE0B890  fmr f31, f23
	ctx.f[31].f64 = ctx.f[23].f64;
	pc = 0x828FE8C0; continue 'dispatch;
            }
            0x828FE8C0 => {
    //   block [0x828FE8C0..0x828FE920)
	// 828FE8C0: 7EBFAB78  mr r31, r21
	ctx.r[31].u64 = ctx.r[21].u64;
	// 828FE8C4: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 828FE8C8: 419A013C  beq cr6, 0x828fea04
	if ctx.cr[6].eq {
	pc = 0x828FEA04; continue 'dispatch;
	}
	// 828FE8CC: 81796AB8  lwz r11, 0x6ab8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828FE8D0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FE8D4: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828FE8D8: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FE8DC: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FE8E0: 4B92D8D9  bl 0x8222c1b8
	ctx.lr = 0x828FE8E4;
	sub_8222C1B8(ctx, base);
	// 828FE8E4: 81030034  lwz r8, 0x34(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 828FE8E8: 5507BFFE  rlwinm r7, r8, 0x17, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x000001FFu64;
	// 828FE8EC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828FE8F0: 419A00F4  beq cr6, 0x828fe9e4
	if ctx.cr[6].eq {
	pc = 0x828FE9E4; continue 'dispatch;
	}
	// 828FE8F4: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828FE8F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FE8FC: 419A0024  beq cr6, 0x828fe920
	if ctx.cr[6].eq {
	pc = 0x828FE920; continue 'dispatch;
	}
	// 828FE900: 894B0089  lbz r10, 0x89(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(137 as u32) ) } as u64;
	// 828FE904: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828FE908: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828FE90C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828FE910: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FE914: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828FE918: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FE91C: 480000CC  b 0x828fe9e8
	pc = 0x828FE9E8; continue 'dispatch;
            }
            0x828FE920 => {
    //   block [0x828FE920..0x828FE93C)
	// 828FE920: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828FE924: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828FE928: 92A10078  stw r21, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[21].u32 ) };
	// 828FE92C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828FE930: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 828FE934: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FE938: 40810054  ble 0x828fe98c
	if !ctx.cr[0].gt {
	pc = 0x828FE98C; continue 'dispatch;
	}
	pc = 0x828FE93C; continue 'dispatch;
            }
            0x828FE93C => {
    //   block [0x828FE93C..0x828FE95C)
	// 828FE93C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828FE940: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828FE944: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828FE948: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FE94C: 2F070089  cmpwi cr6, r7, 0x89
	ctx.cr[6].compare_i32(ctx.r[7].s32, 137, &mut ctx.xer);
	// 828FE950: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828FE954: 41980008  blt cr6, 0x828fe95c
	if ctx.cr[6].lt {
	pc = 0x828FE95C; continue 'dispatch;
	}
	// 828FE958: 7EA7AB78  mr r7, r21
	ctx.r[7].u64 = ctx.r[21].u64;
	pc = 0x828FE95C; continue 'dispatch;
            }
            0x828FE95C => {
    //   block [0x828FE95C..0x828FE978)
	// 828FE95C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828FE960: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828FE964: 419A0014  beq cr6, 0x828fe978
	if ctx.cr[6].eq {
	pc = 0x828FE978; continue 'dispatch;
	}
	// 828FE968: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828FE96C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828FE970: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828FE974: 4800000C  b 0x828fe980
	pc = 0x828FE980; continue 'dispatch;
            }
            0x828FE978 => {
    //   block [0x828FE978..0x828FE980)
	// 828FE978: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828FE97C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828FE980; continue 'dispatch;
            }
            0x828FE980 => {
    //   block [0x828FE980..0x828FE98C)
	// 828FE980: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FE984: 4199FFB8  bgt cr6, 0x828fe93c
	if ctx.cr[6].gt {
	pc = 0x828FE93C; continue 'dispatch;
	}
	// 828FE988: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	pc = 0x828FE98C; continue 'dispatch;
            }
            0x828FE98C => {
    //   block [0x828FE98C..0x828FE9A8)
	// 828FE98C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828FE990: 419A0040  beq cr6, 0x828fe9d0
	if ctx.cr[6].eq {
	pc = 0x828FE9D0; continue 'dispatch;
	}
	// 828FE994: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FE998: 2F0B0089  cmpwi cr6, r11, 0x89
	ctx.cr[6].compare_i32(ctx.r[11].s32, 137, &mut ctx.xer);
	// 828FE99C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FE9A0: 41990008  bgt cr6, 0x828fe9a8
	if ctx.cr[6].gt {
	pc = 0x828FE9A8; continue 'dispatch;
	}
	// 828FE9A4: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	pc = 0x828FE9A8; continue 'dispatch;
            }
            0x828FE9A8 => {
    //   block [0x828FE9A8..0x828FE9D0)
	// 828FE9A8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FE9AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FE9B0: 409A0020  bne cr6, 0x828fe9d0
	if !ctx.cr[6].eq {
	pc = 0x828FE9D0; continue 'dispatch;
	}
	// 828FE9B4: E9610078  ld r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 828FE9B8: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828FE9BC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828FE9C0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FE9C4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828FE9C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FE9CC: 4800001C  b 0x828fe9e8
	pc = 0x828FE9E8; continue 'dispatch;
            }
            0x828FE9D0 => {
    //   block [0x828FE9D0..0x828FE9E4)
	// 828FE9D0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828FE9D4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FE9D8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828FE9DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FE9E0: 48000008  b 0x828fe9e8
	pc = 0x828FE9E8; continue 'dispatch;
            }
            0x828FE9E4 => {
    //   block [0x828FE9E4..0x828FE9E8)
	// 828FE9E4: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	pc = 0x828FE9E8; continue 'dispatch;
            }
            0x828FE9E8 => {
    //   block [0x828FE9E8..0x828FEA04)
	// 828FE9E8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FE9EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FE9F0: 419A0014  beq cr6, 0x828fea04
	if ctx.cr[6].eq {
	pc = 0x828FEA04; continue 'dispatch;
	}
	// 828FE9F4: 897F0049  lbz r11, 0x49(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(73 as u32) ) } as u64;
	// 828FE9F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FE9FC: 409A0008  bne cr6, 0x828fea04
	if !ctx.cr[6].eq {
	pc = 0x828FEA04; continue 'dispatch;
	}
	// 828FEA00: C3F621AC  lfs f31, 0x21ac(r22)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8620 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x828FEA04; continue 'dispatch;
            }
            0x828FEA04 => {
    //   block [0x828FEA04..0x828FEA48)
	// 828FEA04: 80BC0000  lwz r5, 0(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FEA08: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FEA0C: 80780004  lwz r3, 4(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FEA10: 48592341  bl 0x82e90d50
	ctx.lr = 0x828FEA14;
	sub_82E90D50(ctx, base);
	// 828FEA14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FEA18: 419A0064  beq cr6, 0x828fea7c
	if ctx.cr[6].eq {
	pc = 0x828FEA7C; continue 'dispatch;
	}
	// 828FEA1C: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FEA20: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 828FEA24: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FEA28: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FEA2C: 419A001C  beq cr6, 0x828fea48
	if ctx.cr[6].eq {
	pc = 0x828FEA48; continue 'dispatch;
	}
	// 828FEA30: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828FEA34: 4098002C  bge cr6, 0x828fea60
	if !ctx.cr[6].lt {
	pc = 0x828FEA60; continue 'dispatch;
	}
	// 828FEA38: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828FEA3C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828FEA40: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828FEA44: 48000020  b 0x828fea64
	pc = 0x828FEA64; continue 'dispatch;
            }
            0x828FEA48 => {
    //   block [0x828FEA48..0x828FEA60)
	// 828FEA48: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828FEA4C: 40980014  bge cr6, 0x828fea60
	if !ctx.cr[6].lt {
	pc = 0x828FEA60; continue 'dispatch;
	}
	// 828FEA50: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FEA54: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828FEA58: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828FEA5C: 48000008  b 0x828fea64
	pc = 0x828FEA64; continue 'dispatch;
            }
            0x828FEA60 => {
    //   block [0x828FEA60..0x828FEA64)
	// 828FEA60: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	pc = 0x828FEA64; continue 'dispatch;
            }
            0x828FEA64 => {
    //   block [0x828FEA64..0x828FEA7C)
	// 828FEA64: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 828FEA68: 48000411  bl 0x828fee78
	ctx.lr = 0x828FEA6C;
	sub_828FEE78(ctx, base);
	// 828FEA6C: EC0107F2  fmuls f0, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[31].f64) as f32) as f64);
	// 828FEA70: FF00C000  fcmpu cr6, f0, f24
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[24].f64);
	// 828FEA74: 40990008  ble cr6, 0x828fea7c
	if !ctx.cr[6].gt {
	pc = 0x828FEA7C; continue 'dispatch;
	}
	// 828FEA78: FF000090  fmr f24, f0
	ctx.f[24].f64 = ctx.f[0].f64;
	pc = 0x828FEA7C; continue 'dispatch;
            }
            0x828FEA7C => {
    //   block [0x828FEA7C..0x828FEAD4)
	// 828FEA7C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828FEA80: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 828FEA84: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FEA88: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 828FEA8C: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 828FEA90: 91210098  stw r9, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[9].u32 ) };
	// 828FEA94: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 828FEA98: 91010090  stw r8, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[8].u32 ) };
	// 828FEA9C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828FEAA0: 9161009C  stw r11, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 828FEAA4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828FEAA8: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FEAAC: 90E10094  stw r7, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[7].u32 ) };
	// 828FEAB0: E8810090  ld r4, 0x90(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 828FEAB4: E8A10098  ld r5, 0x98(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 828FEAB8: 4BB4D971  bl 0x8244c428
	ctx.lr = 0x828FEABC;
	sub_8244C428(ctx, base);
	// 828FEABC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FEAC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FEAC4: 419A0010  beq cr6, 0x828fead4
	if ctx.cr[6].eq {
	pc = 0x828FEAD4; continue 'dispatch;
	}
	// 828FEAC8: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 828FEACC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828FEAD0: 419A0008  beq cr6, 0x828fead8
	if ctx.cr[6].eq {
	pc = 0x828FEAD8; continue 'dispatch;
	}
	pc = 0x828FEAD4; continue 'dispatch;
            }
            0x828FEAD4 => {
    //   block [0x828FEAD4..0x828FEAD8)
	// 828FEAD4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x828FEAD8; continue 'dispatch;
            }
            0x828FEAD8 => {
    //   block [0x828FEAD8..0x828FEB1C)
	// 828FEAD8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FEADC: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828FEAE0: 409A005C  bne cr6, 0x828feb3c
	if !ctx.cr[6].eq {
	pc = 0x828FEB3C; continue 'dispatch;
	}
	// 828FEAE4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FEAE8: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 828FEAEC: 81210064  lwz r9, 0x64(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828FEAF0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828FEAF4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FEAF8: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 828FEAFC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828FEB00: 91210074  stw r9, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 828FEB04: E8810070  ld r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828FEB08: 4824B279  bl 0x82b49d80
	ctx.lr = 0x828FEB0C;
	sub_82B49D80(ctx, base);
	// 828FEB0C: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 828FEB10: 7F1CD840  cmplw cr6, r28, r27
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[27].u32, &mut ctx.xer);
	// 828FEB14: 409AFBA8  bne cr6, 0x828fe6bc
	if !ctx.cr[6].eq {
	pc = 0x828FE6BC; continue 'dispatch;
	}
	// 828FEB18: 48000028  b 0x828feb40
	pc = 0x828FEB40; continue 'dispatch;
            }
            0x828FEB1C => {
    //   block [0x828FEB1C..0x828FEB3C)
	// 828FEB1C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FEB20: 48116271  bl 0x82a14d90
	ctx.lr = 0x828FEB24;
	sub_82A14D90(ctx, base);
	// 828FEB24: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828FEB28: 4B91D211  bl 0x8221bd38
	ctx.lr = 0x828FEB2C;
	sub_8221BD38(ctx, base);
	// 828FEB2C: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FEB30: 92A10064  stw r21, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[21].u32 ) };
	// 828FEB34: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FEB38: 48000320  b 0x828fee58
	pc = 0x828FEE58; continue 'dispatch;
            }
            0x828FEB3C => {
    //   block [0x828FEB3C..0x828FEB40)
	// 828FEB3C: C3162B34  lfs f24, 0x2b34(r22)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(11060 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	pc = 0x828FEB40; continue 'dispatch;
            }
            0x828FEB40 => {
    //   block [0x828FEB40..0x828FEBCC)
	// 828FEB40: FFE0C090  fmr f31, f24
	ctx.f[31].f64 = ctx.f[24].f64;
	// 828FEB44: FF18A800  fcmpu cr6, f24, f21
	ctx.cr[6].compare_f64(ctx.f[24].f64, ctx.f[21].f64);
	// 828FEB48: 409A0260  bne cr6, 0x828feda8
	if !ctx.cr[6].eq {
	pc = 0x828FEDA8; continue 'dispatch;
	}
	// 828FEB4C: C0120000  lfs f0, 0(r18)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FEB50: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 828FEB54: C1B10000  lfs f13, 0(r17)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828FEB58: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 828FEB5C: C1920004  lfs f12, 4(r18)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828FEB60: ED60682A  fadds f11, f0, f13
	ctx.f[11].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 828FEB64: C1510004  lfs f10, 4(r17)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828FEB68: 80980004  lwz r4, 4(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FEB6C: C1320008  lfs f9, 8(r18)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 828FEB70: ED0C502A  fadds f8, f12, f10
	ctx.f[8].f64 = ((ctx.f[12].f64 + ctx.f[10].f64) as f32) as f64;
	// 828FEB74: C0F10008  lfs f7, 8(r17)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(8 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 828FEB78: ECC9382A  fadds f6, f9, f7
	ctx.f[6].f64 = ((ctx.f[9].f64 + ctx.f[7].f64) as f32) as f64;
	// 828FEB7C: C0160000  lfs f0, 0(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FEB80: ECAB0032  fmuls f5, f11, f0
	ctx.f[5].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 828FEB84: D0A100A0  stfs f5, 0xa0(r1)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 828FEB88: EC880032  fmuls f4, f8, f0
	ctx.f[4].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 828FEB8C: D08100A4  stfs f4, 0xa4(r1)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 828FEB90: EC660032  fmuls f3, f6, f0
	ctx.f[3].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 828FEB94: D06100A8  stfs f3, 0xa8(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 828FEB98: 4BD2C299  bl 0x8262ae30
	ctx.lr = 0x828FEB9C;
	sub_8262AE30(ctx, base);
	// 828FEB9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FEBA0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828FEBA4: 419A0204  beq cr6, 0x828feda8
	if ctx.cr[6].eq {
	pc = 0x828FEDA8; continue 'dispatch;
	}
	// 828FEBA8: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FEBAC: C2D601BC  lfs f22, 0x1bc(r22)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(444 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 828FEBB0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FEBB4: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 828FEBB8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828FEBBC: 40980010  bge cr6, 0x828febcc
	if !ctx.cr[6].lt {
	pc = 0x828FEBCC; continue 'dispatch;
	}
	// 828FEBC0: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828FEBC4: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828FEBC8: 48000008  b 0x828febd0
	pc = 0x828FEBD0; continue 'dispatch;
            }
            0x828FEBCC => {
    //   block [0x828FEBCC..0x828FEBD0)
	// 828FEBCC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x828FEBD0; continue 'dispatch;
            }
            0x828FEBD0 => {
    //   block [0x828FEBD0..0x828FEBF8)
	// 828FEBD0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FEBD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FEBD8: 419A0164  beq cr6, 0x828fed3c
	if ctx.cr[6].eq {
	pc = 0x828FED3C; continue 'dispatch;
	}
	// 828FEBDC: 897A00B9  lbz r11, 0xb9(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(185 as u32) ) } as u64;
	// 828FEBE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FEBE4: 409A0014  bne cr6, 0x828febf8
	if !ctx.cr[6].eq {
	pc = 0x828FEBF8; continue 'dispatch;
	}
	// 828FEBE8: 897A0285  lbz r11, 0x285(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(645 as u32) ) } as u64;
	// 828FEBEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FEBF0: 419AFF2C  beq cr6, 0x828feb1c
	if ctx.cr[6].eq {
	pc = 0x828FEB1C; continue 'dispatch;
	}
	// 828FEBF4: FEC0B890  fmr f22, f23
	ctx.f[22].f64 = ctx.f[23].f64;
	pc = 0x828FEBF8; continue 'dispatch;
            }
            0x828FEBF8 => {
    //   block [0x828FEBF8..0x828FEC58)
	// 828FEBF8: 7EBFAB78  mr r31, r21
	ctx.r[31].u64 = ctx.r[21].u64;
	// 828FEBFC: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 828FEC00: 419A0168  beq cr6, 0x828fed68
	if ctx.cr[6].eq {
	pc = 0x828FED68; continue 'dispatch;
	}
	// 828FEC04: 81796AB8  lwz r11, 0x6ab8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828FEC08: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FEC0C: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 828FEC10: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FEC14: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FEC18: 4B92D5A1  bl 0x8222c1b8
	ctx.lr = 0x828FEC1C;
	sub_8222C1B8(ctx, base);
	// 828FEC1C: 81030034  lwz r8, 0x34(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 828FEC20: 5507BFFE  rlwinm r7, r8, 0x17, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x000001FFu64;
	// 828FEC24: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828FEC28: 419A00F4  beq cr6, 0x828fed1c
	if ctx.cr[6].eq {
	pc = 0x828FED1C; continue 'dispatch;
	}
	// 828FEC2C: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828FEC30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FEC34: 419A0024  beq cr6, 0x828fec58
	if ctx.cr[6].eq {
	pc = 0x828FEC58; continue 'dispatch;
	}
	// 828FEC38: 894B0089  lbz r10, 0x89(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(137 as u32) ) } as u64;
	// 828FEC3C: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828FEC40: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828FEC44: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828FEC48: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FEC4C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828FEC50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FEC54: 480000CC  b 0x828fed20
	pc = 0x828FED20; continue 'dispatch;
            }
            0x828FEC58 => {
    //   block [0x828FEC58..0x828FEC74)
	// 828FEC58: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828FEC5C: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828FEC60: 92A10078  stw r21, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[21].u32 ) };
	// 828FEC64: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828FEC68: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 828FEC6C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FEC70: 40810054  ble 0x828fecc4
	if !ctx.cr[0].gt {
	pc = 0x828FECC4; continue 'dispatch;
	}
	pc = 0x828FEC74; continue 'dispatch;
            }
            0x828FEC74 => {
    //   block [0x828FEC74..0x828FEC94)
	// 828FEC74: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828FEC78: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828FEC7C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 828FEC80: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FEC84: 2F070089  cmpwi cr6, r7, 0x89
	ctx.cr[6].compare_i32(ctx.r[7].s32, 137, &mut ctx.xer);
	// 828FEC88: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828FEC8C: 41980008  blt cr6, 0x828fec94
	if ctx.cr[6].lt {
	pc = 0x828FEC94; continue 'dispatch;
	}
	// 828FEC90: 7EA7AB78  mr r7, r21
	ctx.r[7].u64 = ctx.r[21].u64;
	pc = 0x828FEC94; continue 'dispatch;
            }
            0x828FEC94 => {
    //   block [0x828FEC94..0x828FECB0)
	// 828FEC94: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828FEC98: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828FEC9C: 419A0014  beq cr6, 0x828fecb0
	if ctx.cr[6].eq {
	pc = 0x828FECB0; continue 'dispatch;
	}
	// 828FECA0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828FECA4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828FECA8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828FECAC: 4800000C  b 0x828fecb8
	pc = 0x828FECB8; continue 'dispatch;
            }
            0x828FECB0 => {
    //   block [0x828FECB0..0x828FECB8)
	// 828FECB0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828FECB4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828FECB8; continue 'dispatch;
            }
            0x828FECB8 => {
    //   block [0x828FECB8..0x828FECC4)
	// 828FECB8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FECBC: 4199FFB8  bgt cr6, 0x828fec74
	if ctx.cr[6].gt {
	pc = 0x828FEC74; continue 'dispatch;
	}
	// 828FECC0: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	pc = 0x828FECC4; continue 'dispatch;
            }
            0x828FECC4 => {
    //   block [0x828FECC4..0x828FECE0)
	// 828FECC4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828FECC8: 419A0040  beq cr6, 0x828fed08
	if ctx.cr[6].eq {
	pc = 0x828FED08; continue 'dispatch;
	}
	// 828FECCC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FECD0: 2F0B0089  cmpwi cr6, r11, 0x89
	ctx.cr[6].compare_i32(ctx.r[11].s32, 137, &mut ctx.xer);
	// 828FECD4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FECD8: 41990008  bgt cr6, 0x828fece0
	if ctx.cr[6].gt {
	pc = 0x828FECE0; continue 'dispatch;
	}
	// 828FECDC: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	pc = 0x828FECE0; continue 'dispatch;
            }
            0x828FECE0 => {
    //   block [0x828FECE0..0x828FED08)
	// 828FECE0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FECE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FECE8: 409A0020  bne cr6, 0x828fed08
	if !ctx.cr[6].eq {
	pc = 0x828FED08; continue 'dispatch;
	}
	// 828FECEC: E9610078  ld r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 828FECF0: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 828FECF4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828FECF8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FECFC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828FED00: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FED04: 4800001C  b 0x828fed20
	pc = 0x828FED20; continue 'dispatch;
            }
            0x828FED08 => {
    //   block [0x828FED08..0x828FED1C)
	// 828FED08: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828FED0C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FED10: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828FED14: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FED18: 48000008  b 0x828fed20
	pc = 0x828FED20; continue 'dispatch;
            }
            0x828FED1C => {
    //   block [0x828FED1C..0x828FED20)
	// 828FED1C: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	pc = 0x828FED20; continue 'dispatch;
            }
            0x828FED20 => {
    //   block [0x828FED20..0x828FED3C)
	// 828FED20: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FED24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FED28: 419A0014  beq cr6, 0x828fed3c
	if ctx.cr[6].eq {
	pc = 0x828FED3C; continue 'dispatch;
	}
	// 828FED2C: 897F0049  lbz r11, 0x49(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(73 as u32) ) } as u64;
	// 828FED30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FED34: 409A0008  bne cr6, 0x828fed3c
	if !ctx.cr[6].eq {
	pc = 0x828FED3C; continue 'dispatch;
	}
	// 828FED38: C2D621AC  lfs f22, 0x21ac(r22)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8620 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	pc = 0x828FED3C; continue 'dispatch;
            }
            0x828FED3C => {
    //   block [0x828FED3C..0x828FED68)
	// 828FED3C: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 828FED40: 419A0028  beq cr6, 0x828fed68
	if ctx.cr[6].eq {
	pc = 0x828FED68; continue 'dispatch;
	}
	// 828FED44: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FED48: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FED4C: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 828FED50: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828FED54: 40980038  bge cr6, 0x828fed8c
	if !ctx.cr[6].lt {
	pc = 0x828FED8C; continue 'dispatch;
	}
	// 828FED58: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828FED5C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828FED60: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 828FED64: 4800002C  b 0x828fed90
	pc = 0x828FED90; continue 'dispatch;
            }
            0x828FED68 => {
    //   block [0x828FED68..0x828FED8C)
	// 828FED68: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FED6C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FED70: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 828FED74: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828FED78: 40980014  bge cr6, 0x828fed8c
	if !ctx.cr[6].lt {
	pc = 0x828FED8C; continue 'dispatch;
	}
	// 828FED7C: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 828FED80: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828FED84: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828FED88: 48000008  b 0x828fed90
	pc = 0x828FED90; continue 'dispatch;
            }
            0x828FED8C => {
    //   block [0x828FED8C..0x828FED90)
	// 828FED8C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	pc = 0x828FED90; continue 'dispatch;
            }
            0x828FED90 => {
    //   block [0x828FED90..0x828FEDA8)
	// 828FED90: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 828FED94: 480000E5  bl 0x828fee78
	ctx.lr = 0x828FED98;
	sub_828FEE78(ctx, base);
	// 828FED98: EC0105B2  fmuls f0, f1, f22
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[22].f64) as f32) as f64);
	// 828FED9C: FF00C000  fcmpu cr6, f0, f24
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[24].f64);
	// 828FEDA0: 40990008  ble cr6, 0x828feda8
	if !ctx.cr[6].gt {
	pc = 0x828FEDA8; continue 'dispatch;
	}
	// 828FEDA4: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	pc = 0x828FEDA8; continue 'dispatch;
            }
            0x828FEDA8 => {
    //   block [0x828FEDA8..0x828FEDBC)
	// 828FEDA8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828FEDAC: 48115FE5  bl 0x82a14d90
	ctx.lr = 0x828FEDB0;
	sub_82A14D90(ctx, base);
	// 828FEDB0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828FEDB4: 4B91CF85  bl 0x8221bd38
	ctx.lr = 0x828FEDB8;
	sub_8221BD38(ctx, base);
	// 828FEDB8: 92A10064  stw r21, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[21].u32 ) };
	pc = 0x828FEDBC; continue 'dispatch;
            }
            0x828FEDBC => {
    //   block [0x828FEDBC..0x828FEE04)
	// 828FEDBC: C0110000  lfs f0, 0(r17)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FEDC0: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 828FEDC4: C1B20000  lfs f13, 0(r18)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828FEDC8: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 828FEDCC: C1710004  lfs f11, 4(r17)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828FEDD0: C1520004  lfs f10, 4(r18)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828FEDD4: ED2B5028  fsubs f9, f11, f10
	ctx.f[9].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 828FEDD8: C1110008  lfs f8, 8(r17)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 828FEDDC: C0F20008  lfs f7, 8(r18)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 828FEDE0: ECC83828  fsubs f6, f8, f7
	ctx.f[6].f64 = (((ctx.f[8].f64 - ctx.f[7].f64) as f32) as f64);
	// 828FEDE4: C00BEC04  lfs f0, -0x13fc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FEDE8: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 828FEDEC: ECAC0332  fmuls f5, f12, f12
	ctx.f[5].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 828FEDF0: EC892A7A  fmadds f4, f9, f9, f5
	ctx.f[4].f64 = (((ctx.f[9].f64 * ctx.f[9].f64 + ctx.f[5].f64) as f32) as f64);
	// 828FEDF4: EC6621BA  fmadds f3, f6, f6, f4
	ctx.f[3].f64 = (((ctx.f[6].f64 * ctx.f[6].f64 + ctx.f[4].f64) as f32) as f64);
	// 828FEDF8: EC00182C  fsqrts f0, f3
	ctx.f[0].f64 = ((ctx.f[3].f64).sqrt() as f32) as f64;
	// 828FEDFC: 40980008  bge cr6, 0x828fee04
	if !ctx.cr[6].lt {
	pc = 0x828FEE04; continue 'dispatch;
	}
	// 828FEE00: FFE0A890  fmr f31, f21
	ctx.f[31].f64 = ctx.f[21].f64;
	pc = 0x828FEE04; continue 'dispatch;
            }
            0x828FEE04 => {
    //   block [0x828FEE04..0x828FEE40)
	// 828FEE04: C1B601BC  lfs f13, 0x1bc(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(444 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828FEE08: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FEE0C: ED9F682A  fadds f12, f31, f13
	ctx.f[12].f64 = ((ctx.f[31].f64 + ctx.f[13].f64) as f32) as f64;
	// 828FEE10: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FEE14: ED6C0032  fmuls f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 828FEE18: ED4B05B2  fmuls f10, f11, f22
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[22].f64) as f32) as f64);
	// 828FEE1C: D1500000  stfs f10, 0(r16)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[16].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828FEE20: 419AF138  beq cr6, 0x828fdf58
	if ctx.cr[6].eq {
	pc = 0x828FDF58; continue 'dispatch;
	}
	// 828FEE24: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FEE28: 489BAB2D  bl 0x832b9954
	ctx.lr = 0x828FEE2C;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 828FEE2C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828FEE30: 382101E0  addi r1, r1, 0x1e0
	ctx.r[1].s64 = ctx.r[1].s64 + 480;
	// 828FEE34: 3981FF78  addi r12, r1, -0x88
	ctx.r[12].s64 = ctx.r[1].s64 + -136;
	// 828FEE38: 483AEED1  bl 0x82cadd08
	ctx.lr = 0x828FEE3C;
	sub_82CADCEC(ctx, base);
	// 828FEE3C: 483AA5EC  b 0x82ca9428
	sub_82CA9420(ctx, base);
	return;
            }
            0x828FEE40 => {
    //   block [0x828FEE40..0x828FEE58)
	// 828FEE40: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828FEE44: 89010054  lbz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FEE48: 392B92D4  addi r9, r11, -0x6d2c
	ctx.r[9].s64 = ctx.r[11].s64 + -27948;
	// 828FEE4C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828FEE50: C00901B0  lfs f0, 0x1b0(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(432 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FEE54: D0100000  stfs f0, 0(r16)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[16].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x828FEE58; continue 'dispatch;
            }
            0x828FEE58 => {
    //   block [0x828FEE58..0x828FEE64)
	// 828FEE58: 419A000C  beq cr6, 0x828fee64
	if ctx.cr[6].eq {
	pc = 0x828FEE64; continue 'dispatch;
	}
	// 828FEE5C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FEE60: 489BAAF5  bl 0x832b9954
	ctx.lr = 0x828FEE64;
	// extern call 0x832B9954 → crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x828FEE64; continue 'dispatch;
            }
            0x828FEE64 => {
    //   block [0x828FEE64..0x828FEE78)
	// 828FEE64: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828FEE68: 382101E0  addi r1, r1, 0x1e0
	ctx.r[1].s64 = ctx.r[1].s64 + 480;
	// 828FEE6C: 3981FF78  addi r12, r1, -0x88
	ctx.r[12].s64 = ctx.r[1].s64 + -136;
	// 828FEE70: 483AEE99  bl 0x82cadd08
	ctx.lr = 0x828FEE74;
	sub_82CADCEC(ctx, base);
	// 828FEE74: 483AA5B4  b 0x82ca9428
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FEE78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828FEE78 size=308
    let mut pc: u32 = 0x828FEE78;
    'dispatch: loop {
        match pc {
            0x828FEE78 => {
    //   block [0x828FEE78..0x828FEEBC)
	// 828FEE78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828FEE7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FEE80: 419A012C  beq cr6, 0x828fefac
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x828FEFAC);
		return;
	}
	// 828FEE84: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 828FEE88: 554927FE  rlwinm r9, r10, 4, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0FFFFFFFu64;
	// 828FEE8C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828FEE90: 419A00EC  beq cr6, 0x828fef7c
	if ctx.cr[6].eq {
	pc = 0x828FEF7C; continue 'dispatch;
	}
	// 828FEE94: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828FEE98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FEE9C: 419A0020  beq cr6, 0x828feebc
	if ctx.cr[6].eq {
	pc = 0x828FEEBC; continue 'dispatch;
	}
	// 828FEEA0: 894B003C  lbz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 828FEEA4: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828FEEA8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828FEEAC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828FEEB0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828FEEB4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FEEB8: 480000C8  b 0x828fef80
	pc = 0x828FEF80; continue 'dispatch;
            }
            0x828FEEBC => {
    //   block [0x828FEEBC..0x828FEEDC)
	// 828FEEBC: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828FEEC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828FEEC4: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828FEEC8: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 828FEECC: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828FEED0: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 828FEED4: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FEED8: 40810054  ble 0x828fef2c
	if !ctx.cr[0].gt {
	pc = 0x828FEF2C; continue 'dispatch;
	}
	pc = 0x828FEEDC; continue 'dispatch;
            }
            0x828FEEDC => {
    //   block [0x828FEEDC..0x828FEEFC)
	// 828FEEDC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828FEEE0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828FEEE4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828FEEE8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FEEEC: 2F07003C  cmpwi cr6, r7, 0x3c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 60, &mut ctx.xer);
	// 828FEEF0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828FEEF4: 41980008  blt cr6, 0x828feefc
	if ctx.cr[6].lt {
	pc = 0x828FEEFC; continue 'dispatch;
	}
	// 828FEEF8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x828FEEFC; continue 'dispatch;
            }
            0x828FEEFC => {
    //   block [0x828FEEFC..0x828FEF18)
	// 828FEEFC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828FEF00: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828FEF04: 419A0014  beq cr6, 0x828fef18
	if ctx.cr[6].eq {
	pc = 0x828FEF18; continue 'dispatch;
	}
	// 828FEF08: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828FEF0C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828FEF10: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828FEF14: 4800000C  b 0x828fef20
	pc = 0x828FEF20; continue 'dispatch;
            }
            0x828FEF18 => {
    //   block [0x828FEF18..0x828FEF20)
	// 828FEF18: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828FEF1C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828FEF20; continue 'dispatch;
            }
            0x828FEF20 => {
    //   block [0x828FEF20..0x828FEF2C)
	// 828FEF20: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FEF24: 4199FFB8  bgt cr6, 0x828feedc
	if ctx.cr[6].gt {
	pc = 0x828FEEDC; continue 'dispatch;
	}
	// 828FEF28: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	pc = 0x828FEF2C; continue 'dispatch;
            }
            0x828FEF2C => {
    //   block [0x828FEF2C..0x828FEF48)
	// 828FEF2C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828FEF30: 419A003C  beq cr6, 0x828fef6c
	if ctx.cr[6].eq {
	pc = 0x828FEF6C; continue 'dispatch;
	}
	// 828FEF34: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FEF38: 2F0B003C  cmpwi cr6, r11, 0x3c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 60, &mut ctx.xer);
	// 828FEF3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FEF40: 41990008  bgt cr6, 0x828fef48
	if ctx.cr[6].gt {
	pc = 0x828FEF48; continue 'dispatch;
	}
	// 828FEF44: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x828FEF48; continue 'dispatch;
            }
            0x828FEF48 => {
    //   block [0x828FEF48..0x828FEF6C)
	// 828FEF48: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FEF4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FEF50: 409A001C  bne cr6, 0x828fef6c
	if !ctx.cr[6].eq {
	pc = 0x828FEF6C; continue 'dispatch;
	}
	// 828FEF54: E961FFF0  ld r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FEF58: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828FEF5C: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 828FEF60: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 828FEF64: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FEF68: 48000018  b 0x828fef80
	pc = 0x828FEF80; continue 'dispatch;
            }
            0x828FEF6C => {
    //   block [0x828FEF6C..0x828FEF7C)
	// 828FEF6C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828FEF70: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828FEF74: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FEF78: 48000008  b 0x828fef80
	pc = 0x828FEF80; continue 'dispatch;
            }
            0x828FEF7C => {
    //   block [0x828FEF7C..0x828FEF80)
	// 828FEF7C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x828FEF80; continue 'dispatch;
            }
            0x828FEF80 => {
    //   block [0x828FEF80..0x828FEFAC)
	// 828FEF80: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 828FEF84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FEF88: 419A0024  beq cr6, 0x828fefac
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x828FEFAC);
		return;
	}
	// 828FEF8C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 828FEF90: 4198001C  blt cr6, 0x828fefac
	if ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x828FEFAC);
		return;
	}
	// 828FEF94: 2F040009  cmpwi cr6, r4, 9
	ctx.cr[6].compare_i32(ctx.r[4].s32, 9, &mut ctx.xer);
	// 828FEF98: 40980014  bge cr6, 0x828fefac
	if !ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x828FEFAC);
		return;
	}
	// 828FEF9C: 3944002F  addi r10, r4, 0x2f
	ctx.r[10].s64 = ctx.r[4].s64 + 47;
	// 828FEFA0: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828FEFA4: 7C295C2E  lfsx f1, r9, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828FEFA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FEFB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FEFB8 size=580
    let mut pc: u32 = 0x828FEFB8;
    'dispatch: loop {
        match pc {
            0x828FEFB8 => {
    //   block [0x828FEFB8..0x828FF018)
	// 828FEFB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FEFBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FEFC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FEFC4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828FEFC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FEFCC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828FEFD0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828FEFD4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FEFD8: 419A0204  beq cr6, 0x828ff1dc
	if ctx.cr[6].eq {
	pc = 0x828FF1DC; continue 'dispatch;
	}
	// 828FEFDC: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 828FEFE0: 556A27FE  rlwinm r10, r11, 4, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0FFFFFFFu64;
	// 828FEFE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FEFE8: 419A00F4  beq cr6, 0x828ff0dc
	if ctx.cr[6].eq {
	pc = 0x828FF0DC; continue 'dispatch;
	}
	// 828FEFEC: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 828FEFF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FEFF4: 419A0024  beq cr6, 0x828ff018
	if ctx.cr[6].eq {
	pc = 0x828FF018; continue 'dispatch;
	}
	// 828FEFF8: 894B003C  lbz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 828FEFFC: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828FF000: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 828FF004: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828FF008: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FF00C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828FF010: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FF014: 480000CC  b 0x828ff0e0
	pc = 0x828FF0E0; continue 'dispatch;
            }
            0x828FF018 => {
    //   block [0x828FF018..0x828FF034)
	// 828FF018: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 828FF01C: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 828FF020: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828FF024: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 828FF028: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828FF02C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FF030: 40810054  ble 0x828ff084
	if !ctx.cr[0].gt {
	pc = 0x828FF084; continue 'dispatch;
	}
	pc = 0x828FF034; continue 'dispatch;
            }
            0x828FF034 => {
    //   block [0x828FF034..0x828FF054)
	// 828FF034: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 828FF038: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 828FF03C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 828FF040: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FF044: 2F07003C  cmpwi cr6, r7, 0x3c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 60, &mut ctx.xer);
	// 828FF048: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828FF04C: 41980008  blt cr6, 0x828ff054
	if ctx.cr[6].lt {
	pc = 0x828FF054; continue 'dispatch;
	}
	// 828FF050: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x828FF054; continue 'dispatch;
            }
            0x828FF054 => {
    //   block [0x828FF054..0x828FF070)
	// 828FF054: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 828FF058: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828FF05C: 419A0014  beq cr6, 0x828ff070
	if ctx.cr[6].eq {
	pc = 0x828FF070; continue 'dispatch;
	}
	// 828FF060: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 828FF064: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828FF068: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828FF06C: 4800000C  b 0x828ff078
	pc = 0x828FF078; continue 'dispatch;
            }
            0x828FF070 => {
    //   block [0x828FF070..0x828FF078)
	// 828FF070: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 828FF074: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x828FF078; continue 'dispatch;
            }
            0x828FF078 => {
    //   block [0x828FF078..0x828FF084)
	// 828FF078: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FF07C: 4199FFB8  bgt cr6, 0x828ff034
	if ctx.cr[6].gt {
	pc = 0x828FF034; continue 'dispatch;
	}
	// 828FF080: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x828FF084; continue 'dispatch;
            }
            0x828FF084 => {
    //   block [0x828FF084..0x828FF0A0)
	// 828FF084: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 828FF088: 419A0040  beq cr6, 0x828ff0c8
	if ctx.cr[6].eq {
	pc = 0x828FF0C8; continue 'dispatch;
	}
	// 828FF08C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FF090: 2F0B003C  cmpwi cr6, r11, 0x3c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 60, &mut ctx.xer);
	// 828FF094: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FF098: 41990008  bgt cr6, 0x828ff0a0
	if ctx.cr[6].gt {
	pc = 0x828FF0A0; continue 'dispatch;
	}
	// 828FF09C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x828FF0A0; continue 'dispatch;
            }
            0x828FF0A0 => {
    //   block [0x828FF0A0..0x828FF0C8)
	// 828FF0A0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FF0A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FF0A8: 409A0020  bne cr6, 0x828ff0c8
	if !ctx.cr[6].eq {
	pc = 0x828FF0C8; continue 'dispatch;
	}
	// 828FF0AC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828FF0B0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 828FF0B4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FF0B8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FF0BC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828FF0C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FF0C4: 4800001C  b 0x828ff0e0
	pc = 0x828FF0E0; continue 'dispatch;
            }
            0x828FF0C8 => {
    //   block [0x828FF0C8..0x828FF0DC)
	// 828FF0C8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 828FF0CC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FF0D0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828FF0D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FF0D8: 48000008  b 0x828ff0e0
	pc = 0x828FF0E0; continue 'dispatch;
            }
            0x828FF0DC => {
    //   block [0x828FF0DC..0x828FF0E0)
	// 828FF0DC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x828FF0E0; continue 'dispatch;
            }
            0x828FF0E0 => {
    //   block [0x828FF0E0..0x828FF1B0)
	// 828FF0E0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FF0E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FF0E8: 419A00F4  beq cr6, 0x828ff1dc
	if ctx.cr[6].eq {
	pc = 0x828FF1DC; continue 'dispatch;
	}
	// 828FF0EC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828FF0F0: 4B92D2A1  bl 0x8222c390
	ctx.lr = 0x828FF0F4;
	sub_8222C390(ctx, base);
	// 828FF0F4: FD600818  frsp f11, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].f64 = (ctx.f[1].f64 as f32) as f64;
	// 828FF0F8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828FF0FC: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 828FF100: 392BBE08  addi r9, r11, -0x41f8
	ctx.r[9].s64 = ctx.r[11].s64 + -16888;
	// 828FF104: 390A0E68  addi r8, r10, 0xe68
	ctx.r[8].s64 = ctx.r[10].s64 + 3688;
	// 828FF108: C18BBE08  lfs f12, -0x41f8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16888 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828FF10C: C009D67C  lfs f0, -0x2984(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10628 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FF110: C1A9D688  lfs f13, -0x2978(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10616 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828FF114: FD40581E  fctiwz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 828FF118: D9410050  stfd f10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[10].u64 ) };
	// 828FF11C: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FF120: 7CE6FE70  srawi r6, r7, 0x1f
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[7].s32 >> 31) as i64;
	// 828FF124: 7CC53838  and r5, r6, r7
	ctx.r[5].u64 = ctx.r[6].u64 & ctx.r[7].u64;
	// 828FF128: 7D453850  subf r10, r5, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[5].s64;
	// 828FF12C: 216A0007  subfic r11, r10, 7
	ctx.xer.ca = ctx.r[10].u32 <= 7 as u32;
	ctx.r[11].s64 = (7 as i64) - ctx.r[10].s64;
	// 828FF130: 7D64FE70  srawi r4, r11, 0x1f
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[11].s32 >> 31) as i64;
	// 828FF134: 7C8B5838  and r11, r4, r11
	ctx.r[11].u64 = ctx.r[4].u64 & ctx.r[11].u64;
	// 828FF138: 7D6B5215  add. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FF13C: 7D6307B4  extsw r3, r11
	ctx.r[3].s64 = ctx.r[11].s32 as i64;
	// 828FF140: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 828FF144: F8610050  std r3, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u64 ) };
	// 828FF148: C9210050  lfd f9, 0x50(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828FF14C: FD004E9C  fcfid f8, f9
	ctx.f[8].f64 = (ctx.f[9].s64 as f64);
	// 828FF150: FCE04018  frsp f7, f8
	ctx.f[7].f64 = (ctx.f[8].f64 as f32) as f64;
	// 828FF154: ECDF3828  fsubs f6, f31, f7
	ctx.f[6].f64 = (((ctx.f[31].f64 - ctx.f[7].f64) as f32) as f64);
	// 828FF158: FF060000  fcmpu cr6, f6, f0
	ctx.cr[6].compare_f64(ctx.f[6].f64, ctx.f[0].f64);
	// 828FF15C: 7D200026  mfcr r9
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[9].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 828FF160: 5527DF7A  rlwinm r7, r9, 0x1b, 0x1d, 0x1d
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 828FF164: 5526F77A  rlwinm r6, r9, 0x1e, 0x1d, 0x1d
	ctx.r[6].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 828FF168: 7CE53378  or r5, r7, r6
	ctx.r[5].u64 = ctx.r[7].u64 | ctx.r[6].u64;
	// 828FF16C: 7CA82C2E  lfsx f5, r8, r5
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[5].u32)) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 828FF170: FC8501AE  fsel f4, f5, f6, f0
	ctx.f[4].f64 = if ctx.f[5].f64 >= 0.0 { ctx.f[6].f64 } else { ctx.f[0].f64 };
	// 828FF174: EC646828  fsubs f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 - ctx.f[13].f64) as f32) as f64);
	// 828FF178: FF030000  fcmpu cr6, f3, f0
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[0].f64);
	// 828FF17C: 7C800026  mfcr r4
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[4].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 828FF180: 5483DF7A  rlwinm r3, r4, 0x1b, 0x1d, 0x1d
	ctx.r[3].u64 = ctx.r[4].u32 as u64 & 0x0000001Fu64;
	// 828FF184: 5489F77A  rlwinm r9, r4, 0x1e, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[4].u32 as u64 & 0x00000003u64;
	// 828FF188: 7C674B78  or r7, r3, r9
	ctx.r[7].u64 = ctx.r[3].u64 | ctx.r[9].u64;
	// 828FF18C: 7C483C2E  lfsx f2, r8, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828FF190: FDA2236E  fsel f13, f2, f13, f4
	ctx.f[13].f64 = if ctx.f[2].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[4].f64 };
	// 828FF194: 4180001C  blt 0x828ff1b0
	if ctx.cr[0].lt {
	pc = 0x828FF1B0; continue 'dispatch;
	}
	// 828FF198: 2F0B0009  cmpwi cr6, r11, 9
	ctx.cr[6].compare_i32(ctx.r[11].s32, 9, &mut ctx.xer);
	// 828FF19C: 40980014  bge cr6, 0x828ff1b0
	if !ctx.cr[6].lt {
	pc = 0x828FF1B0; continue 'dispatch;
	}
	// 828FF1A0: 396B002F  addi r11, r11, 0x2f
	ctx.r[11].s64 = ctx.r[11].s64 + 47;
	// 828FF1A4: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828FF1A8: 7C09FC2E  lfsx f0, r9, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FF1AC: 48000008  b 0x828ff1b4
	pc = 0x828FF1B4; continue 'dispatch;
            }
            0x828FF1B0 => {
    //   block [0x828FF1B0..0x828FF1B4)
	// 828FF1B0: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	pc = 0x828FF1B4; continue 'dispatch;
            }
            0x828FF1B4 => {
    //   block [0x828FF1B4..0x828FF1D0)
	// 828FF1B4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828FF1B8: 41980018  blt cr6, 0x828ff1d0
	if ctx.cr[6].lt {
	pc = 0x828FF1D0; continue 'dispatch;
	}
	// 828FF1BC: 2F0A0009  cmpwi cr6, r10, 9
	ctx.cr[6].compare_i32(ctx.r[10].s32, 9, &mut ctx.xer);
	// 828FF1C0: 40980010  bge cr6, 0x828ff1d0
	if !ctx.cr[6].lt {
	pc = 0x828FF1D0; continue 'dispatch;
	}
	// 828FF1C4: 396A002F  addi r11, r10, 0x2f
	ctx.r[11].s64 = ctx.r[10].s64 + 47;
	// 828FF1C8: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828FF1CC: 7D8AFC2E  lfsx f12, r10, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x828FF1D0; continue 'dispatch;
            }
            0x828FF1D0 => {
    //   block [0x828FF1D0..0x828FF1DC)
	// 828FF1D0: ED8C0028  fsubs f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 828FF1D4: EC2C037A  fmadds f1, f12, f13, f0
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 828FF1D8: 4800000C  b 0x828ff1e4
	pc = 0x828FF1E4; continue 'dispatch;
            }
            0x828FF1DC => {
    //   block [0x828FF1DC..0x828FF1E4)
	// 828FF1DC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828FF1E0: C02BBE08  lfs f1, -0x41f8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16888 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	pc = 0x828FF1E4; continue 'dispatch;
            }
            0x828FF1E4 => {
    //   block [0x828FF1E4..0x828FF1FC)
	// 828FF1E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FF1E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FF1EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FF1F0: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828FF1F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FF1F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FF200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FF200 size=60
    let mut pc: u32 = 0x828FF200;
    'dispatch: loop {
        match pc {
            0x828FF200 => {
    //   block [0x828FF200..0x828FF23C)
	// 828FF200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FF204: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FF208: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FF20C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FF210: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828FF214: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828FF218: 388B9854  addi r4, r11, -0x67ac
	ctx.r[4].s64 = ctx.r[11].s64 + -26540;
	// 828FF21C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FF220: 4B92DCB1  bl 0x8222ced0
	ctx.lr = 0x828FF224;
	sub_8222CED0(ctx, base);
	// 828FF224: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FF228: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828FF22C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FF230: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FF234: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FF238: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FF248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FF248 size=304
    let mut pc: u32 = 0x828FF248;
    'dispatch: loop {
        match pc {
            0x828FF248 => {
    //   block [0x828FF248..0x828FF378)
	// 828FF248: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FF24C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FF250: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828FF254: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FF258: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FF25C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FF260: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828FF264: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828FF268: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828FF26C: 392B5148  addi r9, r11, 0x5148
	ctx.r[9].s64 = ctx.r[11].s64 + 20808;
	// 828FF270: 390A0B7C  addi r8, r10, 0xb7c
	ctx.r[8].s64 = ctx.r[10].s64 + 2940;
	// 828FF274: 909F0004  stw r4, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 828FF278: 9BDF0008  stb r30, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u8 ) };
	// 828FF27C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828FF280: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828FF284: 911F000C  stw r8, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 828FF288: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 828FF28C: 4B894BAD  bl 0x82193e38
	ctx.lr = 0x828FF290;
	sub_82193E38(ctx, base);
	// 828FF290: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 828FF294: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FF298: 3867D5C8  addi r3, r7, -0x2a38
	ctx.r[3].s64 = ctx.r[7].s64 + -10808;
	// 828FF29C: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 828FF2A0: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 828FF2A4: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 828FF2A8: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 828FF2AC: C003BEBC  lfs f0, -0x4144(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-16708 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FF2B0: 3C608349  lis r3, -0x7cb7
	ctx.r[3].s64 = -2092367872;
	// 828FF2B4: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FF378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FF378 size=132
    let mut pc: u32 = 0x828FF378;
    'dispatch: loop {
        match pc {
            0x828FF378 => {
    //   block [0x828FF378..0x828FF3E4)
	// 828FF378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FF37C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828FF380: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828FF384: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828FF388: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FF38C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FF390: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828FF394: 387F0064  addi r3, r31, 0x64
	ctx.r[3].s64 = ctx.r[31].s64 + 100;
	// 828FF398: 4B8B8781  bl 0x821b7b18
	ctx.lr = 0x828FF39C;
	sub_821B7B18(ctx, base);
	// 828FF39C: 387F0034  addi r3, r31, 0x34
	ctx.r[3].s64 = ctx.r[31].s64 + 52;
	// 828FF3A0: 4B915A39  bl 0x82214dd8
	ctx.lr = 0x828FF3A4;
	sub_82214DD8(ctx, base);
	// 828FF3A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828FF3A8: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828FF3AC: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 828FF3B0: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 828FF3B4: 4B894A85  bl 0x82193e38
	ctx.lr = 0x828FF3B8;
	sub_82193E38(ctx, base);
	// 828FF3B8: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 828FF3BC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828FF3C0: 38E92850  addi r7, r9, 0x2850
	ctx.r[7].s64 = ctx.r[9].s64 + 10320;
	// 828FF3C4: 57C607FE  clrlwi r6, r30, 0x1f
	ctx.r[6].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 828FF3C8: 911F0010  stw r8, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 828FF3CC: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 828FF3D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FF3D4: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 828FF3D8: 419A000C  beq cr6, 0x828ff3e4
	if ctx.cr[6].eq {
	pc = 0x828FF3E4; continue 'dispatch;
	}
	// 828FF3DC: 4B91C95D  bl 0x8221bd38
	ctx.lr = 0x828FF3E0;
	sub_8221BD38(ctx, base);
	// 828FF3E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x828FF3E4; continue 'dispatch;
            }
            0x828FF3E4 => {
    //   block [0x828FF3E4..0x828FF3FC)
	// 828FF3E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FF3E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828FF3EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828FF3F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828FF3F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828FF3F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FF400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FF400 size=1360
    let mut pc: u32 = 0x828FF400;
    'dispatch: loop {
        match pc {
            0x828FF400 => {
    //   block [0x828FF400..0x828FF470)
	// 828FF400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FF404: 483A9FFD  bl 0x82ca9400
	ctx.lr = 0x828FF408;
	sub_82CA93D0(ctx, base);
	// 828FF408: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FF40C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FF410: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828FF414: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 828FF418: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828FF41C: 409A052C  bne cr6, 0x828ff948
	if !ctx.cr[6].eq {
	pc = 0x828FF948; continue 'dispatch;
	}
	// 828FF420: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828FF424: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828FF428: 3BBF000C  addi r29, r31, 0xc
	ctx.r[29].s64 = ctx.r[31].s64 + 12;
	// 828FF42C: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 828FF430: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FF434: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 828FF438: 419A0038  beq cr6, 0x828ff470
	if ctx.cr[6].eq {
	pc = 0x828FF470; continue 'dispatch;
	}
	// 828FF43C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FF440: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FF444: 419A04B0  beq cr6, 0x828ff8f4
	if ctx.cr[6].eq {
	pc = 0x828FF8F4; continue 'dispatch;
	}
	// 828FF448: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828FF44C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FF450: 419A0020  beq cr6, 0x828ff470
	if ctx.cr[6].eq {
	pc = 0x828FF470; continue 'dispatch;
	}
	// 828FF454: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FF458: 4B8749E1  bl 0x82173e38
	ctx.lr = 0x828FF45C;
	sub_82173E38(ctx, base);
	// 828FF45C: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 828FF460: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828FF464: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FF468: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FF46C: 409A0008  bne cr6, 0x828ff474
	if !ctx.cr[6].eq {
	pc = 0x828FF474; continue 'dispatch;
	}
	pc = 0x828FF470; continue 'dispatch;
            }
            0x828FF470 => {
    //   block [0x828FF470..0x828FF474)
	// 828FF470: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x828FF474; continue 'dispatch;
            }
            0x828FF474 => {
    //   block [0x828FF474..0x828FF490)
	// 828FF474: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FF478: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FF47C: 419A0014  beq cr6, 0x828ff490
	if ctx.cr[6].eq {
	pc = 0x828FF490; continue 'dispatch;
	}
	// 828FF480: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FF484: 4B8749B5  bl 0x82173e38
	ctx.lr = 0x828FF488;
	sub_82173E38(ctx, base);
	// 828FF488: E9630014  ld r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	// 828FF48C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	pc = 0x828FF490; continue 'dispatch;
            }
            0x828FF490 => {
    //   block [0x828FF490..0x828FF6D4)
	// 828FF490: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828FF494: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828FF498: 388BFE9C  addi r4, r11, -0x164
	ctx.r[4].s64 = ctx.r[11].s64 + -356;
	// 828FF49C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF4A0: 4B92DA31  bl 0x8222ced0
	ctx.lr = 0x828FF4A4;
	sub_8222CED0(ctx, base);
	// 828FF4A4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828FF4A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FF4AC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828FF4B0: 4BBB3309  bl 0x824b27b8
	ctx.lr = 0x828FF4B4;
	sub_824B27B8(ctx, base);
	// 828FF4B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF4B8: 4B915921  bl 0x82214dd8
	ctx.lr = 0x828FF4BC;
	sub_82214DD8(ctx, base);
	// 828FF4BC: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828FF4C0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828FF4C4: 388A4DDC  addi r4, r10, 0x4ddc
	ctx.r[4].s64 = ctx.r[10].s64 + 19932;
	// 828FF4C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF4CC: 4B92DA05  bl 0x8222ced0
	ctx.lr = 0x828FF4D0;
	sub_8222CED0(ctx, base);
	// 828FF4D0: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 828FF4D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FF4D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF4DC: 4811DBCD  bl 0x82a1d0a8
	ctx.lr = 0x828FF4E0;
	sub_82A1D0A8(ctx, base);
	// 828FF4E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF4E4: 4B9158F5  bl 0x82214dd8
	ctx.lr = 0x828FF4E8;
	sub_82214DD8(ctx, base);
	// 828FF4E8: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828FF4EC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828FF4F0: 38894DEC  addi r4, r9, 0x4dec
	ctx.r[4].s64 = ctx.r[9].s64 + 19948;
	// 828FF4F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF4F8: 4B92D9D9  bl 0x8222ced0
	ctx.lr = 0x828FF4FC;
	sub_8222CED0(ctx, base);
	// 828FF4FC: 3B9F0034  addi r28, r31, 0x34
	ctx.r[28].s64 = ctx.r[31].s64 + 52;
	// 828FF500: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FF504: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828FF508: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF50C: 4811D9DD  bl 0x82a1cee8
	ctx.lr = 0x828FF510;
	sub_82A1CEE8(ctx, base);
	// 828FF510: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF514: 4B9158C5  bl 0x82214dd8
	ctx.lr = 0x828FF518;
	sub_82214DD8(ctx, base);
	// 828FF518: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828FF51C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828FF520: 38884E10  addi r4, r8, 0x4e10
	ctx.r[4].s64 = ctx.r[8].s64 + 19984;
	// 828FF524: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF528: 4B92D9A9  bl 0x8222ced0
	ctx.lr = 0x828FF52C;
	sub_8222CED0(ctx, base);
	// 828FF52C: 38BF0038  addi r5, r31, 0x38
	ctx.r[5].s64 = ctx.r[31].s64 + 56;
	// 828FF530: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FF534: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF538: 4811D911  bl 0x82a1ce48
	ctx.lr = 0x828FF53C;
	sub_82A1CE48(ctx, base);
	// 828FF53C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF540: 4B915899  bl 0x82214dd8
	ctx.lr = 0x828FF544;
	sub_82214DD8(ctx, base);
	// 828FF544: 3CE0820E  lis r7, -0x7df2
	ctx.r[7].s64 = -2113011712;
	// 828FF548: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828FF54C: 38874E20  addi r4, r7, 0x4e20
	ctx.r[4].s64 = ctx.r[7].s64 + 20000;
	// 828FF550: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF554: 4B92D97D  bl 0x8222ced0
	ctx.lr = 0x828FF558;
	sub_8222CED0(ctx, base);
	// 828FF558: 38BF0039  addi r5, r31, 0x39
	ctx.r[5].s64 = ctx.r[31].s64 + 57;
	// 828FF55C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FF560: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF564: 4811D8E5  bl 0x82a1ce48
	ctx.lr = 0x828FF568;
	sub_82A1CE48(ctx, base);
	// 828FF568: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF56C: 4B91586D  bl 0x82214dd8
	ctx.lr = 0x828FF570;
	sub_82214DD8(ctx, base);
	// 828FF570: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828FF574: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828FF578: 38864E30  addi r4, r6, 0x4e30
	ctx.r[4].s64 = ctx.r[6].s64 + 20016;
	// 828FF57C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF580: 4B92D951  bl 0x8222ced0
	ctx.lr = 0x828FF584;
	sub_8222CED0(ctx, base);
	// 828FF584: 38BF003A  addi r5, r31, 0x3a
	ctx.r[5].s64 = ctx.r[31].s64 + 58;
	// 828FF588: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FF58C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF590: 4811D8B9  bl 0x82a1ce48
	ctx.lr = 0x828FF594;
	sub_82A1CE48(ctx, base);
	// 828FF594: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF598: 4B915841  bl 0x82214dd8
	ctx.lr = 0x828FF59C;
	sub_82214DD8(ctx, base);
	// 828FF59C: 3C80820E  lis r4, -0x7df2
	ctx.r[4].s64 = -2113011712;
	// 828FF5A0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828FF5A4: 38844E40  addi r4, r4, 0x4e40
	ctx.r[4].s64 = ctx.r[4].s64 + 20032;
	// 828FF5A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF5AC: 4B92D925  bl 0x8222ced0
	ctx.lr = 0x828FF5B0;
	sub_8222CED0(ctx, base);
	// 828FF5B0: 38BF003B  addi r5, r31, 0x3b
	ctx.r[5].s64 = ctx.r[31].s64 + 59;
	// 828FF5B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FF5B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF5BC: 4811D88D  bl 0x82a1ce48
	ctx.lr = 0x828FF5C0;
	sub_82A1CE48(ctx, base);
	// 828FF5C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF5C4: 4B915815  bl 0x82214dd8
	ctx.lr = 0x828FF5C8;
	sub_82214DD8(ctx, base);
	// 828FF5C8: 3C60820E  lis r3, -0x7df2
	ctx.r[3].s64 = -2113011712;
	// 828FF5CC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828FF5D0: 38834E50  addi r4, r3, 0x4e50
	ctx.r[4].s64 = ctx.r[3].s64 + 20048;
	// 828FF5D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF5D8: 4B92D8F9  bl 0x8222ced0
	ctx.lr = 0x828FF5DC;
	sub_8222CED0(ctx, base);
	// 828FF5DC: 38BF003C  addi r5, r31, 0x3c
	ctx.r[5].s64 = ctx.r[31].s64 + 60;
	// 828FF5E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FF5E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF5E8: 4811D861  bl 0x82a1ce48
	ctx.lr = 0x828FF5EC;
	sub_82A1CE48(ctx, base);
	// 828FF5EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF5F0: 4B9157E9  bl 0x82214dd8
	ctx.lr = 0x828FF5F4;
	sub_82214DD8(ctx, base);
	// 828FF5F4: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828FF5F8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828FF5FC: 388B4E60  addi r4, r11, 0x4e60
	ctx.r[4].s64 = ctx.r[11].s64 + 20064;
	// 828FF600: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF604: 4B92D8CD  bl 0x8222ced0
	ctx.lr = 0x828FF608;
	sub_8222CED0(ctx, base);
	// 828FF608: 38BF003D  addi r5, r31, 0x3d
	ctx.r[5].s64 = ctx.r[31].s64 + 61;
	// 828FF60C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FF610: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF614: 4811D835  bl 0x82a1ce48
	ctx.lr = 0x828FF618;
	sub_82A1CE48(ctx, base);
	// 828FF618: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF61C: 4B9157BD  bl 0x82214dd8
	ctx.lr = 0x828FF620;
	sub_82214DD8(ctx, base);
	// 828FF620: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828FF624: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828FF628: 388A4E68  addi r4, r10, 0x4e68
	ctx.r[4].s64 = ctx.r[10].s64 + 20072;
	// 828FF62C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF630: 4B92D8A1  bl 0x8222ced0
	ctx.lr = 0x828FF634;
	sub_8222CED0(ctx, base);
	// 828FF634: 38BF003E  addi r5, r31, 0x3e
	ctx.r[5].s64 = ctx.r[31].s64 + 62;
	// 828FF638: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FF63C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF640: 4811D809  bl 0x82a1ce48
	ctx.lr = 0x828FF644;
	sub_82A1CE48(ctx, base);
	// 828FF644: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF648: 4B915791  bl 0x82214dd8
	ctx.lr = 0x828FF64C;
	sub_82214DD8(ctx, base);
	// 828FF64C: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 828FF650: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828FF654: 38894E74  addi r4, r9, 0x4e74
	ctx.r[4].s64 = ctx.r[9].s64 + 20084;
	// 828FF658: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF65C: 4B92D875  bl 0x8222ced0
	ctx.lr = 0x828FF660;
	sub_8222CED0(ctx, base);
	// 828FF660: 38BF003F  addi r5, r31, 0x3f
	ctx.r[5].s64 = ctx.r[31].s64 + 63;
	// 828FF664: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FF668: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF66C: 4811D7DD  bl 0x82a1ce48
	ctx.lr = 0x828FF670;
	sub_82A1CE48(ctx, base);
	// 828FF670: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF674: 4B915765  bl 0x82214dd8
	ctx.lr = 0x828FF678;
	sub_82214DD8(ctx, base);
	// 828FF678: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828FF67C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828FF680: 38884E84  addi r4, r8, 0x4e84
	ctx.r[4].s64 = ctx.r[8].s64 + 20100;
	// 828FF684: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF688: 4B92D849  bl 0x8222ced0
	ctx.lr = 0x828FF68C;
	sub_8222CED0(ctx, base);
	// 828FF68C: 38BF0040  addi r5, r31, 0x40
	ctx.r[5].s64 = ctx.r[31].s64 + 64;
	// 828FF690: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828FF694: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF698: 4811D7B1  bl 0x82a1ce48
	ctx.lr = 0x828FF69C;
	sub_82A1CE48(ctx, base);
	// 828FF69C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF6A0: 4B915739  bl 0x82214dd8
	ctx.lr = 0x828FF6A4;
	sub_82214DD8(ctx, base);
	// 828FF6A4: 3CE0820E  lis r7, -0x7df2
	ctx.r[7].s64 = -2113011712;
	// 828FF6A8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828FF6AC: 38874E94  addi r4, r7, 0x4e94
	ctx.r[4].s64 = ctx.r[7].s64 + 20116;
	// 828FF6B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF6B4: 4B92D81D  bl 0x8222ced0
	ctx.lr = 0x828FF6B8;
	sub_8222CED0(ctx, base);
	// 828FF6B8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FF6BC: 3BABFFDF  addi r29, r11, -0x21
	ctx.r[29].s64 = ctx.r[11].s64 + -33;
	// 828FF6C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828FF6C4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FF6C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FF6CC: 419A0008  beq cr6, 0x828ff6d4
	if ctx.cr[6].eq {
	pc = 0x828FF6D4; continue 'dispatch;
	}
	// 828FF6D0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828FF6D4; continue 'dispatch;
            }
            0x828FF6D4 => {
    //   block [0x828FF6D4..0x828FF710)
	// 828FF6D4: 38BF0044  addi r5, r31, 0x44
	ctx.r[5].s64 = ctx.r[31].s64 + 68;
	// 828FF6D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FF6DC: 4BB81175  bl 0x82480850
	ctx.lr = 0x828FF6E0;
	sub_82480850(ctx, base);
	// 828FF6E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF6E4: 4B9156F5  bl 0x82214dd8
	ctx.lr = 0x828FF6E8;
	sub_82214DD8(ctx, base);
	// 828FF6E8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828FF6EC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828FF6F0: 388B4EA4  addi r4, r11, 0x4ea4
	ctx.r[4].s64 = ctx.r[11].s64 + 20132;
	// 828FF6F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF6F8: 4B92D7D9  bl 0x8222ced0
	ctx.lr = 0x828FF6FC;
	sub_8222CED0(ctx, base);
	// 828FF6FC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FF700: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828FF704: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FF708: 419A0008  beq cr6, 0x828ff710
	if ctx.cr[6].eq {
	pc = 0x828FF710; continue 'dispatch;
	}
	// 828FF70C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828FF710; continue 'dispatch;
            }
            0x828FF710 => {
    //   block [0x828FF710..0x828FF74C)
	// 828FF710: 38BF0048  addi r5, r31, 0x48
	ctx.r[5].s64 = ctx.r[31].s64 + 72;
	// 828FF714: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FF718: 4BB81139  bl 0x82480850
	ctx.lr = 0x828FF71C;
	sub_82480850(ctx, base);
	// 828FF71C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF720: 4B9156B9  bl 0x82214dd8
	ctx.lr = 0x828FF724;
	sub_82214DD8(ctx, base);
	// 828FF724: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828FF728: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828FF72C: 388B4EB0  addi r4, r11, 0x4eb0
	ctx.r[4].s64 = ctx.r[11].s64 + 20144;
	// 828FF730: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF734: 4B92D79D  bl 0x8222ced0
	ctx.lr = 0x828FF738;
	sub_8222CED0(ctx, base);
	// 828FF738: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FF73C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828FF740: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FF744: 419A0008  beq cr6, 0x828ff74c
	if ctx.cr[6].eq {
	pc = 0x828FF74C; continue 'dispatch;
	}
	// 828FF748: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828FF74C; continue 'dispatch;
            }
            0x828FF74C => {
    //   block [0x828FF74C..0x828FF790)
	// 828FF74C: 38BF004C  addi r5, r31, 0x4c
	ctx.r[5].s64 = ctx.r[31].s64 + 76;
	// 828FF750: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FF754: 4BB810FD  bl 0x82480850
	ctx.lr = 0x828FF758;
	sub_82480850(ctx, base);
	// 828FF758: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF75C: 4B91567D  bl 0x82214dd8
	ctx.lr = 0x828FF760;
	sub_82214DD8(ctx, base);
	// 828FF760: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828FF764: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828FF768: 388B293C  addi r4, r11, 0x293c
	ctx.r[4].s64 = ctx.r[11].s64 + 10556;
	// 828FF76C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF770: 4B92D761  bl 0x8222ced0
	ctx.lr = 0x828FF774;
	sub_8222CED0(ctx, base);
	// 828FF774: 815F0050  lwz r10, 0x50(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FF778: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FF77C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828FF780: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FF784: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828FF788: 419A0008  beq cr6, 0x828ff790
	if ctx.cr[6].eq {
	pc = 0x828FF790; continue 'dispatch;
	}
	// 828FF78C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828FF790; continue 'dispatch;
            }
            0x828FF790 => {
    //   block [0x828FF790..0x828FF7D4)
	// 828FF790: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828FF794: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FF798: 4BB81031  bl 0x824807c8
	ctx.lr = 0x828FF79C;
	sub_824807C8(ctx, base);
	// 828FF79C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828FF7A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF7A4: 917F0050  stw r11, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828FF7A8: 4B915631  bl 0x82214dd8
	ctx.lr = 0x828FF7AC;
	sub_82214DD8(ctx, base);
	// 828FF7AC: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828FF7B0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828FF7B4: 388A4EC0  addi r4, r10, 0x4ec0
	ctx.r[4].s64 = ctx.r[10].s64 + 20160;
	// 828FF7B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF7BC: 4B92D715  bl 0x8222ced0
	ctx.lr = 0x828FF7C0;
	sub_8222CED0(ctx, base);
	// 828FF7C0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FF7C4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828FF7C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FF7CC: 419A0008  beq cr6, 0x828ff7d4
	if ctx.cr[6].eq {
	pc = 0x828FF7D4; continue 'dispatch;
	}
	// 828FF7D0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828FF7D4; continue 'dispatch;
            }
            0x828FF7D4 => {
    //   block [0x828FF7D4..0x828FF810)
	// 828FF7D4: 38BF0054  addi r5, r31, 0x54
	ctx.r[5].s64 = ctx.r[31].s64 + 84;
	// 828FF7D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FF7DC: 4BB80FED  bl 0x824807c8
	ctx.lr = 0x828FF7E0;
	sub_824807C8(ctx, base);
	// 828FF7E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF7E4: 4B9155F5  bl 0x82214dd8
	ctx.lr = 0x828FF7E8;
	sub_82214DD8(ctx, base);
	// 828FF7E8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828FF7EC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828FF7F0: 388B4ED4  addi r4, r11, 0x4ed4
	ctx.r[4].s64 = ctx.r[11].s64 + 20180;
	// 828FF7F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF7F8: 4B92D6D9  bl 0x8222ced0
	ctx.lr = 0x828FF7FC;
	sub_8222CED0(ctx, base);
	// 828FF7FC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FF800: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828FF804: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FF808: 419A0008  beq cr6, 0x828ff810
	if ctx.cr[6].eq {
	pc = 0x828FF810; continue 'dispatch;
	}
	// 828FF80C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828FF810; continue 'dispatch;
            }
            0x828FF810 => {
    //   block [0x828FF810..0x828FF84C)
	// 828FF810: 38BF0058  addi r5, r31, 0x58
	ctx.r[5].s64 = ctx.r[31].s64 + 88;
	// 828FF814: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FF818: 4BB80FB1  bl 0x824807c8
	ctx.lr = 0x828FF81C;
	sub_824807C8(ctx, base);
	// 828FF81C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF820: 4B9155B9  bl 0x82214dd8
	ctx.lr = 0x828FF824;
	sub_82214DD8(ctx, base);
	// 828FF824: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828FF828: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828FF82C: 388B4EEC  addi r4, r11, 0x4eec
	ctx.r[4].s64 = ctx.r[11].s64 + 20204;
	// 828FF830: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF834: 4B92D69D  bl 0x8222ced0
	ctx.lr = 0x828FF838;
	sub_8222CED0(ctx, base);
	// 828FF838: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FF83C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828FF840: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FF844: 419A0008  beq cr6, 0x828ff84c
	if ctx.cr[6].eq {
	pc = 0x828FF84C; continue 'dispatch;
	}
	// 828FF848: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828FF84C; continue 'dispatch;
            }
            0x828FF84C => {
    //   block [0x828FF84C..0x828FF888)
	// 828FF84C: 38BF005C  addi r5, r31, 0x5c
	ctx.r[5].s64 = ctx.r[31].s64 + 92;
	// 828FF850: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FF854: 4BB80FFD  bl 0x82480850
	ctx.lr = 0x828FF858;
	sub_82480850(ctx, base);
	// 828FF858: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF85C: 4B91557D  bl 0x82214dd8
	ctx.lr = 0x828FF860;
	sub_82214DD8(ctx, base);
	// 828FF860: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828FF864: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 828FF868: 388B4F00  addi r4, r11, 0x4f00
	ctx.r[4].s64 = ctx.r[11].s64 + 20224;
	// 828FF86C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF870: 4B92D661  bl 0x8222ced0
	ctx.lr = 0x828FF874;
	sub_8222CED0(ctx, base);
	// 828FF874: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FF878: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828FF87C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FF880: 419A0008  beq cr6, 0x828ff888
	if ctx.cr[6].eq {
	pc = 0x828FF888; continue 'dispatch;
	}
	// 828FF884: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828FF888; continue 'dispatch;
            }
            0x828FF888 => {
    //   block [0x828FF888..0x828FF8C4)
	// 828FF888: 38BF0060  addi r5, r31, 0x60
	ctx.r[5].s64 = ctx.r[31].s64 + 96;
	// 828FF88C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FF890: 4BB80FC1  bl 0x82480850
	ctx.lr = 0x828FF894;
	sub_82480850(ctx, base);
	// 828FF894: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF898: 4B915541  bl 0x82214dd8
	ctx.lr = 0x828FF89C;
	sub_82214DD8(ctx, base);
	// 828FF89C: 574B063E  clrlwi r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 828FF8A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FF8A4: 409A00A4  bne cr6, 0x828ff948
	if !ctx.cr[6].eq {
	pc = 0x828FF948; continue 'dispatch;
	}
	// 828FF8A8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828FF8AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FF8B0: 409A0014  bne cr6, 0x828ff8c4
	if !ctx.cr[6].eq {
	pc = 0x828FF8C4; continue 'dispatch;
	}
	// 828FF8B4: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828FF8B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FF8BC: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828FF8C0: 419A0008  beq cr6, 0x828ff8c8
	if ctx.cr[6].eq {
	pc = 0x828FF8C8; continue 'dispatch;
	}
	pc = 0x828FF8C4; continue 'dispatch;
            }
            0x828FF8C4 => {
    //   block [0x828FF8C4..0x828FF8C8)
	// 828FF8C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x828FF8C8; continue 'dispatch;
            }
            0x828FF8C8 => {
    //   block [0x828FF8C8..0x828FF8F4)
	// 828FF8C8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828FF8CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FF8D0: 419A0048  beq cr6, 0x828ff918
	if ctx.cr[6].eq {
	pc = 0x828FF918; continue 'dispatch;
	}
	// 828FF8D4: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 828FF8D8: 4B91F981  bl 0x8221f258
	ctx.lr = 0x828FF8DC;
	sub_8221F258(ctx, base);
	// 828FF8DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FF8E0: 419A0020  beq cr6, 0x828ff900
	if ctx.cr[6].eq {
	pc = 0x828FF900; continue 'dispatch;
	}
	// 828FF8E4: 93630000  stw r27, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 828FF8E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FF8EC: 93630004  stw r27, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 828FF8F0: 48000014  b 0x828ff904
	pc = 0x828FF904; continue 'dispatch;
            }
            0x828FF8F4 => {
    //   block [0x828FF8F4..0x828FF900)
	// 828FF8F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FF8F8: 4B894541  bl 0x82193e38
	ctx.lr = 0x828FF8FC;
	sub_82193E38(ctx, base);
	// 828FF8FC: 4BFFFB74  b 0x828ff470
	pc = 0x828FF470; continue 'dispatch;
            }
            0x828FF900 => {
    //   block [0x828FF900..0x828FF904)
	// 828FF900: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	pc = 0x828FF904; continue 'dispatch;
            }
            0x828FF904 => {
    //   block [0x828FF904..0x828FF918)
	// 828FF904: 387F0064  addi r3, r31, 0x64
	ctx.r[3].s64 = ctx.r[31].s64 + 100;
	// 828FF908: 4BE12801  bl 0x82712108
	ctx.lr = 0x828FF90C;
	sub_82712108(ctx, base);
	// 828FF90C: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 828FF910: E9410058  ld r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828FF914: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	pc = 0x828FF918; continue 'dispatch;
            }
            0x828FF918 => {
    //   block [0x828FF918..0x828FF948)
	// 828FF918: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FF91C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FF920: 419A0028  beq cr6, 0x828ff948
	if ctx.cr[6].eq {
	pc = 0x828FF948; continue 'dispatch;
	}
	// 828FF924: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FF928: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828FF92C: 419A001C  beq cr6, 0x828ff948
	if ctx.cr[6].eq {
	pc = 0x828FF948; continue 'dispatch;
	}
	// 828FF930: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828FF934: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF938: 4B8F0909  bl 0x821f0240
	ctx.lr = 0x828FF93C;
	sub_821F0240(ctx, base);
	// 828FF93C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FF940: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FF944: 48000115  bl 0x828ffa58
	ctx.lr = 0x828FF948;
	sub_828FFA58(ctx, base);
	pc = 0x828FF948; continue 'dispatch;
            }
            0x828FF948 => {
    //   block [0x828FF948..0x828FF950)
	// 828FF948: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828FF94C: 483A9B04  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FF950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FF950 size=264
    let mut pc: u32 = 0x828FF950;
    'dispatch: loop {
        match pc {
            0x828FF950 => {
    //   block [0x828FF950..0x828FF9DC)
	// 828FF950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FF954: 483A9AB5  bl 0x82ca9408
	ctx.lr = 0x828FF958;
	sub_82CA93D0(ctx, base);
	// 828FF958: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FF95C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FF960: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828FF964: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FF968: 38EA4F14  addi r7, r10, 0x4f14
	ctx.r[7].s64 = ctx.r[10].s64 + 20244;
	// 828FF96C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FF970: 80CB001C  lwz r6, 0x1c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 828FF974: 80AB0020  lwz r5, 0x20(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828FF978: 90C10050  stw r6, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u32 ) };
	// 828FF97C: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 828FF980: 4B8B2B79  bl 0x821b24f8
	ctx.lr = 0x828FF984;
	sub_821B24F8(ctx, base);
	// 828FF984: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 828FF988: 4B9AA061  bl 0x822a99e8
	ctx.lr = 0x828FF98C;
	sub_822A99E8(ctx, base);
	// 828FF98C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FF990: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828FF994: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828FF998: 419A0044  beq cr6, 0x828ff9dc
	if ctx.cr[6].eq {
	pc = 0x828FF9DC; continue 'dispatch;
	}
	// 828FF99C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828FF9A0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828FF9A4: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 828FF9A8: 386B4F28  addi r3, r11, 0x4f28
	ctx.r[3].s64 = ctx.r[11].s64 + 20264;
	// 828FF9AC: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 828FF9B0: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 828FF9B4: 4B8F43A5  bl 0x821f3d58
	ctx.lr = 0x828FF9B8;
	sub_821F3D58(ctx, base);
	// 828FF9B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FF9BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FF9C0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828FF9C4: 4B97BE5D  bl 0x8227b820
	ctx.lr = 0x828FF9C8;
	sub_8227B820(ctx, base);
	// 828FF9C8: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828FF9CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FF9D0: 419A000C  beq cr6, 0x828ff9dc
	if ctx.cr[6].eq {
	pc = 0x828FF9DC; continue 'dispatch;
	}
	// 828FF9D4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828FF9D8: 917E0030  stw r11, 0x30(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	pc = 0x828FF9DC; continue 'dispatch;
            }
            0x828FF9DC => {
    //   block [0x828FF9DC..0x828FFA50)
	// 828FF9DC: 809E0064  lwz r4, 0x64(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 828FF9E0: 3BFE0064  addi r31, r30, 0x64
	ctx.r[31].s64 = ctx.r[30].s64 + 100;
	// 828FF9E4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828FF9E8: 419A0068  beq cr6, 0x828ffa50
	if ctx.cr[6].eq {
	pc = 0x828FFA50; continue 'dispatch;
	}
	// 828FF9EC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 828FF9F0: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 828FF9F4: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828FF9F8: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 828FF9FC: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828FFA00: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FFA04: 4B964A85  bl 0x82264488
	ctx.lr = 0x828FFA08;
	sub_82264488(ctx, base);
	// 828FFA08: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 828FFA0C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828FFA10: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FFA14: 38C70B7C  addi r6, r7, 0xb7c
	ctx.r[6].s64 = ctx.r[7].s64 + 2940;
	// 828FFA18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FFA1C: 90C10050  stw r6, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u32 ) };
	// 828FFA20: 4B914E79  bl 0x82214898
	ctx.lr = 0x828FFA24;
	sub_82214898(ctx, base);
	// 828FFA24: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FFA28: 387E000C  addi r3, r30, 0xc
	ctx.r[3].s64 = ctx.r[30].s64 + 12;
	// 828FFA2C: 4BBD249D  bl 0x824d1ec8
	ctx.lr = 0x828FFA30;
	sub_824D1EC8(ctx, base);
	// 828FFA30: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 828FFA34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FFA38: 38850B7C  addi r4, r5, 0xb7c
	ctx.r[4].s64 = ctx.r[5].s64 + 2940;
	// 828FFA3C: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 828FFA40: 4B8943F9  bl 0x82193e38
	ctx.lr = 0x828FFA44;
	sub_82193E38(ctx, base);
	// 828FFA44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FFA48: 4B8B80D1  bl 0x821b7b18
	ctx.lr = 0x828FFA4C;
	sub_821B7B18(ctx, base);
	// 828FFA4C: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x828FFA50; continue 'dispatch;
            }
            0x828FFA50 => {
    //   block [0x828FFA50..0x828FFA58)
	// 828FFA50: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828FFA54: 483A9A04  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FFA58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FFA58 size=120
    let mut pc: u32 = 0x828FFA58;
    'dispatch: loop {
        match pc {
            0x828FFA58 => {
    //   block [0x828FFA58..0x828FFA8C)
	// 828FFA58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FFA5C: 483A99B1  bl 0x82ca940c
	ctx.lr = 0x828FFA60;
	sub_82CA93D0(ctx, base);
	// 828FFA60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FFA64: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828FFA68: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 828FFA6C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FFA70: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FFA74: 83AA6DA0  lwz r29, 0x6da0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28064 as u32) ) } as u64;
	// 828FFA78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FFA7C: 409A0010  bne cr6, 0x828ffa8c
	if !ctx.cr[6].eq {
	pc = 0x828FFA8C; continue 'dispatch;
	}
	// 828FFA80: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828FFA84: 386BFFDF  addi r3, r11, -0x21
	ctx.r[3].s64 = ctx.r[11].s64 + -33;
	// 828FFA88: 48000008  b 0x828ffa90
	pc = 0x828FFA90; continue 'dispatch;
            }
            0x828FFA8C => {
    //   block [0x828FFA8C..0x828FFA90)
	// 828FFA8C: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828FFA90; continue 'dispatch;
            }
            0x828FFA90 => {
    //   block [0x828FFA90..0x828FFAC0)
	// 828FFA90: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 828FFA94: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 828FFA98: 4B8F42C1  bl 0x821f3d58
	ctx.lr = 0x828FFA9C;
	sub_821F3D58(ctx, base);
	// 828FFA9C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828FFAA0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828FFAA4: 481003B5  bl 0x829ffe58
	ctx.lr = 0x828FFAA8;
	sub_829FFE58(ctx, base);
	// 828FFAA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828FFAAC: 419A0014  beq cr6, 0x828ffac0
	if ctx.cr[6].eq {
	pc = 0x828FFAC0; continue 'dispatch;
	}
	// 828FFAB0: 907E0030  stw r3, 0x30(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[3].u32 ) };
	// 828FFAB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828FFAB8: 387E0034  addi r3, r30, 0x34
	ctx.r[3].s64 = ctx.r[30].s64 + 52;
	// 828FFABC: 4B9656E5  bl 0x822651a0
	ctx.lr = 0x828FFAC0;
	sub_822651A0(ctx, base);
	pc = 0x828FFAC0; continue 'dispatch;
            }
            0x828FFAC0 => {
    //   block [0x828FFAC0..0x828FFAD0)
	// 828FFAC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FFAC4: 4B915315  bl 0x82214dd8
	ctx.lr = 0x828FFAC8;
	sub_82214DD8(ctx, base);
	// 828FFAC8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828FFACC: 483A9990  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FFAD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828FFAD0 size=436
    let mut pc: u32 = 0x828FFAD0;
    'dispatch: loop {
        match pc {
            0x828FFAD0 => {
    //   block [0x828FFAD0..0x828FFC78)
	// 828FFAD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FFAD4: 483A9939  bl 0x82ca940c
	ctx.lr = 0x828FFAD8;
	sub_82CA93D0(ctx, base);
	// 828FFAD8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828FFADC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FFAE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FFAE4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828FFAE8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828FFAEC: 419A018C  beq cr6, 0x828ffc78
	if ctx.cr[6].eq {
	pc = 0x828FFC78; continue 'dispatch;
	}
	// 828FFAF0: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 828FFAF4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828FFAF8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FFAFC: 419A017C  beq cr6, 0x828ffc78
	if ctx.cr[6].eq {
	pc = 0x828FFC78; continue 'dispatch;
	}
	// 828FFB00: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828FFB04: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828FFB08: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 828FFB0C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828FFB10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FFB14: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 828FFB18: 4B914D81  bl 0x82214898
	ctx.lr = 0x828FFB1C;
	sub_82214898(ctx, base);
	// 828FFB1C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828FFB20: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828FFB24: 4BBD23A5  bl 0x824d1ec8
	ctx.lr = 0x828FFB28;
	sub_824D1EC8(ctx, base);
	// 828FFB28: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 828FFB2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828FFB30: 38E80B7C  addi r7, r8, 0xb7c
	ctx.r[7].s64 = ctx.r[8].s64 + 2940;
	// 828FFB34: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 828FFB38: 4B894301  bl 0x82193e38
	ctx.lr = 0x828FFB3C;
	sub_82193E38(ctx, base);
	// 828FFB3C: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828FFB40: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828FFB44: 38864E50  addi r4, r6, 0x4e50
	ctx.r[4].s64 = ctx.r[6].s64 + 20048;
	// 828FFB48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FFB4C: 4B8E476D  bl 0x821e42b8
	ctx.lr = 0x828FFB50;
	sub_821E42B8(ctx, base);
	// 828FFB50: 987F003C  stb r3, 0x3c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[3].u8 ) };
	// 828FFB54: 3C80820E  lis r4, -0x7df2
	ctx.r[4].s64 = -2113011712;
	// 828FFB58: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828FFB5C: 38844E10  addi r4, r4, 0x4e10
	ctx.r[4].s64 = ctx.r[4].s64 + 19984;
	// 828FFB60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FFB64: 4B8E4755  bl 0x821e42b8
	ctx.lr = 0x828FFB68;
	sub_821E42B8(ctx, base);
	// 828FFB68: 987F0038  stb r3, 0x38(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[3].u8 ) };
	// 828FFB6C: 3C60820E  lis r3, -0x7df2
	ctx.r[3].s64 = -2113011712;
	// 828FFB70: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828FFB74: 38834E20  addi r4, r3, 0x4e20
	ctx.r[4].s64 = ctx.r[3].s64 + 20000;
	// 828FFB78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FFB7C: 4B8E473D  bl 0x821e42b8
	ctx.lr = 0x828FFB80;
	sub_821E42B8(ctx, base);
	// 828FFB80: 987F0039  stb r3, 0x39(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(57 as u32), ctx.r[3].u8 ) };
	// 828FFB84: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828FFB88: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828FFB8C: 388B4E60  addi r4, r11, 0x4e60
	ctx.r[4].s64 = ctx.r[11].s64 + 20064;
	// 828FFB90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FFB94: 4B8E4725  bl 0x821e42b8
	ctx.lr = 0x828FFB98;
	sub_821E42B8(ctx, base);
	// 828FFB98: 987F003D  stb r3, 0x3d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(61 as u32), ctx.r[3].u8 ) };
	// 828FFB9C: 3FA0820A  lis r29, -0x7df6
	ctx.r[29].s64 = -2113273856;
	// 828FFBA0: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828FFBA4: 393DBE04  addi r9, r29, -0x41fc
	ctx.r[9].s64 = ctx.r[29].s64 + -16892;
	// 828FFBA8: 388A4F34  addi r4, r10, 0x4f34
	ctx.r[4].s64 = ctx.r[10].s64 + 20276;
	// 828FFBAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FFBB0: C029D4C8  lfs f1, -0x2b38(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-11064 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828FFBB4: 4B8DF8A5  bl 0x821df458
	ctx.lr = 0x828FFBB8;
	sub_821DF458(ctx, base);
	// 828FFBB8: D03F0044  stfs f1, 0x44(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 828FFBBC: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 828FFBC0: C3FDBE04  lfs f31, -0x41fc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-16892 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828FFBC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FFBC8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828FFBCC: 38884F48  addi r4, r8, 0x4f48
	ctx.r[4].s64 = ctx.r[8].s64 + 20296;
	// 828FFBD0: 4B8DF889  bl 0x821df458
	ctx.lr = 0x828FFBD4;
	sub_821DF458(ctx, base);
	// 828FFBD4: D03F0048  stfs f1, 0x48(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 828FFBD8: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 828FFBDC: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 828FFBE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FFBE4: 38864F58  addi r4, r6, 0x4f58
	ctx.r[4].s64 = ctx.r[6].s64 + 20312;
	// 828FFBE8: C0270A54  lfs f1, 0xa54(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2644 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828FFBEC: 4B8DF86D  bl 0x821df458
	ctx.lr = 0x828FFBF0;
	sub_821DF458(ctx, base);
	// 828FFBF0: D03F004C  stfs f1, 0x4c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 828FFBF4: 3C80820C  lis r4, -0x7df4
	ctx.r[4].s64 = -2113142784;
	// 828FFBF8: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 828FFBFC: 3884293C  addi r4, r4, 0x293c
	ctx.r[4].s64 = ctx.r[4].s64 + 10556;
	// 828FFC00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FFC04: 4B9ABCBD  bl 0x822ab8c0
	ctx.lr = 0x828FFC08;
	sub_822AB8C0(ctx, base);
	// 828FFC08: 907F0050  stw r3, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828FFC0C: 3C60820E  lis r3, -0x7df2
	ctx.r[3].s64 = -2113011712;
	// 828FFC10: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828FFC14: 38834F6C  addi r4, r3, 0x4f6c
	ctx.r[4].s64 = ctx.r[3].s64 + 20332;
	// 828FFC18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FFC1C: 4B8E469D  bl 0x821e42b8
	ctx.lr = 0x828FFC20;
	sub_821E42B8(ctx, base);
	// 828FFC20: 987F0040  stb r3, 0x40(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[3].u8 ) };
	// 828FFC24: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828FFC28: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828FFC2C: 388B4E30  addi r4, r11, 0x4e30
	ctx.r[4].s64 = ctx.r[11].s64 + 20016;
	// 828FFC30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FFC34: 4B8E4685  bl 0x821e42b8
	ctx.lr = 0x828FFC38;
	sub_821E42B8(ctx, base);
	// 828FFC38: 987F003A  stb r3, 0x3a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(58 as u32), ctx.r[3].u8 ) };
	// 828FFC3C: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828FFC40: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828FFC44: 388A4E40  addi r4, r10, 0x4e40
	ctx.r[4].s64 = ctx.r[10].s64 + 20032;
	// 828FFC48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FFC4C: 4B8E466D  bl 0x821e42b8
	ctx.lr = 0x828FFC50;
	sub_821E42B8(ctx, base);
	// 828FFC50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828FFC54: C01F0048  lfs f0, 0x48(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828FFC58: 987F003B  stb r3, 0x3b(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(59 as u32), ctx.r[3].u8 ) };
	// 828FFC5C: C1BF004C  lfs f13, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828FFC60: 997F003E  stb r11, 0x3e(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(62 as u32), ctx.r[11].u8 ) };
	// 828FFC64: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828FFC68: 997F003F  stb r11, 0x3f(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(63 as u32), ctx.r[11].u8 ) };
	// 828FFC6C: 4198000C  blt cr6, 0x828ffc78
	if ctx.cr[6].lt {
	pc = 0x828FFC78; continue 'dispatch;
	}
	// 828FFC70: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 828FFC74: D01F004C  stfs f0, 0x4c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	pc = 0x828FFC78; continue 'dispatch;
            }
            0x828FFC78 => {
    //   block [0x828FFC78..0x828FFC84)
	// 828FFC78: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828FFC7C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828FFC80: 483A97DC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FFC88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FFC88 size=340
    let mut pc: u32 = 0x828FFC88;
    'dispatch: loop {
        match pc {
            0x828FFC88 => {
    //   block [0x828FFC88..0x828FFDDC)
	// 828FFC88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FFC8C: 483A9781  bl 0x82ca940c
	ctx.lr = 0x828FFC90;
	sub_82CA93D0(ctx, base);
	// 828FFC90: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828FFC94: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FFC98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828FFC9C: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 828FFCA0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828FFCA4: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828FFCA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828FFCAC: 388A4E10  addi r4, r10, 0x4e10
	ctx.r[4].s64 = ctx.r[10].s64 + 19984;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828FFDE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828FFDE0 size=1228
    let mut pc: u32 = 0x828FFDE0;
    'dispatch: loop {
        match pc {
            0x828FFDE0 => {
    //   block [0x828FFDE0..0x828FFE3C)
	// 828FFDE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828FFDE4: 483A9625  bl 0x82ca9408
	ctx.lr = 0x828FFDE8;
	sub_82CA93D0(ctx, base);
	// 828FFDE8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828FFDEC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828FFDF0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828FFDF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FFDF8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828FFDFC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828FFE00: 4B8E1DA9  bl 0x821e1ba8
	ctx.lr = 0x828FFE04;
	sub_821E1BA8(ctx, base);
	// 828FFE04: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828FFE08: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 828FFE0C: 388B4F80  addi r4, r11, 0x4f80
	ctx.r[4].s64 = ctx.r[11].s64 + 20352;
	// 828FFE10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FFE14: 481246C5  bl 0x82a244d8
	ctx.lr = 0x828FFE18;
	sub_82A244D8(ctx, base);
	// 828FFE18: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828FFE1C: 387E000C  addi r3, r30, 0xc
	ctx.r[3].s64 = ctx.r[30].s64 + 12;
	// 828FFE20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828FFE24: 419A001C  beq cr6, 0x828ffe40
	if ctx.cr[6].eq {
	pc = 0x828FFE40; continue 'dispatch;
	}
	// 828FFE28: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828FFE2C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828FFE30: 419A000C  beq cr6, 0x828ffe3c
	if ctx.cr[6].eq {
	pc = 0x828FFE3C; continue 'dispatch;
	}
	// 828FFE34: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 828FFE38: 4800000C  b 0x828ffe44
	pc = 0x828FFE44; continue 'dispatch;
            }
            0x828FFE3C => {
    //   block [0x828FFE3C..0x828FFE40)
	// 828FFE3C: 4B893FFD  bl 0x82193e38
	ctx.lr = 0x828FFE40;
	sub_82193E38(ctx, base);
	pc = 0x828FFE40; continue 'dispatch;
            }
            0x828FFE40 => {
    //   block [0x828FFE40..0x828FFE44)
	// 828FFE40: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x828FFE44; continue 'dispatch;
            }
            0x828FFE44 => {
    //   block [0x828FFE44..0x829002AC)
	// 828FFE44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FFE48: 4BAA3179  bl 0x823a2fc0
	ctx.lr = 0x828FFE4C;
	sub_823A2FC0(ctx, base);
	// 828FFE4C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FFE50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FFE54: 388BFFE8  addi r4, r11, -0x18
	ctx.r[4].s64 = ctx.r[11].s64 + -24;
	// 828FFE58: 38CBFFF8  addi r6, r11, -8
	ctx.r[6].s64 = ctx.r[11].s64 + -8;
	// 828FFE5C: 38ABFFF0  addi r5, r11, -0x10
	ctx.r[5].s64 = ctx.r[11].s64 + -16;
	// 828FFE60: 4B928EC9  bl 0x82228d28
	ctx.lr = 0x828FFE64;
	sub_82228D28(ctx, base);
	// 828FFE64: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828FFE68: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 828FFE6C: 392BFFF0  addi r9, r11, -0x10
	ctx.r[9].s64 = ctx.r[11].s64 + -16;
	// 828FFE70: 38A0000E  li r5, 0xe
	ctx.r[5].s64 = 14;
	// 828FFE74: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828FFE78: 388A4DDC  addi r4, r10, 0x4ddc
	ctx.r[4].s64 = ctx.r[10].s64 + 19932;
	// 828FFE7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828FFE80: 48124659  bl 0x82a244d8
	ctx.lr = 0x828FFE84;
	sub_82A244D8(ctx, base);
	// 828FFE84: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 828FFE88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829002B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829002B8 size=152
    let mut pc: u32 = 0x829002B8;
    'dispatch: loop {
        match pc {
            0x829002B8 => {
    //   block [0x829002B8..0x82900338)
	// 829002B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829002BC: 483A9151  bl 0x82ca940c
	ctx.lr = 0x829002C0;
	sub_82CA93D0(ctx, base);
	// 829002C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829002C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829002C8: 3BDF000C  addi r30, r31, 0xc
	ctx.r[30].s64 = ctx.r[31].s64 + 12;
	// 829002CC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 829002D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829002D4: 419A006C  beq cr6, 0x82900340
	if ctx.cr[6].eq {
	pc = 0x82900340; continue 'dispatch;
	}
	// 829002D8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829002DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829002E0: 419A0058  beq cr6, 0x82900338
	if ctx.cr[6].eq {
	pc = 0x82900338; continue 'dispatch;
	}
	// 829002E4: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829002E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829002EC: 419A0054  beq cr6, 0x82900340
	if ctx.cr[6].eq {
	pc = 0x82900340; continue 'dispatch;
	}
	// 829002F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829002F4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829002F8: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 829002FC: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82900300: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82900304: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82900308: 4B893B31  bl 0x82193e38
	ctx.lr = 0x8290030C;
	sub_82193E38(ctx, base);
	// 8290030C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82900310: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82900314: 4BBD1BB5  bl 0x824d1ec8
	ctx.lr = 0x82900318;
	sub_824D1EC8(ctx, base);
	// 82900318: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8290031C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82900320: 39090B7C  addi r8, r9, 0xb7c
	ctx.r[8].s64 = ctx.r[9].s64 + 2940;
	// 82900324: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82900328: 4B893B11  bl 0x82193e38
	ctx.lr = 0x8290032C;
	sub_82193E38(ctx, base);
	// 8290032C: 9BBF003E  stb r29, 0x3e(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(62 as u32), ctx.r[29].u8 ) };
	// 82900330: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82900334: 483A9128  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82900338 => {
    //   block [0x82900338..0x82900340)
	// 82900338: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8290033C: 4B893AFD  bl 0x82193e38
	ctx.lr = 0x82900340;
	sub_82193E38(ctx, base);
	pc = 0x82900340; continue 'dispatch;
            }
            0x82900340 => {
    //   block [0x82900340..0x82900350)
	// 82900340: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82900344: 997F003E  stb r11, 0x3e(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(62 as u32), ctx.r[11].u8 ) };
	// 82900348: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8290034C: 483A9110  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82900350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82900350 size=136
    let mut pc: u32 = 0x82900350;
    'dispatch: loop {
        match pc {
            0x82900350 => {
    //   block [0x82900350..0x82900378)
	// 82900350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82900354: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82900358: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8290035C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82900360: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82900364: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82900368: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8290036C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82900370: 38EB7088  addi r7, r11, 0x7088
	ctx.r[7].s64 = ctx.r[11].s64 + 28808;
	// 82900374: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	pc = 0x82900378; continue 'dispatch;
            }
            0x82900378 => {
    //   block [0x82900378..0x829003D8)
	// 82900378: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8290037C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82900380: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82900384: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82900388: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8290038C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82900390: 4082FFE8  bne 0x82900378
	if !ctx.cr[0].eq {
	pc = 0x82900378; continue 'dispatch;
	}
	// 82900394: 83C40030  lwz r30, 0x30(r4)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 82900398: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 8290039C: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 829003A0: 38664FA8  addi r3, r6, 0x4fa8
	ctx.r[3].s64 = ctx.r[6].s64 + 20392;
	// 829003A4: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 829003A8: 4B8F39B1  bl 0x821f3d58
	ctx.lr = 0x829003AC;
	sub_821F3D58(ctx, base);
	// 829003AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829003B0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829003B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829003B8: 4BAB0401  bl 0x823b07b8
	ctx.lr = 0x829003BC;
	sub_823B07B8(ctx, base);
	// 829003BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829003C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829003C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829003C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829003CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829003D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829003D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829003D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829003D8 size=136
    let mut pc: u32 = 0x829003D8;
    'dispatch: loop {
        match pc {
            0x829003D8 => {
    //   block [0x829003D8..0x82900400)
	// 829003D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829003DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829003E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829003E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829003E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829003EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829003F0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829003F4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829003F8: 38EB7088  addi r7, r11, 0x7088
	ctx.r[7].s64 = ctx.r[11].s64 + 28808;
	// 829003FC: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	pc = 0x82900400; continue 'dispatch;
            }
            0x82900400 => {
    //   block [0x82900400..0x82900460)
	// 82900400: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82900404: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82900408: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8290040C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82900410: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82900414: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82900418: 4082FFE8  bne 0x82900400
	if !ctx.cr[0].eq {
	pc = 0x82900400; continue 'dispatch;
	}
	// 8290041C: 83C40030  lwz r30, 0x30(r4)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 82900420: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 82900424: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 82900428: 38664FB4  addi r3, r6, 0x4fb4
	ctx.r[3].s64 = ctx.r[6].s64 + 20404;
	// 8290042C: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 82900430: 4B8F3929  bl 0x821f3d58
	ctx.lr = 0x82900434;
	sub_821F3D58(ctx, base);
	// 82900434: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82900438: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290043C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82900440: 4BAB0379  bl 0x823b07b8
	ctx.lr = 0x82900444;
	sub_823B07B8(ctx, base);
	// 82900444: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82900448: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8290044C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82900450: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82900454: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82900458: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8290045C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82900460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82900460 size=136
    let mut pc: u32 = 0x82900460;
    'dispatch: loop {
        match pc {
            0x82900460 => {
    //   block [0x82900460..0x82900488)
	// 82900460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82900464: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82900468: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8290046C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82900470: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82900474: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82900478: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8290047C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82900480: 38EB7088  addi r7, r11, 0x7088
	ctx.r[7].s64 = ctx.r[11].s64 + 28808;
	// 82900484: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	pc = 0x82900488; continue 'dispatch;
            }
            0x82900488 => {
    //   block [0x82900488..0x829004E8)
	// 82900488: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8290048C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82900490: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82900494: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82900498: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8290049C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829004A0: 4082FFE8  bne 0x82900488
	if !ctx.cr[0].eq {
	pc = 0x82900488; continue 'dispatch;
	}
	// 829004A4: 83C40030  lwz r30, 0x30(r4)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 829004A8: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 829004AC: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 829004B0: 38664FC0  addi r3, r6, 0x4fc0
	ctx.r[3].s64 = ctx.r[6].s64 + 20416;
	// 829004B4: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 829004B8: 4B8F38A1  bl 0x821f3d58
	ctx.lr = 0x829004BC;
	sub_821F3D58(ctx, base);
	// 829004BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829004C0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829004C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829004C8: 4BAB02F1  bl 0x823b07b8
	ctx.lr = 0x829004CC;
	sub_823B07B8(ctx, base);
	// 829004CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829004D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829004D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829004D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829004DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829004E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829004E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829004E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829004E8 size=136
    let mut pc: u32 = 0x829004E8;
    'dispatch: loop {
        match pc {
            0x829004E8 => {
    //   block [0x829004E8..0x82900510)
	// 829004E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829004EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829004F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829004F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829004F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829004FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82900500: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82900504: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82900508: 38EB7088  addi r7, r11, 0x7088
	ctx.r[7].s64 = ctx.r[11].s64 + 28808;
	// 8290050C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	pc = 0x82900510; continue 'dispatch;
            }
            0x82900510 => {
    //   block [0x82900510..0x82900570)
	// 82900510: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82900514: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82900518: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8290051C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82900520: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82900524: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82900528: 4082FFE8  bne 0x82900510
	if !ctx.cr[0].eq {
	pc = 0x82900510; continue 'dispatch;
	}
	// 8290052C: 83C40030  lwz r30, 0x30(r4)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 82900530: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 82900534: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 82900538: 38664FC8  addi r3, r6, 0x4fc8
	ctx.r[3].s64 = ctx.r[6].s64 + 20424;
	// 8290053C: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 82900540: 4B8F3819  bl 0x821f3d58
	ctx.lr = 0x82900544;
	sub_821F3D58(ctx, base);
	// 82900544: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82900548: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290054C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82900550: 4BAB0269  bl 0x823b07b8
	ctx.lr = 0x82900554;
	sub_823B07B8(ctx, base);
	// 82900554: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82900558: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8290055C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82900560: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82900564: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82900568: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8290056C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82900570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82900570 size=136
    let mut pc: u32 = 0x82900570;
    'dispatch: loop {
        match pc {
            0x82900570 => {
    //   block [0x82900570..0x82900598)
	// 82900570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82900574: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82900578: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8290057C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82900580: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82900584: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82900588: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8290058C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82900590: 38EB7088  addi r7, r11, 0x7088
	ctx.r[7].s64 = ctx.r[11].s64 + 28808;
	// 82900594: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	pc = 0x82900598; continue 'dispatch;
            }
            0x82900598 => {
    //   block [0x82900598..0x829005F8)
	// 82900598: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8290059C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829005A0: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829005A4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829005A8: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829005AC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829005B0: 4082FFE8  bne 0x82900598
	if !ctx.cr[0].eq {
	pc = 0x82900598; continue 'dispatch;
	}
	// 829005B4: 83C40030  lwz r30, 0x30(r4)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 829005B8: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 829005BC: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 829005C0: 38664FD4  addi r3, r6, 0x4fd4
	ctx.r[3].s64 = ctx.r[6].s64 + 20436;
	// 829005C4: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 829005C8: 4B8F3791  bl 0x821f3d58
	ctx.lr = 0x829005CC;
	sub_821F3D58(ctx, base);
	// 829005CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829005D0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829005D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829005D8: 4BAB01E1  bl 0x823b07b8
	ctx.lr = 0x829005DC;
	sub_823B07B8(ctx, base);
	// 829005DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829005E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829005E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829005E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829005EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829005F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829005F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829005F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829005F8 size=136
    let mut pc: u32 = 0x829005F8;
    'dispatch: loop {
        match pc {
            0x829005F8 => {
    //   block [0x829005F8..0x82900620)
	// 829005F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829005FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82900600: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82900604: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82900608: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290060C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82900610: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82900614: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82900618: 38EB7088  addi r7, r11, 0x7088
	ctx.r[7].s64 = ctx.r[11].s64 + 28808;
	// 8290061C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	pc = 0x82900620; continue 'dispatch;
            }
            0x82900620 => {
    //   block [0x82900620..0x82900680)
	// 82900620: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82900624: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82900628: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8290062C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82900630: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82900634: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82900638: 4082FFE8  bne 0x82900620
	if !ctx.cr[0].eq {
	pc = 0x82900620; continue 'dispatch;
	}
	// 8290063C: 83C40030  lwz r30, 0x30(r4)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 82900640: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 82900644: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 82900648: 38664FDC  addi r3, r6, 0x4fdc
	ctx.r[3].s64 = ctx.r[6].s64 + 20444;
	// 8290064C: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 82900650: 4B8F3709  bl 0x821f3d58
	ctx.lr = 0x82900654;
	sub_821F3D58(ctx, base);
	// 82900654: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82900658: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290065C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82900660: 4BAB0159  bl 0x823b07b8
	ctx.lr = 0x82900664;
	sub_823B07B8(ctx, base);
	// 82900664: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82900668: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8290066C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82900670: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82900674: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82900678: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8290067C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82900680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82900680 size=136
    let mut pc: u32 = 0x82900680;
    'dispatch: loop {
        match pc {
            0x82900680 => {
    //   block [0x82900680..0x829006A8)
	// 82900680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82900684: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82900688: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8290068C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82900690: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82900694: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82900698: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8290069C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829006A0: 38EB7088  addi r7, r11, 0x7088
	ctx.r[7].s64 = ctx.r[11].s64 + 28808;
	// 829006A4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	pc = 0x829006A8; continue 'dispatch;
            }
            0x829006A8 => {
    //   block [0x829006A8..0x82900708)
	// 829006A8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829006AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829006B0: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829006B4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829006B8: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829006BC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829006C0: 4082FFE8  bne 0x829006a8
	if !ctx.cr[0].eq {
	pc = 0x829006A8; continue 'dispatch;
	}
	// 829006C4: 83C40030  lwz r30, 0x30(r4)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 829006C8: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 829006CC: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 829006D0: 38664FE8  addi r3, r6, 0x4fe8
	ctx.r[3].s64 = ctx.r[6].s64 + 20456;
	// 829006D4: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 829006D8: 4B8F3681  bl 0x821f3d58
	ctx.lr = 0x829006DC;
	sub_821F3D58(ctx, base);
	// 829006DC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829006E0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829006E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829006E8: 4BAB00D1  bl 0x823b07b8
	ctx.lr = 0x829006EC;
	sub_823B07B8(ctx, base);
	// 829006EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829006F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829006F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829006F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829006FC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82900700: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82900704: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82900708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82900708 size=136
    let mut pc: u32 = 0x82900708;
    'dispatch: loop {
        match pc {
            0x82900708 => {
    //   block [0x82900708..0x82900730)
	// 82900708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290070C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82900710: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82900714: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82900718: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290071C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82900720: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82900724: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82900728: 38EB7088  addi r7, r11, 0x7088
	ctx.r[7].s64 = ctx.r[11].s64 + 28808;
	// 8290072C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	pc = 0x82900730; continue 'dispatch;
            }
            0x82900730 => {
    //   block [0x82900730..0x82900790)
	// 82900730: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82900734: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82900738: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8290073C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82900740: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82900744: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82900748: 4082FFE8  bne 0x82900730
	if !ctx.cr[0].eq {
	pc = 0x82900730; continue 'dispatch;
	}
	// 8290074C: 83C40030  lwz r30, 0x30(r4)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 82900750: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 82900754: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 82900758: 38664FF4  addi r3, r6, 0x4ff4
	ctx.r[3].s64 = ctx.r[6].s64 + 20468;
	// 8290075C: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 82900760: 4B8F35F9  bl 0x821f3d58
	ctx.lr = 0x82900764;
	sub_821F3D58(ctx, base);
	// 82900764: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82900768: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290076C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82900770: 4BAB0049  bl 0x823b07b8
	ctx.lr = 0x82900774;
	sub_823B07B8(ctx, base);
	// 82900774: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82900778: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8290077C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82900780: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82900784: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82900788: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8290078C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82900790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82900790 size=1316
    let mut pc: u32 = 0x82900790;
    'dispatch: loop {
        match pc {
            0x82900790 => {
    //   block [0x82900790..0x829007F4)
	// 82900790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82900794: 483A8C6D  bl 0x82ca9400
	ctx.lr = 0x82900798;
	sub_82CA93D0(ctx, base);
	// 82900798: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 8290079C: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 829007A0: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829007A4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829007A8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829007AC: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 829007B0: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 829007B4: 80BD0004  lwz r5, 4(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829007B8: 81650028  lwz r11, 0x28(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(40 as u32) ) } as u64;
	// 829007BC: 556A2FFE  rlwinm r10, r11, 5, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x07FFFFFFu64;
	// 829007C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829007C4: 419A00F4  beq cr6, 0x829008b8
	if ctx.cr[6].eq {
	pc = 0x829008B8; continue 'dispatch;
	}
	// 829007C8: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 829007CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829007D0: 419A0024  beq cr6, 0x829007f4
	if ctx.cr[6].eq {
	pc = 0x829007F4; continue 'dispatch;
	}
	// 829007D4: 894B003B  lbz r10, 0x3b(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(59 as u32) ) } as u64;
	// 829007D8: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 829007DC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 829007E0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829007E4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829007E8: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 829007EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829007F0: 480000CC  b 0x829008bc
	pc = 0x829008BC; continue 'dispatch;
            }
            0x829007F4 => {
    //   block [0x829007F4..0x82900810)
	// 829007F4: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 829007F8: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 829007FC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82900800: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82900804: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82900808: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290080C: 40810054  ble 0x82900860
	if !ctx.cr[0].gt {
	pc = 0x82900860; continue 'dispatch;
	}
	pc = 0x82900810; continue 'dispatch;
            }
            0x82900810 => {
    //   block [0x82900810..0x82900830)
	// 82900810: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82900814: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82900818: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8290081C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82900820: 2F07003B  cmpwi cr6, r7, 0x3b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 59, &mut ctx.xer);
	// 82900824: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82900828: 41980008  blt cr6, 0x82900830
	if ctx.cr[6].lt {
	pc = 0x82900830; continue 'dispatch;
	}
	// 8290082C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x82900830; continue 'dispatch;
            }
            0x82900830 => {
    //   block [0x82900830..0x8290084C)
	// 82900830: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82900834: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82900838: 419A0014  beq cr6, 0x8290084c
	if ctx.cr[6].eq {
	pc = 0x8290084C; continue 'dispatch;
	}
	// 8290083C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82900840: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82900844: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82900848: 4800000C  b 0x82900854
	pc = 0x82900854; continue 'dispatch;
            }
            0x8290084C => {
    //   block [0x8290084C..0x82900854)
	// 8290084C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82900850: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82900854; continue 'dispatch;
            }
            0x82900854 => {
    //   block [0x82900854..0x82900860)
	// 82900854: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82900858: 4199FFB8  bgt cr6, 0x82900810
	if ctx.cr[6].gt {
	pc = 0x82900810; continue 'dispatch;
	}
	// 8290085C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82900860; continue 'dispatch;
            }
            0x82900860 => {
    //   block [0x82900860..0x8290087C)
	// 82900860: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82900864: 419A0040  beq cr6, 0x829008a4
	if ctx.cr[6].eq {
	pc = 0x829008A4; continue 'dispatch;
	}
	// 82900868: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290086C: 2F0B003B  cmpwi cr6, r11, 0x3b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 59, &mut ctx.xer);
	// 82900870: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82900874: 41990008  bgt cr6, 0x8290087c
	if ctx.cr[6].gt {
	pc = 0x8290087C; continue 'dispatch;
	}
	// 82900878: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x8290087C; continue 'dispatch;
            }
            0x8290087C => {
    //   block [0x8290087C..0x829008A4)
	// 8290087C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82900880: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82900884: 409A0020  bne cr6, 0x829008a4
	if !ctx.cr[6].eq {
	pc = 0x829008A4; continue 'dispatch;
	}
	// 82900888: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8290088C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82900890: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82900894: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82900898: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 8290089C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829008A0: 4800001C  b 0x829008bc
	pc = 0x829008BC; continue 'dispatch;
            }
            0x829008A4 => {
    //   block [0x829008A4..0x829008B8)
	// 829008A4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829008A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829008AC: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 829008B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829008B4: 48000008  b 0x829008bc
	pc = 0x829008BC; continue 'dispatch;
            }
            0x829008B8 => {
    //   block [0x829008B8..0x829008BC)
	// 829008B8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x829008BC; continue 'dispatch;
            }
            0x829008BC => {
    //   block [0x829008BC..0x82900904)
	// 829008BC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829008C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829008C4: 419A03DC  beq cr6, 0x82900ca0
	if ctx.cr[6].eq {
	pc = 0x82900CA0; continue 'dispatch;
	}
	// 829008C8: 81650028  lwz r11, 0x28(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(40 as u32) ) } as u64;
	// 829008CC: 556A27FE  rlwinm r10, r11, 4, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0FFFFFFFu64;
	// 829008D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829008D4: 419A00F4  beq cr6, 0x829009c8
	if ctx.cr[6].eq {
	pc = 0x829009C8; continue 'dispatch;
	}
	// 829008D8: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 829008DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829008E0: 419A0024  beq cr6, 0x82900904
	if ctx.cr[6].eq {
	pc = 0x82900904; continue 'dispatch;
	}
	// 829008E4: 894B003C  lbz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 829008E8: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 829008EC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 829008F0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829008F4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829008F8: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829008FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82900900: 480000CC  b 0x829009cc
	pc = 0x829009CC; continue 'dispatch;
            }
            0x82900904 => {
    //   block [0x82900904..0x82900920)
	// 82900904: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 82900908: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 8290090C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82900910: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82900914: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82900918: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290091C: 40810054  ble 0x82900970
	if !ctx.cr[0].gt {
	pc = 0x82900970; continue 'dispatch;
	}
	pc = 0x82900920; continue 'dispatch;
            }
            0x82900920 => {
    //   block [0x82900920..0x82900940)
	// 82900920: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82900924: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82900928: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8290092C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82900930: 2F07003C  cmpwi cr6, r7, 0x3c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 60, &mut ctx.xer);
	// 82900934: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82900938: 41980008  blt cr6, 0x82900940
	if ctx.cr[6].lt {
	pc = 0x82900940; continue 'dispatch;
	}
	// 8290093C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x82900940; continue 'dispatch;
            }
            0x82900940 => {
    //   block [0x82900940..0x8290095C)
	// 82900940: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82900944: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82900948: 419A0014  beq cr6, 0x8290095c
	if ctx.cr[6].eq {
	pc = 0x8290095C; continue 'dispatch;
	}
	// 8290094C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82900950: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82900954: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82900958: 4800000C  b 0x82900964
	pc = 0x82900964; continue 'dispatch;
            }
            0x8290095C => {
    //   block [0x8290095C..0x82900964)
	// 8290095C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82900960: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82900964; continue 'dispatch;
            }
            0x82900964 => {
    //   block [0x82900964..0x82900970)
	// 82900964: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82900968: 4199FFB8  bgt cr6, 0x82900920
	if ctx.cr[6].gt {
	pc = 0x82900920; continue 'dispatch;
	}
	// 8290096C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82900970; continue 'dispatch;
            }
            0x82900970 => {
    //   block [0x82900970..0x8290098C)
	// 82900970: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82900974: 419A0040  beq cr6, 0x829009b4
	if ctx.cr[6].eq {
	pc = 0x829009B4; continue 'dispatch;
	}
	// 82900978: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290097C: 2F0B003C  cmpwi cr6, r11, 0x3c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 60, &mut ctx.xer);
	// 82900980: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82900984: 41990008  bgt cr6, 0x8290098c
	if ctx.cr[6].gt {
	pc = 0x8290098C; continue 'dispatch;
	}
	// 82900988: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x8290098C; continue 'dispatch;
            }
            0x8290098C => {
    //   block [0x8290098C..0x829009B4)
	// 8290098C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82900990: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82900994: 409A0020  bne cr6, 0x829009b4
	if !ctx.cr[6].eq {
	pc = 0x829009B4; continue 'dispatch;
	}
	// 82900998: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8290099C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829009A0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829009A4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829009A8: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829009AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829009B0: 4800001C  b 0x829009cc
	pc = 0x829009CC; continue 'dispatch;
            }
            0x829009B4 => {
    //   block [0x829009B4..0x829009C8)
	// 829009B4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829009B8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829009BC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829009C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829009C4: 48000008  b 0x829009cc
	pc = 0x829009CC; continue 'dispatch;
            }
            0x829009C8 => {
    //   block [0x829009C8..0x829009CC)
	// 829009C8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x829009CC; continue 'dispatch;
            }
            0x829009CC => {
    //   block [0x829009CC..0x82900A28)
	// 829009CC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829009D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829009D4: 419A02CC  beq cr6, 0x82900ca0
	if ctx.cr[6].eq {
	pc = 0x82900CA0; continue 'dispatch;
	}
	// 829009D8: 8085007C  lwz r4, 0x7c(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(124 as u32) ) } as u64;
	// 829009DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829009E0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 829009E4: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 829009E8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829009EC: 4E800421  bctrl
	ctx.lr = 0x829009F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829009F0: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 829009F4: 81696AB8  lwz r11, 0x6ab8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(27320 as u32) ) } as u64;
	// 829009F8: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 829009FC: 80E80058  lwz r7, 0x58(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 82900A00: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82900A04: 80660000  lwz r3, 0(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82900A08: 4B92B7B1  bl 0x8222c1b8
	ctx.lr = 0x82900A0C;
	sub_8222C1B8(ctx, base);
	// 82900A0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82900A10: 419A0018  beq cr6, 0x82900a28
	if ctx.cr[6].eq {
	pc = 0x82900A28; continue 'dispatch;
	}
	// 82900A14: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 82900A18: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82900A1C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82900A20: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82900A24: 409A0008  bne cr6, 0x82900a2c
	if !ctx.cr[6].eq {
	pc = 0x82900A2C; continue 'dispatch;
	}
            }
            0x82900A28 => {
    //   block [0x82900A28..0x82900A2C)
	// 82900A28: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82900A2C; continue 'dispatch;
            }
            0x82900A2C => {
    //   block [0x82900A2C..0x82900A60)
	// 82900A2C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82900A30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82900A34: 419A002C  beq cr6, 0x82900a60
	if ctx.cr[6].eq {
	pc = 0x82900A60; continue 'dispatch;
	}
	// 82900A38: 8083007C  lwz r4, 0x7c(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(124 as u32) ) } as u64;
	// 82900A3C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82900A40: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82900A44: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82900A48: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82900A4C: 4E800421  bctrl
	ctx.lr = 0x82900A50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82900A50: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 82900A54: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
            }
            0x82900A60 => {
    //   block [0x82900A60..0x82900CA0)
	// 82900A60: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82900A64: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82900A68: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 82900A6C: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82900A70: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 82900A74: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82900A78: 4E800421  bctrl
	ctx.lr = 0x82900A7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82900A7C: 80FA000C  lwz r7, 0xc(r26)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) } as u64;
	// 82900A80: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 82900A84: 38888D4C  addi r4, r8, -0x72b4
	ctx.r[4].s64 = ctx.r[8].s64 + -29364;
	// 82900A88: 80670018  lwz r3, 0x18(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82900A8C: 4B966A85  bl 0x82267510
	ctx.lr = 0x82900A90;
	sub_82267510(ctx, base);
	// 82900A90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82900A94: 419A000C  beq cr6, 0x82900aa0
	if ctx.cr[6].eq {
	pc = 0x82900AA0; continue 'dispatch;
	}
	// 82900A98: 8163007C  lwz r11, 0x7c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(124 as u32) ) } as u64;
	// 82900A9C: 48000008  b 0x82900aa4
	pc = 0x82900AA4; continue 'dispatch;
	// 82900AA0: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82900AA4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82900AA8: 3B6BFFFF  addi r27, r11, -1
	ctx.r[27].s64 = ctx.r[11].s64 + -1;
	// 82900AAC: 4BD72E75  bl 0x82673920
	ctx.lr = 0x82900AB0;
	sub_82673920(ctx, base);
	// 82900AB0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82900AB4: 41990060  bgt cr6, 0x82900b14
	if ctx.cr[6].gt {
	pc = 0x82900B14; continue 'dispatch;
	}
	// 82900AB8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82900ABC: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82900AC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82900AC4: 4B8E75B5  bl 0x821e8078
	ctx.lr = 0x82900AC8;
	sub_821E8078(ctx, base);
	// 82900AC8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82900ACC: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82900AD0: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 82900AD4: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 82900AD8: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
            }
            0x82900CA0 => {
    //   block [0x82900CA0..0x82900CB4)
	// 82900CA0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82900CA4: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82900CA8: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82900CAC: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82900CB0: 483A87A0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82900CB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82900CB8 size=468
    let mut pc: u32 = 0x82900CB8;
    'dispatch: loop {
        match pc {
            0x82900CB8 => {
    //   block [0x82900CB8..0x82900E8C)
	// 82900CB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82900CBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82900CC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82900CC4: 3980FFE0  li r12, -0x20
	ctx.r[12].s64 = -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82900E90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82900E90 size=332
    let mut pc: u32 = 0x82900E90;
    'dispatch: loop {
        match pc {
            0x82900E90 => {
    //   block [0x82900E90..0x82900FDC)
	// 82900E90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82900E94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82900E98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82900E9C: 3980FFE0  li r12, -0x20
	ctx.r[12].s64 = -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82900FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82900FE0 size=156
    let mut pc: u32 = 0x82900FE0;
    'dispatch: loop {
        match pc {
            0x82900FE0 => {
    //   block [0x82900FE0..0x8290107C)
	// 82900FE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82900FE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82900FE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82900FEC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82900FF0: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82901080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82901080 size=1536
    let mut pc: u32 = 0x82901080;
    'dispatch: loop {
        match pc {
            0x82901080 => {
    //   block [0x82901080..0x82901680)
	// 82901080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82901084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82901088: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8290108C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82901090: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82901094: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82901098: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290109C: 3BCB5000  addi r30, r11, 0x5000
	ctx.r[30].s64 = ctx.r[11].s64 + 20480;
	// 829010A0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829010A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829010A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829010AC: 4B92BE25  bl 0x8222ced0
	ctx.lr = 0x829010B0;
	sub_8222CED0(ctx, base);
	// 829010B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829010B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829010B8: 480005C9  bl 0x82901680
	ctx.lr = 0x829010BC;
	sub_82901680(ctx, base);
	// 829010BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829010C0: 4B913D19  bl 0x82214dd8
	ctx.lr = 0x829010C4;
	sub_82214DD8(ctx, base);
	// 829010C4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 829010C8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829010CC: 388A25B0  addi r4, r10, 0x25b0
	ctx.r[4].s64 = ctx.r[10].s64 + 9648;
	// 829010D0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829010D4: 4B92BDFD  bl 0x8222ced0
	ctx.lr = 0x829010D8;
	sub_8222CED0(ctx, base);
	// 829010D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829010DC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829010E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829010E4: 4B92BDED  bl 0x8222ced0
	ctx.lr = 0x829010E8;
	sub_8222CED0(ctx, base);
	// 829010E8: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 829010EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829010F0: 38C9FAD0  addi r6, r9, -0x530
	ctx.r[6].s64 = ctx.r[9].s64 + -1328;
	// 829010F4: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 829010F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829010FC: 480007CD  bl 0x829018c8
	ctx.lr = 0x82901100;
	sub_829018C8(ctx, base);
	// 82901100: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82901104: 4B913CD5  bl 0x82214dd8
	ctx.lr = 0x82901108;
	sub_82214DD8(ctx, base);
	// 82901108: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8290110C: 4B913CCD  bl 0x82214dd8
	ctx.lr = 0x82901110;
	sub_82214DD8(ctx, base);
	// 82901110: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 82901114: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82901118: 3888500C  addi r4, r8, 0x500c
	ctx.r[4].s64 = ctx.r[8].s64 + 20492;
	// 8290111C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82901120: 4B92BDB1  bl 0x8222ced0
	ctx.lr = 0x82901124;
	sub_8222CED0(ctx, base);
	// 82901124: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82901128: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8290112C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82901130: 4B92BDA1  bl 0x8222ced0
	ctx.lr = 0x82901134;
	sub_8222CED0(ctx, base);
	// 82901134: 3CE08290  lis r7, -0x7d70
	ctx.r[7].s64 = -2104492032;
	// 82901138: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290113C: 38C7FC88  addi r6, r7, -0x378
	ctx.r[6].s64 = ctx.r[7].s64 + -888;
	// 82901140: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82901144: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82901148: 48000989  bl 0x82901ad0
	ctx.lr = 0x8290114C;
	sub_82901AD0(ctx, base);
	// 8290114C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82901150: 4B913C89  bl 0x82214dd8
	ctx.lr = 0x82901154;
	sub_82214DD8(ctx, base);
	// 82901154: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82901158: 4B913C81  bl 0x82214dd8
	ctx.lr = 0x8290115C;
	sub_82214DD8(ctx, base);
	// 8290115C: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 82901160: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82901164: 38865020  addi r4, r6, 0x5020
	ctx.r[4].s64 = ctx.r[6].s64 + 20512;
	// 82901168: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290116C: 4B92BD65  bl 0x8222ced0
	ctx.lr = 0x82901170;
	sub_8222CED0(ctx, base);
	// 82901170: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82901174: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82901178: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8290117C: 4B92BD55  bl 0x8222ced0
	ctx.lr = 0x82901180;
	sub_8222CED0(ctx, base);
	// 82901180: 3C808290  lis r4, -0x7d70
	ctx.r[4].s64 = -2104492032;
	// 82901184: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82901188: 38C4FDE0  addi r6, r4, -0x220
	ctx.r[6].s64 = ctx.r[4].s64 + -544;
	// 8290118C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82901190: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82901194: 48000B45  bl 0x82901cd8
	ctx.lr = 0x82901198;
	sub_82901CD8(ctx, base);
	// 82901198: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8290119C: 4B913C3D  bl 0x82214dd8
	ctx.lr = 0x829011A0;
	sub_82214DD8(ctx, base);
	// 829011A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829011A4: 4B913C35  bl 0x82214dd8
	ctx.lr = 0x829011A8;
	sub_82214DD8(ctx, base);
	// 829011A8: 3C60820E  lis r3, -0x7df2
	ctx.r[3].s64 = -2113011712;
	// 829011AC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829011B0: 38834E68  addi r4, r3, 0x4e68
	ctx.r[4].s64 = ctx.r[3].s64 + 20072;
	// 829011B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829011B8: 4B92BD19  bl 0x8222ced0
	ctx.lr = 0x829011BC;
	sub_8222CED0(ctx, base);
	// 829011BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829011C0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829011C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829011C8: 4B92BD09  bl 0x8222ced0
	ctx.lr = 0x829011CC;
	sub_8222CED0(ctx, base);
	// 829011CC: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 829011D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829011D4: 38CB02B0  addi r6, r11, 0x2b0
	ctx.r[6].s64 = ctx.r[11].s64 + 688;
	// 829011D8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829011DC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 829011E0: 48000D01  bl 0x82901ee0
	ctx.lr = 0x829011E4;
	sub_82901EE0(ctx, base);
	// 829011E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829011E8: 4B913BF1  bl 0x82214dd8
	ctx.lr = 0x829011EC;
	sub_82214DD8(ctx, base);
	// 829011EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829011F0: 4B913BE9  bl 0x82214dd8
	ctx.lr = 0x829011F4;
	sub_82214DD8(ctx, base);
	// 829011F4: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 829011F8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829011FC: 388A502C  addi r4, r10, 0x502c
	ctx.r[4].s64 = ctx.r[10].s64 + 20524;
	// 82901200: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82901204: 4B92BCCD  bl 0x8222ced0
	ctx.lr = 0x82901208;
	sub_8222CED0(ctx, base);
	// 82901208: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8290120C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82901210: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82901214: 4B92BCBD  bl 0x8222ced0
	ctx.lr = 0x82901218;
	sub_8222CED0(ctx, base);
	// 82901218: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 8290121C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82901220: 38C902B8  addi r6, r9, 0x2b8
	ctx.r[6].s64 = ctx.r[9].s64 + 696;
	// 82901224: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82901228: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8290122C: 48000E75  bl 0x829020a0
	ctx.lr = 0x82901230;
	sub_829020A0(ctx, base);
	// 82901230: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82901234: 4B913BA5  bl 0x82214dd8
	ctx.lr = 0x82901238;
	sub_82214DD8(ctx, base);
	// 82901238: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290123C: 4B913B9D  bl 0x82214dd8
	ctx.lr = 0x82901240;
	sub_82214DD8(ctx, base);
	// 82901240: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 82901244: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82901248: 38885038  addi r4, r8, 0x5038
	ctx.r[4].s64 = ctx.r[8].s64 + 20536;
	// 8290124C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82901250: 4B92BC81  bl 0x8222ced0
	ctx.lr = 0x82901254;
	sub_8222CED0(ctx, base);
	// 82901254: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82901258: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8290125C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82901260: 4B92BC71  bl 0x8222ced0
	ctx.lr = 0x82901264;
	sub_8222CED0(ctx, base);
	// 82901264: 3CE08290  lis r7, -0x7d70
	ctx.r[7].s64 = -2104492032;
	// 82901268: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290126C: 38C7FA58  addi r6, r7, -0x5a8
	ctx.r[6].s64 = ctx.r[7].s64 + -1448;
	// 82901270: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82901274: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82901278: 48001031  bl 0x829022a8
	ctx.lr = 0x8290127C;
	sub_829022A8(ctx, base);
	// 8290127C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82901280: 4B913B59  bl 0x82214dd8
	ctx.lr = 0x82901284;
	sub_82214DD8(ctx, base);
	// 82901284: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82901288: 4B913B51  bl 0x82214dd8
	ctx.lr = 0x8290128C;
	sub_82214DD8(ctx, base);
	// 8290128C: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 82901290: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82901294: 38865050  addi r4, r6, 0x5050
	ctx.r[4].s64 = ctx.r[6].s64 + 20560;
	// 82901298: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290129C: 4B92BC35  bl 0x8222ced0
	ctx.lr = 0x829012A0;
	sub_8222CED0(ctx, base);
	// 829012A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829012A4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829012A8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829012AC: 4B92BC25  bl 0x8222ced0
	ctx.lr = 0x829012B0;
	sub_8222CED0(ctx, base);
	// 829012B0: 3C808290  lis r4, -0x7d70
	ctx.r[4].s64 = -2104492032;
	// 829012B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829012B8: 38C40350  addi r6, r4, 0x350
	ctx.r[6].s64 = ctx.r[4].s64 + 848;
	// 829012BC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829012C0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 829012C4: 480011ED  bl 0x829024b0
	ctx.lr = 0x829012C8;
	sub_829024B0(ctx, base);
	// 829012C8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829012CC: 4B913B0D  bl 0x82214dd8
	ctx.lr = 0x829012D0;
	sub_82214DD8(ctx, base);
	// 829012D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829012D4: 4B913B05  bl 0x82214dd8
	ctx.lr = 0x829012D8;
	sub_82214DD8(ctx, base);
	// 829012D8: 3C60820E  lis r3, -0x7df2
	ctx.r[3].s64 = -2113011712;
	// 829012DC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829012E0: 3883505C  addi r4, r3, 0x505c
	ctx.r[4].s64 = ctx.r[3].s64 + 20572;
	// 829012E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829012E8: 4B92BBE9  bl 0x8222ced0
	ctx.lr = 0x829012EC;
	sub_8222CED0(ctx, base);
	// 829012EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829012F0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829012F4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829012F8: 4B92BBD9  bl 0x8222ced0
	ctx.lr = 0x829012FC;
	sub_8222CED0(ctx, base);
	// 829012FC: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 82901300: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82901304: 38CB03D8  addi r6, r11, 0x3d8
	ctx.r[6].s64 = ctx.r[11].s64 + 984;
	// 82901308: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8290130C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82901310: 480011A1  bl 0x829024b0
	ctx.lr = 0x82901314;
	sub_829024B0(ctx, base);
	// 82901314: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82901318: 4B913AC1  bl 0x82214dd8
	ctx.lr = 0x8290131C;
	sub_82214DD8(ctx, base);
	// 8290131C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82901320: 4B913AB9  bl 0x82214dd8
	ctx.lr = 0x82901324;
	sub_82214DD8(ctx, base);
	// 82901324: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 82901328: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8290132C: 388A506C  addi r4, r10, 0x506c
	ctx.r[4].s64 = ctx.r[10].s64 + 20588;
	// 82901330: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82901334: 4B92BB9D  bl 0x8222ced0
	ctx.lr = 0x82901338;
	sub_8222CED0(ctx, base);
	// 82901338: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8290133C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82901340: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82901344: 4B92BB8D  bl 0x8222ced0
	ctx.lr = 0x82901348;
	sub_8222CED0(ctx, base);
	// 82901348: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 8290134C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82901350: 38C90460  addi r6, r9, 0x460
	ctx.r[6].s64 = ctx.r[9].s64 + 1120;
	// 82901354: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82901358: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8290135C: 48001155  bl 0x829024b0
	ctx.lr = 0x82901360;
	sub_829024B0(ctx, base);
	// 82901360: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82901364: 4B913A75  bl 0x82214dd8
	ctx.lr = 0x82901368;
	sub_82214DD8(ctx, base);
	// 82901368: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290136C: 4B913A6D  bl 0x82214dd8
	ctx.lr = 0x82901370;
	sub_82214DD8(ctx, base);
	// 82901370: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 82901374: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82901378: 38885078  addi r4, r8, 0x5078
	ctx.r[4].s64 = ctx.r[8].s64 + 20600;
	// 8290137C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82901380: 4B92BB51  bl 0x8222ced0
	ctx.lr = 0x82901384;
	sub_8222CED0(ctx, base);
	// 82901384: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82901388: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8290138C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82901390: 4B92BB41  bl 0x8222ced0
	ctx.lr = 0x82901394;
	sub_8222CED0(ctx, base);
	// 82901394: 3CE08290  lis r7, -0x7d70
	ctx.r[7].s64 = -2104492032;
	// 82901398: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290139C: 38C704E8  addi r6, r7, 0x4e8
	ctx.r[6].s64 = ctx.r[7].s64 + 1256;
	// 829013A0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829013A4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 829013A8: 48001109  bl 0x829024b0
	ctx.lr = 0x829013AC;
	sub_829024B0(ctx, base);
	// 829013AC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829013B0: 4B913A29  bl 0x82214dd8
	ctx.lr = 0x829013B4;
	sub_82214DD8(ctx, base);
	// 829013B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829013B8: 4B913A21  bl 0x82214dd8
	ctx.lr = 0x829013BC;
	sub_82214DD8(ctx, base);
	// 829013BC: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 829013C0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829013C4: 38865088  addi r4, r6, 0x5088
	ctx.r[4].s64 = ctx.r[6].s64 + 20616;
	// 829013C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829013CC: 4B92BB05  bl 0x8222ced0
	ctx.lr = 0x829013D0;
	sub_8222CED0(ctx, base);
	// 829013D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829013D4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829013D8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829013DC: 4B92BAF5  bl 0x8222ced0
	ctx.lr = 0x829013E0;
	sub_8222CED0(ctx, base);
	// 829013E0: 3C808290  lis r4, -0x7d70
	ctx.r[4].s64 = -2104492032;
	// 829013E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829013E8: 38C40570  addi r6, r4, 0x570
	ctx.r[6].s64 = ctx.r[4].s64 + 1392;
	// 829013EC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829013F0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 829013F4: 480010BD  bl 0x829024b0
	ctx.lr = 0x829013F8;
	sub_829024B0(ctx, base);
	// 829013F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829013FC: 4B9139DD  bl 0x82214dd8
	ctx.lr = 0x82901400;
	sub_82214DD8(ctx, base);
	// 82901400: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82901404: 4B9139D5  bl 0x82214dd8
	ctx.lr = 0x82901408;
	sub_82214DD8(ctx, base);
	// 82901408: 3C60820E  lis r3, -0x7df2
	ctx.r[3].s64 = -2113011712;
	// 8290140C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82901410: 38835094  addi r4, r3, 0x5094
	ctx.r[4].s64 = ctx.r[3].s64 + 20628;
	// 82901414: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82901418: 4B92BAB9  bl 0x8222ced0
	ctx.lr = 0x8290141C;
	sub_8222CED0(ctx, base);
	// 8290141C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82901420: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82901424: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82901428: 4B92BAA9  bl 0x8222ced0
	ctx.lr = 0x8290142C;
	sub_8222CED0(ctx, base);
	// 8290142C: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 82901430: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82901434: 38CB05F8  addi r6, r11, 0x5f8
	ctx.r[6].s64 = ctx.r[11].s64 + 1528;
	// 82901438: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290143C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82901440: 48001071  bl 0x829024b0
	ctx.lr = 0x82901444;
	sub_829024B0(ctx, base);
	// 82901444: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82901448: 4B913991  bl 0x82214dd8
	ctx.lr = 0x8290144C;
	sub_82214DD8(ctx, base);
	// 8290144C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82901450: 4B913989  bl 0x82214dd8
	ctx.lr = 0x82901454;
	sub_82214DD8(ctx, base);
	// 82901454: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 82901458: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8290145C: 388A50A4  addi r4, r10, 0x50a4
	ctx.r[4].s64 = ctx.r[10].s64 + 20644;
	// 82901460: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82901464: 4B92BA6D  bl 0x8222ced0
	ctx.lr = 0x82901468;
	sub_8222CED0(ctx, base);
	// 82901468: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8290146C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82901470: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82901474: 4B92BA5D  bl 0x8222ced0
	ctx.lr = 0x82901478;
	sub_8222CED0(ctx, base);
	// 82901478: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 8290147C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82901480: 38C90680  addi r6, r9, 0x680
	ctx.r[6].s64 = ctx.r[9].s64 + 1664;
	// 82901484: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82901488: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8290148C: 48001025  bl 0x829024b0
	ctx.lr = 0x82901490;
	sub_829024B0(ctx, base);
	// 82901490: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82901494: 4B913945  bl 0x82214dd8
	ctx.lr = 0x82901498;
	sub_82214DD8(ctx, base);
	// 82901498: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290149C: 4B91393D  bl 0x82214dd8
	ctx.lr = 0x829014A0;
	sub_82214DD8(ctx, base);
	// 829014A0: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 829014A4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829014A8: 388850B4  addi r4, r8, 0x50b4
	ctx.r[4].s64 = ctx.r[8].s64 + 20660;
	// 829014AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829014B0: 4B92BA21  bl 0x8222ced0
	ctx.lr = 0x829014B4;
	sub_8222CED0(ctx, base);
	// 829014B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829014B8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829014BC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829014C0: 4B92BA11  bl 0x8222ced0
	ctx.lr = 0x829014C4;
	sub_8222CED0(ctx, base);
	// 829014C4: 3CE08290  lis r7, -0x7d70
	ctx.r[7].s64 = -2104492032;
	// 829014C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829014CC: 38C70708  addi r6, r7, 0x708
	ctx.r[6].s64 = ctx.r[7].s64 + 1800;
	// 829014D0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829014D4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 829014D8: 48000FD9  bl 0x829024b0
	ctx.lr = 0x829014DC;
	sub_829024B0(ctx, base);
	// 829014DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829014E0: 4B9138F9  bl 0x82214dd8
	ctx.lr = 0x829014E4;
	sub_82214DD8(ctx, base);
	// 829014E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829014E8: 4B9138F1  bl 0x82214dd8
	ctx.lr = 0x829014EC;
	sub_82214DD8(ctx, base);
	// 829014EC: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 829014F0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829014F4: 388650C4  addi r4, r6, 0x50c4
	ctx.r[4].s64 = ctx.r[6].s64 + 20676;
	// 829014F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829014FC: 4B92B9D5  bl 0x8222ced0
	ctx.lr = 0x82901500;
	sub_8222CED0(ctx, base);
	// 82901500: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82901504: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82901508: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8290150C: 4B92B9C5  bl 0x8222ced0
	ctx.lr = 0x82901510;
	sub_8222CED0(ctx, base);
	// 82901510: 3C808290  lis r4, -0x7d70
	ctx.r[4].s64 = -2104492032;
	// 82901514: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82901518: 38C40790  addi r6, r4, 0x790
	ctx.r[6].s64 = ctx.r[4].s64 + 1936;
	// 8290151C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82901520: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82901524: 480009BD  bl 0x82901ee0
	ctx.lr = 0x82901528;
	sub_82901EE0(ctx, base);
	// 82901528: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8290152C: 4B9138AD  bl 0x82214dd8
	ctx.lr = 0x82901530;
	sub_82214DD8(ctx, base);
	// 82901530: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82901534: 4B9138A5  bl 0x82214dd8
	ctx.lr = 0x82901538;
	sub_82214DD8(ctx, base);
	// 82901538: 3C60820E  lis r3, -0x7df2
	ctx.r[3].s64 = -2113011712;
	// 8290153C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82901540: 388350D8  addi r4, r3, 0x50d8
	ctx.r[4].s64 = ctx.r[3].s64 + 20696;
	// 82901544: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82901548: 4B92B989  bl 0x8222ced0
	ctx.lr = 0x8290154C;
	sub_8222CED0(ctx, base);
	// 8290154C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82901550: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82901554: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82901558: 4B92B979  bl 0x8222ced0
	ctx.lr = 0x8290155C;
	sub_8222CED0(ctx, base);
	// 8290155C: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 82901560: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82901564: 38CB0CB8  addi r6, r11, 0xcb8
	ctx.r[6].s64 = ctx.r[11].s64 + 3256;
	// 82901568: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8290156C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82901570: 48001141  bl 0x829026b0
	ctx.lr = 0x82901574;
	sub_829026B0(ctx, base);
	// 82901574: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82901578: 4B913861  bl 0x82214dd8
	ctx.lr = 0x8290157C;
	sub_82214DD8(ctx, base);
	// 8290157C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82901580: 4B913859  bl 0x82214dd8
	ctx.lr = 0x82901584;
	sub_82214DD8(ctx, base);
	// 82901584: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 82901588: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8290158C: 388A50FC  addi r4, r10, 0x50fc
	ctx.r[4].s64 = ctx.r[10].s64 + 20732;
	// 82901590: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82901594: 4B92B93D  bl 0x8222ced0
	ctx.lr = 0x82901598;
	sub_8222CED0(ctx, base);
	// 82901598: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8290159C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829015A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829015A4: 4B92B92D  bl 0x8222ced0
	ctx.lr = 0x829015A8;
	sub_8222CED0(ctx, base);
	// 829015A8: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 829015AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829015B0: 38C90E90  addi r6, r9, 0xe90
	ctx.r[6].s64 = ctx.r[9].s64 + 3728;
	// 829015B4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829015B8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 829015BC: 480010F5  bl 0x829026b0
	ctx.lr = 0x829015C0;
	sub_829026B0(ctx, base);
	// 829015C0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829015C4: 4B913815  bl 0x82214dd8
	ctx.lr = 0x829015C8;
	sub_82214DD8(ctx, base);
	// 829015C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829015CC: 4B91380D  bl 0x82214dd8
	ctx.lr = 0x829015D0;
	sub_82214DD8(ctx, base);
	// 829015D0: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 829015D4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829015D8: 38885118  addi r4, r8, 0x5118
	ctx.r[4].s64 = ctx.r[8].s64 + 20760;
	// 829015DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829015E0: 4B92B8F1  bl 0x8222ced0
	ctx.lr = 0x829015E4;
	sub_8222CED0(ctx, base);
	// 829015E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829015E8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829015EC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829015F0: 4B92B8E1  bl 0x8222ced0
	ctx.lr = 0x829015F4;
	sub_8222CED0(ctx, base);
	// 829015F4: 3CE08290  lis r7, -0x7d70
	ctx.r[7].s64 = -2104492032;
	// 829015F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829015FC: 38C70FE0  addi r6, r7, 0xfe0
	ctx.r[6].s64 = ctx.r[7].s64 + 4064;
	// 82901600: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82901604: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82901608: 480010A9  bl 0x829026b0
	ctx.lr = 0x8290160C;
	sub_829026B0(ctx, base);
	// 8290160C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82901610: 4B9137C9  bl 0x82214dd8
	ctx.lr = 0x82901614;
	sub_82214DD8(ctx, base);
	// 82901614: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82901618: 4B9137C1  bl 0x82214dd8
	ctx.lr = 0x8290161C;
	sub_82214DD8(ctx, base);
	// 8290161C: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 82901620: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82901624: 38865134  addi r4, r6, 0x5134
	ctx.r[4].s64 = ctx.r[6].s64 + 20788;
	// 82901628: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290162C: 4B92B8A5  bl 0x8222ced0
	ctx.lr = 0x82901630;
	sub_8222CED0(ctx, base);
	// 82901630: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82901634: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82901638: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8290163C: 4B92B895  bl 0x8222ced0
	ctx.lr = 0x82901640;
	sub_8222CED0(ctx, base);
	// 82901640: 3C808290  lis r4, -0x7d70
	ctx.r[4].s64 = -2104492032;
	// 82901644: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82901648: 38C4F240  addi r6, r4, -0xdc0
	ctx.r[6].s64 = ctx.r[4].s64 + -3520;
	// 8290164C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82901650: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82901654: 4800125D  bl 0x829028b0
	ctx.lr = 0x82901658;
	sub_829028B0(ctx, base);
	// 82901658: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8290165C: 4B91377D  bl 0x82214dd8
	ctx.lr = 0x82901660;
	sub_82214DD8(ctx, base);
	// 82901660: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82901664: 4B913775  bl 0x82214dd8
	ctx.lr = 0x82901668;
	sub_82214DD8(ctx, base);
	// 82901668: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8290166C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82901670: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82901674: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82901678: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8290167C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82901680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82901680 size=584
    let mut pc: u32 = 0x82901680;
    'dispatch: loop {
        match pc {
            0x82901680 => {
    //   block [0x82901680..0x829016A8)
	// 82901680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82901684: 483A7D7D  bl 0x82ca9400
	ctx.lr = 0x82901688;
	sub_82CA93D0(ctx, base);
	// 82901688: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290168C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82901690: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82901694: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82901698: 409A0010  bne cr6, 0x829016a8
	if !ctx.cr[6].eq {
	pc = 0x829016A8; continue 'dispatch;
	}
	// 8290169C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 829016A0: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 829016A4: 48000008  b 0x829016ac
	pc = 0x829016AC; continue 'dispatch;
            }
            0x829016A8 => {
    //   block [0x829016A8..0x829016AC)
	// 829016A8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829016AC; continue 'dispatch;
            }
            0x829016AC => {
    //   block [0x829016AC..0x82901724)
	// 829016AC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 829016B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829016B4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829016B8: 4BACCF09  bl 0x823ce5c0
	ctx.lr = 0x829016BC;
	sub_823CE5C0(ctx, base);
	// 829016BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829016C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829016C4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829016C8: 4BACCB39  bl 0x823ce200
	ctx.lr = 0x829016CC;
	sub_823CE200(ctx, base);
	// 829016CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829016D0: 4B8B6449  bl 0x821b7b18
	ctx.lr = 0x829016D4;
	sub_821B7B18(ctx, base);
	// 829016D4: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 829016D8: 4B91DB81  bl 0x8221f258
	ctx.lr = 0x829016DC;
	sub_8221F258(ctx, base);
	// 829016DC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829016E0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829016E4: 419A0040  beq cr6, 0x82901724
	if ctx.cr[6].eq {
	pc = 0x82901724; continue 'dispatch;
	}
	// 829016E8: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829016EC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 829016F0: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 829016F4: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829016F8: 4B91DB61  bl 0x8221f258
	ctx.lr = 0x829016FC;
	sub_8221F258(ctx, base);
	// 829016FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82901700: 419A0028  beq cr6, 0x82901728
	if ctx.cr[6].eq {
	pc = 0x82901728; continue 'dispatch;
	}
	// 82901704: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 82901708: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 8290170C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82901710: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 82901714: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82901718: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8290171C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82901720: 4800000C  b 0x8290172c
	pc = 0x8290172C; continue 'dispatch;
            }
            0x82901724 => {
    //   block [0x82901724..0x82901728)
	// 82901724: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82901728; continue 'dispatch;
            }
            0x82901728 => {
    //   block [0x82901728..0x8290172C)
	// 82901728: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x8290172C; continue 'dispatch;
            }
            0x8290172C => {
    //   block [0x8290172C..0x82901830)
	// 8290172C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82901730: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82901734: 419A00FC  beq cr6, 0x82901830
	if ctx.cr[6].eq {
	pc = 0x82901830; continue 'dispatch;
	}
	// 82901738: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290173C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 82901740: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82901744: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82901748: 4B9279C1  bl 0x82229108
	ctx.lr = 0x8290174C;
	sub_82229108(ctx, base);
	// 8290174C: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 82901750: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82901754: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82901758: 3BCB2A70  addi r30, r11, 0x2a70
	ctx.r[30].s64 = ctx.r[11].s64 + 10864;
	// 8290175C: 4B926125  bl 0x82227880
	ctx.lr = 0x82901760;
	sub_82227880(ctx, base);
	// 82901760: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82901764: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 82901768: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8290176C: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 82901770: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82901774: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82901778: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 8290177C: 4B899305  bl 0x8219aa80
	ctx.lr = 0x82901780;
	sub_8219AA80(ctx, base);
	// 82901780: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82901784: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82901788: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 8290178C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82901790: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82901794: 4BACCC8D  bl 0x823ce420
	ctx.lr = 0x82901798;
	sub_823CE420(ctx, base);
	// 82901798: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8290179C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 829017A0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829017A4: 48122F25  bl 0x82a246c8
	ctx.lr = 0x829017A8;
	sub_82A246C8(ctx, base);
	// 829017A8: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 829017AC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 829017B0: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 829017B4: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 829017B8: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829017BC: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829017C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829017C4: 4B927945  bl 0x82229108
	ctx.lr = 0x829017C8;
	sub_82229108(ctx, base);
	// 829017C8: 3D608232  lis r11, -0x7dce
	ctx.r[11].s64 = -2110652416;
	// 829017CC: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 829017D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829017D4: 3BEB6BD8  addi r31, r11, 0x6bd8
	ctx.r[31].s64 = ctx.r[11].s64 + 27608;
	// 829017D8: 4B9260A9  bl 0x82227880
	ctx.lr = 0x829017DC;
	sub_82227880(ctx, base);
	// 829017DC: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 829017E0: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 829017E4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829017E8: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 829017EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829017F0: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 829017F4: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 829017F8: 4B899289  bl 0x8219aa80
	ctx.lr = 0x829017FC;
	sub_8219AA80(ctx, base);
	// 829017FC: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 82901800: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82901804: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 82901808: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290180C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82901810: 4BACCC11  bl 0x823ce420
	ctx.lr = 0x82901814;
	sub_823CE420(ctx, base);
	// 82901814: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82901818: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 8290181C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82901820: 48122EA9  bl 0x82a246c8
	ctx.lr = 0x82901824;
	sub_82A246C8(ctx, base);
	// 82901824: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82901828: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 8290182C: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	pc = 0x82901830; continue 'dispatch;
            }
            0x82901830 => {
    //   block [0x82901830..0x82901840)
	// 82901830: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82901834: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82901838: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 8290183C: 419A0020  beq cr6, 0x8290185c
	if ctx.cr[6].eq {
	pc = 0x8290185C; continue 'dispatch;
	}
	pc = 0x82901840; continue 'dispatch;
            }
            0x82901840 => {
    //   block [0x82901840..0x8290185C)
	// 82901840: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82901844: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82901848: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8290184C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82901850: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82901854: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82901858: 4082FFE8  bne 0x82901840
	if !ctx.cr[0].eq {
	pc = 0x82901840; continue 'dispatch;
	}
	pc = 0x8290185C; continue 'dispatch;
            }
            0x8290185C => {
    //   block [0x8290185C..0x8290187C)
	// 8290185C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82901860: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82901864: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 82901868: 4B9F40E1  bl 0x822f5948
	ctx.lr = 0x8290186C;
	sub_822F5948(ctx, base);
	// 8290186C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82901870: 4B8B62A9  bl 0x821b7b18
	ctx.lr = 0x82901874;
	sub_821B7B18(ctx, base);
	// 82901874: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82901878: 419A0040  beq cr6, 0x829018b8
	if ctx.cr[6].eq {
	pc = 0x829018B8; continue 'dispatch;
	}
	pc = 0x8290187C; continue 'dispatch;
            }
            0x8290187C => {
    //   block [0x8290187C..0x829018B8)
	// 8290187C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82901880: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82901884: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82901888: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8290188C: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82901890: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82901894: 4082FFE8  bne 0x8290187c
	if !ctx.cr[0].eq {
	pc = 0x8290187C; continue 'dispatch;
	}
	// 82901898: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290189C: 409A001C  bne cr6, 0x829018b8
	if !ctx.cr[6].eq {
	pc = 0x829018B8; continue 'dispatch;
	}
	// 829018A0: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 829018A4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829018A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829018AC: 4E800421  bctrl
	ctx.lr = 0x829018B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829018B0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829018B4: 4B91A485  bl 0x8221bd38
	ctx.lr = 0x829018B8;
	sub_8221BD38(ctx, base);
            }
            0x829018B8 => {
    //   block [0x829018B8..0x829018C8)
	// 829018B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829018BC: 4B8B625D  bl 0x821b7b18
	ctx.lr = 0x829018C0;
	sub_821B7B18(ctx, base);
	// 829018C0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829018C4: 483A7B8C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829018C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829018C8 size=516
    let mut pc: u32 = 0x829018C8;
    'dispatch: loop {
        match pc {
            0x829018C8 => {
    //   block [0x829018C8..0x82901904)
	// 829018C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829018CC: 483A7B31  bl 0x82ca93fc
	ctx.lr = 0x829018D0;
	sub_82CA93D0(ctx, base);
	// 829018D0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829018D4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829018D8: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 829018DC: 3D408290  lis r10, -0x7d70
	ctx.r[10].s64 = -2104492032;
	// 829018E0: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 829018E4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 829018E8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829018EC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 829018F0: 3BAAFAD0  addi r29, r10, -0x530
	ctx.r[29].s64 = ctx.r[10].s64 + -1328;
	// 829018F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829018F8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 829018FC: 419A0008  beq cr6, 0x82901904
	if ctx.cr[6].eq {
	pc = 0x82901904; continue 'dispatch;
	}
	// 82901900: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82901904; continue 'dispatch;
            }
            0x82901904 => {
    //   block [0x82901904..0x82901998)
	// 82901904: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82901908: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8290190C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82901910: 4BACCCB1  bl 0x823ce5c0
	ctx.lr = 0x82901914;
	sub_823CE5C0(ctx, base);
	// 82901914: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82901918: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8290191C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82901920: 4BACC7F1  bl 0x823ce110
	ctx.lr = 0x82901924;
	sub_823CE110(ctx, base);
	// 82901924: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82901928: 4B8B61F1  bl 0x821b7b18
	ctx.lr = 0x8290192C;
	sub_821B7B18(ctx, base);
	// 8290192C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82901930: 4B91D929  bl 0x8221f258
	ctx.lr = 0x82901934;
	sub_8221F258(ctx, base);
	// 82901934: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82901938: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8290193C: 419A005C  beq cr6, 0x82901998
	if ctx.cr[6].eq {
	pc = 0x82901998; continue 'dispatch;
	}
	// 82901940: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82901944: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82901948: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8290194C: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 82901950: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82901954: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82901958: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8290195C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82901960: 4B8EE8E1  bl 0x821f0240
	ctx.lr = 0x82901964;
	sub_821F0240(ctx, base);
	// 82901964: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82901968: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 8290196C: 4B91D8ED  bl 0x8221f258
	ctx.lr = 0x82901970;
	sub_8221F258(ctx, base);
	// 82901970: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82901974: 419A0028  beq cr6, 0x8290199c
	if ctx.cr[6].eq {
	pc = 0x8290199C; continue 'dispatch;
	}
	// 82901978: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 8290197C: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82901980: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82901984: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 82901988: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8290198C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82901990: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82901994: 4800000C  b 0x829019a0
	pc = 0x829019A0; continue 'dispatch;
            }
            0x82901998 => {
    //   block [0x82901998..0x8290199C)
	// 82901998: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x8290199C; continue 'dispatch;
            }
            0x8290199C => {
    //   block [0x8290199C..0x829019A0)
	// 8290199C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x829019A0; continue 'dispatch;
            }
            0x829019A0 => {
    //   block [0x829019A0..0x829019B4)
	// 829019A0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 829019A4: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 829019A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829019AC: 419A0008  beq cr6, 0x829019b4
	if ctx.cr[6].eq {
	pc = 0x829019B4; continue 'dispatch;
	}
	// 829019B0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829019B4; continue 'dispatch;
            }
            0x829019B4 => {
    //   block [0x829019B4..0x82901A34)
	// 829019B4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829019B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829019BC: 419A0078  beq cr6, 0x82901a34
	if ctx.cr[6].eq {
	pc = 0x82901A34; continue 'dispatch;
	}
	// 829019C0: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829019C4: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 829019C8: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829019CC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829019D0: 4B927739  bl 0x82229108
	ctx.lr = 0x829019D4;
	sub_82229108(ctx, base);
	// 829019D4: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 829019D8: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 829019DC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829019E0: 3BCB2AB0  addi r30, r11, 0x2ab0
	ctx.r[30].s64 = ctx.r[11].s64 + 10928;
	// 829019E4: 4B925E9D  bl 0x82227880
	ctx.lr = 0x829019E8;
	sub_82227880(ctx, base);
	// 829019E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829019EC: 3D408290  lis r10, -0x7d70
	ctx.r[10].s64 = -2104492032;
	// 829019F0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829019F4: 388A3888  addi r4, r10, 0x3888
	ctx.r[4].s64 = ctx.r[10].s64 + 14472;
	// 829019F8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829019FC: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82901A00: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82901A04: 4B89907D  bl 0x8219aa80
	ctx.lr = 0x82901A08;
	sub_8219AA80(ctx, base);
	// 82901A08: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82901A0C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82901A10: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82901A14: 4BACCA0D  bl 0x823ce420
	ctx.lr = 0x82901A18;
	sub_823CE420(ctx, base);
	// 82901A18: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82901A1C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 82901A20: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82901A24: 48122CA5  bl 0x82a246c8
	ctx.lr = 0x82901A28;
	sub_82A246C8(ctx, base);
	// 82901A28: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82901A2C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 82901A30: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x82901A34; continue 'dispatch;
            }
            0x82901A34 => {
    //   block [0x82901A34..0x82901A44)
	// 82901A34: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82901A38: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82901A3C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82901A40: 419A0020  beq cr6, 0x82901a60
	if ctx.cr[6].eq {
	pc = 0x82901A60; continue 'dispatch;
	}
	pc = 0x82901A44; continue 'dispatch;
            }
            0x82901A44 => {
    //   block [0x82901A44..0x82901A60)
	// 82901A44: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82901A48: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82901A4C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82901A50: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82901A54: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82901A58: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82901A5C: 4082FFE8  bne 0x82901a44
	if !ctx.cr[0].eq {
	pc = 0x82901A44; continue 'dispatch;
	}
	pc = 0x82901A60; continue 'dispatch;
            }
            0x82901A60 => {
    //   block [0x82901A60..0x82901A80)
	// 82901A60: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82901A64: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82901A68: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 82901A6C: 4B9F3EDD  bl 0x822f5948
	ctx.lr = 0x82901A70;
	sub_822F5948(ctx, base);
	// 82901A70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82901A74: 4B8B60A5  bl 0x821b7b18
	ctx.lr = 0x82901A78;
	sub_821B7B18(ctx, base);
	// 82901A78: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82901A7C: 419A0040  beq cr6, 0x82901abc
	if ctx.cr[6].eq {
	pc = 0x82901ABC; continue 'dispatch;
	}
	pc = 0x82901A80; continue 'dispatch;
            }
            0x82901A80 => {
    //   block [0x82901A80..0x82901ABC)
	// 82901A80: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82901A84: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82901A88: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82901A8C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82901A90: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82901A94: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82901A98: 4082FFE8  bne 0x82901a80
	if !ctx.cr[0].eq {
	pc = 0x82901A80; continue 'dispatch;
	}
	// 82901A9C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82901AA0: 409A001C  bne cr6, 0x82901abc
	if !ctx.cr[6].eq {
	pc = 0x82901ABC; continue 'dispatch;
	}
	// 82901AA4: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82901AA8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82901AAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82901AB0: 4E800421  bctrl
	ctx.lr = 0x82901AB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82901AB4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82901AB8: 4B91A281  bl 0x8221bd38
	ctx.lr = 0x82901ABC;
	sub_8221BD38(ctx, base);
            }
            0x82901ABC => {
    //   block [0x82901ABC..0x82901ACC)
	// 82901ABC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82901AC0: 4B8B6059  bl 0x821b7b18
	ctx.lr = 0x82901AC4;
	sub_821B7B18(ctx, base);
	// 82901AC4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82901AC8: 483A7984  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82901AD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82901AD0 size=516
    let mut pc: u32 = 0x82901AD0;
    'dispatch: loop {
        match pc {
            0x82901AD0 => {
    //   block [0x82901AD0..0x82901B0C)
	// 82901AD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82901AD4: 483A7929  bl 0x82ca93fc
	ctx.lr = 0x82901AD8;
	sub_82CA93D0(ctx, base);
	// 82901AD8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82901ADC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82901AE0: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 82901AE4: 3D408290  lis r10, -0x7d70
	ctx.r[10].s64 = -2104492032;
	// 82901AE8: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 82901AEC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82901AF0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82901AF4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82901AF8: 3BAAFC88  addi r29, r10, -0x378
	ctx.r[29].s64 = ctx.r[10].s64 + -888;
	// 82901AFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82901B00: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82901B04: 419A0008  beq cr6, 0x82901b0c
	if ctx.cr[6].eq {
	pc = 0x82901B0C; continue 'dispatch;
	}
	// 82901B08: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82901B0C; continue 'dispatch;
            }
            0x82901B0C => {
    //   block [0x82901B0C..0x82901BA0)
	// 82901B0C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82901B10: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82901B14: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82901B18: 4BACCAA9  bl 0x823ce5c0
	ctx.lr = 0x82901B1C;
	sub_823CE5C0(ctx, base);
	// 82901B1C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82901B20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82901B24: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82901B28: 4BACC5E9  bl 0x823ce110
	ctx.lr = 0x82901B2C;
	sub_823CE110(ctx, base);
	// 82901B2C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82901B30: 4B8B5FE9  bl 0x821b7b18
	ctx.lr = 0x82901B34;
	sub_821B7B18(ctx, base);
	// 82901B34: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82901B38: 4B91D721  bl 0x8221f258
	ctx.lr = 0x82901B3C;
	sub_8221F258(ctx, base);
	// 82901B3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82901B40: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82901B44: 419A005C  beq cr6, 0x82901ba0
	if ctx.cr[6].eq {
	pc = 0x82901BA0; continue 'dispatch;
	}
	// 82901B48: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82901B4C: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82901B50: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82901B54: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 82901B58: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82901B5C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82901B60: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82901B64: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82901B68: 4B8EE6D9  bl 0x821f0240
	ctx.lr = 0x82901B6C;
	sub_821F0240(ctx, base);
	// 82901B6C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82901B70: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82901B74: 4B91D6E5  bl 0x8221f258
	ctx.lr = 0x82901B78;
	sub_8221F258(ctx, base);
	// 82901B78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82901B7C: 419A0028  beq cr6, 0x82901ba4
	if ctx.cr[6].eq {
	pc = 0x82901BA4; continue 'dispatch;
	}
	// 82901B80: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 82901B84: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82901B88: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82901B8C: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 82901B90: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82901B94: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82901B98: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82901B9C: 4800000C  b 0x82901ba8
	pc = 0x82901BA8; continue 'dispatch;
            }
            0x82901BA0 => {
    //   block [0x82901BA0..0x82901BA4)
	// 82901BA0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x82901BA4; continue 'dispatch;
            }
            0x82901BA4 => {
    //   block [0x82901BA4..0x82901BA8)
	// 82901BA4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82901BA8; continue 'dispatch;
            }
            0x82901BA8 => {
    //   block [0x82901BA8..0x82901BBC)
	// 82901BA8: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82901BAC: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82901BB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82901BB4: 419A0008  beq cr6, 0x82901bbc
	if ctx.cr[6].eq {
	pc = 0x82901BBC; continue 'dispatch;
	}
	// 82901BB8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82901BBC; continue 'dispatch;
            }
            0x82901BBC => {
    //   block [0x82901BBC..0x82901C3C)
	// 82901BBC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82901BC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82901BC4: 419A0078  beq cr6, 0x82901c3c
	if ctx.cr[6].eq {
	pc = 0x82901C3C; continue 'dispatch;
	}
	// 82901BC8: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82901BCC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 82901BD0: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82901BD4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82901BD8: 4B927531  bl 0x82229108
	ctx.lr = 0x82901BDC;
	sub_82229108(ctx, base);
	// 82901BDC: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 82901BE0: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82901BE4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82901BE8: 3BCB2C38  addi r30, r11, 0x2c38
	ctx.r[30].s64 = ctx.r[11].s64 + 11320;
	// 82901BEC: 4B925C95  bl 0x82227880
	ctx.lr = 0x82901BF0;
	sub_82227880(ctx, base);
	// 82901BF0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82901BF4: 3D408290  lis r10, -0x7d70
	ctx.r[10].s64 = -2104492032;
	// 82901BF8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82901BFC: 388A3928  addi r4, r10, 0x3928
	ctx.r[4].s64 = ctx.r[10].s64 + 14632;
	// 82901C00: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82901C04: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82901C08: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82901C0C: 4B898E75  bl 0x8219aa80
	ctx.lr = 0x82901C10;
	sub_8219AA80(ctx, base);
	// 82901C10: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82901C14: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82901C18: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82901C1C: 4BACC805  bl 0x823ce420
	ctx.lr = 0x82901C20;
	sub_823CE420(ctx, base);
	// 82901C20: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82901C24: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 82901C28: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82901C2C: 48122A9D  bl 0x82a246c8
	ctx.lr = 0x82901C30;
	sub_82A246C8(ctx, base);
	// 82901C30: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82901C34: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 82901C38: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x82901C3C; continue 'dispatch;
            }
            0x82901C3C => {
    //   block [0x82901C3C..0x82901C4C)
	// 82901C3C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82901C40: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82901C44: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82901C48: 419A0020  beq cr6, 0x82901c68
	if ctx.cr[6].eq {
	pc = 0x82901C68; continue 'dispatch;
	}
	pc = 0x82901C4C; continue 'dispatch;
            }
            0x82901C4C => {
    //   block [0x82901C4C..0x82901C68)
	// 82901C4C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82901C50: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82901C54: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82901C58: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82901C5C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82901C60: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82901C64: 4082FFE8  bne 0x82901c4c
	if !ctx.cr[0].eq {
	pc = 0x82901C4C; continue 'dispatch;
	}
	pc = 0x82901C68; continue 'dispatch;
            }
            0x82901C68 => {
    //   block [0x82901C68..0x82901C88)
	// 82901C68: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82901C6C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82901C70: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 82901C74: 4B9F3CD5  bl 0x822f5948
	ctx.lr = 0x82901C78;
	sub_822F5948(ctx, base);
	// 82901C78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82901C7C: 4B8B5E9D  bl 0x821b7b18
	ctx.lr = 0x82901C80;
	sub_821B7B18(ctx, base);
	// 82901C80: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82901C84: 419A0040  beq cr6, 0x82901cc4
	if ctx.cr[6].eq {
	pc = 0x82901CC4; continue 'dispatch;
	}
	pc = 0x82901C88; continue 'dispatch;
            }
            0x82901C88 => {
    //   block [0x82901C88..0x82901CC4)
	// 82901C88: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82901C8C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82901C90: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82901C94: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82901C98: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82901C9C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82901CA0: 4082FFE8  bne 0x82901c88
	if !ctx.cr[0].eq {
	pc = 0x82901C88; continue 'dispatch;
	}
	// 82901CA4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82901CA8: 409A001C  bne cr6, 0x82901cc4
	if !ctx.cr[6].eq {
	pc = 0x82901CC4; continue 'dispatch;
	}
	// 82901CAC: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82901CB0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82901CB4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82901CB8: 4E800421  bctrl
	ctx.lr = 0x82901CBC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82901CBC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82901CC0: 4B91A079  bl 0x8221bd38
	ctx.lr = 0x82901CC4;
	sub_8221BD38(ctx, base);
            }
            0x82901CC4 => {
    //   block [0x82901CC4..0x82901CD4)
	// 82901CC4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82901CC8: 4B8B5E51  bl 0x821b7b18
	ctx.lr = 0x82901CCC;
	sub_821B7B18(ctx, base);
	// 82901CCC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82901CD0: 483A777C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82901CD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82901CD8 size=516
    let mut pc: u32 = 0x82901CD8;
    'dispatch: loop {
        match pc {
            0x82901CD8 => {
    //   block [0x82901CD8..0x82901D14)
	// 82901CD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82901CDC: 483A7721  bl 0x82ca93fc
	ctx.lr = 0x82901CE0;
	sub_82CA93D0(ctx, base);
	// 82901CE0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82901CE4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82901CE8: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 82901CEC: 3D408290  lis r10, -0x7d70
	ctx.r[10].s64 = -2104492032;
	// 82901CF0: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 82901CF4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82901CF8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82901CFC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82901D00: 3BAAFDE0  addi r29, r10, -0x220
	ctx.r[29].s64 = ctx.r[10].s64 + -544;
	// 82901D04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82901D08: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82901D0C: 419A0008  beq cr6, 0x82901d14
	if ctx.cr[6].eq {
	pc = 0x82901D14; continue 'dispatch;
	}
	// 82901D10: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82901D14; continue 'dispatch;
            }
            0x82901D14 => {
    //   block [0x82901D14..0x82901DA8)
	// 82901D14: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82901D18: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82901D1C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82901D20: 4BACC8A1  bl 0x823ce5c0
	ctx.lr = 0x82901D24;
	sub_823CE5C0(ctx, base);
	// 82901D24: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82901D28: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82901D2C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82901D30: 4BACC3E1  bl 0x823ce110
	ctx.lr = 0x82901D34;
	sub_823CE110(ctx, base);
	// 82901D34: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82901D38: 4B8B5DE1  bl 0x821b7b18
	ctx.lr = 0x82901D3C;
	sub_821B7B18(ctx, base);
	// 82901D3C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82901D40: 4B91D519  bl 0x8221f258
	ctx.lr = 0x82901D44;
	sub_8221F258(ctx, base);
	// 82901D44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82901D48: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82901D4C: 419A005C  beq cr6, 0x82901da8
	if ctx.cr[6].eq {
	pc = 0x82901DA8; continue 'dispatch;
	}
	// 82901D50: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82901D54: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82901D58: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82901D5C: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 82901D60: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82901D64: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82901D68: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82901D6C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82901D70: 4B8EE4D1  bl 0x821f0240
	ctx.lr = 0x82901D74;
	sub_821F0240(ctx, base);
	// 82901D74: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82901D78: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82901D7C: 4B91D4DD  bl 0x8221f258
	ctx.lr = 0x82901D80;
	sub_8221F258(ctx, base);
	// 82901D80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82901D84: 419A0028  beq cr6, 0x82901dac
	if ctx.cr[6].eq {
	pc = 0x82901DAC; continue 'dispatch;
	}
	// 82901D88: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 82901D8C: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82901D90: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82901D94: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 82901D98: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82901D9C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82901DA0: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82901DA4: 4800000C  b 0x82901db0
	pc = 0x82901DB0; continue 'dispatch;
            }
            0x82901DA8 => {
    //   block [0x82901DA8..0x82901DAC)
	// 82901DA8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x82901DAC; continue 'dispatch;
            }
            0x82901DAC => {
    //   block [0x82901DAC..0x82901DB0)
	// 82901DAC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82901DB0; continue 'dispatch;
            }
            0x82901DB0 => {
    //   block [0x82901DB0..0x82901DC4)
	// 82901DB0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82901DB4: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82901DB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82901DBC: 419A0008  beq cr6, 0x82901dc4
	if ctx.cr[6].eq {
	pc = 0x82901DC4; continue 'dispatch;
	}
	// 82901DC0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82901DC4; continue 'dispatch;
            }
            0x82901DC4 => {
    //   block [0x82901DC4..0x82901E44)
	// 82901DC4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82901DC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82901DCC: 419A0078  beq cr6, 0x82901e44
	if ctx.cr[6].eq {
	pc = 0x82901E44; continue 'dispatch;
	}
	// 82901DD0: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82901DD4: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 82901DD8: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82901DDC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82901DE0: 4B927329  bl 0x82229108
	ctx.lr = 0x82901DE4;
	sub_82229108(ctx, base);
	// 82901DE4: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 82901DE8: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82901DEC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82901DF0: 3BCB2DB0  addi r30, r11, 0x2db0
	ctx.r[30].s64 = ctx.r[11].s64 + 11696;
	// 82901DF4: 4B925A8D  bl 0x82227880
	ctx.lr = 0x82901DF8;
	sub_82227880(ctx, base);
	// 82901DF8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82901DFC: 3D408248  lis r10, -0x7db8
	ctx.r[10].s64 = -2109210624;
	// 82901E00: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82901E04: 388A1200  addi r4, r10, 0x1200
	ctx.r[4].s64 = ctx.r[10].s64 + 4608;
	// 82901E08: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82901E0C: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82901E10: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82901E14: 4B898C6D  bl 0x8219aa80
	ctx.lr = 0x82901E18;
	sub_8219AA80(ctx, base);
	// 82901E18: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82901E1C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82901E20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82901E24: 4BACC5FD  bl 0x823ce420
	ctx.lr = 0x82901E28;
	sub_823CE420(ctx, base);
	// 82901E28: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82901E2C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 82901E30: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82901E34: 48122895  bl 0x82a246c8
	ctx.lr = 0x82901E38;
	sub_82A246C8(ctx, base);
	// 82901E38: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82901E3C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 82901E40: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x82901E44; continue 'dispatch;
            }
            0x82901E44 => {
    //   block [0x82901E44..0x82901E54)
	// 82901E44: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82901E48: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82901E4C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82901E50: 419A0020  beq cr6, 0x82901e70
	if ctx.cr[6].eq {
	pc = 0x82901E70; continue 'dispatch;
	}
	pc = 0x82901E54; continue 'dispatch;
            }
            0x82901E54 => {
    //   block [0x82901E54..0x82901E70)
	// 82901E54: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82901E58: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82901E5C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82901E60: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82901E64: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82901E68: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82901E6C: 4082FFE8  bne 0x82901e54
	if !ctx.cr[0].eq {
	pc = 0x82901E54; continue 'dispatch;
	}
	pc = 0x82901E70; continue 'dispatch;
            }
            0x82901E70 => {
    //   block [0x82901E70..0x82901E90)
	// 82901E70: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82901E74: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82901E78: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 82901E7C: 4B9F3ACD  bl 0x822f5948
	ctx.lr = 0x82901E80;
	sub_822F5948(ctx, base);
	// 82901E80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82901E84: 4B8B5C95  bl 0x821b7b18
	ctx.lr = 0x82901E88;
	sub_821B7B18(ctx, base);
	// 82901E88: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82901E8C: 419A0040  beq cr6, 0x82901ecc
	if ctx.cr[6].eq {
	pc = 0x82901ECC; continue 'dispatch;
	}
	pc = 0x82901E90; continue 'dispatch;
            }
            0x82901E90 => {
    //   block [0x82901E90..0x82901ECC)
	// 82901E90: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82901E94: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82901E98: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82901E9C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82901EA0: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82901EA4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82901EA8: 4082FFE8  bne 0x82901e90
	if !ctx.cr[0].eq {
	pc = 0x82901E90; continue 'dispatch;
	}
	// 82901EAC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82901EB0: 409A001C  bne cr6, 0x82901ecc
	if !ctx.cr[6].eq {
	pc = 0x82901ECC; continue 'dispatch;
	}
	// 82901EB4: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82901EB8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82901EBC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82901EC0: 4E800421  bctrl
	ctx.lr = 0x82901EC4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82901EC4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82901EC8: 4B919E71  bl 0x8221bd38
	ctx.lr = 0x82901ECC;
	sub_8221BD38(ctx, base);
            }
            0x82901ECC => {
    //   block [0x82901ECC..0x82901EDC)
	// 82901ECC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82901ED0: 4B8B5C49  bl 0x821b7b18
	ctx.lr = 0x82901ED4;
	sub_821B7B18(ctx, base);
	// 82901ED4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82901ED8: 483A7574  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82901EE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82901EE0 size=444
    let mut pc: u32 = 0x82901EE0;
    'dispatch: loop {
        match pc {
            0x82901EE0 => {
    //   block [0x82901EE0..0x82901F18)
	// 82901EE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82901EE4: 483A7519  bl 0x82ca93fc
	ctx.lr = 0x82901EE8;
	sub_82CA93D0(ctx, base);
	// 82901EE8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82901EEC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82901EF0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 82901EF4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82901EF8: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 82901EFC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82901F00: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82901F04: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82901F08: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82901F0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82901F10: 419A0008  beq cr6, 0x82901f18
	if ctx.cr[6].eq {
	pc = 0x82901F18; continue 'dispatch;
	}
	// 82901F14: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82901F18; continue 'dispatch;
            }
            0x82901F18 => {
    //   block [0x82901F18..0x82901F7C)
	// 82901F18: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82901F1C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82901F20: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82901F24: 4BACC69D  bl 0x823ce5c0
	ctx.lr = 0x82901F28;
	sub_823CE5C0(ctx, base);
	// 82901F28: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82901F2C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82901F30: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82901F34: 4BACC1DD  bl 0x823ce110
	ctx.lr = 0x82901F38;
	sub_823CE110(ctx, base);
	// 82901F38: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82901F3C: 4B8B5BDD  bl 0x821b7b18
	ctx.lr = 0x82901F40;
	sub_821B7B18(ctx, base);
	// 82901F40: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82901F44: 4B91D315  bl 0x8221f258
	ctx.lr = 0x82901F48;
	sub_8221F258(ctx, base);
	// 82901F48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82901F4C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82901F50: 419A002C  beq cr6, 0x82901f7c
	if ctx.cr[6].eq {
	pc = 0x82901F7C; continue 'dispatch;
	}
	// 82901F54: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82901F58: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82901F5C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82901F60: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 82901F64: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82901F68: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82901F6C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82901F70: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82901F74: 4B8EE2CD  bl 0x821f0240
	ctx.lr = 0x82901F78;
	sub_821F0240(ctx, base);
	// 82901F78: 48000008  b 0x82901f80
	pc = 0x82901F80; continue 'dispatch;
            }
            0x82901F7C => {
    //   block [0x82901F7C..0x82901F80)
	// 82901F7C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82901F80; continue 'dispatch;
            }
            0x82901F80 => {
    //   block [0x82901F80..0x82901FA4)
	// 82901F80: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 82901F84: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82901F88: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82901F8C: 419A0018  beq cr6, 0x82901fa4
	if ctx.cr[6].eq {
	pc = 0x82901FA4; continue 'dispatch;
	}
	// 82901F90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82901F94: 48102D2D  bl 0x82a04cc0
	ctx.lr = 0x82901F98;
	sub_82A04CC0(ctx, base);
	// 82901F98: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82901F9C: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82901FA0: 4800000C  b 0x82901fac
	pc = 0x82901FAC; continue 'dispatch;
            }
            0x82901FA4 => {
    //   block [0x82901FA4..0x82901FAC)
	// 82901FA4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82901FA8: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	pc = 0x82901FAC; continue 'dispatch;
            }
            0x82901FAC => {
    //   block [0x82901FAC..0x82901FC0)
	// 82901FAC: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82901FB0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82901FB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82901FB8: 419A0008  beq cr6, 0x82901fc0
	if ctx.cr[6].eq {
	pc = 0x82901FC0; continue 'dispatch;
	}
	// 82901FBC: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82901FC0; continue 'dispatch;
            }
            0x82901FC0 => {
    //   block [0x82901FC0..0x82902040)
	// 82901FC0: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82901FC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82901FC8: 419A0078  beq cr6, 0x82902040
	if ctx.cr[6].eq {
	pc = 0x82902040; continue 'dispatch;
	}
	// 82901FCC: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82901FD0: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 82901FD4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82901FD8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82901FDC: 4B92712D  bl 0x82229108
	ctx.lr = 0x82901FE0;
	sub_82229108(ctx, base);
	// 82901FE0: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 82901FE4: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82901FE8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82901FEC: 3BCB2F80  addi r30, r11, 0x2f80
	ctx.r[30].s64 = ctx.r[11].s64 + 12160;
	// 82901FF0: 4B925891  bl 0x82227880
	ctx.lr = 0x82901FF4;
	sub_82227880(ctx, base);
	// 82901FF4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82901FF8: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 82901FFC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82902000: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 82902004: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82902008: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 8290200C: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82902010: 4B898A71  bl 0x8219aa80
	ctx.lr = 0x82902014;
	sub_8219AA80(ctx, base);
	// 82902014: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82902018: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8290201C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82902020: 4BACC401  bl 0x823ce420
	ctx.lr = 0x82902024;
	sub_823CE420(ctx, base);
	// 82902024: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82902028: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 8290202C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82902030: 48122699  bl 0x82a246c8
	ctx.lr = 0x82902034;
	sub_82A246C8(ctx, base);
	// 82902034: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82902038: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 8290203C: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x82902040; continue 'dispatch;
            }
            0x82902040 => {
    //   block [0x82902040..0x82902050)
	// 82902040: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82902044: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82902048: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 8290204C: 419A0020  beq cr6, 0x8290206c
	if ctx.cr[6].eq {
	pc = 0x8290206C; continue 'dispatch;
	}
	pc = 0x82902050; continue 'dispatch;
            }
            0x82902050 => {
    //   block [0x82902050..0x8290206C)
	// 82902050: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82902054: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82902058: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8290205C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82902060: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82902064: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82902068: 4082FFE8  bne 0x82902050
	if !ctx.cr[0].eq {
	pc = 0x82902050; continue 'dispatch;
	}
	pc = 0x8290206C; continue 'dispatch;
            }
            0x8290206C => {
    //   block [0x8290206C..0x8290209C)
	// 8290206C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82902070: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82902074: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 82902078: 4B9F38D1  bl 0x822f5948
	ctx.lr = 0x8290207C;
	sub_822F5948(ctx, base);
	// 8290207C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82902080: 4B8B5A99  bl 0x821b7b18
	ctx.lr = 0x82902084;
	sub_821B7B18(ctx, base);
	// 82902084: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82902088: 4B8B5A91  bl 0x821b7b18
	ctx.lr = 0x8290208C;
	sub_821B7B18(ctx, base);
	// 8290208C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82902090: 4B8B5A89  bl 0x821b7b18
	ctx.lr = 0x82902094;
	sub_821B7B18(ctx, base);
	// 82902094: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82902098: 483A73B4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829020A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829020A0 size=516
    let mut pc: u32 = 0x829020A0;
    'dispatch: loop {
        match pc {
            0x829020A0 => {
    //   block [0x829020A0..0x829020DC)
	// 829020A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829020A4: 483A7359  bl 0x82ca93fc
	ctx.lr = 0x829020A8;
	sub_82CA93D0(ctx, base);
	// 829020A8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829020AC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829020B0: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 829020B4: 3D408290  lis r10, -0x7d70
	ctx.r[10].s64 = -2104492032;
	// 829020B8: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 829020BC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 829020C0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829020C4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 829020C8: 3BAA02B8  addi r29, r10, 0x2b8
	ctx.r[29].s64 = ctx.r[10].s64 + 696;
	// 829020CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829020D0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 829020D4: 419A0008  beq cr6, 0x829020dc
	if ctx.cr[6].eq {
	pc = 0x829020DC; continue 'dispatch;
	}
	// 829020D8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829020DC; continue 'dispatch;
            }
            0x829020DC => {
    //   block [0x829020DC..0x82902170)
	// 829020DC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829020E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829020E4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829020E8: 4BACC4D9  bl 0x823ce5c0
	ctx.lr = 0x829020EC;
	sub_823CE5C0(ctx, base);
	// 829020EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829020F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829020F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829020F8: 4BACC019  bl 0x823ce110
	ctx.lr = 0x829020FC;
	sub_823CE110(ctx, base);
	// 829020FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82902100: 4B8B5A19  bl 0x821b7b18
	ctx.lr = 0x82902104;
	sub_821B7B18(ctx, base);
	// 82902104: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82902108: 4B91D151  bl 0x8221f258
	ctx.lr = 0x8290210C;
	sub_8221F258(ctx, base);
	// 8290210C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82902110: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82902114: 419A005C  beq cr6, 0x82902170
	if ctx.cr[6].eq {
	pc = 0x82902170; continue 'dispatch;
	}
	// 82902118: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8290211C: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82902120: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82902124: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 82902128: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8290212C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82902130: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82902134: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82902138: 4B8EE109  bl 0x821f0240
	ctx.lr = 0x8290213C;
	sub_821F0240(ctx, base);
	// 8290213C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82902140: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82902144: 4B91D115  bl 0x8221f258
	ctx.lr = 0x82902148;
	sub_8221F258(ctx, base);
	// 82902148: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8290214C: 419A0028  beq cr6, 0x82902174
	if ctx.cr[6].eq {
	pc = 0x82902174; continue 'dispatch;
	}
	// 82902150: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 82902154: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82902158: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290215C: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 82902160: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82902164: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82902168: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8290216C: 4800000C  b 0x82902178
	pc = 0x82902178; continue 'dispatch;
            }
            0x82902170 => {
    //   block [0x82902170..0x82902174)
	// 82902170: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x82902174; continue 'dispatch;
            }
            0x82902174 => {
    //   block [0x82902174..0x82902178)
	// 82902174: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82902178; continue 'dispatch;
            }
            0x82902178 => {
    //   block [0x82902178..0x8290218C)
	// 82902178: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290217C: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82902180: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82902184: 419A0008  beq cr6, 0x8290218c
	if ctx.cr[6].eq {
	pc = 0x8290218C; continue 'dispatch;
	}
	// 82902188: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8290218C; continue 'dispatch;
            }
            0x8290218C => {
    //   block [0x8290218C..0x8290220C)
	// 8290218C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82902190: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82902194: 419A0078  beq cr6, 0x8290220c
	if ctx.cr[6].eq {
	pc = 0x8290220C; continue 'dispatch;
	}
	// 82902198: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290219C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 829021A0: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829021A4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829021A8: 4B926F61  bl 0x82229108
	ctx.lr = 0x829021AC;
	sub_82229108(ctx, base);
	// 829021AC: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 829021B0: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 829021B4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829021B8: 3BCB3270  addi r30, r11, 0x3270
	ctx.r[30].s64 = ctx.r[11].s64 + 12912;
	// 829021BC: 4B9256C5  bl 0x82227880
	ctx.lr = 0x829021C0;
	sub_82227880(ctx, base);
	// 829021C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829021C4: 3D408246  lis r10, -0x7dba
	ctx.r[10].s64 = -2109341696;
	// 829021C8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829021CC: 388A5B50  addi r4, r10, 0x5b50
	ctx.r[4].s64 = ctx.r[10].s64 + 23376;
	// 829021D0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829021D4: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 829021D8: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829021DC: 4B8988A5  bl 0x8219aa80
	ctx.lr = 0x829021E0;
	sub_8219AA80(ctx, base);
	// 829021E0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829021E4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829021E8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829021EC: 4BACC235  bl 0x823ce420
	ctx.lr = 0x829021F0;
	sub_823CE420(ctx, base);
	// 829021F0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829021F4: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 829021F8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829021FC: 481224CD  bl 0x82a246c8
	ctx.lr = 0x82902200;
	sub_82A246C8(ctx, base);
	// 82902200: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82902204: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 82902208: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x8290220C; continue 'dispatch;
            }
            0x8290220C => {
    //   block [0x8290220C..0x8290221C)
	// 8290220C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82902210: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82902214: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82902218: 419A0020  beq cr6, 0x82902238
	if ctx.cr[6].eq {
	pc = 0x82902238; continue 'dispatch;
	}
	pc = 0x8290221C; continue 'dispatch;
            }
            0x8290221C => {
    //   block [0x8290221C..0x82902238)
	// 8290221C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82902220: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82902224: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82902228: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8290222C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82902230: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82902234: 4082FFE8  bne 0x8290221c
	if !ctx.cr[0].eq {
	pc = 0x8290221C; continue 'dispatch;
	}
	pc = 0x82902238; continue 'dispatch;
            }
            0x82902238 => {
    //   block [0x82902238..0x82902258)
	// 82902238: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290223C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82902240: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 82902244: 4B9F3705  bl 0x822f5948
	ctx.lr = 0x82902248;
	sub_822F5948(ctx, base);
	// 82902248: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290224C: 4B8B58CD  bl 0x821b7b18
	ctx.lr = 0x82902250;
	sub_821B7B18(ctx, base);
	// 82902250: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82902254: 419A0040  beq cr6, 0x82902294
	if ctx.cr[6].eq {
	pc = 0x82902294; continue 'dispatch;
	}
	pc = 0x82902258; continue 'dispatch;
            }
            0x82902258 => {
    //   block [0x82902258..0x82902294)
	// 82902258: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8290225C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82902260: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82902264: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82902268: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8290226C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82902270: 4082FFE8  bne 0x82902258
	if !ctx.cr[0].eq {
	pc = 0x82902258; continue 'dispatch;
	}
	// 82902274: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82902278: 409A001C  bne cr6, 0x82902294
	if !ctx.cr[6].eq {
	pc = 0x82902294; continue 'dispatch;
	}
	// 8290227C: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82902280: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82902284: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82902288: 4E800421  bctrl
	ctx.lr = 0x8290228C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290228C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82902290: 4B919AA9  bl 0x8221bd38
	ctx.lr = 0x82902294;
	sub_8221BD38(ctx, base);
            }
            0x82902294 => {
    //   block [0x82902294..0x829022A4)
	// 82902294: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82902298: 4B8B5881  bl 0x821b7b18
	ctx.lr = 0x8290229C;
	sub_821B7B18(ctx, base);
	// 8290229C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 829022A0: 483A71AC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829022A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829022A8 size=516
    let mut pc: u32 = 0x829022A8;
    'dispatch: loop {
        match pc {
            0x829022A8 => {
    //   block [0x829022A8..0x829022E4)
	// 829022A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829022AC: 483A7151  bl 0x82ca93fc
	ctx.lr = 0x829022B0;
	sub_82CA93D0(ctx, base);
	// 829022B0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829022B4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829022B8: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 829022BC: 3D408290  lis r10, -0x7d70
	ctx.r[10].s64 = -2104492032;
	// 829022C0: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 829022C4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 829022C8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829022CC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 829022D0: 3BAAFA58  addi r29, r10, -0x5a8
	ctx.r[29].s64 = ctx.r[10].s64 + -1448;
	// 829022D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829022D8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 829022DC: 419A0008  beq cr6, 0x829022e4
	if ctx.cr[6].eq {
	pc = 0x829022E4; continue 'dispatch;
	}
	// 829022E0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829022E4; continue 'dispatch;
            }
            0x829022E4 => {
    //   block [0x829022E4..0x82902378)
	// 829022E4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829022E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829022EC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829022F0: 4BACC2D1  bl 0x823ce5c0
	ctx.lr = 0x829022F4;
	sub_823CE5C0(ctx, base);
	// 829022F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829022F8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829022FC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82902300: 4BACBE11  bl 0x823ce110
	ctx.lr = 0x82902304;
	sub_823CE110(ctx, base);
	// 82902304: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82902308: 4B8B5811  bl 0x821b7b18
	ctx.lr = 0x8290230C;
	sub_821B7B18(ctx, base);
	// 8290230C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82902310: 4B91CF49  bl 0x8221f258
	ctx.lr = 0x82902314;
	sub_8221F258(ctx, base);
	// 82902314: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82902318: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8290231C: 419A005C  beq cr6, 0x82902378
	if ctx.cr[6].eq {
	pc = 0x82902378; continue 'dispatch;
	}
	// 82902320: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82902324: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82902328: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8290232C: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 82902330: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82902334: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82902338: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8290233C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82902340: 4B8EDF01  bl 0x821f0240
	ctx.lr = 0x82902344;
	sub_821F0240(ctx, base);
	// 82902344: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82902348: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 8290234C: 4B91CF0D  bl 0x8221f258
	ctx.lr = 0x82902350;
	sub_8221F258(ctx, base);
	// 82902350: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82902354: 419A0028  beq cr6, 0x8290237c
	if ctx.cr[6].eq {
	pc = 0x8290237C; continue 'dispatch;
	}
	// 82902358: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 8290235C: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82902360: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82902364: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 82902368: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8290236C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82902370: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82902374: 4800000C  b 0x82902380
	pc = 0x82902380; continue 'dispatch;
            }
            0x82902378 => {
    //   block [0x82902378..0x8290237C)
	// 82902378: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x8290237C; continue 'dispatch;
            }
            0x8290237C => {
    //   block [0x8290237C..0x82902380)
	// 8290237C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82902380; continue 'dispatch;
            }
            0x82902380 => {
    //   block [0x82902380..0x82902394)
	// 82902380: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82902384: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82902388: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290238C: 419A0008  beq cr6, 0x82902394
	if ctx.cr[6].eq {
	pc = 0x82902394; continue 'dispatch;
	}
	// 82902390: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82902394; continue 'dispatch;
            }
            0x82902394 => {
    //   block [0x82902394..0x82902414)
	// 82902394: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82902398: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290239C: 419A0078  beq cr6, 0x82902414
	if ctx.cr[6].eq {
	pc = 0x82902414; continue 'dispatch;
	}
	// 829023A0: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829023A4: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 829023A8: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829023AC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829023B0: 4B926D59  bl 0x82229108
	ctx.lr = 0x829023B4;
	sub_82229108(ctx, base);
	// 829023B4: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 829023B8: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 829023BC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829023C0: 3BCB33D0  addi r30, r11, 0x33d0
	ctx.r[30].s64 = ctx.r[11].s64 + 13264;
	// 829023C4: 4B9254BD  bl 0x82227880
	ctx.lr = 0x829023C8;
	sub_82227880(ctx, base);
	// 829023C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829023CC: 3D408290  lis r10, -0x7d70
	ctx.r[10].s64 = -2104492032;
	// 829023D0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829023D4: 388A39D8  addi r4, r10, 0x39d8
	ctx.r[4].s64 = ctx.r[10].s64 + 14808;
	// 829023D8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829023DC: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 829023E0: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829023E4: 4B89869D  bl 0x8219aa80
	ctx.lr = 0x829023E8;
	sub_8219AA80(ctx, base);
	// 829023E8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829023EC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829023F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829023F4: 4BACC02D  bl 0x823ce420
	ctx.lr = 0x829023F8;
	sub_823CE420(ctx, base);
	// 829023F8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829023FC: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 82902400: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82902404: 481222C5  bl 0x82a246c8
	ctx.lr = 0x82902408;
	sub_82A246C8(ctx, base);
	// 82902408: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290240C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 82902410: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x82902414; continue 'dispatch;
            }
            0x82902414 => {
    //   block [0x82902414..0x82902424)
	// 82902414: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82902418: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8290241C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82902420: 419A0020  beq cr6, 0x82902440
	if ctx.cr[6].eq {
	pc = 0x82902440; continue 'dispatch;
	}
	pc = 0x82902424; continue 'dispatch;
            }
            0x82902424 => {
    //   block [0x82902424..0x82902440)
	// 82902424: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82902428: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290242C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82902430: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82902434: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82902438: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290243C: 4082FFE8  bne 0x82902424
	if !ctx.cr[0].eq {
	pc = 0x82902424; continue 'dispatch;
	}
	pc = 0x82902440; continue 'dispatch;
            }
            0x82902440 => {
    //   block [0x82902440..0x82902460)
	// 82902440: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82902444: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82902448: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 8290244C: 4B9F34FD  bl 0x822f5948
	ctx.lr = 0x82902450;
	sub_822F5948(ctx, base);
	// 82902450: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82902454: 4B8B56C5  bl 0x821b7b18
	ctx.lr = 0x82902458;
	sub_821B7B18(ctx, base);
	// 82902458: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8290245C: 419A0040  beq cr6, 0x8290249c
	if ctx.cr[6].eq {
	pc = 0x8290249C; continue 'dispatch;
	}
	pc = 0x82902460; continue 'dispatch;
            }
            0x82902460 => {
    //   block [0x82902460..0x8290249C)
	// 82902460: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82902464: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82902468: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8290246C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82902470: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82902474: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82902478: 4082FFE8  bne 0x82902460
	if !ctx.cr[0].eq {
	pc = 0x82902460; continue 'dispatch;
	}
	// 8290247C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82902480: 409A001C  bne cr6, 0x8290249c
	if !ctx.cr[6].eq {
	pc = 0x8290249C; continue 'dispatch;
	}
	// 82902484: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82902488: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290248C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82902490: 4E800421  bctrl
	ctx.lr = 0x82902494;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82902494: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82902498: 4B9198A1  bl 0x8221bd38
	ctx.lr = 0x8290249C;
	sub_8221BD38(ctx, base);
            }
            0x8290249C => {
    //   block [0x8290249C..0x829024AC)
	// 8290249C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829024A0: 4B8B5679  bl 0x821b7b18
	ctx.lr = 0x829024A4;
	sub_821B7B18(ctx, base);
	// 829024A4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 829024A8: 483A6FA4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829024B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829024B0 size=512
    let mut pc: u32 = 0x829024B0;
    'dispatch: loop {
        match pc {
            0x829024B0 => {
    //   block [0x829024B0..0x829024E8)
	// 829024B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829024B4: 483A6F49  bl 0x82ca93fc
	ctx.lr = 0x829024B8;
	sub_82CA93D0(ctx, base);
	// 829024B8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829024BC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829024C0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 829024C4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 829024C8: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 829024CC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 829024D0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829024D4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 829024D8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 829024DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829024E0: 419A0008  beq cr6, 0x829024e8
	if ctx.cr[6].eq {
	pc = 0x829024E8; continue 'dispatch;
	}
	// 829024E4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829024E8; continue 'dispatch;
            }
            0x829024E8 => {
    //   block [0x829024E8..0x8290257C)
	// 829024E8: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829024EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829024F0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829024F4: 4BACC0CD  bl 0x823ce5c0
	ctx.lr = 0x829024F8;
	sub_823CE5C0(ctx, base);
	// 829024F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829024FC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82902500: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82902504: 4BACBC0D  bl 0x823ce110
	ctx.lr = 0x82902508;
	sub_823CE110(ctx, base);
	// 82902508: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8290250C: 4B8B560D  bl 0x821b7b18
	ctx.lr = 0x82902510;
	sub_821B7B18(ctx, base);
	// 82902510: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82902514: 4B91CD45  bl 0x8221f258
	ctx.lr = 0x82902518;
	sub_8221F258(ctx, base);
	// 82902518: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290251C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82902520: 419A005C  beq cr6, 0x8290257c
	if ctx.cr[6].eq {
	pc = 0x8290257C; continue 'dispatch;
	}
	// 82902524: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82902528: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 8290252C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82902530: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 82902534: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82902538: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8290253C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82902540: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82902544: 4B8EDCFD  bl 0x821f0240
	ctx.lr = 0x82902548;
	sub_821F0240(ctx, base);
	// 82902548: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8290254C: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82902550: 4B91CD09  bl 0x8221f258
	ctx.lr = 0x82902554;
	sub_8221F258(ctx, base);
	// 82902554: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82902558: 419A0028  beq cr6, 0x82902580
	if ctx.cr[6].eq {
	pc = 0x82902580; continue 'dispatch;
	}
	// 8290255C: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 82902560: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82902564: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82902568: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 8290256C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82902570: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82902574: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82902578: 4800000C  b 0x82902584
	pc = 0x82902584; continue 'dispatch;
            }
            0x8290257C => {
    //   block [0x8290257C..0x82902580)
	// 8290257C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x82902580; continue 'dispatch;
            }
            0x82902580 => {
    //   block [0x82902580..0x82902584)
	// 82902580: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82902584; continue 'dispatch;
            }
            0x82902584 => {
    //   block [0x82902584..0x82902598)
	// 82902584: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82902588: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 8290258C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82902590: 419A0008  beq cr6, 0x82902598
	if ctx.cr[6].eq {
	pc = 0x82902598; continue 'dispatch;
	}
	// 82902594: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82902598; continue 'dispatch;
            }
            0x82902598 => {
    //   block [0x82902598..0x82902618)
	// 82902598: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8290259C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829025A0: 419A0078  beq cr6, 0x82902618
	if ctx.cr[6].eq {
	pc = 0x82902618; continue 'dispatch;
	}
	// 829025A4: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829025A8: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 829025AC: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829025B0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829025B4: 4B926B55  bl 0x82229108
	ctx.lr = 0x829025B8;
	sub_82229108(ctx, base);
	// 829025B8: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 829025BC: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 829025C0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829025C4: 3BCB3550  addi r30, r11, 0x3550
	ctx.r[30].s64 = ctx.r[11].s64 + 13648;
	// 829025C8: 4B9252B9  bl 0x82227880
	ctx.lr = 0x829025CC;
	sub_82227880(ctx, base);
	// 829025CC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829025D0: 3D408289  lis r10, -0x7d77
	ctx.r[10].s64 = -2104950784;
	// 829025D4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829025D8: 388A39E8  addi r4, r10, 0x39e8
	ctx.r[4].s64 = ctx.r[10].s64 + 14824;
	// 829025DC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829025E0: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 829025E4: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829025E8: 4B898499  bl 0x8219aa80
	ctx.lr = 0x829025EC;
	sub_8219AA80(ctx, base);
	// 829025EC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829025F0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829025F4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829025F8: 4BACBE29  bl 0x823ce420
	ctx.lr = 0x829025FC;
	sub_823CE420(ctx, base);
	// 829025FC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82902600: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 82902604: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82902608: 481220C1  bl 0x82a246c8
	ctx.lr = 0x8290260C;
	sub_82A246C8(ctx, base);
	// 8290260C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82902610: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 82902614: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x82902618; continue 'dispatch;
            }
            0x82902618 => {
    //   block [0x82902618..0x82902628)
	// 82902618: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8290261C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82902620: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82902624: 419A0020  beq cr6, 0x82902644
	if ctx.cr[6].eq {
	pc = 0x82902644; continue 'dispatch;
	}
	pc = 0x82902628; continue 'dispatch;
            }
            0x82902628 => {
    //   block [0x82902628..0x82902644)
	// 82902628: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8290262C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82902630: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82902634: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82902638: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8290263C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82902640: 4082FFE8  bne 0x82902628
	if !ctx.cr[0].eq {
	pc = 0x82902628; continue 'dispatch;
	}
	pc = 0x82902644; continue 'dispatch;
            }
            0x82902644 => {
    //   block [0x82902644..0x82902664)
	// 82902644: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82902648: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8290264C: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 82902650: 4B9F32F9  bl 0x822f5948
	ctx.lr = 0x82902654;
	sub_822F5948(ctx, base);
	// 82902654: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82902658: 4B8B54C1  bl 0x821b7b18
	ctx.lr = 0x8290265C;
	sub_821B7B18(ctx, base);
	// 8290265C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82902660: 419A0040  beq cr6, 0x829026a0
	if ctx.cr[6].eq {
	pc = 0x829026A0; continue 'dispatch;
	}
	pc = 0x82902664; continue 'dispatch;
            }
            0x82902664 => {
    //   block [0x82902664..0x829026A0)
	// 82902664: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82902668: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290266C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82902670: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82902674: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82902678: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290267C: 4082FFE8  bne 0x82902664
	if !ctx.cr[0].eq {
	pc = 0x82902664; continue 'dispatch;
	}
	// 82902680: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82902684: 409A001C  bne cr6, 0x829026a0
	if !ctx.cr[6].eq {
	pc = 0x829026A0; continue 'dispatch;
	}
	// 82902688: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290268C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82902690: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82902694: 4E800421  bctrl
	ctx.lr = 0x82902698;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82902698: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8290269C: 4B91969D  bl 0x8221bd38
	ctx.lr = 0x829026A0;
	sub_8221BD38(ctx, base);
            }
            0x829026A0 => {
    //   block [0x829026A0..0x829026B0)
	// 829026A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829026A4: 4B8B5475  bl 0x821b7b18
	ctx.lr = 0x829026A8;
	sub_821B7B18(ctx, base);
	// 829026A8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 829026AC: 483A6DA0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829026B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829026B0 size=512
    let mut pc: u32 = 0x829026B0;
    'dispatch: loop {
        match pc {
            0x829026B0 => {
    //   block [0x829026B0..0x829026E8)
	// 829026B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829026B4: 483A6D49  bl 0x82ca93fc
	ctx.lr = 0x829026B8;
	sub_82CA93D0(ctx, base);
	// 829026B8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829026BC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829026C0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 829026C4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 829026C8: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 829026CC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 829026D0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829026D4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 829026D8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 829026DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829026E0: 419A0008  beq cr6, 0x829026e8
	if ctx.cr[6].eq {
	pc = 0x829026E8; continue 'dispatch;
	}
	// 829026E4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829026E8; continue 'dispatch;
            }
            0x829026E8 => {
    //   block [0x829026E8..0x8290277C)
	// 829026E8: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829026EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829026F0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829026F4: 4BACBECD  bl 0x823ce5c0
	ctx.lr = 0x829026F8;
	sub_823CE5C0(ctx, base);
	// 829026F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829026FC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82902700: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82902704: 4BACBA0D  bl 0x823ce110
	ctx.lr = 0x82902708;
	sub_823CE110(ctx, base);
	// 82902708: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8290270C: 4B8B540D  bl 0x821b7b18
	ctx.lr = 0x82902710;
	sub_821B7B18(ctx, base);
	// 82902710: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82902714: 4B91CB45  bl 0x8221f258
	ctx.lr = 0x82902718;
	sub_8221F258(ctx, base);
	// 82902718: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290271C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82902720: 419A005C  beq cr6, 0x8290277c
	if ctx.cr[6].eq {
	pc = 0x8290277C; continue 'dispatch;
	}
	// 82902724: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82902728: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 8290272C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82902730: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 82902734: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82902738: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8290273C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82902740: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82902744: 4B8EDAFD  bl 0x821f0240
	ctx.lr = 0x82902748;
	sub_821F0240(ctx, base);
	// 82902748: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8290274C: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82902750: 4B91CB09  bl 0x8221f258
	ctx.lr = 0x82902754;
	sub_8221F258(ctx, base);
	// 82902754: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82902758: 419A0028  beq cr6, 0x82902780
	if ctx.cr[6].eq {
	pc = 0x82902780; continue 'dispatch;
	}
	// 8290275C: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 82902760: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82902764: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82902768: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 8290276C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82902770: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82902774: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82902778: 4800000C  b 0x82902784
	pc = 0x82902784; continue 'dispatch;
            }
            0x8290277C => {
    //   block [0x8290277C..0x82902780)
	// 8290277C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x82902780; continue 'dispatch;
            }
            0x82902780 => {
    //   block [0x82902780..0x82902784)
	// 82902780: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82902784; continue 'dispatch;
            }
            0x82902784 => {
    //   block [0x82902784..0x82902798)
	// 82902784: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82902788: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 8290278C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82902790: 419A0008  beq cr6, 0x82902798
	if ctx.cr[6].eq {
	pc = 0x82902798; continue 'dispatch;
	}
	// 82902794: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82902798; continue 'dispatch;
            }
            0x82902798 => {
    //   block [0x82902798..0x82902818)
	// 82902798: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8290279C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829027A0: 419A0078  beq cr6, 0x82902818
	if ctx.cr[6].eq {
	pc = 0x82902818; continue 'dispatch;
	}
	// 829027A4: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829027A8: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 829027AC: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829027B0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829027B4: 4B926955  bl 0x82229108
	ctx.lr = 0x829027B8;
	sub_82229108(ctx, base);
	// 829027B8: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 829027BC: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 829027C0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829027C4: 3BCB3708  addi r30, r11, 0x3708
	ctx.r[30].s64 = ctx.r[11].s64 + 14088;
	// 829027C8: 4B9250B9  bl 0x82227880
	ctx.lr = 0x829027CC;
	sub_82227880(ctx, base);
	// 829027CC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829027D0: 3D408273  lis r10, -0x7d8d
	ctx.r[10].s64 = -2106392576;
	// 829027D4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829027D8: 388A1C40  addi r4, r10, 0x1c40
	ctx.r[4].s64 = ctx.r[10].s64 + 7232;
	// 829027DC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829027E0: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 829027E4: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829027E8: 4B898299  bl 0x8219aa80
	ctx.lr = 0x829027EC;
	sub_8219AA80(ctx, base);
	// 829027EC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829027F0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829027F4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829027F8: 4BACBC29  bl 0x823ce420
	ctx.lr = 0x829027FC;
	sub_823CE420(ctx, base);
	// 829027FC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82902800: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 82902804: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82902808: 48121EC1  bl 0x82a246c8
	ctx.lr = 0x8290280C;
	sub_82A246C8(ctx, base);
	// 8290280C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82902810: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 82902814: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x82902818; continue 'dispatch;
            }
            0x82902818 => {
    //   block [0x82902818..0x82902828)
	// 82902818: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8290281C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82902820: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82902824: 419A0020  beq cr6, 0x82902844
	if ctx.cr[6].eq {
	pc = 0x82902844; continue 'dispatch;
	}
	pc = 0x82902828; continue 'dispatch;
            }
            0x82902828 => {
    //   block [0x82902828..0x82902844)
	// 82902828: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8290282C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82902830: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82902834: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82902838: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8290283C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82902840: 4082FFE8  bne 0x82902828
	if !ctx.cr[0].eq {
	pc = 0x82902828; continue 'dispatch;
	}
	pc = 0x82902844; continue 'dispatch;
            }
            0x82902844 => {
    //   block [0x82902844..0x82902864)
	// 82902844: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82902848: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8290284C: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 82902850: 4B9F30F9  bl 0x822f5948
	ctx.lr = 0x82902854;
	sub_822F5948(ctx, base);
	// 82902854: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82902858: 4B8B52C1  bl 0x821b7b18
	ctx.lr = 0x8290285C;
	sub_821B7B18(ctx, base);
	// 8290285C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82902860: 419A0040  beq cr6, 0x829028a0
	if ctx.cr[6].eq {
	pc = 0x829028A0; continue 'dispatch;
	}
	pc = 0x82902864; continue 'dispatch;
            }
            0x82902864 => {
    //   block [0x82902864..0x829028A0)
	// 82902864: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82902868: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290286C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82902870: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82902874: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82902878: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290287C: 4082FFE8  bne 0x82902864
	if !ctx.cr[0].eq {
	pc = 0x82902864; continue 'dispatch;
	}
	// 82902880: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82902884: 409A001C  bne cr6, 0x829028a0
	if !ctx.cr[6].eq {
	pc = 0x829028A0; continue 'dispatch;
	}
	// 82902888: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290288C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82902890: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82902894: 4E800421  bctrl
	ctx.lr = 0x82902898;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82902898: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8290289C: 4B91949D  bl 0x8221bd38
	ctx.lr = 0x829028A0;
	sub_8221BD38(ctx, base);
            }
            0x829028A0 => {
    //   block [0x829028A0..0x829028B0)
	// 829028A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829028A4: 4B8B5275  bl 0x821b7b18
	ctx.lr = 0x829028A8;
	sub_821B7B18(ctx, base);
	// 829028A8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 829028AC: 483A6BA0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829028B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829028B0 size=448
    let mut pc: u32 = 0x829028B0;
    'dispatch: loop {
        match pc {
            0x829028B0 => {
    //   block [0x829028B0..0x829028EC)
	// 829028B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829028B4: 483A6B49  bl 0x82ca93fc
	ctx.lr = 0x829028B8;
	sub_82CA93D0(ctx, base);
	// 829028B8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829028BC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829028C0: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 829028C4: 3D408290  lis r10, -0x7d70
	ctx.r[10].s64 = -2104492032;
	// 829028C8: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 829028CC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 829028D0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829028D4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 829028D8: 3BAAF240  addi r29, r10, -0xdc0
	ctx.r[29].s64 = ctx.r[10].s64 + -3520;
	// 829028DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829028E0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 829028E4: 419A0008  beq cr6, 0x829028ec
	if ctx.cr[6].eq {
	pc = 0x829028EC; continue 'dispatch;
	}
	// 829028E8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829028EC; continue 'dispatch;
            }
            0x829028EC => {
    //   block [0x829028EC..0x82902950)
	// 829028EC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829028F0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829028F4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829028F8: 4BACBCC9  bl 0x823ce5c0
	ctx.lr = 0x829028FC;
	sub_823CE5C0(ctx, base);
	// 829028FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82902900: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82902904: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82902908: 4BACB809  bl 0x823ce110
	ctx.lr = 0x8290290C;
	sub_823CE110(ctx, base);
	// 8290290C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82902910: 4B8B5209  bl 0x821b7b18
	ctx.lr = 0x82902914;
	sub_821B7B18(ctx, base);
	// 82902914: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82902918: 4B91C941  bl 0x8221f258
	ctx.lr = 0x8290291C;
	sub_8221F258(ctx, base);
	// 8290291C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82902920: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82902924: 419A002C  beq cr6, 0x82902950
	if ctx.cr[6].eq {
	pc = 0x82902950; continue 'dispatch;
	}
	// 82902928: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8290292C: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82902930: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82902934: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 82902938: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8290293C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82902940: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82902944: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82902948: 4B8ED8F9  bl 0x821f0240
	ctx.lr = 0x8290294C;
	sub_821F0240(ctx, base);
	// 8290294C: 48000008  b 0x82902954
	pc = 0x82902954; continue 'dispatch;
            }
            0x82902950 => {
    //   block [0x82902950..0x82902954)
	// 82902950: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82902954; continue 'dispatch;
            }
            0x82902954 => {
    //   block [0x82902954..0x82902978)
	// 82902954: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 82902958: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8290295C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82902960: 419A0018  beq cr6, 0x82902978
	if ctx.cr[6].eq {
	pc = 0x82902978; continue 'dispatch;
	}
	// 82902964: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82902968: 48102359  bl 0x82a04cc0
	ctx.lr = 0x8290296C;
	sub_82A04CC0(ctx, base);
	// 8290296C: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82902970: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82902974: 4800000C  b 0x82902980
	pc = 0x82902980; continue 'dispatch;
            }
            0x82902978 => {
    //   block [0x82902978..0x82902980)
	// 82902978: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8290297C: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	pc = 0x82902980; continue 'dispatch;
            }
            0x82902980 => {
    //   block [0x82902980..0x82902994)
	// 82902980: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82902984: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82902988: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290298C: 419A0008  beq cr6, 0x82902994
	if ctx.cr[6].eq {
	pc = 0x82902994; continue 'dispatch;
	}
	// 82902990: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82902994; continue 'dispatch;
            }
            0x82902994 => {
    //   block [0x82902994..0x82902A14)
	// 82902994: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82902998: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290299C: 419A0078  beq cr6, 0x82902a14
	if ctx.cr[6].eq {
	pc = 0x82902A14; continue 'dispatch;
	}
	// 829029A0: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829029A4: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 829029A8: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829029AC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829029B0: 4B926759  bl 0x82229108
	ctx.lr = 0x829029B4;
	sub_82229108(ctx, base);
	// 829029B4: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 829029B8: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 829029BC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829029C0: 3BCB30F8  addi r30, r11, 0x30f8
	ctx.r[30].s64 = ctx.r[11].s64 + 12536;
	// 829029C4: 4B924EBD  bl 0x82227880
	ctx.lr = 0x829029C8;
	sub_82227880(ctx, base);
	// 829029C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829029CC: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 829029D0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829029D4: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 829029D8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829029DC: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 829029E0: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829029E4: 4B89809D  bl 0x8219aa80
	ctx.lr = 0x829029E8;
	sub_8219AA80(ctx, base);
	// 829029E8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829029EC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829029F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829029F4: 4BACBA2D  bl 0x823ce420
	ctx.lr = 0x829029F8;
	sub_823CE420(ctx, base);
	// 829029F8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829029FC: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 82902A00: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82902A04: 48121CC5  bl 0x82a246c8
	ctx.lr = 0x82902A08;
	sub_82A246C8(ctx, base);
	// 82902A08: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82902A0C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 82902A10: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x82902A14; continue 'dispatch;
            }
            0x82902A14 => {
    //   block [0x82902A14..0x82902A24)
	// 82902A14: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82902A18: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82902A1C: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 82902A20: 419A0020  beq cr6, 0x82902a40
	if ctx.cr[6].eq {
	pc = 0x82902A40; continue 'dispatch;
	}
	pc = 0x82902A24; continue 'dispatch;
            }
            0x82902A24 => {
    //   block [0x82902A24..0x82902A40)
	// 82902A24: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82902A28: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82902A2C: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82902A30: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82902A34: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82902A38: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82902A3C: 4082FFE8  bne 0x82902a24
	if !ctx.cr[0].eq {
	pc = 0x82902A24; continue 'dispatch;
	}
	pc = 0x82902A40; continue 'dispatch;
            }
            0x82902A40 => {
    //   block [0x82902A40..0x82902A70)
	// 82902A40: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82902A44: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82902A48: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 82902A4C: 4B9F2EFD  bl 0x822f5948
	ctx.lr = 0x82902A50;
	sub_822F5948(ctx, base);
	// 82902A50: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82902A54: 4B8B50C5  bl 0x821b7b18
	ctx.lr = 0x82902A58;
	sub_821B7B18(ctx, base);
	// 82902A58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82902A5C: 4B8B50BD  bl 0x821b7b18
	ctx.lr = 0x82902A60;
	sub_821B7B18(ctx, base);
	// 82902A60: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82902A64: 4B8B50B5  bl 0x821b7b18
	ctx.lr = 0x82902A68;
	sub_821B7B18(ctx, base);
	// 82902A68: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82902A6C: 483A69E0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82902A70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82902A70 size=56
    let mut pc: u32 = 0x82902A70;
    'dispatch: loop {
        match pc {
            0x82902A70 => {
    //   block [0x82902A70..0x82902A8C)
	// 82902A70: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82902A74: 419A0018  beq cr6, 0x82902a8c
	if ctx.cr[6].eq {
	pc = 0x82902A8C; continue 'dispatch;
	}
	// 82902A78: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 82902A7C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82902A80: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82902A84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82902A88: 409A0008  bne cr6, 0x82902a90
	if !ctx.cr[6].eq {
	pc = 0x82902A90; continue 'dispatch;
	}
	pc = 0x82902A8C; continue 'dispatch;
            }
            0x82902A8C => {
    //   block [0x82902A8C..0x82902A90)
	// 82902A8C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82902A90; continue 'dispatch;
            }
            0x82902A90 => {
    //   block [0x82902A90..0x82902AA8)
	// 82902A90: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82902A94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82902A98: 419A0010  beq cr6, 0x82902aa8
	if ctx.cr[6].eq {
		sub_82902AA8(ctx, base);
		return;
	}
	// 82902A9C: A1640034  lhz r11, 0x34(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) } as u64;
	// 82902AA0: 556307FE  clrlwi r3, r11, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82902AA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82902AA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82902AA8 size=8
    let mut pc: u32 = 0x82902AA8;
    'dispatch: loop {
        match pc {
            0x82902AA8 => {
    //   block [0x82902AA8..0x82902AB0)
	// 82902AA8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82902AAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82902AB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82902AB0 size=388
    let mut pc: u32 = 0x82902AB0;
    'dispatch: loop {
        match pc {
            0x82902AB0 => {
    //   block [0x82902AB0..0x82902AE4)
	// 82902AB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82902AB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82902AB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82902ABC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82902AC0: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82902AC4: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82902AC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82902ACC: 419A0018  beq cr6, 0x82902ae4
	if ctx.cr[6].eq {
	pc = 0x82902AE4; continue 'dispatch;
	}
	// 82902AD0: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 82902AD4: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82902AD8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82902ADC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82902AE0: 409A0008  bne cr6, 0x82902ae8
	if !ctx.cr[6].eq {
	pc = 0x82902AE8; continue 'dispatch;
	}
	pc = 0x82902AE4; continue 'dispatch;
            }
            0x82902AE4 => {
    //   block [0x82902AE4..0x82902AE8)
	// 82902AE4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82902AE8; continue 'dispatch;
            }
            0x82902AE8 => {
    //   block [0x82902AE8..0x82902B34)
	// 82902AE8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82902AEC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82902AF0: 419A0130  beq cr6, 0x82902c20
	if ctx.cr[6].eq {
	pc = 0x82902C20; continue 'dispatch;
	}
	// 82902AF4: A12B0034  lhz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82902AF8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82902AFC: 552807FE  clrlwi r8, r9, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 82902B00: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82902B04: 419A00F8  beq cr6, 0x82902bfc
	if ctx.cr[6].eq {
	pc = 0x82902BFC; continue 'dispatch;
	}
	// 82902B08: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82902B0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82902B10: 419A0024  beq cr6, 0x82902b34
	if ctx.cr[6].eq {
	pc = 0x82902B34; continue 'dispatch;
	}
	// 82902B14: 892A0090  lbz r9, 0x90(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(144 as u32) ) } as u64;
	// 82902B18: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82902B1C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 82902B20: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82902B24: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82902B28: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82902B2C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82902B30: 480000D0  b 0x82902c00
	pc = 0x82902C00; continue 'dispatch;
            }
            0x82902B34 => {
    //   block [0x82902B34..0x82902B54)
	// 82902B34: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82902B38: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82902B3C: 83EB004C  lwz r31, 0x4c(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82902B40: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82902B44: 7D0AF850  subf r8, r10, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 82902B48: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82902B4C: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82902B50: 40810054  ble 0x82902ba4
	if !ctx.cr[0].gt {
	pc = 0x82902BA4; continue 'dispatch;
	}
	pc = 0x82902B54; continue 'dispatch;
            }
            0x82902B54 => {
    //   block [0x82902B54..0x82902B74)
	// 82902B54: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82902B58: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82902B5C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82902B60: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82902B64: 2F070090  cmpwi cr6, r7, 0x90
	ctx.cr[6].compare_i32(ctx.r[7].s32, 144, &mut ctx.xer);
	// 82902B68: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82902B6C: 41980008  blt cr6, 0x82902b74
	if ctx.cr[6].lt {
	pc = 0x82902B74; continue 'dispatch;
	}
	// 82902B70: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x82902B74; continue 'dispatch;
            }
            0x82902B74 => {
    //   block [0x82902B74..0x82902B90)
	// 82902B74: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82902B78: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82902B7C: 419A0014  beq cr6, 0x82902b90
	if ctx.cr[6].eq {
	pc = 0x82902B90; continue 'dispatch;
	}
	// 82902B80: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82902B84: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82902B88: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82902B8C: 4800000C  b 0x82902b98
	pc = 0x82902B98; continue 'dispatch;
            }
            0x82902B90 => {
    //   block [0x82902B90..0x82902B98)
	// 82902B90: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82902B94: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82902B98; continue 'dispatch;
            }
            0x82902B98 => {
    //   block [0x82902B98..0x82902BA4)
	// 82902B98: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82902B9C: 4199FFB8  bgt cr6, 0x82902b54
	if ctx.cr[6].gt {
	pc = 0x82902B54; continue 'dispatch;
	}
	// 82902BA0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82902BA4; continue 'dispatch;
            }
            0x82902BA4 => {
    //   block [0x82902BA4..0x82902BC0)
	// 82902BA4: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82902BA8: 419A0040  beq cr6, 0x82902be8
	if ctx.cr[6].eq {
	pc = 0x82902BE8; continue 'dispatch;
	}
	// 82902BAC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82902BB0: 2F0B0090  cmpwi cr6, r11, 0x90
	ctx.cr[6].compare_i32(ctx.r[11].s32, 144, &mut ctx.xer);
	// 82902BB4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82902BB8: 41990008  bgt cr6, 0x82902bc0
	if ctx.cr[6].gt {
	pc = 0x82902BC0; continue 'dispatch;
	}
	// 82902BBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82902BC0; continue 'dispatch;
            }
            0x82902BC0 => {
    //   block [0x82902BC0..0x82902BE8)
	// 82902BC0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82902BC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82902BC8: 409A0020  bne cr6, 0x82902be8
	if !ctx.cr[6].eq {
	pc = 0x82902BE8; continue 'dispatch;
	}
	// 82902BCC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82902BD0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82902BD4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82902BD8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82902BDC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82902BE0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82902BE4: 4800001C  b 0x82902c00
	pc = 0x82902C00; continue 'dispatch;
            }
            0x82902BE8 => {
    //   block [0x82902BE8..0x82902BFC)
	// 82902BE8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82902BEC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82902BF0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82902BF4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82902BF8: 48000008  b 0x82902c00
	pc = 0x82902C00; continue 'dispatch;
            }
            0x82902BFC => {
    //   block [0x82902BFC..0x82902C00)
	// 82902BFC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82902C00; continue 'dispatch;
            }
            0x82902C00 => {
    //   block [0x82902C00..0x82902C20)
	// 82902C00: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82902C04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82902C08: 419A0018  beq cr6, 0x82902c20
	if ctx.cr[6].eq {
	pc = 0x82902C20; continue 'dispatch;
	}
	// 82902C0C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82902C10: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82902C14: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82902C18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82902C1C: 4E800421  bctrl
	ctx.lr = 0x82902C20;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82902C20 => {
    //   block [0x82902C20..0x82902C34)
	// 82902C20: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82902C24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82902C28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82902C2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82902C30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82902C38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82902C38 size=376
    let mut pc: u32 = 0x82902C38;
    'dispatch: loop {
        match pc {
            0x82902C38 => {
    //   block [0x82902C38..0x82902C64)
	// 82902C38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82902C3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82902C40: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82902C44: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82902C48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82902C4C: 419A0018  beq cr6, 0x82902c64
	if ctx.cr[6].eq {
	pc = 0x82902C64; continue 'dispatch;
	}
	// 82902C50: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 82902C54: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82902C58: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82902C5C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82902C60: 409A0008  bne cr6, 0x82902c68
	if !ctx.cr[6].eq {
	pc = 0x82902C68; continue 'dispatch;
	}
	pc = 0x82902C64; continue 'dispatch;
            }
            0x82902C64 => {
    //   block [0x82902C64..0x82902C68)
	// 82902C64: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82902C68; continue 'dispatch;
            }
            0x82902C68 => {
    //   block [0x82902C68..0x82902CB4)
	// 82902C68: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82902C6C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82902C70: 419A0130  beq cr6, 0x82902da0
	if ctx.cr[6].eq {
	pc = 0x82902DA0; continue 'dispatch;
	}
	// 82902C74: A12B0034  lhz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82902C78: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82902C7C: 552807FE  clrlwi r8, r9, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 82902C80: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82902C84: 419A00F8  beq cr6, 0x82902d7c
	if ctx.cr[6].eq {
	pc = 0x82902D7C; continue 'dispatch;
	}
	// 82902C88: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82902C8C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82902C90: 419A0024  beq cr6, 0x82902cb4
	if ctx.cr[6].eq {
	pc = 0x82902CB4; continue 'dispatch;
	}
	// 82902C94: 892A0090  lbz r9, 0x90(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(144 as u32) ) } as u64;
	// 82902C98: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82902C9C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 82902CA0: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82902CA4: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82902CA8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82902CAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82902CB0: 480000D0  b 0x82902d80
	pc = 0x82902D80; continue 'dispatch;
            }
            0x82902CB4 => {
    //   block [0x82902CB4..0x82902CD4)
	// 82902CB4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82902CB8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82902CBC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82902CC0: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82902CC4: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82902CC8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82902CCC: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82902CD0: 40810054  ble 0x82902d24
	if !ctx.cr[0].gt {
	pc = 0x82902D24; continue 'dispatch;
	}
	pc = 0x82902CD4; continue 'dispatch;
            }
            0x82902CD4 => {
    //   block [0x82902CD4..0x82902CF4)
	// 82902CD4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82902CD8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82902CDC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82902CE0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82902CE4: 2F070090  cmpwi cr6, r7, 0x90
	ctx.cr[6].compare_i32(ctx.r[7].s32, 144, &mut ctx.xer);
	// 82902CE8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82902CEC: 41980008  blt cr6, 0x82902cf4
	if ctx.cr[6].lt {
	pc = 0x82902CF4; continue 'dispatch;
	}
	// 82902CF0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x82902CF4; continue 'dispatch;
            }
            0x82902CF4 => {
    //   block [0x82902CF4..0x82902D10)
	// 82902CF4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82902CF8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82902CFC: 419A0014  beq cr6, 0x82902d10
	if ctx.cr[6].eq {
	pc = 0x82902D10; continue 'dispatch;
	}
	// 82902D00: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82902D04: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82902D08: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82902D0C: 4800000C  b 0x82902d18
	pc = 0x82902D18; continue 'dispatch;
            }
            0x82902D10 => {
    //   block [0x82902D10..0x82902D18)
	// 82902D10: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82902D14: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82902D18; continue 'dispatch;
            }
            0x82902D18 => {
    //   block [0x82902D18..0x82902D24)
	// 82902D18: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82902D1C: 4199FFB8  bgt cr6, 0x82902cd4
	if ctx.cr[6].gt {
	pc = 0x82902CD4; continue 'dispatch;
	}
	// 82902D20: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82902D24; continue 'dispatch;
            }
            0x82902D24 => {
    //   block [0x82902D24..0x82902D40)
	// 82902D24: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82902D28: 419A0040  beq cr6, 0x82902d68
	if ctx.cr[6].eq {
	pc = 0x82902D68; continue 'dispatch;
	}
	// 82902D2C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82902D30: 2F0B0090  cmpwi cr6, r11, 0x90
	ctx.cr[6].compare_i32(ctx.r[11].s32, 144, &mut ctx.xer);
	// 82902D34: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82902D38: 41990008  bgt cr6, 0x82902d40
	if ctx.cr[6].gt {
	pc = 0x82902D40; continue 'dispatch;
	}
	// 82902D3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82902D40; continue 'dispatch;
            }
            0x82902D40 => {
    //   block [0x82902D40..0x82902D68)
	// 82902D40: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82902D44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82902D48: 409A0020  bne cr6, 0x82902d68
	if !ctx.cr[6].eq {
	pc = 0x82902D68; continue 'dispatch;
	}
	// 82902D4C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82902D50: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82902D54: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82902D58: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82902D5C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82902D60: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82902D64: 4800001C  b 0x82902d80
	pc = 0x82902D80; continue 'dispatch;
            }
            0x82902D68 => {
    //   block [0x82902D68..0x82902D7C)
	// 82902D68: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82902D6C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82902D70: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82902D74: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82902D78: 48000008  b 0x82902d80
	pc = 0x82902D80; continue 'dispatch;
            }
            0x82902D7C => {
    //   block [0x82902D7C..0x82902D80)
	// 82902D7C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82902D80; continue 'dispatch;
            }
            0x82902D80 => {
    //   block [0x82902D80..0x82902DA0)
	// 82902D80: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82902D84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82902D88: 419A0018  beq cr6, 0x82902da0
	if ctx.cr[6].eq {
	pc = 0x82902DA0; continue 'dispatch;
	}
	// 82902D8C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82902D90: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82902D94: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82902D98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82902D9C: 4E800421  bctrl
	ctx.lr = 0x82902DA0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82902DA0 => {
    //   block [0x82902DA0..0x82902DB0)
	// 82902DA0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82902DA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82902DA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82902DAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82902DB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82902DB0 size=464
    let mut pc: u32 = 0x82902DB0;
    'dispatch: loop {
        match pc {
            0x82902DB0 => {
    //   block [0x82902DB0..0x82902E3C)
	// 82902DB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82902DB4: 483A6659  bl 0x82ca940c
	ctx.lr = 0x82902DB8;
	sub_82CA93D0(ctx, base);
	// 82902DB8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82902DBC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82902DC0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82902DC4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82902DC8: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82902DCC: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82902DD0: 55280038  rlwinm r8, r9, 0, 0, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82902DD4: 2F080008  cmpwi cr6, r8, 8
	ctx.cr[6].compare_i32(ctx.r[8].s32, 8, &mut ctx.xer);
	// 82902DD8: 4198019C  blt cr6, 0x82902f74
	if ctx.cr[6].lt {
	pc = 0x82902F74; continue 'dispatch;
	}
	// 82902DDC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82902DE0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82902DE4: 38AB79B0  addi r5, r11, 0x79b0
	ctx.r[5].s64 = ctx.r[11].s64 + 31152;
	// 82902DE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82902DEC: 4B9251DD  bl 0x82227fc8
	ctx.lr = 0x82902DF0;
	sub_82227FC8(ctx, base);
	// 82902DF0: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82902DF4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82902DF8: 419A017C  beq cr6, 0x82902f74
	if ctx.cr[6].eq {
	pc = 0x82902F74; continue 'dispatch;
	}
	// 82902DFC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82902E00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82902E04: 4B9252F5  bl 0x822280f8
	ctx.lr = 0x82902E08;
	sub_822280F8(ctx, base);
	// 82902E08: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82902E0C: 4B924755  bl 0x82227560
	ctx.lr = 0x82902E10;
	sub_82227560(ctx, base);
	// 82902E10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82902E14: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82902E18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82902E1C: 4B8DD56D  bl 0x821e0388
	ctx.lr = 0x82902E20;
	sub_821E0388(ctx, base);
	// 82902E20: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82902E24: 419A0018  beq cr6, 0x82902e3c
	if ctx.cr[6].eq {
	pc = 0x82902E3C; continue 'dispatch;
	}
	// 82902E28: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82902E2C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82902E30: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82902E34: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82902E38: 409A0008  bne cr6, 0x82902e40
	if !ctx.cr[6].eq {
	pc = 0x82902E40; continue 'dispatch;
	}
	pc = 0x82902E3C; continue 'dispatch;
            }
            0x82902E3C => {
    //   block [0x82902E3C..0x82902E40)
	// 82902E3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82902E40; continue 'dispatch;
            }
            0x82902E40 => {
    //   block [0x82902E40..0x82902E88)
	// 82902E40: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82902E44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82902E48: 419A012C  beq cr6, 0x82902f74
	if ctx.cr[6].eq {
	pc = 0x82902F74; continue 'dispatch;
	}
	// 82902E4C: A15F0034  lhz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82902E50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82902E54: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82902E58: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82902E5C: 419A00EC  beq cr6, 0x82902f48
	if ctx.cr[6].eq {
	pc = 0x82902F48; continue 'dispatch;
	}
	// 82902E60: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82902E64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82902E68: 419A0020  beq cr6, 0x82902e88
	if ctx.cr[6].eq {
	pc = 0x82902E88; continue 'dispatch;
	}
	// 82902E6C: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 82902E70: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82902E74: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82902E78: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82902E7C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82902E80: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82902E84: 480000C8  b 0x82902f4c
	pc = 0x82902F4C; continue 'dispatch;
            }
            0x82902E88 => {
    //   block [0x82902E88..0x82902EA8)
	// 82902E88: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82902E8C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82902E90: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82902E94: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82902E98: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82902E9C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82902EA0: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82902EA4: 40810054  ble 0x82902ef8
	if !ctx.cr[0].gt {
	pc = 0x82902EF8; continue 'dispatch;
	}
	pc = 0x82902EA8; continue 'dispatch;
            }
            0x82902EA8 => {
    //   block [0x82902EA8..0x82902EC8)
	// 82902EA8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82902EAC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82902EB0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82902EB4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82902EB8: 2F070090  cmpwi cr6, r7, 0x90
	ctx.cr[6].compare_i32(ctx.r[7].s32, 144, &mut ctx.xer);
	// 82902EBC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82902EC0: 41980008  blt cr6, 0x82902ec8
	if ctx.cr[6].lt {
	pc = 0x82902EC8; continue 'dispatch;
	}
	// 82902EC4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x82902EC8; continue 'dispatch;
            }
            0x82902EC8 => {
    //   block [0x82902EC8..0x82902EE4)
	// 82902EC8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82902ECC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82902ED0: 419A0014  beq cr6, 0x82902ee4
	if ctx.cr[6].eq {
	pc = 0x82902EE4; continue 'dispatch;
	}
	// 82902ED4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82902ED8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82902EDC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82902EE0: 4800000C  b 0x82902eec
	pc = 0x82902EEC; continue 'dispatch;
            }
            0x82902EE4 => {
    //   block [0x82902EE4..0x82902EEC)
	// 82902EE4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82902EE8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82902EEC; continue 'dispatch;
            }
            0x82902EEC => {
    //   block [0x82902EEC..0x82902EF8)
	// 82902EEC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82902EF0: 4199FFB8  bgt cr6, 0x82902ea8
	if ctx.cr[6].gt {
	pc = 0x82902EA8; continue 'dispatch;
	}
	// 82902EF4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82902EF8; continue 'dispatch;
            }
            0x82902EF8 => {
    //   block [0x82902EF8..0x82902F14)
	// 82902EF8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82902EFC: 419A003C  beq cr6, 0x82902f38
	if ctx.cr[6].eq {
	pc = 0x82902F38; continue 'dispatch;
	}
	// 82902F00: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82902F04: 2F0B0090  cmpwi cr6, r11, 0x90
	ctx.cr[6].compare_i32(ctx.r[11].s32, 144, &mut ctx.xer);
	// 82902F08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82902F0C: 41990008  bgt cr6, 0x82902f14
	if ctx.cr[6].gt {
	pc = 0x82902F14; continue 'dispatch;
	}
	// 82902F10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82902F14; continue 'dispatch;
            }
            0x82902F14 => {
    //   block [0x82902F14..0x82902F38)
	// 82902F14: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82902F18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82902F1C: 409A001C  bne cr6, 0x82902f38
	if !ctx.cr[6].eq {
	pc = 0x82902F38; continue 'dispatch;
	}
	// 82902F20: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82902F24: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82902F28: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82902F2C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82902F30: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82902F34: 48000018  b 0x82902f4c
	pc = 0x82902F4C; continue 'dispatch;
            }
            0x82902F38 => {
    //   block [0x82902F38..0x82902F48)
	// 82902F38: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82902F3C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82902F40: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82902F44: 48000008  b 0x82902f4c
	pc = 0x82902F4C; continue 'dispatch;
            }
            0x82902F48 => {
    //   block [0x82902F48..0x82902F4C)
	// 82902F48: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82902F4C; continue 'dispatch;
            }
            0x82902F4C => {
    //   block [0x82902F4C..0x82902F74)
	// 82902F4C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82902F50: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82902F54: 419A0020  beq cr6, 0x82902f74
	if ctx.cr[6].eq {
	pc = 0x82902F74; continue 'dispatch;
	}
	// 82902F58: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82902F5C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82902F60: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82902F64: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82902F68: 4E800421  bctrl
	ctx.lr = 0x82902F6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82902F6C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82902F70: 483A64EC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82902F74 => {
    //   block [0x82902F74..0x82902F80)
	// 82902F74: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82902F78: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82902F7C: 483A64E0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82902F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82902F80 size=372
    let mut pc: u32 = 0x82902F80;
    'dispatch: loop {
        match pc {
            0x82902F80 => {
    //   block [0x82902F80..0x82902FA8)
	// 82902F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82902F84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82902F88: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82902F8C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82902F90: 419A0018  beq cr6, 0x82902fa8
	if ctx.cr[6].eq {
	pc = 0x82902FA8; continue 'dispatch;
	}
	// 82902F94: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 82902F98: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82902F9C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82902FA0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82902FA4: 409A0008  bne cr6, 0x82902fac
	if !ctx.cr[6].eq {
	pc = 0x82902FAC; continue 'dispatch;
	}
	pc = 0x82902FA8; continue 'dispatch;
            }
            0x82902FA8 => {
    //   block [0x82902FA8..0x82902FAC)
	// 82902FA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82902FAC; continue 'dispatch;
            }
            0x82902FAC => {
    //   block [0x82902FAC..0x82902FF4)
	// 82902FAC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82902FB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82902FB4: 419A012C  beq cr6, 0x829030e0
	if ctx.cr[6].eq {
	pc = 0x829030E0; continue 'dispatch;
	}
	// 82902FB8: A1440034  lhz r10, 0x34(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) } as u64;
	// 82902FBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82902FC0: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82902FC4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82902FC8: 419A00E8  beq cr6, 0x829030b0
	if ctx.cr[6].eq {
	pc = 0x829030B0; continue 'dispatch;
	}
	// 82902FCC: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 82902FD0: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 82902FD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82902FD8: 419A001C  beq cr6, 0x82902ff4
	if ctx.cr[6].eq {
	pc = 0x82902FF4; continue 'dispatch;
	}
	// 82902FDC: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 82902FE0: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 82902FE4: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82902FE8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82902FEC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82902FF0: 480000C4  b 0x829030b4
	pc = 0x829030B4; continue 'dispatch;
            }
            0x82902FF4 => {
    //   block [0x82902FF4..0x82903010)
	// 82902FF4: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 82902FF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82902FFC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82903000: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82903004: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82903008: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290300C: 40810054  ble 0x82903060
	if !ctx.cr[0].gt {
	pc = 0x82903060; continue 'dispatch;
	}
	pc = 0x82903010; continue 'dispatch;
            }
            0x82903010 => {
    //   block [0x82903010..0x82903030)
	// 82903010: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82903014: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82903018: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8290301C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903020: 2F070090  cmpwi cr6, r7, 0x90
	ctx.cr[6].compare_i32(ctx.r[7].s32, 144, &mut ctx.xer);
	// 82903024: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82903028: 41980008  blt cr6, 0x82903030
	if ctx.cr[6].lt {
	pc = 0x82903030; continue 'dispatch;
	}
	// 8290302C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x82903030; continue 'dispatch;
            }
            0x82903030 => {
    //   block [0x82903030..0x8290304C)
	// 82903030: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82903034: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82903038: 419A0014  beq cr6, 0x8290304c
	if ctx.cr[6].eq {
	pc = 0x8290304C; continue 'dispatch;
	}
	// 8290303C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82903040: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82903044: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82903048: 4800000C  b 0x82903054
	pc = 0x82903054; continue 'dispatch;
            }
            0x8290304C => {
    //   block [0x8290304C..0x82903054)
	// 8290304C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82903050: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82903054; continue 'dispatch;
            }
            0x82903054 => {
    //   block [0x82903054..0x82903060)
	// 82903054: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82903058: 4199FFB8  bgt cr6, 0x82903010
	if ctx.cr[6].gt {
	pc = 0x82903010; continue 'dispatch;
	}
	// 8290305C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82903060; continue 'dispatch;
            }
            0x82903060 => {
    //   block [0x82903060..0x8290307C)
	// 82903060: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82903064: 419A003C  beq cr6, 0x829030a0
	if ctx.cr[6].eq {
	pc = 0x829030A0; continue 'dispatch;
	}
	// 82903068: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290306C: 2F0B0090  cmpwi cr6, r11, 0x90
	ctx.cr[6].compare_i32(ctx.r[11].s32, 144, &mut ctx.xer);
	// 82903070: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82903074: 41990008  bgt cr6, 0x8290307c
	if ctx.cr[6].gt {
	pc = 0x8290307C; continue 'dispatch;
	}
	// 82903078: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8290307C; continue 'dispatch;
            }
            0x8290307C => {
    //   block [0x8290307C..0x829030A0)
	// 8290307C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82903080: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82903084: 409A001C  bne cr6, 0x829030a0
	if !ctx.cr[6].eq {
	pc = 0x829030A0; continue 'dispatch;
	}
	// 82903088: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8290308C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82903090: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82903094: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82903098: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290309C: 48000018  b 0x829030b4
	pc = 0x829030B4; continue 'dispatch;
            }
            0x829030A0 => {
    //   block [0x829030A0..0x829030B0)
	// 829030A0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829030A4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829030A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829030AC: 48000008  b 0x829030b4
	pc = 0x829030B4; continue 'dispatch;
            }
            0x829030B0 => {
    //   block [0x829030B0..0x829030B4)
	// 829030B0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x829030B4; continue 'dispatch;
            }
            0x829030B4 => {
    //   block [0x829030B4..0x829030E0)
	// 829030B4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 829030B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829030BC: 419A0024  beq cr6, 0x829030e0
	if ctx.cr[6].eq {
	pc = 0x829030E0; continue 'dispatch;
	}
	// 829030C0: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829030C4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 829030C8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829030CC: 4E800421  bctrl
	ctx.lr = 0x829030D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829030D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829030D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829030D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829030DC: 4E800020  blr
	return;
            }
            0x829030E0 => {
    //   block [0x829030E0..0x829030F4)
	// 829030E0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829030E4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829030E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829030EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829030F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829030F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829030F8 size=372
    let mut pc: u32 = 0x829030F8;
    'dispatch: loop {
        match pc {
            0x829030F8 => {
    //   block [0x829030F8..0x82903120)
	// 829030F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829030FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82903100: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82903104: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82903108: 419A0018  beq cr6, 0x82903120
	if ctx.cr[6].eq {
	pc = 0x82903120; continue 'dispatch;
	}
	// 8290310C: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 82903110: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82903114: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82903118: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290311C: 409A0008  bne cr6, 0x82903124
	if !ctx.cr[6].eq {
	pc = 0x82903124; continue 'dispatch;
	}
	pc = 0x82903120; continue 'dispatch;
            }
            0x82903120 => {
    //   block [0x82903120..0x82903124)
	// 82903120: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82903124; continue 'dispatch;
            }
            0x82903124 => {
    //   block [0x82903124..0x8290316C)
	// 82903124: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82903128: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290312C: 419A012C  beq cr6, 0x82903258
	if ctx.cr[6].eq {
	pc = 0x82903258; continue 'dispatch;
	}
	// 82903130: A1440034  lhz r10, 0x34(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) } as u64;
	// 82903134: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82903138: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 8290313C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82903140: 419A00E8  beq cr6, 0x82903228
	if ctx.cr[6].eq {
	pc = 0x82903228; continue 'dispatch;
	}
	// 82903144: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 82903148: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 8290314C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82903150: 419A001C  beq cr6, 0x8290316c
	if ctx.cr[6].eq {
	pc = 0x8290316C; continue 'dispatch;
	}
	// 82903154: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 82903158: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 8290315C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82903160: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903164: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82903168: 480000C4  b 0x8290322c
	pc = 0x8290322C; continue 'dispatch;
            }
            0x8290316C => {
    //   block [0x8290316C..0x82903188)
	// 8290316C: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 82903170: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82903174: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82903178: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8290317C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82903180: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82903184: 40810054  ble 0x829031d8
	if !ctx.cr[0].gt {
	pc = 0x829031D8; continue 'dispatch;
	}
	pc = 0x82903188; continue 'dispatch;
            }
            0x82903188 => {
    //   block [0x82903188..0x829031A8)
	// 82903188: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8290318C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82903190: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82903194: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903198: 2F070090  cmpwi cr6, r7, 0x90
	ctx.cr[6].compare_i32(ctx.r[7].s32, 144, &mut ctx.xer);
	// 8290319C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829031A0: 41980008  blt cr6, 0x829031a8
	if ctx.cr[6].lt {
	pc = 0x829031A8; continue 'dispatch;
	}
	// 829031A4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x829031A8; continue 'dispatch;
            }
            0x829031A8 => {
    //   block [0x829031A8..0x829031C4)
	// 829031A8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829031AC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829031B0: 419A0014  beq cr6, 0x829031c4
	if ctx.cr[6].eq {
	pc = 0x829031C4; continue 'dispatch;
	}
	// 829031B4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829031B8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829031BC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829031C0: 4800000C  b 0x829031cc
	pc = 0x829031CC; continue 'dispatch;
            }
            0x829031C4 => {
    //   block [0x829031C4..0x829031CC)
	// 829031C4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829031C8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829031CC; continue 'dispatch;
            }
            0x829031CC => {
    //   block [0x829031CC..0x829031D8)
	// 829031CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829031D0: 4199FFB8  bgt cr6, 0x82903188
	if ctx.cr[6].gt {
	pc = 0x82903188; continue 'dispatch;
	}
	// 829031D4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x829031D8; continue 'dispatch;
            }
            0x829031D8 => {
    //   block [0x829031D8..0x829031F4)
	// 829031D8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829031DC: 419A003C  beq cr6, 0x82903218
	if ctx.cr[6].eq {
	pc = 0x82903218; continue 'dispatch;
	}
	// 829031E0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829031E4: 2F0B0090  cmpwi cr6, r11, 0x90
	ctx.cr[6].compare_i32(ctx.r[11].s32, 144, &mut ctx.xer);
	// 829031E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829031EC: 41990008  bgt cr6, 0x829031f4
	if ctx.cr[6].gt {
	pc = 0x829031F4; continue 'dispatch;
	}
	// 829031F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829031F4; continue 'dispatch;
            }
            0x829031F4 => {
    //   block [0x829031F4..0x82903218)
	// 829031F4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829031F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829031FC: 409A001C  bne cr6, 0x82903218
	if !ctx.cr[6].eq {
	pc = 0x82903218; continue 'dispatch;
	}
	// 82903200: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82903204: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82903208: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8290320C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82903210: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903214: 48000018  b 0x8290322c
	pc = 0x8290322C; continue 'dispatch;
            }
            0x82903218 => {
    //   block [0x82903218..0x82903228)
	// 82903218: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8290321C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82903220: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903224: 48000008  b 0x8290322c
	pc = 0x8290322C; continue 'dispatch;
            }
            0x82903228 => {
    //   block [0x82903228..0x8290322C)
	// 82903228: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x8290322C; continue 'dispatch;
            }
            0x8290322C => {
    //   block [0x8290322C..0x82903258)
	// 8290322C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82903230: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82903234: 419A0024  beq cr6, 0x82903258
	if ctx.cr[6].eq {
	pc = 0x82903258; continue 'dispatch;
	}
	// 82903238: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290323C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82903240: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82903244: 4E800421  bctrl
	ctx.lr = 0x82903248;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82903248: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8290324C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82903250: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82903254: 4E800020  blr
	return;
            }
            0x82903258 => {
    //   block [0x82903258..0x8290326C)
	// 82903258: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8290325C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82903260: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82903264: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82903268: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82903270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82903270 size=352
    let mut pc: u32 = 0x82903270;
    'dispatch: loop {
        match pc {
            0x82903270 => {
    //   block [0x82903270..0x82903298)
	// 82903270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82903274: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82903278: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290327C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82903280: 419A0018  beq cr6, 0x82903298
	if ctx.cr[6].eq {
	pc = 0x82903298; continue 'dispatch;
	}
	// 82903284: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 82903288: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8290328C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82903290: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82903294: 409A0008  bne cr6, 0x8290329c
	if !ctx.cr[6].eq {
	pc = 0x8290329C; continue 'dispatch;
	}
	pc = 0x82903298; continue 'dispatch;
            }
            0x82903298 => {
    //   block [0x82903298..0x8290329C)
	// 82903298: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8290329C; continue 'dispatch;
            }
            0x8290329C => {
    //   block [0x8290329C..0x829032E4)
	// 8290329C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829032A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829032A4: 419A011C  beq cr6, 0x829033c0
	if ctx.cr[6].eq {
	pc = 0x829033C0; continue 'dispatch;
	}
	// 829032A8: A1440034  lhz r10, 0x34(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) } as u64;
	// 829032AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829032B0: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 829032B4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829032B8: 419A00E8  beq cr6, 0x829033a0
	if ctx.cr[6].eq {
	pc = 0x829033A0; continue 'dispatch;
	}
	// 829032BC: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 829032C0: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 829032C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829032C8: 419A001C  beq cr6, 0x829032e4
	if ctx.cr[6].eq {
	pc = 0x829032E4; continue 'dispatch;
	}
	// 829032CC: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 829032D0: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 829032D4: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829032D8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829032DC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829032E0: 480000C4  b 0x829033a4
	pc = 0x829033A4; continue 'dispatch;
            }
            0x829032E4 => {
    //   block [0x829032E4..0x82903300)
	// 829032E4: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 829032E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829032EC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829032F0: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829032F4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829032F8: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829032FC: 40810054  ble 0x82903350
	if !ctx.cr[0].gt {
	pc = 0x82903350; continue 'dispatch;
	}
	pc = 0x82903300; continue 'dispatch;
            }
            0x82903300 => {
    //   block [0x82903300..0x82903320)
	// 82903300: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82903304: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82903308: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8290330C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903310: 2F070090  cmpwi cr6, r7, 0x90
	ctx.cr[6].compare_i32(ctx.r[7].s32, 144, &mut ctx.xer);
	// 82903314: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82903318: 41980008  blt cr6, 0x82903320
	if ctx.cr[6].lt {
	pc = 0x82903320; continue 'dispatch;
	}
	// 8290331C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x82903320; continue 'dispatch;
            }
            0x82903320 => {
    //   block [0x82903320..0x8290333C)
	// 82903320: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82903324: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82903328: 419A0014  beq cr6, 0x8290333c
	if ctx.cr[6].eq {
	pc = 0x8290333C; continue 'dispatch;
	}
	// 8290332C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82903330: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82903334: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82903338: 4800000C  b 0x82903344
	pc = 0x82903344; continue 'dispatch;
            }
            0x8290333C => {
    //   block [0x8290333C..0x82903344)
	// 8290333C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82903340: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82903344; continue 'dispatch;
            }
            0x82903344 => {
    //   block [0x82903344..0x82903350)
	// 82903344: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82903348: 4199FFB8  bgt cr6, 0x82903300
	if ctx.cr[6].gt {
	pc = 0x82903300; continue 'dispatch;
	}
	// 8290334C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82903350; continue 'dispatch;
            }
            0x82903350 => {
    //   block [0x82903350..0x8290336C)
	// 82903350: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82903354: 419A003C  beq cr6, 0x82903390
	if ctx.cr[6].eq {
	pc = 0x82903390; continue 'dispatch;
	}
	// 82903358: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290335C: 2F0B0090  cmpwi cr6, r11, 0x90
	ctx.cr[6].compare_i32(ctx.r[11].s32, 144, &mut ctx.xer);
	// 82903360: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82903364: 41990008  bgt cr6, 0x8290336c
	if ctx.cr[6].gt {
	pc = 0x8290336C; continue 'dispatch;
	}
	// 82903368: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8290336C; continue 'dispatch;
            }
            0x8290336C => {
    //   block [0x8290336C..0x82903390)
	// 8290336C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82903370: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82903374: 409A001C  bne cr6, 0x82903390
	if !ctx.cr[6].eq {
	pc = 0x82903390; continue 'dispatch;
	}
	// 82903378: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8290337C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82903380: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82903384: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82903388: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290338C: 48000018  b 0x829033a4
	pc = 0x829033A4; continue 'dispatch;
            }
            0x82903390 => {
    //   block [0x82903390..0x829033A0)
	// 82903390: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82903394: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82903398: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290339C: 48000008  b 0x829033a4
	pc = 0x829033A4; continue 'dispatch;
            }
            0x829033A0 => {
    //   block [0x829033A0..0x829033A4)
	// 829033A0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x829033A4; continue 'dispatch;
            }
            0x829033A4 => {
    //   block [0x829033A4..0x829033C0)
	// 829033A4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 829033A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829033AC: 419A0014  beq cr6, 0x829033c0
	if ctx.cr[6].eq {
	pc = 0x829033C0; continue 'dispatch;
	}
	// 829033B0: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829033B4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 829033B8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829033BC: 4E800421  bctrl
	ctx.lr = 0x829033C0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x829033C0 => {
    //   block [0x829033C0..0x829033D0)
	// 829033C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829033C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829033C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829033CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829033D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829033D0 size=384
    let mut pc: u32 = 0x829033D0;
    'dispatch: loop {
        match pc {
            0x829033D0 => {
    //   block [0x829033D0..0x82903404)
	// 829033D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829033D4: 483A6039  bl 0x82ca940c
	ctx.lr = 0x829033D8;
	sub_82CA93D0(ctx, base);
	// 829033D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829033DC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829033E0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829033E4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829033E8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 829033EC: 419A0018  beq cr6, 0x82903404
	if ctx.cr[6].eq {
	pc = 0x82903404; continue 'dispatch;
	}
	// 829033F0: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 829033F4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829033F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829033FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82903400: 409A0008  bne cr6, 0x82903408
	if !ctx.cr[6].eq {
	pc = 0x82903408; continue 'dispatch;
	}
	pc = 0x82903404; continue 'dispatch;
            }
            0x82903404 => {
    //   block [0x82903404..0x82903408)
	// 82903404: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82903408; continue 'dispatch;
            }
            0x82903408 => {
    //   block [0x82903408..0x82903450)
	// 82903408: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290340C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82903410: 419A0130  beq cr6, 0x82903540
	if ctx.cr[6].eq {
	pc = 0x82903540; continue 'dispatch;
	}
	// 82903414: A1640034  lhz r11, 0x34(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) } as u64;
	// 82903418: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 8290341C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82903420: 419A00F0  beq cr6, 0x82903510
	if ctx.cr[6].eq {
	pc = 0x82903510; continue 'dispatch;
	}
	// 82903424: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 82903428: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 8290342C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82903430: 419A0020  beq cr6, 0x82903450
	if ctx.cr[6].eq {
	pc = 0x82903450; continue 'dispatch;
	}
	// 82903434: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 82903438: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 8290343C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82903440: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903444: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82903448: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290344C: 480000C8  b 0x82903514
	pc = 0x82903514; continue 'dispatch;
            }
            0x82903450 => {
    //   block [0x82903450..0x82903468)
	// 82903450: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 82903454: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82903458: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8290345C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82903460: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82903464: 40810054  ble 0x829034b8
	if !ctx.cr[0].gt {
	pc = 0x829034B8; continue 'dispatch;
	}
	pc = 0x82903468; continue 'dispatch;
            }
            0x82903468 => {
    //   block [0x82903468..0x82903488)
	// 82903468: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8290346C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82903470: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82903474: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903478: 2F070090  cmpwi cr6, r7, 0x90
	ctx.cr[6].compare_i32(ctx.r[7].s32, 144, &mut ctx.xer);
	// 8290347C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82903480: 41980008  blt cr6, 0x82903488
	if ctx.cr[6].lt {
	pc = 0x82903488; continue 'dispatch;
	}
	// 82903484: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x82903488; continue 'dispatch;
            }
            0x82903488 => {
    //   block [0x82903488..0x829034A4)
	// 82903488: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8290348C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82903490: 419A0014  beq cr6, 0x829034a4
	if ctx.cr[6].eq {
	pc = 0x829034A4; continue 'dispatch;
	}
	// 82903494: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82903498: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8290349C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829034A0: 4800000C  b 0x829034ac
	pc = 0x829034AC; continue 'dispatch;
            }
            0x829034A4 => {
    //   block [0x829034A4..0x829034AC)
	// 829034A4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829034A8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829034AC; continue 'dispatch;
            }
            0x829034AC => {
    //   block [0x829034AC..0x829034B8)
	// 829034AC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829034B0: 4199FFB8  bgt cr6, 0x82903468
	if ctx.cr[6].gt {
	pc = 0x82903468; continue 'dispatch;
	}
	// 829034B4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x829034B8; continue 'dispatch;
            }
            0x829034B8 => {
    //   block [0x829034B8..0x829034D4)
	// 829034B8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829034BC: 419A0040  beq cr6, 0x829034fc
	if ctx.cr[6].eq {
	pc = 0x829034FC; continue 'dispatch;
	}
	// 829034C0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829034C4: 2F0B0090  cmpwi cr6, r11, 0x90
	ctx.cr[6].compare_i32(ctx.r[11].s32, 144, &mut ctx.xer);
	// 829034C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829034CC: 41990008  bgt cr6, 0x829034d4
	if ctx.cr[6].gt {
	pc = 0x829034D4; continue 'dispatch;
	}
	// 829034D0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x829034D4; continue 'dispatch;
            }
            0x829034D4 => {
    //   block [0x829034D4..0x829034FC)
	// 829034D4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829034D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829034DC: 409A0020  bne cr6, 0x829034fc
	if !ctx.cr[6].eq {
	pc = 0x829034FC; continue 'dispatch;
	}
	// 829034E0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829034E4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829034E8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829034EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829034F0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829034F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829034F8: 4800001C  b 0x82903514
	pc = 0x82903514; continue 'dispatch;
            }
            0x829034FC => {
    //   block [0x829034FC..0x82903510)
	// 829034FC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82903500: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903504: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82903508: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290350C: 48000008  b 0x82903514
	pc = 0x82903514; continue 'dispatch;
            }
            0x82903510 => {
    //   block [0x82903510..0x82903514)
	// 82903510: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82903514; continue 'dispatch;
            }
            0x82903514 => {
    //   block [0x82903514..0x82903540)
	// 82903514: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82903518: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290351C: 419A0024  beq cr6, 0x82903540
	if ctx.cr[6].eq {
	pc = 0x82903540; continue 'dispatch;
	}
	// 82903520: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82903524: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82903528: 4B8ECD19  bl 0x821f0240
	ctx.lr = 0x8290352C;
	sub_821F0240(ctx, base);
	// 8290352C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82903530: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903534: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82903538: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8290353C: 4E800421  bctrl
	ctx.lr = 0x82903540;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82903540 => {
    //   block [0x82903540..0x82903550)
	// 82903540: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82903544: 4B911895  bl 0x82214dd8
	ctx.lr = 0x82903548;
	sub_82214DD8(ctx, base);
	// 82903548: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8290354C: 483A5F10  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82903550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82903550 size=440
    let mut pc: u32 = 0x82903550;
    'dispatch: loop {
        match pc {
            0x82903550 => {
    //   block [0x82903550..0x82903584)
	// 82903550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82903554: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82903558: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8290355C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82903560: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82903564: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82903568: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 8290356C: 419A0018  beq cr6, 0x82903584
	if ctx.cr[6].eq {
	pc = 0x82903584; continue 'dispatch;
	}
	// 82903570: 89650090  lbz r11, 0x90(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(144 as u32) ) } as u64;
	// 82903574: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82903578: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290357C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82903580: 409A0008  bne cr6, 0x82903588
	if !ctx.cr[6].eq {
	pc = 0x82903588; continue 'dispatch;
	}
	pc = 0x82903584; continue 'dispatch;
            }
            0x82903584 => {
    //   block [0x82903584..0x82903588)
	// 82903584: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x82903588; continue 'dispatch;
            }
            0x82903588 => {
    //   block [0x82903588..0x829035D0)
	// 82903588: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290358C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82903590: 419A0138  beq cr6, 0x829036c8
	if ctx.cr[6].eq {
	pc = 0x829036C8; continue 'dispatch;
	}
	// 82903594: A1450034  lhz r10, 0x34(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(52 as u32) ) } as u64;
	// 82903598: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8290359C: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 829035A0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829035A4: 419A00E8  beq cr6, 0x8290368c
	if ctx.cr[6].eq {
	pc = 0x8290368C; continue 'dispatch;
	}
	// 829035A8: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 829035AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829035B0: 419A0020  beq cr6, 0x829035d0
	if ctx.cr[6].eq {
	pc = 0x829035D0; continue 'dispatch;
	}
	// 829035B4: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 829035B8: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 829035BC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 829035C0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829035C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829035C8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829035CC: 480000C4  b 0x82903690
	pc = 0x82903690; continue 'dispatch;
            }
            0x829035D0 => {
    //   block [0x829035D0..0x829035EC)
	// 829035D0: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 829035D4: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 829035D8: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 829035DC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829035E0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829035E4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829035E8: 40810054  ble 0x8290363c
	if !ctx.cr[0].gt {
	pc = 0x8290363C; continue 'dispatch;
	}
	pc = 0x829035EC; continue 'dispatch;
            }
            0x829035EC => {
    //   block [0x829035EC..0x8290360C)
	// 829035EC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829035F0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829035F4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829035F8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829035FC: 2F070090  cmpwi cr6, r7, 0x90
	ctx.cr[6].compare_i32(ctx.r[7].s32, 144, &mut ctx.xer);
	// 82903600: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82903604: 41980008  blt cr6, 0x8290360c
	if ctx.cr[6].lt {
	pc = 0x8290360C; continue 'dispatch;
	}
	// 82903608: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x8290360C; continue 'dispatch;
            }
            0x8290360C => {
    //   block [0x8290360C..0x82903628)
	// 8290360C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82903610: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82903614: 419A0014  beq cr6, 0x82903628
	if ctx.cr[6].eq {
	pc = 0x82903628; continue 'dispatch;
	}
	// 82903618: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8290361C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82903620: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82903624: 4800000C  b 0x82903630
	pc = 0x82903630; continue 'dispatch;
            }
            0x82903628 => {
    //   block [0x82903628..0x82903630)
	// 82903628: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8290362C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82903630; continue 'dispatch;
            }
            0x82903630 => {
    //   block [0x82903630..0x8290363C)
	// 82903630: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82903634: 4199FFB8  bgt cr6, 0x829035ec
	if ctx.cr[6].gt {
	pc = 0x829035EC; continue 'dispatch;
	}
	// 82903638: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8290363C; continue 'dispatch;
            }
            0x8290363C => {
    //   block [0x8290363C..0x82903658)
	// 8290363C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82903640: 419A003C  beq cr6, 0x8290367c
	if ctx.cr[6].eq {
	pc = 0x8290367C; continue 'dispatch;
	}
	// 82903644: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903648: 2F0B0090  cmpwi cr6, r11, 0x90
	ctx.cr[6].compare_i32(ctx.r[11].s32, 144, &mut ctx.xer);
	// 8290364C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82903650: 41990008  bgt cr6, 0x82903658
	if ctx.cr[6].gt {
	pc = 0x82903658; continue 'dispatch;
	}
	// 82903654: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x82903658; continue 'dispatch;
            }
            0x82903658 => {
    //   block [0x82903658..0x8290367C)
	// 82903658: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290365C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82903660: 409A001C  bne cr6, 0x8290367c
	if !ctx.cr[6].eq {
	pc = 0x8290367C; continue 'dispatch;
	}
	// 82903664: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82903668: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290366C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82903670: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82903674: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903678: 48000018  b 0x82903690
	pc = 0x82903690; continue 'dispatch;
            }
            0x8290367C => {
    //   block [0x8290367C..0x8290368C)
	// 8290367C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82903680: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82903684: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903688: 48000008  b 0x82903690
	pc = 0x82903690; continue 'dispatch;
            }
            0x8290368C => {
    //   block [0x8290368C..0x82903690)
	// 8290368C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	pc = 0x82903690; continue 'dispatch;
            }
            0x82903690 => {
    //   block [0x82903690..0x829036C8)
	// 82903690: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82903694: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82903698: 419A0030  beq cr6, 0x829036c8
	if ctx.cr[6].eq {
	pc = 0x829036C8; continue 'dispatch;
	}
	// 8290369C: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 829036A0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 829036A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829036A8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829036AC: 4E800421  bctrl
	ctx.lr = 0x829036B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829036B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829036B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829036B8: 4B8ECB89  bl 0x821f0240
	ctx.lr = 0x829036BC;
	sub_821F0240(ctx, base);
	// 829036BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829036C0: 4B911719  bl 0x82214dd8
	ctx.lr = 0x829036C4;
	sub_82214DD8(ctx, base);
	// 829036C4: 4800002C  b 0x829036f0
	pc = 0x829036F0; continue 'dispatch;
            }
            0x829036C8 => {
    //   block [0x829036C8..0x829036D4)
	// 829036C8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829036CC: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 829036D0: 390B7088  addi r8, r11, 0x7088
	ctx.r[8].s64 = ctx.r[11].s64 + 28808;
	pc = 0x829036D4; continue 'dispatch;
            }
            0x829036D4 => {
    //   block [0x829036D4..0x829036F0)
	// 829036D4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829036D8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829036DC: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829036E0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829036E4: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829036E8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829036EC: 4082FFE8  bne 0x829036d4
	if !ctx.cr[0].eq {
	pc = 0x829036D4; continue 'dispatch;
	}
	pc = 0x829036F0; continue 'dispatch;
            }
            0x829036F0 => {
    //   block [0x829036F0..0x82903708)
	// 829036F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829036F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829036F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829036FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82903700: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82903704: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82903708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82903708 size=380
    let mut pc: u32 = 0x82903708;
    'dispatch: loop {
        match pc {
            0x82903708 => {
    //   block [0x82903708..0x82903730)
	// 82903708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290370C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82903710: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82903714: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82903718: 419A0018  beq cr6, 0x82903730
	if ctx.cr[6].eq {
	pc = 0x82903730; continue 'dispatch;
	}
	// 8290371C: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 82903720: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82903724: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82903728: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290372C: 409A0008  bne cr6, 0x82903734
	if !ctx.cr[6].eq {
	pc = 0x82903734; continue 'dispatch;
	}
	pc = 0x82903730; continue 'dispatch;
            }
            0x82903730 => {
    //   block [0x82903730..0x82903734)
	// 82903730: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82903734; continue 'dispatch;
            }
            0x82903734 => {
    //   block [0x82903734..0x8290377C)
	// 82903734: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82903738: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290373C: 419A0130  beq cr6, 0x8290386c
	if ctx.cr[6].eq {
	pc = 0x8290386C; continue 'dispatch;
	}
	// 82903740: A1440034  lhz r10, 0x34(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) } as u64;
	// 82903744: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82903748: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 8290374C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82903750: 419A00EC  beq cr6, 0x8290383c
	if ctx.cr[6].eq {
	pc = 0x8290383C; continue 'dispatch;
	}
	// 82903754: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 82903758: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290375C: 419A0020  beq cr6, 0x8290377c
	if ctx.cr[6].eq {
	pc = 0x8290377C; continue 'dispatch;
	}
	// 82903760: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 82903764: 81640048  lwz r11, 0x48(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 82903768: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8290376C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82903770: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82903774: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903778: 480000C8  b 0x82903840
	pc = 0x82903840; continue 'dispatch;
            }
            0x8290377C => {
    //   block [0x8290377C..0x8290379C)
	// 8290377C: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 82903780: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82903784: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 82903788: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8290378C: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82903790: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82903794: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82903798: 40810054  ble 0x829037ec
	if !ctx.cr[0].gt {
	pc = 0x829037EC; continue 'dispatch;
	}
	pc = 0x8290379C; continue 'dispatch;
            }
            0x8290379C => {
    //   block [0x8290379C..0x829037BC)
	// 8290379C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829037A0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829037A4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829037A8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829037AC: 2F070090  cmpwi cr6, r7, 0x90
	ctx.cr[6].compare_i32(ctx.r[7].s32, 144, &mut ctx.xer);
	// 829037B0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829037B4: 41980008  blt cr6, 0x829037bc
	if ctx.cr[6].lt {
	pc = 0x829037BC; continue 'dispatch;
	}
	// 829037B8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x829037BC; continue 'dispatch;
            }
            0x829037BC => {
    //   block [0x829037BC..0x829037D8)
	// 829037BC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829037C0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829037C4: 419A0014  beq cr6, 0x829037d8
	if ctx.cr[6].eq {
	pc = 0x829037D8; continue 'dispatch;
	}
	// 829037C8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829037CC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829037D0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829037D4: 4800000C  b 0x829037e0
	pc = 0x829037E0; continue 'dispatch;
            }
            0x829037D8 => {
    //   block [0x829037D8..0x829037E0)
	// 829037D8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829037DC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829037E0; continue 'dispatch;
            }
            0x829037E0 => {
    //   block [0x829037E0..0x829037EC)
	// 829037E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829037E4: 4199FFB8  bgt cr6, 0x8290379c
	if ctx.cr[6].gt {
	pc = 0x8290379C; continue 'dispatch;
	}
	// 829037E8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x829037EC; continue 'dispatch;
            }
            0x829037EC => {
    //   block [0x829037EC..0x82903808)
	// 829037EC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829037F0: 419A003C  beq cr6, 0x8290382c
	if ctx.cr[6].eq {
	pc = 0x8290382C; continue 'dispatch;
	}
	// 829037F4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829037F8: 2F0B0090  cmpwi cr6, r11, 0x90
	ctx.cr[6].compare_i32(ctx.r[11].s32, 144, &mut ctx.xer);
	// 829037FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82903800: 41990008  bgt cr6, 0x82903808
	if ctx.cr[6].gt {
	pc = 0x82903808; continue 'dispatch;
	}
	// 82903804: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82903808; continue 'dispatch;
            }
            0x82903808 => {
    //   block [0x82903808..0x8290382C)
	// 82903808: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290380C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82903810: 409A001C  bne cr6, 0x8290382c
	if !ctx.cr[6].eq {
	pc = 0x8290382C; continue 'dispatch;
	}
	// 82903814: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82903818: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290381C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82903820: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82903824: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903828: 48000018  b 0x82903840
	pc = 0x82903840; continue 'dispatch;
            }
            0x8290382C => {
    //   block [0x8290382C..0x8290383C)
	// 8290382C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82903830: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82903834: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903838: 48000008  b 0x82903840
	pc = 0x82903840; continue 'dispatch;
            }
            0x8290383C => {
    //   block [0x8290383C..0x82903840)
	// 8290383C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82903840; continue 'dispatch;
            }
            0x82903840 => {
    //   block [0x82903840..0x8290386C)
	// 82903840: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82903844: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82903848: 419A0024  beq cr6, 0x8290386c
	if ctx.cr[6].eq {
	pc = 0x8290386C; continue 'dispatch;
	}
	// 8290384C: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903850: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82903854: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82903858: 4E800421  bctrl
	ctx.lr = 0x8290385C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290385C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82903860: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82903864: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82903868: 4E800020  blr
	return;
            }
            0x8290386C => {
    //   block [0x8290386C..0x82903884)
	// 8290386C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82903870: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82903874: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82903878: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8290387C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82903880: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82903888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82903888 size=160
    let mut pc: u32 = 0x82903888;
    'dispatch: loop {
        match pc {
            0x82903888 => {
    //   block [0x82903888..0x82903928)
	// 82903888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290388C: 483A5B79  bl 0x82ca9404
	ctx.lr = 0x82903890;
	sub_82CA93D0(ctx, base);
	// 82903890: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82903894: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 82903898: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290389C: 4B92485D  bl 0x822280f8
	ctx.lr = 0x829038A0;
	sub_822280F8(ctx, base);
	// 829038A0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829038A4: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 829038A8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 829038AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829038B0: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 829038B4: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 829038B8: 83CA0004  lwz r30, 4(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829038BC: 83AA0000  lwz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829038C0: 4B924839  bl 0x822280f8
	ctx.lr = 0x829038C4;
	sub_822280F8(ctx, base);
	// 829038C4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829038C8: 4B923C99  bl 0x82227560
	ctx.lr = 0x829038CC;
	sub_82227560(ctx, base);
	// 829038CC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829038D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829038D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829038D8: 4B924821  bl 0x822280f8
	ctx.lr = 0x829038DC;
	sub_822280F8(ctx, base);
	// 829038DC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829038E0: 4B923C81  bl 0x82227560
	ctx.lr = 0x829038E4;
	sub_82227560(ctx, base);
	// 829038E4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 829038E8: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 829038EC: 88810050  lbz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829038F0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829038F4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829038F8: 4B9FE789  bl 0x82302080
	ctx.lr = 0x829038FC;
	sub_82302080(ctx, base);
	// 829038FC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82903900: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82903904: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82903908: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8290390C: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 82903910: 4E800421  bctrl
	ctx.lr = 0x82903914;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82903914: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82903918: 4B8B4201  bl 0x821b7b18
	ctx.lr = 0x8290391C;
	sub_821B7B18(ctx, base);
	// 8290391C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82903920: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82903924: 483A5B30  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82903928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82903928 size=176
    let mut pc: u32 = 0x82903928;
    'dispatch: loop {
        match pc {
            0x82903928 => {
    //   block [0x82903928..0x829039D8)
	// 82903928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290392C: 483A5ADD  bl 0x82ca9408
	ctx.lr = 0x82903930;
	sub_82CA93D0(ctx, base);
	// 82903930: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829039D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829039D8 size=124
    let mut pc: u32 = 0x829039D8;
    'dispatch: loop {
        match pc {
            0x829039D8 => {
    //   block [0x829039D8..0x82903A54)
	// 829039D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829039DC: 483A5A2D  bl 0x82ca9408
	ctx.lr = 0x829039E0;
	sub_82CA93D0(ctx, base);
	// 829039E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829039E4: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 829039E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829039EC: 4B92470D  bl 0x822280f8
	ctx.lr = 0x829039F0;
	sub_822280F8(ctx, base);
	// 829039F0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829039F4: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 829039F8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 829039FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82903A00: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82903A04: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 82903A08: 83CA0004  lwz r30, 4(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903A0C: 83AA0000  lwz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903A10: 4B9246E9  bl 0x822280f8
	ctx.lr = 0x82903A14;
	sub_822280F8(ctx, base);
	// 82903A14: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903A18: 4B923B49  bl 0x82227560
	ctx.lr = 0x82903A1C;
	sub_82227560(ctx, base);
	// 82903A1C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82903A20: 88810050  lbz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82903A24: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 82903A28: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82903A2C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82903A30: 4B9FE5B9  bl 0x82301fe8
	ctx.lr = 0x82903A34;
	sub_82301FE8(ctx, base);
	// 82903A34: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82903A38: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82903A3C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82903A40: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 82903A44: 4E800421  bctrl
	ctx.lr = 0x82903A48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82903A48: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82903A4C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82903A50: 483A5A08  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82903A58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82903A58 size=60
    let mut pc: u32 = 0x82903A58;
    'dispatch: loop {
        match pc {
            0x82903A58 => {
    //   block [0x82903A58..0x82903A94)
	// 82903A58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82903A5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82903A60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82903A64: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82903A68: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82903A6C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82903A70: 388B95EC  addi r4, r11, -0x6a14
	ctx.r[4].s64 = ctx.r[11].s64 + -27156;
	// 82903A74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82903A78: 4B929459  bl 0x8222ced0
	ctx.lr = 0x82903A7C;
	sub_8222CED0(ctx, base);
	// 82903A7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82903A80: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82903A84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82903A88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82903A8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82903A90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82903A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82903A98 size=100
    let mut pc: u32 = 0x82903A98;
    'dispatch: loop {
        match pc {
            0x82903A98 => {
    //   block [0x82903A98..0x82903AE4)
	// 82903A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82903A9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82903AA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82903AA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82903AA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82903AAC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82903AB0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82903AB4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82903AB8: 419A002C  beq cr6, 0x82903ae4
	if ctx.cr[6].eq {
	pc = 0x82903AE4; continue 'dispatch;
	}
	// 82903ABC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82903AC0: 38BE000C  addi r5, r30, 0xc
	ctx.r[5].s64 = ctx.r[30].s64 + 12;
	// 82903AC4: 388B5188  addi r4, r11, 0x5188
	ctx.r[4].s64 = ctx.r[11].s64 + 20872;
	// 82903AC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82903ACC: 4BAA9875  bl 0x823ad340
	ctx.lr = 0x82903AD0;
	sub_823AD340(ctx, base);
	// 82903AD0: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 82903AD4: 38BE0010  addi r5, r30, 0x10
	ctx.r[5].s64 = ctx.r[30].s64 + 16;
	// 82903AD8: 388A5194  addi r4, r10, 0x5194
	ctx.r[4].s64 = ctx.r[10].s64 + 20884;
	// 82903ADC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82903AE0: 4BAA9911  bl 0x823ad3f0
	ctx.lr = 0x82903AE4;
	sub_823AD3F0(ctx, base);
	pc = 0x82903AE4; continue 'dispatch;
            }
            0x82903AE4 => {
    //   block [0x82903AE4..0x82903AFC)
	// 82903AE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82903AE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82903AEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82903AF0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82903AF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82903AF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82903B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82903B00 size=96
    let mut pc: u32 = 0x82903B00;
    'dispatch: loop {
        match pc {
            0x82903B00 => {
    //   block [0x82903B00..0x82903B60)
	// 82903B00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82903B04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82903B08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82903B0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82903B10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82903B14: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82903B18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82903B1C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82903B20: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82903B24: 388B5188  addi r4, r11, 0x5188
	ctx.r[4].s64 = ctx.r[11].s64 + 20872;
	// 82903B28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82903B2C: 4B9293A5  bl 0x8222ced0
	ctx.lr = 0x82903B30;
	sub_8222CED0(ctx, base);
	// 82903B30: 38BF000C  addi r5, r31, 0xc
	ctx.r[5].s64 = ctx.r[31].s64 + 12;
	// 82903B34: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82903B38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82903B3C: 4811930D  bl 0x82a1ce48
	ctx.lr = 0x82903B40;
	sub_82A1CE48(ctx, base);
	// 82903B40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82903B44: 4B911295  bl 0x82214dd8
	ctx.lr = 0x82903B48;
	sub_82214DD8(ctx, base);
	// 82903B48: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82903B4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82903B50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82903B54: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82903B58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82903B5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82903B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82903B60 size=244
    let mut pc: u32 = 0x82903B60;
    'dispatch: loop {
        match pc {
            0x82903B60 => {
    //   block [0x82903B60..0x82903C54)
	// 82903B60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82903B64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82903B68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82903B6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82903B70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82903B74: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82903B78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82903B7C: 3BCB51A0  addi r30, r11, 0x51a0
	ctx.r[30].s64 = ctx.r[11].s64 + 20896;
	// 82903B80: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82903B84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82903B88: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82903B8C: 4B929345  bl 0x8222ced0
	ctx.lr = 0x82903B90;
	sub_8222CED0(ctx, base);
	// 82903B90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82903B94: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82903B98: 480000D1  bl 0x82903c68
	ctx.lr = 0x82903B9C;
	sub_82903C68(ctx, base);
	// 82903B9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82903BA0: 4B911239  bl 0x82214dd8
	ctx.lr = 0x82903BA4;
	sub_82214DD8(ctx, base);
	// 82903BA4: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 82903BA8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82903BAC: 388A51AC  addi r4, r10, 0x51ac
	ctx.r[4].s64 = ctx.r[10].s64 + 20908;
	// 82903BB0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82903BB4: 4B92931D  bl 0x8222ced0
	ctx.lr = 0x82903BB8;
	sub_8222CED0(ctx, base);
	// 82903BB8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82903BBC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82903BC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82903BC4: 4B92930D  bl 0x8222ced0
	ctx.lr = 0x82903BC8;
	sub_8222CED0(ctx, base);
	// 82903BC8: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 82903BCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82903BD0: 38C93C58  addi r6, r9, 0x3c58
	ctx.r[6].s64 = ctx.r[9].s64 + 15448;
	// 82903BD4: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82903BD8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82903BDC: 480002D5  bl 0x82903eb0
	ctx.lr = 0x82903BE0;
	sub_82903EB0(ctx, base);
	// 82903BE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82903BE4: 4B9111F5  bl 0x82214dd8
	ctx.lr = 0x82903BE8;
	sub_82214DD8(ctx, base);
	// 82903BE8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82903BEC: 4B9111ED  bl 0x82214dd8
	ctx.lr = 0x82903BF0;
	sub_82214DD8(ctx, base);
	// 82903BF0: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 82903BF4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82903BF8: 388851B8  addi r4, r8, 0x51b8
	ctx.r[4].s64 = ctx.r[8].s64 + 20920;
	// 82903BFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82903C00: 4B9292D1  bl 0x8222ced0
	ctx.lr = 0x82903C04;
	sub_8222CED0(ctx, base);
	// 82903C04: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82903C08: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82903C0C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82903C10: 4B9292C1  bl 0x8222ced0
	ctx.lr = 0x82903C14;
	sub_8222CED0(ctx, base);
	// 82903C14: 3CE08290  lis r7, -0x7d70
	ctx.r[7].s64 = -2104492032;
	// 82903C18: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82903C1C: 38C73C60  addi r6, r7, 0x3c60
	ctx.r[6].s64 = ctx.r[7].s64 + 15456;
	// 82903C20: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82903C24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82903C28: 48000491  bl 0x829040b8
	ctx.lr = 0x82903C2C;
	sub_829040B8(ctx, base);
	// 82903C2C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82903C30: 4B9111A9  bl 0x82214dd8
	ctx.lr = 0x82903C34;
	sub_82214DD8(ctx, base);
	// 82903C34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82903C38: 4B9111A1  bl 0x82214dd8
	ctx.lr = 0x82903C3C;
	sub_82214DD8(ctx, base);
	// 82903C3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82903C40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82903C44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82903C48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82903C4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82903C50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82903C58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82903C58 size=8
    let mut pc: u32 = 0x82903C58;
    'dispatch: loop {
        match pc {
            0x82903C58 => {
    //   block [0x82903C58..0x82903C60)
	// 82903C58: 8863000C  lbz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82903C5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82903C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82903C60 size=8
    let mut pc: u32 = 0x82903C60;
    'dispatch: loop {
        match pc {
            0x82903C60 => {
    //   block [0x82903C60..0x82903C68)
	// 82903C60: 9883000C  stb r4, 0xc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[4].u8 ) };
	// 82903C64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82903C68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82903C68 size=584
    let mut pc: u32 = 0x82903C68;
    'dispatch: loop {
        match pc {
            0x82903C68 => {
    //   block [0x82903C68..0x82903C90)
	// 82903C68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82903C6C: 483A5795  bl 0x82ca9400
	ctx.lr = 0x82903C70;
	sub_82CA93D0(ctx, base);
	// 82903C70: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82903C74: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903C78: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82903C7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82903C80: 409A0010  bne cr6, 0x82903c90
	if !ctx.cr[6].eq {
	pc = 0x82903C90; continue 'dispatch;
	}
	// 82903C84: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82903C88: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 82903C8C: 48000008  b 0x82903c94
	pc = 0x82903C94; continue 'dispatch;
            }
            0x82903C90 => {
    //   block [0x82903C90..0x82903C94)
	// 82903C90: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82903C94; continue 'dispatch;
            }
            0x82903C94 => {
    //   block [0x82903C94..0x82903D0C)
	// 82903C94: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903C98: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82903C9C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903CA0: 4BACA921  bl 0x823ce5c0
	ctx.lr = 0x82903CA4;
	sub_823CE5C0(ctx, base);
	// 82903CA4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82903CA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82903CAC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82903CB0: 4BACA551  bl 0x823ce200
	ctx.lr = 0x82903CB4;
	sub_823CE200(ctx, base);
	// 82903CB4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82903CB8: 4B8B3E61  bl 0x821b7b18
	ctx.lr = 0x82903CBC;
	sub_821B7B18(ctx, base);
	// 82903CBC: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82903CC0: 4B91B599  bl 0x8221f258
	ctx.lr = 0x82903CC4;
	sub_8221F258(ctx, base);
	// 82903CC4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82903CC8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82903CCC: 419A0040  beq cr6, 0x82903d0c
	if ctx.cr[6].eq {
	pc = 0x82903D0C; continue 'dispatch;
	}
	// 82903CD0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82903CD4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82903CD8: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 82903CDC: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82903CE0: 4B91B579  bl 0x8221f258
	ctx.lr = 0x82903CE4;
	sub_8221F258(ctx, base);
	// 82903CE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82903CE8: 419A0028  beq cr6, 0x82903d10
	if ctx.cr[6].eq {
	pc = 0x82903D10; continue 'dispatch;
	}
	// 82903CEC: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 82903CF0: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82903CF4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82903CF8: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 82903CFC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82903D00: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82903D04: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82903D08: 4800000C  b 0x82903d14
	pc = 0x82903D14; continue 'dispatch;
            }
            0x82903D0C => {
    //   block [0x82903D0C..0x82903D10)
	// 82903D0C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82903D10; continue 'dispatch;
            }
            0x82903D10 => {
    //   block [0x82903D10..0x82903D14)
	// 82903D10: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x82903D14; continue 'dispatch;
            }
            0x82903D14 => {
    //   block [0x82903D14..0x82903E18)
	// 82903D14: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82903D18: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82903D1C: 419A00FC  beq cr6, 0x82903e18
	if ctx.cr[6].eq {
	pc = 0x82903E18; continue 'dispatch;
	}
	// 82903D20: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903D24: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 82903D28: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903D2C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82903D30: 4B9253D9  bl 0x82229108
	ctx.lr = 0x82903D34;
	sub_82229108(ctx, base);
	// 82903D34: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 82903D38: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82903D3C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82903D40: 3BCB4308  addi r30, r11, 0x4308
	ctx.r[30].s64 = ctx.r[11].s64 + 17160;
	// 82903D44: 4B923B3D  bl 0x82227880
	ctx.lr = 0x82903D48;
	sub_82227880(ctx, base);
	// 82903D48: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82903D4C: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 82903D50: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82903D54: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 82903D58: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82903D5C: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82903D60: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82903D64: 4B896D1D  bl 0x8219aa80
	ctx.lr = 0x82903D68;
	sub_8219AA80(ctx, base);
	// 82903D68: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82903D6C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82903D70: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 82903D74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82903D78: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82903D7C: 4BACA6A5  bl 0x823ce420
	ctx.lr = 0x82903D80;
	sub_823CE420(ctx, base);
	// 82903D80: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82903D84: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 82903D88: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82903D8C: 4812093D  bl 0x82a246c8
	ctx.lr = 0x82903D90;
	sub_82A246C8(ctx, base);
	// 82903D90: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82903D94: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 82903D98: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 82903D9C: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82903DA0: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903DA4: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903DA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82903DAC: 4B92535D  bl 0x82229108
	ctx.lr = 0x82903DB0;
	sub_82229108(ctx, base);
	// 82903DB0: 3D608232  lis r11, -0x7dce
	ctx.r[11].s64 = -2110652416;
	// 82903DB4: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82903DB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82903DBC: 3BEB6C48  addi r31, r11, 0x6c48
	ctx.r[31].s64 = ctx.r[11].s64 + 27720;
	// 82903DC0: 4B923AC1  bl 0x82227880
	ctx.lr = 0x82903DC4;
	sub_82227880(ctx, base);
	// 82903DC4: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82903DC8: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 82903DCC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82903DD0: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 82903DD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82903DD8: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82903DDC: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82903DE0: 4B896CA1  bl 0x8219aa80
	ctx.lr = 0x82903DE4;
	sub_8219AA80(ctx, base);
	// 82903DE4: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 82903DE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82903DEC: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 82903DF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82903DF4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82903DF8: 4BACA629  bl 0x823ce420
	ctx.lr = 0x82903DFC;
	sub_823CE420(ctx, base);
	// 82903DFC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82903E00: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 82903E04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82903E08: 481208C1  bl 0x82a246c8
	ctx.lr = 0x82903E0C;
	sub_82A246C8(ctx, base);
	// 82903E0C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82903E10: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 82903E14: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	pc = 0x82903E18; continue 'dispatch;
            }
            0x82903E18 => {
    //   block [0x82903E18..0x82903E28)
	// 82903E18: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82903E1C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82903E20: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 82903E24: 419A0020  beq cr6, 0x82903e44
	if ctx.cr[6].eq {
	pc = 0x82903E44; continue 'dispatch;
	}
	pc = 0x82903E28; continue 'dispatch;
            }
            0x82903E28 => {
    //   block [0x82903E28..0x82903E44)
	// 82903E28: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82903E2C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82903E30: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82903E34: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82903E38: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82903E3C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82903E40: 4082FFE8  bne 0x82903e28
	if !ctx.cr[0].eq {
	pc = 0x82903E28; continue 'dispatch;
	}
	pc = 0x82903E44; continue 'dispatch;
            }
            0x82903E44 => {
    //   block [0x82903E44..0x82903E64)
	// 82903E44: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903E48: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82903E4C: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 82903E50: 4B9F1AF9  bl 0x822f5948
	ctx.lr = 0x82903E54;
	sub_822F5948(ctx, base);
	// 82903E54: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82903E58: 4B8B3CC1  bl 0x821b7b18
	ctx.lr = 0x82903E5C;
	sub_821B7B18(ctx, base);
	// 82903E5C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82903E60: 419A0040  beq cr6, 0x82903ea0
	if ctx.cr[6].eq {
	pc = 0x82903EA0; continue 'dispatch;
	}
	pc = 0x82903E64; continue 'dispatch;
            }
            0x82903E64 => {
    //   block [0x82903E64..0x82903EA0)
	// 82903E64: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82903E68: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82903E6C: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82903E70: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82903E74: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82903E78: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82903E7C: 4082FFE8  bne 0x82903e64
	if !ctx.cr[0].eq {
	pc = 0x82903E64; continue 'dispatch;
	}
	// 82903E80: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82903E84: 409A001C  bne cr6, 0x82903ea0
	if !ctx.cr[6].eq {
	pc = 0x82903EA0; continue 'dispatch;
	}
	// 82903E88: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82903E8C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903E90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82903E94: 4E800421  bctrl
	ctx.lr = 0x82903E98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82903E98: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82903E9C: 4B917E9D  bl 0x8221bd38
	ctx.lr = 0x82903EA0;
	sub_8221BD38(ctx, base);
            }
            0x82903EA0 => {
    //   block [0x82903EA0..0x82903EB0)
	// 82903EA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82903EA4: 4B8B3C75  bl 0x821b7b18
	ctx.lr = 0x82903EA8;
	sub_821B7B18(ctx, base);
	// 82903EA8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82903EAC: 483A55A4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82903EB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82903EB0 size=516
    let mut pc: u32 = 0x82903EB0;
    'dispatch: loop {
        match pc {
            0x82903EB0 => {
    //   block [0x82903EB0..0x82903EEC)
	// 82903EB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82903EB4: 483A5549  bl 0x82ca93fc
	ctx.lr = 0x82903EB8;
	sub_82CA93D0(ctx, base);
	// 82903EB8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82903EBC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82903EC0: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 82903EC4: 3D408290  lis r10, -0x7d70
	ctx.r[10].s64 = -2104492032;
	// 82903EC8: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 82903ECC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82903ED0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903ED4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82903ED8: 3BAA3C58  addi r29, r10, 0x3c58
	ctx.r[29].s64 = ctx.r[10].s64 + 15448;
	// 82903EDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82903EE0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82903EE4: 419A0008  beq cr6, 0x82903eec
	if ctx.cr[6].eq {
	pc = 0x82903EEC; continue 'dispatch;
	}
	// 82903EE8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82903EEC; continue 'dispatch;
            }
            0x82903EEC => {
    //   block [0x82903EEC..0x82903F80)
	// 82903EEC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903EF0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82903EF4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903EF8: 4BACA6C9  bl 0x823ce5c0
	ctx.lr = 0x82903EFC;
	sub_823CE5C0(ctx, base);
	// 82903EFC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82903F00: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82903F04: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82903F08: 4BACA209  bl 0x823ce110
	ctx.lr = 0x82903F0C;
	sub_823CE110(ctx, base);
	// 82903F0C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82903F10: 4B8B3C09  bl 0x821b7b18
	ctx.lr = 0x82903F14;
	sub_821B7B18(ctx, base);
	// 82903F14: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82903F18: 4B91B341  bl 0x8221f258
	ctx.lr = 0x82903F1C;
	sub_8221F258(ctx, base);
	// 82903F1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82903F20: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82903F24: 419A005C  beq cr6, 0x82903f80
	if ctx.cr[6].eq {
	pc = 0x82903F80; continue 'dispatch;
	}
	// 82903F28: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82903F2C: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82903F30: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82903F34: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 82903F38: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82903F3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82903F40: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82903F44: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82903F48: 4B8EC2F9  bl 0x821f0240
	ctx.lr = 0x82903F4C;
	sub_821F0240(ctx, base);
	// 82903F4C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82903F50: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82903F54: 4B91B305  bl 0x8221f258
	ctx.lr = 0x82903F58;
	sub_8221F258(ctx, base);
	// 82903F58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82903F5C: 419A0028  beq cr6, 0x82903f84
	if ctx.cr[6].eq {
	pc = 0x82903F84; continue 'dispatch;
	}
	// 82903F60: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 82903F64: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82903F68: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82903F6C: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 82903F70: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82903F74: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82903F78: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82903F7C: 4800000C  b 0x82903f88
	pc = 0x82903F88; continue 'dispatch;
            }
            0x82903F80 => {
    //   block [0x82903F80..0x82903F84)
	// 82903F80: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x82903F84; continue 'dispatch;
            }
            0x82903F84 => {
    //   block [0x82903F84..0x82903F88)
	// 82903F84: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82903F88; continue 'dispatch;
            }
            0x82903F88 => {
    //   block [0x82903F88..0x82903F9C)
	// 82903F88: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903F8C: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82903F90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82903F94: 419A0008  beq cr6, 0x82903f9c
	if ctx.cr[6].eq {
	pc = 0x82903F9C; continue 'dispatch;
	}
	// 82903F98: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82903F9C; continue 'dispatch;
            }
            0x82903F9C => {
    //   block [0x82903F9C..0x8290401C)
	// 82903F9C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82903FA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82903FA4: 419A0078  beq cr6, 0x8290401c
	if ctx.cr[6].eq {
	pc = 0x8290401C; continue 'dispatch;
	}
	// 82903FA8: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82903FAC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 82903FB0: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82903FB4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82903FB8: 4B925151  bl 0x82229108
	ctx.lr = 0x82903FBC;
	sub_82229108(ctx, base);
	// 82903FBC: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 82903FC0: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82903FC4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82903FC8: 3BCB4348  addi r30, r11, 0x4348
	ctx.r[30].s64 = ctx.r[11].s64 + 17224;
	// 82903FCC: 4B9238B5  bl 0x82227880
	ctx.lr = 0x82903FD0;
	sub_82227880(ctx, base);
	// 82903FD0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82903FD4: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 82903FD8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82903FDC: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 82903FE0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82903FE4: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82903FE8: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82903FEC: 4B896A95  bl 0x8219aa80
	ctx.lr = 0x82903FF0;
	sub_8219AA80(ctx, base);
	// 82903FF0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82903FF4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82903FF8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82903FFC: 4BACA425  bl 0x823ce420
	ctx.lr = 0x82904000;
	sub_823CE420(ctx, base);
	// 82904000: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82904004: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 82904008: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8290400C: 481206BD  bl 0x82a246c8
	ctx.lr = 0x82904010;
	sub_82A246C8(ctx, base);
	// 82904010: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82904014: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 82904018: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x8290401C; continue 'dispatch;
            }
            0x8290401C => {
    //   block [0x8290401C..0x8290402C)
	// 8290401C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82904020: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82904024: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82904028: 419A0020  beq cr6, 0x82904048
	if ctx.cr[6].eq {
	pc = 0x82904048; continue 'dispatch;
	}
	pc = 0x8290402C; continue 'dispatch;
            }
            0x8290402C => {
    //   block [0x8290402C..0x82904048)
	// 8290402C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82904030: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82904034: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82904038: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8290403C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82904040: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82904044: 4082FFE8  bne 0x8290402c
	if !ctx.cr[0].eq {
	pc = 0x8290402C; continue 'dispatch;
	}
	pc = 0x82904048; continue 'dispatch;
            }
            0x82904048 => {
    //   block [0x82904048..0x82904068)
	// 82904048: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290404C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82904050: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 82904054: 4B9F18F5  bl 0x822f5948
	ctx.lr = 0x82904058;
	sub_822F5948(ctx, base);
	// 82904058: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290405C: 4B8B3ABD  bl 0x821b7b18
	ctx.lr = 0x82904060;
	sub_821B7B18(ctx, base);
	// 82904060: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82904064: 419A0040  beq cr6, 0x829040a4
	if ctx.cr[6].eq {
	pc = 0x829040A4; continue 'dispatch;
	}
	pc = 0x82904068; continue 'dispatch;
            }
            0x82904068 => {
    //   block [0x82904068..0x829040A4)
	// 82904068: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8290406C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82904070: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82904074: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82904078: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8290407C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82904080: 4082FFE8  bne 0x82904068
	if !ctx.cr[0].eq {
	pc = 0x82904068; continue 'dispatch;
	}
	// 82904084: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82904088: 409A001C  bne cr6, 0x829040a4
	if !ctx.cr[6].eq {
	pc = 0x829040A4; continue 'dispatch;
	}
	// 8290408C: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82904090: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82904094: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82904098: 4E800421  bctrl
	ctx.lr = 0x8290409C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290409C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829040A0: 4B917C99  bl 0x8221bd38
	ctx.lr = 0x829040A4;
	sub_8221BD38(ctx, base);
            }
            0x829040A4 => {
    //   block [0x829040A4..0x829040B4)
	// 829040A4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829040A8: 4B8B3A71  bl 0x821b7b18
	ctx.lr = 0x829040AC;
	sub_821B7B18(ctx, base);
	// 829040AC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 829040B0: 483A539C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829040B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829040B8 size=516
    let mut pc: u32 = 0x829040B8;
    'dispatch: loop {
        match pc {
            0x829040B8 => {
    //   block [0x829040B8..0x829040F4)
	// 829040B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829040BC: 483A5341  bl 0x82ca93fc
	ctx.lr = 0x829040C0;
	sub_82CA93D0(ctx, base);
	// 829040C0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829040C4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829040C8: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 829040CC: 3D408290  lis r10, -0x7d70
	ctx.r[10].s64 = -2104492032;
	// 829040D0: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 829040D4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 829040D8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829040DC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 829040E0: 3BAA3C60  addi r29, r10, 0x3c60
	ctx.r[29].s64 = ctx.r[10].s64 + 15456;
	// 829040E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829040E8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 829040EC: 419A0008  beq cr6, 0x829040f4
	if ctx.cr[6].eq {
	pc = 0x829040F4; continue 'dispatch;
	}
	// 829040F0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829040F4; continue 'dispatch;
            }
            0x829040F4 => {
    //   block [0x829040F4..0x82904188)
	// 829040F4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829040F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829040FC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82904100: 4BACA4C1  bl 0x823ce5c0
	ctx.lr = 0x82904104;
	sub_823CE5C0(ctx, base);
	// 82904104: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82904108: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8290410C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82904110: 4BACA001  bl 0x823ce110
	ctx.lr = 0x82904114;
	sub_823CE110(ctx, base);
	// 82904114: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82904118: 4B8B3A01  bl 0x821b7b18
	ctx.lr = 0x8290411C;
	sub_821B7B18(ctx, base);
	// 8290411C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82904120: 4B91B139  bl 0x8221f258
	ctx.lr = 0x82904124;
	sub_8221F258(ctx, base);
	// 82904124: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82904128: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8290412C: 419A005C  beq cr6, 0x82904188
	if ctx.cr[6].eq {
	pc = 0x82904188; continue 'dispatch;
	}
	// 82904130: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82904134: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82904138: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8290413C: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 82904140: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82904144: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82904148: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8290414C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82904150: 4B8EC0F1  bl 0x821f0240
	ctx.lr = 0x82904154;
	sub_821F0240(ctx, base);
	// 82904154: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82904158: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 8290415C: 4B91B0FD  bl 0x8221f258
	ctx.lr = 0x82904160;
	sub_8221F258(ctx, base);
	// 82904160: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82904164: 419A0028  beq cr6, 0x8290418c
	if ctx.cr[6].eq {
	pc = 0x8290418C; continue 'dispatch;
	}
	// 82904168: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 8290416C: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82904170: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82904174: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 82904178: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8290417C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82904180: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82904184: 4800000C  b 0x82904190
	pc = 0x82904190; continue 'dispatch;
            }
            0x82904188 => {
    //   block [0x82904188..0x8290418C)
	// 82904188: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x8290418C; continue 'dispatch;
            }
            0x8290418C => {
    //   block [0x8290418C..0x82904190)
	// 8290418C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82904190; continue 'dispatch;
            }
            0x82904190 => {
    //   block [0x82904190..0x829041A4)
	// 82904190: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82904194: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82904198: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290419C: 419A0008  beq cr6, 0x829041a4
	if ctx.cr[6].eq {
	pc = 0x829041A4; continue 'dispatch;
	}
	// 829041A0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829041A4; continue 'dispatch;
            }
            0x829041A4 => {
    //   block [0x829041A4..0x82904224)
	// 829041A4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829041A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829041AC: 419A0078  beq cr6, 0x82904224
	if ctx.cr[6].eq {
	pc = 0x82904224; continue 'dispatch;
	}
	// 829041B0: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829041B4: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 829041B8: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829041BC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829041C0: 4B924F49  bl 0x82229108
	ctx.lr = 0x829041C4;
	sub_82229108(ctx, base);
	// 829041C4: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 829041C8: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 829041CC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829041D0: 3BCB44C0  addi r30, r11, 0x44c0
	ctx.r[30].s64 = ctx.r[11].s64 + 17600;
	// 829041D4: 4B9236AD  bl 0x82227880
	ctx.lr = 0x829041D8;
	sub_82227880(ctx, base);
	// 829041D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829041DC: 3D40827C  lis r10, -0x7d84
	ctx.r[10].s64 = -2105802752;
	// 829041E0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829041E4: 388AD6C8  addi r4, r10, -0x2938
	ctx.r[4].s64 = ctx.r[10].s64 + -10552;
	// 829041E8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829041EC: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 829041F0: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829041F4: 4B89688D  bl 0x8219aa80
	ctx.lr = 0x829041F8;
	sub_8219AA80(ctx, base);
	// 829041F8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829041FC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82904200: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82904204: 4BACA21D  bl 0x823ce420
	ctx.lr = 0x82904208;
	sub_823CE420(ctx, base);
	// 82904208: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290420C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 82904210: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82904214: 481204B5  bl 0x82a246c8
	ctx.lr = 0x82904218;
	sub_82A246C8(ctx, base);
	// 82904218: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290421C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 82904220: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x82904224; continue 'dispatch;
            }
            0x82904224 => {
    //   block [0x82904224..0x82904234)
	// 82904224: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82904228: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8290422C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82904230: 419A0020  beq cr6, 0x82904250
	if ctx.cr[6].eq {
	pc = 0x82904250; continue 'dispatch;
	}
	pc = 0x82904234; continue 'dispatch;
            }
            0x82904234 => {
    //   block [0x82904234..0x82904250)
	// 82904234: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82904238: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290423C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82904240: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82904244: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82904248: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290424C: 4082FFE8  bne 0x82904234
	if !ctx.cr[0].eq {
	pc = 0x82904234; continue 'dispatch;
	}
	pc = 0x82904250; continue 'dispatch;
            }
            0x82904250 => {
    //   block [0x82904250..0x82904270)
	// 82904250: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82904254: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82904258: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 8290425C: 4B9F16ED  bl 0x822f5948
	ctx.lr = 0x82904260;
	sub_822F5948(ctx, base);
	// 82904260: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82904264: 4B8B38B5  bl 0x821b7b18
	ctx.lr = 0x82904268;
	sub_821B7B18(ctx, base);
	// 82904268: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8290426C: 419A0040  beq cr6, 0x829042ac
	if ctx.cr[6].eq {
	pc = 0x829042AC; continue 'dispatch;
	}
	pc = 0x82904270; continue 'dispatch;
            }
            0x82904270 => {
    //   block [0x82904270..0x829042AC)
	// 82904270: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82904274: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82904278: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8290427C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82904280: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82904284: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82904288: 4082FFE8  bne 0x82904270
	if !ctx.cr[0].eq {
	pc = 0x82904270; continue 'dispatch;
	}
	// 8290428C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82904290: 409A001C  bne cr6, 0x829042ac
	if !ctx.cr[6].eq {
	pc = 0x829042AC; continue 'dispatch;
	}
	// 82904294: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82904298: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290429C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829042A0: 4E800421  bctrl
	ctx.lr = 0x829042A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829042A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829042A8: 4B917A91  bl 0x8221bd38
	ctx.lr = 0x829042AC;
	sub_8221BD38(ctx, base);
            }
            0x829042AC => {
    //   block [0x829042AC..0x829042BC)
	// 829042AC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829042B0: 4B8B3869  bl 0x821b7b18
	ctx.lr = 0x829042B4;
	sub_821B7B18(ctx, base);
	// 829042B4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 829042B8: 483A5194  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829042C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829042C0 size=72
    let mut pc: u32 = 0x829042C0;
    'dispatch: loop {
        match pc {
            0x829042C0 => {
    //   block [0x829042C0..0x829042F4)
	// 829042C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829042C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829042C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829042CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829042D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829042D4: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829042D8: 548A07FE  clrlwi r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 829042DC: 392B2B90  addi r9, r11, 0x2b90
	ctx.r[9].s64 = ctx.r[11].s64 + 11152;
	// 829042E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829042E4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829042E8: 419A000C  beq cr6, 0x829042f4
	if ctx.cr[6].eq {
	pc = 0x829042F4; continue 'dispatch;
	}
	// 829042EC: 4B917A4D  bl 0x8221bd38
	ctx.lr = 0x829042F0;
	sub_8221BD38(ctx, base);
	// 829042F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x829042F4; continue 'dispatch;
            }
            0x829042F4 => {
    //   block [0x829042F4..0x82904308)
	// 829042F4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829042F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829042FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82904300: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82904304: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82904308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82904308 size=56
    let mut pc: u32 = 0x82904308;
    'dispatch: loop {
        match pc {
            0x82904308 => {
    //   block [0x82904308..0x82904324)
	// 82904308: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8290430C: 419A0018  beq cr6, 0x82904324
	if ctx.cr[6].eq {
	pc = 0x82904324; continue 'dispatch;
	}
	// 82904310: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 82904314: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82904318: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290431C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82904320: 409A0008  bne cr6, 0x82904328
	if !ctx.cr[6].eq {
	pc = 0x82904328; continue 'dispatch;
	}
	pc = 0x82904324; continue 'dispatch;
            }
            0x82904324 => {
    //   block [0x82904324..0x82904328)
	// 82904324: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82904328; continue 'dispatch;
            }
            0x82904328 => {
    //   block [0x82904328..0x82904340)
	// 82904328: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290432C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82904330: 419A0010  beq cr6, 0x82904340
	if ctx.cr[6].eq {
		sub_82904340(ctx, base);
		return;
	}
	// 82904334: A1640030  lhz r11, 0x30(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 82904338: 556307FE  clrlwi r3, r11, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 8290433C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82904340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82904340 size=8
    let mut pc: u32 = 0x82904340;
    'dispatch: loop {
        match pc {
            0x82904340 => {
    //   block [0x82904340..0x82904348)
	// 82904340: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82904344: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82904348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82904348 size=372
    let mut pc: u32 = 0x82904348;
    'dispatch: loop {
        match pc {
            0x82904348 => {
    //   block [0x82904348..0x82904370)
	// 82904348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290434C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82904350: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82904354: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82904358: 419A0018  beq cr6, 0x82904370
	if ctx.cr[6].eq {
	pc = 0x82904370; continue 'dispatch;
	}
	// 8290435C: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 82904360: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82904364: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82904368: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290436C: 409A0008  bne cr6, 0x82904374
	if !ctx.cr[6].eq {
	pc = 0x82904374; continue 'dispatch;
	}
	pc = 0x82904370; continue 'dispatch;
            }
            0x82904370 => {
    //   block [0x82904370..0x82904374)
	// 82904370: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82904374; continue 'dispatch;
            }
            0x82904374 => {
    //   block [0x82904374..0x829043BC)
	// 82904374: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82904378: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290437C: 419A012C  beq cr6, 0x829044a8
	if ctx.cr[6].eq {
	pc = 0x829044A8; continue 'dispatch;
	}
	// 82904380: A1440030  lhz r10, 0x30(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 82904384: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82904388: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 8290438C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82904390: 419A00E8  beq cr6, 0x82904478
	if ctx.cr[6].eq {
	pc = 0x82904478; continue 'dispatch;
	}
	// 82904394: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 82904398: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 8290439C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829043A0: 419A001C  beq cr6, 0x829043bc
	if ctx.cr[6].eq {
	pc = 0x829043BC; continue 'dispatch;
	}
	// 829043A4: 896B0070  lbz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 829043A8: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 829043AC: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829043B0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829043B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829043B8: 480000C4  b 0x8290447c
	pc = 0x8290447C; continue 'dispatch;
            }
            0x829043BC => {
    //   block [0x829043BC..0x829043D8)
	// 829043BC: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 829043C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829043C4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829043C8: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829043CC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829043D0: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829043D4: 40810054  ble 0x82904428
	if !ctx.cr[0].gt {
	pc = 0x82904428; continue 'dispatch;
	}
	pc = 0x829043D8; continue 'dispatch;
            }
            0x829043D8 => {
    //   block [0x829043D8..0x829043F8)
	// 829043D8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829043DC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829043E0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829043E4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829043E8: 2F070070  cmpwi cr6, r7, 0x70
	ctx.cr[6].compare_i32(ctx.r[7].s32, 112, &mut ctx.xer);
	// 829043EC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829043F0: 41980008  blt cr6, 0x829043f8
	if ctx.cr[6].lt {
	pc = 0x829043F8; continue 'dispatch;
	}
	// 829043F4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x829043F8; continue 'dispatch;
            }
            0x829043F8 => {
    //   block [0x829043F8..0x82904414)
	// 829043F8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829043FC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82904400: 419A0014  beq cr6, 0x82904414
	if ctx.cr[6].eq {
	pc = 0x82904414; continue 'dispatch;
	}
	// 82904404: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82904408: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8290440C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82904410: 4800000C  b 0x8290441c
	pc = 0x8290441C; continue 'dispatch;
            }
            0x82904414 => {
    //   block [0x82904414..0x8290441C)
	// 82904414: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82904418: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8290441C; continue 'dispatch;
            }
            0x8290441C => {
    //   block [0x8290441C..0x82904428)
	// 8290441C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82904420: 4199FFB8  bgt cr6, 0x829043d8
	if ctx.cr[6].gt {
	pc = 0x829043D8; continue 'dispatch;
	}
	// 82904424: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82904428; continue 'dispatch;
            }
            0x82904428 => {
    //   block [0x82904428..0x82904444)
	// 82904428: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8290442C: 419A003C  beq cr6, 0x82904468
	if ctx.cr[6].eq {
	pc = 0x82904468; continue 'dispatch;
	}
	// 82904430: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82904434: 2F0B0070  cmpwi cr6, r11, 0x70
	ctx.cr[6].compare_i32(ctx.r[11].s32, 112, &mut ctx.xer);
	// 82904438: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290443C: 41990008  bgt cr6, 0x82904444
	if ctx.cr[6].gt {
	pc = 0x82904444; continue 'dispatch;
	}
	// 82904440: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82904444; continue 'dispatch;
            }
            0x82904444 => {
    //   block [0x82904444..0x82904468)
	// 82904444: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82904448: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290444C: 409A001C  bne cr6, 0x82904468
	if !ctx.cr[6].eq {
	pc = 0x82904468; continue 'dispatch;
	}
	// 82904450: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82904454: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82904458: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8290445C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82904460: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82904464: 48000018  b 0x8290447c
	pc = 0x8290447C; continue 'dispatch;
            }
            0x82904468 => {
    //   block [0x82904468..0x82904478)
	// 82904468: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8290446C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82904470: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82904474: 48000008  b 0x8290447c
	pc = 0x8290447C; continue 'dispatch;
            }
            0x82904478 => {
    //   block [0x82904478..0x8290447C)
	// 82904478: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x8290447C; continue 'dispatch;
            }
            0x8290447C => {
    //   block [0x8290447C..0x829044A8)
	// 8290447C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82904480: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82904484: 419A0024  beq cr6, 0x829044a8
	if ctx.cr[6].eq {
	pc = 0x829044A8; continue 'dispatch;
	}
	// 82904488: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290448C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82904490: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82904494: 4E800421  bctrl
	ctx.lr = 0x82904498;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82904498: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8290449C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829044A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829044A4: 4E800020  blr
	return;
            }
            0x829044A8 => {
    //   block [0x829044A8..0x829044BC)
	// 829044A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829044AC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829044B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829044B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829044B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829044C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829044C0 size=376
    let mut pc: u32 = 0x829044C0;
    'dispatch: loop {
        match pc {
            0x829044C0 => {
    //   block [0x829044C0..0x829044EC)
	// 829044C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829044C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829044C8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829044CC: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 829044D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829044D4: 419A0018  beq cr6, 0x829044ec
	if ctx.cr[6].eq {
	pc = 0x829044EC; continue 'dispatch;
	}
	// 829044D8: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 829044DC: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 829044E0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829044E4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829044E8: 409A0008  bne cr6, 0x829044f0
	if !ctx.cr[6].eq {
	pc = 0x829044F0; continue 'dispatch;
	}
	pc = 0x829044EC; continue 'dispatch;
            }
            0x829044EC => {
    //   block [0x829044EC..0x829044F0)
	// 829044EC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x829044F0; continue 'dispatch;
            }
            0x829044F0 => {
    //   block [0x829044F0..0x8290453C)
	// 829044F0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 829044F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829044F8: 419A0130  beq cr6, 0x82904628
	if ctx.cr[6].eq {
	pc = 0x82904628; continue 'dispatch;
	}
	// 829044FC: A12B0030  lhz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82904500: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82904504: 552807FE  clrlwi r8, r9, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 82904508: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8290450C: 419A00F8  beq cr6, 0x82904604
	if ctx.cr[6].eq {
	pc = 0x82904604; continue 'dispatch;
	}
	// 82904510: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82904514: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82904518: 419A0024  beq cr6, 0x8290453c
	if ctx.cr[6].eq {
	pc = 0x8290453C; continue 'dispatch;
	}
	// 8290451C: 892A0070  lbz r9, 0x70(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(112 as u32) ) } as u64;
	// 82904520: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82904524: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 82904528: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8290452C: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82904530: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82904534: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82904538: 480000D0  b 0x82904608
	pc = 0x82904608; continue 'dispatch;
            }
            0x8290453C => {
    //   block [0x8290453C..0x8290455C)
	// 8290453C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82904540: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82904544: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82904548: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 8290454C: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82904550: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82904554: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82904558: 40810054  ble 0x829045ac
	if !ctx.cr[0].gt {
	pc = 0x829045AC; continue 'dispatch;
	}
	pc = 0x8290455C; continue 'dispatch;
            }
            0x8290455C => {
    //   block [0x8290455C..0x8290457C)
	// 8290455C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82904560: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82904564: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82904568: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290456C: 2F070070  cmpwi cr6, r7, 0x70
	ctx.cr[6].compare_i32(ctx.r[7].s32, 112, &mut ctx.xer);
	// 82904570: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82904574: 41980008  blt cr6, 0x8290457c
	if ctx.cr[6].lt {
	pc = 0x8290457C; continue 'dispatch;
	}
	// 82904578: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x8290457C; continue 'dispatch;
            }
            0x8290457C => {
    //   block [0x8290457C..0x82904598)
	// 8290457C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82904580: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82904584: 419A0014  beq cr6, 0x82904598
	if ctx.cr[6].eq {
	pc = 0x82904598; continue 'dispatch;
	}
	// 82904588: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8290458C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82904590: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82904594: 4800000C  b 0x829045a0
	pc = 0x829045A0; continue 'dispatch;
            }
            0x82904598 => {
    //   block [0x82904598..0x829045A0)
	// 82904598: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8290459C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829045A0; continue 'dispatch;
            }
            0x829045A0 => {
    //   block [0x829045A0..0x829045AC)
	// 829045A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829045A4: 4199FFB8  bgt cr6, 0x8290455c
	if ctx.cr[6].gt {
	pc = 0x8290455C; continue 'dispatch;
	}
	// 829045A8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x829045AC; continue 'dispatch;
            }
            0x829045AC => {
    //   block [0x829045AC..0x829045C8)
	// 829045AC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829045B0: 419A0040  beq cr6, 0x829045f0
	if ctx.cr[6].eq {
	pc = 0x829045F0; continue 'dispatch;
	}
	// 829045B4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829045B8: 2F0B0070  cmpwi cr6, r11, 0x70
	ctx.cr[6].compare_i32(ctx.r[11].s32, 112, &mut ctx.xer);
	// 829045BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829045C0: 41990008  bgt cr6, 0x829045c8
	if ctx.cr[6].gt {
	pc = 0x829045C8; continue 'dispatch;
	}
	// 829045C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829045C8; continue 'dispatch;
            }
            0x829045C8 => {
    //   block [0x829045C8..0x829045F0)
	// 829045C8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829045CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829045D0: 409A0020  bne cr6, 0x829045f0
	if !ctx.cr[6].eq {
	pc = 0x829045F0; continue 'dispatch;
	}
	// 829045D4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829045D8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829045DC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829045E0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829045E4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 829045E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829045EC: 4800001C  b 0x82904608
	pc = 0x82904608; continue 'dispatch;
            }
            0x829045F0 => {
    //   block [0x829045F0..0x82904604)
	// 829045F0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829045F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829045F8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 829045FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82904600: 48000008  b 0x82904608
	pc = 0x82904608; continue 'dispatch;
            }
            0x82904604 => {
    //   block [0x82904604..0x82904608)
	// 82904604: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82904608; continue 'dispatch;
            }
            0x82904608 => {
    //   block [0x82904608..0x82904628)
	// 82904608: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290460C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82904610: 419A0018  beq cr6, 0x82904628
	if ctx.cr[6].eq {
	pc = 0x82904628; continue 'dispatch;
	}
	// 82904614: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82904618: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 8290461C: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82904620: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82904624: 4E800421  bctrl
	ctx.lr = 0x82904628;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82904628 => {
    //   block [0x82904628..0x82904638)
	// 82904628: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8290462C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82904630: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82904634: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82904638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82904638 size=116
    let mut pc: u32 = 0x82904638;
    'dispatch: loop {
        match pc {
            0x82904638 => {
    //   block [0x82904638..0x82904684)
	// 82904638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290463C: 483A4DD1  bl 0x82ca940c
	ctx.lr = 0x82904640;
	sub_82CA93D0(ctx, base);
	// 82904640: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82904644: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82904648: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 8290464C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82904650: 4B91AC09  bl 0x8221f258
	ctx.lr = 0x82904654;
	sub_8221F258(ctx, base);
	// 82904654: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82904658: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8290465C: 419A0028  beq cr6, 0x82904684
	if ctx.cr[6].eq {
	pc = 0x82904684; continue 'dispatch;
	}
	// 82904660: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82904664: 4B889725  bl 0x8218dd88
	ctx.lr = 0x82904668;
	sub_8218DD88(ctx, base);
	// 82904668: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8290466C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82904670: 394B5200  addi r10, r11, 0x5200
	ctx.r[10].s64 = ctx.r[11].s64 + 20992;
	// 82904674: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82904678: 893E006C  lbz r9, 0x6c(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 8290467C: 993F006C  stb r9, 0x6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[9].u8 ) };
	// 82904680: 48000008  b 0x82904688
	pc = 0x82904688; continue 'dispatch;
            }
            0x82904684 => {
    //   block [0x82904684..0x82904688)
	// 82904684: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x82904688; continue 'dispatch;
            }
            0x82904688 => {
    //   block [0x82904688..0x829046A0)
	// 82904688: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8290468C: 4B9BB88D  bl 0x822bff18
	ctx.lr = 0x82904690;
	sub_822BFF18(ctx, base);
	// 82904690: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82904694: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82904698: 419A0008  beq cr6, 0x829046a0
	if ctx.cr[6].eq {
	pc = 0x829046A0; continue 'dispatch;
	}
	// 8290469C: 4B87CB85  bl 0x82181220
	ctx.lr = 0x829046A0;
	sub_82181220(ctx, base);
	pc = 0x829046A0; continue 'dispatch;
            }
            0x829046A0 => {
    //   block [0x829046A0..0x829046AC)
	// 829046A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829046A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829046A8: 483A4DB4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829046B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829046B0 size=116
    let mut pc: u32 = 0x829046B0;
    'dispatch: loop {
        match pc {
            0x829046B0 => {
    //   block [0x829046B0..0x829046FC)
	// 829046B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829046B4: 483A4D59  bl 0x82ca940c
	ctx.lr = 0x829046B8;
	sub_82CA93D0(ctx, base);
	// 829046B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829046BC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829046C0: 3860007C  li r3, 0x7c
	ctx.r[3].s64 = 124;
	// 829046C4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829046C8: 4B91AB91  bl 0x8221f258
	ctx.lr = 0x829046CC;
	sub_8221F258(ctx, base);
	// 829046CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829046D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829046D4: 419A0028  beq cr6, 0x829046fc
	if ctx.cr[6].eq {
	pc = 0x829046FC; continue 'dispatch;
	}
	// 829046D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829046DC: 4BB05615  bl 0x82409cf0
	ctx.lr = 0x829046E0;
	sub_82409CF0(ctx, base);
	// 829046E0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 829046E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829046E8: 394B5250  addi r10, r11, 0x5250
	ctx.r[10].s64 = ctx.r[11].s64 + 21072;
	// 829046EC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829046F0: C01E0078  lfs f0, 0x78(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829046F4: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 829046F8: 48000008  b 0x82904700
	pc = 0x82904700; continue 'dispatch;
            }
            0x829046FC => {
    //   block [0x829046FC..0x82904700)
	// 829046FC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x82904700; continue 'dispatch;
            }
            0x82904700 => {
    //   block [0x82904700..0x82904718)
	// 82904700: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82904704: 4B9BB815  bl 0x822bff18
	ctx.lr = 0x82904708;
	sub_822BFF18(ctx, base);
	// 82904708: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290470C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82904710: 419A0008  beq cr6, 0x82904718
	if ctx.cr[6].eq {
	pc = 0x82904718; continue 'dispatch;
	}
	// 82904714: 4B87CB0D  bl 0x82181220
	ctx.lr = 0x82904718;
	sub_82181220(ctx, base);
	pc = 0x82904718; continue 'dispatch;
            }
            0x82904718 => {
    //   block [0x82904718..0x82904724)
	// 82904718: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8290471C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82904720: 483A4D3C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82904728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82904728 size=184
    let mut pc: u32 = 0x82904728;
    'dispatch: loop {
        match pc {
            0x82904728 => {
    //   block [0x82904728..0x829047B8)
	// 82904728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290472C: 483A4CE1  bl 0x82ca940c
	ctx.lr = 0x82904730;
	sub_82CA93D0(ctx, base);
	// 82904730: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82904734: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82904738: 386000A0  li r3, 0xa0
	ctx.r[3].s64 = 160;
	// 8290473C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82904740: 4B91AB19  bl 0x8221f258
	ctx.lr = 0x82904744;
	sub_8221F258(ctx, base);
	// 82904744: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82904748: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8290474C: 419A006C  beq cr6, 0x829047b8
	if ctx.cr[6].eq {
	pc = 0x829047B8; continue 'dispatch;
	}
	// 82904750: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82904754: 4B889635  bl 0x8218dd88
	ctx.lr = 0x82904758;
	sub_8218DD88(ctx, base);
	// 82904758: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8290475C: 389E006C  addi r4, r30, 0x6c
	ctx.r[4].s64 = ctx.r[30].s64 + 108;
	// 82904760: 394B52A0  addi r10, r11, 0x52a0
	ctx.r[10].s64 = ctx.r[11].s64 + 21152;
	// 82904764: 387F006C  addi r3, r31, 0x6c
	ctx.r[3].s64 = ctx.r[31].s64 + 108;
	// 82904768: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8290476C: 4B892605  bl 0x82196d70
	ctx.lr = 0x82904770;
	sub_82196D70(ctx, base);
	// 82904770: 39600080  li r11, 0x80
	ctx.r[11].s64 = 128;
	pc = 0x829047B8; continue 'dispatch;
            }
            0x829047B8 => {
    //   block [0x829047B8..0x829047E0)
	// 829047B8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829047BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829047C0: 4B9BB759  bl 0x822bff18
	ctx.lr = 0x829047C4;
	sub_822BFF18(ctx, base);
	// 829047C4: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829047C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829047CC: 419A0008  beq cr6, 0x829047d4
	if ctx.cr[6].eq {
	pc = 0x829047D4; continue 'dispatch;
	}
	// 829047D0: 4B87CA51  bl 0x82181220
	ctx.lr = 0x829047D4;
	sub_82181220(ctx, base);
	// 829047D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829047D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829047DC: 483A4C80  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829047E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829047E0 size=80
    let mut pc: u32 = 0x829047E0;
    'dispatch: loop {
        match pc {
            0x829047E0 => {
    //   block [0x829047E0..0x82904818)
	// 829047E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829047E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829047E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829047EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829047F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829047F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829047F8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829047FC: 4BD1B6AD  bl 0x8261fea8
	ctx.lr = 0x82904800;
	sub_8261FEA8(ctx, base);
	// 82904800: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82904804: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82904808: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290480C: 419A000C  beq cr6, 0x82904818
	if ctx.cr[6].eq {
	pc = 0x82904818; continue 'dispatch;
	}
	// 82904810: 4B917529  bl 0x8221bd38
	ctx.lr = 0x82904814;
	sub_8221BD38(ctx, base);
	// 82904814: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82904818; continue 'dispatch;
            }
            0x82904818 => {
    //   block [0x82904818..0x82904830)
	// 82904818: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8290481C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82904820: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82904824: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82904828: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8290482C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82904830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82904830 size=108
    let mut pc: u32 = 0x82904830;
    'dispatch: loop {
        match pc {
            0x82904830 => {
    //   block [0x82904830..0x82904874)
	// 82904830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82904834: 483A4BD9  bl 0x82ca940c
	ctx.lr = 0x82904838;
	sub_82CA93D0(ctx, base);
	// 82904838: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290483C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82904840: 38600078  li r3, 0x78
	ctx.r[3].s64 = 120;
	// 82904844: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82904848: 4B91AA11  bl 0x8221f258
	ctx.lr = 0x8290484C;
	sub_8221F258(ctx, base);
	// 8290484C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82904850: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82904854: 419A0020  beq cr6, 0x82904874
	if ctx.cr[6].eq {
	pc = 0x82904874; continue 'dispatch;
	}
	// 82904858: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8290485C: 4BB05495  bl 0x82409cf0
	ctx.lr = 0x82904860;
	sub_82409CF0(ctx, base);
	// 82904860: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82904864: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82904868: 394B52F0  addi r10, r11, 0x52f0
	ctx.r[10].s64 = ctx.r[11].s64 + 21232;
	// 8290486C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82904870: 48000008  b 0x82904878
	pc = 0x82904878; continue 'dispatch;
            }
            0x82904874 => {
    //   block [0x82904874..0x82904878)
	// 82904874: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x82904878; continue 'dispatch;
            }
            0x82904878 => {
    //   block [0x82904878..0x82904890)
	// 82904878: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8290487C: 4B9BB69D  bl 0x822bff18
	ctx.lr = 0x82904880;
	sub_822BFF18(ctx, base);
	// 82904880: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82904884: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82904888: 419A0008  beq cr6, 0x82904890
	if ctx.cr[6].eq {
	pc = 0x82904890; continue 'dispatch;
	}
	// 8290488C: 4B87C995  bl 0x82181220
	ctx.lr = 0x82904890;
	sub_82181220(ctx, base);
	pc = 0x82904890; continue 'dispatch;
            }
            0x82904890 => {
    //   block [0x82904890..0x8290489C)
	// 82904890: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82904894: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82904898: 483A4BC4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829048A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829048A0 size=392
    let mut pc: u32 = 0x829048A0;
    'dispatch: loop {
        match pc {
            0x829048A0 => {
    //   block [0x829048A0..0x829048E8)
	// 829048A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829048A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829048A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829048AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829048B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829048B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829048B8: 4B8951D9  bl 0x82199a90
	ctx.lr = 0x829048BC;
	sub_82199A90(ctx, base);
	// 829048BC: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 829048C0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829048C4: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 829048C8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829048CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829048D0: 419A001C  beq cr6, 0x829048ec
	if ctx.cr[6].eq {
	pc = 0x829048EC; continue 'dispatch;
	}
	// 829048D4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829048D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829048DC: 419A000C  beq cr6, 0x829048e8
	if ctx.cr[6].eq {
	pc = 0x829048E8; continue 'dispatch;
	}
	// 829048E0: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829048E4: 4800000C  b 0x829048f0
	pc = 0x829048F0; continue 'dispatch;
            }
            0x829048E8 => {
    //   block [0x829048E8..0x829048EC)
	// 829048E8: 4B88F551  bl 0x82193e38
	ctx.lr = 0x829048EC;
	sub_82193E38(ctx, base);
	pc = 0x829048EC; continue 'dispatch;
            }
            0x829048EC => {
    //   block [0x829048EC..0x829048F0)
	// 829048EC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x829048F0; continue 'dispatch;
            }
            0x829048F0 => {
    //   block [0x829048F0..0x8290492C)
	// 829048F0: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 829048F4: 55491FFE  rlwinm r9, r10, 3, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 829048F8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829048FC: 419A00F4  beq cr6, 0x829049f0
	if ctx.cr[6].eq {
	pc = 0x829049F0; continue 'dispatch;
	}
	// 82904900: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82904904: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82904908: 419A0024  beq cr6, 0x8290492c
	if ctx.cr[6].eq {
	pc = 0x8290492C; continue 'dispatch;
	}
	// 8290490C: 894A001D  lbz r10, 0x1d(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(29 as u32) ) } as u64;
	// 82904910: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82904914: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82904918: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8290491C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82904920: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82904924: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82904928: 480000CC  b 0x829049f4
	pc = 0x829049F4; continue 'dispatch;
            }
            0x8290492C => {
    //   block [0x8290492C..0x82904948)
	// 8290492C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82904930: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82904934: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82904938: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8290493C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82904940: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82904944: 40810054  ble 0x82904998
	if !ctx.cr[0].gt {
	pc = 0x82904998; continue 'dispatch;
	}
	pc = 0x82904948; continue 'dispatch;
            }
            0x82904948 => {
    //   block [0x82904948..0x82904968)
	// 82904948: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8290494C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82904950: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82904954: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82904958: 2F07001D  cmpwi cr6, r7, 0x1d
	ctx.cr[6].compare_i32(ctx.r[7].s32, 29, &mut ctx.xer);
	// 8290495C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82904960: 41980008  blt cr6, 0x82904968
	if ctx.cr[6].lt {
	pc = 0x82904968; continue 'dispatch;
	}
	// 82904964: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x82904968; continue 'dispatch;
            }
            0x82904968 => {
    //   block [0x82904968..0x82904984)
	// 82904968: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8290496C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82904970: 419A0014  beq cr6, 0x82904984
	if ctx.cr[6].eq {
	pc = 0x82904984; continue 'dispatch;
	}
	// 82904974: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82904978: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8290497C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82904980: 4800000C  b 0x8290498c
	pc = 0x8290498C; continue 'dispatch;
            }
            0x82904984 => {
    //   block [0x82904984..0x8290498C)
	// 82904984: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82904988: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8290498C; continue 'dispatch;
            }
            0x8290498C => {
    //   block [0x8290498C..0x82904998)
	// 8290498C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82904990: 4199FFB8  bgt cr6, 0x82904948
	if ctx.cr[6].gt {
	pc = 0x82904948; continue 'dispatch;
	}
	// 82904994: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82904998; continue 'dispatch;
            }
            0x82904998 => {
    //   block [0x82904998..0x829049B4)
	// 82904998: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8290499C: 419A0040  beq cr6, 0x829049dc
	if ctx.cr[6].eq {
	pc = 0x829049DC; continue 'dispatch;
	}
	// 829049A0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829049A4: 2F0B001D  cmpwi cr6, r11, 0x1d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 29, &mut ctx.xer);
	// 829049A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829049AC: 41990008  bgt cr6, 0x829049b4
	if ctx.cr[6].gt {
	pc = 0x829049B4; continue 'dispatch;
	}
	// 829049B0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x829049B4; continue 'dispatch;
            }
            0x829049B4 => {
    //   block [0x829049B4..0x829049DC)
	// 829049B4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829049B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829049BC: 409A0020  bne cr6, 0x829049dc
	if !ctx.cr[6].eq {
	pc = 0x829049DC; continue 'dispatch;
	}
	// 829049C0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829049C4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829049C8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829049CC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829049D0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829049D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829049D8: 4800001C  b 0x829049f4
	pc = 0x829049F4; continue 'dispatch;
            }
            0x829049DC => {
    //   block [0x829049DC..0x829049F0)
	// 829049DC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829049E0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829049E4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829049E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829049EC: 48000008  b 0x829049f4
	pc = 0x829049F4; continue 'dispatch;
            }
            0x829049F0 => {
    //   block [0x829049F0..0x829049F4)
	// 829049F0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x829049F4; continue 'dispatch;
            }
            0x829049F4 => {
    //   block [0x829049F4..0x82904A10)
	// 829049F4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829049F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829049FC: 419A0014  beq cr6, 0x82904a10
	if ctx.cr[6].eq {
	pc = 0x82904A10; continue 'dispatch;
	}
	// 82904A00: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82904A04: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 82904A08: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82904A0C: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	pc = 0x82904A10; continue 'dispatch;
            }
            0x82904A10 => {
    //   block [0x82904A10..0x82904A28)
	// 82904A10: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82904A14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82904A18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82904A1C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82904A20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82904A24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82904A28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82904A28 size=408
    let mut pc: u32 = 0x82904A28;
    'dispatch: loop {
        match pc {
            0x82904A28 => {
    //   block [0x82904A28..0x82904A8C)
	// 82904A28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82904A2C: 483A49E1  bl 0x82ca940c
	ctx.lr = 0x82904A30;
	sub_82CA93D0(ctx, base);
	// 82904A30: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82904A34: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82904A38: 897D006C  lbz r11, 0x6c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(108 as u32) ) } as u64;
	// 82904A3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82904A40: 409A0178  bne cr6, 0x82904bb8
	if !ctx.cr[6].eq {
	pc = 0x82904BB8; continue 'dispatch;
	}
	// 82904A44: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82904A48: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82904A4C: 4B86FA1D  bl 0x82174468
	ctx.lr = 0x82904A50;
	sub_82174468(ctx, base);
	// 82904A50: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82904A54: 556A1FFE  rlwinm r10, r11, 3, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 82904A58: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82904A5C: 419A00F4  beq cr6, 0x82904b50
	if ctx.cr[6].eq {
	pc = 0x82904B50; continue 'dispatch;
	}
	// 82904A60: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 82904A64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82904A68: 419A0024  beq cr6, 0x82904a8c
	if ctx.cr[6].eq {
	pc = 0x82904A8C; continue 'dispatch;
	}
	// 82904A6C: 894B001D  lbz r10, 0x1d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 82904A70: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 82904A74: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82904A78: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82904A7C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82904A80: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82904A84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82904A88: 480000CC  b 0x82904b54
	pc = 0x82904B54; continue 'dispatch;
            }
            0x82904A8C => {
    //   block [0x82904A8C..0x82904AA8)
	// 82904A8C: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 82904A90: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 82904A94: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82904A98: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82904A9C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82904AA0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82904AA4: 40810054  ble 0x82904af8
	if !ctx.cr[0].gt {
	pc = 0x82904AF8; continue 'dispatch;
	}
	pc = 0x82904AA8; continue 'dispatch;
            }
            0x82904AA8 => {
    //   block [0x82904AA8..0x82904AC8)
	// 82904AA8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82904AAC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82904AB0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82904AB4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82904AB8: 2F07001D  cmpwi cr6, r7, 0x1d
	ctx.cr[6].compare_i32(ctx.r[7].s32, 29, &mut ctx.xer);
	// 82904ABC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82904AC0: 41980008  blt cr6, 0x82904ac8
	if ctx.cr[6].lt {
	pc = 0x82904AC8; continue 'dispatch;
	}
	// 82904AC4: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x82904AC8; continue 'dispatch;
            }
            0x82904AC8 => {
    //   block [0x82904AC8..0x82904AE4)
	// 82904AC8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82904ACC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82904AD0: 419A0014  beq cr6, 0x82904ae4
	if ctx.cr[6].eq {
	pc = 0x82904AE4; continue 'dispatch;
	}
	// 82904AD4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82904AD8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82904ADC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82904AE0: 4800000C  b 0x82904aec
	pc = 0x82904AEC; continue 'dispatch;
            }
            0x82904AE4 => {
    //   block [0x82904AE4..0x82904AEC)
	// 82904AE4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82904AE8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82904AEC; continue 'dispatch;
            }
            0x82904AEC => {
    //   block [0x82904AEC..0x82904AF8)
	// 82904AEC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82904AF0: 4199FFB8  bgt cr6, 0x82904aa8
	if ctx.cr[6].gt {
	pc = 0x82904AA8; continue 'dispatch;
	}
	// 82904AF4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82904AF8; continue 'dispatch;
            }
            0x82904AF8 => {
    //   block [0x82904AF8..0x82904B14)
	// 82904AF8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82904AFC: 419A0040  beq cr6, 0x82904b3c
	if ctx.cr[6].eq {
	pc = 0x82904B3C; continue 'dispatch;
	}
	// 82904B00: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82904B04: 2F0B001D  cmpwi cr6, r11, 0x1d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 29, &mut ctx.xer);
	// 82904B08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82904B0C: 41990008  bgt cr6, 0x82904b14
	if ctx.cr[6].gt {
	pc = 0x82904B14; continue 'dispatch;
	}
	// 82904B10: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82904B14; continue 'dispatch;
            }
            0x82904B14 => {
    //   block [0x82904B14..0x82904B3C)
	// 82904B14: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82904B18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82904B1C: 409A0020  bne cr6, 0x82904b3c
	if !ctx.cr[6].eq {
	pc = 0x82904B3C; continue 'dispatch;
	}
	// 82904B20: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82904B24: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82904B28: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82904B2C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82904B30: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82904B34: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82904B38: 4800001C  b 0x82904b54
	pc = 0x82904B54; continue 'dispatch;
            }
            0x82904B3C => {
    //   block [0x82904B3C..0x82904B50)
	// 82904B3C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82904B40: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82904B44: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82904B48: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82904B4C: 48000008  b 0x82904b54
	pc = 0x82904B54; continue 'dispatch;
            }
            0x82904B50 => {
    //   block [0x82904B50..0x82904B54)
	// 82904B50: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82904B54; continue 'dispatch;
            }
            0x82904B54 => {
    //   block [0x82904B54..0x82904B8C)
	// 82904B54: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82904B58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82904B5C: 419A0044  beq cr6, 0x82904ba0
	if ctx.cr[6].eq {
	pc = 0x82904BA0; continue 'dispatch;
	}
	// 82904B60: C01F0020  lfs f0, 0x20(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82904B64: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82904B68: FD800210  fabs f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82904B6C: 394BDE98  addi r10, r11, -0x2168
	ctx.r[10].s64 = ctx.r[11].s64 + -8552;
	// 82904B70: C1ABDE98  lfs f13, -0x2168(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8552 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82904B74: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82904B78: C00AB5EC  lfs f0, -0x4a14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-18964 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82904B7C: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82904B80: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82904B84: 40990008  ble cr6, 0x82904b8c
	if !ctx.cr[6].gt {
	pc = 0x82904B8C; continue 'dispatch;
	}
	// 82904B88: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82904B8C; continue 'dispatch;
            }
            0x82904B8C => {
    //   block [0x82904B8C..0x82904BA0)
	// 82904B8C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82904B90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82904B94: 419A0010  beq cr6, 0x82904ba4
	if ctx.cr[6].eq {
	pc = 0x82904BA4; continue 'dispatch;
	}
	// 82904B98: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82904B9C: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	pc = 0x82904BA0; continue 'dispatch;
            }
            0x82904BA0 => {
    //   block [0x82904BA0..0x82904BA4)
	// 82904BA0: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	pc = 0x82904BA4; continue 'dispatch;
            }
            0x82904BA4 => {
    //   block [0x82904BA4..0x82904BB8)
	// 82904BA4: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 82904BA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82904BAC: 419A000C  beq cr6, 0x82904bb8
	if ctx.cr[6].eq {
	pc = 0x82904BB8; continue 'dispatch;
	}
	// 82904BB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82904BB4: 4800000D  bl 0x82904bc0
	ctx.lr = 0x82904BB8;
	sub_82904BC0(ctx, base);
	pc = 0x82904BB8; continue 'dispatch;
            }
            0x82904BB8 => {
    //   block [0x82904BB8..0x82904BC0)
	// 82904BB8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82904BBC: 483A48A0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82904BC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82904BC0 size=732
    let mut pc: u32 = 0x82904BC0;
    'dispatch: loop {
        match pc {
            0x82904BC0 => {
    //   block [0x82904BC0..0x82904C1C)
	// 82904BC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82904BC4: 483A4845  bl 0x82ca9408
	ctx.lr = 0x82904BC8;
	sub_82CA93D0(ctx, base);
	// 82904BC8: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 82904BCC: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82904BD0: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82904BD4: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82904BD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82904BDC: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82904BE0: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 82904BE4: 9B9F006C  stb r28, 0x6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[28].u8 ) };
	// 82904BE8: 4B91A671  bl 0x8221f258
	ctx.lr = 0x82904BEC;
	sub_8221F258(ctx, base);
	// 82904BEC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82904BF0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82904BF4: 419A0028  beq cr6, 0x82904c1c
	if ctx.cr[6].eq {
	pc = 0x82904C1C; continue 'dispatch;
	}
	// 82904BF8: 38BF0054  addi r5, r31, 0x54
	ctx.r[5].s64 = ctx.r[31].s64 + 84;
	// 82904BFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82904C00: 4806CFB1  bl 0x82971bb0
	ctx.lr = 0x82904C04;
	sub_82971BB0(ctx, base);
	// 82904C04: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82904C08: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82904C0C: 394B2BF4  addi r10, r11, 0x2bf4
	ctx.r[10].s64 = ctx.r[11].s64 + 11252;
	// 82904C10: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82904C14: 93BE002C  stw r29, 0x2c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(44 as u32), ctx.r[29].u32 ) };
	// 82904C18: 4800000C  b 0x82904c24
	pc = 0x82904C24; continue 'dispatch;
            }
            0x82904C1C => {
    //   block [0x82904C1C..0x82904C24)
	// 82904C1C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82904C20: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	pc = 0x82904C24; continue 'dispatch;
            }
            0x82904C24 => {
    //   block [0x82904C24..0x82904CB8)
	// 82904C24: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82904C28: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82904C2C: 4B8B6E85  bl 0x821bbab0
	ctx.lr = 0x82904C30;
	sub_821BBAB0(ctx, base);
	// 82904C30: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82904C34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82904C38: 4B967231  bl 0x8226be68
	ctx.lr = 0x82904C3C;
	sub_8226BE68(ctx, base);
	// 82904C3C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82904C40: 4B8B2ED9  bl 0x821b7b18
	ctx.lr = 0x82904C44;
	sub_821B7B18(ctx, base);
	// 82904C44: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82904C48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82904C4C: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82904C50: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82904C54: 4E800421  bctrl
	ctx.lr = 0x82904C58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82904C58: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 82904C5C: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 82904C60: 4B91A5F9  bl 0x8221f258
	ctx.lr = 0x82904C64;
	sub_8221F258(ctx, base);
	// 82904C64: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82904C68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82904C6C: 39099490  addi r8, r9, -0x6b70
	ctx.r[8].s64 = ctx.r[9].s64 + -27504;
	// 82904C70: C3C99490  lfs f30, -0x6b70(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82904C74: C3E8FFF4  lfs f31, -0xc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82904C78: 419A0040  beq cr6, 0x82904cb8
	if ctx.cr[6].eq {
	pc = 0x82904CB8; continue 'dispatch;
	}
	// 82904C7C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82904C80: D3E30008  stfs f31, 8(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82904C84: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82904C88: D3E3000C  stfs f31, 0xc(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82904C8C: 392B21E0  addi r9, r11, 0x21e0
	ctx.r[9].s64 = ctx.r[11].s64 + 8672;
	// 82904C90: D3A30010  stfs f29, 0x10(r3)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82904C94: D3C30014  stfs f30, 0x14(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82904C98: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82904C9C: D3C30020  stfs f30, 0x20(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82904CA0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82904CA4: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82904CA8: 9BA3001C  stb r29, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[29].u8 ) };
	// 82904CAC: 9BA3001D  stb r29, 0x1d(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(29 as u32), ctx.r[29].u8 ) };
	// 82904CB0: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82904CB4: 48000008  b 0x82904cbc
	pc = 0x82904CBC; continue 'dispatch;
            }
            0x82904CB8 => {
    //   block [0x82904CB8..0x82904CBC)
	// 82904CB8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	pc = 0x82904CBC; continue 'dispatch;
            }
            0x82904CBC => {
    //   block [0x82904CBC..0x82904D4C)
	// 82904CBC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82904CC0: 4B8B6DF1  bl 0x821bbab0
	ctx.lr = 0x82904CC4;
	sub_821BBAB0(ctx, base);
	// 82904CC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82904CC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82904CCC: 4B96719D  bl 0x8226be68
	ctx.lr = 0x82904CD0;
	sub_8226BE68(ctx, base);
	// 82904CD0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82904CD4: 4B8B2E45  bl 0x821b7b18
	ctx.lr = 0x82904CD8;
	sub_821B7B18(ctx, base);
	// 82904CD8: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 82904CDC: 4B91A57D  bl 0x8221f258
	ctx.lr = 0x82904CE0;
	sub_8221F258(ctx, base);
	// 82904CE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82904CE4: 419A0068  beq cr6, 0x82904d4c
	if ctx.cr[6].eq {
	pc = 0x82904D4C; continue 'dispatch;
	}
	// 82904CE8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82904CEC: D3E30008  stfs f31, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82904CF0: D3C30024  stfs f30, 0x24(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82904CF4: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82904CF8: 394B1DEC  addi r10, r11, 0x1dec
	ctx.r[10].s64 = ctx.r[11].s64 + 7660;
	// 82904CFC: D3C30028  stfs f30, 0x28(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82904D00: D3E3002C  stfs f31, 0x2c(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82904D04: 9B83000C  stb r28, 0xc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[28].u8 ) };
	// 82904D08: D3E30030  stfs f31, 0x30(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82904D0C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82904D10: D3E30034  stfs f31, 0x34(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82904D14: 9BA3000D  stb r29, 0xd(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(13 as u32), ctx.r[29].u8 ) };
	// 82904D18: D3E30038  stfs f31, 0x38(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82904D1C: 9BA3000E  stb r29, 0xe(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(14 as u32), ctx.r[29].u8 ) };
	// 82904D20: D3E3003C  stfs f31, 0x3c(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82904D24: 9BA30020  stb r29, 0x20(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 82904D28: 9BA30040  stb r29, 0x40(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[29].u8 ) };
	// 82904D2C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82904D30: 9BA30041  stb r29, 0x41(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(65 as u32), ctx.r[29].u8 ) };
	// 82904D34: 9BA30042  stb r29, 0x42(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(66 as u32), ctx.r[29].u8 ) };
	// 82904D38: 9BA30043  stb r29, 0x43(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(67 as u32), ctx.r[29].u8 ) };
	// 82904D3C: 93A30048  stw r29, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[29].u32 ) };
	// 82904D40: 93A3004C  stw r29, 0x4c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), ctx.r[29].u32 ) };
	// 82904D44: 9B830054  stb r28, 0x54(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[28].u8 ) };
	// 82904D48: 48000008  b 0x82904d50
	pc = 0x82904D50; continue 'dispatch;
            }
            0x82904D4C => {
    //   block [0x82904D4C..0x82904D50)
	// 82904D4C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	pc = 0x82904D50; continue 'dispatch;
            }
            0x82904D50 => {
    //   block [0x82904D50..0x82904D98)
	// 82904D50: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82904D54: 4B8B6D5D  bl 0x821bbab0
	ctx.lr = 0x82904D58;
	sub_821BBAB0(ctx, base);
	// 82904D58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82904D5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82904D60: 4B967109  bl 0x8226be68
	ctx.lr = 0x82904D64;
	sub_8226BE68(ctx, base);
	// 82904D64: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82904D68: 4B8B2DB1  bl 0x821b7b18
	ctx.lr = 0x82904D6C;
	sub_821B7B18(ctx, base);
	// 82904D6C: 9BBF004F  stb r29, 0x4f(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(79 as u32), ctx.r[29].u8 ) };
	// 82904D70: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82904D74: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82904D78: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 82904D7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82904D80: 419A001C  beq cr6, 0x82904d9c
	if ctx.cr[6].eq {
	pc = 0x82904D9C; continue 'dispatch;
	}
	// 82904D84: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82904D88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82904D8C: 419A000C  beq cr6, 0x82904d98
	if ctx.cr[6].eq {
	pc = 0x82904D98; continue 'dispatch;
	}
	// 82904D90: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82904D94: 4800000C  b 0x82904da0
	pc = 0x82904DA0; continue 'dispatch;
            }
            0x82904D98 => {
    //   block [0x82904D98..0x82904D9C)
	// 82904D98: 4B88F0A1  bl 0x82193e38
	ctx.lr = 0x82904D9C;
	sub_82193E38(ctx, base);
	pc = 0x82904D9C; continue 'dispatch;
            }
            0x82904D9C => {
    //   block [0x82904D9C..0x82904DA0)
	// 82904D9C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82904DA0; continue 'dispatch;
            }
            0x82904DA0 => {
    //   block [0x82904DA0..0x82904DD4)
	// 82904DA0: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82904DA4: 55495FFE  rlwinm r9, r10, 0xb, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x001FFFFFu64;
	// 82904DA8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82904DAC: 419A00D4  beq cr6, 0x82904e80
	if ctx.cr[6].eq {
	pc = 0x82904E80; continue 'dispatch;
	}
	// 82904DB0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82904DB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82904DB8: 419A001C  beq cr6, 0x82904dd4
	if ctx.cr[6].eq {
	pc = 0x82904DD4; continue 'dispatch;
	}
	// 82904DBC: 894A0015  lbz r10, 0x15(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 82904DC0: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82904DC4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82904DC8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82904DCC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82904DD0: 480000AC  b 0x82904e7c
	pc = 0x82904E7C; continue 'dispatch;
            }
            0x82904DD4 => {
    //   block [0x82904DD4..0x82904DF0)
	// 82904DD4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82904DD8: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82904DDC: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82904DE0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82904DE4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82904DE8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82904DEC: 40810054  ble 0x82904e40
	if !ctx.cr[0].gt {
	pc = 0x82904E40; continue 'dispatch;
	}
	pc = 0x82904DF0; continue 'dispatch;
            }
            0x82904DF0 => {
    //   block [0x82904DF0..0x82904E10)
	// 82904DF0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82904DF4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82904DF8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82904DFC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82904E00: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 82904E04: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82904E08: 41980008  blt cr6, 0x82904e10
	if ctx.cr[6].lt {
	pc = 0x82904E10; continue 'dispatch;
	}
	// 82904E0C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x82904E10; continue 'dispatch;
            }
            0x82904E10 => {
    //   block [0x82904E10..0x82904E2C)
	// 82904E10: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82904E14: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82904E18: 419A0014  beq cr6, 0x82904e2c
	if ctx.cr[6].eq {
	pc = 0x82904E2C; continue 'dispatch;
	}
	// 82904E1C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82904E20: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82904E24: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82904E28: 4800000C  b 0x82904e34
	pc = 0x82904E34; continue 'dispatch;
            }
            0x82904E2C => {
    //   block [0x82904E2C..0x82904E34)
	// 82904E2C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82904E30: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82904E34; continue 'dispatch;
            }
            0x82904E34 => {
    //   block [0x82904E34..0x82904E40)
	// 82904E34: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82904E38: 4199FFB8  bgt cr6, 0x82904df0
	if ctx.cr[6].gt {
	pc = 0x82904DF0; continue 'dispatch;
	}
	// 82904E3C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82904E40; continue 'dispatch;
            }
            0x82904E40 => {
    //   block [0x82904E40..0x82904E58)
	// 82904E40: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82904E44: 419A0030  beq cr6, 0x82904e74
	if ctx.cr[6].eq {
	pc = 0x82904E74; continue 'dispatch;
	}
	// 82904E48: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82904E4C: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 82904E50: 40990008  ble cr6, 0x82904e58
	if !ctx.cr[6].gt {
	pc = 0x82904E58; continue 'dispatch;
	}
	// 82904E54: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	pc = 0x82904E58; continue 'dispatch;
            }
            0x82904E58 => {
    //   block [0x82904E58..0x82904E74)
	// 82904E58: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82904E5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82904E60: 409A0014  bne cr6, 0x82904e74
	if !ctx.cr[6].eq {
	pc = 0x82904E74; continue 'dispatch;
	}
	// 82904E64: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82904E68: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82904E6C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82904E70: 48000008  b 0x82904e78
	pc = 0x82904E78; continue 'dispatch;
            }
            0x82904E74 => {
    //   block [0x82904E74..0x82904E78)
	// 82904E74: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x82904E78; continue 'dispatch;
            }
            0x82904E78 => {
    //   block [0x82904E78..0x82904E7C)
	// 82904E78: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82904E7C; continue 'dispatch;
            }
            0x82904E7C => {
    //   block [0x82904E7C..0x82904E80)
	// 82904E7C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	pc = 0x82904E80; continue 'dispatch;
            }
            0x82904E80 => {
    //   block [0x82904E80..0x82904E9C)
	// 82904E80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82904E84: 4BB1BF0D  bl 0x82420d90
	ctx.lr = 0x82904E88;
	sub_82420D90(ctx, base);
	// 82904E88: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82904E8C: CBA1FFC0  lfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82904E90: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82904E94: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82904E98: 483A45C0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82904EA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82904EA0 size=504
    let mut pc: u32 = 0x82904EA0;
    'dispatch: loop {
        match pc {
            0x82904EA0 => {
    //   block [0x82904EA0..0x82905098)
	// 82904EA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82904EA4: 483A4569  bl 0x82ca940c
	ctx.lr = 0x82904EA8;
	sub_82CA93D0(ctx, base);
	// 82904EA8: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82905098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82905098 size=16
    let mut pc: u32 = 0x82905098;
    'dispatch: loop {
        match pc {
            0x82905098 => {
    //   block [0x82905098..0x829050A8)
	// 82905098: 8963006C  lbz r11, 0x6c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) } as u64;
	// 8290509C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829050A0: 419A0008  beq cr6, 0x829050a8
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x829050A8);
		return;
	}
	// 829050A4: 4B8CD774  b 0x821d2818
	sub_821D2818(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829050B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829050B0 size=88
    let mut pc: u32 = 0x829050B0;
    'dispatch: loop {
        match pc {
            0x829050B0 => {
    //   block [0x829050B0..0x82905108)
	// 829050B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829050B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829050B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829050BC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 829050C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829050C4: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 829050C8: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829050CC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829050D0: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 829050D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829050D8: 4BF46759  bl 0x8284b830
	ctx.lr = 0x829050DC;
	sub_8284B830(ctx, base);
	// 829050DC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 829050E0: D3FF0078  stfs f31, 0x78(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 829050E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829050E8: 394B5250  addi r10, r11, 0x5250
	ctx.r[10].s64 = ctx.r[11].s64 + 21072;
	// 829050EC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829050F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829050F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829050F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829050FC: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82905100: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82905104: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82905108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82905108 size=1464
    let mut pc: u32 = 0x82905108;
    'dispatch: loop {
        match pc {
            0x82905108 => {
    //   block [0x82905108..0x82905148)
	// 82905108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290510C: 483A42FD  bl 0x82ca9408
	ctx.lr = 0x82905110;
	sub_82CA93D0(ctx, base);
	// 82905110: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82905114: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82905118: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8290511C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82905120: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 82905124: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 82905128: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290512C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82905130: 419A0020  beq cr6, 0x82905150
	if ctx.cr[6].eq {
	pc = 0x82905150; continue 'dispatch;
	}
	// 82905134: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82905138: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290513C: 419A000C  beq cr6, 0x82905148
	if ctx.cr[6].eq {
	pc = 0x82905148; continue 'dispatch;
	}
	// 82905140: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82905144: 48000010  b 0x82905154
	pc = 0x82905154; continue 'dispatch;
            }
            0x82905148 => {
    //   block [0x82905148..0x82905150)
	// 82905148: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8290514C: 4B88ECED  bl 0x82193e38
	ctx.lr = 0x82905150;
	sub_82193E38(ctx, base);
	pc = 0x82905150; continue 'dispatch;
            }
            0x82905150 => {
    //   block [0x82905150..0x82905154)
	// 82905150: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82905154; continue 'dispatch;
            }
            0x82905154 => {
    //   block [0x82905154..0x82905190)
	// 82905154: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82905158: 55495FFE  rlwinm r9, r10, 0xb, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x001FFFFFu64;
	// 8290515C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82905160: 419A00F4  beq cr6, 0x82905254
	if ctx.cr[6].eq {
	pc = 0x82905254; continue 'dispatch;
	}
	// 82905164: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82905168: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290516C: 419A0024  beq cr6, 0x82905190
	if ctx.cr[6].eq {
	pc = 0x82905190; continue 'dispatch;
	}
	// 82905170: 894A0015  lbz r10, 0x15(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 82905174: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82905178: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8290517C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82905180: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82905184: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82905188: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290518C: 480000CC  b 0x82905258
	pc = 0x82905258; continue 'dispatch;
            }
            0x82905190 => {
    //   block [0x82905190..0x829051AC)
	// 82905190: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82905194: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82905198: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 8290519C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829051A0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829051A4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829051A8: 40810054  ble 0x829051fc
	if !ctx.cr[0].gt {
	pc = 0x829051FC; continue 'dispatch;
	}
	pc = 0x829051AC; continue 'dispatch;
            }
            0x829051AC => {
    //   block [0x829051AC..0x829051CC)
	// 829051AC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829051B0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829051B4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829051B8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829051BC: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 829051C0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829051C4: 41980008  blt cr6, 0x829051cc
	if ctx.cr[6].lt {
	pc = 0x829051CC; continue 'dispatch;
	}
	// 829051C8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x829051CC; continue 'dispatch;
            }
            0x829051CC => {
    //   block [0x829051CC..0x829051E8)
	// 829051CC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829051D0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829051D4: 419A0014  beq cr6, 0x829051e8
	if ctx.cr[6].eq {
	pc = 0x829051E8; continue 'dispatch;
	}
	// 829051D8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829051DC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829051E0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829051E4: 4800000C  b 0x829051f0
	pc = 0x829051F0; continue 'dispatch;
            }
            0x829051E8 => {
    //   block [0x829051E8..0x829051F0)
	// 829051E8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829051EC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829051F0; continue 'dispatch;
            }
            0x829051F0 => {
    //   block [0x829051F0..0x829051FC)
	// 829051F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829051F4: 4199FFB8  bgt cr6, 0x829051ac
	if ctx.cr[6].gt {
	pc = 0x829051AC; continue 'dispatch;
	}
	// 829051F8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x829051FC; continue 'dispatch;
            }
            0x829051FC => {
    //   block [0x829051FC..0x82905218)
	// 829051FC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82905200: 419A0040  beq cr6, 0x82905240
	if ctx.cr[6].eq {
	pc = 0x82905240; continue 'dispatch;
	}
	// 82905204: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82905208: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 8290520C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82905210: 41990008  bgt cr6, 0x82905218
	if ctx.cr[6].gt {
	pc = 0x82905218; continue 'dispatch;
	}
	// 82905214: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82905218; continue 'dispatch;
            }
            0x82905218 => {
    //   block [0x82905218..0x82905240)
	// 82905218: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290521C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82905220: 409A0020  bne cr6, 0x82905240
	if !ctx.cr[6].eq {
	pc = 0x82905240; continue 'dispatch;
	}
	// 82905224: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82905228: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8290522C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82905230: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82905234: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82905238: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290523C: 4800001C  b 0x82905258
	pc = 0x82905258; continue 'dispatch;
            }
            0x82905240 => {
    //   block [0x82905240..0x82905254)
	// 82905240: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82905244: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82905248: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8290524C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82905250: 48000008  b 0x82905258
	pc = 0x82905258; continue 'dispatch;
            }
            0x82905254 => {
    //   block [0x82905254..0x82905258)
	// 82905254: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82905258; continue 'dispatch;
            }
            0x82905258 => {
    //   block [0x82905258..0x82905288)
	// 82905258: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290525C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82905260: 419A0028  beq cr6, 0x82905288
	if ctx.cr[6].eq {
	pc = 0x82905288; continue 'dispatch;
	}
	// 82905264: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 82905268: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290526C: 4B8FA35D  bl 0x821ff5c8
	ctx.lr = 0x82905270;
	sub_821FF5C8(ctx, base);
	// 82905270: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82905274: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82905278: 409A0010  bne cr6, 0x82905288
	if !ctx.cr[6].eq {
	pc = 0x82905288; continue 'dispatch;
	}
	// 8290527C: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 82905280: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82905284: 4BB1A725  bl 0x8241f9a8
	ctx.lr = 0x82905288;
	sub_8241F9A8(ctx, base);
	pc = 0x82905288; continue 'dispatch;
            }
            0x82905288 => {
    //   block [0x82905288..0x829052AC)
	// 82905288: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290528C: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 82905290: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82905294: 419A0020  beq cr6, 0x829052b4
	if ctx.cr[6].eq {
	pc = 0x829052B4; continue 'dispatch;
	}
	// 82905298: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290529C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829052A0: 419A000C  beq cr6, 0x829052ac
	if ctx.cr[6].eq {
	pc = 0x829052AC; continue 'dispatch;
	}
	// 829052A4: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829052A8: 48000010  b 0x829052b8
	pc = 0x829052B8; continue 'dispatch;
            }
            0x829052AC => {
    //   block [0x829052AC..0x829052B4)
	// 829052AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829052B0: 4B88EB89  bl 0x82193e38
	ctx.lr = 0x829052B4;
	sub_82193E38(ctx, base);
	pc = 0x829052B4; continue 'dispatch;
            }
            0x829052B4 => {
    //   block [0x829052B4..0x829052B8)
	// 829052B4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829052B8; continue 'dispatch;
            }
            0x829052B8 => {
    //   block [0x829052B8..0x829052F4)
	// 829052B8: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 829052BC: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 829052C0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829052C4: 419A00F4  beq cr6, 0x829053b8
	if ctx.cr[6].eq {
	pc = 0x829053B8; continue 'dispatch;
	}
	// 829052C8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 829052CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829052D0: 419A0024  beq cr6, 0x829052f4
	if ctx.cr[6].eq {
	pc = 0x829052F4; continue 'dispatch;
	}
	// 829052D4: 894A00E1  lbz r10, 0xe1(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(225 as u32) ) } as u64;
	// 829052D8: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 829052DC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 829052E0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829052E4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829052E8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829052EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829052F0: 480000CC  b 0x829053bc
	pc = 0x829053BC; continue 'dispatch;
            }
            0x829052F4 => {
    //   block [0x829052F4..0x82905310)
	// 829052F4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 829052F8: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829052FC: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82905300: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82905304: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82905308: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290530C: 40810054  ble 0x82905360
	if !ctx.cr[0].gt {
	pc = 0x82905360; continue 'dispatch;
	}
	pc = 0x82905310; continue 'dispatch;
            }
            0x82905310 => {
    //   block [0x82905310..0x82905330)
	// 82905310: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82905314: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82905318: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8290531C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82905320: 2F0700E1  cmpwi cr6, r7, 0xe1
	ctx.cr[6].compare_i32(ctx.r[7].s32, 225, &mut ctx.xer);
	// 82905324: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82905328: 41980008  blt cr6, 0x82905330
	if ctx.cr[6].lt {
	pc = 0x82905330; continue 'dispatch;
	}
	// 8290532C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x82905330; continue 'dispatch;
            }
            0x82905330 => {
    //   block [0x82905330..0x8290534C)
	// 82905330: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82905334: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82905338: 419A0014  beq cr6, 0x8290534c
	if ctx.cr[6].eq {
	pc = 0x8290534C; continue 'dispatch;
	}
	// 8290533C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82905340: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82905344: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82905348: 4800000C  b 0x82905354
	pc = 0x82905354; continue 'dispatch;
            }
            0x8290534C => {
    //   block [0x8290534C..0x82905354)
	// 8290534C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82905350: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82905354; continue 'dispatch;
            }
            0x82905354 => {
    //   block [0x82905354..0x82905360)
	// 82905354: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82905358: 4199FFB8  bgt cr6, 0x82905310
	if ctx.cr[6].gt {
	pc = 0x82905310; continue 'dispatch;
	}
	// 8290535C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82905360; continue 'dispatch;
            }
            0x82905360 => {
    //   block [0x82905360..0x8290537C)
	// 82905360: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82905364: 419A0040  beq cr6, 0x829053a4
	if ctx.cr[6].eq {
	pc = 0x829053A4; continue 'dispatch;
	}
	// 82905368: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290536C: 2F0B00E1  cmpwi cr6, r11, 0xe1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 225, &mut ctx.xer);
	// 82905370: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82905374: 41990008  bgt cr6, 0x8290537c
	if ctx.cr[6].gt {
	pc = 0x8290537C; continue 'dispatch;
	}
	// 82905378: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x8290537C; continue 'dispatch;
            }
            0x8290537C => {
    //   block [0x8290537C..0x829053A4)
	// 8290537C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82905380: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82905384: 409A0020  bne cr6, 0x829053a4
	if !ctx.cr[6].eq {
	pc = 0x829053A4; continue 'dispatch;
	}
	// 82905388: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8290538C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82905390: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82905394: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82905398: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8290539C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829053A0: 4800001C  b 0x829053bc
	pc = 0x829053BC; continue 'dispatch;
            }
            0x829053A4 => {
    //   block [0x829053A4..0x829053B8)
	// 829053A4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829053A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829053AC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829053B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829053B4: 48000008  b 0x829053bc
	pc = 0x829053BC; continue 'dispatch;
            }
            0x829053B8 => {
    //   block [0x829053B8..0x829053BC)
	// 829053B8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829053BC; continue 'dispatch;
            }
            0x829053BC => {
    //   block [0x829053BC..0x829053CC)
	// 829053BC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829053C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829053C4: 419A0008  beq cr6, 0x829053cc
	if ctx.cr[6].eq {
	pc = 0x829053CC; continue 'dispatch;
	}
	// 829053C8: 9BBF000C  stb r29, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	pc = 0x829053CC; continue 'dispatch;
            }
            0x829053CC => {
    //   block [0x829053CC..0x829053EC)
	// 829053CC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829053D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829053D4: 419A0020  beq cr6, 0x829053f4
	if ctx.cr[6].eq {
	pc = 0x829053F4; continue 'dispatch;
	}
	// 829053D8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829053DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829053E0: 419A000C  beq cr6, 0x829053ec
	if ctx.cr[6].eq {
	pc = 0x829053EC; continue 'dispatch;
	}
	// 829053E4: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829053E8: 48000010  b 0x829053f8
	pc = 0x829053F8; continue 'dispatch;
            }
            0x829053EC => {
    //   block [0x829053EC..0x829053F4)
	// 829053EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829053F0: 4B88EA49  bl 0x82193e38
	ctx.lr = 0x829053F4;
	sub_82193E38(ctx, base);
	pc = 0x829053F4; continue 'dispatch;
            }
            0x829053F4 => {
    //   block [0x829053F4..0x829053F8)
	// 829053F4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829053F8; continue 'dispatch;
            }
            0x829053F8 => {
    //   block [0x829053F8..0x8290546C)
	// 829053F8: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 829053FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82905400: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82905404: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82905408: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8290540C: 4E800421  bctrl
	ctx.lr = 0x82905410;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82905410: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82905414: 4B965B2D  bl 0x8226af40
	ctx.lr = 0x82905418;
	sub_8226AF40(ctx, base);
	// 82905418: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8290541C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82905420: 419A0148  beq cr6, 0x82905568
	if ctx.cr[6].eq {
	pc = 0x82905568; continue 'dispatch;
	}
	// 82905424: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82905428: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 8290542C: 4B86F03D  bl 0x82174468
	ctx.lr = 0x82905430;
	sub_82174468(ctx, base);
	// 82905430: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82905434: 556A1FFE  rlwinm r10, r11, 3, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 82905438: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290543C: 419A00F0  beq cr6, 0x8290552c
	if ctx.cr[6].eq {
	pc = 0x8290552C; continue 'dispatch;
	}
	// 82905440: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 82905444: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 82905448: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290544C: 419A0020  beq cr6, 0x8290546c
	if ctx.cr[6].eq {
	pc = 0x8290546C; continue 'dispatch;
	}
	// 82905450: 896B001D  lbz r11, 0x1d(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 82905454: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 82905458: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8290545C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82905460: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82905464: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82905468: 480000C8  b 0x82905530
	pc = 0x82905530; continue 'dispatch;
            }
            0x8290546C => {
    //   block [0x8290546C..0x82905484)
	// 8290546C: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 82905470: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82905474: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82905478: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8290547C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82905480: 40810054  ble 0x829054d4
	if !ctx.cr[0].gt {
	pc = 0x829054D4; continue 'dispatch;
	}
	pc = 0x82905484; continue 'dispatch;
            }
            0x82905484 => {
    //   block [0x82905484..0x829054A4)
	// 82905484: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82905488: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8290548C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82905490: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82905494: 2F07001D  cmpwi cr6, r7, 0x1d
	ctx.cr[6].compare_i32(ctx.r[7].s32, 29, &mut ctx.xer);
	// 82905498: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8290549C: 41980008  blt cr6, 0x829054a4
	if ctx.cr[6].lt {
	pc = 0x829054A4; continue 'dispatch;
	}
	// 829054A0: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x829054A4; continue 'dispatch;
            }
            0x829054A4 => {
    //   block [0x829054A4..0x829054C0)
	// 829054A4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829054A8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829054AC: 419A0014  beq cr6, 0x829054c0
	if ctx.cr[6].eq {
	pc = 0x829054C0; continue 'dispatch;
	}
	// 829054B0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829054B4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829054B8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829054BC: 4800000C  b 0x829054c8
	pc = 0x829054C8; continue 'dispatch;
            }
            0x829054C0 => {
    //   block [0x829054C0..0x829054C8)
	// 829054C0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829054C4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829054C8; continue 'dispatch;
            }
            0x829054C8 => {
    //   block [0x829054C8..0x829054D4)
	// 829054C8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829054CC: 4199FFB8  bgt cr6, 0x82905484
	if ctx.cr[6].gt {
	pc = 0x82905484; continue 'dispatch;
	}
	// 829054D0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x829054D4; continue 'dispatch;
            }
            0x829054D4 => {
    //   block [0x829054D4..0x829054F0)
	// 829054D4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829054D8: 419A0040  beq cr6, 0x82905518
	if ctx.cr[6].eq {
	pc = 0x82905518; continue 'dispatch;
	}
	// 829054DC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829054E0: 2F0B001D  cmpwi cr6, r11, 0x1d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 29, &mut ctx.xer);
	// 829054E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829054E8: 41990008  bgt cr6, 0x829054f0
	if ctx.cr[6].gt {
	pc = 0x829054F0; continue 'dispatch;
	}
	// 829054EC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829054F0; continue 'dispatch;
            }
            0x829054F0 => {
    //   block [0x829054F0..0x82905518)
	// 829054F0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829054F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829054F8: 409A0020  bne cr6, 0x82905518
	if !ctx.cr[6].eq {
	pc = 0x82905518; continue 'dispatch;
	}
	// 829054FC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82905500: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82905504: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82905508: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290550C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82905510: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82905514: 4800001C  b 0x82905530
	pc = 0x82905530; continue 'dispatch;
            }
            0x82905518 => {
    //   block [0x82905518..0x8290552C)
	// 82905518: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8290551C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82905520: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82905524: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82905528: 48000008  b 0x82905530
	pc = 0x82905530; continue 'dispatch;
            }
            0x8290552C => {
    //   block [0x8290552C..0x82905530)
	// 8290552C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82905530; continue 'dispatch;
            }
            0x82905530 => {
    //   block [0x82905530..0x82905568)
	// 82905530: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82905534: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82905538: 419A0030  beq cr6, 0x82905568
	if ctx.cr[6].eq {
	pc = 0x82905568; continue 'dispatch;
	}
	// 8290553C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82905540: 895F0031  lbz r10, 0x31(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(49 as u32) ) } as u64;
	// 82905544: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82905548: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	pc = 0x82905568; continue 'dispatch;
            }
            0x82905568 => {
    //   block [0x82905568..0x829056C0)
	// 82905568: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8290556C: C01C0078  lfs f0, 0x78(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82905570: C3EB9484  lfs f31, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82905574: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82905578: 40990134  ble cr6, 0x829056ac
	if !ctx.cr[6].gt {
	pc = 0x829056AC; continue 'dispatch;
	}
	// 8290557C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82905580: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 82905584: 4B86EEE5  bl 0x82174468
	ctx.lr = 0x82905588;
	sub_82174468(ctx, base);
	// 82905588: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 8290558C: 556A1FFE  rlwinm r10, r11, 3, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 82905590: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82905594: 419A00E4  beq cr6, 0x82905678
	if ctx.cr[6].eq {
	pc = 0x82905678; continue 'dispatch;
	}
	// 82905598: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 8290559C: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829055A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829055A4: 419A001C  beq cr6, 0x829055c0
	if ctx.cr[6].eq {
	pc = 0x829055C0; continue 'dispatch;
	}
	// 829055A8: 896B001D  lbz r11, 0x1d(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 829055AC: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 829055B0: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829055B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829055B8: 83EA0004  lwz r31, 4(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829055BC: 480000C0  b 0x8290567c
	pc = 0x8290567C; continue 'dispatch;
	// 829055C0: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 829055C4: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 829055C8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829055CC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829055D0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829055D4: 40810054  ble 0x82905628
	if !ctx.cr[0].gt {
	pc = 0x82905628; continue 'dispatch;
	}
	// 829055D8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829055DC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829055E0: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 829055E4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829055E8: 2F07001D  cmpwi cr6, r7, 0x1d
	ctx.cr[6].compare_i32(ctx.r[7].s32, 29, &mut ctx.xer);
	// 829055EC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829055F0: 41980008  blt cr6, 0x829055f8
	if ctx.cr[6].lt {
	pc = 0x829055F8; continue 'dispatch;
	}
	// 829055F4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 829055F8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829055FC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82905600: 419A0014  beq cr6, 0x82905614
	if ctx.cr[6].eq {
	pc = 0x82905614; continue 'dispatch;
	}
	// 82905604: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82905608: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8290560C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82905610: 4800000C  b 0x8290561c
	pc = 0x8290561C; continue 'dispatch;
	// 82905614: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82905618: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 8290561C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82905620: 4199FFB8  bgt cr6, 0x829055d8
	if ctx.cr[6].gt {
	pc = 0x829055D8; continue 'dispatch;
	}
	// 82905624: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82905628: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8290562C: 419A003C  beq cr6, 0x82905668
	if ctx.cr[6].eq {
	pc = 0x82905668; continue 'dispatch;
	}
	// 82905630: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82905634: 2F0B001D  cmpwi cr6, r11, 0x1d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 29, &mut ctx.xer);
	// 82905638: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290563C: 41990008  bgt cr6, 0x82905644
	if ctx.cr[6].gt {
	pc = 0x82905644; continue 'dispatch;
	}
	// 82905640: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82905644: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82905648: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290564C: 409A001C  bne cr6, 0x82905668
	if !ctx.cr[6].eq {
	pc = 0x82905668; continue 'dispatch;
	}
	// 82905650: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82905654: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82905658: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8290565C: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82905660: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82905664: 48000018  b 0x8290567c
	pc = 0x8290567C; continue 'dispatch;
	// 82905668: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8290566C: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82905670: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82905674: 48000008  b 0x8290567c
	pc = 0x8290567C; continue 'dispatch;
	// 82905678: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 8290567C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82905680: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82905684: 419A0024  beq cr6, 0x829056a8
	if ctx.cr[6].eq {
	pc = 0x829056A8; continue 'dispatch;
	}
	// 82905688: C01C0078  lfs f0, 0x78(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8290568C: 93BF002C  stw r29, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[29].u32 ) };
	// 82905690: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82905694: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82905698: 4B8DE0A1  bl 0x821e3738
	ctx.lr = 0x8290569C;
	sub_821E3738(ctx, base);
	// 8290569C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829056A0: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 829056A4: 483A3DB4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 829056A8: D3FC0078  stfs f31, 0x78(r28)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 829056AC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829056B0: 4B8DE089  bl 0x821e3738
	ctx.lr = 0x829056B4;
	sub_821E3738(ctx, base);
	// 829056B4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829056B8: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 829056BC: 483A3D9C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829056C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829056C0 size=356
    let mut pc: u32 = 0x829056C0;
    'dispatch: loop {
        match pc {
            0x829056C0 => {
    //   block [0x829056C0..0x82905734)
	// 829056C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829056C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829056C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829056CC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829056D0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829056D4: C1A30078  lfs f13, 0x78(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829056D8: C00B9484  lfs f0, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829056DC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 829056E0: 40990130  ble cr6, 0x82905810
	if !ctx.cr[6].gt {
	pc = 0x82905810; continue 'dispatch;
	}
	// 829056E4: 8963004B  lbz r11, 0x4b(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(75 as u32) ) } as u64;
	// 829056E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829056EC: 419A0124  beq cr6, 0x82905810
	if ctx.cr[6].eq {
	pc = 0x82905810; continue 'dispatch;
	}
	// 829056F0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829056F4: 4B86ED75  bl 0x82174468
	ctx.lr = 0x829056F8;
	sub_82174468(ctx, base);
	// 829056F8: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 829056FC: 556A1FFE  rlwinm r10, r11, 3, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 82905700: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82905704: 419A00F4  beq cr6, 0x829057f8
	if ctx.cr[6].eq {
	pc = 0x829057F8; continue 'dispatch;
	}
	// 82905708: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 8290570C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82905710: 419A0024  beq cr6, 0x82905734
	if ctx.cr[6].eq {
	pc = 0x82905734; continue 'dispatch;
	}
	// 82905714: 894B001D  lbz r10, 0x1d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 82905718: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 8290571C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82905720: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82905724: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82905728: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8290572C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82905730: 480000CC  b 0x829057fc
	pc = 0x829057FC; continue 'dispatch;
            }
            0x82905734 => {
    //   block [0x82905734..0x82905750)
	// 82905734: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 82905738: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 8290573C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82905740: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82905744: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82905748: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290574C: 40810054  ble 0x829057a0
	if !ctx.cr[0].gt {
	pc = 0x829057A0; continue 'dispatch;
	}
	pc = 0x82905750; continue 'dispatch;
            }
            0x82905750 => {
    //   block [0x82905750..0x82905770)
	// 82905750: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82905754: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82905758: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8290575C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82905760: 2F07001D  cmpwi cr6, r7, 0x1d
	ctx.cr[6].compare_i32(ctx.r[7].s32, 29, &mut ctx.xer);
	// 82905764: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82905768: 41980008  blt cr6, 0x82905770
	if ctx.cr[6].lt {
	pc = 0x82905770; continue 'dispatch;
	}
	// 8290576C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x82905770; continue 'dispatch;
            }
            0x82905770 => {
    //   block [0x82905770..0x8290578C)
	// 82905770: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82905774: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82905778: 419A0014  beq cr6, 0x8290578c
	if ctx.cr[6].eq {
	pc = 0x8290578C; continue 'dispatch;
	}
	// 8290577C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82905780: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82905784: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82905788: 4800000C  b 0x82905794
	pc = 0x82905794; continue 'dispatch;
            }
            0x8290578C => {
    //   block [0x8290578C..0x82905794)
	// 8290578C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82905790: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82905794; continue 'dispatch;
            }
            0x82905794 => {
    //   block [0x82905794..0x829057A0)
	// 82905794: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82905798: 4199FFB8  bgt cr6, 0x82905750
	if ctx.cr[6].gt {
	pc = 0x82905750; continue 'dispatch;
	}
	// 8290579C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x829057A0; continue 'dispatch;
            }
            0x829057A0 => {
    //   block [0x829057A0..0x829057BC)
	// 829057A0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829057A4: 419A0040  beq cr6, 0x829057e4
	if ctx.cr[6].eq {
	pc = 0x829057E4; continue 'dispatch;
	}
	// 829057A8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829057AC: 2F0B001D  cmpwi cr6, r11, 0x1d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 29, &mut ctx.xer);
	// 829057B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829057B4: 41990008  bgt cr6, 0x829057bc
	if ctx.cr[6].gt {
	pc = 0x829057BC; continue 'dispatch;
	}
	// 829057B8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x829057BC; continue 'dispatch;
            }
            0x829057BC => {
    //   block [0x829057BC..0x829057E4)
	// 829057BC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829057C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829057C4: 409A0020  bne cr6, 0x829057e4
	if !ctx.cr[6].eq {
	pc = 0x829057E4; continue 'dispatch;
	}
	// 829057C8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829057CC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829057D0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829057D4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829057D8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829057DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829057E0: 4800001C  b 0x829057fc
	pc = 0x829057FC; continue 'dispatch;
            }
            0x829057E4 => {
    //   block [0x829057E4..0x829057F8)
	// 829057E4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829057E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829057EC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829057F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829057F4: 48000008  b 0x829057fc
	pc = 0x829057FC; continue 'dispatch;
            }
            0x829057F8 => {
    //   block [0x829057F8..0x829057FC)
	// 829057F8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x829057FC; continue 'dispatch;
            }
            0x829057FC => {
    //   block [0x829057FC..0x82905810)
	// 829057FC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82905800: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82905804: 419A000C  beq cr6, 0x82905810
	if ctx.cr[6].eq {
	pc = 0x82905810; continue 'dispatch;
	}
	// 82905808: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 8290580C: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	pc = 0x82905810; continue 'dispatch;
            }
            0x82905810 => {
    //   block [0x82905810..0x82905824)
	// 82905810: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82905814: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82905818: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290581C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82905820: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82905828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82905828 size=160
    let mut pc: u32 = 0x82905828;
    'dispatch: loop {
        match pc {
            0x82905828 => {
    //   block [0x82905828..0x829058C8)
	// 82905828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290582C: 483A3BE1  bl 0x82ca940c
	ctx.lr = 0x82905830;
	sub_82CA93D0(ctx, base);
	// 82905830: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829058C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829058C8 size=1160
    let mut pc: u32 = 0x829058C8;
    'dispatch: loop {
        match pc {
            0x829058C8 => {
    //   block [0x829058C8..0x82905D50)
	// 829058C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829058CC: 483A3B39  bl 0x82ca9404
	ctx.lr = 0x829058D0;
	sub_82CA93D0(ctx, base);
	// 829058D0: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82905D50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82905D50 size=808
    let mut pc: u32 = 0x82905D50;
    'dispatch: loop {
        match pc {
            0x82905D50 => {
    //   block [0x82905D50..0x82905DA4)
	// 82905D50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82905D54: 483A36B9  bl 0x82ca940c
	ctx.lr = 0x82905D58;
	sub_82CA93D0(ctx, base);
	// 82905D58: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82905D5C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82905D60: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82905D64: 387D006C  addi r3, r29, 0x6c
	ctx.r[3].s64 = ctx.r[29].s64 + 108;
	// 82905D68: 817D0070  lwz r11, 0x70(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(112 as u32) ) } as u64;
	// 82905D6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82905D70: 419A0034  beq cr6, 0x82905da4
	if ctx.cr[6].eq {
	pc = 0x82905DA4; continue 'dispatch;
	}
	// 82905D74: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82905D78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82905D7C: 419A0078  beq cr6, 0x82905df4
	if ctx.cr[6].eq {
	pc = 0x82905DF4; continue 'dispatch;
	}
	// 82905D80: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82905D84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82905D88: 419A001C  beq cr6, 0x82905da4
	if ctx.cr[6].eq {
	pc = 0x82905DA4; continue 'dispatch;
	}
	// 82905D8C: 4B86E0AD  bl 0x82173e38
	ctx.lr = 0x82905D90;
	sub_82173E38(ctx, base);
	// 82905D90: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 82905D94: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82905D98: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82905D9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82905DA0: 409A0008  bne cr6, 0x82905da8
	if !ctx.cr[6].eq {
	pc = 0x82905DA8; continue 'dispatch;
	}
	pc = 0x82905DA4; continue 'dispatch;
            }
            0x82905DA4 => {
    //   block [0x82905DA4..0x82905DA8)
	// 82905DA4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82905DA8; continue 'dispatch;
            }
            0x82905DA8 => {
    //   block [0x82905DA8..0x82905DCC)
	// 82905DA8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82905DAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82905DB0: 419A001C  beq cr6, 0x82905dcc
	if ctx.cr[6].eq {
	pc = 0x82905DCC; continue 'dispatch;
	}
	// 82905DB4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82905DB8: 3BDD0090  addi r30, r29, 0x90
	ctx.r[30].s64 = ctx.r[29].s64 + 144;
	// 82905DBC: 4B86E6AD  bl 0x82174468
	ctx.lr = 0x82905DC0;
	sub_82174468(ctx, base);
	// 82905DC0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82905DC4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82905DC8: 4BB043A1  bl 0x8240a168
	ctx.lr = 0x82905DCC;
	sub_8240A168(ctx, base);
	pc = 0x82905DCC; continue 'dispatch;
            }
            0x82905DCC => {
    //   block [0x82905DCC..0x82905DF4)
	// 82905DCC: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82905DD0: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 82905DD4: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82905DD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82905DDC: 419A0024  beq cr6, 0x82905e00
	if ctx.cr[6].eq {
	pc = 0x82905E00; continue 'dispatch;
	}
	// 82905DE0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82905DE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82905DE8: 419A0014  beq cr6, 0x82905dfc
	if ctx.cr[6].eq {
	pc = 0x82905DFC; continue 'dispatch;
	}
	// 82905DEC: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82905DF0: 48000014  b 0x82905e04
	pc = 0x82905E04; continue 'dispatch;
            }
            0x82905DF4 => {
    //   block [0x82905DF4..0x82905DFC)
	// 82905DF4: 4B88E045  bl 0x82193e38
	ctx.lr = 0x82905DF8;
	sub_82193E38(ctx, base);
	// 82905DF8: 4BFFFFAC  b 0x82905da4
	pc = 0x82905DA4; continue 'dispatch;
            }
            0x82905DFC => {
    //   block [0x82905DFC..0x82905E00)
	// 82905DFC: 4B88E03D  bl 0x82193e38
	ctx.lr = 0x82905E00;
	sub_82193E38(ctx, base);
	pc = 0x82905E00; continue 'dispatch;
            }
            0x82905E00 => {
    //   block [0x82905E00..0x82905E04)
	// 82905E00: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82905E04; continue 'dispatch;
            }
            0x82905E04 => {
    //   block [0x82905E04..0x82905E40)
	// 82905E04: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82905E08: 55491FFE  rlwinm r9, r10, 3, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 82905E0C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82905E10: 419A00F4  beq cr6, 0x82905f04
	if ctx.cr[6].eq {
	pc = 0x82905F04; continue 'dispatch;
	}
	// 82905E14: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82905E18: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82905E1C: 419A0024  beq cr6, 0x82905e40
	if ctx.cr[6].eq {
	pc = 0x82905E40; continue 'dispatch;
	}
	// 82905E20: 894A001D  lbz r10, 0x1d(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(29 as u32) ) } as u64;
	// 82905E24: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82905E28: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82905E2C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82905E30: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82905E34: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82905E38: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82905E3C: 480000CC  b 0x82905f08
	pc = 0x82905F08; continue 'dispatch;
            }
            0x82905E40 => {
    //   block [0x82905E40..0x82905E5C)
	// 82905E40: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82905E44: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82905E48: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 82905E4C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82905E50: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 82905E54: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82905E58: 40810054  ble 0x82905eac
	if !ctx.cr[0].gt {
	pc = 0x82905EAC; continue 'dispatch;
	}
	pc = 0x82905E5C; continue 'dispatch;
            }
            0x82905E5C => {
    //   block [0x82905E5C..0x82905E7C)
	// 82905E5C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82905E60: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82905E64: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82905E68: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82905E6C: 2F07001D  cmpwi cr6, r7, 0x1d
	ctx.cr[6].compare_i32(ctx.r[7].s32, 29, &mut ctx.xer);
	// 82905E70: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82905E74: 41980008  blt cr6, 0x82905e7c
	if ctx.cr[6].lt {
	pc = 0x82905E7C; continue 'dispatch;
	}
	// 82905E78: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x82905E7C; continue 'dispatch;
            }
            0x82905E7C => {
    //   block [0x82905E7C..0x82905E98)
	// 82905E7C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82905E80: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82905E84: 419A0014  beq cr6, 0x82905e98
	if ctx.cr[6].eq {
	pc = 0x82905E98; continue 'dispatch;
	}
	// 82905E88: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82905E8C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82905E90: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82905E94: 4800000C  b 0x82905ea0
	pc = 0x82905EA0; continue 'dispatch;
            }
            0x82905E98 => {
    //   block [0x82905E98..0x82905EA0)
	// 82905E98: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82905E9C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82905EA0; continue 'dispatch;
            }
            0x82905EA0 => {
    //   block [0x82905EA0..0x82905EAC)
	// 82905EA0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82905EA4: 4199FFB8  bgt cr6, 0x82905e5c
	if ctx.cr[6].gt {
	pc = 0x82905E5C; continue 'dispatch;
	}
	// 82905EA8: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	pc = 0x82905EAC; continue 'dispatch;
            }
            0x82905EAC => {
    //   block [0x82905EAC..0x82905EC8)
	// 82905EAC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82905EB0: 419A0040  beq cr6, 0x82905ef0
	if ctx.cr[6].eq {
	pc = 0x82905EF0; continue 'dispatch;
	}
	// 82905EB4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82905EB8: 2F0B001D  cmpwi cr6, r11, 0x1d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 29, &mut ctx.xer);
	// 82905EBC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82905EC0: 41990008  bgt cr6, 0x82905ec8
	if ctx.cr[6].gt {
	pc = 0x82905EC8; continue 'dispatch;
	}
	// 82905EC4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82905EC8; continue 'dispatch;
            }
            0x82905EC8 => {
    //   block [0x82905EC8..0x82905EF0)
	// 82905EC8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82905ECC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82905ED0: 409A0020  bne cr6, 0x82905ef0
	if !ctx.cr[6].eq {
	pc = 0x82905EF0; continue 'dispatch;
	}
	// 82905ED4: E9610070  ld r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82905ED8: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 82905EDC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82905EE0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82905EE4: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82905EE8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82905EEC: 4800001C  b 0x82905f08
	pc = 0x82905F08; continue 'dispatch;
            }
            0x82905EF0 => {
    //   block [0x82905EF0..0x82905F04)
	// 82905EF0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82905EF4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82905EF8: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82905EFC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82905F00: 48000008  b 0x82905f08
	pc = 0x82905F08; continue 'dispatch;
            }
            0x82905F04 => {
    //   block [0x82905F04..0x82905F08)
	// 82905F04: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82905F08; continue 'dispatch;
            }
            0x82905F08 => {
    //   block [0x82905F08..0x82905F1C)
	// 82905F08: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82905F0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82905F10: 419A000C  beq cr6, 0x82905f1c
	if ctx.cr[6].eq {
	pc = 0x82905F1C; continue 'dispatch;
	}
	// 82905F14: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82905F18: 917E002C  stw r11, 0x2c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	pc = 0x82905F1C; continue 'dispatch;
            }
            0x82905F1C => {
    //   block [0x82905F1C..0x82905F6C)
	// 82905F1C: 897D004B  lbz r11, 0x4b(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(75 as u32) ) } as u64;
	// 82905F20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82905F24: 409A014C  bne cr6, 0x82906070
	if !ctx.cr[6].eq {
	pc = 0x82906070; continue 'dispatch;
	}
	// 82905F28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82905F2C: 4B86E53D  bl 0x82174468
	ctx.lr = 0x82905F30;
	sub_82174468(ctx, base);
	// 82905F30: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82905F34: 556A27FE  rlwinm r10, r11, 4, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0FFFFFFFu64;
	// 82905F38: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82905F3C: 419A00F0  beq cr6, 0x8290602c
	if ctx.cr[6].eq {
	pc = 0x8290602C; continue 'dispatch;
	}
	// 82905F40: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 82905F44: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 82905F48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82905F4C: 419A0020  beq cr6, 0x82905f6c
	if ctx.cr[6].eq {
	pc = 0x82905F6C; continue 'dispatch;
	}
	// 82905F50: 896B003C  lbz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82905F54: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 82905F58: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82905F5C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82905F60: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82905F64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82905F68: 480000C8  b 0x82906030
	pc = 0x82906030; continue 'dispatch;
            }
            0x82905F6C => {
    //   block [0x82905F6C..0x82905F84)
	// 82905F6C: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 82905F70: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 82905F74: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82905F78: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 82905F7C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82905F80: 40810054  ble 0x82905fd4
	if !ctx.cr[0].gt {
	pc = 0x82905FD4; continue 'dispatch;
	}
	pc = 0x82905F84; continue 'dispatch;
            }
            0x82905F84 => {
    //   block [0x82905F84..0x82905FA4)
	// 82905F84: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82905F88: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82905F8C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82905F90: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82905F94: 2F07003C  cmpwi cr6, r7, 0x3c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 60, &mut ctx.xer);
	// 82905F98: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82905F9C: 41980008  blt cr6, 0x82905fa4
	if ctx.cr[6].lt {
	pc = 0x82905FA4; continue 'dispatch;
	}
	// 82905FA0: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x82905FA4; continue 'dispatch;
            }
            0x82905FA4 => {
    //   block [0x82905FA4..0x82905FC0)
	// 82905FA4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82905FA8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82905FAC: 419A0014  beq cr6, 0x82905fc0
	if ctx.cr[6].eq {
	pc = 0x82905FC0; continue 'dispatch;
	}
	// 82905FB0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82905FB4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82905FB8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82905FBC: 4800000C  b 0x82905fc8
	pc = 0x82905FC8; continue 'dispatch;
            }
            0x82905FC0 => {
    //   block [0x82905FC0..0x82905FC8)
	// 82905FC0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82905FC4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82905FC8; continue 'dispatch;
            }
            0x82905FC8 => {
    //   block [0x82905FC8..0x82905FD4)
	// 82905FC8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82905FCC: 4199FFB8  bgt cr6, 0x82905f84
	if ctx.cr[6].gt {
	pc = 0x82905F84; continue 'dispatch;
	}
	// 82905FD0: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	pc = 0x82905FD4; continue 'dispatch;
            }
            0x82905FD4 => {
    //   block [0x82905FD4..0x82905FF0)
	// 82905FD4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82905FD8: 419A0040  beq cr6, 0x82906018
	if ctx.cr[6].eq {
	pc = 0x82906018; continue 'dispatch;
	}
	// 82905FDC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82905FE0: 2F0B003C  cmpwi cr6, r11, 0x3c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 60, &mut ctx.xer);
	// 82905FE4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82905FE8: 41990008  bgt cr6, 0x82905ff0
	if ctx.cr[6].gt {
	pc = 0x82905FF0; continue 'dispatch;
	}
	// 82905FEC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82905FF0; continue 'dispatch;
            }
            0x82905FF0 => {
    //   block [0x82905FF0..0x82906018)
	// 82905FF0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82905FF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82905FF8: 409A0020  bne cr6, 0x82906018
	if !ctx.cr[6].eq {
	pc = 0x82906018; continue 'dispatch;
	}
	// 82905FFC: E9610070  ld r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82906000: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 82906004: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82906008: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290600C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82906010: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82906014: 4800001C  b 0x82906030
	pc = 0x82906030; continue 'dispatch;
            }
            0x82906018 => {
    //   block [0x82906018..0x8290602C)
	// 82906018: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8290601C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82906020: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82906024: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82906028: 48000008  b 0x82906030
	pc = 0x82906030; continue 'dispatch;
            }
            0x8290602C => {
    //   block [0x8290602C..0x82906030)
	// 8290602C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82906030; continue 'dispatch;
            }
            0x82906030 => {
    //   block [0x82906030..0x82906070)
	// 82906030: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82906034: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82906038: 419A0038  beq cr6, 0x82906070
	if ctx.cr[6].eq {
	pc = 0x82906070; continue 'dispatch;
	}
	// 8290603C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82906040: 38E00080  li r7, 0x80
	ctx.r[7].s64 = 128;
	// 82906044: 38ABD5C8  addi r5, r11, -0x2a38
	ctx.r[5].s64 = ctx.r[11].s64 + -10808;
	// 82906048: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290604C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82906050: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82906054: C04BD5C8  lfs f2, -0x2a38(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10808 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82906058: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	pc = 0x82906070; continue 'dispatch;
            }
            0x82906070 => {
    //   block [0x82906070..0x82906078)
	// 82906070: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82906074: 483A33E8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82906078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82906078 size=368
    let mut pc: u32 = 0x82906078;
    'dispatch: loop {
        match pc {
            0x82906078 => {
    //   block [0x82906078..0x829061E8)
	// 82906078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290607C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82906080: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82906084: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82906088: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829061E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829061E8 size=188
    let mut pc: u32 = 0x829061E8;
    'dispatch: loop {
        match pc {
            0x829061E8 => {
    //   block [0x829061E8..0x82906220)
	// 829061E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829061EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829061F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829061F4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829061F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829061FC: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82906200: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82906204: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82906208: 419A001C  beq cr6, 0x82906224
	if ctx.cr[6].eq {
	pc = 0x82906224; continue 'dispatch;
	}
	// 8290620C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82906210: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82906214: 419A000C  beq cr6, 0x82906220
	if ctx.cr[6].eq {
	pc = 0x82906220; continue 'dispatch;
	}
	// 82906218: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8290621C: 4800000C  b 0x82906228
	pc = 0x82906228; continue 'dispatch;
            }
            0x82906220 => {
    //   block [0x82906220..0x82906224)
	// 82906220: 4B88DC19  bl 0x82193e38
	ctx.lr = 0x82906224;
	sub_82193E38(ctx, base);
	pc = 0x82906224; continue 'dispatch;
            }
            0x82906224 => {
    //   block [0x82906224..0x82906228)
	// 82906224: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82906228; continue 'dispatch;
            }
            0x82906228 => {
    //   block [0x82906228..0x829062A4)
	// 82906228: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 8290622C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82906230: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82906234: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82906238: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8290623C: 4E800421  bctrl
	ctx.lr = 0x82906240;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82906240: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82906244: 39000080  li r8, 0x80
	ctx.r[8].s64 = 128;
	// 82906248: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 8290624C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82906250: 38A790F0  addi r5, r7, -0x6f10
	ctx.r[5].s64 = ctx.r[7].s64 + -28432;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829062A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829062A8 size=4
    let mut pc: u32 = 0x829062A8;
    'dispatch: loop {
        match pc {
            0x829062A8 => {
    //   block [0x829062A8..0x829062AC)
	// 829062A8: 4B8DD490  b 0x821e3738
	sub_821E3738(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829062B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829062B0 size=916
    let mut pc: u32 = 0x829062B0;
    'dispatch: loop {
        match pc {
            0x829062B0 => {
    //   block [0x829062B0..0x82906644)
	// 829062B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829062B4: 483A3151  bl 0x82ca9404
	ctx.lr = 0x829062B8;
	sub_82CA93D0(ctx, base);
	// 829062B8: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82906648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82906648 size=60
    let mut pc: u32 = 0x82906648;
    'dispatch: loop {
        match pc {
            0x82906648 => {
    //   block [0x82906648..0x82906684)
	// 82906648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290664C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82906650: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82906654: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82906658: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8290665C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82906660: 388B8D6C  addi r4, r11, -0x7294
	ctx.r[4].s64 = ctx.r[11].s64 + -29332;
	// 82906664: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82906668: 4B926869  bl 0x8222ced0
	ctx.lr = 0x8290666C;
	sub_8222CED0(ctx, base);
	// 8290666C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82906670: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82906674: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82906678: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290667C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82906680: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82906688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82906688 size=116
    let mut pc: u32 = 0x82906688;
    'dispatch: loop {
        match pc {
            0x82906688 => {
    //   block [0x82906688..0x829066E4)
	// 82906688: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290668C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82906690: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82906694: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82906698: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290669C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829066A0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829066A4: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 829066A8: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 829066AC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829066B0: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 829066B4: 4B88D785  bl 0x82193e38
	ctx.lr = 0x829066B8;
	sub_82193E38(ctx, base);
	// 829066B8: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 829066BC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829066C0: 38E92850  addi r7, r9, 0x2850
	ctx.r[7].s64 = ctx.r[9].s64 + 10320;
	// 829066C4: 57C607FE  clrlwi r6, r30, 0x1f
	ctx.r[6].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 829066C8: 911F002C  stw r8, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[8].u32 ) };
	// 829066CC: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 829066D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829066D4: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 829066D8: 419A000C  beq cr6, 0x829066e4
	if ctx.cr[6].eq {
	pc = 0x829066E4; continue 'dispatch;
	}
	// 829066DC: 4B91565D  bl 0x8221bd38
	ctx.lr = 0x829066E0;
	sub_8221BD38(ctx, base);
	// 829066E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x829066E4; continue 'dispatch;
            }
            0x829066E4 => {
    //   block [0x829066E4..0x829066FC)
	// 829066E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829066E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829066EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829066F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829066F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829066F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82906700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82906700 size=240
    let mut pc: u32 = 0x82906700;
    'dispatch: loop {
        match pc {
            0x82906700 => {
    //   block [0x82906700..0x82906790)
	// 82906700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82906704: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82906708: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8290670C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82906710: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82906714: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82906718: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8290671C: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 82906720: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82906724: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82906728: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 8290672C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82906730: 4B90E169  bl 0x82214898
	ctx.lr = 0x82906734;
	sub_82214898(ctx, base);
	// 82906734: 3BFE0028  addi r31, r30, 0x28
	ctx.r[31].s64 = ctx.r[30].s64 + 40;
	// 82906738: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8290673C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82906740: 4BBCB789  bl 0x824d1ec8
	ctx.lr = 0x82906744;
	sub_824D1EC8(ctx, base);
	// 82906744: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82906748: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290674C: 38E80B7C  addi r7, r8, 0xb7c
	ctx.r[7].s64 = ctx.r[8].s64 + 2940;
	// 82906750: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 82906754: 4B88D6E5  bl 0x82193e38
	ctx.lr = 0x82906758;
	sub_82193E38(ctx, base);
	// 82906758: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 8290675C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82906760: 419A0030  beq cr6, 0x82906790
	if ctx.cr[6].eq {
	pc = 0x82906790; continue 'dispatch;
	}
	// 82906764: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82906768: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290676C: 419A0078  beq cr6, 0x829067e4
	if ctx.cr[6].eq {
	pc = 0x829067E4; continue 'dispatch;
	}
	// 82906770: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82906774: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82906778: 419A0018  beq cr6, 0x82906790
	if ctx.cr[6].eq {
	pc = 0x82906790; continue 'dispatch;
	}
	// 8290677C: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 82906780: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82906784: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82906788: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290678C: 409A0008  bne cr6, 0x82906794
	if !ctx.cr[6].eq {
	pc = 0x82906794; continue 'dispatch;
	}
	pc = 0x82906790; continue 'dispatch;
            }
            0x82906790 => {
    //   block [0x82906790..0x82906794)
	// 82906790: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82906794; continue 'dispatch;
            }
            0x82906794 => {
    //   block [0x82906794..0x829067CC)
	// 82906794: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82906798: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290679C: 419A0030  beq cr6, 0x829067cc
	if ctx.cr[6].eq {
	pc = 0x829067CC; continue 'dispatch;
	}
	// 829067A0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829067A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829067A8: 83CB007C  lwz r30, 0x7c(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 829067AC: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829067B0: 4B86D689  bl 0x82173e38
	ctx.lr = 0x829067B4;
	sub_82173E38(ctx, base);
	// 829067B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829067B8: 815F0098  lwz r10, 0x98(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 829067BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829067C0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829067C4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829067C8: 4E800421  bctrl
	ctx.lr = 0x829067CC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x829067CC => {
    //   block [0x829067CC..0x829067E4)
	// 829067CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829067D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829067D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829067D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829067DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829067E0: 4E800020  blr
	return;
            }
            0x829067E4 => {
    //   block [0x829067E4..0x829067F0)
	// 829067E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829067E8: 4B88D651  bl 0x82193e38
	ctx.lr = 0x829067EC;
	sub_82193E38(ctx, base);
	// 829067EC: 4BFFFFA4  b 0x82906790
	pc = 0x82906790; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829067F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829067F0 size=168
    let mut pc: u32 = 0x829067F0;
    'dispatch: loop {
        match pc {
            0x829067F0 => {
    //   block [0x829067F0..0x8290685C)
	// 829067F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829067F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829067F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829067FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82906800: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 82906804: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82906808: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8290680C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82906810: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82906814: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82906818: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290681C: 396B9484  addi r11, r11, -0x6b7c
	ctx.r[11].s64 = ctx.r[11].s64 + -27516;
	// 82906820: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82906824: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82906828: 909F000C  stw r4, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	// 8290682C: C3AB0000  lfs f29, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82906830: 9BDF0024  stb r30, 0x24(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u8 ) };
	// 82906834: FF1FE800  fcmpu cr6, f31, f29
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[29].f64);
	// 82906838: 40990024  ble cr6, 0x8290685c
	if !ctx.cr[6].gt {
	pc = 0x8290685C; continue 'dispatch;
	}
	// 8290683C: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82906840: C04B21CC  lfs f2, 0x21cc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8652 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82906844: CBCA9660  lfd f30, -0x69a0(r10)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-27040 as u32) ) };
	// 82906848: 4BCF06D9  bl 0x825f6f20
	ctx.lr = 0x8290684C;
	sub_825F6F20(ctx, base);
	// 8290684C: FC0107B2  fmul f0, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64 * ctx.f[30].f64;
	// 82906850: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82906854: D9A10050  stfd f13, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[13].u64 ) };
	// 82906858: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x8290685C; continue 'dispatch;
            }
            0x8290685C => {
    //   block [0x8290685C..0x82906874)
	// 8290685C: FF1FE800  fcmpu cr6, f31, f29
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[29].f64);
	// 82906860: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82906864: 40990010  ble cr6, 0x82906874
	if !ctx.cr[6].gt {
	pc = 0x82906874; continue 'dispatch;
	}
	// 82906868: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 8290686C: 40980008  bge cr6, 0x82906874
	if !ctx.cr[6].lt {
	pc = 0x82906874; continue 'dispatch;
	}
	// 82906870: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	pc = 0x82906874; continue 'dispatch;
            }
            0x82906874 => {
    //   block [0x82906874..0x82906898)
	// 82906874: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82906878: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8290687C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82906880: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82906884: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82906888: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8290688C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82906890: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82906894: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82906898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82906898 size=260
    let mut pc: u32 = 0x82906898;
    'dispatch: loop {
        match pc {
            0x82906898 => {
    //   block [0x82906898..0x829068F0)
	// 82906898: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290689C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829068A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829068A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829068A8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 829068AC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829068B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829068B4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829068B8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829068BC: 394B9484  addi r10, r11, -0x6b7c
	ctx.r[10].s64 = ctx.r[11].s64 + -27516;
	// 829068C0: 813F0020  lwz r9, 0x20(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 829068C4: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829068C8: C3EA000C  lfs f31, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829068CC: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 829068D0: 41990020  bgt cr6, 0x829068f0
	if ctx.cr[6].gt {
	pc = 0x829068F0; continue 'dispatch;
	}
	// 829068D4: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 829068D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829068DC: 40990014  ble cr6, 0x829068f0
	if !ctx.cr[6].gt {
	pc = 0x829068F0; continue 'dispatch;
	}
	// 829068E0: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829068E4: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 829068E8: 41810008  bgt 0x829068f0
	if ctx.cr[0].gt {
	pc = 0x829068F0; continue 'dispatch;
	}
	// 829068EC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	pc = 0x829068F0; continue 'dispatch;
            }
            0x829068F0 => {
    //   block [0x829068F0..0x82906918)
	// 829068F0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 829068F4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829068F8: 41980020  blt cr6, 0x82906918
	if ctx.cr[6].lt {
	pc = 0x82906918; continue 'dispatch;
	}
	// 829068FC: 409A003C  bne cr6, 0x82906938
	if !ctx.cr[6].eq {
	pc = 0x82906938; continue 'dispatch;
	}
	// 82906900: 552B063E  clrlwi r11, r9, 0x18
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82906904: C3EA0000  lfs f31, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82906908: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290690C: 419A002C  beq cr6, 0x82906938
	if ctx.cr[6].eq {
	pc = 0x82906938; continue 'dispatch;
	}
	// 82906910: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82906914: 48000024  b 0x82906938
	pc = 0x82906938; continue 'dispatch;
            }
            0x82906918 => {
    //   block [0x82906918..0x82906938)
	// 82906918: 552B063E  clrlwi r11, r9, 0x18
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 8290691C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82906920: 419A0018  beq cr6, 0x82906938
	if ctx.cr[6].eq {
	pc = 0x82906938; continue 'dispatch;
	}
	// 82906924: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 82906928: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8290692C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82906930: C02A223C  lfs f1, 0x223c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8764 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82906934: 4BFFFEBD  bl 0x829067f0
	ctx.lr = 0x82906938;
	sub_829067F0(ctx, base);
	pc = 0x82906938; continue 'dispatch;
            }
            0x82906938 => {
    //   block [0x82906938..0x82906980)
	// 82906938: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8290693C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82906940: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82906944: 480001B5  bl 0x82906af8
	ctx.lr = 0x82906948;
	sub_82906AF8(ctx, base);
	// 82906948: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 8290694C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82906950: 419A0030  beq cr6, 0x82906980
	if ctx.cr[6].eq {
	pc = 0x82906980; continue 'dispatch;
	}
	// 82906954: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82906958: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290695C: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82906960: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82906964: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82906968: 4E800421  bctrl
	ctx.lr = 0x8290696C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290696C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82906970: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82906974: 4BA86205  bl 0x8238cb78
	ctx.lr = 0x82906978;
	sub_8238CB78(ctx, base);
	// 82906978: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290697C: 4BA86EAD  bl 0x8238d828
	ctx.lr = 0x82906980;
	sub_8238D828(ctx, base);
            }
            0x82906980 => {
    //   block [0x82906980..0x8290699C)
	// 82906980: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82906984: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82906988: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290698C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82906990: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82906994: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82906998: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829069A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829069A0 size=344
    let mut pc: u32 = 0x829069A0;
    'dispatch: loop {
        match pc {
            0x829069A0 => {
    //   block [0x829069A0..0x829069EC)
	// 829069A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829069A4: 483A2A69  bl 0x82ca940c
	ctx.lr = 0x829069A8;
	sub_82CA93D0(ctx, base);
	// 829069A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829069AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829069B0: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 829069B4: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 829069B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829069BC: 419A0030  beq cr6, 0x829069ec
	if ctx.cr[6].eq {
	pc = 0x829069EC; continue 'dispatch;
	}
	// 829069C0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829069C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829069C8: 419A0124  beq cr6, 0x82906aec
	if ctx.cr[6].eq {
	pc = 0x82906AEC; continue 'dispatch;
	}
	// 829069CC: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829069D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829069D4: 419A0018  beq cr6, 0x829069ec
	if ctx.cr[6].eq {
	pc = 0x829069EC; continue 'dispatch;
	}
	// 829069D8: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 829069DC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829069E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829069E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829069E8: 409A0008  bne cr6, 0x829069f0
	if !ctx.cr[6].eq {
	pc = 0x829069F0; continue 'dispatch;
	}
	pc = 0x829069EC; continue 'dispatch;
            }
            0x829069EC => {
    //   block [0x829069EC..0x829069F0)
	// 829069EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829069F0; continue 'dispatch;
            }
            0x829069F0 => {
    //   block [0x829069F0..0x82906A28)
	// 829069F0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829069F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829069F8: 419A0030  beq cr6, 0x82906a28
	if ctx.cr[6].eq {
	pc = 0x82906A28; continue 'dispatch;
	}
	// 829069FC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82906A00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82906A04: 83AB007C  lwz r29, 0x7c(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 82906A08: 83DD0000  lwz r30, 0(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82906A0C: 4B86D42D  bl 0x82173e38
	ctx.lr = 0x82906A10;
	sub_82173E38(ctx, base);
	// 82906A10: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82906A14: 815E0098  lwz r10, 0x98(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(152 as u32) ) } as u64;
	// 82906A18: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82906A1C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82906A20: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82906A24: 4E800421  bctrl
	ctx.lr = 0x82906A28;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82906A28 => {
    //   block [0x82906A28..0x82906A5C)
	// 82906A28: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82906A2C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82906A30: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 82906A34: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82906A38: 810A0058  lwz r8, 0x58(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 82906A3C: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82906A40: 81670034  lwz r11, 0x34(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(52 as u32) ) } as u64;
	// 82906A44: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82906A48: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82906A4C: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82906A50: 7F065040  cmplw cr6, r6, r10
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82906A54: 40990008  ble cr6, 0x82906a5c
	if !ctx.cr[6].gt {
	pc = 0x82906A5C; continue 'dispatch;
	}
	// 82906A58: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82906A5C; continue 'dispatch;
            }
            0x82906A5C => {
    //   block [0x82906A5C..0x82906A70)
	// 82906A5C: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82906A60: 81040008  lwz r8, 8(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82906A64: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82906A68: 40990008  ble cr6, 0x82906a70
	if !ctx.cr[6].gt {
	pc = 0x82906A70; continue 'dispatch;
	}
	// 82906A6C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82906A70; continue 'dispatch;
            }
            0x82906A70 => {
    //   block [0x82906A70..0x82906A88)
	// 82906A70: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 82906A74: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82906A78: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82906A7C: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82906A80: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 82906A84: 419A001C  beq cr6, 0x82906aa0
	if ctx.cr[6].eq {
	pc = 0x82906AA0; continue 'dispatch;
	}
	pc = 0x82906A88; continue 'dispatch;
            }
            0x82906A88 => {
    //   block [0x82906A88..0x82906AA0)
	// 82906A88: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82906A8C: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82906A90: 419A0010  beq cr6, 0x82906aa0
	if ctx.cr[6].eq {
	pc = 0x82906AA0; continue 'dispatch;
	}
	// 82906A94: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82906A98: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82906A9C: 409AFFEC  bne cr6, 0x82906a88
	if !ctx.cr[6].eq {
	pc = 0x82906A88; continue 'dispatch;
	}
	pc = 0x82906AA0; continue 'dispatch;
            }
            0x82906AA0 => {
    //   block [0x82906AA0..0x82906AB8)
	// 82906AA0: 81440008  lwz r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82906AA4: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82906AA8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82906AAC: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82906AB0: 40990008  ble cr6, 0x82906ab8
	if !ctx.cr[6].gt {
	pc = 0x82906AB8; continue 'dispatch;
	}
	// 82906AB4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82906AB8; continue 'dispatch;
            }
            0x82906AB8 => {
    //   block [0x82906AB8..0x82906ACC)
	// 82906AB8: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82906ABC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82906AC0: 419A000C  beq cr6, 0x82906acc
	if ctx.cr[6].eq {
	pc = 0x82906ACC; continue 'dispatch;
	}
	// 82906AC4: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82906AC8: 419A0008  beq cr6, 0x82906ad0
	if ctx.cr[6].eq {
	pc = 0x82906AD0; continue 'dispatch;
	}
	pc = 0x82906ACC; continue 'dispatch;
            }
            0x82906ACC => {
    //   block [0x82906ACC..0x82906AD0)
	// 82906ACC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82906AD0; continue 'dispatch;
            }
            0x82906AD0 => {
    //   block [0x82906AD0..0x82906AE4)
	// 82906AD0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82906AD4: 419A0010  beq cr6, 0x82906ae4
	if ctx.cr[6].eq {
	pc = 0x82906AE4; continue 'dispatch;
	}
	// 82906AD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82906ADC: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82906AE0: 4BA1A5B9  bl 0x82321098
	ctx.lr = 0x82906AE4;
	sub_82321098(ctx, base);
	pc = 0x82906AE4; continue 'dispatch;
            }
            0x82906AE4 => {
    //   block [0x82906AE4..0x82906AEC)
	// 82906AE4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82906AE8: 483A2974  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82906AEC => {
    //   block [0x82906AEC..0x82906AF8)
	// 82906AEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82906AF0: 4B88D349  bl 0x82193e38
	ctx.lr = 0x82906AF4;
	sub_82193E38(ctx, base);
	// 82906AF4: 4BFFFEF8  b 0x829069ec
	pc = 0x829069EC; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82906AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82906AF8 size=500
    let mut pc: u32 = 0x82906AF8;
    'dispatch: loop {
        match pc {
            0x82906AF8 => {
    //   block [0x82906AF8..0x82906B3C)
	// 82906AF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82906AFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82906B00: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82906B04: 54AA063E  clrlwi r10, r5, 0x18
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82906B08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82906B0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82906B10: 409A009C  bne cr6, 0x82906bac
	if !ctx.cr[6].eq {
	pc = 0x82906BAC; continue 'dispatch;
	}
	// 82906B14: C1430018  lfs f10, 0x18(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82906B18: FF0A0800  fcmpu cr6, f10, f1
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[1].f64);
	// 82906B1C: 419A0094  beq cr6, 0x82906bb0
	if ctx.cr[6].eq {
	pc = 0x82906BB0; continue 'dispatch;
	}
	// 82906B20: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82906B24: 396BD5C8  addi r11, r11, -0x2a38
	ctx.r[11].s64 = ctx.r[11].s64 + -10808;
	// 82906B28: C00BBEC8  lfs f0, -0x4138(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16696 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82906B2C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82906B30: 4198000C  blt cr6, 0x82906b3c
	if ctx.cr[6].lt {
	pc = 0x82906B3C; continue 'dispatch;
	}
	// 82906B34: C18BE168  lfs f12, -0x1e98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7832 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82906B38: 48000008  b 0x82906b40
	pc = 0x82906B40; continue 'dispatch;
            }
            0x82906B3C => {
    //   block [0x82906B3C..0x82906B40)
	// 82906B3C: C18BE0F8  lfs f12, -0x1f08(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7944 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82906B40; continue 'dispatch;
            }
            0x82906B40 => {
    //   block [0x82906B40..0x82906B98)
	// 82906B40: ED215028  fsubs f9, f1, f10
	ctx.f[9].f64 = (((ctx.f[1].f64 - ctx.f[10].f64) as f32) as f64);
	// 82906B44: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82906B48: C1ABBEBC  lfs f13, -0x4144(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16708 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82906B4C: ED006024  fdivs f8, f0, f12
	ctx.f[8].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 82906B50: 3D208210  lis r9, -0x7df0
	ctx.r[9].s64 = -2112880640;
	// 82906B54: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82906B58: 39090E68  addi r8, r9, 0xe68
	ctx.r[8].s64 = ctx.r[9].s64 + 3688;
	// 82906B5C: C98A9660  lfd f12, -0x69a0(r10)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-27040 as u32) ) };
	// 82906B60: FCE06018  frsp f7, f12
	ctx.f[7].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82906B64: FF096800  fcmpu cr6, f9, f13
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[13].f64);
	// 82906B68: 7CE00026  mfcr r7
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[7].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 82906B6C: 54E6DF7A  rlwinm r6, r7, 0x1b, 0x1d, 0x1d
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 82906B70: ECC83824  fdivs f6, f8, f7
	ctx.f[6].f64 = ((ctx.f[8].f64 / ctx.f[7].f64) as f32) as f64;
	// 82906B74: 54E5F77A  rlwinm r5, r7, 0x1e, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0x00000003u64;
	// 82906B78: 7CC42B78  or r4, r6, r5
	ctx.r[4].u64 = ctx.r[6].u64 | ctx.r[5].u64;
	// 82906B7C: 7CA8242E  lfsx f5, r8, r4
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[4].u32)) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82906B80: FC85582E  fsel f4, f5, f0, f11
	ctx.f[4].f64 = if ctx.f[5].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[11].f64 };
	// 82906B84: EC6451BA  fmadds f3, f4, f6, f10
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[6].f64 + ctx.f[10].f64) as f32) as f64);
	// 82906B88: D0630018  stfs f3, 0x18(r3)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82906B8C: FF030000  fcmpu cr6, f3, f0
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[0].f64);
	// 82906B90: 40990008  ble cr6, 0x82906b98
	if !ctx.cr[6].gt {
	pc = 0x82906B98; continue 'dispatch;
	}
	// 82906B94: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	pc = 0x82906B98; continue 'dispatch;
            }
            0x82906B98 => {
    //   block [0x82906B98..0x82906BA8)
	// 82906B98: C0030018  lfs f0, 0x18(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82906B9C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82906BA0: 40980008  bge cr6, 0x82906ba8
	if !ctx.cr[6].lt {
	pc = 0x82906BA8; continue 'dispatch;
	}
	// 82906BA4: D1A30018  stfs f13, 0x18(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	pc = 0x82906BA8; continue 'dispatch;
            }
            0x82906BA8 => {
    //   block [0x82906BA8..0x82906BAC)
	// 82906BA8: C0230018  lfs f1, 0x18(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	pc = 0x82906BAC; continue 'dispatch;
            }
            0x82906BAC => {
    //   block [0x82906BAC..0x82906BB0)
	// 82906BAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82906BB0; continue 'dispatch;
            }
            0x82906BB0 => {
    //   block [0x82906BB0..0x82906C00)
	// 82906BB0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82906BB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82906BB8: 419A0124  beq cr6, 0x82906cdc
	if ctx.cr[6].eq {
	pc = 0x82906CDC; continue 'dispatch;
	}
	// 82906BBC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82906BC0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82906BC4: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82906BC8: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 82906BCC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82906BD0: 419A00F8  beq cr6, 0x82906cc8
	if ctx.cr[6].eq {
	pc = 0x82906CC8; continue 'dispatch;
	}
	// 82906BD4: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82906BD8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82906BDC: 419A0024  beq cr6, 0x82906c00
	if ctx.cr[6].eq {
	pc = 0x82906C00; continue 'dispatch;
	}
	// 82906BE0: 894A0003  lbz r10, 3(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(3 as u32) ) } as u64;
	// 82906BE4: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82906BE8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82906BEC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82906BF0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82906BF4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82906BF8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82906BFC: 480000D0  b 0x82906ccc
	pc = 0x82906CCC; continue 'dispatch;
            }
            0x82906C00 => {
    //   block [0x82906C00..0x82906C20)
	// 82906C00: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82906C04: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82906C08: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82906C0C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82906C10: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82906C14: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82906C18: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82906C1C: 40810054  ble 0x82906c70
	if !ctx.cr[0].gt {
	pc = 0x82906C70; continue 'dispatch;
	}
	pc = 0x82906C20; continue 'dispatch;
            }
            0x82906C20 => {
    //   block [0x82906C20..0x82906C40)
	// 82906C20: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82906C24: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82906C28: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82906C2C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82906C30: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 82906C34: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82906C38: 41980008  blt cr6, 0x82906c40
	if ctx.cr[6].lt {
	pc = 0x82906C40; continue 'dispatch;
	}
	// 82906C3C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x82906C40; continue 'dispatch;
            }
            0x82906C40 => {
    //   block [0x82906C40..0x82906C5C)
	// 82906C40: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82906C44: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82906C48: 419A0014  beq cr6, 0x82906c5c
	if ctx.cr[6].eq {
	pc = 0x82906C5C; continue 'dispatch;
	}
	// 82906C4C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82906C50: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82906C54: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82906C58: 4800000C  b 0x82906c64
	pc = 0x82906C64; continue 'dispatch;
            }
            0x82906C5C => {
    //   block [0x82906C5C..0x82906C64)
	// 82906C5C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82906C60: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82906C64; continue 'dispatch;
            }
            0x82906C64 => {
    //   block [0x82906C64..0x82906C70)
	// 82906C64: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82906C68: 4199FFB8  bgt cr6, 0x82906c20
	if ctx.cr[6].gt {
	pc = 0x82906C20; continue 'dispatch;
	}
	// 82906C6C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82906C70; continue 'dispatch;
            }
            0x82906C70 => {
    //   block [0x82906C70..0x82906C8C)
	// 82906C70: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82906C74: 419A0040  beq cr6, 0x82906cb4
	if ctx.cr[6].eq {
	pc = 0x82906CB4; continue 'dispatch;
	}
	// 82906C78: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82906C7C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82906C80: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82906C84: 41990008  bgt cr6, 0x82906c8c
	if ctx.cr[6].gt {
	pc = 0x82906C8C; continue 'dispatch;
	}
	// 82906C88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82906C8C; continue 'dispatch;
            }
            0x82906C8C => {
    //   block [0x82906C8C..0x82906CB4)
	// 82906C8C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82906C90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82906C94: 409A0020  bne cr6, 0x82906cb4
	if !ctx.cr[6].eq {
	pc = 0x82906CB4; continue 'dispatch;
	}
	// 82906C98: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82906C9C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82906CA0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82906CA4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82906CA8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82906CAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82906CB0: 4800001C  b 0x82906ccc
	pc = 0x82906CCC; continue 'dispatch;
            }
            0x82906CB4 => {
    //   block [0x82906CB4..0x82906CC8)
	// 82906CB4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82906CB8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82906CBC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82906CC0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82906CC4: 48000008  b 0x82906ccc
	pc = 0x82906CCC; continue 'dispatch;
            }
            0x82906CC8 => {
    //   block [0x82906CC8..0x82906CCC)
	// 82906CC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82906CCC; continue 'dispatch;
            }
            0x82906CCC => {
    //   block [0x82906CCC..0x82906CDC)
	// 82906CCC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82906CD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82906CD4: 419A0008  beq cr6, 0x82906cdc
	if ctx.cr[6].eq {
	pc = 0x82906CDC; continue 'dispatch;
	}
	// 82906CD8: 4BC6C549  bl 0x82573220
	ctx.lr = 0x82906CDC;
	sub_82573220(ctx, base);
	pc = 0x82906CDC; continue 'dispatch;
            }
            0x82906CDC => {
    //   block [0x82906CDC..0x82906CEC)
	// 82906CDC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82906CE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82906CE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82906CE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82906CF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82906CF0 size=8
    let mut pc: u32 = 0x82906CF0;
    'dispatch: loop {
        match pc {
            0x82906CF0 => {
    //   block [0x82906CF0..0x82906CF8)
	// 82906CF0: 38600073  li r3, 0x73
	ctx.r[3].s64 = 115;
	// 82906CF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82906CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82906CF8 size=60
    let mut pc: u32 = 0x82906CF8;
    'dispatch: loop {
        match pc {
            0x82906CF8 => {
    //   block [0x82906CF8..0x82906D34)
	// 82906CF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82906CFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82906D00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82906D04: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82906D08: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82906D0C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82906D10: 388B961C  addi r4, r11, -0x69e4
	ctx.r[4].s64 = ctx.r[11].s64 + -27108;
	// 82906D14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82906D18: 4B9261B9  bl 0x8222ced0
	ctx.lr = 0x82906D1C;
	sub_8222CED0(ctx, base);
	// 82906D1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82906D20: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82906D24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82906D28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82906D2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82906D30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82906D38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82906D38 size=148
    let mut pc: u32 = 0x82906D38;
    'dispatch: loop {
        match pc {
            0x82906D38 => {
    //   block [0x82906D38..0x82906D94)
	// 82906D38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82906D3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82906D40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82906D44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82906D48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82906D4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82906D50: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82906D54: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 82906D58: 394B4540  addi r10, r11, 0x4540
	ctx.r[10].s64 = ctx.r[11].s64 + 17728;
	// 82906D5C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82906D60: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82906D64: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 82906D68: 3889CB44  addi r4, r9, -0x34bc
	ctx.r[4].s64 = ctx.r[9].s64 + -13500;
	// 82906D6C: 4BD6BBCD  bl 0x82672938
	ctx.lr = 0x82906D70;
	sub_82672938(ctx, base);
	// 82906D70: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82906D74: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82906D78: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82906D7C: 911F0050  stw r8, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82906D80: 419A0014  beq cr6, 0x82906d94
	if ctx.cr[6].eq {
	pc = 0x82906D94; continue 'dispatch;
	}
	// 82906D84: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82906D88: 4BD1F199  bl 0x82625f20
	ctx.lr = 0x82906D8C;
	sub_82625F20(ctx, base);
	// 82906D8C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82906D90: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x82906D94; continue 'dispatch;
            }
            0x82906D94 => {
    //   block [0x82906D94..0x82906DB4)
	// 82906D94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82906D98: 4BFC5FB1  bl 0x828ccd48
	ctx.lr = 0x82906D9C;
	sub_828CCD48(ctx, base);
	// 82906D9C: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82906DA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82906DA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82906DA8: 419A000C  beq cr6, 0x82906db4
	if ctx.cr[6].eq {
	pc = 0x82906DB4; continue 'dispatch;
	}
	// 82906DAC: 4B914F8D  bl 0x8221bd38
	ctx.lr = 0x82906DB0;
	sub_8221BD38(ctx, base);
	// 82906DB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82906DB4; continue 'dispatch;
            }
            0x82906DB4 => {
    //   block [0x82906DB4..0x82906DCC)
	// 82906DB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82906DB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82906DBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82906DC0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82906DC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82906DC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82906DD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82906DD0 size=100
    let mut pc: u32 = 0x82906DD0;
    'dispatch: loop {
        match pc {
            0x82906DD0 => {
    //   block [0x82906DD0..0x82906E1C)
	// 82906DD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82906DD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82906DD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82906DDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82906DE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82906DE4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82906DE8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82906DEC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82906DF0: 419A002C  beq cr6, 0x82906e1c
	if ctx.cr[6].eq {
	pc = 0x82906E1C; continue 'dispatch;
	}
	// 82906DF4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82906DF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82906DFC: 388B998C  addi r4, r11, -0x6674
	ctx.r[4].s64 = ctx.r[11].s64 + -26228;
	// 82906E00: 4BAB8A21  bl 0x823bf820
	ctx.lr = 0x82906E04;
	sub_823BF820(ctx, base);
	// 82906E04: 907E0020  stw r3, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 82906E08: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 82906E0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82906E10: 388A5394  addi r4, r10, 0x5394
	ctx.r[4].s64 = ctx.r[10].s64 + 21396;
	// 82906E14: 4BA0947D  bl 0x82310290
	ctx.lr = 0x82906E18;
	sub_82310290(ctx, base);
	// 82906E18: 987E001D  stb r3, 0x1d(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(29 as u32), ctx.r[3].u8 ) };
	pc = 0x82906E1C; continue 'dispatch;
            }
            0x82906E1C => {
    //   block [0x82906E1C..0x82906E34)
	// 82906E1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82906E20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82906E24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82906E28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82906E2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82906E30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82906E38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82906E38 size=96
    let mut pc: u32 = 0x82906E38;
    'dispatch: loop {
        match pc {
            0x82906E38 => {
    //   block [0x82906E38..0x82906E98)
	// 82906E38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82906E3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82906E40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82906E44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82906E48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82906E4C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82906E50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82906E54: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82906E58: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82906E5C: 388B3990  addi r4, r11, 0x3990
	ctx.r[4].s64 = ctx.r[11].s64 + 14736;
	// 82906E60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82906E64: 4B92606D  bl 0x8222ced0
	ctx.lr = 0x82906E68;
	sub_8222CED0(ctx, base);
	// 82906E68: 38BF001C  addi r5, r31, 0x1c
	ctx.r[5].s64 = ctx.r[31].s64 + 28;
	// 82906E6C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82906E70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82906E74: 48115FD5  bl 0x82a1ce48
	ctx.lr = 0x82906E78;
	sub_82A1CE48(ctx, base);
	// 82906E78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82906E7C: 4B90DF5D  bl 0x82214dd8
	ctx.lr = 0x82906E80;
	sub_82214DD8(ctx, base);
	// 82906E80: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82906E84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82906E88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82906E8C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82906E90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82906E94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82906E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82906E98 size=668
    let mut pc: u32 = 0x82906E98;
    'dispatch: loop {
        match pc {
            0x82906E98 => {
    //   block [0x82906E98..0x82906F7C)
	// 82906E98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82906E9C: 483A2551  bl 0x82ca93ec
	ctx.lr = 0x82906EA0;
	sub_82CA93D0(ctx, base);
	// 82906EA0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82906EA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82906EA8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82906EAC: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82906EB0: 4BA86609  bl 0x8238d4b8
	ctx.lr = 0x82906EB4;
	sub_8238D4B8(ctx, base);
	// 82906EB4: 897E001D  lbz r11, 0x1d(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(29 as u32) ) } as u64;
	// 82906EB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82906EBC: 419A0270  beq cr6, 0x8290712c
	if ctx.cr[6].eq {
	pc = 0x8290712C; continue 'dispatch;
	}
	// 82906EC0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82906EC4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82906EC8: 39400073  li r10, 0x73
	ctx.r[10].s64 = 115;
	// 82906ECC: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 82906ED0: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82906ED4: 93810068  stw r28, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 82906ED8: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82906EDC: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 82906EE0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82906EE4: 9381006C  stw r28, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	// 82906EE8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82906EEC: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82906EF0: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 82906EF4: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82906EF8: 8067000C  lwz r3, 0xc(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 82906EFC: 4BEFAAFD  bl 0x828019f8
	ctx.lr = 0x82906F00;
	sub_828019F8(ctx, base);
	// 82906F00: 82A10064  lwz r21, 0x64(r1)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82906F04: 82C10068  lwz r22, 0x68(r1)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82906F08: 7EB7AB78  mr r23, r21
	ctx.r[23].u64 = ctx.r[21].u64;
	// 82906F0C: 7F15B040  cmplw cr6, r21, r22
	ctx.cr[6].compare_u32(ctx.r[21].u32, ctx.r[22].u32, &mut ctx.xer);
	// 82906F10: 419A020C  beq cr6, 0x8290711c
	if ctx.cr[6].eq {
	pc = 0x8290711C; continue 'dispatch;
	}
	// 82906F14: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82906F18: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 82906F1C: 3B000030  li r24, 0x30
	ctx.r[24].s64 = 48;
	// 82906F20: 3B200040  li r25, 0x40
	ctx.r[25].s64 = 64;
	// 82906F24: 3FA0834C  lis r29, -0x7cb4
	ctx.r[29].s64 = -2092171264;
	// 82906F28: 3B6BCB44  addi r27, r11, -0x34bc
	ctx.r[27].s64 = ctx.r[11].s64 + -13500;
	// 82906F2C: 3B4A53A4  addi r26, r10, 0x53a4
	ctx.r[26].s64 = ctx.r[10].s64 + 21412;
	// 82906F30: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82906F34: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 82906F38: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82906F3C: 419A01D4  beq cr6, 0x82907110
	if ctx.cr[6].eq {
	pc = 0x82907110; continue 'dispatch;
	}
	// 82906F40: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82906F44: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 82906F48: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 82906F4C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82906F50: 419A00E8  beq cr6, 0x82907038
	if ctx.cr[6].eq {
	pc = 0x82907038; continue 'dispatch;
	}
	// 82906F54: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82906F58: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82906F5C: 419A0020  beq cr6, 0x82906f7c
	if ctx.cr[6].eq {
	pc = 0x82906F7C; continue 'dispatch;
	}
	// 82906F60: 894A0073  lbz r10, 0x73(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(115 as u32) ) } as u64;
	// 82906F64: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82906F68: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82906F6C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82906F70: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82906F74: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82906F78: 480000C4  b 0x8290703c
	pc = 0x8290703C; continue 'dispatch;
            }
            0x82906F7C => {
    //   block [0x82906F7C..0x82906F98)
	// 82906F7C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82906F80: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82906F84: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82906F88: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82906F8C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82906F90: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82906F94: 40810054  ble 0x82906fe8
	if !ctx.cr[0].gt {
	pc = 0x82906FE8; continue 'dispatch;
	}
	pc = 0x82906F98; continue 'dispatch;
            }
            0x82906F98 => {
    //   block [0x82906F98..0x82906FB8)
	// 82906F98: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82906F9C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82906FA0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82906FA4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82906FA8: 2F070073  cmpwi cr6, r7, 0x73
	ctx.cr[6].compare_i32(ctx.r[7].s32, 115, &mut ctx.xer);
	// 82906FAC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82906FB0: 41980008  blt cr6, 0x82906fb8
	if ctx.cr[6].lt {
	pc = 0x82906FB8; continue 'dispatch;
	}
	// 82906FB4: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x82906FB8; continue 'dispatch;
            }
            0x82906FB8 => {
    //   block [0x82906FB8..0x82906FD4)
	// 82906FB8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82906FBC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82906FC0: 419A0014  beq cr6, 0x82906fd4
	if ctx.cr[6].eq {
	pc = 0x82906FD4; continue 'dispatch;
	}
	// 82906FC4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82906FC8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82906FCC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82906FD0: 4800000C  b 0x82906fdc
	pc = 0x82906FDC; continue 'dispatch;
            }
            0x82906FD4 => {
    //   block [0x82906FD4..0x82906FDC)
	// 82906FD4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82906FD8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82906FDC; continue 'dispatch;
            }
            0x82906FDC => {
    //   block [0x82906FDC..0x82906FE8)
	// 82906FDC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82906FE0: 4199FFB8  bgt cr6, 0x82906f98
	if ctx.cr[6].gt {
	pc = 0x82906F98; continue 'dispatch;
	}
	// 82906FE4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x82906FE8; continue 'dispatch;
            }
            0x82906FE8 => {
    //   block [0x82906FE8..0x82907004)
	// 82906FE8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82906FEC: 419A003C  beq cr6, 0x82907028
	if ctx.cr[6].eq {
	pc = 0x82907028; continue 'dispatch;
	}
	// 82906FF0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82906FF4: 2F0B0073  cmpwi cr6, r11, 0x73
	ctx.cr[6].compare_i32(ctx.r[11].s32, 115, &mut ctx.xer);
	// 82906FF8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82906FFC: 41990008  bgt cr6, 0x82907004
	if ctx.cr[6].gt {
	pc = 0x82907004; continue 'dispatch;
	}
	// 82907000: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x82907004; continue 'dispatch;
            }
            0x82907004 => {
    //   block [0x82907004..0x82907028)
	// 82907004: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82907008: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290700C: 409A001C  bne cr6, 0x82907028
	if !ctx.cr[6].eq {
	pc = 0x82907028; continue 'dispatch;
	}
	// 82907010: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82907014: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82907018: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8290701C: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82907020: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82907024: 48000018  b 0x8290703c
	pc = 0x8290703C; continue 'dispatch;
            }
            0x82907028 => {
    //   block [0x82907028..0x82907038)
	// 82907028: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8290702C: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82907030: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82907034: 48000008  b 0x8290703c
	pc = 0x8290703C; continue 'dispatch;
            }
            0x82907038 => {
    //   block [0x82907038..0x8290703C)
	// 82907038: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8290703C; continue 'dispatch;
            }
            0x8290703C => {
    //   block [0x8290703C..0x82907110)
	// 8290703C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82907040: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82907044: 419A00CC  beq cr6, 0x82907110
	if ctx.cr[6].eq {
	pc = 0x82907110; continue 'dispatch;
	}
	// 82907048: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8290704C: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82907050: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82907054: 409A00BC  bne cr6, 0x82907110
	if !ctx.cr[6].eq {
	pc = 0x82907110; continue 'dispatch;
	}
	// 82907058: 8085007C  lwz r4, 0x7c(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(124 as u32) ) } as u64;
	// 8290705C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82907060: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82907064: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82907068: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8290706C: 4E800421  bctrl
	ctx.lr = 0x82907070;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82907070: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 82907074: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
            }
            0x82907110 => {
    //   block [0x82907110..0x8290711C)
	// 82907110: 3AF70004  addi r23, r23, 4
	ctx.r[23].s64 = ctx.r[23].s64 + 4;
	// 82907114: 7F17B040  cmplw cr6, r23, r22
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[22].u32, &mut ctx.xer);
	// 82907118: 409AFE18  bne cr6, 0x82906f30
	if !ctx.cr[6].eq {
	pc = 0x82906F30; continue 'dispatch;
	}
	pc = 0x8290711C; continue 'dispatch;
            }
            0x8290711C => {
    //   block [0x8290711C..0x8290712C)
	// 8290711C: 2B150000  cmplwi cr6, r21, 0
	ctx.cr[6].compare_u32(ctx.r[21].u32, 0 as u32, &mut ctx.xer);
	// 82907120: 419A000C  beq cr6, 0x8290712c
	if ctx.cr[6].eq {
	pc = 0x8290712C; continue 'dispatch;
	}
	// 82907124: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82907128: 4B914C11  bl 0x8221bd38
	ctx.lr = 0x8290712C;
	sub_8221BD38(ctx, base);
	pc = 0x8290712C; continue 'dispatch;
            }
            0x8290712C => {
    //   block [0x8290712C..0x82907134)
	// 8290712C: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82907130: 483A230C  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82907138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82907138 size=92
    let mut pc: u32 = 0x82907138;
    'dispatch: loop {
        match pc {
            0x82907138 => {
    //   block [0x82907138..0x82907180)
	// 82907138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290713C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82907140: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82907144: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82907148: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290714C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82907150: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 82907154: 388BCB44  addi r4, r11, -0x34bc
	ctx.r[4].s64 = ctx.r[11].s64 + -13500;
	// 82907158: 4BD6B7E1  bl 0x82672938
	ctx.lr = 0x8290715C;
	sub_82672938(ctx, base);
	// 8290715C: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82907160: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82907164: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82907168: 915F0050  stw r10, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8290716C: 419A0014  beq cr6, 0x82907180
	if ctx.cr[6].eq {
	pc = 0x82907180; continue 'dispatch;
	}
	// 82907170: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82907174: 4BD1EDAD  bl 0x82625f20
	ctx.lr = 0x82907178;
	sub_82625F20(ctx, base);
	// 82907178: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 8290717C: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x82907180; continue 'dispatch;
            }
            0x82907180 => {
    //   block [0x82907180..0x82907194)
	// 82907180: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82907184: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82907188: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290718C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82907190: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82907198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82907198 size=108
    let mut pc: u32 = 0x82907198;
    'dispatch: loop {
        match pc {
            0x82907198 => {
    //   block [0x82907198..0x829071D4)
	// 82907198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290719C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829071A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829071A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829071A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829071AC: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 829071B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829071B4: 989F001C  stb r4, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[4].u8 ) };
	// 829071B8: 419A001C  beq cr6, 0x829071d4
	if ctx.cr[6].eq {
	pc = 0x829071D4; continue 'dispatch;
	}
	// 829071BC: 4800004D  bl 0x82907208
	ctx.lr = 0x829071C0;
	sub_82907208(ctx, base);
	// 829071C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829071C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829071C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829071CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829071D0: 4E800020  blr
	return;
            }
            0x829071D4 => {
    //   block [0x829071D4..0x829071F0)
	// 829071D4: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 829071D8: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 829071DC: 419A0014  beq cr6, 0x829071f0
	if ctx.cr[6].eq {
	pc = 0x829071F0; continue 'dispatch;
	}
	// 829071E0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829071E4: 4BD1ED3D  bl 0x82625f20
	ctx.lr = 0x829071E8;
	sub_82625F20(ctx, base);
	// 829071E8: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 829071EC: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x829071F0; continue 'dispatch;
            }
            0x829071F0 => {
    //   block [0x829071F0..0x82907204)
	// 829071F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829071F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829071F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829071FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82907200: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82907208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82907208 size=220
    let mut pc: u32 = 0x82907208;
    'dispatch: loop {
        match pc {
            0x82907208 => {
    //   block [0x82907208..0x829072D0)
	// 82907208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290720C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82907210: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82907214: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82907218: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290721C: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82907220: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82907224: 409A00AC  bne cr6, 0x829072d0
	if !ctx.cr[6].eq {
	pc = 0x829072D0; continue 'dispatch;
	}
	// 82907228: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8290722C: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 82907230: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82907234: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82907238: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8290723C: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82907240: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82907244: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 82907248: C1A8CDBC  lfs f13, -0x3244(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-12868 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8290724C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82907250: 39210054  addi r9, r1, 0x54
	ctx.r[9].s64 = ctx.r[1].s64 + 84;
	// 82907254: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82907258: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	pc = 0x829072D0; continue 'dispatch;
            }
            0x829072D0 => {
    //   block [0x829072D0..0x829072E4)
	// 829072D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829072D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829072D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829072DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829072E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829072E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829072E8 size=244
    let mut pc: u32 = 0x829072E8;
    'dispatch: loop {
        match pc {
            0x829072E8 => {
    //   block [0x829072E8..0x829073DC)
	// 829072E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829072EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829072F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829072F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829072F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829072FC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82907300: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82907304: 3BCB5380  addi r30, r11, 0x5380
	ctx.r[30].s64 = ctx.r[11].s64 + 21376;
	// 82907308: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8290730C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82907310: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82907314: 4B925BBD  bl 0x8222ced0
	ctx.lr = 0x82907318;
	sub_8222CED0(ctx, base);
	// 82907318: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290731C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82907320: 480000C1  bl 0x829073e0
	ctx.lr = 0x82907324;
	sub_829073E0(ctx, base);
	// 82907324: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82907328: 4B90DAB1  bl 0x82214dd8
	ctx.lr = 0x8290732C;
	sub_82214DD8(ctx, base);
	// 8290732C: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82907330: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82907334: 388A3990  addi r4, r10, 0x3990
	ctx.r[4].s64 = ctx.r[10].s64 + 14736;
	// 82907338: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8290733C: 4B925B95  bl 0x8222ced0
	ctx.lr = 0x82907340;
	sub_8222CED0(ctx, base);
	// 82907340: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82907344: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82907348: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290734C: 4B925B85  bl 0x8222ced0
	ctx.lr = 0x82907350;
	sub_8222CED0(ctx, base);
	// 82907350: 3D20822D  lis r9, -0x7dd3
	ctx.r[9].s64 = -2110980096;
	// 82907354: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82907358: 38C92948  addi r6, r9, 0x2948
	ctx.r[6].s64 = ctx.r[9].s64 + 10568;
	// 8290735C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82907360: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82907364: 480002C5  bl 0x82907628
	ctx.lr = 0x82907368;
	sub_82907628(ctx, base);
	// 82907368: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290736C: 4B90DA6D  bl 0x82214dd8
	ctx.lr = 0x82907370;
	sub_82214DD8(ctx, base);
	// 82907370: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82907374: 4B90DA65  bl 0x82214dd8
	ctx.lr = 0x82907378;
	sub_82214DD8(ctx, base);
	// 82907378: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 8290737C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82907380: 38883AD4  addi r4, r8, 0x3ad4
	ctx.r[4].s64 = ctx.r[8].s64 + 15060;
	// 82907384: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82907388: 4B925B49  bl 0x8222ced0
	ctx.lr = 0x8290738C;
	sub_8222CED0(ctx, base);
	// 8290738C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82907390: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82907394: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82907398: 4B925B39  bl 0x8222ced0
	ctx.lr = 0x8290739C;
	sub_8222CED0(ctx, base);
	// 8290739C: 3CE08290  lis r7, -0x7d70
	ctx.r[7].s64 = -2104492032;
	// 829073A0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829073A4: 38C77198  addi r6, r7, 0x7198
	ctx.r[6].s64 = ctx.r[7].s64 + 29080;
	// 829073A8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 829073AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829073B0: 48000481  bl 0x82907830
	ctx.lr = 0x829073B4;
	sub_82907830(ctx, base);
	// 829073B4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829073B8: 4B90DA21  bl 0x82214dd8
	ctx.lr = 0x829073BC;
	sub_82214DD8(ctx, base);
	// 829073BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829073C0: 4B90DA19  bl 0x82214dd8
	ctx.lr = 0x829073C4;
	sub_82214DD8(ctx, base);
	// 829073C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829073C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829073CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829073D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829073D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829073D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829073E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829073E0 size=584
    let mut pc: u32 = 0x829073E0;
    'dispatch: loop {
        match pc {
            0x829073E0 => {
    //   block [0x829073E0..0x82907408)
	// 829073E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829073E4: 483A201D  bl 0x82ca9400
	ctx.lr = 0x829073E8;
	sub_82CA93D0(ctx, base);
	// 829073E8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829073EC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 829073F0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 829073F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829073F8: 409A0010  bne cr6, 0x82907408
	if !ctx.cr[6].eq {
	pc = 0x82907408; continue 'dispatch;
	}
	// 829073FC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82907400: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 82907404: 48000008  b 0x8290740c
	pc = 0x8290740C; continue 'dispatch;
            }
            0x82907408 => {
    //   block [0x82907408..0x8290740C)
	// 82907408: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8290740C; continue 'dispatch;
            }
            0x8290740C => {
    //   block [0x8290740C..0x82907484)
	// 8290740C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82907410: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82907414: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82907418: 4BAC71A9  bl 0x823ce5c0
	ctx.lr = 0x8290741C;
	sub_823CE5C0(ctx, base);
	// 8290741C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82907420: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82907424: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82907428: 4BAC6DD9  bl 0x823ce200
	ctx.lr = 0x8290742C;
	sub_823CE200(ctx, base);
	// 8290742C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82907430: 4B8B06E9  bl 0x821b7b18
	ctx.lr = 0x82907434;
	sub_821B7B18(ctx, base);
	// 82907434: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82907438: 4B917E21  bl 0x8221f258
	ctx.lr = 0x8290743C;
	sub_8221F258(ctx, base);
	// 8290743C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82907440: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82907444: 419A0040  beq cr6, 0x82907484
	if ctx.cr[6].eq {
	pc = 0x82907484; continue 'dispatch;
	}
	// 82907448: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 8290744C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82907450: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 82907454: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82907458: 4B917E01  bl 0x8221f258
	ctx.lr = 0x8290745C;
	sub_8221F258(ctx, base);
	// 8290745C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82907460: 419A0028  beq cr6, 0x82907488
	if ctx.cr[6].eq {
	pc = 0x82907488; continue 'dispatch;
	}
	// 82907464: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 82907468: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 8290746C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82907470: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 82907474: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82907478: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8290747C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82907480: 4800000C  b 0x8290748c
	pc = 0x8290748C; continue 'dispatch;
            }
            0x82907484 => {
    //   block [0x82907484..0x82907488)
	// 82907484: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82907488; continue 'dispatch;
            }
            0x82907488 => {
    //   block [0x82907488..0x8290748C)
	// 82907488: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x8290748C; continue 'dispatch;
            }
            0x8290748C => {
    //   block [0x8290748C..0x82907590)
	// 8290748C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82907490: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82907494: 419A00FC  beq cr6, 0x82907590
	if ctx.cr[6].eq {
	pc = 0x82907590; continue 'dispatch;
	}
	// 82907498: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290749C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 829074A0: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829074A4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829074A8: 4B921C61  bl 0x82229108
	ctx.lr = 0x829074AC;
	sub_82229108(ctx, base);
	// 829074AC: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 829074B0: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 829074B4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829074B8: 3BCB7A38  addi r30, r11, 0x7a38
	ctx.r[30].s64 = ctx.r[11].s64 + 31288;
	// 829074BC: 4B9203C5  bl 0x82227880
	ctx.lr = 0x829074C0;
	sub_82227880(ctx, base);
	// 829074C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829074C4: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 829074C8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829074CC: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 829074D0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829074D4: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 829074D8: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829074DC: 4B8935A5  bl 0x8219aa80
	ctx.lr = 0x829074E0;
	sub_8219AA80(ctx, base);
	// 829074E0: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 829074E4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 829074E8: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 829074EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829074F0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829074F4: 4BAC6F2D  bl 0x823ce420
	ctx.lr = 0x829074F8;
	sub_823CE420(ctx, base);
	// 829074F8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829074FC: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 82907500: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82907504: 4811D1C5  bl 0x82a246c8
	ctx.lr = 0x82907508;
	sub_82A246C8(ctx, base);
	// 82907508: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290750C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 82907510: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 82907514: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82907518: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290751C: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82907520: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82907524: 4B921BE5  bl 0x82229108
	ctx.lr = 0x82907528;
	sub_82229108(ctx, base);
	// 82907528: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 8290752C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82907530: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82907534: 3BEB6CF0  addi r31, r11, 0x6cf0
	ctx.r[31].s64 = ctx.r[11].s64 + 27888;
	// 82907538: 4B920349  bl 0x82227880
	ctx.lr = 0x8290753C;
	sub_82227880(ctx, base);
	// 8290753C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82907540: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 82907544: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82907548: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 8290754C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82907550: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82907554: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82907558: 4B893529  bl 0x8219aa80
	ctx.lr = 0x8290755C;
	sub_8219AA80(ctx, base);
	// 8290755C: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 82907560: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82907564: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 82907568: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290756C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82907570: 4BAC6EB1  bl 0x823ce420
	ctx.lr = 0x82907574;
	sub_823CE420(ctx, base);
	// 82907574: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82907578: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 8290757C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82907580: 4811D149  bl 0x82a246c8
	ctx.lr = 0x82907584;
	sub_82A246C8(ctx, base);
	// 82907584: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82907588: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 8290758C: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	pc = 0x82907590; continue 'dispatch;
            }
            0x82907590 => {
    //   block [0x82907590..0x829075A0)
	// 82907590: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82907594: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82907598: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 8290759C: 419A0020  beq cr6, 0x829075bc
	if ctx.cr[6].eq {
	pc = 0x829075BC; continue 'dispatch;
	}
	pc = 0x829075A0; continue 'dispatch;
            }
            0x829075A0 => {
    //   block [0x829075A0..0x829075BC)
	// 829075A0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 829075A4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829075A8: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 829075AC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829075B0: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829075B4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829075B8: 4082FFE8  bne 0x829075a0
	if !ctx.cr[0].eq {
	pc = 0x829075A0; continue 'dispatch;
	}
	pc = 0x829075BC; continue 'dispatch;
            }
            0x829075BC => {
    //   block [0x829075BC..0x829075DC)
	// 829075BC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 829075C0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 829075C4: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 829075C8: 4B9EE381  bl 0x822f5948
	ctx.lr = 0x829075CC;
	sub_822F5948(ctx, base);
	// 829075CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829075D0: 4B8B0549  bl 0x821b7b18
	ctx.lr = 0x829075D4;
	sub_821B7B18(ctx, base);
	// 829075D4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829075D8: 419A0040  beq cr6, 0x82907618
	if ctx.cr[6].eq {
	pc = 0x82907618; continue 'dispatch;
	}
	pc = 0x829075DC; continue 'dispatch;
            }
            0x829075DC => {
    //   block [0x829075DC..0x82907618)
	// 829075DC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 829075E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829075E4: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 829075E8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829075EC: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829075F0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829075F4: 4082FFE8  bne 0x829075dc
	if !ctx.cr[0].eq {
	pc = 0x829075DC; continue 'dispatch;
	}
	// 829075F8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829075FC: 409A001C  bne cr6, 0x82907618
	if !ctx.cr[6].eq {
	pc = 0x82907618; continue 'dispatch;
	}
	// 82907600: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82907604: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82907608: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8290760C: 4E800421  bctrl
	ctx.lr = 0x82907610;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82907610: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82907614: 4B914725  bl 0x8221bd38
	ctx.lr = 0x82907618;
	sub_8221BD38(ctx, base);
            }
            0x82907618 => {
    //   block [0x82907618..0x82907628)
	// 82907618: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290761C: 4B8B04FD  bl 0x821b7b18
	ctx.lr = 0x82907620;
	sub_821B7B18(ctx, base);
	// 82907620: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82907624: 483A1E2C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82907628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82907628 size=516
    let mut pc: u32 = 0x82907628;
    'dispatch: loop {
        match pc {
            0x82907628 => {
    //   block [0x82907628..0x82907664)
	// 82907628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290762C: 483A1DD1  bl 0x82ca93fc
	ctx.lr = 0x82907630;
	sub_82CA93D0(ctx, base);
	// 82907630: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82907634: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82907638: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 8290763C: 3D40822D  lis r10, -0x7dd3
	ctx.r[10].s64 = -2110980096;
	// 82907640: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 82907644: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82907648: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290764C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82907650: 3BAA2948  addi r29, r10, 0x2948
	ctx.r[29].s64 = ctx.r[10].s64 + 10568;
	// 82907654: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82907658: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 8290765C: 419A0008  beq cr6, 0x82907664
	if ctx.cr[6].eq {
	pc = 0x82907664; continue 'dispatch;
	}
	// 82907660: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82907664; continue 'dispatch;
            }
            0x82907664 => {
    //   block [0x82907664..0x829076F8)
	// 82907664: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82907668: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8290766C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82907670: 4BAC6F51  bl 0x823ce5c0
	ctx.lr = 0x82907674;
	sub_823CE5C0(ctx, base);
	// 82907674: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82907678: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8290767C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82907680: 4BAC6A91  bl 0x823ce110
	ctx.lr = 0x82907684;
	sub_823CE110(ctx, base);
	// 82907684: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82907688: 4B8B0491  bl 0x821b7b18
	ctx.lr = 0x8290768C;
	sub_821B7B18(ctx, base);
	// 8290768C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82907690: 4B917BC9  bl 0x8221f258
	ctx.lr = 0x82907694;
	sub_8221F258(ctx, base);
	// 82907694: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82907698: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8290769C: 419A005C  beq cr6, 0x829076f8
	if ctx.cr[6].eq {
	pc = 0x829076F8; continue 'dispatch;
	}
	// 829076A0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 829076A4: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 829076A8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829076AC: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 829076B0: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829076B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829076B8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829076BC: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 829076C0: 4B8E8B81  bl 0x821f0240
	ctx.lr = 0x829076C4;
	sub_821F0240(ctx, base);
	// 829076C4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 829076C8: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 829076CC: 4B917B8D  bl 0x8221f258
	ctx.lr = 0x829076D0;
	sub_8221F258(ctx, base);
	// 829076D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829076D4: 419A0028  beq cr6, 0x829076fc
	if ctx.cr[6].eq {
	pc = 0x829076FC; continue 'dispatch;
	}
	// 829076D8: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 829076DC: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 829076E0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829076E4: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 829076E8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829076EC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829076F0: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 829076F4: 4800000C  b 0x82907700
	pc = 0x82907700; continue 'dispatch;
            }
            0x829076F8 => {
    //   block [0x829076F8..0x829076FC)
	// 829076F8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x829076FC; continue 'dispatch;
            }
            0x829076FC => {
    //   block [0x829076FC..0x82907700)
	// 829076FC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82907700; continue 'dispatch;
            }
            0x82907700 => {
    //   block [0x82907700..0x82907714)
	// 82907700: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82907704: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82907708: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290770C: 419A0008  beq cr6, 0x82907714
	if ctx.cr[6].eq {
	pc = 0x82907714; continue 'dispatch;
	}
	// 82907710: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82907714; continue 'dispatch;
            }
            0x82907714 => {
    //   block [0x82907714..0x82907794)
	// 82907714: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82907718: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290771C: 419A0078  beq cr6, 0x82907794
	if ctx.cr[6].eq {
	pc = 0x82907794; continue 'dispatch;
	}
	// 82907720: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82907724: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 82907728: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290772C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82907730: 4B9219D9  bl 0x82229108
	ctx.lr = 0x82907734;
	sub_82229108(ctx, base);
	// 82907734: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 82907738: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8290773C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82907740: 3BCB7A78  addi r30, r11, 0x7a78
	ctx.r[30].s64 = ctx.r[11].s64 + 31352;
	// 82907744: 4B92013D  bl 0x82227880
	ctx.lr = 0x82907748;
	sub_82227880(ctx, base);
	// 82907748: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8290774C: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 82907750: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82907754: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 82907758: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8290775C: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82907760: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82907764: 4B89331D  bl 0x8219aa80
	ctx.lr = 0x82907768;
	sub_8219AA80(ctx, base);
	// 82907768: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290776C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82907770: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82907774: 4BAC6CAD  bl 0x823ce420
	ctx.lr = 0x82907778;
	sub_823CE420(ctx, base);
	// 82907778: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290777C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 82907780: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82907784: 4811CF45  bl 0x82a246c8
	ctx.lr = 0x82907788;
	sub_82A246C8(ctx, base);
	// 82907788: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290778C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 82907790: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x82907794; continue 'dispatch;
            }
            0x82907794 => {
    //   block [0x82907794..0x829077A4)
	// 82907794: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82907798: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8290779C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 829077A0: 419A0020  beq cr6, 0x829077c0
	if ctx.cr[6].eq {
	pc = 0x829077C0; continue 'dispatch;
	}
	pc = 0x829077A4; continue 'dispatch;
            }
            0x829077A4 => {
    //   block [0x829077A4..0x829077C0)
	// 829077A4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 829077A8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829077AC: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 829077B0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829077B4: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829077B8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829077BC: 4082FFE8  bne 0x829077a4
	if !ctx.cr[0].eq {
	pc = 0x829077A4; continue 'dispatch;
	}
	pc = 0x829077C0; continue 'dispatch;
            }
            0x829077C0 => {
    //   block [0x829077C0..0x829077E0)
	// 829077C0: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829077C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829077C8: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 829077CC: 4B9EE17D  bl 0x822f5948
	ctx.lr = 0x829077D0;
	sub_822F5948(ctx, base);
	// 829077D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829077D4: 4B8B0345  bl 0x821b7b18
	ctx.lr = 0x829077D8;
	sub_821B7B18(ctx, base);
	// 829077D8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829077DC: 419A0040  beq cr6, 0x8290781c
	if ctx.cr[6].eq {
	pc = 0x8290781C; continue 'dispatch;
	}
	pc = 0x829077E0; continue 'dispatch;
            }
            0x829077E0 => {
    //   block [0x829077E0..0x8290781C)
	// 829077E0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 829077E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829077E8: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 829077EC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829077F0: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829077F4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829077F8: 4082FFE8  bne 0x829077e0
	if !ctx.cr[0].eq {
	pc = 0x829077E0; continue 'dispatch;
	}
	// 829077FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82907800: 409A001C  bne cr6, 0x8290781c
	if !ctx.cr[6].eq {
	pc = 0x8290781C; continue 'dispatch;
	}
	// 82907804: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82907808: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290780C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82907810: 4E800421  bctrl
	ctx.lr = 0x82907814;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82907814: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82907818: 4B914521  bl 0x8221bd38
	ctx.lr = 0x8290781C;
	sub_8221BD38(ctx, base);
            }
            0x8290781C => {
    //   block [0x8290781C..0x8290782C)
	// 8290781C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82907820: 4B8B02F9  bl 0x821b7b18
	ctx.lr = 0x82907824;
	sub_821B7B18(ctx, base);
	// 82907824: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82907828: 483A1C24  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82907830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82907830 size=516
    let mut pc: u32 = 0x82907830;
    'dispatch: loop {
        match pc {
            0x82907830 => {
    //   block [0x82907830..0x8290786C)
	// 82907830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82907834: 483A1BC9  bl 0x82ca93fc
	ctx.lr = 0x82907838;
	sub_82CA93D0(ctx, base);
	// 82907838: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290783C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82907840: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 82907844: 3D408290  lis r10, -0x7d70
	ctx.r[10].s64 = -2104492032;
	// 82907848: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 8290784C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82907850: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82907854: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82907858: 3BAA7198  addi r29, r10, 0x7198
	ctx.r[29].s64 = ctx.r[10].s64 + 29080;
	// 8290785C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82907860: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82907864: 419A0008  beq cr6, 0x8290786c
	if ctx.cr[6].eq {
	pc = 0x8290786C; continue 'dispatch;
	}
	// 82907868: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8290786C; continue 'dispatch;
            }
            0x8290786C => {
    //   block [0x8290786C..0x82907900)
	// 8290786C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82907870: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82907874: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82907878: 4BAC6D49  bl 0x823ce5c0
	ctx.lr = 0x8290787C;
	sub_823CE5C0(ctx, base);
	// 8290787C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82907880: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82907884: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82907888: 4BAC6889  bl 0x823ce110
	ctx.lr = 0x8290788C;
	sub_823CE110(ctx, base);
	// 8290788C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82907890: 4B8B0289  bl 0x821b7b18
	ctx.lr = 0x82907894;
	sub_821B7B18(ctx, base);
	// 82907894: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82907898: 4B9179C1  bl 0x8221f258
	ctx.lr = 0x8290789C;
	sub_8221F258(ctx, base);
	// 8290789C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829078A0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829078A4: 419A005C  beq cr6, 0x82907900
	if ctx.cr[6].eq {
	pc = 0x82907900; continue 'dispatch;
	}
	// 829078A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 829078AC: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 829078B0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829078B4: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 829078B8: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829078BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829078C0: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829078C4: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 829078C8: 4B8E8979  bl 0x821f0240
	ctx.lr = 0x829078CC;
	sub_821F0240(ctx, base);
	// 829078CC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 829078D0: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 829078D4: 4B917985  bl 0x8221f258
	ctx.lr = 0x829078D8;
	sub_8221F258(ctx, base);
	// 829078D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829078DC: 419A0028  beq cr6, 0x82907904
	if ctx.cr[6].eq {
	pc = 0x82907904; continue 'dispatch;
	}
	// 829078E0: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 829078E4: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 829078E8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829078EC: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 829078F0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829078F4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829078F8: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 829078FC: 4800000C  b 0x82907908
	pc = 0x82907908; continue 'dispatch;
            }
            0x82907900 => {
    //   block [0x82907900..0x82907904)
	// 82907900: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x82907904; continue 'dispatch;
            }
            0x82907904 => {
    //   block [0x82907904..0x82907908)
	// 82907904: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82907908; continue 'dispatch;
            }
            0x82907908 => {
    //   block [0x82907908..0x8290791C)
	// 82907908: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290790C: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82907910: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82907914: 419A0008  beq cr6, 0x8290791c
	if ctx.cr[6].eq {
	pc = 0x8290791C; continue 'dispatch;
	}
	// 82907918: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8290791C; continue 'dispatch;
            }
            0x8290791C => {
    //   block [0x8290791C..0x8290799C)
	// 8290791C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82907920: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82907924: 419A0078  beq cr6, 0x8290799c
	if ctx.cr[6].eq {
	pc = 0x8290799C; continue 'dispatch;
	}
	// 82907928: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290792C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 82907930: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82907934: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82907938: 4B9217D1  bl 0x82229108
	ctx.lr = 0x8290793C;
	sub_82229108(ctx, base);
	// 8290793C: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 82907940: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82907944: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82907948: 3BCB7BF0  addi r30, r11, 0x7bf0
	ctx.r[30].s64 = ctx.r[11].s64 + 31728;
	// 8290794C: 4B91FF35  bl 0x82227880
	ctx.lr = 0x82907950;
	sub_82227880(ctx, base);
	// 82907950: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82907954: 3D40827C  lis r10, -0x7d84
	ctx.r[10].s64 = -2105802752;
	// 82907958: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8290795C: 388AD6C8  addi r4, r10, -0x2938
	ctx.r[4].s64 = ctx.r[10].s64 + -10552;
	// 82907960: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82907964: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82907968: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 8290796C: 4B893115  bl 0x8219aa80
	ctx.lr = 0x82907970;
	sub_8219AA80(ctx, base);
	// 82907970: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82907974: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82907978: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8290797C: 4BAC6AA5  bl 0x823ce420
	ctx.lr = 0x82907980;
	sub_823CE420(ctx, base);
	// 82907980: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82907984: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 82907988: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8290798C: 4811CD3D  bl 0x82a246c8
	ctx.lr = 0x82907990;
	sub_82A246C8(ctx, base);
	// 82907990: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82907994: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 82907998: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x8290799C; continue 'dispatch;
            }
            0x8290799C => {
    //   block [0x8290799C..0x829079AC)
	// 8290799C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829079A0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829079A4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 829079A8: 419A0020  beq cr6, 0x829079c8
	if ctx.cr[6].eq {
	pc = 0x829079C8; continue 'dispatch;
	}
	pc = 0x829079AC; continue 'dispatch;
            }
            0x829079AC => {
    //   block [0x829079AC..0x829079C8)
	// 829079AC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 829079B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829079B4: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 829079B8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829079BC: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829079C0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829079C4: 4082FFE8  bne 0x829079ac
	if !ctx.cr[0].eq {
	pc = 0x829079AC; continue 'dispatch;
	}
	pc = 0x829079C8; continue 'dispatch;
            }
            0x829079C8 => {
    //   block [0x829079C8..0x829079E8)
	// 829079C8: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829079CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829079D0: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 829079D4: 4B9EDF75  bl 0x822f5948
	ctx.lr = 0x829079D8;
	sub_822F5948(ctx, base);
	// 829079D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829079DC: 4B8B013D  bl 0x821b7b18
	ctx.lr = 0x829079E0;
	sub_821B7B18(ctx, base);
	// 829079E0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829079E4: 419A0040  beq cr6, 0x82907a24
	if ctx.cr[6].eq {
	pc = 0x82907A24; continue 'dispatch;
	}
	pc = 0x829079E8; continue 'dispatch;
            }
            0x829079E8 => {
    //   block [0x829079E8..0x82907A24)
	// 829079E8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 829079EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829079F0: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 829079F4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829079F8: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829079FC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82907A00: 4082FFE8  bne 0x829079e8
	if !ctx.cr[0].eq {
	pc = 0x829079E8; continue 'dispatch;
	}
	// 82907A04: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82907A08: 409A001C  bne cr6, 0x82907a24
	if !ctx.cr[6].eq {
	pc = 0x82907A24; continue 'dispatch;
	}
	// 82907A0C: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82907A10: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82907A14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82907A18: 4E800421  bctrl
	ctx.lr = 0x82907A1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82907A1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82907A20: 4B914319  bl 0x8221bd38
	ctx.lr = 0x82907A24;
	sub_8221BD38(ctx, base);
            }
            0x82907A24 => {
    //   block [0x82907A24..0x82907A34)
	// 82907A24: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82907A28: 4B8B00F1  bl 0x821b7b18
	ctx.lr = 0x82907A2C;
	sub_821B7B18(ctx, base);
	// 82907A2C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82907A30: 483A1A1C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82907A38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82907A38 size=56
    let mut pc: u32 = 0x82907A38;
    'dispatch: loop {
        match pc {
            0x82907A38 => {
    //   block [0x82907A38..0x82907A54)
	// 82907A38: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82907A3C: 419A0018  beq cr6, 0x82907a54
	if ctx.cr[6].eq {
	pc = 0x82907A54; continue 'dispatch;
	}
	// 82907A40: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 82907A44: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82907A48: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82907A4C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82907A50: 409A0008  bne cr6, 0x82907a58
	if !ctx.cr[6].eq {
	pc = 0x82907A58; continue 'dispatch;
	}
	pc = 0x82907A54; continue 'dispatch;
            }
            0x82907A54 => {
    //   block [0x82907A54..0x82907A58)
	// 82907A54: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82907A58; continue 'dispatch;
            }
            0x82907A58 => {
    //   block [0x82907A58..0x82907A70)
	// 82907A58: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82907A5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82907A60: 419A0010  beq cr6, 0x82907a70
	if ctx.cr[6].eq {
		sub_82907A70(ctx, base);
		return;
	}
	// 82907A64: 81640030  lwz r11, 0x30(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 82907A68: 55636FFE  rlwinm r3, r11, 0xd, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 82907A6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82907A70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82907A70 size=8
    let mut pc: u32 = 0x82907A70;
    'dispatch: loop {
        match pc {
            0x82907A70 => {
    //   block [0x82907A70..0x82907A78)
	// 82907A70: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82907A74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82907A78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82907A78 size=372
    let mut pc: u32 = 0x82907A78;
    'dispatch: loop {
        match pc {
            0x82907A78 => {
    //   block [0x82907A78..0x82907AA0)
	// 82907A78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82907A7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82907A80: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82907A84: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82907A88: 419A0018  beq cr6, 0x82907aa0
	if ctx.cr[6].eq {
	pc = 0x82907AA0; continue 'dispatch;
	}
	// 82907A8C: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 82907A90: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82907A94: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82907A98: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82907A9C: 409A0008  bne cr6, 0x82907aa4
	if !ctx.cr[6].eq {
	pc = 0x82907AA4; continue 'dispatch;
	}
	pc = 0x82907AA0; continue 'dispatch;
            }
            0x82907AA0 => {
    //   block [0x82907AA0..0x82907AA4)
	// 82907AA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82907AA4; continue 'dispatch;
            }
            0x82907AA4 => {
    //   block [0x82907AA4..0x82907AEC)
	// 82907AA4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82907AA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82907AAC: 419A012C  beq cr6, 0x82907bd8
	if ctx.cr[6].eq {
	pc = 0x82907BD8; continue 'dispatch;
	}
	// 82907AB0: 81440030  lwz r10, 0x30(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 82907AB4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82907AB8: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 82907ABC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82907AC0: 419A00E8  beq cr6, 0x82907ba8
	if ctx.cr[6].eq {
	pc = 0x82907BA8; continue 'dispatch;
	}
	// 82907AC4: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 82907AC8: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 82907ACC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82907AD0: 419A001C  beq cr6, 0x82907aec
	if ctx.cr[6].eq {
	pc = 0x82907AEC; continue 'dispatch;
	}
	// 82907AD4: 896B0073  lbz r11, 0x73(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(115 as u32) ) } as u64;
	// 82907AD8: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 82907ADC: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82907AE0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82907AE4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82907AE8: 480000C4  b 0x82907bac
	pc = 0x82907BAC; continue 'dispatch;
            }
            0x82907AEC => {
    //   block [0x82907AEC..0x82907B08)
	// 82907AEC: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 82907AF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82907AF4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82907AF8: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82907AFC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82907B00: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82907B04: 40810054  ble 0x82907b58
	if !ctx.cr[0].gt {
	pc = 0x82907B58; continue 'dispatch;
	}
	pc = 0x82907B08; continue 'dispatch;
            }
            0x82907B08 => {
    //   block [0x82907B08..0x82907B28)
	// 82907B08: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82907B0C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82907B10: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82907B14: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82907B18: 2F070073  cmpwi cr6, r7, 0x73
	ctx.cr[6].compare_i32(ctx.r[7].s32, 115, &mut ctx.xer);
	// 82907B1C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82907B20: 41980008  blt cr6, 0x82907b28
	if ctx.cr[6].lt {
	pc = 0x82907B28; continue 'dispatch;
	}
	// 82907B24: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x82907B28; continue 'dispatch;
            }
            0x82907B28 => {
    //   block [0x82907B28..0x82907B44)
	// 82907B28: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82907B2C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82907B30: 419A0014  beq cr6, 0x82907b44
	if ctx.cr[6].eq {
	pc = 0x82907B44; continue 'dispatch;
	}
	// 82907B34: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82907B38: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82907B3C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82907B40: 4800000C  b 0x82907b4c
	pc = 0x82907B4C; continue 'dispatch;
            }
            0x82907B44 => {
    //   block [0x82907B44..0x82907B4C)
	// 82907B44: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82907B48: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82907B4C; continue 'dispatch;
            }
            0x82907B4C => {
    //   block [0x82907B4C..0x82907B58)
	// 82907B4C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82907B50: 4199FFB8  bgt cr6, 0x82907b08
	if ctx.cr[6].gt {
	pc = 0x82907B08; continue 'dispatch;
	}
	// 82907B54: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82907B58; continue 'dispatch;
            }
            0x82907B58 => {
    //   block [0x82907B58..0x82907B74)
	// 82907B58: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82907B5C: 419A003C  beq cr6, 0x82907b98
	if ctx.cr[6].eq {
	pc = 0x82907B98; continue 'dispatch;
	}
	// 82907B60: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82907B64: 2F0B0073  cmpwi cr6, r11, 0x73
	ctx.cr[6].compare_i32(ctx.r[11].s32, 115, &mut ctx.xer);
	// 82907B68: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82907B6C: 41990008  bgt cr6, 0x82907b74
	if ctx.cr[6].gt {
	pc = 0x82907B74; continue 'dispatch;
	}
	// 82907B70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82907B74; continue 'dispatch;
            }
            0x82907B74 => {
    //   block [0x82907B74..0x82907B98)
	// 82907B74: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82907B78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82907B7C: 409A001C  bne cr6, 0x82907b98
	if !ctx.cr[6].eq {
	pc = 0x82907B98; continue 'dispatch;
	}
	// 82907B80: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82907B84: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82907B88: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82907B8C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82907B90: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82907B94: 48000018  b 0x82907bac
	pc = 0x82907BAC; continue 'dispatch;
            }
            0x82907B98 => {
    //   block [0x82907B98..0x82907BA8)
	// 82907B98: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82907B9C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82907BA0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82907BA4: 48000008  b 0x82907bac
	pc = 0x82907BAC; continue 'dispatch;
            }
            0x82907BA8 => {
    //   block [0x82907BA8..0x82907BAC)
	// 82907BA8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82907BAC; continue 'dispatch;
            }
            0x82907BAC => {
    //   block [0x82907BAC..0x82907BD8)
	// 82907BAC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82907BB0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82907BB4: 419A0024  beq cr6, 0x82907bd8
	if ctx.cr[6].eq {
	pc = 0x82907BD8; continue 'dispatch;
	}
	// 82907BB8: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82907BBC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82907BC0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82907BC4: 4E800421  bctrl
	ctx.lr = 0x82907BC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82907BC8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82907BCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82907BD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82907BD4: 4E800020  blr
	return;
            }
            0x82907BD8 => {
    //   block [0x82907BD8..0x82907BEC)
	// 82907BD8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82907BDC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82907BE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82907BE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82907BE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82907BF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82907BF0 size=376
    let mut pc: u32 = 0x82907BF0;
    'dispatch: loop {
        match pc {
            0x82907BF0 => {
    //   block [0x82907BF0..0x82907C1C)
	// 82907BF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82907BF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82907BF8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82907BFC: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82907C00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82907C04: 419A0018  beq cr6, 0x82907c1c
	if ctx.cr[6].eq {
	pc = 0x82907C1C; continue 'dispatch;
	}
	// 82907C08: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 82907C0C: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82907C10: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82907C14: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82907C18: 409A0008  bne cr6, 0x82907c20
	if !ctx.cr[6].eq {
	pc = 0x82907C20; continue 'dispatch;
	}
	pc = 0x82907C1C; continue 'dispatch;
            }
            0x82907C1C => {
    //   block [0x82907C1C..0x82907C20)
	// 82907C1C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82907C20; continue 'dispatch;
            }
            0x82907C20 => {
    //   block [0x82907C20..0x82907C6C)
	// 82907C20: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82907C24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82907C28: 419A0130  beq cr6, 0x82907d58
	if ctx.cr[6].eq {
	pc = 0x82907D58; continue 'dispatch;
	}
	// 82907C2C: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82907C30: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82907C34: 55286FFE  rlwinm r8, r9, 0xd, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0007FFFFu64;
	// 82907C38: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82907C3C: 419A00F8  beq cr6, 0x82907d34
	if ctx.cr[6].eq {
	pc = 0x82907D34; continue 'dispatch;
	}
	// 82907C40: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82907C44: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82907C48: 419A0024  beq cr6, 0x82907c6c
	if ctx.cr[6].eq {
	pc = 0x82907C6C; continue 'dispatch;
	}
	// 82907C4C: 892A0073  lbz r9, 0x73(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(115 as u32) ) } as u64;
	// 82907C50: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82907C54: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 82907C58: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82907C5C: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82907C60: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82907C64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82907C68: 480000D0  b 0x82907d38
	pc = 0x82907D38; continue 'dispatch;
            }
            0x82907C6C => {
    //   block [0x82907C6C..0x82907C8C)
	// 82907C6C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82907C70: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82907C74: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82907C78: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82907C7C: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82907C80: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82907C84: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82907C88: 40810054  ble 0x82907cdc
	if !ctx.cr[0].gt {
	pc = 0x82907CDC; continue 'dispatch;
	}
	pc = 0x82907C8C; continue 'dispatch;
            }
            0x82907C8C => {
    //   block [0x82907C8C..0x82907CAC)
	// 82907C8C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82907C90: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82907C94: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82907C98: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82907C9C: 2F070073  cmpwi cr6, r7, 0x73
	ctx.cr[6].compare_i32(ctx.r[7].s32, 115, &mut ctx.xer);
	// 82907CA0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82907CA4: 41980008  blt cr6, 0x82907cac
	if ctx.cr[6].lt {
	pc = 0x82907CAC; continue 'dispatch;
	}
	// 82907CA8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x82907CAC; continue 'dispatch;
            }
            0x82907CAC => {
    //   block [0x82907CAC..0x82907CC8)
	// 82907CAC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82907CB0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82907CB4: 419A0014  beq cr6, 0x82907cc8
	if ctx.cr[6].eq {
	pc = 0x82907CC8; continue 'dispatch;
	}
	// 82907CB8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82907CBC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82907CC0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82907CC4: 4800000C  b 0x82907cd0
	pc = 0x82907CD0; continue 'dispatch;
            }
            0x82907CC8 => {
    //   block [0x82907CC8..0x82907CD0)
	// 82907CC8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82907CCC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82907CD0; continue 'dispatch;
            }
            0x82907CD0 => {
    //   block [0x82907CD0..0x82907CDC)
	// 82907CD0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82907CD4: 4199FFB8  bgt cr6, 0x82907c8c
	if ctx.cr[6].gt {
	pc = 0x82907C8C; continue 'dispatch;
	}
	// 82907CD8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82907CDC; continue 'dispatch;
            }
            0x82907CDC => {
    //   block [0x82907CDC..0x82907CF8)
	// 82907CDC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82907CE0: 419A0040  beq cr6, 0x82907d20
	if ctx.cr[6].eq {
	pc = 0x82907D20; continue 'dispatch;
	}
	// 82907CE4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82907CE8: 2F0B0073  cmpwi cr6, r11, 0x73
	ctx.cr[6].compare_i32(ctx.r[11].s32, 115, &mut ctx.xer);
	// 82907CEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82907CF0: 41990008  bgt cr6, 0x82907cf8
	if ctx.cr[6].gt {
	pc = 0x82907CF8; continue 'dispatch;
	}
	// 82907CF4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82907CF8; continue 'dispatch;
            }
            0x82907CF8 => {
    //   block [0x82907CF8..0x82907D20)
	// 82907CF8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82907CFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82907D00: 409A0020  bne cr6, 0x82907d20
	if !ctx.cr[6].eq {
	pc = 0x82907D20; continue 'dispatch;
	}
	// 82907D04: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82907D08: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82907D0C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82907D10: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82907D14: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82907D18: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82907D1C: 4800001C  b 0x82907d38
	pc = 0x82907D38; continue 'dispatch;
            }
            0x82907D20 => {
    //   block [0x82907D20..0x82907D34)
	// 82907D20: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82907D24: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82907D28: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82907D2C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82907D30: 48000008  b 0x82907d38
	pc = 0x82907D38; continue 'dispatch;
            }
            0x82907D34 => {
    //   block [0x82907D34..0x82907D38)
	// 82907D34: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82907D38; continue 'dispatch;
            }
            0x82907D38 => {
    //   block [0x82907D38..0x82907D58)
	// 82907D38: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82907D3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82907D40: 419A0018  beq cr6, 0x82907d58
	if ctx.cr[6].eq {
	pc = 0x82907D58; continue 'dispatch;
	}
	// 82907D44: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82907D48: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82907D4C: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82907D50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82907D54: 4E800421  bctrl
	ctx.lr = 0x82907D58;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82907D58 => {
    //   block [0x82907D58..0x82907D68)
	// 82907D58: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82907D5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82907D60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82907D64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82907D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82907D68 size=60
    let mut pc: u32 = 0x82907D68;
    'dispatch: loop {
        match pc {
            0x82907D68 => {
    //   block [0x82907D68..0x82907DA4)
	// 82907D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82907D6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82907D70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82907D74: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82907D78: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82907D7C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82907D80: 388B9DD0  addi r4, r11, -0x6230
	ctx.r[4].s64 = ctx.r[11].s64 + -25136;
	// 82907D84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82907D88: 4B925149  bl 0x8222ced0
	ctx.lr = 0x82907D8C;
	sub_8222CED0(ctx, base);
	// 82907D8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82907D90: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82907D94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82907D98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82907D9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82907DA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82907DA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82907DA8 size=104
    let mut pc: u32 = 0x82907DA8;
    'dispatch: loop {
        match pc {
            0x82907DA8 => {
    //   block [0x82907DA8..0x82907DF8)
	// 82907DA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82907DAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82907DB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82907DB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82907DB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82907DBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82907DC0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82907DC4: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 82907DC8: 4B8AFD51  bl 0x821b7b18
	ctx.lr = 0x82907DCC;
	sub_821B7B18(ctx, base);
	// 82907DCC: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82907DD0: 4B90D009  bl 0x82214dd8
	ctx.lr = 0x82907DD4;
	sub_82214DD8(ctx, base);
	// 82907DD4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82907DD8: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82907DDC: 392B2850  addi r9, r11, 0x2850
	ctx.r[9].s64 = ctx.r[11].s64 + 10320;
	// 82907DE0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82907DE4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82907DE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82907DEC: 419A000C  beq cr6, 0x82907df8
	if ctx.cr[6].eq {
	pc = 0x82907DF8; continue 'dispatch;
	}
	// 82907DF0: 4B913F49  bl 0x8221bd38
	ctx.lr = 0x82907DF4;
	sub_8221BD38(ctx, base);
	// 82907DF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82907DF8; continue 'dispatch;
            }
            0x82907DF8 => {
    //   block [0x82907DF8..0x82907E10)
	// 82907DF8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82907DFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82907E00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82907E04: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82907E08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82907E0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82907E10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82907E10 size=196
    let mut pc: u32 = 0x82907E10;
    'dispatch: loop {
        match pc {
            0x82907E10 => {
    //   block [0x82907E10..0x82907EA8)
	// 82907E10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82907E14: 483A15F9  bl 0x82ca940c
	ctx.lr = 0x82907E18;
	sub_82CA93D0(ctx, base);
	// 82907E18: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82907E1C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82907E20: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82907E24: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 82907E28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82907E2C: 386B2DF8  addi r3, r11, 0x2df8
	ctx.r[3].s64 = ctx.r[11].s64 + 11768;
	// 82907E30: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 82907E34: 3BBF000C  addi r29, r31, 0xc
	ctx.r[29].s64 = ctx.r[31].s64 + 12;
	// 82907E38: 4B8EBF21  bl 0x821f3d58
	ctx.lr = 0x82907E3C;
	sub_821F3D58(ctx, base);
	// 82907E3C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82907E40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82907E44: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82907E48: 4BAA8971  bl 0x823b07b8
	ctx.lr = 0x82907E4C;
	sub_823B07B8(ctx, base);
	// 82907E4C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82907E50: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82907E54: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82907E58: 388BCB48  addi r4, r11, -0x34b8
	ctx.r[4].s64 = ctx.r[11].s64 + -13496;
	// 82907E5C: 892A0090  lbz r9, 0x90(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(144 as u32) ) } as u64;
	// 82907E60: 61280002  ori r8, r9, 2
	ctx.r[8].u64 = ctx.r[9].u64 | 2;
	// 82907E64: 990A0090  stb r8, 0x90(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(144 as u32), ctx.r[8].u8 ) };
	// 82907E68: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82907E6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82907E70: 81440008  lwz r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82907E74: 419A0040  beq cr6, 0x82907eb4
	if ctx.cr[6].eq {
	pc = 0x82907EB4; continue 'dispatch;
	}
	// 82907E78: 8124000C  lwz r9, 0xc(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82907E7C: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82907E80: 7CEB4850  subf r7, r11, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82907E84: 7D091670  srawi r9, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 82907E88: 7CE81670  srawi r8, r7, 2
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[7].s32 >> 2) as i64;
	// 82907E8C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82907E90: 40980018  bge cr6, 0x82907ea8
	if !ctx.cr[6].lt {
	pc = 0x82907EA8; continue 'dispatch;
	}
	// 82907E94: 396A0004  addi r11, r10, 4
	ctx.r[11].s64 = ctx.r[10].s64 + 4;
	// 82907E98: 93EA0000  stw r31, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82907E9C: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82907EA0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82907EA4: 483A15B8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82907EA8 => {
    //   block [0x82907EA8..0x82907EB4)
	// 82907EA8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82907EAC: 40990008  ble cr6, 0x82907eb4
	if !ctx.cr[6].gt {
	pc = 0x82907EB4; continue 'dispatch;
	}
	// 82907EB0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82907EB4; continue 'dispatch;
            }
            0x82907EB4 => {
    //   block [0x82907EB4..0x82907ED4)
	// 82907EB4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82907EB8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82907EBC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82907EC0: 90810058  stw r4, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u32 ) };
	// 82907EC4: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82907EC8: 48000DE9  bl 0x82908cb0
	ctx.lr = 0x82907ECC;
	sub_82908CB0(ctx, base);
	// 82907ECC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82907ED0: 483A158C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82907ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82907ED8 size=148
    let mut pc: u32 = 0x82907ED8;
    'dispatch: loop {
        match pc {
            0x82907ED8 => {
    //   block [0x82907ED8..0x82907F6C)
	// 82907ED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82907EDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82907EE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82907EE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82907EE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82907EEC: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 82907EF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82907EF4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82907EF8: 808AEC0C  lwz r4, -0x13f4(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-5108 as u32) ) } as u64;
	// 82907EFC: 39640001  addi r11, r4, 1
	ctx.r[11].s64 = ctx.r[4].s64 + 1;
	// 82907F00: 916AEC0C  stw r11, -0x13f4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-5108 as u32), ctx.r[11].u32 ) };
	// 82907F04: 4BA46DBD  bl 0x8234ecc0
	ctx.lr = 0x82907F08;
	sub_8234ECC0(ctx, base);
	// 82907F08: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 82907F0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82907F10: 388953CC  addi r4, r9, 0x53cc
	ctx.r[4].s64 = ctx.r[9].s64 + 21452;
	// 82907F14: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82907F18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82907F1C: 4B924FB5  bl 0x8222ced0
	ctx.lr = 0x82907F20;
	sub_8222CED0(ctx, base);
	// 82907F20: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82907F24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82907F28: 4B8E48D1  bl 0x821ec7f8
	ctx.lr = 0x82907F2C;
	sub_821EC7F8(ctx, base);
	// 82907F2C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82907F30: 4B90CEA9  bl 0x82214dd8
	ctx.lr = 0x82907F34;
	sub_82214DD8(ctx, base);
	// 82907F34: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 82907F38: 38DF0014  addi r6, r31, 0x14
	ctx.r[6].s64 = ctx.r[31].s64 + 20;
	// 82907F3C: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82907F40: 3868CB58  addi r3, r8, -0x34a8
	ctx.r[3].s64 = ctx.r[8].s64 + -13480;
	// 82907F44: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82907F48: 4BD6A1D1  bl 0x82672118
	ctx.lr = 0x82907F4C;
	sub_82672118(ctx, base);
	// 82907F4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82907F50: 4B90CE89  bl 0x82214dd8
	ctx.lr = 0x82907F54;
	sub_82214DD8(ctx, base);
	// 82907F54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82907F58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82907F5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82907F60: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82907F64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82907F68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82907F70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82907F70 size=240
    let mut pc: u32 = 0x82907F70;
    'dispatch: loop {
        match pc {
            0x82907F70 => {
    //   block [0x82907F70..0x82907FA8)
	// 82907F70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82907F74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82907F78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82907F7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82907F80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82907F84: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82907F88: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82907F8C: 3BEBCB48  addi r31, r11, -0x34b8
	ctx.r[31].s64 = ctx.r[11].s64 + -13496;
	// 82907F90: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82907F94: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82907F98: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82907F9C: 4099000C  ble cr6, 0x82907fa8
	if !ctx.cr[6].gt {
	pc = 0x82907FA8; continue 'dispatch;
	}
	// 82907FA0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 82907FA4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82907FA8; continue 'dispatch;
            }
            0x82907FA8 => {
    //   block [0x82907FA8..0x82907FC4)
	// 82907FA8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82907FAC: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82907FB0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82907FB4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82907FB8: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82907FBC: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82907FC0: 419A0028  beq cr6, 0x82907fe8
	if ctx.cr[6].eq {
	pc = 0x82907FE8; continue 'dispatch;
	}
	pc = 0x82907FC4; continue 'dispatch;
            }
            0x82907FC4 => {
    //   block [0x82907FC4..0x82907FDC)
	// 82907FC4: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82907FC8: 7F09F040  cmplw cr6, r9, r30
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82907FCC: 419A0010  beq cr6, 0x82907fdc
	if ctx.cr[6].eq {
	pc = 0x82907FDC; continue 'dispatch;
	}
	// 82907FD0: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 82907FD4: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82907FD8: 409AFFEC  bne cr6, 0x82907fc4
	if !ctx.cr[6].eq {
	pc = 0x82907FC4; continue 'dispatch;
	}
	pc = 0x82907FDC; continue 'dispatch;
            }
            0x82907FDC => {
    //   block [0x82907FDC..0x82907FE8)
	// 82907FDC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82907FE0: 40990008  ble cr6, 0x82907fe8
	if !ctx.cr[6].gt {
	pc = 0x82907FE8; continue 'dispatch;
	}
	// 82907FE4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82907FE8; continue 'dispatch;
            }
            0x82907FE8 => {
    //   block [0x82907FE8..0x82907FFC)
	// 82907FE8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82907FEC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82907FF0: 419A000C  beq cr6, 0x82907ffc
	if ctx.cr[6].eq {
	pc = 0x82907FFC; continue 'dispatch;
	}
	// 82907FF4: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82907FF8: 419A0008  beq cr6, 0x82908000
	if ctx.cr[6].eq {
	pc = 0x82908000; continue 'dispatch;
	}
	pc = 0x82907FFC; continue 'dispatch;
            }
            0x82907FFC => {
    //   block [0x82907FFC..0x82908000)
	// 82907FFC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82908000; continue 'dispatch;
            }
            0x82908000 => {
    //   block [0x82908000..0x82908028)
	// 82908000: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82908004: 419A002C  beq cr6, 0x82908030
	if ctx.cr[6].eq {
	pc = 0x82908030; continue 'dispatch;
	}
	// 82908008: 38A30004  addi r5, r3, 4
	ctx.r[5].s64 = ctx.r[3].s64 + 4;
	// 8290800C: 7D455850  subf r10, r5, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[5].s64;
	// 82908010: 7D4A1671  srawi. r10, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82908014: 40810014  ble 0x82908028
	if !ctx.cr[0].gt {
	pc = 0x82908028; continue 'dispatch;
	}
	// 82908018: 5544103A  slwi r4, r10, 2
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 8290801C: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82908020: 483A2009  bl 0x82caa028
	ctx.lr = 0x82908024;
	sub_82CAA028(ctx, base);
	// 82908024: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82908028; continue 'dispatch;
            }
            0x82908028 => {
    //   block [0x82908028..0x82908030)
	// 82908028: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 8290802C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82908030; continue 'dispatch;
            }
            0x82908030 => {
    //   block [0x82908030..0x82908060)
	// 82908030: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82908034: 387E0014  addi r3, r30, 0x14
	ctx.r[3].s64 = ctx.r[30].s64 + 20;
	// 82908038: 388BCB58  addi r4, r11, -0x34a8
	ctx.r[4].s64 = ctx.r[11].s64 + -13480;
	// 8290803C: 4BD6A8FD  bl 0x82672938
	ctx.lr = 0x82908040;
	sub_82672938(ctx, base);
	// 82908040: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82908044: 915E0014  stw r10, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82908048: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8290804C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82908050: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82908054: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82908058: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8290805C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82908060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82908060 size=132
    let mut pc: u32 = 0x82908060;
    'dispatch: loop {
        match pc {
            0x82908060 => {
    //   block [0x82908060..0x829080B4)
	// 82908060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82908064: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82908068: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8290806C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82908070: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82908074: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82908078: 3BFE0018  addi r31, r30, 0x18
	ctx.r[31].s64 = ctx.r[30].s64 + 24;
	// 8290807C: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82908080: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82908084: 419A0030  beq cr6, 0x829080b4
	if ctx.cr[6].eq {
	pc = 0x829080B4; continue 'dispatch;
	}
	// 82908088: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8290808C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82908090: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 82908094: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82908098: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 8290809C: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829080A0: 4BA48821  bl 0x823508c0
	ctx.lr = 0x829080A4;
	sub_823508C0(ctx, base);
	// 829080A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829080A8: 4B8AFA71  bl 0x821b7b18
	ctx.lr = 0x829080AC;
	sub_821B7B18(ctx, base);
	// 829080AC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829080B0: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	pc = 0x829080B4; continue 'dispatch;
            }
            0x829080B4 => {
    //   block [0x829080B4..0x829080CC)
	// 829080B4: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 829080B8: 894BEC10  lbz r10, -0x13f0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-5104 as u32) ) } as u64;
	// 829080BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829080C0: 419A000C  beq cr6, 0x829080cc
	if ctx.cr[6].eq {
	pc = 0x829080CC; continue 'dispatch;
	}
	// 829080C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829080C8: 48000659  bl 0x82908720
	ctx.lr = 0x829080CC;
	sub_82908720(ctx, base);
	pc = 0x829080CC; continue 'dispatch;
            }
            0x829080CC => {
    //   block [0x829080CC..0x829080E4)
	// 829080CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829080D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829080D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829080D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829080DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829080E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829080E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829080E8 size=348
    let mut pc: u32 = 0x829080E8;
    'dispatch: loop {
        match pc {
            0x829080E8 => {
    //   block [0x829080E8..0x8290812C)
	// 829080E8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829080EC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829080F0: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 829080F4: 5528F7FE  rlwinm r8, r9, 0x1e, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 829080F8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 829080FC: 419A00F8  beq cr6, 0x829081f4
	if ctx.cr[6].eq {
	pc = 0x829081F4; continue 'dispatch;
	}
	// 82908100: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82908104: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82908108: 419A0024  beq cr6, 0x8290812c
	if ctx.cr[6].eq {
	pc = 0x8290812C; continue 'dispatch;
	}
	// 8290810C: 894A0002  lbz r10, 2(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 82908110: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82908114: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82908118: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8290811C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82908120: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82908124: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82908128: 480000D0  b 0x829081f8
	pc = 0x829081F8; continue 'dispatch;
            }
            0x8290812C => {
    //   block [0x8290812C..0x8290814C)
	// 8290812C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82908130: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82908134: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82908138: 9121FFF0  stw r9, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u32 ) };
	// 8290813C: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82908140: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 82908144: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82908148: 40810054  ble 0x8290819c
	if !ctx.cr[0].gt {
	pc = 0x8290819C; continue 'dispatch;
	}
	pc = 0x8290814C; continue 'dispatch;
            }
            0x8290814C => {
    //   block [0x8290814C..0x8290816C)
	// 8290814C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82908150: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82908154: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82908158: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290815C: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 82908160: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82908164: 41980008  blt cr6, 0x8290816c
	if ctx.cr[6].lt {
	pc = 0x8290816C; continue 'dispatch;
	}
	// 82908168: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x8290816C; continue 'dispatch;
            }
            0x8290816C => {
    //   block [0x8290816C..0x82908188)
	// 8290816C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82908170: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82908174: 419A0014  beq cr6, 0x82908188
	if ctx.cr[6].eq {
	pc = 0x82908188; continue 'dispatch;
	}
	// 82908178: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8290817C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82908180: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82908184: 4800000C  b 0x82908190
	pc = 0x82908190; continue 'dispatch;
            }
            0x82908188 => {
    //   block [0x82908188..0x82908190)
	// 82908188: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8290818C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82908190; continue 'dispatch;
            }
            0x82908190 => {
    //   block [0x82908190..0x8290819C)
	// 82908190: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82908194: 4199FFB8  bgt cr6, 0x8290814c
	if ctx.cr[6].gt {
	pc = 0x8290814C; continue 'dispatch;
	}
	// 82908198: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	pc = 0x8290819C; continue 'dispatch;
            }
            0x8290819C => {
    //   block [0x8290819C..0x829081B8)
	// 8290819C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829081A0: 419A0040  beq cr6, 0x829081e0
	if ctx.cr[6].eq {
	pc = 0x829081E0; continue 'dispatch;
	}
	// 829081A4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829081A8: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 829081AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829081B0: 41990008  bgt cr6, 0x829081b8
	if ctx.cr[6].gt {
	pc = 0x829081B8; continue 'dispatch;
	}
	// 829081B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829081B8; continue 'dispatch;
            }
            0x829081B8 => {
    //   block [0x829081B8..0x829081E0)
	// 829081B8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829081BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829081C0: 409A0020  bne cr6, 0x829081e0
	if !ctx.cr[6].eq {
	pc = 0x829081E0; continue 'dispatch;
	}
	// 829081C4: E961FFF0  ld r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829081C8: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 829081CC: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 829081D0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829081D4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 829081D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829081DC: 4800001C  b 0x829081f8
	pc = 0x829081F8; continue 'dispatch;
            }
            0x829081E0 => {
    //   block [0x829081E0..0x829081F4)
	// 829081E0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829081E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829081E8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 829081EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829081F0: 48000008  b 0x829081f8
	pc = 0x829081F8; continue 'dispatch;
            }
            0x829081F4 => {
    //   block [0x829081F4..0x829081F8)
	// 829081F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829081F8; continue 'dispatch;
            }
            0x829081F8 => {
    //   block [0x829081F8..0x82908244)
	// 829081F8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829081FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82908200: 419A0044  beq cr6, 0x82908244
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82908244);
		return;
	}
	// 82908204: 39600040  li r11, 0x40
	ctx.r[11].s64 = 64;
	// 82908208: 3921FFF0  addi r9, r1, -0x10
	ctx.r[9].s64 = ctx.r[1].s64 + -16;
	// 8290820C: 3901FFF0  addi r8, r1, -0x10
	ctx.r[8].s64 = ctx.r[1].s64 + -16;
	// 82908210: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82908250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82908250 size=52
    let mut pc: u32 = 0x82908250;
    'dispatch: loop {
        match pc {
            0x82908250 => {
    //   block [0x82908250..0x82908284)
	// 82908250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82908254: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82908258: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8290825C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82908260: 3884000C  addi r4, r4, 0xc
	ctx.r[4].s64 = ctx.r[4].s64 + 12;
	// 82908264: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82908268: 4B8E7FD9  bl 0x821f0240
	ctx.lr = 0x8290826C;
	sub_821F0240(ctx, base);
	// 8290826C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82908270: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82908274: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82908278: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290827C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82908280: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82908288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82908288 size=8
    let mut pc: u32 = 0x82908288;
    'dispatch: loop {
        match pc {
            0x82908288 => {
    //   block [0x82908288..0x82908290)
	// 82908288: 88630010  lbz r3, 0x10(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 8290828C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82908298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82908298 size=348
    let mut pc: u32 = 0x82908298;
    'dispatch: loop {
        match pc {
            0x82908298 => {
    //   block [0x82908298..0x829082D4)
	// 82908298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290829C: 483A1159  bl 0x82ca93f4
	ctx.lr = 0x829082A0;
	sub_82CA93D0(ctx, base);
	// 829082A0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829082A4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829082A8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829082AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829082B0: 4B8D98F9  bl 0x821e1ba8
	ctx.lr = 0x829082B4;
	sub_821E1BA8(ctx, base);
	// 829082B4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829082B8: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 829082BC: 3BCBCB48  addi r30, r11, -0x34b8
	ctx.r[30].s64 = ctx.r[11].s64 + -13496;
	// 829082C0: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829082C4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829082C8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829082CC: 40990008  ble cr6, 0x829082d4
	if !ctx.cr[6].gt {
	pc = 0x829082D4; continue 'dispatch;
	}
	// 829082D0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829082D4; continue 'dispatch;
            }
            0x829082D4 => {
    //   block [0x829082D4..0x829082E8)
	// 829082D4: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 829082D8: 7D5C5378  mr r28, r10
	ctx.r[28].u64 = ctx.r[10].u64;
	// 829082DC: 3B600003  li r27, 3
	ctx.r[27].s64 = 3;
	// 829082E0: 3F408349  lis r26, -0x7cb7
	ctx.r[26].s64 = -2092367872;
	// 829082E4: 3B29FFDF  addi r25, r9, -0x21
	ctx.r[25].s64 = ctx.r[9].s64 + -33;
	pc = 0x829082E8; continue 'dispatch;
            }
            0x829082E8 => {
    //   block [0x829082E8..0x829082F4)
	// 829082E8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829082EC: 40990008  ble cr6, 0x829082f4
	if !ctx.cr[6].gt {
	pc = 0x829082F4; continue 'dispatch;
	}
	// 829082F0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829082F4; continue 'dispatch;
            }
            0x829082F4 => {
    //   block [0x829082F4..0x82908304)
	// 829082F4: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829082F8: 419A00F0  beq cr6, 0x829083e8
	if ctx.cr[6].eq {
	pc = 0x829083E8; continue 'dispatch;
	}
	// 829082FC: 41980008  blt cr6, 0x82908304
	if ctx.cr[6].lt {
	pc = 0x82908304; continue 'dispatch;
	}
	// 82908300: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82908304; continue 'dispatch;
            }
            0x82908304 => {
    //   block [0x82908304..0x82908350)
	// 82908304: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82908308: 89090010  lbz r8, 0x10(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 8290830C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82908310: 419A00C4  beq cr6, 0x829083d4
	if ctx.cr[6].eq {
	pc = 0x829083D4; continue 'dispatch;
	}
	// 82908314: 7BAB0020  clrldi r11, r29, 0x20
	ctx.r[11].u64 = ctx.r[29].u64 & 0x00000000FFFFFFFFu64;
	// 82908318: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290831C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82908320: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82908324: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82908328: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8290832C: D18A0000  stfs f12, 0(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82908330: 936A0004  stw r27, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82908334: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82908338: 392B0008  addi r9, r11, 8
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	// 8290833C: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82908340: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82908344: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82908348: 41980008  blt cr6, 0x82908350
	if ctx.cr[6].lt {
	pc = 0x82908350; continue 'dispatch;
	}
	// 8290834C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82908350; continue 'dispatch;
            }
            0x82908350 => {
    //   block [0x82908350..0x8290838C)
	// 82908350: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82908354: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82908358: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290835C: 830B0004  lwz r24, 4(r11)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82908360: 4B91F521  bl 0x82227880
	ctx.lr = 0x82908364;
	sub_82227880(ctx, base);
	// 82908364: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 82908368: 4B8F0B11  bl 0x821f8e78
	ctx.lr = 0x8290836C;
	sub_821F8E78(ctx, base);
	// 8290836C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82908370: 4B924231  bl 0x8222c5a0
	ctx.lr = 0x82908374;
	sub_8222C5A0(ctx, base);
	// 82908374: 90770000  stw r3, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82908378: 817A79B0  lwz r11, 0x79b0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(31152 as u32) ) } as u64;
	// 8290837C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82908380: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82908384: 419A0008  beq cr6, 0x8290838c
	if ctx.cr[6].eq {
	pc = 0x8290838C; continue 'dispatch;
	}
	// 82908388: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8290838C; continue 'dispatch;
            }
            0x8290838C => {
    //   block [0x8290838C..0x829083D4)
	// 8290838C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 82908390: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82908394: 4B91FFF5  bl 0x82228388
	ctx.lr = 0x82908398;
	sub_82228388(ctx, base);
	// 82908398: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 8290839C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829083A0: 4B91F6E1  bl 0x82227a80
	ctx.lr = 0x829083A4;
	sub_82227A80(ctx, base);
	// 829083A4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829083A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829083AC: 388BFFE8  addi r4, r11, -0x18
	ctx.r[4].s64 = ctx.r[11].s64 + -24;
	// 829083B0: 38CBFFF8  addi r6, r11, -8
	ctx.r[6].s64 = ctx.r[11].s64 + -8;
	// 829083B4: 38ABFFF0  addi r5, r11, -0x10
	ctx.r[5].s64 = ctx.r[11].s64 + -16;
	// 829083B8: 4B920971  bl 0x82228d28
	ctx.lr = 0x829083BC;
	sub_82228D28(ctx, base);
	// 829083BC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829083C0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 829083C4: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 829083C8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 829083CC: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829083D0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x829083D4; continue 'dispatch;
            }
            0x829083D4 => {
    //   block [0x829083D4..0x829083E0)
	// 829083D4: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829083D8: 41980008  blt cr6, 0x829083e0
	if ctx.cr[6].lt {
	pc = 0x829083E0; continue 'dispatch;
	}
	// 829083DC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829083E0; continue 'dispatch;
            }
            0x829083E0 => {
    //   block [0x829083E0..0x829083E8)
	// 829083E0: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 829083E4: 4BFFFF04  b 0x829082e8
	pc = 0x829082E8; continue 'dispatch;
            }
            0x829083E8 => {
    //   block [0x829083E8..0x829083F4)
	// 829083E8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829083EC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 829083F0: 483A1054  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829083F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829083F8 size=324
    let mut pc: u32 = 0x829083F8;
    'dispatch: loop {
        match pc {
            0x829083F8 => {
    //   block [0x829083F8..0x82908434)
	// 829083F8: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 829083FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82908400: 554927FE  rlwinm r9, r10, 4, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0FFFFFFFu64;
	// 82908404: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82908408: 419A00E8  beq cr6, 0x829084f0
	if ctx.cr[6].eq {
	pc = 0x829084F0; continue 'dispatch;
	}
	// 8290840C: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 82908410: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 82908414: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82908418: 419A001C  beq cr6, 0x82908434
	if ctx.cr[6].eq {
	pc = 0x82908434; continue 'dispatch;
	}
	// 8290841C: 896B003C  lbz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82908420: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 82908424: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82908428: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290842C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82908430: 480000C4  b 0x829084f4
	pc = 0x829084F4; continue 'dispatch;
            }
            0x82908434 => {
    //   block [0x82908434..0x82908450)
	// 82908434: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 82908438: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8290843C: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 82908440: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82908444: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82908448: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290844C: 40810054  ble 0x829084a0
	if !ctx.cr[0].gt {
	pc = 0x829084A0; continue 'dispatch;
	}
	pc = 0x82908450; continue 'dispatch;
            }
            0x82908450 => {
    //   block [0x82908450..0x82908470)
	// 82908450: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82908454: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82908458: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8290845C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82908460: 2F07003C  cmpwi cr6, r7, 0x3c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 60, &mut ctx.xer);
	// 82908464: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82908468: 41980008  blt cr6, 0x82908470
	if ctx.cr[6].lt {
	pc = 0x82908470; continue 'dispatch;
	}
	// 8290846C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x82908470; continue 'dispatch;
            }
            0x82908470 => {
    //   block [0x82908470..0x8290848C)
	// 82908470: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82908474: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82908478: 419A0014  beq cr6, 0x8290848c
	if ctx.cr[6].eq {
	pc = 0x8290848C; continue 'dispatch;
	}
	// 8290847C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82908480: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82908484: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82908488: 4800000C  b 0x82908494
	pc = 0x82908494; continue 'dispatch;
            }
            0x8290848C => {
    //   block [0x8290848C..0x82908494)
	// 8290848C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82908490: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82908494; continue 'dispatch;
            }
            0x82908494 => {
    //   block [0x82908494..0x829084A0)
	// 82908494: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82908498: 4199FFB8  bgt cr6, 0x82908450
	if ctx.cr[6].gt {
	pc = 0x82908450; continue 'dispatch;
	}
	// 8290849C: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	pc = 0x829084A0; continue 'dispatch;
            }
            0x829084A0 => {
    //   block [0x829084A0..0x829084BC)
	// 829084A0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829084A4: 419A003C  beq cr6, 0x829084e0
	if ctx.cr[6].eq {
	pc = 0x829084E0; continue 'dispatch;
	}
	// 829084A8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829084AC: 2F0B003C  cmpwi cr6, r11, 0x3c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 60, &mut ctx.xer);
	// 829084B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829084B4: 41990008  bgt cr6, 0x829084bc
	if ctx.cr[6].gt {
	pc = 0x829084BC; continue 'dispatch;
	}
	// 829084B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829084BC; continue 'dispatch;
            }
            0x829084BC => {
    //   block [0x829084BC..0x829084E0)
	// 829084BC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829084C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829084C4: 409A001C  bne cr6, 0x829084e0
	if !ctx.cr[6].eq {
	pc = 0x829084E0; continue 'dispatch;
	}
	// 829084C8: E961FFF0  ld r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829084CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829084D0: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 829084D4: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 829084D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829084DC: 48000018  b 0x829084f4
	pc = 0x829084F4; continue 'dispatch;
            }
            0x829084E0 => {
    //   block [0x829084E0..0x829084F0)
	// 829084E0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829084E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829084E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829084EC: 48000008  b 0x829084f4
	pc = 0x829084F4; continue 'dispatch;
            }
            0x829084F0 => {
    //   block [0x829084F0..0x829084F4)
	// 829084F0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x829084F4; continue 'dispatch;
            }
            0x829084F4 => {
    //   block [0x829084F4..0x82908530)
	// 829084F4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 829084F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829084FC: 419A0040  beq cr6, 0x8290853c
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x8290853C);
		return;
	}
	// 82908500: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82908504: 812A0030  lwz r9, 0x30(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 82908508: 5528FFFE  rlwinm r8, r9, 0x1f, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 8290850C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82908510: 409A002C  bne cr6, 0x8290853c
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x8290853C);
		return;
	}
	// 82908514: 894B0294  lbz r10, 0x294(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(660 as u32) ) } as u64;
	// 82908518: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290851C: 419A0014  beq cr6, 0x82908530
	if ctx.cr[6].eq {
	pc = 0x82908530; continue 'dispatch;
	}
	// 82908520: 896B0286  lbz r11, 0x286(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(646 as u32) ) } as u64;
	// 82908524: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82908528: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290852C: 409A0008  bne cr6, 0x82908534
	if !ctx.cr[6].eq {
	pc = 0x82908534; continue 'dispatch;
	}
	pc = 0x82908530; continue 'dispatch;
            }
            0x82908530 => {
    //   block [0x82908530..0x82908534)
	// 82908530: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82908534; continue 'dispatch;
            }
            0x82908534 => {
    //   block [0x82908534..0x8290853C)
	// 82908534: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82908538: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82908548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82908548 size=372
    let mut pc: u32 = 0x82908548;
    'dispatch: loop {
        match pc {
            0x82908548 => {
    //   block [0x82908548..0x829085A0)
	// 82908548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290854C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82908550: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82908554: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82908558: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290855C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82908560: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82908564: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82908568: 5549F7FE  rlwinm r9, r10, 0x1e, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 8290856C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82908570: 419A00F4  beq cr6, 0x82908664
	if ctx.cr[6].eq {
	pc = 0x82908664; continue 'dispatch;
	}
	// 82908574: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82908578: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290857C: 419A0024  beq cr6, 0x829085a0
	if ctx.cr[6].eq {
	pc = 0x829085A0; continue 'dispatch;
	}
	// 82908580: 894A0002  lbz r10, 2(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 82908584: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82908588: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8290858C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82908590: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82908594: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82908598: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290859C: 480000CC  b 0x82908668
	pc = 0x82908668; continue 'dispatch;
            }
            0x829085A0 => {
    //   block [0x829085A0..0x829085BC)
	// 829085A0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 829085A4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829085A8: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 829085AC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829085B0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829085B4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829085B8: 40810054  ble 0x8290860c
	if !ctx.cr[0].gt {
	pc = 0x8290860C; continue 'dispatch;
	}
	pc = 0x829085BC; continue 'dispatch;
            }
            0x829085BC => {
    //   block [0x829085BC..0x829085DC)
	// 829085BC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829085C0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829085C4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829085C8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829085CC: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 829085D0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829085D4: 41980008  blt cr6, 0x829085dc
	if ctx.cr[6].lt {
	pc = 0x829085DC; continue 'dispatch;
	}
	// 829085D8: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	pc = 0x829085DC; continue 'dispatch;
            }
            0x829085DC => {
    //   block [0x829085DC..0x829085F8)
	// 829085DC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829085E0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829085E4: 419A0014  beq cr6, 0x829085f8
	if ctx.cr[6].eq {
	pc = 0x829085F8; continue 'dispatch;
	}
	// 829085E8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829085EC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829085F0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829085F4: 4800000C  b 0x82908600
	pc = 0x82908600; continue 'dispatch;
            }
            0x829085F8 => {
    //   block [0x829085F8..0x82908600)
	// 829085F8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829085FC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82908600; continue 'dispatch;
            }
            0x82908600 => {
    //   block [0x82908600..0x8290860C)
	// 82908600: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82908604: 4199FFB8  bgt cr6, 0x829085bc
	if ctx.cr[6].gt {
	pc = 0x829085BC; continue 'dispatch;
	}
	// 82908608: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8290860C; continue 'dispatch;
            }
            0x8290860C => {
    //   block [0x8290860C..0x82908628)
	// 8290860C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82908610: 419A0040  beq cr6, 0x82908650
	if ctx.cr[6].eq {
	pc = 0x82908650; continue 'dispatch;
	}
	// 82908614: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82908618: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 8290861C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82908620: 41990008  bgt cr6, 0x82908628
	if ctx.cr[6].gt {
	pc = 0x82908628; continue 'dispatch;
	}
	// 82908624: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	pc = 0x82908628; continue 'dispatch;
            }
            0x82908628 => {
    //   block [0x82908628..0x82908650)
	// 82908628: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290862C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82908630: 409A0020  bne cr6, 0x82908650
	if !ctx.cr[6].eq {
	pc = 0x82908650; continue 'dispatch;
	}
	// 82908634: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82908638: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8290863C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82908640: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82908644: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82908648: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290864C: 4800001C  b 0x82908668
	pc = 0x82908668; continue 'dispatch;
            }
            0x82908650 => {
    //   block [0x82908650..0x82908664)
	// 82908650: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82908654: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82908658: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 8290865C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82908660: 48000008  b 0x82908668
	pc = 0x82908668; continue 'dispatch;
            }
            0x82908664 => {
    //   block [0x82908664..0x82908668)
	// 82908664: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	pc = 0x82908668; continue 'dispatch;
            }
            0x82908668 => {
    //   block [0x82908668..0x829086A0)
	// 82908668: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290866C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82908670: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82908674: 419A002C  beq cr6, 0x829086a0
	if ctx.cr[6].eq {
	pc = 0x829086A0; continue 'dispatch;
	}
	// 82908678: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290867C: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82908680: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82908684: 4E800421  bctrl
	ctx.lr = 0x82908688;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82908688: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290868C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82908690: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82908694: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82908698: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8290869C: 4E800020  blr
	return;
            }
            0x829086A0 => {
    //   block [0x829086A0..0x829086BC)
	// 829086A0: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829086C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829086C0 size=96
    let mut pc: u32 = 0x829086C0;
    'dispatch: loop {
        match pc {
            0x829086C0 => {
    //   block [0x829086C0..0x82908720)
	// 829086C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829086C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829086C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829086CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829086D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829086D4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 829086D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829086DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829086E0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829086E4: 388BCE8C  addi r4, r11, -0x3174
	ctx.r[4].s64 = ctx.r[11].s64 + -12660;
	// 829086E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829086EC: 4B9247E5  bl 0x8222ced0
	ctx.lr = 0x829086F0;
	sub_8222CED0(ctx, base);
	// 829086F0: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 829086F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829086F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829086FC: 4811474D  bl 0x82a1ce48
	ctx.lr = 0x82908700;
	sub_82A1CE48(ctx, base);
	// 82908700: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82908704: 4B90C6D5  bl 0x82214dd8
	ctx.lr = 0x82908708;
	sub_82214DD8(ctx, base);
	// 82908708: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8290870C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82908710: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82908714: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82908718: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8290871C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82908720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82908720 size=928
    let mut pc: u32 = 0x82908720;
    'dispatch: loop {
        match pc {
            0x82908720 => {
    //   block [0x82908720..0x82908AC0)
	// 82908720: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82908724: 483A0CDD  bl 0x82ca9400
	ctx.lr = 0x82908728;
	sub_82CA93D0(ctx, base);
	// 82908728: DBA1FFB0  stfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[29].u64 ) };
	// 8290872C: DBC1FFB8  stfd f30, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 82908730: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82908734: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82908AC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82908AC0 size=492
    let mut pc: u32 = 0x82908AC0;
    'dispatch: loop {
        match pc {
            0x82908AC0 => {
    //   block [0x82908AC0..0x82908CAC)
	// 82908AC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82908AC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82908AC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82908ACC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82908AD0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82908AD4: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82908AD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82908ADC: 3BCB53E0  addi r30, r11, 0x53e0
	ctx.r[30].s64 = ctx.r[11].s64 + 21472;
	// 82908AE0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82908AE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82908AE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82908AEC: 4B9243E5  bl 0x8222ced0
	ctx.lr = 0x82908AF0;
	sub_8222CED0(ctx, base);
	// 82908AF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82908AF4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82908AF8: 48000531  bl 0x82909028
	ctx.lr = 0x82908AFC;
	sub_82909028(ctx, base);
	// 82908AFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82908B00: 4B90C2D9  bl 0x82214dd8
	ctx.lr = 0x82908B04;
	sub_82214DD8(ctx, base);
	// 82908B04: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82908B08: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82908B0C: 388A708C  addi r4, r10, 0x708c
	ctx.r[4].s64 = ctx.r[10].s64 + 28812;
	// 82908B10: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82908B14: 4B9243BD  bl 0x8222ced0
	ctx.lr = 0x82908B18;
	sub_8222CED0(ctx, base);
	// 82908B18: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82908B1C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82908B20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82908B24: 4B9243AD  bl 0x8222ced0
	ctx.lr = 0x82908B28;
	sub_8222CED0(ctx, base);
	// 82908B28: 3D208291  lis r9, -0x7d6f
	ctx.r[9].s64 = -2104426496;
	// 82908B2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82908B30: 38C980E8  addi r6, r9, -0x7f18
	ctx.r[6].s64 = ctx.r[9].s64 + -32536;
	// 82908B34: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82908B38: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82908B3C: 48000735  bl 0x82909270
	ctx.lr = 0x82908B40;
	sub_82909270(ctx, base);
	// 82908B40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82908B44: 4B90C295  bl 0x82214dd8
	ctx.lr = 0x82908B48;
	sub_82214DD8(ctx, base);
	// 82908B48: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82908B4C: 4B90C28D  bl 0x82214dd8
	ctx.lr = 0x82908B50;
	sub_82214DD8(ctx, base);
	// 82908B50: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 82908B54: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82908B58: 388853FC  addi r4, r8, 0x53fc
	ctx.r[4].s64 = ctx.r[8].s64 + 21500;
	// 82908B5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82908B60: 4B924371  bl 0x8222ced0
	ctx.lr = 0x82908B64;
	sub_8222CED0(ctx, base);
	// 82908B64: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82908B68: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82908B6C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82908B70: 4B924361  bl 0x8222ced0
	ctx.lr = 0x82908B74;
	sub_8222CED0(ctx, base);
	// 82908B74: 3CE08291  lis r7, -0x7d6f
	ctx.r[7].s64 = -2104426496;
	// 82908B78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82908B7C: 38C78250  addi r6, r7, -0x7db0
	ctx.r[6].s64 = ctx.r[7].s64 + -32176;
	// 82908B80: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82908B84: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82908B88: 480008F1  bl 0x82909478
	ctx.lr = 0x82908B8C;
	sub_82909478(ctx, base);
	// 82908B8C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82908B90: 4B90C249  bl 0x82214dd8
	ctx.lr = 0x82908B94;
	sub_82214DD8(ctx, base);
	// 82908B94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82908B98: 4B90C241  bl 0x82214dd8
	ctx.lr = 0x82908B9C;
	sub_82214DD8(ctx, base);
	// 82908B9C: 3CC0820B  lis r6, -0x7df5
	ctx.r[6].s64 = -2113208320;
	// 82908BA0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82908BA4: 3886E244  addi r4, r6, -0x1dbc
	ctx.r[4].s64 = ctx.r[6].s64 + -7612;
	// 82908BA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82908BAC: 4B924325  bl 0x8222ced0
	ctx.lr = 0x82908BB0;
	sub_8222CED0(ctx, base);
	// 82908BB0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82908BB4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82908BB8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82908BBC: 4B924315  bl 0x8222ced0
	ctx.lr = 0x82908BC0;
	sub_8222CED0(ctx, base);
	// 82908BC0: 3C808291  lis r4, -0x7d6f
	ctx.r[4].s64 = -2104426496;
	// 82908BC4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82908BC8: 38C48288  addi r6, r4, -0x7d78
	ctx.r[6].s64 = ctx.r[4].s64 + -32120;
	// 82908BCC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82908BD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82908BD4: 48000AAD  bl 0x82909680
	ctx.lr = 0x82908BD8;
	sub_82909680(ctx, base);
	// 82908BD8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82908BDC: 4B90C1FD  bl 0x82214dd8
	ctx.lr = 0x82908BE0;
	sub_82214DD8(ctx, base);
	// 82908BE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82908BE4: 4B90C1F5  bl 0x82214dd8
	ctx.lr = 0x82908BE8;
	sub_82214DD8(ctx, base);
	// 82908BE8: 3C60820E  lis r3, -0x7df2
	ctx.r[3].s64 = -2113011712;
	// 82908BEC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82908BF0: 38835408  addi r4, r3, 0x5408
	ctx.r[4].s64 = ctx.r[3].s64 + 21512;
	// 82908BF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82908BF8: 4B9242D9  bl 0x8222ced0
	ctx.lr = 0x82908BFC;
	sub_8222CED0(ctx, base);
	// 82908BFC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82908C00: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82908C04: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82908C08: 4B9242C9  bl 0x8222ced0
	ctx.lr = 0x82908C0C;
	sub_8222CED0(ctx, base);
	// 82908C0C: 3D608291  lis r11, -0x7d6f
	ctx.r[11].s64 = -2104426496;
	// 82908C10: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82908C14: 38CB8290  addi r6, r11, -0x7d70
	ctx.r[6].s64 = ctx.r[11].s64 + -32112;
	// 82908C18: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82908C1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82908C20: 48000C69  bl 0x82909888
	ctx.lr = 0x82908C24;
	sub_82909888(ctx, base);
	// 82908C24: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82908C28: 4B90C1B1  bl 0x82214dd8
	ctx.lr = 0x82908C2C;
	sub_82214DD8(ctx, base);
	// 82908C2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82908C30: 4B90C1A9  bl 0x82214dd8
	ctx.lr = 0x82908C34;
	sub_82214DD8(ctx, base);
	// 82908C34: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82908C38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82908C3C: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82908C40: 4BAC5981  bl 0x823ce5c0
	ctx.lr = 0x82908C44;
	sub_823CE5C0(ctx, base);
	// 82908C44: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82908C48: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82908C4C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82908C50: 4BAC54C1  bl 0x823ce110
	ctx.lr = 0x82908C54;
	sub_823CE110(ctx, base);
	// 82908C54: 3D208217  lis r9, -0x7de9
	ctx.r[9].s64 = -2112421888;
	// 82908C58: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 82908C5C: 38A94928  addi r5, r9, 0x4928
	ctx.r[5].s64 = ctx.r[9].s64 + 18728;
	// 82908C60: 38885414  addi r4, r8, 0x5414
	ctx.r[4].s64 = ctx.r[8].s64 + 21524;
	// 82908C64: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82908C68: 4BD0FE91  bl 0x82618af8
	ctx.lr = 0x82908C6C;
	sub_82618AF8(ctx, base);
	// 82908C6C: 3CE08291  lis r7, -0x7d6f
	ctx.r[7].s64 = -2104426496;
	// 82908C70: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 82908C74: 38A78298  addi r5, r7, -0x7d68
	ctx.r[5].s64 = ctx.r[7].s64 + -32104;
	// 82908C78: 38865438  addi r4, r6, 0x5438
	ctx.r[4].s64 = ctx.r[6].s64 + 21560;
	// 82908C7C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82908C80: 4BAC5661  bl 0x823ce2e0
	ctx.lr = 0x82908C84;
	sub_823CE2E0(ctx, base);
	// 82908C84: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82908C88: 4B8AEE91  bl 0x821b7b18
	ctx.lr = 0x82908C8C;
	sub_821B7B18(ctx, base);
	// 82908C8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82908C90: 4B8AEE89  bl 0x821b7b18
	ctx.lr = 0x82908C94;
	sub_821B7B18(ctx, base);
	// 82908C94: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82908C98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82908C9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82908CA0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82908CA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82908CA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82908CB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82908CB0 size=216
    let mut pc: u32 = 0x82908CB0;
    'dispatch: loop {
        match pc {
            0x82908CB0 => {
    //   block [0x82908CB0..0x82908CEC)
	// 82908CB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82908CB4: 483A0759  bl 0x82ca940c
	ctx.lr = 0x82908CB8;
	sub_82CA93D0(ctx, base);
	// 82908CB8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82908CBC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82908CC0: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82908CC4: 3BEBCB48  addi r31, r11, -0x34b8
	ctx.r[31].s64 = ctx.r[11].s64 + -13496;
	// 82908CC8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82908CCC: F88100A0  std r4, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[4].u64 ) };
	// 82908CD0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82908CD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82908CD8: 419A0014  beq cr6, 0x82908cec
	if ctx.cr[6].eq {
	pc = 0x82908CEC; continue 'dispatch;
	}
	// 82908CDC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82908CE0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82908CE4: 7D291671  srawi. r9, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82908CE8: 4082000C  bne 0x82908cf4
	if !ctx.cr[0].eq {
	pc = 0x82908CF4; continue 'dispatch;
	}
	pc = 0x82908CEC; continue 'dispatch;
            }
            0x82908CEC => {
    //   block [0x82908CEC..0x82908CF4)
	// 82908CEC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82908CF0: 48000034  b 0x82908d24
	pc = 0x82908D24; continue 'dispatch;
            }
            0x82908CF4 => {
    //   block [0x82908CF4..0x82908D00)
	// 82908CF4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82908CF8: 40990008  ble cr6, 0x82908d00
	if !ctx.cr[6].gt {
	pc = 0x82908D00; continue 'dispatch;
	}
	// 82908CFC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82908D00; continue 'dispatch;
            }
            0x82908D00 => {
    //   block [0x82908D00..0x82908D14)
	// 82908D00: 814100A0  lwz r10, 0xa0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 82908D04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82908D08: 419A000C  beq cr6, 0x82908d14
	if ctx.cr[6].eq {
	pc = 0x82908D14; continue 'dispatch;
	}
	// 82908D0C: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82908D10: 419A0008  beq cr6, 0x82908d18
	if ctx.cr[6].eq {
	pc = 0x82908D18; continue 'dispatch;
	}
	pc = 0x82908D14; continue 'dispatch;
            }
            0x82908D14 => {
    //   block [0x82908D14..0x82908D18)
	// 82908D14: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82908D18; continue 'dispatch;
            }
            0x82908D18 => {
    //   block [0x82908D18..0x82908D24)
	// 82908D18: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82908D1C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82908D20: 7D3E1670  srawi r30, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[9].s32 >> 2) as i64;
	pc = 0x82908D24; continue 'dispatch;
            }
            0x82908D24 => {
    //   block [0x82908D24..0x82908D44)
	// 82908D24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82908D28: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82908D2C: 4800005D  bl 0x82908d88
	ctx.lr = 0x82908D30;
	sub_82908D88(ctx, base);
	// 82908D30: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82908D34: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82908D38: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82908D3C: 40990008  ble cr6, 0x82908d44
	if !ctx.cr[6].gt {
	pc = 0x82908D44; continue 'dispatch;
	}
	// 82908D40: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82908D44; continue 'dispatch;
            }
            0x82908D44 => {
    //   block [0x82908D44..0x82908D6C)
	// 82908D44: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82908D48: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82908D4C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82908D50: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82908D54: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82908D58: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 82908D5C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82908D60: 4199000C  bgt cr6, 0x82908d6c
	if ctx.cr[6].gt {
	pc = 0x82908D6C; continue 'dispatch;
	}
	// 82908D64: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82908D68: 40980008  bge cr6, 0x82908d70
	if !ctx.cr[6].lt {
	pc = 0x82908D70; continue 'dispatch;
	}
	pc = 0x82908D6C; continue 'dispatch;
            }
            0x82908D6C => {
    //   block [0x82908D6C..0x82908D70)
	// 82908D6C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82908D70; continue 'dispatch;
            }
            0x82908D70 => {
    //   block [0x82908D70..0x82908D88)
	// 82908D70: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82908D74: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82908D78: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82908D7C: F97D0000  std r11, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82908D80: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82908D84: 483A06D8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82908D88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82908D88 size=672
    let mut pc: u32 = 0x82908D88;
    'dispatch: loop {
        match pc {
            0x82908D88 => {
    //   block [0x82908D88..0x82908DC0)
	// 82908D88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82908D8C: 483A0675  bl 0x82ca9400
	ctx.lr = 0x82908D90;
	sub_82CA93D0(ctx, base);
	// 82908D90: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82908D94: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82908D98: 83460000  lwz r26, 0(r6)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82908D9C: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 82908DA0: 3B8BCB48  addi r28, r11, -0x34b8
	ctx.r[28].s64 = ctx.r[11].s64 + -13496;
	// 82908DA4: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82908DA8: 83FC0008  lwz r31, 8(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82908DAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82908DB0: 409A0010  bne cr6, 0x82908dc0
	if !ctx.cr[6].eq {
	pc = 0x82908DC0; continue 'dispatch;
	}
	// 82908DB4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82908DB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82908DBC: 48000018  b 0x82908dd4
	pc = 0x82908DD4; continue 'dispatch;
            }
            0x82908DC0 => {
    //   block [0x82908DC0..0x82908DD4)
	// 82908DC0: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82908DC4: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82908DC8: 7D691670  srawi r9, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82908DCC: 7D6AF850  subf r11, r10, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 82908DD0: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	pc = 0x82908DD4; continue 'dispatch;
            }
            0x82908DD4 => {
    //   block [0x82908DD4..0x82908DF4)
	// 82908DD4: 3D003FFF  lis r8, 0x3fff
	ctx.r[8].s64 = 1073676288;
	// 82908DD8: 6108FFFF  ori r8, r8, 0xffff
	ctx.r[8].u64 = ctx.r[8].u64 | 65535;
	// 82908DDC: 7CEB4050  subf r7, r11, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82908DE0: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 82908DE4: 40980010  bge cr6, 0x82908df4
	if !ctx.cr[6].lt {
	pc = 0x82908DF4; continue 'dispatch;
	}
	// 82908DE8: 4BBEBCE9  bl 0x824f4ad0
	ctx.lr = 0x82908DEC;
	sub_824F4AD0(ctx, base);
	// 82908DEC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82908DF0: 483A0660  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82908DF4 => {
    //   block [0x82908DF4..0x82908E04)
	// 82908DF4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82908DF8: 409A000C  bne cr6, 0x82908e04
	if !ctx.cr[6].eq {
	pc = 0x82908E04; continue 'dispatch;
	}
	// 82908DFC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82908E00: 4800000C  b 0x82908e0c
	pc = 0x82908E0C; continue 'dispatch;
            }
            0x82908E04 => {
    //   block [0x82908E04..0x82908E0C)
	// 82908E04: 7D6AF850  subf r11, r10, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 82908E08: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	pc = 0x82908E0C; continue 'dispatch;
            }
            0x82908E0C => {
    //   block [0x82908E0C..0x82908E30)
	// 82908E0C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82908E10: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82908E14: 4098010C  bge cr6, 0x82908f20
	if !ctx.cr[6].lt {
	pc = 0x82908F20; continue 'dispatch;
	}
	// 82908E18: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82908E1C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82908E20: 7D0B4050  subf r8, r11, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82908E24: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82908E28: 41980008  blt cr6, 0x82908e30
	if ctx.cr[6].lt {
	pc = 0x82908E30; continue 'dispatch;
	}
	// 82908E2C: 7F6B4A14  add r27, r11, r9
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x82908E30; continue 'dispatch;
            }
            0x82908E30 => {
    //   block [0x82908E30..0x82908E40)
	// 82908E30: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82908E34: 409A000C  bne cr6, 0x82908e40
	if !ctx.cr[6].eq {
	pc = 0x82908E40; continue 'dispatch;
	}
	// 82908E38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82908E3C: 4800000C  b 0x82908e48
	pc = 0x82908E48; continue 'dispatch;
            }
            0x82908E40 => {
    //   block [0x82908E40..0x82908E48)
	// 82908E40: 7D6AF850  subf r11, r10, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 82908E44: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	pc = 0x82908E48; continue 'dispatch;
            }
            0x82908E48 => {
    //   block [0x82908E48..0x82908E64)
	// 82908E48: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82908E4C: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82908E50: 40980020  bge cr6, 0x82908e70
	if !ctx.cr[6].lt {
	pc = 0x82908E70; continue 'dispatch;
	}
	// 82908E54: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82908E58: 409A000C  bne cr6, 0x82908e64
	if !ctx.cr[6].eq {
	pc = 0x82908E64; continue 'dispatch;
	}
	// 82908E5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82908E60: 4800000C  b 0x82908e6c
	pc = 0x82908E6C; continue 'dispatch;
            }
            0x82908E64 => {
    //   block [0x82908E64..0x82908E6C)
	// 82908E64: 7D6AF850  subf r11, r10, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 82908E68: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	pc = 0x82908E6C; continue 'dispatch;
            }
            0x82908E6C => {
    //   block [0x82908E6C..0x82908E70)
	// 82908E6C: 3B6B0001  addi r27, r11, 1
	ctx.r[27].s64 = ctx.r[11].s64 + 1;
	pc = 0x82908E70; continue 'dispatch;
            }
            0x82908E70 => {
    //   block [0x82908E70..0x82908EA4)
	// 82908E70: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82908E74: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82908E78: 4817D1A1  bl 0x82a86018
	ctx.lr = 0x82908E7C;
	sub_82A86018(ctx, base);
	// 82908E7C: 80BC0004  lwz r5, 4(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82908E80: 83C100AC  lwz r30, 0xac(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82908E84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82908E88: 7D65F050  subf r11, r5, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[5].s64;
	// 82908E8C: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82908E90: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82908E94: 7FA6FA14  add r29, r6, r31
	ctx.r[29].u64 = ctx.r[6].u64 + ctx.r[31].u64;
	// 82908E98: 4182000C  beq 0x82908ea4
	if ctx.cr[0].eq {
	pc = 0x82908EA4; continue 'dispatch;
	}
	// 82908E9C: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82908EA0: 483A1189  bl 0x82caa028
	ctx.lr = 0x82908EA4;
	sub_82CAA028(ctx, base);
	pc = 0x82908EA4; continue 'dispatch;
            }
            0x82908EA4 => {
    //   block [0x82908EA4..0x82908ED0)
	// 82908EA4: 935D0000  stw r26, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82908EA8: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82908EAC: 7D5E5850  subf r10, r30, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 82908EB0: 7D4A1671  srawi. r10, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82908EB4: 4182001C  beq 0x82908ed0
	if ctx.cr[0].eq {
	pc = 0x82908ED0; continue 'dispatch;
	}
	// 82908EB8: 5544103A  slwi r4, r10, 2
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82908EBC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82908EC0: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82908EC4: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 82908EC8: 483A1161  bl 0x82caa028
	ctx.lr = 0x82908ECC;
	sub_82CAA028(ctx, base);
	// 82908ECC: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82908ED0; continue 'dispatch;
            }
            0x82908ED0 => {
    //   block [0x82908ED0..0x82908EE4)
	// 82908ED0: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82908ED4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82908ED8: 409A000C  bne cr6, 0x82908ee4
	if !ctx.cr[6].eq {
	pc = 0x82908EE4; continue 'dispatch;
	}
	// 82908EDC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82908EE0: 4800000C  b 0x82908eec
	pc = 0x82908EEC; continue 'dispatch;
            }
            0x82908EE4 => {
    //   block [0x82908EE4..0x82908EEC)
	// 82908EE4: 7D635850  subf r11, r3, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82908EE8: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	pc = 0x82908EEC; continue 'dispatch;
            }
            0x82908EEC => {
    //   block [0x82908EEC..0x82908EFC)
	// 82908EEC: 3BCB0001  addi r30, r11, 1
	ctx.r[30].s64 = ctx.r[11].s64 + 1;
	// 82908EF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82908EF4: 419A0008  beq cr6, 0x82908efc
	if ctx.cr[6].eq {
	pc = 0x82908EFC; continue 'dispatch;
	}
	// 82908EF8: 4B912E41  bl 0x8221bd38
	ctx.lr = 0x82908EFC;
	sub_8221BD38(ctx, base);
	pc = 0x82908EFC; continue 'dispatch;
            }
            0x82908EFC => {
    //   block [0x82908EFC..0x82908F20)
	// 82908EFC: 576B103A  slwi r11, r27, 2
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82908F00: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82908F04: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82908F08: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82908F0C: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82908F10: 917C000C  stw r11, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82908F14: 915C0008  stw r10, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82908F18: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82908F1C: 483A0534  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82908F20 => {
    //   block [0x82908F20..0x82908F54)
	// 82908F20: 83C100AC  lwz r30, 0xac(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82908F24: 7D7EF850  subf r11, r30, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 82908F28: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82908F2C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82908F30: 40980080  bge cr6, 0x82908fb0
	if !ctx.cr[6].lt {
	pc = 0x82908FB0; continue 'dispatch;
	}
	// 82908F34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82908F38: 419A001C  beq cr6, 0x82908f54
	if ctx.cr[6].eq {
	pc = 0x82908F54; continue 'dispatch;
	}
	// 82908F3C: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82908F40: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82908F44: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82908F48: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82908F4C: 483A10DD  bl 0x82caa028
	ctx.lr = 0x82908F50;
	sub_82CAA028(ctx, base);
	// 82908F50: 83FC0008  lwz r31, 8(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82908F54; continue 'dispatch;
            }
            0x82908F54 => {
    //   block [0x82908F54..0x82908F70)
	// 82908F54: 7D7EF850  subf r11, r30, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 82908F58: 7D6A1670  srawi r10, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82908F5C: 214A0001  subfic r10, r10, 1
	ctx.xer.ca = ctx.r[10].u32 <= 1 as u32;
	ctx.r[10].s64 = (1 as i64) - ctx.r[10].s64;
	// 82908F60: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82908F64: 419A001C  beq cr6, 0x82908f80
	if ctx.cr[6].eq {
	pc = 0x82908F80; continue 'dispatch;
	}
	// 82908F68: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82908F6C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82908F70; continue 'dispatch;
            }
            0x82908F70 => {
    //   block [0x82908F70..0x82908F80)
	// 82908F70: 934B0000  stw r26, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82908F74: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82908F78: 4200FFF8  bdnz 0x82908f70
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82908F70; continue 'dispatch;
	}
	// 82908F7C: 83FC0008  lwz r31, 8(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82908F80; continue 'dispatch;
            }
            0x82908F80 => {
    //   block [0x82908F80..0x82908F98)
	// 82908F80: 395F0004  addi r10, r31, 4
	ctx.r[10].s64 = ctx.r[31].s64 + 4;
	// 82908F84: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82908F88: 392AFFFC  addi r9, r10, -4
	ctx.r[9].s64 = ctx.r[10].s64 + -4;
	// 82908F8C: 915C0008  stw r10, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82908F90: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82908F94: 419A008C  beq cr6, 0x82909020
	if ctx.cr[6].eq {
	pc = 0x82909020; continue 'dispatch;
	}
	pc = 0x82908F98; continue 'dispatch;
            }
            0x82908F98 => {
    //   block [0x82908F98..0x82908FB0)
	// 82908F98: 934B0000  stw r26, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82908F9C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82908FA0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82908FA4: 409AFFF4  bne cr6, 0x82908f98
	if !ctx.cr[6].eq {
	pc = 0x82908F98; continue 'dispatch;
	}
	// 82908FA8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82908FAC: 483A04A4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82908FB0 => {
    //   block [0x82908FB0..0x82908FD8)
	// 82908FB0: 3BBFFFFC  addi r29, r31, -4
	ctx.r[29].s64 = ctx.r[31].s64 + -4;
	// 82908FB4: 7D7DF850  subf r11, r29, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[29].s64;
	// 82908FB8: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82908FBC: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82908FC0: 7F66FA14  add r27, r6, r31
	ctx.r[27].u64 = ctx.r[6].u64 + ctx.r[31].u64;
	// 82908FC4: 41820014  beq 0x82908fd8
	if ctx.cr[0].eq {
	pc = 0x82908FD8; continue 'dispatch;
	}
	// 82908FC8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82908FCC: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82908FD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82908FD4: 483A1055  bl 0x82caa028
	ctx.lr = 0x82908FD8;
	sub_82CAA028(ctx, base);
	pc = 0x82908FD8; continue 'dispatch;
            }
            0x82908FD8 => {
    //   block [0x82908FD8..0x82909000)
	// 82908FD8: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 82908FDC: 937C0008  stw r27, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 82908FE0: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82908FE4: 4081001C  ble 0x82909000
	if !ctx.cr[0].gt {
	pc = 0x82909000; continue 'dispatch;
	}
	// 82908FE8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82908FEC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82908FF0: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82908FF4: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82908FF8: 7C6BF850  subf r3, r11, r31
	ctx.r[3].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82908FFC: 483A102D  bl 0x82caa028
	ctx.lr = 0x82909000;
	sub_82CAA028(ctx, base);
	pc = 0x82909000; continue 'dispatch;
            }
            0x82909000 => {
    //   block [0x82909000..0x82909010)
	// 82909000: 395E0004  addi r10, r30, 4
	ctx.r[10].s64 = ctx.r[30].s64 + 4;
	// 82909004: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82909008: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8290900C: 419A0014  beq cr6, 0x82909020
	if ctx.cr[6].eq {
	pc = 0x82909020; continue 'dispatch;
	}
	pc = 0x82909010; continue 'dispatch;
            }
            0x82909010 => {
    //   block [0x82909010..0x82909020)
	// 82909010: 934B0000  stw r26, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82909014: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82909018: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8290901C: 409AFFF4  bne cr6, 0x82909010
	if !ctx.cr[6].eq {
	pc = 0x82909010; continue 'dispatch;
	}
	pc = 0x82909020; continue 'dispatch;
            }
            0x82909020 => {
    //   block [0x82909020..0x82909028)
	// 82909020: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82909024: 483A042C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82909028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82909028 size=584
    let mut pc: u32 = 0x82909028;
    'dispatch: loop {
        match pc {
            0x82909028 => {
    //   block [0x82909028..0x82909050)
	// 82909028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290902C: 483A03D5  bl 0x82ca9400
	ctx.lr = 0x82909030;
	sub_82CA93D0(ctx, base);
	// 82909030: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82909034: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82909038: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8290903C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82909040: 409A0010  bne cr6, 0x82909050
	if !ctx.cr[6].eq {
	pc = 0x82909050; continue 'dispatch;
	}
	// 82909044: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82909048: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 8290904C: 48000008  b 0x82909054
	pc = 0x82909054; continue 'dispatch;
            }
            0x82909050 => {
    //   block [0x82909050..0x82909054)
	// 82909050: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82909054; continue 'dispatch;
            }
            0x82909054 => {
    //   block [0x82909054..0x829090CC)
	// 82909054: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82909058: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8290905C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82909060: 4BAC5561  bl 0x823ce5c0
	ctx.lr = 0x82909064;
	sub_823CE5C0(ctx, base);
	// 82909064: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82909068: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290906C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82909070: 4BAC5191  bl 0x823ce200
	ctx.lr = 0x82909074;
	sub_823CE200(ctx, base);
	// 82909074: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82909078: 4B8AEAA1  bl 0x821b7b18
	ctx.lr = 0x8290907C;
	sub_821B7B18(ctx, base);
	// 8290907C: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82909080: 4B9161D9  bl 0x8221f258
	ctx.lr = 0x82909084;
	sub_8221F258(ctx, base);
	// 82909084: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82909088: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8290908C: 419A0040  beq cr6, 0x829090cc
	if ctx.cr[6].eq {
	pc = 0x829090CC; continue 'dispatch;
	}
	// 82909090: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82909094: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82909098: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 8290909C: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829090A0: 4B9161B9  bl 0x8221f258
	ctx.lr = 0x829090A4;
	sub_8221F258(ctx, base);
	// 829090A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829090A8: 419A0028  beq cr6, 0x829090d0
	if ctx.cr[6].eq {
	pc = 0x829090D0; continue 'dispatch;
	}
	// 829090AC: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 829090B0: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 829090B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829090B8: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 829090BC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829090C0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829090C4: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 829090C8: 4800000C  b 0x829090d4
	pc = 0x829090D4; continue 'dispatch;
            }
            0x829090CC => {
    //   block [0x829090CC..0x829090D0)
	// 829090CC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x829090D0; continue 'dispatch;
            }
            0x829090D0 => {
    //   block [0x829090D0..0x829090D4)
	// 829090D0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x829090D4; continue 'dispatch;
            }
            0x829090D4 => {
    //   block [0x829090D4..0x829091D8)
	// 829090D4: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829090D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829090DC: 419A00FC  beq cr6, 0x829091d8
	if ctx.cr[6].eq {
	pc = 0x829091D8; continue 'dispatch;
	}
	// 829090E0: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829090E4: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 829090E8: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829090EC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829090F0: 4B920019  bl 0x82229108
	ctx.lr = 0x829090F4;
	sub_82229108(ctx, base);
	// 829090F4: 3D608291  lis r11, -0x7d6f
	ctx.r[11].s64 = -2104426496;
	// 829090F8: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 829090FC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82909100: 3BCB9A90  addi r30, r11, -0x6570
	ctx.r[30].s64 = ctx.r[11].s64 + -25968;
	// 82909104: 4B91E77D  bl 0x82227880
	ctx.lr = 0x82909108;
	sub_82227880(ctx, base);
	// 82909108: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8290910C: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 82909110: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82909114: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 82909118: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8290911C: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82909120: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82909124: 4B89195D  bl 0x8219aa80
	ctx.lr = 0x82909128;
	sub_8219AA80(ctx, base);
	// 82909128: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 8290912C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82909130: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 82909134: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82909138: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8290913C: 4BAC52E5  bl 0x823ce420
	ctx.lr = 0x82909140;
	sub_823CE420(ctx, base);
	// 82909140: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82909144: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 82909148: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8290914C: 4811B57D  bl 0x82a246c8
	ctx.lr = 0x82909150;
	sub_82A246C8(ctx, base);
	// 82909150: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82909154: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 82909158: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 8290915C: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82909160: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82909164: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82909168: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8290916C: 4B91FF9D  bl 0x82229108
	ctx.lr = 0x82909170;
	sub_82229108(ctx, base);
	// 82909170: 3D608232  lis r11, -0x7dce
	ctx.r[11].s64 = -2110652416;
	// 82909174: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82909178: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8290917C: 3BEB6EB0  addi r31, r11, 0x6eb0
	ctx.r[31].s64 = ctx.r[11].s64 + 28336;
	// 82909180: 4B91E701  bl 0x82227880
	ctx.lr = 0x82909184;
	sub_82227880(ctx, base);
	// 82909184: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82909188: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 8290918C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82909190: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 82909194: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82909198: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 8290919C: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 829091A0: 4B8918E1  bl 0x8219aa80
	ctx.lr = 0x829091A4;
	sub_8219AA80(ctx, base);
	// 829091A4: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 829091A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829091AC: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 829091B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829091B4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829091B8: 4BAC5269  bl 0x823ce420
	ctx.lr = 0x829091BC;
	sub_823CE420(ctx, base);
	// 829091BC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829091C0: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 829091C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829091C8: 4811B501  bl 0x82a246c8
	ctx.lr = 0x829091CC;
	sub_82A246C8(ctx, base);
	// 829091CC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829091D0: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 829091D4: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	pc = 0x829091D8; continue 'dispatch;
            }
            0x829091D8 => {
    //   block [0x829091D8..0x829091E8)
	// 829091D8: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 829091DC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829091E0: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 829091E4: 419A0020  beq cr6, 0x82909204
	if ctx.cr[6].eq {
	pc = 0x82909204; continue 'dispatch;
	}
	pc = 0x829091E8; continue 'dispatch;
            }
            0x829091E8 => {
    //   block [0x829091E8..0x82909204)
	// 829091E8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 829091EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829091F0: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 829091F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829091F8: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829091FC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82909200: 4082FFE8  bne 0x829091e8
	if !ctx.cr[0].eq {
	pc = 0x829091E8; continue 'dispatch;
	}
	pc = 0x82909204; continue 'dispatch;
            }
            0x82909204 => {
    //   block [0x82909204..0x82909224)
	// 82909204: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82909208: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8290920C: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 82909210: 4B9EC739  bl 0x822f5948
	ctx.lr = 0x82909214;
	sub_822F5948(ctx, base);
	// 82909214: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82909218: 4B8AE901  bl 0x821b7b18
	ctx.lr = 0x8290921C;
	sub_821B7B18(ctx, base);
	// 8290921C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82909220: 419A0040  beq cr6, 0x82909260
	if ctx.cr[6].eq {
	pc = 0x82909260; continue 'dispatch;
	}
	pc = 0x82909224; continue 'dispatch;
            }
            0x82909224 => {
    //   block [0x82909224..0x82909260)
	// 82909224: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82909228: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290922C: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82909230: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82909234: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82909238: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290923C: 4082FFE8  bne 0x82909224
	if !ctx.cr[0].eq {
	pc = 0x82909224; continue 'dispatch;
	}
	// 82909240: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82909244: 409A001C  bne cr6, 0x82909260
	if !ctx.cr[6].eq {
	pc = 0x82909260; continue 'dispatch;
	}
	// 82909248: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290924C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82909250: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82909254: 4E800421  bctrl
	ctx.lr = 0x82909258;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82909258: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8290925C: 4B912ADD  bl 0x8221bd38
	ctx.lr = 0x82909260;
	sub_8221BD38(ctx, base);
            }
            0x82909260 => {
    //   block [0x82909260..0x82909270)
	// 82909260: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82909264: 4B8AE8B5  bl 0x821b7b18
	ctx.lr = 0x82909268;
	sub_821B7B18(ctx, base);
	// 82909268: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8290926C: 483A01E4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82909270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82909270 size=516
    let mut pc: u32 = 0x82909270;
    'dispatch: loop {
        match pc {
            0x82909270 => {
    //   block [0x82909270..0x829092AC)
	// 82909270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82909274: 483A0189  bl 0x82ca93fc
	ctx.lr = 0x82909278;
	sub_82CA93D0(ctx, base);
	// 82909278: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290927C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82909280: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 82909284: 3D408291  lis r10, -0x7d6f
	ctx.r[10].s64 = -2104426496;
	// 82909288: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 8290928C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82909290: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82909294: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82909298: 3BAA80E8  addi r29, r10, -0x7f18
	ctx.r[29].s64 = ctx.r[10].s64 + -32536;
	// 8290929C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829092A0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 829092A4: 419A0008  beq cr6, 0x829092ac
	if ctx.cr[6].eq {
	pc = 0x829092AC; continue 'dispatch;
	}
	// 829092A8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829092AC; continue 'dispatch;
            }
            0x829092AC => {
    //   block [0x829092AC..0x82909340)
	// 829092AC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829092B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829092B4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829092B8: 4BAC5309  bl 0x823ce5c0
	ctx.lr = 0x829092BC;
	sub_823CE5C0(ctx, base);
	// 829092BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829092C0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829092C4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829092C8: 4BAC4E49  bl 0x823ce110
	ctx.lr = 0x829092CC;
	sub_823CE110(ctx, base);
	// 829092CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829092D0: 4B8AE849  bl 0x821b7b18
	ctx.lr = 0x829092D4;
	sub_821B7B18(ctx, base);
	// 829092D4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829092D8: 4B915F81  bl 0x8221f258
	ctx.lr = 0x829092DC;
	sub_8221F258(ctx, base);
	// 829092DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829092E0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829092E4: 419A005C  beq cr6, 0x82909340
	if ctx.cr[6].eq {
	pc = 0x82909340; continue 'dispatch;
	}
	// 829092E8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 829092EC: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 829092F0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829092F4: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 829092F8: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829092FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82909300: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82909304: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82909308: 4B8E6F39  bl 0x821f0240
	ctx.lr = 0x8290930C;
	sub_821F0240(ctx, base);
	// 8290930C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82909310: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82909314: 4B915F45  bl 0x8221f258
	ctx.lr = 0x82909318;
	sub_8221F258(ctx, base);
	// 82909318: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8290931C: 419A0028  beq cr6, 0x82909344
	if ctx.cr[6].eq {
	pc = 0x82909344; continue 'dispatch;
	}
	// 82909320: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 82909324: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82909328: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290932C: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 82909330: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82909334: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82909338: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8290933C: 4800000C  b 0x82909348
	pc = 0x82909348; continue 'dispatch;
            }
            0x82909340 => {
    //   block [0x82909340..0x82909344)
	// 82909340: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x82909344; continue 'dispatch;
            }
            0x82909344 => {
    //   block [0x82909344..0x82909348)
	// 82909344: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82909348; continue 'dispatch;
            }
            0x82909348 => {
    //   block [0x82909348..0x8290935C)
	// 82909348: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290934C: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82909350: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82909354: 419A0008  beq cr6, 0x8290935c
	if ctx.cr[6].eq {
	pc = 0x8290935C; continue 'dispatch;
	}
	// 82909358: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8290935C; continue 'dispatch;
            }
            0x8290935C => {
    //   block [0x8290935C..0x829093DC)
	// 8290935C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82909360: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82909364: 419A0078  beq cr6, 0x829093dc
	if ctx.cr[6].eq {
	pc = 0x829093DC; continue 'dispatch;
	}
	// 82909368: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290936C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 82909370: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82909374: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82909378: 4B91FD91  bl 0x82229108
	ctx.lr = 0x8290937C;
	sub_82229108(ctx, base);
	// 8290937C: 3D608291  lis r11, -0x7d6f
	ctx.r[11].s64 = -2104426496;
	// 82909380: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82909384: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82909388: 3BCB9AD0  addi r30, r11, -0x6530
	ctx.r[30].s64 = ctx.r[11].s64 + -25904;
	// 8290938C: 4B91E4F5  bl 0x82227880
	ctx.lr = 0x82909390;
	sub_82227880(ctx, base);
	// 82909390: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82909394: 3D40828E  lis r10, -0x7d72
	ctx.r[10].s64 = -2104623104;
	// 82909398: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8290939C: 388A8370  addi r4, r10, -0x7c90
	ctx.r[4].s64 = ctx.r[10].s64 + -31888;
	// 829093A0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829093A4: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 829093A8: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829093AC: 4B8916D5  bl 0x8219aa80
	ctx.lr = 0x829093B0;
	sub_8219AA80(ctx, base);
	// 829093B0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829093B4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829093B8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829093BC: 4BAC5065  bl 0x823ce420
	ctx.lr = 0x829093C0;
	sub_823CE420(ctx, base);
	// 829093C0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829093C4: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 829093C8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829093CC: 4811B2FD  bl 0x82a246c8
	ctx.lr = 0x829093D0;
	sub_82A246C8(ctx, base);
	// 829093D0: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 829093D4: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 829093D8: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x829093DC; continue 'dispatch;
            }
            0x829093DC => {
    //   block [0x829093DC..0x829093EC)
	// 829093DC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829093E0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829093E4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 829093E8: 419A0020  beq cr6, 0x82909408
	if ctx.cr[6].eq {
	pc = 0x82909408; continue 'dispatch;
	}
	pc = 0x829093EC; continue 'dispatch;
            }
            0x829093EC => {
    //   block [0x829093EC..0x82909408)
	// 829093EC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 829093F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829093F4: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 829093F8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829093FC: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82909400: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82909404: 4082FFE8  bne 0x829093ec
	if !ctx.cr[0].eq {
	pc = 0x829093EC; continue 'dispatch;
	}
	pc = 0x82909408; continue 'dispatch;
            }
            0x82909408 => {
    //   block [0x82909408..0x82909428)
	// 82909408: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290940C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82909410: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 82909414: 4B9EC535  bl 0x822f5948
	ctx.lr = 0x82909418;
	sub_822F5948(ctx, base);
	// 82909418: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290941C: 4B8AE6FD  bl 0x821b7b18
	ctx.lr = 0x82909420;
	sub_821B7B18(ctx, base);
	// 82909420: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82909424: 419A0040  beq cr6, 0x82909464
	if ctx.cr[6].eq {
	pc = 0x82909464; continue 'dispatch;
	}
	pc = 0x82909428; continue 'dispatch;
            }
            0x82909428 => {
    //   block [0x82909428..0x82909464)
	// 82909428: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8290942C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82909430: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82909434: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82909438: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8290943C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82909440: 4082FFE8  bne 0x82909428
	if !ctx.cr[0].eq {
	pc = 0x82909428; continue 'dispatch;
	}
	// 82909444: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82909448: 409A001C  bne cr6, 0x82909464
	if !ctx.cr[6].eq {
	pc = 0x82909464; continue 'dispatch;
	}
	// 8290944C: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82909450: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82909454: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82909458: 4E800421  bctrl
	ctx.lr = 0x8290945C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290945C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82909460: 4B9128D9  bl 0x8221bd38
	ctx.lr = 0x82909464;
	sub_8221BD38(ctx, base);
            }
            0x82909464 => {
    //   block [0x82909464..0x82909474)
	// 82909464: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82909468: 4B8AE6B1  bl 0x821b7b18
	ctx.lr = 0x8290946C;
	sub_821B7B18(ctx, base);
	// 8290946C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82909470: 4839FFDC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82909478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82909478 size=516
    let mut pc: u32 = 0x82909478;
    'dispatch: loop {
        match pc {
            0x82909478 => {
    //   block [0x82909478..0x829094B4)
	// 82909478: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290947C: 4839FF81  bl 0x82ca93fc
	ctx.lr = 0x82909480;
	sub_82CA93D0(ctx, base);
	// 82909480: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82909484: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82909488: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 8290948C: 3D408291  lis r10, -0x7d6f
	ctx.r[10].s64 = -2104426496;
	// 82909490: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 82909494: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82909498: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290949C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 829094A0: 3BAA8250  addi r29, r10, -0x7db0
	ctx.r[29].s64 = ctx.r[10].s64 + -32176;
	// 829094A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829094A8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 829094AC: 419A0008  beq cr6, 0x829094b4
	if ctx.cr[6].eq {
	pc = 0x829094B4; continue 'dispatch;
	}
	// 829094B0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829094B4; continue 'dispatch;
            }
            0x829094B4 => {
    //   block [0x829094B4..0x82909548)
	// 829094B4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829094B8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829094BC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829094C0: 4BAC5101  bl 0x823ce5c0
	ctx.lr = 0x829094C4;
	sub_823CE5C0(ctx, base);
	// 829094C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829094C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829094CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829094D0: 4BAC4C41  bl 0x823ce110
	ctx.lr = 0x829094D4;
	sub_823CE110(ctx, base);
	// 829094D4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829094D8: 4B8AE641  bl 0x821b7b18
	ctx.lr = 0x829094DC;
	sub_821B7B18(ctx, base);
	// 829094DC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829094E0: 4B915D79  bl 0x8221f258
	ctx.lr = 0x829094E4;
	sub_8221F258(ctx, base);
	// 829094E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829094E8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829094EC: 419A005C  beq cr6, 0x82909548
	if ctx.cr[6].eq {
	pc = 0x82909548; continue 'dispatch;
	}
	// 829094F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 829094F4: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 829094F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829094FC: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 82909500: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82909504: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82909508: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8290950C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82909510: 4B8E6D31  bl 0x821f0240
	ctx.lr = 0x82909514;
	sub_821F0240(ctx, base);
	// 82909514: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82909518: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 8290951C: 4B915D3D  bl 0x8221f258
	ctx.lr = 0x82909520;
	sub_8221F258(ctx, base);
	// 82909520: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82909524: 419A0028  beq cr6, 0x8290954c
	if ctx.cr[6].eq {
	pc = 0x8290954C; continue 'dispatch;
	}
	// 82909528: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 8290952C: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82909530: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82909534: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 82909538: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8290953C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82909540: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82909544: 4800000C  b 0x82909550
	pc = 0x82909550; continue 'dispatch;
            }
            0x82909548 => {
    //   block [0x82909548..0x8290954C)
	// 82909548: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x8290954C; continue 'dispatch;
            }
            0x8290954C => {
    //   block [0x8290954C..0x82909550)
	// 8290954C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82909550; continue 'dispatch;
            }
            0x82909550 => {
    //   block [0x82909550..0x82909564)
	// 82909550: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82909554: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82909558: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290955C: 419A0008  beq cr6, 0x82909564
	if ctx.cr[6].eq {
	pc = 0x82909564; continue 'dispatch;
	}
	// 82909560: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82909564; continue 'dispatch;
            }
            0x82909564 => {
    //   block [0x82909564..0x829095E4)
	// 82909564: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82909568: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290956C: 419A0078  beq cr6, 0x829095e4
	if ctx.cr[6].eq {
	pc = 0x829095E4; continue 'dispatch;
	}
	// 82909570: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82909574: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 82909578: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290957C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82909580: 4B91FB89  bl 0x82229108
	ctx.lr = 0x82909584;
	sub_82229108(ctx, base);
	// 82909584: 3D608291  lis r11, -0x7d6f
	ctx.r[11].s64 = -2104426496;
	// 82909588: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8290958C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82909590: 3BCB9C50  addi r30, r11, -0x63b0
	ctx.r[30].s64 = ctx.r[11].s64 + -25520;
	// 82909594: 4B91E2ED  bl 0x82227880
	ctx.lr = 0x82909598;
	sub_82227880(ctx, base);
	// 82909598: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8290959C: 3D408289  lis r10, -0x7d77
	ctx.r[10].s64 = -2104950784;
	// 829095A0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829095A4: 388A39E8  addi r4, r10, 0x39e8
	ctx.r[4].s64 = ctx.r[10].s64 + 14824;
	// 829095A8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829095AC: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 829095B0: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829095B4: 4B8914CD  bl 0x8219aa80
	ctx.lr = 0x829095B8;
	sub_8219AA80(ctx, base);
	// 829095B8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829095BC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829095C0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829095C4: 4BAC4E5D  bl 0x823ce420
	ctx.lr = 0x829095C8;
	sub_823CE420(ctx, base);
	// 829095C8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829095CC: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 829095D0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829095D4: 4811B0F5  bl 0x82a246c8
	ctx.lr = 0x829095D8;
	sub_82A246C8(ctx, base);
	// 829095D8: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 829095DC: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 829095E0: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x829095E4; continue 'dispatch;
            }
            0x829095E4 => {
    //   block [0x829095E4..0x829095F4)
	// 829095E4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829095E8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829095EC: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 829095F0: 419A0020  beq cr6, 0x82909610
	if ctx.cr[6].eq {
	pc = 0x82909610; continue 'dispatch;
	}
	pc = 0x829095F4; continue 'dispatch;
            }
            0x829095F4 => {
    //   block [0x829095F4..0x82909610)
	// 829095F4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 829095F8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829095FC: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82909600: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82909604: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82909608: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290960C: 4082FFE8  bne 0x829095f4
	if !ctx.cr[0].eq {
	pc = 0x829095F4; continue 'dispatch;
	}
	pc = 0x82909610; continue 'dispatch;
            }
            0x82909610 => {
    //   block [0x82909610..0x82909630)
	// 82909610: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82909614: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82909618: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 8290961C: 4B9EC32D  bl 0x822f5948
	ctx.lr = 0x82909620;
	sub_822F5948(ctx, base);
	// 82909620: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82909624: 4B8AE4F5  bl 0x821b7b18
	ctx.lr = 0x82909628;
	sub_821B7B18(ctx, base);
	// 82909628: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8290962C: 419A0040  beq cr6, 0x8290966c
	if ctx.cr[6].eq {
	pc = 0x8290966C; continue 'dispatch;
	}
	pc = 0x82909630; continue 'dispatch;
            }
            0x82909630 => {
    //   block [0x82909630..0x8290966C)
	// 82909630: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82909634: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82909638: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8290963C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82909640: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82909644: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82909648: 4082FFE8  bne 0x82909630
	if !ctx.cr[0].eq {
	pc = 0x82909630; continue 'dispatch;
	}
	// 8290964C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82909650: 409A001C  bne cr6, 0x8290966c
	if !ctx.cr[6].eq {
	pc = 0x8290966C; continue 'dispatch;
	}
	// 82909654: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82909658: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290965C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82909660: 4E800421  bctrl
	ctx.lr = 0x82909664;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82909664: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82909668: 4B9126D1  bl 0x8221bd38
	ctx.lr = 0x8290966C;
	sub_8221BD38(ctx, base);
            }
            0x8290966C => {
    //   block [0x8290966C..0x8290967C)
	// 8290966C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82909670: 4B8AE4A9  bl 0x821b7b18
	ctx.lr = 0x82909674;
	sub_821B7B18(ctx, base);
	// 82909674: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82909678: 4839FDD4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82909680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82909680 size=516
    let mut pc: u32 = 0x82909680;
    'dispatch: loop {
        match pc {
            0x82909680 => {
    //   block [0x82909680..0x829096BC)
	// 82909680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82909684: 4839FD79  bl 0x82ca93fc
	ctx.lr = 0x82909688;
	sub_82CA93D0(ctx, base);
	// 82909688: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290968C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82909690: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 82909694: 3D408291  lis r10, -0x7d6f
	ctx.r[10].s64 = -2104426496;
	// 82909698: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 8290969C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 829096A0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829096A4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 829096A8: 3BAA8288  addi r29, r10, -0x7d78
	ctx.r[29].s64 = ctx.r[10].s64 + -32120;
	// 829096AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829096B0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 829096B4: 419A0008  beq cr6, 0x829096bc
	if ctx.cr[6].eq {
	pc = 0x829096BC; continue 'dispatch;
	}
	// 829096B8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829096BC; continue 'dispatch;
            }
            0x829096BC => {
    //   block [0x829096BC..0x82909750)
	// 829096BC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829096C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829096C4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829096C8: 4BAC4EF9  bl 0x823ce5c0
	ctx.lr = 0x829096CC;
	sub_823CE5C0(ctx, base);
	// 829096CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829096D0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829096D4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829096D8: 4BAC4A39  bl 0x823ce110
	ctx.lr = 0x829096DC;
	sub_823CE110(ctx, base);
	// 829096DC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829096E0: 4B8AE439  bl 0x821b7b18
	ctx.lr = 0x829096E4;
	sub_821B7B18(ctx, base);
	// 829096E4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829096E8: 4B915B71  bl 0x8221f258
	ctx.lr = 0x829096EC;
	sub_8221F258(ctx, base);
	// 829096EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829096F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829096F4: 419A005C  beq cr6, 0x82909750
	if ctx.cr[6].eq {
	pc = 0x82909750; continue 'dispatch;
	}
	// 829096F8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 829096FC: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82909700: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82909704: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 82909708: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8290970C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82909710: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82909714: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82909718: 4B8E6B29  bl 0x821f0240
	ctx.lr = 0x8290971C;
	sub_821F0240(ctx, base);
	// 8290971C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82909720: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82909724: 4B915B35  bl 0x8221f258
	ctx.lr = 0x82909728;
	sub_8221F258(ctx, base);
	// 82909728: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8290972C: 419A0028  beq cr6, 0x82909754
	if ctx.cr[6].eq {
	pc = 0x82909754; continue 'dispatch;
	}
	// 82909730: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 82909734: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82909738: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290973C: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 82909740: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82909744: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82909748: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8290974C: 4800000C  b 0x82909758
	pc = 0x82909758; continue 'dispatch;
            }
            0x82909750 => {
    //   block [0x82909750..0x82909754)
	// 82909750: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x82909754; continue 'dispatch;
            }
            0x82909754 => {
    //   block [0x82909754..0x82909758)
	// 82909754: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82909758; continue 'dispatch;
            }
            0x82909758 => {
    //   block [0x82909758..0x8290976C)
	// 82909758: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290975C: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82909760: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82909764: 419A0008  beq cr6, 0x8290976c
	if ctx.cr[6].eq {
	pc = 0x8290976C; continue 'dispatch;
	}
	// 82909768: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8290976C; continue 'dispatch;
            }
            0x8290976C => {
    //   block [0x8290976C..0x829097EC)
	// 8290976C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82909770: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82909774: 419A0078  beq cr6, 0x829097ec
	if ctx.cr[6].eq {
	pc = 0x829097EC; continue 'dispatch;
	}
	// 82909778: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290977C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 82909780: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82909784: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82909788: 4B91F981  bl 0x82229108
	ctx.lr = 0x8290978C;
	sub_82229108(ctx, base);
	// 8290978C: 3D608291  lis r11, -0x7d6f
	ctx.r[11].s64 = -2104426496;
	// 82909790: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82909794: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82909798: 3BCB9E08  addi r30, r11, -0x61f8
	ctx.r[30].s64 = ctx.r[11].s64 + -25080;
	// 8290979C: 4B91E0E5  bl 0x82227880
	ctx.lr = 0x829097A0;
	sub_82227880(ctx, base);
	// 829097A0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829097A4: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 829097A8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829097AC: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 829097B0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829097B4: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 829097B8: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829097BC: 4B8912C5  bl 0x8219aa80
	ctx.lr = 0x829097C0;
	sub_8219AA80(ctx, base);
	// 829097C0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829097C4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829097C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829097CC: 4BAC4C55  bl 0x823ce420
	ctx.lr = 0x829097D0;
	sub_823CE420(ctx, base);
	// 829097D0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829097D4: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 829097D8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829097DC: 4811AEED  bl 0x82a246c8
	ctx.lr = 0x829097E0;
	sub_82A246C8(ctx, base);
	// 829097E0: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 829097E4: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 829097E8: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x829097EC; continue 'dispatch;
            }
            0x829097EC => {
    //   block [0x829097EC..0x829097FC)
	// 829097EC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829097F0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829097F4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 829097F8: 419A0020  beq cr6, 0x82909818
	if ctx.cr[6].eq {
	pc = 0x82909818; continue 'dispatch;
	}
	pc = 0x829097FC; continue 'dispatch;
            }
            0x829097FC => {
    //   block [0x829097FC..0x82909818)
	// 829097FC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82909800: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82909804: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82909808: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8290980C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82909810: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82909814: 4082FFE8  bne 0x829097fc
	if !ctx.cr[0].eq {
	pc = 0x829097FC; continue 'dispatch;
	}
	pc = 0x82909818; continue 'dispatch;
            }
            0x82909818 => {
    //   block [0x82909818..0x82909838)
	// 82909818: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290981C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82909820: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 82909824: 4B9EC125  bl 0x822f5948
	ctx.lr = 0x82909828;
	sub_822F5948(ctx, base);
	// 82909828: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290982C: 4B8AE2ED  bl 0x821b7b18
	ctx.lr = 0x82909830;
	sub_821B7B18(ctx, base);
	// 82909830: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82909834: 419A0040  beq cr6, 0x82909874
	if ctx.cr[6].eq {
	pc = 0x82909874; continue 'dispatch;
	}
	pc = 0x82909838; continue 'dispatch;
            }
            0x82909838 => {
    //   block [0x82909838..0x82909874)
	// 82909838: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8290983C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82909840: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82909844: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82909848: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8290984C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82909850: 4082FFE8  bne 0x82909838
	if !ctx.cr[0].eq {
	pc = 0x82909838; continue 'dispatch;
	}
	// 82909854: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82909858: 409A001C  bne cr6, 0x82909874
	if !ctx.cr[6].eq {
	pc = 0x82909874; continue 'dispatch;
	}
	// 8290985C: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82909860: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82909864: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82909868: 4E800421  bctrl
	ctx.lr = 0x8290986C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290986C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82909870: 4B9124C9  bl 0x8221bd38
	ctx.lr = 0x82909874;
	sub_8221BD38(ctx, base);
            }
            0x82909874 => {
    //   block [0x82909874..0x82909884)
	// 82909874: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82909878: 4B8AE2A1  bl 0x821b7b18
	ctx.lr = 0x8290987C;
	sub_821B7B18(ctx, base);
	// 8290987C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82909880: 4839FBCC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82909888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82909888 size=516
    let mut pc: u32 = 0x82909888;
    'dispatch: loop {
        match pc {
            0x82909888 => {
    //   block [0x82909888..0x829098C4)
	// 82909888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290988C: 4839FB71  bl 0x82ca93fc
	ctx.lr = 0x82909890;
	sub_82CA93D0(ctx, base);
	// 82909890: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82909894: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82909898: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 8290989C: 3D408291  lis r10, -0x7d6f
	ctx.r[10].s64 = -2104426496;
	// 829098A0: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 829098A4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 829098A8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829098AC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 829098B0: 3BAA8290  addi r29, r10, -0x7d70
	ctx.r[29].s64 = ctx.r[10].s64 + -32112;
	// 829098B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829098B8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 829098BC: 419A0008  beq cr6, 0x829098c4
	if ctx.cr[6].eq {
	pc = 0x829098C4; continue 'dispatch;
	}
	// 829098C0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829098C4; continue 'dispatch;
            }
            0x829098C4 => {
    //   block [0x829098C4..0x82909958)
	// 829098C4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829098C8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829098CC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829098D0: 4BAC4CF1  bl 0x823ce5c0
	ctx.lr = 0x829098D4;
	sub_823CE5C0(ctx, base);
	// 829098D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829098D8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829098DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829098E0: 4BAC4831  bl 0x823ce110
	ctx.lr = 0x829098E4;
	sub_823CE110(ctx, base);
	// 829098E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829098E8: 4B8AE231  bl 0x821b7b18
	ctx.lr = 0x829098EC;
	sub_821B7B18(ctx, base);
	// 829098EC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829098F0: 4B915969  bl 0x8221f258
	ctx.lr = 0x829098F4;
	sub_8221F258(ctx, base);
	// 829098F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829098F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829098FC: 419A005C  beq cr6, 0x82909958
	if ctx.cr[6].eq {
	pc = 0x82909958; continue 'dispatch;
	}
	// 82909900: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82909904: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82909908: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8290990C: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 82909910: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82909914: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82909918: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8290991C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82909920: 4B8E6921  bl 0x821f0240
	ctx.lr = 0x82909924;
	sub_821F0240(ctx, base);
	// 82909924: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82909928: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 8290992C: 4B91592D  bl 0x8221f258
	ctx.lr = 0x82909930;
	sub_8221F258(ctx, base);
	// 82909930: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82909934: 419A0028  beq cr6, 0x8290995c
	if ctx.cr[6].eq {
	pc = 0x8290995C; continue 'dispatch;
	}
	// 82909938: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 8290993C: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82909940: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82909944: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 82909948: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8290994C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82909950: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82909954: 4800000C  b 0x82909960
	pc = 0x82909960; continue 'dispatch;
            }
            0x82909958 => {
    //   block [0x82909958..0x8290995C)
	// 82909958: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x8290995C; continue 'dispatch;
            }
            0x8290995C => {
    //   block [0x8290995C..0x82909960)
	// 8290995C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82909960; continue 'dispatch;
            }
            0x82909960 => {
    //   block [0x82909960..0x82909974)
	// 82909960: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82909964: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82909968: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290996C: 419A0008  beq cr6, 0x82909974
	if ctx.cr[6].eq {
	pc = 0x82909974; continue 'dispatch;
	}
	// 82909970: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82909974; continue 'dispatch;
            }
            0x82909974 => {
    //   block [0x82909974..0x829099F4)
	// 82909974: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82909978: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290997C: 419A0078  beq cr6, 0x829099f4
	if ctx.cr[6].eq {
	pc = 0x829099F4; continue 'dispatch;
	}
	// 82909980: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82909984: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 82909988: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290998C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82909990: 4B91F779  bl 0x82229108
	ctx.lr = 0x82909994;
	sub_82229108(ctx, base);
	// 82909994: 3D608291  lis r11, -0x7d6f
	ctx.r[11].s64 = -2104426496;
	// 82909998: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8290999C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829099A0: 3BCB9F80  addi r30, r11, -0x6080
	ctx.r[30].s64 = ctx.r[11].s64 + -24704;
	// 829099A4: 4B91DEDD  bl 0x82227880
	ctx.lr = 0x829099A8;
	sub_82227880(ctx, base);
	// 829099A8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829099AC: 3D40827C  lis r10, -0x7d84
	ctx.r[10].s64 = -2105802752;
	// 829099B0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829099B4: 388AD6C8  addi r4, r10, -0x2938
	ctx.r[4].s64 = ctx.r[10].s64 + -10552;
	// 829099B8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829099BC: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 829099C0: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829099C4: 4B8910BD  bl 0x8219aa80
	ctx.lr = 0x829099C8;
	sub_8219AA80(ctx, base);
	// 829099C8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829099CC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829099D0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829099D4: 4BAC4A4D  bl 0x823ce420
	ctx.lr = 0x829099D8;
	sub_823CE420(ctx, base);
	// 829099D8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829099DC: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 829099E0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829099E4: 4811ACE5  bl 0x82a246c8
	ctx.lr = 0x829099E8;
	sub_82A246C8(ctx, base);
	// 829099E8: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 829099EC: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 829099F0: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x829099F4; continue 'dispatch;
            }
            0x829099F4 => {
    //   block [0x829099F4..0x82909A04)
	// 829099F4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829099F8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829099FC: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82909A00: 419A0020  beq cr6, 0x82909a20
	if ctx.cr[6].eq {
	pc = 0x82909A20; continue 'dispatch;
	}
	pc = 0x82909A04; continue 'dispatch;
            }
            0x82909A04 => {
    //   block [0x82909A04..0x82909A20)
	// 82909A04: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82909A08: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82909A0C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82909A10: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82909A14: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82909A18: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82909A1C: 4082FFE8  bne 0x82909a04
	if !ctx.cr[0].eq {
	pc = 0x82909A04; continue 'dispatch;
	}
	pc = 0x82909A20; continue 'dispatch;
            }
            0x82909A20 => {
    //   block [0x82909A20..0x82909A40)
	// 82909A20: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82909A24: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82909A28: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 82909A2C: 4B9EBF1D  bl 0x822f5948
	ctx.lr = 0x82909A30;
	sub_822F5948(ctx, base);
	// 82909A30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82909A34: 4B8AE0E5  bl 0x821b7b18
	ctx.lr = 0x82909A38;
	sub_821B7B18(ctx, base);
	// 82909A38: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82909A3C: 419A0040  beq cr6, 0x82909a7c
	if ctx.cr[6].eq {
	pc = 0x82909A7C; continue 'dispatch;
	}
	pc = 0x82909A40; continue 'dispatch;
            }
            0x82909A40 => {
    //   block [0x82909A40..0x82909A7C)
	// 82909A40: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82909A44: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82909A48: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82909A4C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82909A50: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82909A54: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82909A58: 4082FFE8  bne 0x82909a40
	if !ctx.cr[0].eq {
	pc = 0x82909A40; continue 'dispatch;
	}
	// 82909A5C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82909A60: 409A001C  bne cr6, 0x82909a7c
	if !ctx.cr[6].eq {
	pc = 0x82909A7C; continue 'dispatch;
	}
	// 82909A64: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82909A68: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82909A6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82909A70: 4E800421  bctrl
	ctx.lr = 0x82909A74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82909A74: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82909A78: 4B9122C1  bl 0x8221bd38
	ctx.lr = 0x82909A7C;
	sub_8221BD38(ctx, base);
            }
            0x82909A7C => {
    //   block [0x82909A7C..0x82909A8C)
	// 82909A7C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82909A80: 4B8AE099  bl 0x821b7b18
	ctx.lr = 0x82909A84;
	sub_821B7B18(ctx, base);
	// 82909A84: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82909A88: 4839F9C4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82909A90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82909A90 size=56
    let mut pc: u32 = 0x82909A90;
    'dispatch: loop {
        match pc {
            0x82909A90 => {
    //   block [0x82909A90..0x82909AAC)
	// 82909A90: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82909A94: 419A0018  beq cr6, 0x82909aac
	if ctx.cr[6].eq {
	pc = 0x82909AAC; continue 'dispatch;
	}
	// 82909A98: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 82909A9C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82909AA0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82909AA4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82909AA8: 409A0008  bne cr6, 0x82909ab0
	if !ctx.cr[6].eq {
	pc = 0x82909AB0; continue 'dispatch;
	}
	pc = 0x82909AAC; continue 'dispatch;
            }
            0x82909AAC => {
    //   block [0x82909AAC..0x82909AB0)
	// 82909AAC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82909AB0; continue 'dispatch;
            }
            0x82909AB0 => {
    //   block [0x82909AB0..0x82909AC8)
	// 82909AB0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82909AB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82909AB8: 419A0010  beq cr6, 0x82909ac8
	if ctx.cr[6].eq {
		sub_82909AC8(ctx, base);
		return;
	}
	// 82909ABC: 81640040  lwz r11, 0x40(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(64 as u32) ) } as u64;
	// 82909AC0: 5563C7FE  rlwinm r3, r11, 0x18, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82909AC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82909AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82909AC8 size=8
    let mut pc: u32 = 0x82909AC8;
    'dispatch: loop {
        match pc {
            0x82909AC8 => {
    //   block [0x82909AC8..0x82909AD0)
	// 82909AC8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82909ACC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82909AD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82909AD0 size=380
    let mut pc: u32 = 0x82909AD0;
    'dispatch: loop {
        match pc {
            0x82909AD0 => {
    //   block [0x82909AD0..0x82909AF8)
	// 82909AD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82909AD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82909AD8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82909ADC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82909AE0: 419A0018  beq cr6, 0x82909af8
	if ctx.cr[6].eq {
	pc = 0x82909AF8; continue 'dispatch;
	}
	// 82909AE4: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 82909AE8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82909AEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82909AF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82909AF4: 409A0008  bne cr6, 0x82909afc
	if !ctx.cr[6].eq {
	pc = 0x82909AFC; continue 'dispatch;
	}
	pc = 0x82909AF8; continue 'dispatch;
            }
            0x82909AF8 => {
    //   block [0x82909AF8..0x82909AFC)
	// 82909AF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82909AFC; continue 'dispatch;
            }
            0x82909AFC => {
    //   block [0x82909AFC..0x82909B44)
	// 82909AFC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82909B00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82909B04: 419A0130  beq cr6, 0x82909c34
	if ctx.cr[6].eq {
	pc = 0x82909C34; continue 'dispatch;
	}
	// 82909B08: 81440040  lwz r10, 0x40(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(64 as u32) ) } as u64;
	// 82909B0C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82909B10: 5549C7FE  rlwinm r9, r10, 0x18, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82909B14: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82909B18: 419A00EC  beq cr6, 0x82909c04
	if ctx.cr[6].eq {
	pc = 0x82909C04; continue 'dispatch;
	}
	// 82909B1C: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 82909B20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82909B24: 419A0020  beq cr6, 0x82909b44
	if ctx.cr[6].eq {
	pc = 0x82909B44; continue 'dispatch;
	}
	// 82909B28: 894B00E8  lbz r10, 0xe8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(232 as u32) ) } as u64;
	// 82909B2C: 81640048  lwz r11, 0x48(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 82909B30: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82909B34: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82909B38: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82909B3C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82909B40: 480000C8  b 0x82909c08
	pc = 0x82909C08; continue 'dispatch;
            }
            0x82909B44 => {
    //   block [0x82909B44..0x82909B64)
	// 82909B44: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 82909B48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82909B4C: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 82909B50: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82909B54: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82909B58: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82909B5C: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82909B60: 40810054  ble 0x82909bb4
	if !ctx.cr[0].gt {
	pc = 0x82909BB4; continue 'dispatch;
	}
	pc = 0x82909B64; continue 'dispatch;
            }
            0x82909B64 => {
    //   block [0x82909B64..0x82909B84)
	// 82909B64: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82909B68: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82909B6C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82909B70: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82909B74: 2F0700E8  cmpwi cr6, r7, 0xe8
	ctx.cr[6].compare_i32(ctx.r[7].s32, 232, &mut ctx.xer);
	// 82909B78: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82909B7C: 41980008  blt cr6, 0x82909b84
	if ctx.cr[6].lt {
	pc = 0x82909B84; continue 'dispatch;
	}
	// 82909B80: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x82909B84; continue 'dispatch;
            }
            0x82909B84 => {
    //   block [0x82909B84..0x82909BA0)
	// 82909B84: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82909B88: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82909B8C: 419A0014  beq cr6, 0x82909ba0
	if ctx.cr[6].eq {
	pc = 0x82909BA0; continue 'dispatch;
	}
	// 82909B90: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82909B94: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82909B98: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82909B9C: 4800000C  b 0x82909ba8
	pc = 0x82909BA8; continue 'dispatch;
            }
            0x82909BA0 => {
    //   block [0x82909BA0..0x82909BA8)
	// 82909BA0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82909BA4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82909BA8; continue 'dispatch;
            }
            0x82909BA8 => {
    //   block [0x82909BA8..0x82909BB4)
	// 82909BA8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82909BAC: 4199FFB8  bgt cr6, 0x82909b64
	if ctx.cr[6].gt {
	pc = 0x82909B64; continue 'dispatch;
	}
	// 82909BB0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82909BB4; continue 'dispatch;
            }
            0x82909BB4 => {
    //   block [0x82909BB4..0x82909BD0)
	// 82909BB4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82909BB8: 419A003C  beq cr6, 0x82909bf4
	if ctx.cr[6].eq {
	pc = 0x82909BF4; continue 'dispatch;
	}
	// 82909BBC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82909BC0: 2F0B00E8  cmpwi cr6, r11, 0xe8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 232, &mut ctx.xer);
	// 82909BC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82909BC8: 41990008  bgt cr6, 0x82909bd0
	if ctx.cr[6].gt {
	pc = 0x82909BD0; continue 'dispatch;
	}
	// 82909BCC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82909BD0; continue 'dispatch;
            }
            0x82909BD0 => {
    //   block [0x82909BD0..0x82909BF4)
	// 82909BD0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82909BD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82909BD8: 409A001C  bne cr6, 0x82909bf4
	if !ctx.cr[6].eq {
	pc = 0x82909BF4; continue 'dispatch;
	}
	// 82909BDC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82909BE0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82909BE4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82909BE8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82909BEC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82909BF0: 48000018  b 0x82909c08
	pc = 0x82909C08; continue 'dispatch;
            }
            0x82909BF4 => {
    //   block [0x82909BF4..0x82909C04)
	// 82909BF4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82909BF8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82909BFC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82909C00: 48000008  b 0x82909c08
	pc = 0x82909C08; continue 'dispatch;
            }
            0x82909C04 => {
    //   block [0x82909C04..0x82909C08)
	// 82909C04: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82909C08; continue 'dispatch;
            }
            0x82909C08 => {
    //   block [0x82909C08..0x82909C34)
	// 82909C08: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82909C0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82909C10: 419A0024  beq cr6, 0x82909c34
	if ctx.cr[6].eq {
	pc = 0x82909C34; continue 'dispatch;
	}
	// 82909C14: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82909C18: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82909C1C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82909C20: 4E800421  bctrl
	ctx.lr = 0x82909C24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82909C24: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82909C28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82909C2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82909C30: 4E800020  blr
	return;
            }
            0x82909C34 => {
    //   block [0x82909C34..0x82909C4C)
	// 82909C34: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82909C38: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82909C3C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82909C40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82909C44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82909C48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82909C50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82909C50 size=440
    let mut pc: u32 = 0x82909C50;
    'dispatch: loop {
        match pc {
            0x82909C50 => {
    //   block [0x82909C50..0x82909C84)
	// 82909C50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82909C54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82909C58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82909C5C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82909C60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82909C64: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82909C68: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82909C6C: 419A0018  beq cr6, 0x82909c84
	if ctx.cr[6].eq {
	pc = 0x82909C84; continue 'dispatch;
	}
	// 82909C70: 89650090  lbz r11, 0x90(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(144 as u32) ) } as u64;
	// 82909C74: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82909C78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82909C7C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82909C80: 409A0008  bne cr6, 0x82909c88
	if !ctx.cr[6].eq {
	pc = 0x82909C88; continue 'dispatch;
	}
	pc = 0x82909C84; continue 'dispatch;
            }
            0x82909C84 => {
    //   block [0x82909C84..0x82909C88)
	// 82909C84: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x82909C88; continue 'dispatch;
            }
            0x82909C88 => {
    //   block [0x82909C88..0x82909CD0)
	// 82909C88: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82909C8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82909C90: 419A0138  beq cr6, 0x82909dc8
	if ctx.cr[6].eq {
	pc = 0x82909DC8; continue 'dispatch;
	}
	// 82909C94: 81450040  lwz r10, 0x40(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(64 as u32) ) } as u64;
	// 82909C98: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82909C9C: 5549C7FE  rlwinm r9, r10, 0x18, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82909CA0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82909CA4: 419A00E8  beq cr6, 0x82909d8c
	if ctx.cr[6].eq {
	pc = 0x82909D8C; continue 'dispatch;
	}
	// 82909CA8: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 82909CAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82909CB0: 419A0020  beq cr6, 0x82909cd0
	if ctx.cr[6].eq {
	pc = 0x82909CD0; continue 'dispatch;
	}
	// 82909CB4: 894B00E8  lbz r10, 0xe8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(232 as u32) ) } as u64;
	// 82909CB8: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 82909CBC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 82909CC0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82909CC4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82909CC8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82909CCC: 480000C4  b 0x82909d90
	pc = 0x82909D90; continue 'dispatch;
            }
            0x82909CD0 => {
    //   block [0x82909CD0..0x82909CEC)
	// 82909CD0: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 82909CD4: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 82909CD8: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82909CDC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82909CE0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82909CE4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82909CE8: 40810054  ble 0x82909d3c
	if !ctx.cr[0].gt {
	pc = 0x82909D3C; continue 'dispatch;
	}
	pc = 0x82909CEC; continue 'dispatch;
            }
            0x82909CEC => {
    //   block [0x82909CEC..0x82909D0C)
	// 82909CEC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82909CF0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82909CF4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82909CF8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82909CFC: 2F0700E8  cmpwi cr6, r7, 0xe8
	ctx.cr[6].compare_i32(ctx.r[7].s32, 232, &mut ctx.xer);
	// 82909D00: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82909D04: 41980008  blt cr6, 0x82909d0c
	if ctx.cr[6].lt {
	pc = 0x82909D0C; continue 'dispatch;
	}
	// 82909D08: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x82909D0C; continue 'dispatch;
            }
            0x82909D0C => {
    //   block [0x82909D0C..0x82909D28)
	// 82909D0C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82909D10: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82909D14: 419A0014  beq cr6, 0x82909d28
	if ctx.cr[6].eq {
	pc = 0x82909D28; continue 'dispatch;
	}
	// 82909D18: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82909D1C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82909D20: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82909D24: 4800000C  b 0x82909d30
	pc = 0x82909D30; continue 'dispatch;
            }
            0x82909D28 => {
    //   block [0x82909D28..0x82909D30)
	// 82909D28: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82909D2C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82909D30; continue 'dispatch;
            }
            0x82909D30 => {
    //   block [0x82909D30..0x82909D3C)
	// 82909D30: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82909D34: 4199FFB8  bgt cr6, 0x82909cec
	if ctx.cr[6].gt {
	pc = 0x82909CEC; continue 'dispatch;
	}
	// 82909D38: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82909D3C; continue 'dispatch;
            }
            0x82909D3C => {
    //   block [0x82909D3C..0x82909D58)
	// 82909D3C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82909D40: 419A003C  beq cr6, 0x82909d7c
	if ctx.cr[6].eq {
	pc = 0x82909D7C; continue 'dispatch;
	}
	// 82909D44: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82909D48: 2F0B00E8  cmpwi cr6, r11, 0xe8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 232, &mut ctx.xer);
	// 82909D4C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82909D50: 41990008  bgt cr6, 0x82909d58
	if ctx.cr[6].gt {
	pc = 0x82909D58; continue 'dispatch;
	}
	// 82909D54: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x82909D58; continue 'dispatch;
            }
            0x82909D58 => {
    //   block [0x82909D58..0x82909D7C)
	// 82909D58: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82909D5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82909D60: 409A001C  bne cr6, 0x82909d7c
	if !ctx.cr[6].eq {
	pc = 0x82909D7C; continue 'dispatch;
	}
	// 82909D64: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82909D68: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82909D6C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82909D70: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82909D74: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82909D78: 48000018  b 0x82909d90
	pc = 0x82909D90; continue 'dispatch;
            }
            0x82909D7C => {
    //   block [0x82909D7C..0x82909D8C)
	// 82909D7C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82909D80: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82909D84: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82909D88: 48000008  b 0x82909d90
	pc = 0x82909D90; continue 'dispatch;
            }
            0x82909D8C => {
    //   block [0x82909D8C..0x82909D90)
	// 82909D8C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	pc = 0x82909D90; continue 'dispatch;
            }
            0x82909D90 => {
    //   block [0x82909D90..0x82909DC8)
	// 82909D90: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82909D94: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82909D98: 419A0030  beq cr6, 0x82909dc8
	if ctx.cr[6].eq {
	pc = 0x82909DC8; continue 'dispatch;
	}
	// 82909D9C: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82909DA0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82909DA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82909DA8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82909DAC: 4E800421  bctrl
	ctx.lr = 0x82909DB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82909DB0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82909DB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82909DB8: 4B8E6489  bl 0x821f0240
	ctx.lr = 0x82909DBC;
	sub_821F0240(ctx, base);
	// 82909DBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82909DC0: 4B90B019  bl 0x82214dd8
	ctx.lr = 0x82909DC4;
	sub_82214DD8(ctx, base);
	// 82909DC4: 4800002C  b 0x82909df0
	pc = 0x82909DF0; continue 'dispatch;
            }
            0x82909DC8 => {
    //   block [0x82909DC8..0x82909DD4)
	// 82909DC8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82909DCC: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82909DD0: 390B7088  addi r8, r11, 0x7088
	ctx.r[8].s64 = ctx.r[11].s64 + 28808;
	pc = 0x82909DD4; continue 'dispatch;
            }
            0x82909DD4 => {
    //   block [0x82909DD4..0x82909DF0)
	// 82909DD4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82909DD8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82909DDC: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82909DE0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82909DE4: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82909DE8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82909DEC: 4082FFE8  bne 0x82909dd4
	if !ctx.cr[0].eq {
	pc = 0x82909DD4; continue 'dispatch;
	}
	pc = 0x82909DF0; continue 'dispatch;
            }
            0x82909DF0 => {
    //   block [0x82909DF0..0x82909E08)
	// 82909DF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82909DF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82909DF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82909DFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82909E00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82909E04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82909E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82909E08 size=372
    let mut pc: u32 = 0x82909E08;
    'dispatch: loop {
        match pc {
            0x82909E08 => {
    //   block [0x82909E08..0x82909E30)
	// 82909E08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82909E0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82909E10: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82909E14: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82909E18: 419A0018  beq cr6, 0x82909e30
	if ctx.cr[6].eq {
	pc = 0x82909E30; continue 'dispatch;
	}
	// 82909E1C: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 82909E20: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82909E24: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82909E28: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82909E2C: 409A0008  bne cr6, 0x82909e34
	if !ctx.cr[6].eq {
	pc = 0x82909E34; continue 'dispatch;
	}
	pc = 0x82909E30; continue 'dispatch;
            }
            0x82909E30 => {
    //   block [0x82909E30..0x82909E34)
	// 82909E30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82909E34; continue 'dispatch;
            }
            0x82909E34 => {
    //   block [0x82909E34..0x82909E7C)
	// 82909E34: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82909E38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82909E3C: 419A012C  beq cr6, 0x82909f68
	if ctx.cr[6].eq {
	pc = 0x82909F68; continue 'dispatch;
	}
	// 82909E40: 81440040  lwz r10, 0x40(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(64 as u32) ) } as u64;
	// 82909E44: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82909E48: 5549C7FE  rlwinm r9, r10, 0x18, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82909E4C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82909E50: 419A00E8  beq cr6, 0x82909f38
	if ctx.cr[6].eq {
	pc = 0x82909F38; continue 'dispatch;
	}
	// 82909E54: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 82909E58: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 82909E5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82909E60: 419A001C  beq cr6, 0x82909e7c
	if ctx.cr[6].eq {
	pc = 0x82909E7C; continue 'dispatch;
	}
	// 82909E64: 896B00E8  lbz r11, 0xe8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(232 as u32) ) } as u64;
	// 82909E68: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 82909E6C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82909E70: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82909E74: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82909E78: 480000C4  b 0x82909f3c
	pc = 0x82909F3C; continue 'dispatch;
            }
            0x82909E7C => {
    //   block [0x82909E7C..0x82909E98)
	// 82909E7C: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 82909E80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82909E84: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82909E88: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82909E8C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82909E90: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82909E94: 40810054  ble 0x82909ee8
	if !ctx.cr[0].gt {
	pc = 0x82909EE8; continue 'dispatch;
	}
	pc = 0x82909E98; continue 'dispatch;
            }
            0x82909E98 => {
    //   block [0x82909E98..0x82909EB8)
	// 82909E98: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82909E9C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82909EA0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82909EA4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82909EA8: 2F0700E8  cmpwi cr6, r7, 0xe8
	ctx.cr[6].compare_i32(ctx.r[7].s32, 232, &mut ctx.xer);
	// 82909EAC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82909EB0: 41980008  blt cr6, 0x82909eb8
	if ctx.cr[6].lt {
	pc = 0x82909EB8; continue 'dispatch;
	}
	// 82909EB4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x82909EB8; continue 'dispatch;
            }
            0x82909EB8 => {
    //   block [0x82909EB8..0x82909ED4)
	// 82909EB8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82909EBC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82909EC0: 419A0014  beq cr6, 0x82909ed4
	if ctx.cr[6].eq {
	pc = 0x82909ED4; continue 'dispatch;
	}
	// 82909EC4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82909EC8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82909ECC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82909ED0: 4800000C  b 0x82909edc
	pc = 0x82909EDC; continue 'dispatch;
            }
            0x82909ED4 => {
    //   block [0x82909ED4..0x82909EDC)
	// 82909ED4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82909ED8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82909EDC; continue 'dispatch;
            }
            0x82909EDC => {
    //   block [0x82909EDC..0x82909EE8)
	// 82909EDC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82909EE0: 4199FFB8  bgt cr6, 0x82909e98
	if ctx.cr[6].gt {
	pc = 0x82909E98; continue 'dispatch;
	}
	// 82909EE4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82909EE8; continue 'dispatch;
            }
            0x82909EE8 => {
    //   block [0x82909EE8..0x82909F04)
	// 82909EE8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82909EEC: 419A003C  beq cr6, 0x82909f28
	if ctx.cr[6].eq {
	pc = 0x82909F28; continue 'dispatch;
	}
	// 82909EF0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82909EF4: 2F0B00E8  cmpwi cr6, r11, 0xe8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 232, &mut ctx.xer);
	// 82909EF8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82909EFC: 41990008  bgt cr6, 0x82909f04
	if ctx.cr[6].gt {
	pc = 0x82909F04; continue 'dispatch;
	}
	// 82909F00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82909F04; continue 'dispatch;
            }
            0x82909F04 => {
    //   block [0x82909F04..0x82909F28)
	// 82909F04: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82909F08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82909F0C: 409A001C  bne cr6, 0x82909f28
	if !ctx.cr[6].eq {
	pc = 0x82909F28; continue 'dispatch;
	}
	// 82909F10: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82909F14: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82909F18: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82909F1C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82909F20: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82909F24: 48000018  b 0x82909f3c
	pc = 0x82909F3C; continue 'dispatch;
            }
            0x82909F28 => {
    //   block [0x82909F28..0x82909F38)
	// 82909F28: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82909F2C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82909F30: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82909F34: 48000008  b 0x82909f3c
	pc = 0x82909F3C; continue 'dispatch;
            }
            0x82909F38 => {
    //   block [0x82909F38..0x82909F3C)
	// 82909F38: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82909F3C; continue 'dispatch;
            }
            0x82909F3C => {
    //   block [0x82909F3C..0x82909F68)
	// 82909F3C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82909F40: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82909F44: 419A0024  beq cr6, 0x82909f68
	if ctx.cr[6].eq {
	pc = 0x82909F68; continue 'dispatch;
	}
	// 82909F48: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82909F4C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82909F50: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82909F54: 4E800421  bctrl
	ctx.lr = 0x82909F58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82909F58: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82909F5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82909F60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82909F64: 4E800020  blr
	return;
            }
            0x82909F68 => {
    //   block [0x82909F68..0x82909F7C)
	// 82909F68: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82909F6C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82909F70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82909F74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82909F78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82909F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82909F80 size=376
    let mut pc: u32 = 0x82909F80;
    'dispatch: loop {
        match pc {
            0x82909F80 => {
    //   block [0x82909F80..0x82909FAC)
	// 82909F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82909F84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82909F88: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82909F8C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82909F90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82909F94: 419A0018  beq cr6, 0x82909fac
	if ctx.cr[6].eq {
	pc = 0x82909FAC; continue 'dispatch;
	}
	// 82909F98: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 82909F9C: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82909FA0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82909FA4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82909FA8: 409A0008  bne cr6, 0x82909fb0
	if !ctx.cr[6].eq {
	pc = 0x82909FB0; continue 'dispatch;
	}
	pc = 0x82909FAC; continue 'dispatch;
            }
            0x82909FAC => {
    //   block [0x82909FAC..0x82909FB0)
	// 82909FAC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82909FB0; continue 'dispatch;
            }
            0x82909FB0 => {
    //   block [0x82909FB0..0x82909FFC)
	// 82909FB0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82909FB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82909FB8: 419A0130  beq cr6, 0x8290a0e8
	if ctx.cr[6].eq {
	pc = 0x8290A0E8; continue 'dispatch;
	}
	// 82909FBC: 812B0040  lwz r9, 0x40(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82909FC0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82909FC4: 5528C7FE  rlwinm r8, r9, 0x18, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82909FC8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82909FCC: 419A00F8  beq cr6, 0x8290a0c4
	if ctx.cr[6].eq {
	pc = 0x8290A0C4; continue 'dispatch;
	}
	// 82909FD0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82909FD4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82909FD8: 419A0024  beq cr6, 0x82909ffc
	if ctx.cr[6].eq {
	pc = 0x82909FFC; continue 'dispatch;
	}
	// 82909FDC: 892A00E8  lbz r9, 0xe8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(232 as u32) ) } as u64;
	// 82909FE0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82909FE4: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 82909FE8: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82909FEC: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82909FF0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82909FF4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82909FF8: 480000D0  b 0x8290a0c8
	pc = 0x8290A0C8; continue 'dispatch;
            }
            0x82909FFC => {
    //   block [0x82909FFC..0x8290A01C)
	// 82909FFC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8290A000: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8290A004: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8290A008: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 8290A00C: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8290A010: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8290A014: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290A018: 40810054  ble 0x8290a06c
	if !ctx.cr[0].gt {
	pc = 0x8290A06C; continue 'dispatch;
	}
	pc = 0x8290A01C; continue 'dispatch;
            }
            0x8290A01C => {
    //   block [0x8290A01C..0x8290A03C)
	// 8290A01C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8290A020: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8290A024: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8290A028: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290A02C: 2F0700E8  cmpwi cr6, r7, 0xe8
	ctx.cr[6].compare_i32(ctx.r[7].s32, 232, &mut ctx.xer);
	// 8290A030: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8290A034: 41980008  blt cr6, 0x8290a03c
	if ctx.cr[6].lt {
	pc = 0x8290A03C; continue 'dispatch;
	}
	// 8290A038: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x8290A03C; continue 'dispatch;
            }
            0x8290A03C => {
    //   block [0x8290A03C..0x8290A058)
	// 8290A03C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8290A040: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8290A044: 419A0014  beq cr6, 0x8290a058
	if ctx.cr[6].eq {
	pc = 0x8290A058; continue 'dispatch;
	}
	// 8290A048: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8290A04C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8290A050: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8290A054: 4800000C  b 0x8290a060
	pc = 0x8290A060; continue 'dispatch;
            }
            0x8290A058 => {
    //   block [0x8290A058..0x8290A060)
	// 8290A058: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8290A05C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8290A060; continue 'dispatch;
            }
            0x8290A060 => {
    //   block [0x8290A060..0x8290A06C)
	// 8290A060: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290A064: 4199FFB8  bgt cr6, 0x8290a01c
	if ctx.cr[6].gt {
	pc = 0x8290A01C; continue 'dispatch;
	}
	// 8290A068: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8290A06C; continue 'dispatch;
            }
            0x8290A06C => {
    //   block [0x8290A06C..0x8290A088)
	// 8290A06C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8290A070: 419A0040  beq cr6, 0x8290a0b0
	if ctx.cr[6].eq {
	pc = 0x8290A0B0; continue 'dispatch;
	}
	// 8290A074: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290A078: 2F0B00E8  cmpwi cr6, r11, 0xe8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 232, &mut ctx.xer);
	// 8290A07C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290A080: 41990008  bgt cr6, 0x8290a088
	if ctx.cr[6].gt {
	pc = 0x8290A088; continue 'dispatch;
	}
	// 8290A084: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8290A088; continue 'dispatch;
            }
            0x8290A088 => {
    //   block [0x8290A088..0x8290A0B0)
	// 8290A088: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290A08C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290A090: 409A0020  bne cr6, 0x8290a0b0
	if !ctx.cr[6].eq {
	pc = 0x8290A0B0; continue 'dispatch;
	}
	// 8290A094: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8290A098: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8290A09C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8290A0A0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290A0A4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8290A0A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290A0AC: 4800001C  b 0x8290a0c8
	pc = 0x8290A0C8; continue 'dispatch;
            }
            0x8290A0B0 => {
    //   block [0x8290A0B0..0x8290A0C4)
	// 8290A0B0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8290A0B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290A0B8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8290A0BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290A0C0: 48000008  b 0x8290a0c8
	pc = 0x8290A0C8; continue 'dispatch;
            }
            0x8290A0C4 => {
    //   block [0x8290A0C4..0x8290A0C8)
	// 8290A0C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8290A0C8; continue 'dispatch;
            }
            0x8290A0C8 => {
    //   block [0x8290A0C8..0x8290A0E8)
	// 8290A0C8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290A0CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290A0D0: 419A0018  beq cr6, 0x8290a0e8
	if ctx.cr[6].eq {
	pc = 0x8290A0E8; continue 'dispatch;
	}
	// 8290A0D4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290A0D8: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 8290A0DC: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 8290A0E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8290A0E4: 4E800421  bctrl
	ctx.lr = 0x8290A0E8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8290A0E8 => {
    //   block [0x8290A0E8..0x8290A0F8)
	// 8290A0E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8290A0EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8290A0F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290A0F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290A0F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290A0F8 size=60
    let mut pc: u32 = 0x8290A0F8;
    'dispatch: loop {
        match pc {
            0x8290A0F8 => {
    //   block [0x8290A0F8..0x8290A134)
	// 8290A0F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290A0FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8290A100: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8290A104: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290A108: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8290A10C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8290A110: 388B973C  addi r4, r11, -0x68c4
	ctx.r[4].s64 = ctx.r[11].s64 + -26820;
	// 8290A114: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290A118: 4B922DB9  bl 0x8222ced0
	ctx.lr = 0x8290A11C;
	sub_8222CED0(ctx, base);
	// 8290A11C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290A120: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8290A124: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8290A128: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290A12C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8290A130: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290A140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8290A140 size=8
    let mut pc: u32 = 0x8290A140;
    'dispatch: loop {
        match pc {
            0x8290A140 => {
    //   block [0x8290A140..0x8290A148)
	// 8290A140: 80630028  lwz r3, 0x28(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 8290A144: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290A148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290A148 size=148
    let mut pc: u32 = 0x8290A148;
    'dispatch: loop {
        match pc {
            0x8290A148 => {
    //   block [0x8290A148..0x8290A1A4)
	// 8290A148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290A14C: 4839F2BD  bl 0x82ca9408
	ctx.lr = 0x8290A150;
	sub_82CA93D0(ctx, base);
	// 8290A150: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290A154: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290A158: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8290A15C: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 8290A160: 3B8B0B7C  addi r28, r11, 0xb7c
	ctx.r[28].s64 = ctx.r[11].s64 + 2940;
	// 8290A164: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8290A168: 939F0020  stw r28, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[28].u32 ) };
	// 8290A16C: 4B889CCD  bl 0x82193e38
	ctx.lr = 0x8290A170;
	sub_82193E38(ctx, base);
	// 8290A170: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8290A174: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 8290A178: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 8290A17C: 939F0018  stw r28, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[28].u32 ) };
	// 8290A180: 4B889CB9  bl 0x82193e38
	ctx.lr = 0x8290A184;
	sub_82193E38(ctx, base);
	// 8290A184: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 8290A188: 939F0010  stw r28, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[28].u32 ) };
	// 8290A18C: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 8290A190: 4B889CA9  bl 0x82193e38
	ctx.lr = 0x8290A194;
	sub_82193E38(ctx, base);
	// 8290A194: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8290A198: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 8290A19C: 419A0008  beq cr6, 0x8290a1a4
	if ctx.cr[6].eq {
	pc = 0x8290A1A4; continue 'dispatch;
	}
	// 8290A1A0: 3BDF000C  addi r30, r31, 0xc
	ctx.r[30].s64 = ctx.r[31].s64 + 12;
	pc = 0x8290A1A4; continue 'dispatch;
            }
            0x8290A1A4 => {
    //   block [0x8290A1A4..0x8290A1D4)
	// 8290A1A4: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 8290A1A8: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 8290A1AC: 392B79A4  addi r9, r11, 0x79a4
	ctx.r[9].s64 = ctx.r[11].s64 + 31140;
	// 8290A1B0: 390A2850  addi r8, r10, 0x2850
	ctx.r[8].s64 = ctx.r[10].s64 + 10320;
	// 8290A1B4: 57A707FE  clrlwi r7, r29, 0x1f
	ctx.r[7].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	// 8290A1B8: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8290A1BC: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 8290A1C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290A1C4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8290A1C8: 419A000C  beq cr6, 0x8290a1d4
	if ctx.cr[6].eq {
	pc = 0x8290A1D4; continue 'dispatch;
	}
	// 8290A1CC: 4B911B6D  bl 0x8221bd38
	ctx.lr = 0x8290A1D0;
	sub_8221BD38(ctx, base);
	// 8290A1D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x8290A1D4; continue 'dispatch;
            }
            0x8290A1D4 => {
    //   block [0x8290A1D4..0x8290A1DC)
	// 8290A1D4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8290A1D8: 4839F280  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290A1E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290A1E0 size=556
    let mut pc: u32 = 0x8290A1E0;
    'dispatch: loop {
        match pc {
            0x8290A1E0 => {
    //   block [0x8290A1E0..0x8290A298)
	// 8290A1E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290A1E4: 4839F229  bl 0x82ca940c
	ctx.lr = 0x8290A1E8;
	sub_82CA93D0(ctx, base);
	// 8290A1E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290A1EC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8290A1F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8290A1F4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8290A1F8: 419A0154  beq cr6, 0x8290a34c
	if ctx.cr[6].eq {
	pc = 0x8290A34C; continue 'dispatch;
	}
	// 8290A1FC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8290A200: 38BE0070  addi r5, r30, 0x70
	ctx.r[5].s64 = ctx.r[30].s64 + 112;
	// 8290A204: 388B5490  addi r4, r11, 0x5490
	ctx.r[4].s64 = ctx.r[11].s64 + 21648;
	// 8290A208: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290A20C: 4BAA3135  bl 0x823ad340
	ctx.lr = 0x8290A210;
	sub_823AD340(ctx, base);
	// 8290A210: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 8290A214: 38BE0072  addi r5, r30, 0x72
	ctx.r[5].s64 = ctx.r[30].s64 + 114;
	// 8290A218: 388A54A4  addi r4, r10, 0x54a4
	ctx.r[4].s64 = ctx.r[10].s64 + 21668;
	// 8290A21C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290A220: 4BAA3121  bl 0x823ad340
	ctx.lr = 0x8290A224;
	sub_823AD340(ctx, base);
	// 8290A224: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 8290A228: 38BE0074  addi r5, r30, 0x74
	ctx.r[5].s64 = ctx.r[30].s64 + 116;
	// 8290A22C: 38895C94  addi r4, r9, 0x5c94
	ctx.r[4].s64 = ctx.r[9].s64 + 23700;
	// 8290A230: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290A234: 4BAA310D  bl 0x823ad340
	ctx.lr = 0x8290A238;
	sub_823AD340(ctx, base);
	// 8290A238: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 8290A23C: 38BE0073  addi r5, r30, 0x73
	ctx.r[5].s64 = ctx.r[30].s64 + 115;
	// 8290A240: 38885C88  addi r4, r8, 0x5c88
	ctx.r[4].s64 = ctx.r[8].s64 + 23688;
	// 8290A244: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290A248: 4BAA30F9  bl 0x823ad340
	ctx.lr = 0x8290A24C;
	sub_823AD340(ctx, base);
	// 8290A24C: 3CE0820E  lis r7, -0x7df2
	ctx.r[7].s64 = -2113011712;
	// 8290A250: 38BE0048  addi r5, r30, 0x48
	ctx.r[5].s64 = ctx.r[30].s64 + 72;
	// 8290A254: 38874694  addi r4, r7, 0x4694
	ctx.r[4].s64 = ctx.r[7].s64 + 18068;
	// 8290A258: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290A25C: 4BC8917D  bl 0x825933d8
	ctx.lr = 0x8290A260;
	sub_825933D8(ctx, base);
	// 8290A260: 3CC0811C  lis r6, -0x7ee4
	ctx.r[6].s64 = -2128871424;
	// 8290A264: 3CA0820E  lis r5, -0x7df2
	ctx.r[5].s64 = -2113011712;
	// 8290A268: 60DD9DC5  ori r29, r6, 0x9dc5
	ctx.r[29].u64 = ctx.r[6].u64 | 40389;
	// 8290A26C: 386554B8  addi r3, r5, 0x54b8
	ctx.r[3].s64 = ctx.r[5].s64 + 21688;
	// 8290A270: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8290A274: 4B8E9AE5  bl 0x821f3d58
	ctx.lr = 0x8290A278;
	sub_821F3D58(ctx, base);
	// 8290A278: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8290A27C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290A280: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 8290A284: 480F6445  bl 0x82a006c8
	ctx.lr = 0x8290A288;
	sub_82A006C8(ctx, base);
	// 8290A288: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8290A28C: 419A000C  beq cr6, 0x8290a298
	if ctx.cr[6].eq {
	pc = 0x8290A298; continue 'dispatch;
	}
	// 8290A290: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290A294: 48000008  b 0x8290a29c
	pc = 0x8290A29C; continue 'dispatch;
            }
            0x8290A298 => {
    //   block [0x8290A298..0x8290A29C)
	// 8290A298: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8290A29C; continue 'dispatch;
            }
            0x8290A29C => {
    //   block [0x8290A29C..0x8290A2D0)
	// 8290A29C: 917E002C  stw r11, 0x2c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 8290A2A0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8290A2A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8290A2A8: 386B54D0  addi r3, r11, 0x54d0
	ctx.r[3].s64 = ctx.r[11].s64 + 21712;
	// 8290A2AC: 4B8E9AAD  bl 0x821f3d58
	ctx.lr = 0x8290A2B0;
	sub_821F3D58(ctx, base);
	// 8290A2B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8290A2B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290A2B8: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 8290A2BC: 480F640D  bl 0x82a006c8
	ctx.lr = 0x8290A2C0;
	sub_82A006C8(ctx, base);
	// 8290A2C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8290A2C4: 419A000C  beq cr6, 0x8290a2d0
	if ctx.cr[6].eq {
	pc = 0x8290A2D0; continue 'dispatch;
	}
	// 8290A2C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290A2CC: 48000008  b 0x8290a2d4
	pc = 0x8290A2D4; continue 'dispatch;
            }
            0x8290A2D0 => {
    //   block [0x8290A2D0..0x8290A2D4)
	// 8290A2D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8290A2D4; continue 'dispatch;
            }
            0x8290A2D4 => {
    //   block [0x8290A2D4..0x8290A308)
	// 8290A2D4: 917E0030  stw r11, 0x30(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 8290A2D8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8290A2DC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8290A2E0: 386B54F0  addi r3, r11, 0x54f0
	ctx.r[3].s64 = ctx.r[11].s64 + 21744;
	// 8290A2E4: 4B8E9A75  bl 0x821f3d58
	ctx.lr = 0x8290A2E8;
	sub_821F3D58(ctx, base);
	// 8290A2E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8290A2EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290A2F0: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 8290A2F4: 480F63D5  bl 0x82a006c8
	ctx.lr = 0x8290A2F8;
	sub_82A006C8(ctx, base);
	// 8290A2F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8290A2FC: 419A000C  beq cr6, 0x8290a308
	if ctx.cr[6].eq {
	pc = 0x8290A308; continue 'dispatch;
	}
	// 8290A300: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290A304: 48000008  b 0x8290a30c
	pc = 0x8290A30C; continue 'dispatch;
            }
            0x8290A308 => {
    //   block [0x8290A308..0x8290A30C)
	// 8290A308: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8290A30C; continue 'dispatch;
            }
            0x8290A30C => {
    //   block [0x8290A30C..0x8290A34C)
	// 8290A30C: 917E0034  stw r11, 0x34(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 8290A310: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8290A314: 38BE0077  addi r5, r30, 0x77
	ctx.r[5].s64 = ctx.r[30].s64 + 119;
	// 8290A318: 388B5508  addi r4, r11, 0x5508
	ctx.r[4].s64 = ctx.r[11].s64 + 21768;
	// 8290A31C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290A320: 4BAA3021  bl 0x823ad340
	ctx.lr = 0x8290A324;
	sub_823AD340(ctx, base);
	// 8290A324: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 8290A328: 38BE0078  addi r5, r30, 0x78
	ctx.r[5].s64 = ctx.r[30].s64 + 120;
	// 8290A32C: 388A551C  addi r4, r10, 0x551c
	ctx.r[4].s64 = ctx.r[10].s64 + 21788;
	// 8290A330: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290A334: 4BAA300D  bl 0x823ad340
	ctx.lr = 0x8290A338;
	sub_823AD340(ctx, base);
	// 8290A338: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 8290A33C: 38BE0040  addi r5, r30, 0x40
	ctx.r[5].s64 = ctx.r[30].s64 + 64;
	// 8290A340: 38895CA0  addi r4, r9, 0x5ca0
	ctx.r[4].s64 = ctx.r[9].s64 + 23712;
	// 8290A344: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290A348: 4BAA30A9  bl 0x823ad3f0
	ctx.lr = 0x8290A34C;
	sub_823AD3F0(ctx, base);
	pc = 0x8290A34C; continue 'dispatch;
            }
            0x8290A34C => {
    //   block [0x8290A34C..0x8290A378)
	// 8290A34C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8290A350: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8290A354: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8290A358: 816A008C  lwz r11, 0x8c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 8290A35C: 892B0034  lbz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 8290A360: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8290A364: 419A0014  beq cr6, 0x8290a378
	if ctx.cr[6].eq {
	pc = 0x8290A378; continue 'dispatch;
	}
	// 8290A368: 896B0036  lbz r11, 0x36(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(54 as u32) ) } as u64;
	// 8290A36C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290A370: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290A374: 409A0008  bne cr6, 0x8290a37c
	if !ctx.cr[6].eq {
	pc = 0x8290A37C; continue 'dispatch;
	}
	pc = 0x8290A378; continue 'dispatch;
            }
            0x8290A378 => {
    //   block [0x8290A378..0x8290A37C)
	// 8290A378: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8290A37C; continue 'dispatch;
            }
            0x8290A37C => {
    //   block [0x8290A37C..0x8290A404)
	// 8290A37C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290A380: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290A384: 409A0080  bne cr6, 0x8290a404
	if !ctx.cr[6].eq {
	pc = 0x8290A404; continue 'dispatch;
	}
	// 8290A388: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290A38C: 806B007C  lwz r3, 0x7c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 8290A390: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290A394: 812A005C  lwz r9, 0x5c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(92 as u32) ) } as u64;
	// 8290A398: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8290A39C: 4E800421  bctrl
	ctx.lr = 0x8290A3A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290A3A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290A3A4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8290A3A8: 419A005C  beq cr6, 0x8290a404
	if ctx.cr[6].eq {
	pc = 0x8290A404; continue 'dispatch;
	}
	// 8290A3AC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290A3B0: 389E000C  addi r4, r30, 0xc
	ctx.r[4].s64 = ctx.r[30].s64 + 12;
	// 8290A3B4: 814B0064  lwz r10, 0x64(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 8290A3B8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8290A3BC: 4E800421  bctrl
	ctx.lr = 0x8290A3C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290A3C0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8290A3C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8290A3C8: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 8290A3CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290A3D0: 4BA7B839  bl 0x82385c08
	ctx.lr = 0x8290A3D4;
	sub_82385C08(ctx, base);
	// 8290A3D4: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8290A3D8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8290A3DC: 419A0028  beq cr6, 0x8290a404
	if ctx.cr[6].eq {
	pc = 0x8290A404; continue 'dispatch;
	}
	// 8290A3E0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8290A3E4: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 8290A3E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290A3EC: 419A0018  beq cr6, 0x8290a404
	if ctx.cr[6].eq {
	pc = 0x8290A404; continue 'dispatch;
	}
	// 8290A3F0: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 8290A3F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290A3F8: 419A000C  beq cr6, 0x8290a404
	if ctx.cr[6].eq {
	pc = 0x8290A404; continue 'dispatch;
	}
	// 8290A3FC: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 8290A400: B14B002A  sth r10, 0x2a(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(42 as u32), ctx.r[10].u16 ) };
            }
            0x8290A404 => {
    //   block [0x8290A404..0x8290A40C)
	// 8290A404: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8290A408: 4839F054  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290A410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290A410 size=476
    let mut pc: u32 = 0x8290A410;
    'dispatch: loop {
        match pc {
            0x8290A410 => {
    //   block [0x8290A410..0x8290A450)
	// 8290A410: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290A414: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8290A418: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8290A41C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290A420: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8290A424: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8290A428: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8290A42C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8290A430: 816A008C  lwz r11, 0x8c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 8290A434: 892B0034  lbz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 8290A438: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8290A43C: 419A0014  beq cr6, 0x8290a450
	if ctx.cr[6].eq {
	pc = 0x8290A450; continue 'dispatch;
	}
	// 8290A440: 896B0036  lbz r11, 0x36(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(54 as u32) ) } as u64;
	// 8290A444: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290A448: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290A44C: 409A0008  bne cr6, 0x8290a454
	if !ctx.cr[6].eq {
	pc = 0x8290A454; continue 'dispatch;
	}
	pc = 0x8290A450; continue 'dispatch;
            }
            0x8290A450 => {
    //   block [0x8290A450..0x8290A454)
	// 8290A450: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x8290A454; continue 'dispatch;
            }
            0x8290A454 => {
    //   block [0x8290A454..0x8290A4A0)
	// 8290A454: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290A458: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290A45C: 419A017C  beq cr6, 0x8290a5d8
	if ctx.cr[6].eq {
	pc = 0x8290A5D8; continue 'dispatch;
	}
	// 8290A460: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290A464: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290A468: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 8290A46C: 5549F7FE  rlwinm r9, r10, 0x1e, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 8290A470: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8290A474: 419A00E8  beq cr6, 0x8290a55c
	if ctx.cr[6].eq {
	pc = 0x8290A55C; continue 'dispatch;
	}
	// 8290A478: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8290A47C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290A480: 419A0020  beq cr6, 0x8290a4a0
	if ctx.cr[6].eq {
	pc = 0x8290A4A0; continue 'dispatch;
	}
	// 8290A484: 894A0002  lbz r10, 2(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 8290A488: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8290A48C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8290A490: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8290A494: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290A498: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290A49C: 480000C4  b 0x8290a560
	pc = 0x8290A560; continue 'dispatch;
            }
            0x8290A4A0 => {
    //   block [0x8290A4A0..0x8290A4BC)
	// 8290A4A0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8290A4A4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8290A4A8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8290A4AC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8290A4B0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8290A4B4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290A4B8: 40810054  ble 0x8290a50c
	if !ctx.cr[0].gt {
	pc = 0x8290A50C; continue 'dispatch;
	}
	pc = 0x8290A4BC; continue 'dispatch;
            }
            0x8290A4BC => {
    //   block [0x8290A4BC..0x8290A4DC)
	// 8290A4BC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8290A4C0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8290A4C4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8290A4C8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290A4CC: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 8290A4D0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8290A4D4: 41980008  blt cr6, 0x8290a4dc
	if ctx.cr[6].lt {
	pc = 0x8290A4DC; continue 'dispatch;
	}
	// 8290A4D8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x8290A4DC; continue 'dispatch;
            }
            0x8290A4DC => {
    //   block [0x8290A4DC..0x8290A4F8)
	// 8290A4DC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8290A4E0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8290A4E4: 419A0014  beq cr6, 0x8290a4f8
	if ctx.cr[6].eq {
	pc = 0x8290A4F8; continue 'dispatch;
	}
	// 8290A4E8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8290A4EC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8290A4F0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8290A4F4: 4800000C  b 0x8290a500
	pc = 0x8290A500; continue 'dispatch;
            }
            0x8290A4F8 => {
    //   block [0x8290A4F8..0x8290A500)
	// 8290A4F8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8290A4FC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8290A500; continue 'dispatch;
            }
            0x8290A500 => {
    //   block [0x8290A500..0x8290A50C)
	// 8290A500: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290A504: 4199FFB8  bgt cr6, 0x8290a4bc
	if ctx.cr[6].gt {
	pc = 0x8290A4BC; continue 'dispatch;
	}
	// 8290A508: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8290A50C; continue 'dispatch;
            }
            0x8290A50C => {
    //   block [0x8290A50C..0x8290A528)
	// 8290A50C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8290A510: 419A003C  beq cr6, 0x8290a54c
	if ctx.cr[6].eq {
	pc = 0x8290A54C; continue 'dispatch;
	}
	// 8290A514: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290A518: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 8290A51C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290A520: 41990008  bgt cr6, 0x8290a528
	if ctx.cr[6].gt {
	pc = 0x8290A528; continue 'dispatch;
	}
	// 8290A524: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x8290A528; continue 'dispatch;
            }
            0x8290A528 => {
    //   block [0x8290A528..0x8290A54C)
	// 8290A528: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290A52C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290A530: 409A001C  bne cr6, 0x8290a54c
	if !ctx.cr[6].eq {
	pc = 0x8290A54C; continue 'dispatch;
	}
	// 8290A534: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8290A538: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8290A53C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8290A540: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290A544: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290A548: 48000018  b 0x8290a560
	pc = 0x8290A560; continue 'dispatch;
            }
            0x8290A54C => {
    //   block [0x8290A54C..0x8290A55C)
	// 8290A54C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8290A550: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290A554: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290A558: 48000008  b 0x8290a560
	pc = 0x8290A560; continue 'dispatch;
            }
            0x8290A55C => {
    //   block [0x8290A55C..0x8290A560)
	// 8290A55C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x8290A560; continue 'dispatch;
            }
            0x8290A560 => {
    //   block [0x8290A560..0x8290A5D8)
	// 8290A560: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290A564: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290A568: 419A0070  beq cr6, 0x8290a5d8
	if ctx.cr[6].eq {
	pc = 0x8290A5D8; continue 'dispatch;
	}
	// 8290A56C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290A570: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 8290A574: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8290A578: 4E800421  bctrl
	ctx.lr = 0x8290A57C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290A57C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8290A580: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8290A584: 419A0054  beq cr6, 0x8290a5d8
	if ctx.cr[6].eq {
	pc = 0x8290A5D8; continue 'dispatch;
	}
	// 8290A588: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8290A58C: 4BA7B67D  bl 0x82385c08
	ctx.lr = 0x8290A590;
	sub_82385C08(ctx, base);
	// 8290A590: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8290A594: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290A598: 419A0040  beq cr6, 0x8290a5d8
	if ctx.cr[6].eq {
	pc = 0x8290A5D8; continue 'dispatch;
	}
	// 8290A59C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8290A5A0: 807F0038  lwz r3, 0x38(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 8290A5A4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 8290A5A8: 419A0030  beq cr6, 0x8290a5d8
	if ctx.cr[6].eq {
	pc = 0x8290A5D8; continue 'dispatch;
	}
	// 8290A5AC: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 8290A5B0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290A5B4: 90830008  stw r4, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 8290A5B8: 5164801E  rlwimi r4, r11, 0x10, 0, 0xf
	ctx.r[4].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[4].u64 & 0xFFFFFFFF0000FFFF);
	// 8290A5BC: 4BF48CFD  bl 0x828532b8
	ctx.lr = 0x8290A5C0;
	sub_828532B8(ctx, base);
	// 8290A5C0: 807F0038  lwz r3, 0x38(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 8290A5C4: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 8290A5C8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290A5CC: 812A0024  lwz r9, 0x24(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 8290A5D0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8290A5D4: 4E800421  bctrl
	ctx.lr = 0x8290A5D8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8290A5D8 => {
    //   block [0x8290A5D8..0x8290A5EC)
	// 8290A5D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8290A5DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8290A5E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290A5E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8290A5E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290A5F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290A5F0 size=356
    let mut pc: u32 = 0x8290A5F0;
    'dispatch: loop {
        match pc {
            0x8290A5F0 => {
    //   block [0x8290A5F0..0x8290A62C)
	// 8290A5F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290A5F4: 4839EE19  bl 0x82ca940c
	ctx.lr = 0x8290A5F8;
	sub_82CA93D0(ctx, base);
	// 8290A5F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290A5FC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8290A600: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290A604: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8290A608: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8290A60C: 816A008C  lwz r11, 0x8c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 8290A610: 892B0034  lbz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 8290A614: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8290A618: 419A0014  beq cr6, 0x8290a62c
	if ctx.cr[6].eq {
	pc = 0x8290A62C; continue 'dispatch;
	}
	// 8290A61C: 896B0036  lbz r11, 0x36(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(54 as u32) ) } as u64;
	// 8290A620: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290A624: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290A628: 409A0008  bne cr6, 0x8290a630
	if !ctx.cr[6].eq {
	pc = 0x8290A630; continue 'dispatch;
	}
	pc = 0x8290A62C; continue 'dispatch;
            }
            0x8290A62C => {
    //   block [0x8290A62C..0x8290A630)
	// 8290A62C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8290A630; continue 'dispatch;
            }
            0x8290A630 => {
    //   block [0x8290A630..0x8290A670)
	// 8290A630: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290A634: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290A638: 409A0108  bne cr6, 0x8290a740
	if !ctx.cr[6].eq {
	pc = 0x8290A740; continue 'dispatch;
	}
	// 8290A63C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290A640: 806B007C  lwz r3, 0x7c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 8290A644: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290A648: 812A005C  lwz r9, 0x5c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(92 as u32) ) } as u64;
	// 8290A64C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8290A650: 4E800421  bctrl
	ctx.lr = 0x8290A654;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290A654: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8290A658: 419A0018  beq cr6, 0x8290a670
	if ctx.cr[6].eq {
	pc = 0x8290A670; continue 'dispatch;
	}
	// 8290A65C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290A660: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 8290A664: 814B0068  lwz r10, 0x68(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 8290A668: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8290A66C: 4E800421  bctrl
	ctx.lr = 0x8290A670;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8290A670 => {
    //   block [0x8290A670..0x8290A6B4)
	// 8290A670: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8290A674: 3BBF0018  addi r29, r31, 0x18
	ctx.r[29].s64 = ctx.r[31].s64 + 24;
	// 8290A678: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290A67C: 419A0038  beq cr6, 0x8290a6b4
	if ctx.cr[6].eq {
	pc = 0x8290A6B4; continue 'dispatch;
	}
	// 8290A680: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290A684: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290A688: 419A00C0  beq cr6, 0x8290a748
	if ctx.cr[6].eq {
	pc = 0x8290A748; continue 'dispatch;
	}
	// 8290A68C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8290A690: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290A694: 419A0020  beq cr6, 0x8290a6b4
	if ctx.cr[6].eq {
	pc = 0x8290A6B4; continue 'dispatch;
	}
	// 8290A698: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8290A69C: 4B86979D  bl 0x82173e38
	ctx.lr = 0x8290A6A0;
	sub_82173E38(ctx, base);
	// 8290A6A0: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 8290A6A4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8290A6A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290A6AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290A6B0: 409A0008  bne cr6, 0x8290a6b8
	if !ctx.cr[6].eq {
	pc = 0x8290A6B8; continue 'dispatch;
	}
	pc = 0x8290A6B4; continue 'dispatch;
            }
            0x8290A6B4 => {
    //   block [0x8290A6B4..0x8290A6B8)
	// 8290A6B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8290A6B8; continue 'dispatch;
            }
            0x8290A6B8 => {
    //   block [0x8290A6B8..0x8290A6FC)
	// 8290A6B8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290A6BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290A6C0: 419A0080  beq cr6, 0x8290a740
	if ctx.cr[6].eq {
	pc = 0x8290A740; continue 'dispatch;
	}
	// 8290A6C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8290A6C8: 4B869771  bl 0x82173e38
	ctx.lr = 0x8290A6CC;
	sub_82173E38(ctx, base);
	// 8290A6CC: 8063007C  lwz r3, 0x7c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(124 as u32) ) } as u64;
	// 8290A6D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290A6D4: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 8290A6D8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8290A6DC: 4E800421  bctrl
	ctx.lr = 0x8290A6E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290A6E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8290A6E4: 419A0018  beq cr6, 0x8290a6fc
	if ctx.cr[6].eq {
	pc = 0x8290A6FC; continue 'dispatch;
	}
	// 8290A6E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290A6EC: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290A6F0: 814B0050  lwz r10, 0x50(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 8290A6F4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8290A6F8: 4E800421  bctrl
	ctx.lr = 0x8290A6FC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8290A6FC => {
    //   block [0x8290A6FC..0x8290A740)
	// 8290A6FC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290A700: 806B007C  lwz r3, 0x7c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 8290A704: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290A708: 812A005C  lwz r9, 0x5c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(92 as u32) ) } as u64;
	// 8290A70C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8290A710: 4E800421  bctrl
	ctx.lr = 0x8290A714;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290A714: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290A718: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8290A71C: 419A0024  beq cr6, 0x8290a740
	if ctx.cr[6].eq {
	pc = 0x8290A740; continue 'dispatch;
	}
	// 8290A720: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8290A724: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290A728: 4B869711  bl 0x82173e38
	ctx.lr = 0x8290A72C;
	sub_82173E38(ctx, base);
	// 8290A72C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8290A730: 817E0050  lwz r11, 0x50(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 8290A734: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290A738: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8290A73C: 4E800421  bctrl
	ctx.lr = 0x8290A740;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8290A740 => {
    //   block [0x8290A740..0x8290A748)
	// 8290A740: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8290A744: 4839ED18  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x8290A748 => {
    //   block [0x8290A748..0x8290A754)
	// 8290A748: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8290A74C: 4B8896ED  bl 0x82193e38
	ctx.lr = 0x8290A750;
	sub_82193E38(ctx, base);
	// 8290A750: 4BFFFF64  b 0x8290a6b4
	pc = 0x8290A6B4; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290A758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8290A758 size=4840
    let mut pc: u32 = 0x8290A758;
    'dispatch: loop {
        match pc {
            0x8290A758 => {
    //   block [0x8290A758..0x8290BA40)
	// 8290A758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290A75C: 4839EC89  bl 0x82ca93e4
	ctx.lr = 0x8290A760;
	sub_82CA93D0(ctx, base);
	// 8290A760: DBE1FF88  stfd f31, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 8290A764: 3980FF60  li r12, -0xa0
	ctx.r[12].s64 = -160;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290BA40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290BA40 size=304
    let mut pc: u32 = 0x8290BA40;
    'dispatch: loop {
        match pc {
            0x8290BA40 => {
    //   block [0x8290BA40..0x8290BAD0)
	// 8290BA40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290BA44: 4839D9C9  bl 0x82ca940c
	ctx.lr = 0x8290BA48;
	sub_82CA93D0(ctx, base);
	// 8290BA48: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290BA4C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8290BA50: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8290BA54: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 8290BA58: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8290BA5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290BA60: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 8290BA64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290BA68: 4B908E31  bl 0x82214898
	ctx.lr = 0x8290BA6C;
	sub_82214898(ctx, base);
	// 8290BA6C: 3BDF0018  addi r30, r31, 0x18
	ctx.r[30].s64 = ctx.r[31].s64 + 24;
	// 8290BA70: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8290BA74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8290BA78: 4BBC6451  bl 0x824d1ec8
	ctx.lr = 0x8290BA7C;
	sub_824D1EC8(ctx, base);
	// 8290BA7C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 8290BA80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290BA84: 38E80B7C  addi r7, r8, 0xb7c
	ctx.r[7].s64 = ctx.r[8].s64 + 2940;
	// 8290BA88: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 8290BA8C: 4B8883AD  bl 0x82193e38
	ctx.lr = 0x8290BA90;
	sub_82193E38(ctx, base);
	// 8290BA90: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8290BA94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290BA98: 419A0038  beq cr6, 0x8290bad0
	if ctx.cr[6].eq {
	pc = 0x8290BAD0; continue 'dispatch;
	}
	// 8290BA9C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290BAA0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290BAA4: 419A00C0  beq cr6, 0x8290bb64
	if ctx.cr[6].eq {
	pc = 0x8290BB64; continue 'dispatch;
	}
	// 8290BAA8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8290BAAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290BAB0: 419A0020  beq cr6, 0x8290bad0
	if ctx.cr[6].eq {
	pc = 0x8290BAD0; continue 'dispatch;
	}
	// 8290BAB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8290BAB8: 4B868381  bl 0x82173e38
	ctx.lr = 0x8290BABC;
	sub_82173E38(ctx, base);
	// 8290BABC: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 8290BAC0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8290BAC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290BAC8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290BACC: 409A0008  bne cr6, 0x8290bad4
	if !ctx.cr[6].eq {
	pc = 0x8290BAD4; continue 'dispatch;
	}
	pc = 0x8290BAD0; continue 'dispatch;
            }
            0x8290BAD0 => {
    //   block [0x8290BAD0..0x8290BAD4)
	// 8290BAD0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8290BAD4; continue 'dispatch;
            }
            0x8290BAD4 => {
    //   block [0x8290BAD4..0x8290BB18)
	// 8290BAD4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290BAD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290BADC: 419A0080  beq cr6, 0x8290bb5c
	if ctx.cr[6].eq {
	pc = 0x8290BB5C; continue 'dispatch;
	}
	// 8290BAE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8290BAE4: 4B868355  bl 0x82173e38
	ctx.lr = 0x8290BAE8;
	sub_82173E38(ctx, base);
	// 8290BAE8: 8063007C  lwz r3, 0x7c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(124 as u32) ) } as u64;
	// 8290BAEC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290BAF0: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 8290BAF4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8290BAF8: 4E800421  bctrl
	ctx.lr = 0x8290BAFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290BAFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8290BB00: 419A0018  beq cr6, 0x8290bb18
	if ctx.cr[6].eq {
	pc = 0x8290BB18; continue 'dispatch;
	}
	// 8290BB04: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290BB08: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290BB0C: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8290BB10: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8290BB14: 4E800421  bctrl
	ctx.lr = 0x8290BB18;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8290BB18 => {
    //   block [0x8290BB18..0x8290BB5C)
	// 8290BB18: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290BB1C: 806B007C  lwz r3, 0x7c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 8290BB20: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290BB24: 812A005C  lwz r9, 0x5c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(92 as u32) ) } as u64;
	// 8290BB28: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8290BB2C: 4E800421  bctrl
	ctx.lr = 0x8290BB30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290BB30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290BB34: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8290BB38: 419A0024  beq cr6, 0x8290bb5c
	if ctx.cr[6].eq {
	pc = 0x8290BB5C; continue 'dispatch;
	}
	// 8290BB3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8290BB40: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290BB44: 4B8682F5  bl 0x82173e38
	ctx.lr = 0x8290BB48;
	sub_82173E38(ctx, base);
	// 8290BB48: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8290BB4C: 817D004C  lwz r11, 0x4c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 8290BB50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290BB54: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8290BB58: 4E800421  bctrl
	ctx.lr = 0x8290BB5C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8290BB5C => {
    //   block [0x8290BB5C..0x8290BB64)
	// 8290BB5C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8290BB60: 4839D8FC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x8290BB64 => {
    //   block [0x8290BB64..0x8290BB70)
	// 8290BB64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8290BB68: 4B8882D1  bl 0x82193e38
	ctx.lr = 0x8290BB6C;
	sub_82193E38(ctx, base);
	// 8290BB6C: 4BFFFF64  b 0x8290bad0
	pc = 0x8290BAD0; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290BB70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290BB70 size=312
    let mut pc: u32 = 0x8290BB70;
    'dispatch: loop {
        match pc {
            0x8290BB70 => {
    //   block [0x8290BB70..0x8290BBE0)
	// 8290BB70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290BB74: 4839D899  bl 0x82ca940c
	ctx.lr = 0x8290BB78;
	sub_82CA93D0(ctx, base);
	// 8290BB78: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290BB7C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8290BB80: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8290BB84: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 8290BB88: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 8290BB8C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8290BB90: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8290BB94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290BB98: 4B908D01  bl 0x82214898
	ctx.lr = 0x8290BB9C;
	sub_82214898(ctx, base);
	// 8290BB9C: 3BFD0020  addi r31, r29, 0x20
	ctx.r[31].s64 = ctx.r[29].s64 + 32;
	// 8290BBA0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8290BBA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290BBA8: 4BBC6321  bl 0x824d1ec8
	ctx.lr = 0x8290BBAC;
	sub_824D1EC8(ctx, base);
	// 8290BBAC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8290BBB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290BBB4: 39090B7C  addi r8, r9, 0xb7c
	ctx.r[8].s64 = ctx.r[9].s64 + 2940;
	// 8290BBB8: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 8290BBBC: 4B88827D  bl 0x82193e38
	ctx.lr = 0x8290BBC0;
	sub_82193E38(ctx, base);
	// 8290BBC0: 817D0024  lwz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 8290BBC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290BBC8: 419A0020  beq cr6, 0x8290bbe8
	if ctx.cr[6].eq {
	pc = 0x8290BBE8; continue 'dispatch;
	}
	// 8290BBCC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290BBD0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290BBD4: 419A000C  beq cr6, 0x8290bbe0
	if ctx.cr[6].eq {
	pc = 0x8290BBE0; continue 'dispatch;
	}
	// 8290BBD8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8290BBDC: 48000010  b 0x8290bbec
	pc = 0x8290BBEC; continue 'dispatch;
            }
            0x8290BBE0 => {
    //   block [0x8290BBE0..0x8290BBE8)
	// 8290BBE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290BBE4: 4B888255  bl 0x82193e38
	ctx.lr = 0x8290BBE8;
	sub_82193E38(ctx, base);
	pc = 0x8290BBE8; continue 'dispatch;
            }
            0x8290BBE8 => {
    //   block [0x8290BBE8..0x8290BBEC)
	// 8290BBE8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x8290BBEC; continue 'dispatch;
            }
            0x8290BBEC => {
    //   block [0x8290BBEC..0x8290BC54)
	// 8290BBEC: 806B007C  lwz r3, 0x7c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 8290BBF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8290BBF4: 419A0060  beq cr6, 0x8290bc54
	if ctx.cr[6].eq {
	pc = 0x8290BC54; continue 'dispatch;
	}
	// 8290BBF8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290BBFC: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 8290BC00: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8290BC04: 4E800421  bctrl
	ctx.lr = 0x8290BC08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290BC08: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8290BC0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8290BC10: 419A0044  beq cr6, 0x8290bc54
	if ctx.cr[6].eq {
	pc = 0x8290BC54; continue 'dispatch;
	}
	// 8290BC14: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8290BC18: 4BE10DD9  bl 0x8271c9f0
	ctx.lr = 0x8290BC1C;
	sub_8271C9F0(ctx, base);
	// 8290BC1C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8290BC20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290BC24: 419A0030  beq cr6, 0x8290bc54
	if ctx.cr[6].eq {
	pc = 0x8290BC54; continue 'dispatch;
	}
	// 8290BC28: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8290BC2C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8290BC30: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8290BC34: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290BC38: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8290BC3C: 810A0014  lwz r8, 0x14(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 8290BC40: 80E90058  lwz r7, 0x58(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 8290BC44: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290BC48: 80860018  lwz r4, 0x18(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(24 as u32) ) } as u64;
	// 8290BC4C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 8290BC50: 4E800421  bctrl
	ctx.lr = 0x8290BC54;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8290BC54 => {
    //   block [0x8290BC54..0x8290BC74)
	// 8290BC54: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290BC58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290BC5C: 419A0020  beq cr6, 0x8290bc7c
	if ctx.cr[6].eq {
	pc = 0x8290BC7C; continue 'dispatch;
	}
	// 8290BC60: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290BC64: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290BC68: 419A000C  beq cr6, 0x8290bc74
	if ctx.cr[6].eq {
	pc = 0x8290BC74; continue 'dispatch;
	}
	// 8290BC6C: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 8290BC70: 48000010  b 0x8290bc80
	pc = 0x8290BC80; continue 'dispatch;
            }
            0x8290BC74 => {
    //   block [0x8290BC74..0x8290BC7C)
	// 8290BC74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290BC78: 4B8881C1  bl 0x82193e38
	ctx.lr = 0x8290BC7C;
	sub_82193E38(ctx, base);
	pc = 0x8290BC7C; continue 'dispatch;
            }
            0x8290BC7C => {
    //   block [0x8290BC7C..0x8290BC80)
	// 8290BC7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x8290BC80; continue 'dispatch;
            }
            0x8290BC80 => {
    //   block [0x8290BC80..0x8290BCA0)
	// 8290BC80: 4B8A5899  bl 0x821b1518
	ctx.lr = 0x8290BC84;
	sub_821B1518(ctx, base);
	// 8290BC84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8290BC88: 419A0018  beq cr6, 0x8290bca0
	if ctx.cr[6].eq {
	pc = 0x8290BCA0; continue 'dispatch;
	}
	// 8290BC8C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290BC90: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290BC94: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8290BC98: 917D0038  stw r11, 0x38(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 8290BC9C: 4BA8181D  bl 0x8238d4b8
	ctx.lr = 0x8290BCA0;
	sub_8238D4B8(ctx, base);
	pc = 0x8290BCA0; continue 'dispatch;
            }
            0x8290BCA0 => {
    //   block [0x8290BCA0..0x8290BCA8)
	// 8290BCA0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8290BCA4: 4839D7B8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290BCA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290BCA8 size=336
    let mut pc: u32 = 0x8290BCA8;
    'dispatch: loop {
        match pc {
            0x8290BCA8 => {
    //   block [0x8290BCA8..0x8290BDF8)
	// 8290BCA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290BCAC: 4839D761  bl 0x82ca940c
	ctx.lr = 0x8290BCB0;
	sub_82CA93D0(ctx, base);
	// 8290BCB0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290BCB4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8290BCB8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8290BCBC: 3BAB299C  addi r29, r11, 0x299c
	ctx.r[29].s64 = ctx.r[11].s64 + 10652;
	// 8290BCC0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8290BCC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290BCC8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8290BCCC: 4B921205  bl 0x8222ced0
	ctx.lr = 0x8290BCD0;
	sub_8222CED0(ctx, base);
	// 8290BCD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8290BCD4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8290BCD8: 48000DB9  bl 0x8290ca90
	ctx.lr = 0x8290BCDC;
	sub_8290CA90(ctx, base);
	// 8290BCDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290BCE0: 4B9090F9  bl 0x82214dd8
	ctx.lr = 0x8290BCE4;
	sub_82214DD8(ctx, base);
	// 8290BCE4: 3D408274  lis r10, -0x7d8c
	ctx.r[10].s64 = -2106327040;
	// 8290BCE8: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 8290BCEC: 390A0568  addi r8, r10, 0x568
	ctx.r[8].s64 = ctx.r[10].s64 + 1384;
	// 8290BCF0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8290BCF4: 38895578  addi r4, r9, 0x5578
	ctx.r[4].s64 = ctx.r[9].s64 + 21880;
	// 8290BCF8: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 8290BCFC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8290BD00: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8290BD04: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8290BD08: 4B9211C9  bl 0x8222ced0
	ctx.lr = 0x8290BD0C;
	sub_8222CED0(ctx, base);
	// 8290BD0C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8290BD10: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8290BD14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290BD18: 4B9211B9  bl 0x8222ced0
	ctx.lr = 0x8290BD1C;
	sub_8222CED0(ctx, base);
	// 8290BD1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8290BD20: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 8290BD24: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8290BD28: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8290BD2C: 48000FAD  bl 0x8290ccd8
	ctx.lr = 0x8290BD30;
	sub_8290CCD8(ctx, base);
	// 8290BD30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290BD34: 4B9090A5  bl 0x82214dd8
	ctx.lr = 0x8290BD38;
	sub_82214DD8(ctx, base);
	// 8290BD38: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8290BD3C: 4B90909D  bl 0x82214dd8
	ctx.lr = 0x8290BD40;
	sub_82214DD8(ctx, base);
	// 8290BD40: 3CE08291  lis r7, -0x7d6f
	ctx.r[7].s64 = -2104426496;
	// 8290BD44: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 8290BD48: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8290BD4C: 3867A140  addi r3, r7, -0x5ec0
	ctx.r[3].s64 = ctx.r[7].s64 + -24256;
	// 8290BD50: 3886558C  addi r4, r6, 0x558c
	ctx.r[4].s64 = ctx.r[6].s64 + 21900;
	// 8290BD54: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 8290BD58: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8290BD5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290BD60: 4B921171  bl 0x8222ced0
	ctx.lr = 0x8290BD64;
	sub_8222CED0(ctx, base);
	// 8290BD64: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8290BD68: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8290BD6C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8290BD70: 4B921161  bl 0x8222ced0
	ctx.lr = 0x8290BD74;
	sub_8222CED0(ctx, base);
	// 8290BD74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8290BD78: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8290BD7C: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8290BD80: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8290BD84: 48001165  bl 0x8290cee8
	ctx.lr = 0x8290BD88;
	sub_8290CEE8(ctx, base);
	// 8290BD88: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8290BD8C: 4B90904D  bl 0x82214dd8
	ctx.lr = 0x8290BD90;
	sub_82214DD8(ctx, base);
	// 8290BD90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290BD94: 4B909045  bl 0x82214dd8
	ctx.lr = 0x8290BD98;
	sub_82214DD8(ctx, base);
	// 8290BD98: 3D608291  lis r11, -0x7d6f
	ctx.r[11].s64 = -2104426496;
	// 8290BD9C: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 8290BDA0: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8290BDA4: 392BA138  addi r9, r11, -0x5ec8
	ctx.r[9].s64 = ctx.r[11].s64 + -24264;
	// 8290BDA8: 388A559C  addi r4, r10, 0x559c
	ctx.r[4].s64 = ctx.r[10].s64 + 21916;
	// 8290BDAC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8290BDB0: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 8290BDB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290BDB8: 4B921119  bl 0x8222ced0
	ctx.lr = 0x8290BDBC;
	sub_8222CED0(ctx, base);
	// 8290BDBC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8290BDC0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8290BDC4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8290BDC8: 4B921109  bl 0x8222ced0
	ctx.lr = 0x8290BDCC;
	sub_8222CED0(ctx, base);
	// 8290BDCC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8290BDD0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8290BDD4: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8290BDD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8290BDDC: 4800131D  bl 0x8290d0f8
	ctx.lr = 0x8290BDE0;
	sub_8290D0F8(ctx, base);
	// 8290BDE0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8290BDE4: 4B908FF5  bl 0x82214dd8
	ctx.lr = 0x8290BDE8;
	sub_82214DD8(ctx, base);
	// 8290BDE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290BDEC: 4B908FED  bl 0x82214dd8
	ctx.lr = 0x8290BDF0;
	sub_82214DD8(ctx, base);
	// 8290BDF0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8290BDF4: 4839D668  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290BDF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290BDF8 size=68
    let mut pc: u32 = 0x8290BDF8;
    'dispatch: loop {
        match pc {
            0x8290BDF8 => {
    //   block [0x8290BDF8..0x8290BE28)
	// 8290BDF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290BDFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8290BE00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8290BE04: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290BE08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290BE0C: 48000035  bl 0x8290be40
	ctx.lr = 0x8290BE10;
	sub_8290BE40(ctx, base);
	// 8290BE10: 897F0076  lbz r11, 0x76(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(118 as u32) ) } as u64;
	// 8290BE14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290BE18: 419A0010  beq cr6, 0x8290be28
	if ctx.cr[6].eq {
	pc = 0x8290BE28; continue 'dispatch;
	}
	// 8290BE1C: 3880007F  li r4, 0x7f
	ctx.r[4].s64 = 127;
	// 8290BE20: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290BE24: 4BA80D55  bl 0x8238cb78
	ctx.lr = 0x8290BE28;
	sub_8238CB78(ctx, base);
	pc = 0x8290BE28; continue 'dispatch;
            }
            0x8290BE28 => {
    //   block [0x8290BE28..0x8290BE3C)
	// 8290BE28: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8290BE2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8290BE30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290BE34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8290BE38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290BE40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8290BE40 size=1048
    let mut pc: u32 = 0x8290BE40;
    'dispatch: loop {
        match pc {
            0x8290BE40 => {
    //   block [0x8290BE40..0x8290C258)
	// 8290BE40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290BE44: 4839D5A9  bl 0x82ca93ec
	ctx.lr = 0x8290BE48;
	sub_82CA93D0(ctx, base);
	// 8290BE48: DBA1FF88  stfd f29, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[29].u64 ) };
	// 8290BE4C: DBC1FF90  stfd f30, -0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[30].u64 ) };
	// 8290BE50: DBE1FF98  stfd f31, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 8290BE54: 3980FF50  li r12, -0xb0
	ctx.r[12].s64 = -176;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290C258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290C258 size=1028
    let mut pc: u32 = 0x8290C258;
    'dispatch: loop {
        match pc {
            0x8290C258 => {
    //   block [0x8290C258..0x8290C30C)
	// 8290C258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290C25C: 4839D1AD  bl 0x82ca9408
	ctx.lr = 0x8290C260;
	sub_82CA93D0(ctx, base);
	// 8290C260: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 8290C264: 483A1A75  bl 0x82cadcd8
	ctx.lr = 0x8290C268;
	sub_82CADCA0(ctx, base);
	// 8290C268: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290C26C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8290C270: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8290C274: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290C278: 806B007C  lwz r3, 0x7c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 8290C27C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290C280: 812A005C  lwz r9, 0x5c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(92 as u32) ) } as u64;
	// 8290C284: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8290C288: 4E800421  bctrl
	ctx.lr = 0x8290C28C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290C28C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290C290: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8290C294: 419A0154  beq cr6, 0x8290c3e8
	if ctx.cr[6].eq {
	pc = 0x8290C3E8; continue 'dispatch;
	}
	// 8290C298: 387C0018  addi r3, r28, 0x18
	ctx.r[3].s64 = ctx.r[28].s64 + 24;
	// 8290C29C: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290C2A0: 4B867B99  bl 0x82173e38
	ctx.lr = 0x8290C2A4;
	sub_82173E38(ctx, base);
	// 8290C2A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8290C2A8: 817E0050  lwz r11, 0x50(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 8290C2AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290C2B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8290C2B4: 4E800421  bctrl
	ctx.lr = 0x8290C2B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290C2B8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290C2BC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8290C2C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290C2C4: 812A004C  lwz r9, 0x4c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(76 as u32) ) } as u64;
	// 8290C2C8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8290C2CC: 4E800421  bctrl
	ctx.lr = 0x8290C2D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290C2D0: 891D0024  lbz r8, 0x24(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 8290C2D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8290C2D8: 550707FE  clrlwi r7, r8, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x00000001u64;
	// 8290C2DC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8290C2E0: 419A00EC  beq cr6, 0x8290c3cc
	if ctx.cr[6].eq {
	pc = 0x8290C3CC; continue 'dispatch;
	}
	// 8290C2E4: 817D008C  lwz r11, 0x8c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 8290C2E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290C2EC: 419A0020  beq cr6, 0x8290c30c
	if ctx.cr[6].eq {
	pc = 0x8290C30C; continue 'dispatch;
	}
	// 8290C2F0: 894B0018  lbz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8290C2F4: 817D0048  lwz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 8290C2F8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8290C2FC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8290C300: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290C304: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290C308: 480000C8  b 0x8290c3d0
	pc = 0x8290C3D0; continue 'dispatch;
            }
            0x8290C30C => {
    //   block [0x8290C30C..0x8290C32C)
	// 8290C30C: 815D0048  lwz r10, 0x48(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 8290C310: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8290C314: 80DD004C  lwz r6, 0x4c(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 8290C318: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 8290C31C: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8290C320: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 8290C324: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290C328: 40810054  ble 0x8290c37c
	if !ctx.cr[0].gt {
	pc = 0x8290C37C; continue 'dispatch;
	}
	pc = 0x8290C32C; continue 'dispatch;
            }
            0x8290C32C => {
    //   block [0x8290C32C..0x8290C34C)
	// 8290C32C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8290C330: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8290C334: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8290C338: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290C33C: 2F070018  cmpwi cr6, r7, 0x18
	ctx.cr[6].compare_i32(ctx.r[7].s32, 24, &mut ctx.xer);
	// 8290C340: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8290C344: 41980008  blt cr6, 0x8290c34c
	if ctx.cr[6].lt {
	pc = 0x8290C34C; continue 'dispatch;
	}
	// 8290C348: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x8290C34C; continue 'dispatch;
            }
            0x8290C34C => {
    //   block [0x8290C34C..0x8290C368)
	// 8290C34C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8290C350: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8290C354: 419A0014  beq cr6, 0x8290c368
	if ctx.cr[6].eq {
	pc = 0x8290C368; continue 'dispatch;
	}
	// 8290C358: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8290C35C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8290C360: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8290C364: 4800000C  b 0x8290c370
	pc = 0x8290C370; continue 'dispatch;
            }
            0x8290C368 => {
    //   block [0x8290C368..0x8290C370)
	// 8290C368: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8290C36C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8290C370; continue 'dispatch;
            }
            0x8290C370 => {
    //   block [0x8290C370..0x8290C37C)
	// 8290C370: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290C374: 4199FFB8  bgt cr6, 0x8290c32c
	if ctx.cr[6].gt {
	pc = 0x8290C32C; continue 'dispatch;
	}
	// 8290C378: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	pc = 0x8290C37C; continue 'dispatch;
            }
            0x8290C37C => {
    //   block [0x8290C37C..0x8290C398)
	// 8290C37C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8290C380: 419A003C  beq cr6, 0x8290c3bc
	if ctx.cr[6].eq {
	pc = 0x8290C3BC; continue 'dispatch;
	}
	// 8290C384: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290C388: 2F0B0018  cmpwi cr6, r11, 0x18
	ctx.cr[6].compare_i32(ctx.r[11].s32, 24, &mut ctx.xer);
	// 8290C38C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290C390: 41990008  bgt cr6, 0x8290c398
	if ctx.cr[6].gt {
	pc = 0x8290C398; continue 'dispatch;
	}
	// 8290C394: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8290C398; continue 'dispatch;
            }
            0x8290C398 => {
    //   block [0x8290C398..0x8290C3BC)
	// 8290C398: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290C39C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290C3A0: 409A001C  bne cr6, 0x8290c3bc
	if !ctx.cr[6].eq {
	pc = 0x8290C3BC; continue 'dispatch;
	}
	// 8290C3A4: E9610070  ld r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 8290C3A8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290C3AC: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 8290C3B0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8290C3B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290C3B8: 48000018  b 0x8290c3d0
	pc = 0x8290C3D0; continue 'dispatch;
            }
            0x8290C3BC => {
    //   block [0x8290C3BC..0x8290C3CC)
	// 8290C3BC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8290C3C0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290C3C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290C3C8: 48000008  b 0x8290c3d0
	pc = 0x8290C3D0; continue 'dispatch;
            }
            0x8290C3CC => {
    //   block [0x8290C3CC..0x8290C3D0)
	// 8290C3CC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x8290C3D0; continue 'dispatch;
            }
            0x8290C3D0 => {
    //   block [0x8290C3D0..0x8290C3E8)
	// 8290C3D0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8290C3D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290C3D8: 419A0010  beq cr6, 0x8290c3e8
	if ctx.cr[6].eq {
	pc = 0x8290C3E8; continue 'dispatch;
	}
	// 8290C3DC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8290C3E0: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290C3E4: 4BBF1EBD  bl 0x824fe2a0
	ctx.lr = 0x8290C3E8;
	sub_824FE2A0(ctx, base);
	pc = 0x8290C3E8; continue 'dispatch;
            }
            0x8290C3E8 => {
    //   block [0x8290C3E8..0x8290C418)
	// 8290C3E8: 807D007C  lwz r3, 0x7c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(124 as u32) ) } as u64;
	// 8290C3EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290C3F0: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 8290C3F4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8290C3F8: 4E800421  bctrl
	ctx.lr = 0x8290C3FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290C3FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8290C400: 419A0018  beq cr6, 0x8290c418
	if ctx.cr[6].eq {
	pc = 0x8290C418; continue 'dispatch;
	}
	// 8290C404: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290C408: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290C40C: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8290C410: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8290C414: 4E800421  bctrl
	ctx.lr = 0x8290C418;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8290C418 => {
    //   block [0x8290C418..0x8290C454)
	// 8290C418: 809D007C  lwz r4, 0x7c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(124 as u32) ) } as u64;
	// 8290C41C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8290C420: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290C424: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 8290C428: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8290C42C: 4E800421  bctrl
	ctx.lr = 0x8290C430;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290C430: 817C001C  lwz r11, 0x1c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 8290C434: 387C0018  addi r3, r28, 0x18
	ctx.r[3].s64 = ctx.r[28].s64 + 24;
	// 8290C438: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290C43C: 419A001C  beq cr6, 0x8290c458
	if ctx.cr[6].eq {
	pc = 0x8290C458; continue 'dispatch;
	}
	// 8290C440: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290C444: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290C448: 419A000C  beq cr6, 0x8290c454
	if ctx.cr[6].eq {
	pc = 0x8290C454; continue 'dispatch;
	}
	// 8290C44C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8290C450: 4800000C  b 0x8290c45c
	pc = 0x8290C45C; continue 'dispatch;
            }
            0x8290C454 => {
    //   block [0x8290C454..0x8290C458)
	// 8290C454: 4B8879E5  bl 0x82193e38
	ctx.lr = 0x8290C458;
	sub_82193E38(ctx, base);
	pc = 0x8290C458; continue 'dispatch;
            }
            0x8290C458 => {
    //   block [0x8290C458..0x8290C45C)
	// 8290C458: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8290C45C; continue 'dispatch;
            }
            0x8290C45C => {
    //   block [0x8290C45C..0x8290C65C)
	// 8290C45C: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 8290C460: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8290C464: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290C468: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 8290C46C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8290C470: 4E800421  bctrl
	ctx.lr = 0x8290C474;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290C474: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 8290C478: 390100A0  addi r8, r1, 0xa0
	ctx.r[8].s64 = ctx.r[1].s64 + 160;
	// 8290C47C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8290C480: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 8290C484: 3BEB9490  addi r31, r11, -0x6b70
	ctx.r[31].s64 = ctx.r[11].s64 + -27504;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290C660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8290C660 size=1068
    let mut pc: u32 = 0x8290C660;
    'dispatch: loop {
        match pc {
            0x8290C660 => {
    //   block [0x8290C660..0x8290CA8C)
	// 8290C660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290C664: 4839CDA1  bl 0x82ca9404
	ctx.lr = 0x8290C668;
	sub_82CA93D0(ctx, base);
	// 8290C668: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290CA90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290CA90 size=584
    let mut pc: u32 = 0x8290CA90;
    'dispatch: loop {
        match pc {
            0x8290CA90 => {
    //   block [0x8290CA90..0x8290CAB8)
	// 8290CA90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290CA94: 4839C96D  bl 0x82ca9400
	ctx.lr = 0x8290CA98;
	sub_82CA93D0(ctx, base);
	// 8290CA98: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290CA9C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290CAA0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8290CAA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290CAA8: 409A0010  bne cr6, 0x8290cab8
	if !ctx.cr[6].eq {
	pc = 0x8290CAB8; continue 'dispatch;
	}
	// 8290CAAC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8290CAB0: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 8290CAB4: 48000008  b 0x8290cabc
	pc = 0x8290CABC; continue 'dispatch;
            }
            0x8290CAB8 => {
    //   block [0x8290CAB8..0x8290CABC)
	// 8290CAB8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8290CABC; continue 'dispatch;
            }
            0x8290CABC => {
    //   block [0x8290CABC..0x8290CB34)
	// 8290CABC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290CAC0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8290CAC4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290CAC8: 4BAC1AF9  bl 0x823ce5c0
	ctx.lr = 0x8290CACC;
	sub_823CE5C0(ctx, base);
	// 8290CACC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8290CAD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290CAD4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290CAD8: 4BAC1729  bl 0x823ce200
	ctx.lr = 0x8290CADC;
	sub_823CE200(ctx, base);
	// 8290CADC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8290CAE0: 4B8AB039  bl 0x821b7b18
	ctx.lr = 0x8290CAE4;
	sub_821B7B18(ctx, base);
	// 8290CAE4: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 8290CAE8: 4B912771  bl 0x8221f258
	ctx.lr = 0x8290CAEC;
	sub_8221F258(ctx, base);
	// 8290CAEC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8290CAF0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8290CAF4: 419A0040  beq cr6, 0x8290cb34
	if ctx.cr[6].eq {
	pc = 0x8290CB34; continue 'dispatch;
	}
	// 8290CAF8: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 8290CAFC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8290CB00: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 8290CB04: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8290CB08: 4B912751  bl 0x8221f258
	ctx.lr = 0x8290CB0C;
	sub_8221F258(ctx, base);
	// 8290CB0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8290CB10: 419A0028  beq cr6, 0x8290cb38
	if ctx.cr[6].eq {
	pc = 0x8290CB38; continue 'dispatch;
	}
	// 8290CB14: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 8290CB18: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 8290CB1C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290CB20: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 8290CB24: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8290CB28: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8290CB2C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8290CB30: 4800000C  b 0x8290cb3c
	pc = 0x8290CB3C; continue 'dispatch;
            }
            0x8290CB34 => {
    //   block [0x8290CB34..0x8290CB38)
	// 8290CB34: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x8290CB38; continue 'dispatch;
            }
            0x8290CB38 => {
    //   block [0x8290CB38..0x8290CB3C)
	// 8290CB38: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x8290CB3C; continue 'dispatch;
            }
            0x8290CB3C => {
    //   block [0x8290CB3C..0x8290CC40)
	// 8290CB3C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8290CB40: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8290CB44: 419A00FC  beq cr6, 0x8290cc40
	if ctx.cr[6].eq {
	pc = 0x8290CC40; continue 'dispatch;
	}
	// 8290CB48: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290CB4C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 8290CB50: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290CB54: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8290CB58: 4B91C5B1  bl 0x82229108
	ctx.lr = 0x8290CB5C;
	sub_82229108(ctx, base);
	// 8290CB5C: 3D608291  lis r11, -0x7d6f
	ctx.r[11].s64 = -2104426496;
	// 8290CB60: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8290CB64: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8290CB68: 3BCBD308  addi r30, r11, -0x2cf8
	ctx.r[30].s64 = ctx.r[11].s64 + -11512;
	// 8290CB6C: 4B91AD15  bl 0x82227880
	ctx.lr = 0x8290CB70;
	sub_82227880(ctx, base);
	// 8290CB70: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8290CB74: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 8290CB78: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8290CB7C: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 8290CB80: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8290CB84: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 8290CB88: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 8290CB8C: 4B88DEF5  bl 0x8219aa80
	ctx.lr = 0x8290CB90;
	sub_8219AA80(ctx, base);
	// 8290CB90: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 8290CB94: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8290CB98: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 8290CB9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290CBA0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8290CBA4: 4BAC187D  bl 0x823ce420
	ctx.lr = 0x8290CBA8;
	sub_823CE420(ctx, base);
	// 8290CBA8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8290CBAC: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 8290CBB0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8290CBB4: 48117B15  bl 0x82a246c8
	ctx.lr = 0x8290CBB8;
	sub_82A246C8(ctx, base);
	// 8290CBB8: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290CBBC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 8290CBC0: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 8290CBC4: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 8290CBC8: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290CBCC: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290CBD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8290CBD4: 4B91C535  bl 0x82229108
	ctx.lr = 0x8290CBD8;
	sub_82229108(ctx, base);
	// 8290CBD8: 3D608232  lis r11, -0x7dce
	ctx.r[11].s64 = -2110652416;
	// 8290CBDC: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8290CBE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8290CBE4: 3BEB6CC0  addi r31, r11, 0x6cc0
	ctx.r[31].s64 = ctx.r[11].s64 + 27840;
	// 8290CBE8: 4B91AC99  bl 0x82227880
	ctx.lr = 0x8290CBEC;
	sub_82227880(ctx, base);
	// 8290CBEC: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 8290CBF0: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 8290CBF4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8290CBF8: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 8290CBFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8290CC00: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 8290CC04: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 8290CC08: 4B88DE79  bl 0x8219aa80
	ctx.lr = 0x8290CC0C;
	sub_8219AA80(ctx, base);
	// 8290CC0C: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 8290CC10: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8290CC14: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 8290CC18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290CC1C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290CC20: 4BAC1801  bl 0x823ce420
	ctx.lr = 0x8290CC24;
	sub_823CE420(ctx, base);
	// 8290CC24: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290CC28: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 8290CC2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8290CC30: 48117A99  bl 0x82a246c8
	ctx.lr = 0x8290CC34;
	sub_82A246C8(ctx, base);
	// 8290CC34: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290CC38: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 8290CC3C: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	pc = 0x8290CC40; continue 'dispatch;
            }
            0x8290CC40 => {
    //   block [0x8290CC40..0x8290CC50)
	// 8290CC40: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 8290CC44: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8290CC48: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 8290CC4C: 419A0020  beq cr6, 0x8290cc6c
	if ctx.cr[6].eq {
	pc = 0x8290CC6C; continue 'dispatch;
	}
	pc = 0x8290CC50; continue 'dispatch;
            }
            0x8290CC50 => {
    //   block [0x8290CC50..0x8290CC6C)
	// 8290CC50: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8290CC54: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290CC58: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8290CC5C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8290CC60: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8290CC64: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290CC68: 4082FFE8  bne 0x8290cc50
	if !ctx.cr[0].eq {
	pc = 0x8290CC50; continue 'dispatch;
	}
	pc = 0x8290CC6C; continue 'dispatch;
            }
            0x8290CC6C => {
    //   block [0x8290CC6C..0x8290CC8C)
	// 8290CC6C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290CC70: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8290CC74: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 8290CC78: 4B9E8CD1  bl 0x822f5948
	ctx.lr = 0x8290CC7C;
	sub_822F5948(ctx, base);
	// 8290CC7C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8290CC80: 4B8AAE99  bl 0x821b7b18
	ctx.lr = 0x8290CC84;
	sub_821B7B18(ctx, base);
	// 8290CC84: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8290CC88: 419A0040  beq cr6, 0x8290ccc8
	if ctx.cr[6].eq {
	pc = 0x8290CCC8; continue 'dispatch;
	}
	pc = 0x8290CC8C; continue 'dispatch;
            }
            0x8290CC8C => {
    //   block [0x8290CC8C..0x8290CCC8)
	// 8290CC8C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8290CC90: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290CC94: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8290CC98: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8290CC9C: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8290CCA0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290CCA4: 4082FFE8  bne 0x8290cc8c
	if !ctx.cr[0].eq {
	pc = 0x8290CC8C; continue 'dispatch;
	}
	// 8290CCA8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290CCAC: 409A001C  bne cr6, 0x8290ccc8
	if !ctx.cr[6].eq {
	pc = 0x8290CCC8; continue 'dispatch;
	}
	// 8290CCB0: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290CCB4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290CCB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8290CCBC: 4E800421  bctrl
	ctx.lr = 0x8290CCC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290CCC0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8290CCC4: 4B90F075  bl 0x8221bd38
	ctx.lr = 0x8290CCC8;
	sub_8221BD38(ctx, base);
            }
            0x8290CCC8 => {
    //   block [0x8290CCC8..0x8290CCD8)
	// 8290CCC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290CCCC: 4B8AAE4D  bl 0x821b7b18
	ctx.lr = 0x8290CCD0;
	sub_821B7B18(ctx, base);
	// 8290CCD0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8290CCD4: 4839C77C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290CCD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290CCD8 size=528
    let mut pc: u32 = 0x8290CCD8;
    'dispatch: loop {
        match pc {
            0x8290CCD8 => {
    //   block [0x8290CCD8..0x8290CD10)
	// 8290CCD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290CCDC: 4839C721  bl 0x82ca93fc
	ctx.lr = 0x8290CCE0;
	sub_82CA93D0(ctx, base);
	// 8290CCE0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290CCE4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8290CCE8: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8290CCEC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 8290CCF0: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 8290CCF4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 8290CCF8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290CCFC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 8290CD00: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 8290CD04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290CD08: 419A0008  beq cr6, 0x8290cd10
	if ctx.cr[6].eq {
	pc = 0x8290CD10; continue 'dispatch;
	}
	// 8290CD0C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8290CD10; continue 'dispatch;
            }
            0x8290CD10 => {
    //   block [0x8290CD10..0x8290CDB4)
	// 8290CD10: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290CD14: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8290CD18: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290CD1C: 4BAC18A5  bl 0x823ce5c0
	ctx.lr = 0x8290CD20;
	sub_823CE5C0(ctx, base);
	// 8290CD20: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8290CD24: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8290CD28: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290CD2C: 4BAC13E5  bl 0x823ce110
	ctx.lr = 0x8290CD30;
	sub_823CE110(ctx, base);
	// 8290CD30: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8290CD34: 4B8AADE5  bl 0x821b7b18
	ctx.lr = 0x8290CD38;
	sub_821B7B18(ctx, base);
	// 8290CD38: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 8290CD3C: 4B91251D  bl 0x8221f258
	ctx.lr = 0x8290CD40;
	sub_8221F258(ctx, base);
	// 8290CD40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290CD44: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8290CD48: 419A006C  beq cr6, 0x8290cdb4
	if ctx.cr[6].eq {
	pc = 0x8290CDB4; continue 'dispatch;
	}
	// 8290CD4C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 8290CD50: FBBF0010  std r29, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u64 ) };
	// 8290CD54: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8290CD58: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8290CD5C: 390B04D0  addi r8, r11, 0x4d0
	ctx.r[8].s64 = ctx.r[11].s64 + 1232;
	// 8290CD60: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8290CD64: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 8290CD68: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8290CD6C: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8290CD70: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 8290CD74: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 8290CD78: F8FF0008  std r7, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 8290CD7C: 4B8E34C5  bl 0x821f0240
	ctx.lr = 0x8290CD80;
	sub_821F0240(ctx, base);
	// 8290CD80: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8290CD84: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 8290CD88: 4B9124D1  bl 0x8221f258
	ctx.lr = 0x8290CD8C;
	sub_8221F258(ctx, base);
	// 8290CD8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8290CD90: 419A0028  beq cr6, 0x8290cdb8
	if ctx.cr[6].eq {
	pc = 0x8290CDB8; continue 'dispatch;
	}
	// 8290CD94: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 8290CD98: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 8290CD9C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290CDA0: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 8290CDA4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8290CDA8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8290CDAC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8290CDB0: 4800000C  b 0x8290cdbc
	pc = 0x8290CDBC; continue 'dispatch;
            }
            0x8290CDB4 => {
    //   block [0x8290CDB4..0x8290CDB8)
	// 8290CDB4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x8290CDB8; continue 'dispatch;
            }
            0x8290CDB8 => {
    //   block [0x8290CDB8..0x8290CDBC)
	// 8290CDB8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x8290CDBC; continue 'dispatch;
            }
            0x8290CDBC => {
    //   block [0x8290CDBC..0x8290CDD0)
	// 8290CDBC: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290CDC0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 8290CDC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290CDC8: 419A0008  beq cr6, 0x8290cdd0
	if ctx.cr[6].eq {
	pc = 0x8290CDD0; continue 'dispatch;
	}
	// 8290CDCC: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8290CDD0; continue 'dispatch;
            }
            0x8290CDD0 => {
    //   block [0x8290CDD0..0x8290CE50)
	// 8290CDD0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8290CDD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290CDD8: 419A0078  beq cr6, 0x8290ce50
	if ctx.cr[6].eq {
	pc = 0x8290CE50; continue 'dispatch;
	}
	// 8290CDDC: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290CDE0: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 8290CDE4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290CDE8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8290CDEC: 4B91C31D  bl 0x82229108
	ctx.lr = 0x8290CDF0;
	sub_82229108(ctx, base);
	// 8290CDF0: 3D608291  lis r11, -0x7d6f
	ctx.r[11].s64 = -2104426496;
	// 8290CDF4: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8290CDF8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8290CDFC: 3BCBD348  addi r30, r11, -0x2cb8
	ctx.r[30].s64 = ctx.r[11].s64 + -11448;
	// 8290CE00: 4B91AA81  bl 0x82227880
	ctx.lr = 0x8290CE04;
	sub_82227880(ctx, base);
	// 8290CE04: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8290CE08: 3D40823B  lis r10, -0x7dc5
	ctx.r[10].s64 = -2110062592;
	// 8290CE0C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8290CE10: 388A08A0  addi r4, r10, 0x8a0
	ctx.r[4].s64 = ctx.r[10].s64 + 2208;
	// 8290CE14: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8290CE18: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 8290CE1C: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 8290CE20: 4B88DC61  bl 0x8219aa80
	ctx.lr = 0x8290CE24;
	sub_8219AA80(ctx, base);
	// 8290CE24: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290CE28: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8290CE2C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8290CE30: 4BAC15F1  bl 0x823ce420
	ctx.lr = 0x8290CE34;
	sub_823CE420(ctx, base);
	// 8290CE34: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290CE38: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 8290CE3C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8290CE40: 48117889  bl 0x82a246c8
	ctx.lr = 0x8290CE44;
	sub_82A246C8(ctx, base);
	// 8290CE44: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290CE48: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 8290CE4C: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x8290CE50; continue 'dispatch;
            }
            0x8290CE50 => {
    //   block [0x8290CE50..0x8290CE60)
	// 8290CE50: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8290CE54: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8290CE58: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 8290CE5C: 419A0020  beq cr6, 0x8290ce7c
	if ctx.cr[6].eq {
	pc = 0x8290CE7C; continue 'dispatch;
	}
	pc = 0x8290CE60; continue 'dispatch;
            }
            0x8290CE60 => {
    //   block [0x8290CE60..0x8290CE7C)
	// 8290CE60: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8290CE64: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290CE68: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8290CE6C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8290CE70: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8290CE74: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290CE78: 4082FFE8  bne 0x8290ce60
	if !ctx.cr[0].eq {
	pc = 0x8290CE60; continue 'dispatch;
	}
	pc = 0x8290CE7C; continue 'dispatch;
            }
            0x8290CE7C => {
    //   block [0x8290CE7C..0x8290CE9C)
	// 8290CE7C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290CE80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8290CE84: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 8290CE88: 4B9E8AC1  bl 0x822f5948
	ctx.lr = 0x8290CE8C;
	sub_822F5948(ctx, base);
	// 8290CE8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290CE90: 4B8AAC89  bl 0x821b7b18
	ctx.lr = 0x8290CE94;
	sub_821B7B18(ctx, base);
	// 8290CE94: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8290CE98: 419A0040  beq cr6, 0x8290ced8
	if ctx.cr[6].eq {
	pc = 0x8290CED8; continue 'dispatch;
	}
	pc = 0x8290CE9C; continue 'dispatch;
            }
            0x8290CE9C => {
    //   block [0x8290CE9C..0x8290CED8)
	// 8290CE9C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8290CEA0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290CEA4: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8290CEA8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8290CEAC: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8290CEB0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290CEB4: 4082FFE8  bne 0x8290ce9c
	if !ctx.cr[0].eq {
	pc = 0x8290CE9C; continue 'dispatch;
	}
	// 8290CEB8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290CEBC: 409A001C  bne cr6, 0x8290ced8
	if !ctx.cr[6].eq {
	pc = 0x8290CED8; continue 'dispatch;
	}
	// 8290CEC0: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290CEC4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290CEC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8290CECC: 4E800421  bctrl
	ctx.lr = 0x8290CED0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290CED0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8290CED4: 4B90EE65  bl 0x8221bd38
	ctx.lr = 0x8290CED8;
	sub_8221BD38(ctx, base);
            }
            0x8290CED8 => {
    //   block [0x8290CED8..0x8290CEE8)
	// 8290CED8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8290CEDC: 4B8AAC3D  bl 0x821b7b18
	ctx.lr = 0x8290CEE0;
	sub_821B7B18(ctx, base);
	// 8290CEE0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8290CEE4: 4839C568  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290CEE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290CEE8 size=528
    let mut pc: u32 = 0x8290CEE8;
    'dispatch: loop {
        match pc {
            0x8290CEE8 => {
    //   block [0x8290CEE8..0x8290CF20)
	// 8290CEE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290CEEC: 4839C511  bl 0x82ca93fc
	ctx.lr = 0x8290CEF0;
	sub_82CA93D0(ctx, base);
	// 8290CEF0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290CEF4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8290CEF8: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8290CEFC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 8290CF00: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 8290CF04: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 8290CF08: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290CF0C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 8290CF10: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 8290CF14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290CF18: 419A0008  beq cr6, 0x8290cf20
	if ctx.cr[6].eq {
	pc = 0x8290CF20; continue 'dispatch;
	}
	// 8290CF1C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8290CF20; continue 'dispatch;
            }
            0x8290CF20 => {
    //   block [0x8290CF20..0x8290CFC4)
	// 8290CF20: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290CF24: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8290CF28: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290CF2C: 4BAC1695  bl 0x823ce5c0
	ctx.lr = 0x8290CF30;
	sub_823CE5C0(ctx, base);
	// 8290CF30: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8290CF34: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8290CF38: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290CF3C: 4BAC11D5  bl 0x823ce110
	ctx.lr = 0x8290CF40;
	sub_823CE110(ctx, base);
	// 8290CF40: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8290CF44: 4B8AABD5  bl 0x821b7b18
	ctx.lr = 0x8290CF48;
	sub_821B7B18(ctx, base);
	// 8290CF48: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 8290CF4C: 4B91230D  bl 0x8221f258
	ctx.lr = 0x8290CF50;
	sub_8221F258(ctx, base);
	// 8290CF50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290CF54: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8290CF58: 419A006C  beq cr6, 0x8290cfc4
	if ctx.cr[6].eq {
	pc = 0x8290CFC4; continue 'dispatch;
	}
	// 8290CF5C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 8290CF60: FBBF0010  std r29, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u64 ) };
	// 8290CF64: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8290CF68: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8290CF6C: 390B04D0  addi r8, r11, 0x4d0
	ctx.r[8].s64 = ctx.r[11].s64 + 1232;
	// 8290CF70: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8290CF74: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 8290CF78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8290CF7C: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8290CF80: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 8290CF84: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 8290CF88: F8FF0008  std r7, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 8290CF8C: 4B8E32B5  bl 0x821f0240
	ctx.lr = 0x8290CF90;
	sub_821F0240(ctx, base);
	// 8290CF90: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8290CF94: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 8290CF98: 4B9122C1  bl 0x8221f258
	ctx.lr = 0x8290CF9C;
	sub_8221F258(ctx, base);
	// 8290CF9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8290CFA0: 419A0028  beq cr6, 0x8290cfc8
	if ctx.cr[6].eq {
	pc = 0x8290CFC8; continue 'dispatch;
	}
	// 8290CFA4: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 8290CFA8: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 8290CFAC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290CFB0: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 8290CFB4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8290CFB8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8290CFBC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8290CFC0: 4800000C  b 0x8290cfcc
	pc = 0x8290CFCC; continue 'dispatch;
            }
            0x8290CFC4 => {
    //   block [0x8290CFC4..0x8290CFC8)
	// 8290CFC4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x8290CFC8; continue 'dispatch;
            }
            0x8290CFC8 => {
    //   block [0x8290CFC8..0x8290CFCC)
	// 8290CFC8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x8290CFCC; continue 'dispatch;
            }
            0x8290CFCC => {
    //   block [0x8290CFCC..0x8290CFE0)
	// 8290CFCC: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290CFD0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 8290CFD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290CFD8: 419A0008  beq cr6, 0x8290cfe0
	if ctx.cr[6].eq {
	pc = 0x8290CFE0; continue 'dispatch;
	}
	// 8290CFDC: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8290CFE0; continue 'dispatch;
            }
            0x8290CFE0 => {
    //   block [0x8290CFE0..0x8290D060)
	// 8290CFE0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8290CFE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290CFE8: 419A0078  beq cr6, 0x8290d060
	if ctx.cr[6].eq {
	pc = 0x8290D060; continue 'dispatch;
	}
	// 8290CFEC: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290CFF0: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 8290CFF4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290CFF8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8290CFFC: 4B91C10D  bl 0x82229108
	ctx.lr = 0x8290D000;
	sub_82229108(ctx, base);
	// 8290D000: 3D608291  lis r11, -0x7d6f
	ctx.r[11].s64 = -2104426496;
	// 8290D004: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8290D008: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8290D00C: 3BCBD348  addi r30, r11, -0x2cb8
	ctx.r[30].s64 = ctx.r[11].s64 + -11448;
	// 8290D010: 4B91A871  bl 0x82227880
	ctx.lr = 0x8290D014;
	sub_82227880(ctx, base);
	// 8290D014: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8290D018: 3D408295  lis r10, -0x7d6b
	ctx.r[10].s64 = -2104164352;
	// 8290D01C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8290D020: 388AC430  addi r4, r10, -0x3bd0
	ctx.r[4].s64 = ctx.r[10].s64 + -15312;
	// 8290D024: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8290D028: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 8290D02C: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 8290D030: 4B88DA51  bl 0x8219aa80
	ctx.lr = 0x8290D034;
	sub_8219AA80(ctx, base);
	// 8290D034: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290D038: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8290D03C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8290D040: 4BAC13E1  bl 0x823ce420
	ctx.lr = 0x8290D044;
	sub_823CE420(ctx, base);
	// 8290D044: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290D048: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 8290D04C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8290D050: 48117679  bl 0x82a246c8
	ctx.lr = 0x8290D054;
	sub_82A246C8(ctx, base);
	// 8290D054: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290D058: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 8290D05C: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x8290D060; continue 'dispatch;
            }
            0x8290D060 => {
    //   block [0x8290D060..0x8290D070)
	// 8290D060: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8290D064: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8290D068: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 8290D06C: 419A0020  beq cr6, 0x8290d08c
	if ctx.cr[6].eq {
	pc = 0x8290D08C; continue 'dispatch;
	}
	pc = 0x8290D070; continue 'dispatch;
            }
            0x8290D070 => {
    //   block [0x8290D070..0x8290D08C)
	// 8290D070: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8290D074: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290D078: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8290D07C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8290D080: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8290D084: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290D088: 4082FFE8  bne 0x8290d070
	if !ctx.cr[0].eq {
	pc = 0x8290D070; continue 'dispatch;
	}
	pc = 0x8290D08C; continue 'dispatch;
            }
            0x8290D08C => {
    //   block [0x8290D08C..0x8290D0AC)
	// 8290D08C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290D090: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8290D094: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 8290D098: 4B9E88B1  bl 0x822f5948
	ctx.lr = 0x8290D09C;
	sub_822F5948(ctx, base);
	// 8290D09C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290D0A0: 4B8AAA79  bl 0x821b7b18
	ctx.lr = 0x8290D0A4;
	sub_821B7B18(ctx, base);
	// 8290D0A4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8290D0A8: 419A0040  beq cr6, 0x8290d0e8
	if ctx.cr[6].eq {
	pc = 0x8290D0E8; continue 'dispatch;
	}
	pc = 0x8290D0AC; continue 'dispatch;
            }
            0x8290D0AC => {
    //   block [0x8290D0AC..0x8290D0E8)
	// 8290D0AC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8290D0B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290D0B4: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8290D0B8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8290D0BC: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8290D0C0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290D0C4: 4082FFE8  bne 0x8290d0ac
	if !ctx.cr[0].eq {
	pc = 0x8290D0AC; continue 'dispatch;
	}
	// 8290D0C8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290D0CC: 409A001C  bne cr6, 0x8290d0e8
	if !ctx.cr[6].eq {
	pc = 0x8290D0E8; continue 'dispatch;
	}
	// 8290D0D0: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290D0D4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290D0D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8290D0DC: 4E800421  bctrl
	ctx.lr = 0x8290D0E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290D0E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8290D0E4: 4B90EC55  bl 0x8221bd38
	ctx.lr = 0x8290D0E8;
	sub_8221BD38(ctx, base);
            }
            0x8290D0E8 => {
    //   block [0x8290D0E8..0x8290D0F8)
	// 8290D0E8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8290D0EC: 4B8AAA2D  bl 0x821b7b18
	ctx.lr = 0x8290D0F0;
	sub_821B7B18(ctx, base);
	// 8290D0F0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8290D0F4: 4839C358  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290D0F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290D0F8 size=528
    let mut pc: u32 = 0x8290D0F8;
    'dispatch: loop {
        match pc {
            0x8290D0F8 => {
    //   block [0x8290D0F8..0x8290D130)
	// 8290D0F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290D0FC: 4839C301  bl 0x82ca93fc
	ctx.lr = 0x8290D100;
	sub_82CA93D0(ctx, base);
	// 8290D100: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290D104: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8290D108: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8290D10C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 8290D110: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 8290D114: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 8290D118: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290D11C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 8290D120: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 8290D124: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290D128: 419A0008  beq cr6, 0x8290d130
	if ctx.cr[6].eq {
	pc = 0x8290D130; continue 'dispatch;
	}
	// 8290D12C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8290D130; continue 'dispatch;
            }
            0x8290D130 => {
    //   block [0x8290D130..0x8290D1D4)
	// 8290D130: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290D134: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8290D138: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290D13C: 4BAC1485  bl 0x823ce5c0
	ctx.lr = 0x8290D140;
	sub_823CE5C0(ctx, base);
	// 8290D140: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8290D144: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8290D148: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290D14C: 4BAC0FC5  bl 0x823ce110
	ctx.lr = 0x8290D150;
	sub_823CE110(ctx, base);
	// 8290D150: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8290D154: 4B8AA9C5  bl 0x821b7b18
	ctx.lr = 0x8290D158;
	sub_821B7B18(ctx, base);
	// 8290D158: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 8290D15C: 4B9120FD  bl 0x8221f258
	ctx.lr = 0x8290D160;
	sub_8221F258(ctx, base);
	// 8290D160: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290D164: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8290D168: 419A006C  beq cr6, 0x8290d1d4
	if ctx.cr[6].eq {
	pc = 0x8290D1D4; continue 'dispatch;
	}
	// 8290D16C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 8290D170: FBBF0008  std r29, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u64 ) };
	// 8290D174: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8290D178: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8290D17C: 390B04D0  addi r8, r11, 0x4d0
	ctx.r[8].s64 = ctx.r[11].s64 + 1232;
	// 8290D180: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8290D184: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 8290D188: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8290D18C: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8290D190: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 8290D194: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 8290D198: F8FF0010  std r7, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[7].u64 ) };
	// 8290D19C: 4B8E30A5  bl 0x821f0240
	ctx.lr = 0x8290D1A0;
	sub_821F0240(ctx, base);
	// 8290D1A0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8290D1A4: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 8290D1A8: 4B9120B1  bl 0x8221f258
	ctx.lr = 0x8290D1AC;
	sub_8221F258(ctx, base);
	// 8290D1AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8290D1B0: 419A0028  beq cr6, 0x8290d1d8
	if ctx.cr[6].eq {
	pc = 0x8290D1D8; continue 'dispatch;
	}
	// 8290D1B4: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 8290D1B8: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 8290D1BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290D1C0: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 8290D1C4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8290D1C8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8290D1CC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8290D1D0: 4800000C  b 0x8290d1dc
	pc = 0x8290D1DC; continue 'dispatch;
            }
            0x8290D1D4 => {
    //   block [0x8290D1D4..0x8290D1D8)
	// 8290D1D4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x8290D1D8; continue 'dispatch;
            }
            0x8290D1D8 => {
    //   block [0x8290D1D8..0x8290D1DC)
	// 8290D1D8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x8290D1DC; continue 'dispatch;
            }
            0x8290D1DC => {
    //   block [0x8290D1DC..0x8290D1F0)
	// 8290D1DC: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290D1E0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 8290D1E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290D1E8: 419A0008  beq cr6, 0x8290d1f0
	if ctx.cr[6].eq {
	pc = 0x8290D1F0; continue 'dispatch;
	}
	// 8290D1EC: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8290D1F0; continue 'dispatch;
            }
            0x8290D1F0 => {
    //   block [0x8290D1F0..0x8290D270)
	// 8290D1F0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8290D1F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290D1F8: 419A0078  beq cr6, 0x8290d270
	if ctx.cr[6].eq {
	pc = 0x8290D270; continue 'dispatch;
	}
	// 8290D1FC: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290D200: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 8290D204: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290D208: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8290D20C: 4B91BEFD  bl 0x82229108
	ctx.lr = 0x8290D210;
	sub_82229108(ctx, base);
	// 8290D210: 3D608291  lis r11, -0x7d6f
	ctx.r[11].s64 = -2104426496;
	// 8290D214: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8290D218: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8290D21C: 3BCBD4C0  addi r30, r11, -0x2b40
	ctx.r[30].s64 = ctx.r[11].s64 + -11072;
	// 8290D220: 4B91A661  bl 0x82227880
	ctx.lr = 0x8290D224;
	sub_82227880(ctx, base);
	// 8290D224: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8290D228: 3D408295  lis r10, -0x7d6b
	ctx.r[10].s64 = -2104164352;
	// 8290D22C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8290D230: 388A3B58  addi r4, r10, 0x3b58
	ctx.r[4].s64 = ctx.r[10].s64 + 15192;
	// 8290D234: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8290D238: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 8290D23C: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 8290D240: 4B88D841  bl 0x8219aa80
	ctx.lr = 0x8290D244;
	sub_8219AA80(ctx, base);
	// 8290D244: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290D248: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8290D24C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8290D250: 4BAC11D1  bl 0x823ce420
	ctx.lr = 0x8290D254;
	sub_823CE420(ctx, base);
	// 8290D254: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290D258: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 8290D25C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8290D260: 48117469  bl 0x82a246c8
	ctx.lr = 0x8290D264;
	sub_82A246C8(ctx, base);
	// 8290D264: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290D268: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 8290D26C: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x8290D270; continue 'dispatch;
            }
            0x8290D270 => {
    //   block [0x8290D270..0x8290D280)
	// 8290D270: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8290D274: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8290D278: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 8290D27C: 419A0020  beq cr6, 0x8290d29c
	if ctx.cr[6].eq {
	pc = 0x8290D29C; continue 'dispatch;
	}
	pc = 0x8290D280; continue 'dispatch;
            }
            0x8290D280 => {
    //   block [0x8290D280..0x8290D29C)
	// 8290D280: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8290D284: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290D288: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8290D28C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8290D290: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8290D294: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290D298: 4082FFE8  bne 0x8290d280
	if !ctx.cr[0].eq {
	pc = 0x8290D280; continue 'dispatch;
	}
	pc = 0x8290D29C; continue 'dispatch;
            }
            0x8290D29C => {
    //   block [0x8290D29C..0x8290D2BC)
	// 8290D29C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290D2A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8290D2A4: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 8290D2A8: 4B9E86A1  bl 0x822f5948
	ctx.lr = 0x8290D2AC;
	sub_822F5948(ctx, base);
	// 8290D2AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290D2B0: 4B8AA869  bl 0x821b7b18
	ctx.lr = 0x8290D2B4;
	sub_821B7B18(ctx, base);
	// 8290D2B4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8290D2B8: 419A0040  beq cr6, 0x8290d2f8
	if ctx.cr[6].eq {
	pc = 0x8290D2F8; continue 'dispatch;
	}
	pc = 0x8290D2BC; continue 'dispatch;
            }
            0x8290D2BC => {
    //   block [0x8290D2BC..0x8290D2F8)
	// 8290D2BC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8290D2C0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290D2C4: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8290D2C8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8290D2CC: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8290D2D0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290D2D4: 4082FFE8  bne 0x8290d2bc
	if !ctx.cr[0].eq {
	pc = 0x8290D2BC; continue 'dispatch;
	}
	// 8290D2D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290D2DC: 409A001C  bne cr6, 0x8290d2f8
	if !ctx.cr[6].eq {
	pc = 0x8290D2F8; continue 'dispatch;
	}
	// 8290D2E0: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290D2E4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290D2E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8290D2EC: 4E800421  bctrl
	ctx.lr = 0x8290D2F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290D2F0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8290D2F4: 4B90EA45  bl 0x8221bd38
	ctx.lr = 0x8290D2F8;
	sub_8221BD38(ctx, base);
            }
            0x8290D2F8 => {
    //   block [0x8290D2F8..0x8290D308)
	// 8290D2F8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8290D2FC: 4B8AA81D  bl 0x821b7b18
	ctx.lr = 0x8290D300;
	sub_821B7B18(ctx, base);
	// 8290D300: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8290D304: 4839C148  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290D308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8290D308 size=56
    let mut pc: u32 = 0x8290D308;
    'dispatch: loop {
        match pc {
            0x8290D308 => {
    //   block [0x8290D308..0x8290D324)
	// 8290D308: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8290D30C: 419A0018  beq cr6, 0x8290d324
	if ctx.cr[6].eq {
	pc = 0x8290D324; continue 'dispatch;
	}
	// 8290D310: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 8290D314: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8290D318: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290D31C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290D320: 409A0008  bne cr6, 0x8290d328
	if !ctx.cr[6].eq {
	pc = 0x8290D328; continue 'dispatch;
	}
	pc = 0x8290D324; continue 'dispatch;
            }
            0x8290D324 => {
    //   block [0x8290D324..0x8290D328)
	// 8290D324: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8290D328; continue 'dispatch;
            }
            0x8290D328 => {
    //   block [0x8290D328..0x8290D340)
	// 8290D328: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290D32C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290D330: 419A0010  beq cr6, 0x8290d340
	if ctx.cr[6].eq {
		sub_8290D340(ctx, base);
		return;
	}
	// 8290D334: 81640030  lwz r11, 0x30(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 8290D338: 55630FFE  srwi r3, r11, 0x1f
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shr(31);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 8290D33C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290D340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8290D340 size=8
    let mut pc: u32 = 0x8290D340;
    'dispatch: loop {
        match pc {
            0x8290D340 => {
    //   block [0x8290D340..0x8290D348)
	// 8290D340: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8290D344: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290D348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290D348 size=376
    let mut pc: u32 = 0x8290D348;
    'dispatch: loop {
        match pc {
            0x8290D348 => {
    //   block [0x8290D348..0x8290D370)
	// 8290D348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290D34C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8290D350: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290D354: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8290D358: 419A0018  beq cr6, 0x8290d370
	if ctx.cr[6].eq {
	pc = 0x8290D370; continue 'dispatch;
	}
	// 8290D35C: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 8290D360: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8290D364: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290D368: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290D36C: 409A0008  bne cr6, 0x8290d374
	if !ctx.cr[6].eq {
	pc = 0x8290D374; continue 'dispatch;
	}
	pc = 0x8290D370; continue 'dispatch;
            }
            0x8290D370 => {
    //   block [0x8290D370..0x8290D374)
	// 8290D370: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8290D374; continue 'dispatch;
            }
            0x8290D374 => {
    //   block [0x8290D374..0x8290D3BC)
	// 8290D374: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290D378: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290D37C: 419A0130  beq cr6, 0x8290d4ac
	if ctx.cr[6].eq {
	pc = 0x8290D4AC; continue 'dispatch;
	}
	// 8290D380: 81440030  lwz r10, 0x30(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 8290D384: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8290D388: 55490FFE  srwi r9, r10, 0x1f
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shr(31);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8290D38C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8290D390: 419A00E8  beq cr6, 0x8290d478
	if ctx.cr[6].eq {
	pc = 0x8290D478; continue 'dispatch;
	}
	// 8290D394: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 8290D398: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 8290D39C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290D3A0: 419A001C  beq cr6, 0x8290d3bc
	if ctx.cr[6].eq {
	pc = 0x8290D3BC; continue 'dispatch;
	}
	// 8290D3A4: 896B007F  lbz r11, 0x7f(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(127 as u32) ) } as u64;
	// 8290D3A8: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 8290D3AC: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8290D3B0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290D3B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290D3B8: 480000C4  b 0x8290d47c
	pc = 0x8290D47C; continue 'dispatch;
            }
            0x8290D3BC => {
    //   block [0x8290D3BC..0x8290D3D8)
	// 8290D3BC: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 8290D3C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8290D3C4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8290D3C8: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8290D3CC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8290D3D0: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290D3D4: 40810054  ble 0x8290d428
	if !ctx.cr[0].gt {
	pc = 0x8290D428; continue 'dispatch;
	}
	pc = 0x8290D3D8; continue 'dispatch;
            }
            0x8290D3D8 => {
    //   block [0x8290D3D8..0x8290D3F8)
	// 8290D3D8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8290D3DC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8290D3E0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8290D3E4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290D3E8: 2F07007F  cmpwi cr6, r7, 0x7f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 127, &mut ctx.xer);
	// 8290D3EC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8290D3F0: 41980008  blt cr6, 0x8290d3f8
	if ctx.cr[6].lt {
	pc = 0x8290D3F8; continue 'dispatch;
	}
	// 8290D3F4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x8290D3F8; continue 'dispatch;
            }
            0x8290D3F8 => {
    //   block [0x8290D3F8..0x8290D414)
	// 8290D3F8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8290D3FC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8290D400: 419A0014  beq cr6, 0x8290d414
	if ctx.cr[6].eq {
	pc = 0x8290D414; continue 'dispatch;
	}
	// 8290D404: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8290D408: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8290D40C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8290D410: 4800000C  b 0x8290d41c
	pc = 0x8290D41C; continue 'dispatch;
            }
            0x8290D414 => {
    //   block [0x8290D414..0x8290D41C)
	// 8290D414: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8290D418: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8290D41C; continue 'dispatch;
            }
            0x8290D41C => {
    //   block [0x8290D41C..0x8290D428)
	// 8290D41C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290D420: 4199FFB8  bgt cr6, 0x8290d3d8
	if ctx.cr[6].gt {
	pc = 0x8290D3D8; continue 'dispatch;
	}
	// 8290D424: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8290D428; continue 'dispatch;
            }
            0x8290D428 => {
    //   block [0x8290D428..0x8290D444)
	// 8290D428: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8290D42C: 419A003C  beq cr6, 0x8290d468
	if ctx.cr[6].eq {
	pc = 0x8290D468; continue 'dispatch;
	}
	// 8290D430: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290D434: 2F0B007F  cmpwi cr6, r11, 0x7f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 127, &mut ctx.xer);
	// 8290D438: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290D43C: 41990008  bgt cr6, 0x8290d444
	if ctx.cr[6].gt {
	pc = 0x8290D444; continue 'dispatch;
	}
	// 8290D440: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8290D444; continue 'dispatch;
            }
            0x8290D444 => {
    //   block [0x8290D444..0x8290D468)
	// 8290D444: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290D448: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290D44C: 409A001C  bne cr6, 0x8290d468
	if !ctx.cr[6].eq {
	pc = 0x8290D468; continue 'dispatch;
	}
	// 8290D450: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8290D454: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290D458: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8290D45C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8290D460: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290D464: 48000018  b 0x8290d47c
	pc = 0x8290D47C; continue 'dispatch;
            }
            0x8290D468 => {
    //   block [0x8290D468..0x8290D478)
	// 8290D468: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8290D46C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290D470: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290D474: 48000008  b 0x8290d47c
	pc = 0x8290D47C; continue 'dispatch;
            }
            0x8290D478 => {
    //   block [0x8290D478..0x8290D47C)
	// 8290D478: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x8290D47C; continue 'dispatch;
            }
            0x8290D47C => {
    //   block [0x8290D47C..0x8290D4AC)
	// 8290D47C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8290D480: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290D484: 419A0028  beq cr6, 0x8290d4ac
	if ctx.cr[6].eq {
	pc = 0x8290D4AC; continue 'dispatch;
	}
	// 8290D488: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 8290D48C: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 8290D490: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8290D494: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8290D498: 4E800421  bctrl
	ctx.lr = 0x8290D49C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290D49C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8290D4A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8290D4A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290D4A8: 4E800020  blr
	return;
            }
            0x8290D4AC => {
    //   block [0x8290D4AC..0x8290D4C0)
	// 8290D4AC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8290D4B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8290D4B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8290D4B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290D4BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290D4C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290D4C0 size=356
    let mut pc: u32 = 0x8290D4C0;
    'dispatch: loop {
        match pc {
            0x8290D4C0 => {
    //   block [0x8290D4C0..0x8290D4E8)
	// 8290D4C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290D4C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8290D4C8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290D4CC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8290D4D0: 419A0018  beq cr6, 0x8290d4e8
	if ctx.cr[6].eq {
	pc = 0x8290D4E8; continue 'dispatch;
	}
	// 8290D4D4: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 8290D4D8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8290D4DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290D4E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290D4E4: 409A0008  bne cr6, 0x8290d4ec
	if !ctx.cr[6].eq {
	pc = 0x8290D4EC; continue 'dispatch;
	}
	pc = 0x8290D4E8; continue 'dispatch;
            }
            0x8290D4E8 => {
    //   block [0x8290D4E8..0x8290D4EC)
	// 8290D4E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8290D4EC; continue 'dispatch;
            }
            0x8290D4EC => {
    //   block [0x8290D4EC..0x8290D534)
	// 8290D4EC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290D4F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290D4F4: 419A0120  beq cr6, 0x8290d614
	if ctx.cr[6].eq {
	pc = 0x8290D614; continue 'dispatch;
	}
	// 8290D4F8: 81440030  lwz r10, 0x30(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 8290D4FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8290D500: 55490FFE  srwi r9, r10, 0x1f
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shr(31);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8290D504: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8290D508: 419A00E8  beq cr6, 0x8290d5f0
	if ctx.cr[6].eq {
	pc = 0x8290D5F0; continue 'dispatch;
	}
	// 8290D50C: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 8290D510: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 8290D514: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290D518: 419A001C  beq cr6, 0x8290d534
	if ctx.cr[6].eq {
	pc = 0x8290D534; continue 'dispatch;
	}
	// 8290D51C: 896B007F  lbz r11, 0x7f(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(127 as u32) ) } as u64;
	// 8290D520: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 8290D524: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8290D528: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290D52C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290D530: 480000C4  b 0x8290d5f4
	pc = 0x8290D5F4; continue 'dispatch;
            }
            0x8290D534 => {
    //   block [0x8290D534..0x8290D550)
	// 8290D534: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 8290D538: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8290D53C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8290D540: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8290D544: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8290D548: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290D54C: 40810054  ble 0x8290d5a0
	if !ctx.cr[0].gt {
	pc = 0x8290D5A0; continue 'dispatch;
	}
	pc = 0x8290D550; continue 'dispatch;
            }
            0x8290D550 => {
    //   block [0x8290D550..0x8290D570)
	// 8290D550: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8290D554: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8290D558: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8290D55C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290D560: 2F07007F  cmpwi cr6, r7, 0x7f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 127, &mut ctx.xer);
	// 8290D564: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8290D568: 41980008  blt cr6, 0x8290d570
	if ctx.cr[6].lt {
	pc = 0x8290D570; continue 'dispatch;
	}
	// 8290D56C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x8290D570; continue 'dispatch;
            }
            0x8290D570 => {
    //   block [0x8290D570..0x8290D58C)
	// 8290D570: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8290D574: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8290D578: 419A0014  beq cr6, 0x8290d58c
	if ctx.cr[6].eq {
	pc = 0x8290D58C; continue 'dispatch;
	}
	// 8290D57C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8290D580: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8290D584: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8290D588: 4800000C  b 0x8290d594
	pc = 0x8290D594; continue 'dispatch;
            }
            0x8290D58C => {
    //   block [0x8290D58C..0x8290D594)
	// 8290D58C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8290D590: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8290D594; continue 'dispatch;
            }
            0x8290D594 => {
    //   block [0x8290D594..0x8290D5A0)
	// 8290D594: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290D598: 4199FFB8  bgt cr6, 0x8290d550
	if ctx.cr[6].gt {
	pc = 0x8290D550; continue 'dispatch;
	}
	// 8290D59C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8290D5A0; continue 'dispatch;
            }
            0x8290D5A0 => {
    //   block [0x8290D5A0..0x8290D5BC)
	// 8290D5A0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8290D5A4: 419A003C  beq cr6, 0x8290d5e0
	if ctx.cr[6].eq {
	pc = 0x8290D5E0; continue 'dispatch;
	}
	// 8290D5A8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290D5AC: 2F0B007F  cmpwi cr6, r11, 0x7f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 127, &mut ctx.xer);
	// 8290D5B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290D5B4: 41990008  bgt cr6, 0x8290d5bc
	if ctx.cr[6].gt {
	pc = 0x8290D5BC; continue 'dispatch;
	}
	// 8290D5B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8290D5BC; continue 'dispatch;
            }
            0x8290D5BC => {
    //   block [0x8290D5BC..0x8290D5E0)
	// 8290D5BC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290D5C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290D5C4: 409A001C  bne cr6, 0x8290d5e0
	if !ctx.cr[6].eq {
	pc = 0x8290D5E0; continue 'dispatch;
	}
	// 8290D5C8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8290D5CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290D5D0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8290D5D4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8290D5D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290D5DC: 48000018  b 0x8290d5f4
	pc = 0x8290D5F4; continue 'dispatch;
            }
            0x8290D5E0 => {
    //   block [0x8290D5E0..0x8290D5F0)
	// 8290D5E0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8290D5E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290D5E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290D5EC: 48000008  b 0x8290d5f4
	pc = 0x8290D5F4; continue 'dispatch;
            }
            0x8290D5F0 => {
    //   block [0x8290D5F0..0x8290D5F4)
	// 8290D5F0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x8290D5F4; continue 'dispatch;
            }
            0x8290D5F4 => {
    //   block [0x8290D5F4..0x8290D614)
	// 8290D5F4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8290D5F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290D5FC: 419A0018  beq cr6, 0x8290d614
	if ctx.cr[6].eq {
	pc = 0x8290D614; continue 'dispatch;
	}
	// 8290D600: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8290D604: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290D608: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8290D60C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8290D610: 4E800421  bctrl
	ctx.lr = 0x8290D614;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8290D614 => {
    //   block [0x8290D614..0x8290D624)
	// 8290D614: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8290D618: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8290D61C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290D620: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290D628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8290D628 size=8
    let mut pc: u32 = 0x8290D628;
    'dispatch: loop {
        match pc {
            0x8290D628 => {
    //   block [0x8290D628..0x8290D630)
	// 8290D628: 3863FFF4  addi r3, r3, -0xc
	ctx.r[3].s64 = ctx.r[3].s64 + -12;
	// 8290D62C: 4BFFCB1C  b 0x8290a148
	sub_8290A148(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290D630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290D630 size=60
    let mut pc: u32 = 0x8290D630;
    'dispatch: loop {
        match pc {
            0x8290D630 => {
    //   block [0x8290D630..0x8290D66C)
	// 8290D630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290D634: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8290D638: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8290D63C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290D640: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8290D644: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8290D648: 388B9AB4  addi r4, r11, -0x654c
	ctx.r[4].s64 = ctx.r[11].s64 + -25932;
	// 8290D64C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290D650: 4B91F881  bl 0x8222ced0
	ctx.lr = 0x8290D654;
	sub_8222CED0(ctx, base);
	// 8290D654: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290D658: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8290D65C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8290D660: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290D664: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8290D668: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290D670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290D670 size=60
    let mut pc: u32 = 0x8290D670;
    'dispatch: loop {
        match pc {
            0x8290D670 => {
    //   block [0x8290D670..0x8290D6AC)
	// 8290D670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290D674: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8290D678: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8290D67C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290D680: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8290D684: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8290D688: 388B9A34  addi r4, r11, -0x65cc
	ctx.r[4].s64 = ctx.r[11].s64 + -26060;
	// 8290D68C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290D690: 4B91F841  bl 0x8222ced0
	ctx.lr = 0x8290D694;
	sub_8222CED0(ctx, base);
	// 8290D694: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290D698: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8290D69C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8290D6A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290D6A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8290D6A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290D6B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8290D6B0 size=8
    let mut pc: u32 = 0x8290D6B0;
    'dispatch: loop {
        match pc {
            0x8290D6B0 => {
    //   block [0x8290D6B0..0x8290D6B8)
	// 8290D6B0: C023000C  lfs f1, 0xc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8290D6B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290D6B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290D6B8 size=584
    let mut pc: u32 = 0x8290D6B8;
    'dispatch: loop {
        match pc {
            0x8290D6B8 => {
    //   block [0x8290D6B8..0x8290D6E0)
	// 8290D6B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290D6BC: 4839BD45  bl 0x82ca9400
	ctx.lr = 0x8290D6C0;
	sub_82CA93D0(ctx, base);
	// 8290D6C0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290D6C4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290D6C8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8290D6CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290D6D0: 409A0010  bne cr6, 0x8290d6e0
	if !ctx.cr[6].eq {
	pc = 0x8290D6E0; continue 'dispatch;
	}
	// 8290D6D4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8290D6D8: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 8290D6DC: 48000008  b 0x8290d6e4
	pc = 0x8290D6E4; continue 'dispatch;
            }
            0x8290D6E0 => {
    //   block [0x8290D6E0..0x8290D6E4)
	// 8290D6E0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8290D6E4; continue 'dispatch;
            }
            0x8290D6E4 => {
    //   block [0x8290D6E4..0x8290D75C)
	// 8290D6E4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290D6E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8290D6EC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290D6F0: 4BAC0ED1  bl 0x823ce5c0
	ctx.lr = 0x8290D6F4;
	sub_823CE5C0(ctx, base);
	// 8290D6F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8290D6F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290D6FC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290D700: 4BAC0B01  bl 0x823ce200
	ctx.lr = 0x8290D704;
	sub_823CE200(ctx, base);
	// 8290D704: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8290D708: 4B8AA411  bl 0x821b7b18
	ctx.lr = 0x8290D70C;
	sub_821B7B18(ctx, base);
	// 8290D70C: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 8290D710: 4B911B49  bl 0x8221f258
	ctx.lr = 0x8290D714;
	sub_8221F258(ctx, base);
	// 8290D714: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8290D718: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8290D71C: 419A0040  beq cr6, 0x8290d75c
	if ctx.cr[6].eq {
	pc = 0x8290D75C; continue 'dispatch;
	}
	// 8290D720: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 8290D724: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8290D728: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 8290D72C: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8290D730: 4B911B29  bl 0x8221f258
	ctx.lr = 0x8290D734;
	sub_8221F258(ctx, base);
	// 8290D734: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8290D738: 419A0028  beq cr6, 0x8290d760
	if ctx.cr[6].eq {
	pc = 0x8290D760; continue 'dispatch;
	}
	// 8290D73C: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 8290D740: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 8290D744: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290D748: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 8290D74C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8290D750: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8290D754: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8290D758: 4800000C  b 0x8290d764
	pc = 0x8290D764; continue 'dispatch;
            }
            0x8290D75C => {
    //   block [0x8290D75C..0x8290D760)
	// 8290D75C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x8290D760; continue 'dispatch;
            }
            0x8290D760 => {
    //   block [0x8290D760..0x8290D764)
	// 8290D760: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x8290D764; continue 'dispatch;
            }
            0x8290D764 => {
    //   block [0x8290D764..0x8290D868)
	// 8290D764: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8290D768: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8290D76C: 419A00FC  beq cr6, 0x8290d868
	if ctx.cr[6].eq {
	pc = 0x8290D868; continue 'dispatch;
	}
	// 8290D770: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290D774: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 8290D778: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290D77C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8290D780: 4B91B989  bl 0x82229108
	ctx.lr = 0x8290D784;
	sub_82229108(ctx, base);
	// 8290D784: 3D608291  lis r11, -0x7d6f
	ctx.r[11].s64 = -2104426496;
	// 8290D788: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8290D78C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8290D790: 3BCBDB08  addi r30, r11, -0x24f8
	ctx.r[30].s64 = ctx.r[11].s64 + -9464;
	// 8290D794: 4B91A0ED  bl 0x82227880
	ctx.lr = 0x8290D798;
	sub_82227880(ctx, base);
	// 8290D798: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8290D79C: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 8290D7A0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8290D7A4: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 8290D7A8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8290D7AC: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 8290D7B0: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 8290D7B4: 4B88D2CD  bl 0x8219aa80
	ctx.lr = 0x8290D7B8;
	sub_8219AA80(ctx, base);
	// 8290D7B8: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 8290D7BC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8290D7C0: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 8290D7C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290D7C8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8290D7CC: 4BAC0C55  bl 0x823ce420
	ctx.lr = 0x8290D7D0;
	sub_823CE420(ctx, base);
	// 8290D7D0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8290D7D4: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 8290D7D8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8290D7DC: 48116EED  bl 0x82a246c8
	ctx.lr = 0x8290D7E0;
	sub_82A246C8(ctx, base);
	// 8290D7E0: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290D7E4: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 8290D7E8: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 8290D7EC: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 8290D7F0: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290D7F4: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290D7F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8290D7FC: 4B91B90D  bl 0x82229108
	ctx.lr = 0x8290D800;
	sub_82229108(ctx, base);
	// 8290D800: 3D608232  lis r11, -0x7dce
	ctx.r[11].s64 = -2110652416;
	// 8290D804: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8290D808: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8290D80C: 3BEB6CF0  addi r31, r11, 0x6cf0
	ctx.r[31].s64 = ctx.r[11].s64 + 27888;
	// 8290D810: 4B91A071  bl 0x82227880
	ctx.lr = 0x8290D814;
	sub_82227880(ctx, base);
	// 8290D814: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 8290D818: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 8290D81C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8290D820: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 8290D824: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8290D828: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 8290D82C: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 8290D830: 4B88D251  bl 0x8219aa80
	ctx.lr = 0x8290D834;
	sub_8219AA80(ctx, base);
	// 8290D834: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 8290D838: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8290D83C: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 8290D840: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290D844: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290D848: 4BAC0BD9  bl 0x823ce420
	ctx.lr = 0x8290D84C;
	sub_823CE420(ctx, base);
	// 8290D84C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290D850: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 8290D854: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8290D858: 48116E71  bl 0x82a246c8
	ctx.lr = 0x8290D85C;
	sub_82A246C8(ctx, base);
	// 8290D85C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290D860: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 8290D864: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	pc = 0x8290D868; continue 'dispatch;
            }
            0x8290D868 => {
    //   block [0x8290D868..0x8290D878)
	// 8290D868: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 8290D86C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8290D870: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 8290D874: 419A0020  beq cr6, 0x8290d894
	if ctx.cr[6].eq {
	pc = 0x8290D894; continue 'dispatch;
	}
	pc = 0x8290D878; continue 'dispatch;
            }
            0x8290D878 => {
    //   block [0x8290D878..0x8290D894)
	// 8290D878: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8290D87C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290D880: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8290D884: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8290D888: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8290D88C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290D890: 4082FFE8  bne 0x8290d878
	if !ctx.cr[0].eq {
	pc = 0x8290D878; continue 'dispatch;
	}
	pc = 0x8290D894; continue 'dispatch;
            }
            0x8290D894 => {
    //   block [0x8290D894..0x8290D8B4)
	// 8290D894: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290D898: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8290D89C: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 8290D8A0: 4B9E80A9  bl 0x822f5948
	ctx.lr = 0x8290D8A4;
	sub_822F5948(ctx, base);
	// 8290D8A4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8290D8A8: 4B8AA271  bl 0x821b7b18
	ctx.lr = 0x8290D8AC;
	sub_821B7B18(ctx, base);
	// 8290D8AC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8290D8B0: 419A0040  beq cr6, 0x8290d8f0
	if ctx.cr[6].eq {
	pc = 0x8290D8F0; continue 'dispatch;
	}
	pc = 0x8290D8B4; continue 'dispatch;
            }
            0x8290D8B4 => {
    //   block [0x8290D8B4..0x8290D8F0)
	// 8290D8B4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8290D8B8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290D8BC: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8290D8C0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8290D8C4: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8290D8C8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290D8CC: 4082FFE8  bne 0x8290d8b4
	if !ctx.cr[0].eq {
	pc = 0x8290D8B4; continue 'dispatch;
	}
	// 8290D8D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290D8D4: 409A001C  bne cr6, 0x8290d8f0
	if !ctx.cr[6].eq {
	pc = 0x8290D8F0; continue 'dispatch;
	}
	// 8290D8D8: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290D8DC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290D8E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8290D8E4: 4E800421  bctrl
	ctx.lr = 0x8290D8E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290D8E8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8290D8EC: 4B90E44D  bl 0x8221bd38
	ctx.lr = 0x8290D8F0;
	sub_8221BD38(ctx, base);
            }
            0x8290D8F0 => {
    //   block [0x8290D8F0..0x8290D900)
	// 8290D8F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290D8F4: 4B8AA225  bl 0x821b7b18
	ctx.lr = 0x8290D8F8;
	sub_821B7B18(ctx, base);
	// 8290D8F8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8290D8FC: 4839BB54  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290D900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290D900 size=516
    let mut pc: u32 = 0x8290D900;
    'dispatch: loop {
        match pc {
            0x8290D900 => {
    //   block [0x8290D900..0x8290D93C)
	// 8290D900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290D904: 4839BAF9  bl 0x82ca93fc
	ctx.lr = 0x8290D908;
	sub_82CA93D0(ctx, base);
	// 8290D908: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290D90C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8290D910: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 8290D914: 3D408291  lis r10, -0x7d6f
	ctx.r[10].s64 = -2104426496;
	// 8290D918: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 8290D91C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 8290D920: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290D924: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 8290D928: 3BAAD6B0  addi r29, r10, -0x2950
	ctx.r[29].s64 = ctx.r[10].s64 + -10576;
	// 8290D92C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290D930: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 8290D934: 419A0008  beq cr6, 0x8290d93c
	if ctx.cr[6].eq {
	pc = 0x8290D93C; continue 'dispatch;
	}
	// 8290D938: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8290D93C; continue 'dispatch;
            }
            0x8290D93C => {
    //   block [0x8290D93C..0x8290D9D0)
	// 8290D93C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290D940: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8290D944: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290D948: 4BAC0C79  bl 0x823ce5c0
	ctx.lr = 0x8290D94C;
	sub_823CE5C0(ctx, base);
	// 8290D94C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8290D950: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8290D954: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290D958: 4BAC07B9  bl 0x823ce110
	ctx.lr = 0x8290D95C;
	sub_823CE110(ctx, base);
	// 8290D95C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8290D960: 4B8AA1B9  bl 0x821b7b18
	ctx.lr = 0x8290D964;
	sub_821B7B18(ctx, base);
	// 8290D964: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8290D968: 4B9118F1  bl 0x8221f258
	ctx.lr = 0x8290D96C;
	sub_8221F258(ctx, base);
	// 8290D96C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290D970: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8290D974: 419A005C  beq cr6, 0x8290d9d0
	if ctx.cr[6].eq {
	pc = 0x8290D9D0; continue 'dispatch;
	}
	// 8290D978: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8290D97C: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 8290D980: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8290D984: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 8290D988: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8290D98C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8290D990: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8290D994: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 8290D998: 4B8E28A9  bl 0x821f0240
	ctx.lr = 0x8290D99C;
	sub_821F0240(ctx, base);
	// 8290D99C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8290D9A0: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 8290D9A4: 4B9118B5  bl 0x8221f258
	ctx.lr = 0x8290D9A8;
	sub_8221F258(ctx, base);
	// 8290D9A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8290D9AC: 419A0028  beq cr6, 0x8290d9d4
	if ctx.cr[6].eq {
	pc = 0x8290D9D4; continue 'dispatch;
	}
	// 8290D9B0: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 8290D9B4: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 8290D9B8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290D9BC: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 8290D9C0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8290D9C4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8290D9C8: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8290D9CC: 4800000C  b 0x8290d9d8
	pc = 0x8290D9D8; continue 'dispatch;
            }
            0x8290D9D0 => {
    //   block [0x8290D9D0..0x8290D9D4)
	// 8290D9D0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x8290D9D4; continue 'dispatch;
            }
            0x8290D9D4 => {
    //   block [0x8290D9D4..0x8290D9D8)
	// 8290D9D4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x8290D9D8; continue 'dispatch;
            }
            0x8290D9D8 => {
    //   block [0x8290D9D8..0x8290D9EC)
	// 8290D9D8: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290D9DC: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 8290D9E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290D9E4: 419A0008  beq cr6, 0x8290d9ec
	if ctx.cr[6].eq {
	pc = 0x8290D9EC; continue 'dispatch;
	}
	// 8290D9E8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8290D9EC; continue 'dispatch;
            }
            0x8290D9EC => {
    //   block [0x8290D9EC..0x8290DA6C)
	// 8290D9EC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8290D9F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290D9F4: 419A0078  beq cr6, 0x8290da6c
	if ctx.cr[6].eq {
	pc = 0x8290DA6C; continue 'dispatch;
	}
	// 8290D9F8: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290D9FC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 8290DA00: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290DA04: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8290DA08: 4B91B701  bl 0x82229108
	ctx.lr = 0x8290DA0C;
	sub_82229108(ctx, base);
	// 8290DA0C: 3D608291  lis r11, -0x7d6f
	ctx.r[11].s64 = -2104426496;
	// 8290DA10: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8290DA14: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8290DA18: 3BCBDB48  addi r30, r11, -0x24b8
	ctx.r[30].s64 = ctx.r[11].s64 + -9400;
	// 8290DA1C: 4B919E65  bl 0x82227880
	ctx.lr = 0x8290DA20;
	sub_82227880(ctx, base);
	// 8290DA20: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8290DA24: 3D40828E  lis r10, -0x7d72
	ctx.r[10].s64 = -2104623104;
	// 8290DA28: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8290DA2C: 388A8370  addi r4, r10, -0x7c90
	ctx.r[4].s64 = ctx.r[10].s64 + -31888;
	// 8290DA30: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8290DA34: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 8290DA38: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 8290DA3C: 4B88D045  bl 0x8219aa80
	ctx.lr = 0x8290DA40;
	sub_8219AA80(ctx, base);
	// 8290DA40: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290DA44: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8290DA48: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8290DA4C: 4BAC09D5  bl 0x823ce420
	ctx.lr = 0x8290DA50;
	sub_823CE420(ctx, base);
	// 8290DA50: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290DA54: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 8290DA58: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8290DA5C: 48116C6D  bl 0x82a246c8
	ctx.lr = 0x8290DA60;
	sub_82A246C8(ctx, base);
	// 8290DA60: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290DA64: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 8290DA68: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x8290DA6C; continue 'dispatch;
            }
            0x8290DA6C => {
    //   block [0x8290DA6C..0x8290DA7C)
	// 8290DA6C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8290DA70: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8290DA74: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 8290DA78: 419A0020  beq cr6, 0x8290da98
	if ctx.cr[6].eq {
	pc = 0x8290DA98; continue 'dispatch;
	}
	pc = 0x8290DA7C; continue 'dispatch;
            }
            0x8290DA7C => {
    //   block [0x8290DA7C..0x8290DA98)
	// 8290DA7C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8290DA80: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290DA84: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8290DA88: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8290DA8C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8290DA90: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290DA94: 4082FFE8  bne 0x8290da7c
	if !ctx.cr[0].eq {
	pc = 0x8290DA7C; continue 'dispatch;
	}
	pc = 0x8290DA98; continue 'dispatch;
            }
            0x8290DA98 => {
    //   block [0x8290DA98..0x8290DAB8)
	// 8290DA98: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290DA9C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8290DAA0: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 8290DAA4: 4B9E7EA5  bl 0x822f5948
	ctx.lr = 0x8290DAA8;
	sub_822F5948(ctx, base);
	// 8290DAA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290DAAC: 4B8AA06D  bl 0x821b7b18
	ctx.lr = 0x8290DAB0;
	sub_821B7B18(ctx, base);
	// 8290DAB0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8290DAB4: 419A0040  beq cr6, 0x8290daf4
	if ctx.cr[6].eq {
	pc = 0x8290DAF4; continue 'dispatch;
	}
	pc = 0x8290DAB8; continue 'dispatch;
            }
            0x8290DAB8 => {
    //   block [0x8290DAB8..0x8290DAF4)
	// 8290DAB8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8290DABC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290DAC0: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8290DAC4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8290DAC8: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8290DACC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290DAD0: 4082FFE8  bne 0x8290dab8
	if !ctx.cr[0].eq {
	pc = 0x8290DAB8; continue 'dispatch;
	}
	// 8290DAD4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290DAD8: 409A001C  bne cr6, 0x8290daf4
	if !ctx.cr[6].eq {
	pc = 0x8290DAF4; continue 'dispatch;
	}
	// 8290DADC: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290DAE0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290DAE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8290DAE8: 4E800421  bctrl
	ctx.lr = 0x8290DAEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290DAEC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8290DAF0: 4B90E249  bl 0x8221bd38
	ctx.lr = 0x8290DAF4;
	sub_8221BD38(ctx, base);
            }
            0x8290DAF4 => {
    //   block [0x8290DAF4..0x8290DB04)
	// 8290DAF4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8290DAF8: 4B8AA021  bl 0x821b7b18
	ctx.lr = 0x8290DAFC;
	sub_821B7B18(ctx, base);
	// 8290DAFC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8290DB00: 4839B94C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290DB08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8290DB08 size=56
    let mut pc: u32 = 0x8290DB08;
    'dispatch: loop {
        match pc {
            0x8290DB08 => {
    //   block [0x8290DB08..0x8290DB24)
	// 8290DB08: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8290DB0C: 419A0018  beq cr6, 0x8290db24
	if ctx.cr[6].eq {
	pc = 0x8290DB24; continue 'dispatch;
	}
	// 8290DB10: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 8290DB14: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8290DB18: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290DB1C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290DB20: 409A0008  bne cr6, 0x8290db28
	if !ctx.cr[6].eq {
	pc = 0x8290DB28; continue 'dispatch;
	}
	pc = 0x8290DB24; continue 'dispatch;
            }
            0x8290DB24 => {
    //   block [0x8290DB24..0x8290DB28)
	// 8290DB24: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8290DB28; continue 'dispatch;
            }
            0x8290DB28 => {
    //   block [0x8290DB28..0x8290DB40)
	// 8290DB28: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290DB2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290DB30: 419A0010  beq cr6, 0x8290db40
	if ctx.cr[6].eq {
		sub_8290DB40(ctx, base);
		return;
	}
	// 8290DB34: 81640038  lwz r11, 0x38(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(56 as u32) ) } as u64;
	// 8290DB38: 5563EFFE  rlwinm r3, r11, 0x1d, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 8290DB3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290DB40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8290DB40 size=8
    let mut pc: u32 = 0x8290DB40;
    'dispatch: loop {
        match pc {
            0x8290DB40 => {
    //   block [0x8290DB40..0x8290DB48)
	// 8290DB40: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8290DB44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290DB48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8290DB48 size=380
    let mut pc: u32 = 0x8290DB48;
    'dispatch: loop {
        match pc {
            0x8290DB48 => {
    //   block [0x8290DB48..0x8290DB70)
	// 8290DB48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290DB4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8290DB50: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290DB54: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8290DB58: 419A0018  beq cr6, 0x8290db70
	if ctx.cr[6].eq {
	pc = 0x8290DB70; continue 'dispatch;
	}
	// 8290DB5C: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 8290DB60: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8290DB64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290DB68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290DB6C: 409A0008  bne cr6, 0x8290db74
	if !ctx.cr[6].eq {
	pc = 0x8290DB74; continue 'dispatch;
	}
	pc = 0x8290DB70; continue 'dispatch;
            }
            0x8290DB70 => {
    //   block [0x8290DB70..0x8290DB74)
	// 8290DB70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8290DB74; continue 'dispatch;
            }
            0x8290DB74 => {
    //   block [0x8290DB74..0x8290DBBC)
	// 8290DB74: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290DB78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290DB7C: 419A0130  beq cr6, 0x8290dcac
	if ctx.cr[6].eq {
	pc = 0x8290DCAC; continue 'dispatch;
	}
	// 8290DB80: 81440038  lwz r10, 0x38(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(56 as u32) ) } as u64;
	// 8290DB84: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8290DB88: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 8290DB8C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8290DB90: 419A00EC  beq cr6, 0x8290dc7c
	if ctx.cr[6].eq {
	pc = 0x8290DC7C; continue 'dispatch;
	}
	// 8290DB94: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 8290DB98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290DB9C: 419A0020  beq cr6, 0x8290dbbc
	if ctx.cr[6].eq {
	pc = 0x8290DBBC; continue 'dispatch;
	}
	// 8290DBA0: 894B00A3  lbz r10, 0xa3(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(163 as u32) ) } as u64;
	// 8290DBA4: 81640048  lwz r11, 0x48(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 8290DBA8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8290DBAC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8290DBB0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290DBB4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290DBB8: 480000C8  b 0x8290dc80
	pc = 0x8290DC80; continue 'dispatch;
            }
            0x8290DBBC => {
    //   block [0x8290DBBC..0x8290DBDC)
	// 8290DBBC: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 8290DBC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8290DBC4: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 8290DBC8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8290DBCC: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8290DBD0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8290DBD4: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290DBD8: 40810054  ble 0x8290dc2c
	if !ctx.cr[0].gt {
	pc = 0x8290DC2C; continue 'dispatch;
	}
	pc = 0x8290DBDC; continue 'dispatch;
            }
            0x8290DBDC => {
    //   block [0x8290DBDC..0x8290DBFC)
	// 8290DBDC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8290DBE0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8290DBE4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8290DBE8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290DBEC: 2F0700A3  cmpwi cr6, r7, 0xa3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 163, &mut ctx.xer);
	// 8290DBF0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8290DBF4: 41980008  blt cr6, 0x8290dbfc
	if ctx.cr[6].lt {
	pc = 0x8290DBFC; continue 'dispatch;
	}
	// 8290DBF8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x8290DBFC; continue 'dispatch;
            }
            0x8290DBFC => {
    //   block [0x8290DBFC..0x8290DC18)
	// 8290DBFC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8290DC00: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8290DC04: 419A0014  beq cr6, 0x8290dc18
	if ctx.cr[6].eq {
	pc = 0x8290DC18; continue 'dispatch;
	}
	// 8290DC08: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8290DC0C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8290DC10: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8290DC14: 4800000C  b 0x8290dc20
	pc = 0x8290DC20; continue 'dispatch;
            }
            0x8290DC18 => {
    //   block [0x8290DC18..0x8290DC20)
	// 8290DC18: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8290DC1C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8290DC20; continue 'dispatch;
            }
            0x8290DC20 => {
    //   block [0x8290DC20..0x8290DC2C)
	// 8290DC20: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290DC24: 4199FFB8  bgt cr6, 0x8290dbdc
	if ctx.cr[6].gt {
	pc = 0x8290DBDC; continue 'dispatch;
	}
	// 8290DC28: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8290DC2C; continue 'dispatch;
            }
            0x8290DC2C => {
    //   block [0x8290DC2C..0x8290DC48)
	// 8290DC2C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8290DC30: 419A003C  beq cr6, 0x8290dc6c
	if ctx.cr[6].eq {
	pc = 0x8290DC6C; continue 'dispatch;
	}
	// 8290DC34: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290DC38: 2F0B00A3  cmpwi cr6, r11, 0xa3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 163, &mut ctx.xer);
	// 8290DC3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290DC40: 41990008  bgt cr6, 0x8290dc48
	if ctx.cr[6].gt {
	pc = 0x8290DC48; continue 'dispatch;
	}
	// 8290DC44: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8290DC48; continue 'dispatch;
            }
            0x8290DC48 => {
    //   block [0x8290DC48..0x8290DC6C)
	// 8290DC48: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290DC4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290DC50: 409A001C  bne cr6, 0x8290dc6c
	if !ctx.cr[6].eq {
	pc = 0x8290DC6C; continue 'dispatch;
	}
	// 8290DC54: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8290DC58: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290DC5C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8290DC60: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8290DC64: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290DC68: 48000018  b 0x8290dc80
	pc = 0x8290DC80; continue 'dispatch;
            }
            0x8290DC6C => {
    //   block [0x8290DC6C..0x8290DC7C)
	// 8290DC6C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8290DC70: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290DC74: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290DC78: 48000008  b 0x8290dc80
	pc = 0x8290DC80; continue 'dispatch;
            }
            0x8290DC7C => {
    //   block [0x8290DC7C..0x8290DC80)
	// 8290DC7C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x8290DC80; continue 'dispatch;
            }
            0x8290DC80 => {
    //   block [0x8290DC80..0x8290DCAC)
	// 8290DC80: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8290DC84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290DC88: 419A0024  beq cr6, 0x8290dcac
	if ctx.cr[6].eq {
	pc = 0x8290DCAC; continue 'dispatch;
	}
	// 8290DC8C: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290DC90: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8290DC94: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8290DC98: 4E800421  bctrl
	ctx.lr = 0x8290DC9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290DC9C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8290DCA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8290DCA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290DCA8: 4E800020  blr
	return;
            }
            0x8290DCAC => {
    //   block [0x8290DCAC..0x8290DCC4)
	// 8290DCAC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8290DCB0: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8290DCB4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8290DCB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8290DCBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290DCC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290DCC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290DCC8 size=60
    let mut pc: u32 = 0x8290DCC8;
    'dispatch: loop {
        match pc {
            0x8290DCC8 => {
    //   block [0x8290DCC8..0x8290DD04)
	// 8290DCC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290DCCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8290DCD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8290DCD4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290DCD8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8290DCDC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8290DCE0: 388B9A54  addi r4, r11, -0x65ac
	ctx.r[4].s64 = ctx.r[11].s64 + -26028;
	// 8290DCE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290DCE8: 4B91F1E9  bl 0x8222ced0
	ctx.lr = 0x8290DCEC;
	sub_8222CED0(ctx, base);
	// 8290DCEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290DCF0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8290DCF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8290DCF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290DCFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8290DD00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290DD08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8290DD08 size=8
    let mut pc: u32 = 0x8290DD08;
    'dispatch: loop {
        match pc {
            0x8290DD08 => {
    //   block [0x8290DD08..0x8290DD10)
	// 8290DD08: 80630014  lwz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 8290DD0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290DD10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8290DD10 size=8
    let mut pc: u32 = 0x8290DD10;
    'dispatch: loop {
        match pc {
            0x8290DD10 => {
    //   block [0x8290DD10..0x8290DD18)
	// 8290DD10: 80630018  lwz r3, 0x18(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 8290DD14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290DD20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290DD20 size=96
    let mut pc: u32 = 0x8290DD20;
    'dispatch: loop {
        match pc {
            0x8290DD20 => {
    //   block [0x8290DD20..0x8290DD68)
	// 8290DD20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290DD24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8290DD28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8290DD2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8290DD30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290DD34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290DD38: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8290DD3C: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 8290DD40: 4B907099  bl 0x82214dd8
	ctx.lr = 0x8290DD44;
	sub_82214DD8(ctx, base);
	// 8290DD44: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 8290DD48: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 8290DD4C: 392B2850  addi r9, r11, 0x2850
	ctx.r[9].s64 = ctx.r[11].s64 + 10320;
	// 8290DD50: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290DD54: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8290DD58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290DD5C: 419A000C  beq cr6, 0x8290dd68
	if ctx.cr[6].eq {
	pc = 0x8290DD68; continue 'dispatch;
	}
	// 8290DD60: 4B90DFD9  bl 0x8221bd38
	ctx.lr = 0x8290DD64;
	sub_8221BD38(ctx, base);
	// 8290DD64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x8290DD68; continue 'dispatch;
            }
            0x8290DD68 => {
    //   block [0x8290DD68..0x8290DD80)
	// 8290DD68: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8290DD6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8290DD70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290DD74: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8290DD78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8290DD7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290DD80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290DD80 size=340
    let mut pc: u32 = 0x8290DD80;
    'dispatch: loop {
        match pc {
            0x8290DD80 => {
    //   block [0x8290DD80..0x8290DE10)
	// 8290DD80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290DD84: 4839B689  bl 0x82ca940c
	ctx.lr = 0x8290DD88;
	sub_82CA93D0(ctx, base);
	// 8290DD88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290DD8C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8290DD90: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 8290DD94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290DD98: 38EA5668  addi r7, r10, 0x5668
	ctx.r[7].s64 = ctx.r[10].s64 + 22120;
	// 8290DD9C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290DDA0: 80CB001C  lwz r6, 0x1c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 8290DDA4: 80AB0020  lwz r5, 0x20(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 8290DDA8: 90C10050  stw r6, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u32 ) };
	// 8290DDAC: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 8290DDB0: 4B8A4749  bl 0x821b24f8
	ctx.lr = 0x8290DDB4;
	sub_821B24F8(ctx, base);
	// 8290DDB4: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 8290DDB8: 4B99BC31  bl 0x822a99e8
	ctx.lr = 0x8290DDBC;
	sub_822A99E8(ctx, base);
	// 8290DDBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290DDC0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8290DDC4: 419A0108  beq cr6, 0x8290decc
	if ctx.cr[6].eq {
	pc = 0x8290DECC; continue 'dispatch;
	}
	// 8290DDC8: 3D60811C  lis r11, -0x7ee4
	ctx.r[11].s64 = -2128871424;
	// 8290DDCC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8290DDD0: 617D9DC5  ori r29, r11, 0x9dc5
	ctx.r[29].u64 = ctx.r[11].u64 | 40389;
	// 8290DDD4: 386A1358  addi r3, r10, 0x1358
	ctx.r[3].s64 = ctx.r[10].s64 + 4952;
	// 8290DDD8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8290DDDC: 4B8E5F7D  bl 0x821f3d58
	ctx.lr = 0x8290DDE0;
	sub_821F3D58(ctx, base);
	// 8290DDE0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8290DDE4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8290DDE8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8290DDEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290DDF0: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 8290DDF4: 480F2625  bl 0x82a00418
	ctx.lr = 0x8290DDF8;
	sub_82A00418(ctx, base);
	// 8290DDF8: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8290DDFC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8290DE00: 419A0010  beq cr6, 0x8290de10
	if ctx.cr[6].eq {
	pc = 0x8290DE10; continue 'dispatch;
	}
	// 8290DE04: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8290DE08: 7D6B59D6  mullw r11, r11, r11
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8290DE0C: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x8290DE10; continue 'dispatch;
            }
            0x8290DE10 => {
    //   block [0x8290DE10..0x8290DE48)
	// 8290DE10: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8290DE14: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8290DE18: 386B8360  addi r3, r11, -0x7ca0
	ctx.r[3].s64 = ctx.r[11].s64 + -31904;
	// 8290DE1C: 4B8E5F3D  bl 0x821f3d58
	ctx.lr = 0x8290DE20;
	sub_821F3D58(ctx, base);
	// 8290DE20: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8290DE24: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8290DE28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290DE2C: 480F25ED  bl 0x82a00418
	ctx.lr = 0x8290DE30;
	sub_82A00418(ctx, base);
	// 8290DE30: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8290DE34: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290DE38: 419A0010  beq cr6, 0x8290de48
	if ctx.cr[6].eq {
	pc = 0x8290DE48; continue 'dispatch;
	}
	// 8290DE3C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8290DE40: 7D6B59D6  mullw r11, r11, r11
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8290DE44: 917E0010  stw r11, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x8290DE48; continue 'dispatch;
            }
            0x8290DE48 => {
    //   block [0x8290DE48..0x8290DE7C)
	// 8290DE48: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8290DE4C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8290DE50: 386B5684  addi r3, r11, 0x5684
	ctx.r[3].s64 = ctx.r[11].s64 + 22148;
	// 8290DE54: 4B8E5F05  bl 0x821f3d58
	ctx.lr = 0x8290DE58;
	sub_821F3D58(ctx, base);
	// 8290DE58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8290DE5C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8290DE60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290DE64: 480F25B5  bl 0x82a00418
	ctx.lr = 0x8290DE68;
	sub_82A00418(ctx, base);
	// 8290DE68: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8290DE6C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290DE70: 419A000C  beq cr6, 0x8290de7c
	if ctx.cr[6].eq {
	pc = 0x8290DE7C; continue 'dispatch;
	}
	// 8290DE74: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8290DE78: 917E0014  stw r11, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	pc = 0x8290DE7C; continue 'dispatch;
            }
            0x8290DE7C => {
    //   block [0x8290DE7C..0x8290DEB0)
	// 8290DE7C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8290DE80: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8290DE84: 386B569C  addi r3, r11, 0x569c
	ctx.r[3].s64 = ctx.r[11].s64 + 22172;
	// 8290DE88: 4B8E5ED1  bl 0x821f3d58
	ctx.lr = 0x8290DE8C;
	sub_821F3D58(ctx, base);
	// 8290DE8C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8290DE90: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8290DE94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290DE98: 480F2581  bl 0x82a00418
	ctx.lr = 0x8290DE9C;
	sub_82A00418(ctx, base);
	// 8290DE9C: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8290DEA0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290DEA4: 419A000C  beq cr6, 0x8290deb0
	if ctx.cr[6].eq {
	pc = 0x8290DEB0; continue 'dispatch;
	}
	// 8290DEA8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8290DEAC: 917E0018  stw r11, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	pc = 0x8290DEB0; continue 'dispatch;
            }
            0x8290DEB0 => {
    //   block [0x8290DEB0..0x8290DECC)
	// 8290DEB0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8290DEB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290DEB8: 388B2EB4  addi r4, r11, 0x2eb4
	ctx.r[4].s64 = ctx.r[11].s64 + 11956;
	// 8290DEBC: 4BA15685  bl 0x82323540
	ctx.lr = 0x8290DEC0;
	sub_82323540(ctx, base);
	// 8290DEC0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8290DEC4: 387E001C  addi r3, r30, 0x1c
	ctx.r[3].s64 = ctx.r[30].s64 + 28;
	// 8290DEC8: 4B967571  bl 0x82275438
	ctx.lr = 0x8290DECC;
	sub_82275438(ctx, base);
	pc = 0x8290DECC; continue 'dispatch;
            }
            0x8290DECC => {
    //   block [0x8290DECC..0x8290DED4)
	// 8290DECC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8290DED0: 4839B58C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290DED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290DED8 size=640
    let mut pc: u32 = 0x8290DED8;
    'dispatch: loop {
        match pc {
            0x8290DED8 => {
    //   block [0x8290DED8..0x8290E158)
	// 8290DED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290DEDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8290DEE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8290DEE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8290DEE8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8290DEEC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290DEF0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8290DEF4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8290DEF8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8290DEFC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8290DF00: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290DF04: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 8290DF08: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290DF0C: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 8290DF10: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8290DF14: 4E800421  bctrl
	ctx.lr = 0x8290DF18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290DF18: 809F007C  lwz r4, 0x7c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 8290DF1C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8290DF20: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290DF24: 80E80040  lwz r7, 0x40(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(64 as u32) ) } as u64;
	// 8290DF28: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 8290DF2C: 4E800421  bctrl
	ctx.lr = 0x8290DF30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290DF30: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 8290DF34: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 8290DF38: 807E000C  lwz r3, 0xc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 8290DF3C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8290DF40: 7C6B07B4  extsw r11, r3
	ctx.r[11].s64 = ctx.r[3].s32 as i64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290E158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290E158 size=396
    let mut pc: u32 = 0x8290E158;
    'dispatch: loop {
        match pc {
            0x8290E158 => {
    //   block [0x8290E158..0x8290E2E4)
	// 8290E158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290E15C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8290E160: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8290E164: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8290E168: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290E16C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8290E170: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290E174: 3BCB56B4  addi r30, r11, 0x56b4
	ctx.r[30].s64 = ctx.r[11].s64 + 22196;
	// 8290E178: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8290E17C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290E180: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8290E184: 4B91ED4D  bl 0x8222ced0
	ctx.lr = 0x8290E188;
	sub_8222CED0(ctx, base);
	// 8290E188: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290E18C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8290E190: 48000159  bl 0x8290e2e8
	ctx.lr = 0x8290E194;
	sub_8290E2E8(ctx, base);
	// 8290E194: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290E198: 4B906C41  bl 0x82214dd8
	ctx.lr = 0x8290E19C;
	sub_82214DD8(ctx, base);
	// 8290E19C: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 8290E1A0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8290E1A4: 388A56C4  addi r4, r10, 0x56c4
	ctx.r[4].s64 = ctx.r[10].s64 + 22212;
	// 8290E1A8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8290E1AC: 4B91ED25  bl 0x8222ced0
	ctx.lr = 0x8290E1B0;
	sub_8222CED0(ctx, base);
	// 8290E1B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8290E1B4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8290E1B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290E1BC: 4B91ED15  bl 0x8222ced0
	ctx.lr = 0x8290E1C0;
	sub_8222CED0(ctx, base);
	// 8290E1C0: 3D208291  lis r9, -0x7d6f
	ctx.r[9].s64 = -2104426496;
	// 8290E1C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290E1C8: 38C9DD08  addi r6, r9, -0x22f8
	ctx.r[6].s64 = ctx.r[9].s64 + -8952;
	// 8290E1CC: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 8290E1D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8290E1D4: 4800035D  bl 0x8290e530
	ctx.lr = 0x8290E1D8;
	sub_8290E530(ctx, base);
	// 8290E1D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290E1DC: 4B906BFD  bl 0x82214dd8
	ctx.lr = 0x8290E1E0;
	sub_82214DD8(ctx, base);
	// 8290E1E0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8290E1E4: 4B906BF5  bl 0x82214dd8
	ctx.lr = 0x8290E1E8;
	sub_82214DD8(ctx, base);
	// 8290E1E8: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 8290E1EC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8290E1F0: 388856DC  addi r4, r8, 0x56dc
	ctx.r[4].s64 = ctx.r[8].s64 + 22236;
	// 8290E1F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290E1F8: 4B91ECD9  bl 0x8222ced0
	ctx.lr = 0x8290E1FC;
	sub_8222CED0(ctx, base);
	// 8290E1FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8290E200: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8290E204: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8290E208: 4B91ECC9  bl 0x8222ced0
	ctx.lr = 0x8290E20C;
	sub_8222CED0(ctx, base);
	// 8290E20C: 3CE08291  lis r7, -0x7d6f
	ctx.r[7].s64 = -2104426496;
	// 8290E210: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290E214: 38C7DD10  addi r6, r7, -0x22f0
	ctx.r[6].s64 = ctx.r[7].s64 + -8944;
	// 8290E218: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8290E21C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8290E220: 48000311  bl 0x8290e530
	ctx.lr = 0x8290E224;
	sub_8290E530(ctx, base);
	// 8290E224: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8290E228: 4B906BB1  bl 0x82214dd8
	ctx.lr = 0x8290E22C;
	sub_82214DD8(ctx, base);
	// 8290E22C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290E230: 4B906BA9  bl 0x82214dd8
	ctx.lr = 0x8290E234;
	sub_82214DD8(ctx, base);
	// 8290E234: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 8290E238: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8290E23C: 388656F8  addi r4, r6, 0x56f8
	ctx.r[4].s64 = ctx.r[6].s64 + 22264;
	// 8290E240: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290E244: 4B91EC8D  bl 0x8222ced0
	ctx.lr = 0x8290E248;
	sub_8222CED0(ctx, base);
	// 8290E248: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8290E24C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8290E250: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8290E254: 4B91EC7D  bl 0x8222ced0
	ctx.lr = 0x8290E258;
	sub_8222CED0(ctx, base);
	// 8290E258: 3C808291  lis r4, -0x7d6f
	ctx.r[4].s64 = -2104426496;
	// 8290E25C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8290E260: 38C4DED8  addi r6, r4, -0x2128
	ctx.r[6].s64 = ctx.r[4].s64 + -8488;
	// 8290E264: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8290E268: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290E26C: 480004C5  bl 0x8290e730
	ctx.lr = 0x8290E270;
	sub_8290E730(ctx, base);
	// 8290E270: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8290E274: 4B906B65  bl 0x82214dd8
	ctx.lr = 0x8290E278;
	sub_82214DD8(ctx, base);
	// 8290E278: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290E27C: 4B906B5D  bl 0x82214dd8
	ctx.lr = 0x8290E280;
	sub_82214DD8(ctx, base);
	// 8290E280: 3C60820E  lis r3, -0x7df2
	ctx.r[3].s64 = -2113011712;
	// 8290E284: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8290E288: 38835710  addi r4, r3, 0x5710
	ctx.r[4].s64 = ctx.r[3].s64 + 22288;
	// 8290E28C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290E290: 4B91EC41  bl 0x8222ced0
	ctx.lr = 0x8290E294;
	sub_8222CED0(ctx, base);
	// 8290E294: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8290E298: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8290E29C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8290E2A0: 4B91EC31  bl 0x8222ced0
	ctx.lr = 0x8290E2A4;
	sub_8222CED0(ctx, base);
	// 8290E2A4: 3D608291  lis r11, -0x7d6f
	ctx.r[11].s64 = -2104426496;
	// 8290E2A8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8290E2AC: 38CBDD18  addi r6, r11, -0x22e8
	ctx.r[6].s64 = ctx.r[11].s64 + -8936;
	// 8290E2B0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8290E2B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290E2B8: 48000681  bl 0x8290e938
	ctx.lr = 0x8290E2BC;
	sub_8290E938(ctx, base);
	// 8290E2BC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8290E2C0: 4B906B19  bl 0x82214dd8
	ctx.lr = 0x8290E2C4;
	sub_82214DD8(ctx, base);
	// 8290E2C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290E2C8: 4B906B11  bl 0x82214dd8
	ctx.lr = 0x8290E2CC;
	sub_82214DD8(ctx, base);
	// 8290E2CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8290E2D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8290E2D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290E2D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8290E2DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8290E2E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290E2E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290E2E8 size=584
    let mut pc: u32 = 0x8290E2E8;
    'dispatch: loop {
        match pc {
            0x8290E2E8 => {
    //   block [0x8290E2E8..0x8290E310)
	// 8290E2E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290E2EC: 4839B115  bl 0x82ca9400
	ctx.lr = 0x8290E2F0;
	sub_82CA93D0(ctx, base);
	// 8290E2F0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290E2F4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290E2F8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8290E2FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290E300: 409A0010  bne cr6, 0x8290e310
	if !ctx.cr[6].eq {
	pc = 0x8290E310; continue 'dispatch;
	}
	// 8290E304: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8290E308: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 8290E30C: 48000008  b 0x8290e314
	pc = 0x8290E314; continue 'dispatch;
            }
            0x8290E310 => {
    //   block [0x8290E310..0x8290E314)
	// 8290E310: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8290E314; continue 'dispatch;
            }
            0x8290E314 => {
    //   block [0x8290E314..0x8290E38C)
	// 8290E314: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290E318: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8290E31C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290E320: 4BAC02A1  bl 0x823ce5c0
	ctx.lr = 0x8290E324;
	sub_823CE5C0(ctx, base);
	// 8290E324: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8290E328: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290E32C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290E330: 4BABFED1  bl 0x823ce200
	ctx.lr = 0x8290E334;
	sub_823CE200(ctx, base);
	// 8290E334: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8290E338: 4B8A97E1  bl 0x821b7b18
	ctx.lr = 0x8290E33C;
	sub_821B7B18(ctx, base);
	// 8290E33C: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 8290E340: 4B910F19  bl 0x8221f258
	ctx.lr = 0x8290E344;
	sub_8221F258(ctx, base);
	// 8290E344: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8290E348: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8290E34C: 419A0040  beq cr6, 0x8290e38c
	if ctx.cr[6].eq {
	pc = 0x8290E38C; continue 'dispatch;
	}
	// 8290E350: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 8290E354: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8290E358: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 8290E35C: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8290E360: 4B910EF9  bl 0x8221f258
	ctx.lr = 0x8290E364;
	sub_8221F258(ctx, base);
	// 8290E364: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8290E368: 419A0028  beq cr6, 0x8290e390
	if ctx.cr[6].eq {
	pc = 0x8290E390; continue 'dispatch;
	}
	// 8290E36C: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 8290E370: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 8290E374: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290E378: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 8290E37C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8290E380: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8290E384: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8290E388: 4800000C  b 0x8290e394
	pc = 0x8290E394; continue 'dispatch;
            }
            0x8290E38C => {
    //   block [0x8290E38C..0x8290E390)
	// 8290E38C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x8290E390; continue 'dispatch;
            }
            0x8290E390 => {
    //   block [0x8290E390..0x8290E394)
	// 8290E390: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x8290E394; continue 'dispatch;
            }
            0x8290E394 => {
    //   block [0x8290E394..0x8290E498)
	// 8290E394: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8290E398: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8290E39C: 419A00FC  beq cr6, 0x8290e498
	if ctx.cr[6].eq {
	pc = 0x8290E498; continue 'dispatch;
	}
	// 8290E3A0: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290E3A4: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 8290E3A8: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290E3AC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8290E3B0: 4B91AD59  bl 0x82229108
	ctx.lr = 0x8290E3B4;
	sub_82229108(ctx, base);
	// 8290E3B4: 3D608291  lis r11, -0x7d6f
	ctx.r[11].s64 = -2104426496;
	// 8290E3B8: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8290E3BC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8290E3C0: 3BCBEB40  addi r30, r11, -0x14c0
	ctx.r[30].s64 = ctx.r[11].s64 + -5312;
	// 8290E3C4: 4B9194BD  bl 0x82227880
	ctx.lr = 0x8290E3C8;
	sub_82227880(ctx, base);
	// 8290E3C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8290E3CC: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 8290E3D0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8290E3D4: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 8290E3D8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8290E3DC: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 8290E3E0: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 8290E3E4: 4B88C69D  bl 0x8219aa80
	ctx.lr = 0x8290E3E8;
	sub_8219AA80(ctx, base);
	// 8290E3E8: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 8290E3EC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8290E3F0: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 8290E3F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290E3F8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8290E3FC: 4BAC0025  bl 0x823ce420
	ctx.lr = 0x8290E400;
	sub_823CE420(ctx, base);
	// 8290E400: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8290E404: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 8290E408: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8290E40C: 481162BD  bl 0x82a246c8
	ctx.lr = 0x8290E410;
	sub_82A246C8(ctx, base);
	// 8290E410: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290E414: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 8290E418: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 8290E41C: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 8290E420: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290E424: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290E428: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8290E42C: 4B91ACDD  bl 0x82229108
	ctx.lr = 0x8290E430;
	sub_82229108(ctx, base);
	// 8290E430: 3D608232  lis r11, -0x7dce
	ctx.r[11].s64 = -2110652416;
	// 8290E434: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8290E438: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8290E43C: 3BEB6D08  addi r31, r11, 0x6d08
	ctx.r[31].s64 = ctx.r[11].s64 + 27912;
	// 8290E440: 4B919441  bl 0x82227880
	ctx.lr = 0x8290E444;
	sub_82227880(ctx, base);
	// 8290E444: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 8290E448: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 8290E44C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8290E450: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 8290E454: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8290E458: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 8290E45C: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 8290E460: 4B88C621  bl 0x8219aa80
	ctx.lr = 0x8290E464;
	sub_8219AA80(ctx, base);
	// 8290E464: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 8290E468: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8290E46C: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 8290E470: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290E474: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290E478: 4BABFFA9  bl 0x823ce420
	ctx.lr = 0x8290E47C;
	sub_823CE420(ctx, base);
	// 8290E47C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290E480: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 8290E484: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8290E488: 48116241  bl 0x82a246c8
	ctx.lr = 0x8290E48C;
	sub_82A246C8(ctx, base);
	// 8290E48C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290E490: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 8290E494: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	pc = 0x8290E498; continue 'dispatch;
            }
            0x8290E498 => {
    //   block [0x8290E498..0x8290E4A8)
	// 8290E498: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 8290E49C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8290E4A0: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 8290E4A4: 419A0020  beq cr6, 0x8290e4c4
	if ctx.cr[6].eq {
	pc = 0x8290E4C4; continue 'dispatch;
	}
	pc = 0x8290E4A8; continue 'dispatch;
            }
            0x8290E4A8 => {
    //   block [0x8290E4A8..0x8290E4C4)
	// 8290E4A8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8290E4AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290E4B0: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8290E4B4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8290E4B8: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8290E4BC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290E4C0: 4082FFE8  bne 0x8290e4a8
	if !ctx.cr[0].eq {
	pc = 0x8290E4A8; continue 'dispatch;
	}
	pc = 0x8290E4C4; continue 'dispatch;
            }
            0x8290E4C4 => {
    //   block [0x8290E4C4..0x8290E4E4)
	// 8290E4C4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290E4C8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8290E4CC: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 8290E4D0: 4B9E7479  bl 0x822f5948
	ctx.lr = 0x8290E4D4;
	sub_822F5948(ctx, base);
	// 8290E4D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8290E4D8: 4B8A9641  bl 0x821b7b18
	ctx.lr = 0x8290E4DC;
	sub_821B7B18(ctx, base);
	// 8290E4DC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8290E4E0: 419A0040  beq cr6, 0x8290e520
	if ctx.cr[6].eq {
	pc = 0x8290E520; continue 'dispatch;
	}
	pc = 0x8290E4E4; continue 'dispatch;
            }
            0x8290E4E4 => {
    //   block [0x8290E4E4..0x8290E520)
	// 8290E4E4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8290E4E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290E4EC: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8290E4F0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8290E4F4: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8290E4F8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290E4FC: 4082FFE8  bne 0x8290e4e4
	if !ctx.cr[0].eq {
	pc = 0x8290E4E4; continue 'dispatch;
	}
	// 8290E500: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290E504: 409A001C  bne cr6, 0x8290e520
	if !ctx.cr[6].eq {
	pc = 0x8290E520; continue 'dispatch;
	}
	// 8290E508: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290E50C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290E510: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8290E514: 4E800421  bctrl
	ctx.lr = 0x8290E518;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290E518: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8290E51C: 4B90D81D  bl 0x8221bd38
	ctx.lr = 0x8290E520;
	sub_8221BD38(ctx, base);
            }
            0x8290E520 => {
    //   block [0x8290E520..0x8290E530)
	// 8290E520: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290E524: 4B8A95F5  bl 0x821b7b18
	ctx.lr = 0x8290E528;
	sub_821B7B18(ctx, base);
	// 8290E528: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8290E52C: 4839AF24  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290E530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290E530 size=512
    let mut pc: u32 = 0x8290E530;
    'dispatch: loop {
        match pc {
            0x8290E530 => {
    //   block [0x8290E530..0x8290E568)
	// 8290E530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290E534: 4839AEC9  bl 0x82ca93fc
	ctx.lr = 0x8290E538;
	sub_82CA93D0(ctx, base);
	// 8290E538: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290E53C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8290E540: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8290E544: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 8290E548: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 8290E54C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 8290E550: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290E554: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 8290E558: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 8290E55C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290E560: 419A0008  beq cr6, 0x8290e568
	if ctx.cr[6].eq {
	pc = 0x8290E568; continue 'dispatch;
	}
	// 8290E564: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8290E568; continue 'dispatch;
            }
            0x8290E568 => {
    //   block [0x8290E568..0x8290E5FC)
	// 8290E568: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290E56C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8290E570: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290E574: 4BAC004D  bl 0x823ce5c0
	ctx.lr = 0x8290E578;
	sub_823CE5C0(ctx, base);
	// 8290E578: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8290E57C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8290E580: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290E584: 4BABFB8D  bl 0x823ce110
	ctx.lr = 0x8290E588;
	sub_823CE110(ctx, base);
	// 8290E588: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8290E58C: 4B8A958D  bl 0x821b7b18
	ctx.lr = 0x8290E590;
	sub_821B7B18(ctx, base);
	// 8290E590: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8290E594: 4B910CC5  bl 0x8221f258
	ctx.lr = 0x8290E598;
	sub_8221F258(ctx, base);
	// 8290E598: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290E59C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8290E5A0: 419A005C  beq cr6, 0x8290e5fc
	if ctx.cr[6].eq {
	pc = 0x8290E5FC; continue 'dispatch;
	}
	// 8290E5A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8290E5A8: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 8290E5AC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8290E5B0: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 8290E5B4: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8290E5B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8290E5BC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8290E5C0: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 8290E5C4: 4B8E1C7D  bl 0x821f0240
	ctx.lr = 0x8290E5C8;
	sub_821F0240(ctx, base);
	// 8290E5C8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8290E5CC: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 8290E5D0: 4B910C89  bl 0x8221f258
	ctx.lr = 0x8290E5D4;
	sub_8221F258(ctx, base);
	// 8290E5D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8290E5D8: 419A0028  beq cr6, 0x8290e600
	if ctx.cr[6].eq {
	pc = 0x8290E600; continue 'dispatch;
	}
	// 8290E5DC: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 8290E5E0: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 8290E5E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290E5E8: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 8290E5EC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8290E5F0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8290E5F4: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8290E5F8: 4800000C  b 0x8290e604
	pc = 0x8290E604; continue 'dispatch;
            }
            0x8290E5FC => {
    //   block [0x8290E5FC..0x8290E600)
	// 8290E5FC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x8290E600; continue 'dispatch;
            }
            0x8290E600 => {
    //   block [0x8290E600..0x8290E604)
	// 8290E600: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x8290E604; continue 'dispatch;
            }
            0x8290E604 => {
    //   block [0x8290E604..0x8290E618)
	// 8290E604: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290E608: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 8290E60C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290E610: 419A0008  beq cr6, 0x8290e618
	if ctx.cr[6].eq {
	pc = 0x8290E618; continue 'dispatch;
	}
	// 8290E614: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8290E618; continue 'dispatch;
            }
            0x8290E618 => {
    //   block [0x8290E618..0x8290E698)
	// 8290E618: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8290E61C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290E620: 419A0078  beq cr6, 0x8290e698
	if ctx.cr[6].eq {
	pc = 0x8290E698; continue 'dispatch;
	}
	// 8290E624: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290E628: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 8290E62C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290E630: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8290E634: 4B91AAD5  bl 0x82229108
	ctx.lr = 0x8290E638;
	sub_82229108(ctx, base);
	// 8290E638: 3D608291  lis r11, -0x7d6f
	ctx.r[11].s64 = -2104426496;
	// 8290E63C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8290E640: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8290E644: 3BCBEB80  addi r30, r11, -0x1480
	ctx.r[30].s64 = ctx.r[11].s64 + -5248;
	// 8290E648: 4B919239  bl 0x82227880
	ctx.lr = 0x8290E64C;
	sub_82227880(ctx, base);
	// 8290E64C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8290E650: 3D408295  lis r10, -0x7d6b
	ctx.r[10].s64 = -2104164352;
	// 8290E654: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8290E658: 388AC430  addi r4, r10, -0x3bd0
	ctx.r[4].s64 = ctx.r[10].s64 + -15312;
	// 8290E65C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8290E660: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 8290E664: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 8290E668: 4B88C419  bl 0x8219aa80
	ctx.lr = 0x8290E66C;
	sub_8219AA80(ctx, base);
	// 8290E66C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290E670: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8290E674: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8290E678: 4BABFDA9  bl 0x823ce420
	ctx.lr = 0x8290E67C;
	sub_823CE420(ctx, base);
	// 8290E67C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290E680: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 8290E684: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8290E688: 48116041  bl 0x82a246c8
	ctx.lr = 0x8290E68C;
	sub_82A246C8(ctx, base);
	// 8290E68C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290E690: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 8290E694: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x8290E698; continue 'dispatch;
            }
            0x8290E698 => {
    //   block [0x8290E698..0x8290E6A8)
	// 8290E698: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8290E69C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8290E6A0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 8290E6A4: 419A0020  beq cr6, 0x8290e6c4
	if ctx.cr[6].eq {
	pc = 0x8290E6C4; continue 'dispatch;
	}
	pc = 0x8290E6A8; continue 'dispatch;
            }
            0x8290E6A8 => {
    //   block [0x8290E6A8..0x8290E6C4)
	// 8290E6A8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8290E6AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290E6B0: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8290E6B4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8290E6B8: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8290E6BC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290E6C0: 4082FFE8  bne 0x8290e6a8
	if !ctx.cr[0].eq {
	pc = 0x8290E6A8; continue 'dispatch;
	}
	pc = 0x8290E6C4; continue 'dispatch;
            }
            0x8290E6C4 => {
    //   block [0x8290E6C4..0x8290E6E4)
	// 8290E6C4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290E6C8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8290E6CC: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 8290E6D0: 4B9E7279  bl 0x822f5948
	ctx.lr = 0x8290E6D4;
	sub_822F5948(ctx, base);
	// 8290E6D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290E6D8: 4B8A9441  bl 0x821b7b18
	ctx.lr = 0x8290E6DC;
	sub_821B7B18(ctx, base);
	// 8290E6DC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8290E6E0: 419A0040  beq cr6, 0x8290e720
	if ctx.cr[6].eq {
	pc = 0x8290E720; continue 'dispatch;
	}
	pc = 0x8290E6E4; continue 'dispatch;
            }
            0x8290E6E4 => {
    //   block [0x8290E6E4..0x8290E720)
	// 8290E6E4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8290E6E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290E6EC: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8290E6F0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8290E6F4: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8290E6F8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290E6FC: 4082FFE8  bne 0x8290e6e4
	if !ctx.cr[0].eq {
	pc = 0x8290E6E4; continue 'dispatch;
	}
	// 8290E700: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290E704: 409A001C  bne cr6, 0x8290e720
	if !ctx.cr[6].eq {
	pc = 0x8290E720; continue 'dispatch;
	}
	// 8290E708: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290E70C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290E710: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8290E714: 4E800421  bctrl
	ctx.lr = 0x8290E718;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290E718: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8290E71C: 4B90D61D  bl 0x8221bd38
	ctx.lr = 0x8290E720;
	sub_8221BD38(ctx, base);
            }
            0x8290E720 => {
    //   block [0x8290E720..0x8290E730)
	// 8290E720: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8290E724: 4B8A93F5  bl 0x821b7b18
	ctx.lr = 0x8290E728;
	sub_821B7B18(ctx, base);
	// 8290E728: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8290E72C: 4839AD20  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290E730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290E730 size=516
    let mut pc: u32 = 0x8290E730;
    'dispatch: loop {
        match pc {
            0x8290E730 => {
    //   block [0x8290E730..0x8290E76C)
	// 8290E730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290E734: 4839ACC9  bl 0x82ca93fc
	ctx.lr = 0x8290E738;
	sub_82CA93D0(ctx, base);
	// 8290E738: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290E73C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8290E740: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 8290E744: 3D408291  lis r10, -0x7d6f
	ctx.r[10].s64 = -2104426496;
	// 8290E748: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 8290E74C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 8290E750: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290E754: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 8290E758: 3BAADED8  addi r29, r10, -0x2128
	ctx.r[29].s64 = ctx.r[10].s64 + -8488;
	// 8290E75C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290E760: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 8290E764: 419A0008  beq cr6, 0x8290e76c
	if ctx.cr[6].eq {
	pc = 0x8290E76C; continue 'dispatch;
	}
	// 8290E768: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8290E76C; continue 'dispatch;
            }
            0x8290E76C => {
    //   block [0x8290E76C..0x8290E800)
	// 8290E76C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290E770: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8290E774: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290E778: 4BABFE49  bl 0x823ce5c0
	ctx.lr = 0x8290E77C;
	sub_823CE5C0(ctx, base);
	// 8290E77C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8290E780: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8290E784: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290E788: 4BABF989  bl 0x823ce110
	ctx.lr = 0x8290E78C;
	sub_823CE110(ctx, base);
	// 8290E78C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8290E790: 4B8A9389  bl 0x821b7b18
	ctx.lr = 0x8290E794;
	sub_821B7B18(ctx, base);
	// 8290E794: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8290E798: 4B910AC1  bl 0x8221f258
	ctx.lr = 0x8290E79C;
	sub_8221F258(ctx, base);
	// 8290E79C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290E7A0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8290E7A4: 419A005C  beq cr6, 0x8290e800
	if ctx.cr[6].eq {
	pc = 0x8290E800; continue 'dispatch;
	}
	// 8290E7A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8290E7AC: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 8290E7B0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8290E7B4: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 8290E7B8: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8290E7BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8290E7C0: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8290E7C4: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 8290E7C8: 4B8E1A79  bl 0x821f0240
	ctx.lr = 0x8290E7CC;
	sub_821F0240(ctx, base);
	// 8290E7CC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8290E7D0: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 8290E7D4: 4B910A85  bl 0x8221f258
	ctx.lr = 0x8290E7D8;
	sub_8221F258(ctx, base);
	// 8290E7D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8290E7DC: 419A0028  beq cr6, 0x8290e804
	if ctx.cr[6].eq {
	pc = 0x8290E804; continue 'dispatch;
	}
	// 8290E7E0: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 8290E7E4: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 8290E7E8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290E7EC: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 8290E7F0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8290E7F4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8290E7F8: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8290E7FC: 4800000C  b 0x8290e808
	pc = 0x8290E808; continue 'dispatch;
            }
            0x8290E800 => {
    //   block [0x8290E800..0x8290E804)
	// 8290E800: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x8290E804; continue 'dispatch;
            }
            0x8290E804 => {
    //   block [0x8290E804..0x8290E808)
	// 8290E804: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x8290E808; continue 'dispatch;
            }
            0x8290E808 => {
    //   block [0x8290E808..0x8290E81C)
	// 8290E808: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290E80C: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 8290E810: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290E814: 419A0008  beq cr6, 0x8290e81c
	if ctx.cr[6].eq {
	pc = 0x8290E81C; continue 'dispatch;
	}
	// 8290E818: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8290E81C; continue 'dispatch;
            }
            0x8290E81C => {
    //   block [0x8290E81C..0x8290E89C)
	// 8290E81C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8290E820: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290E824: 419A0078  beq cr6, 0x8290e89c
	if ctx.cr[6].eq {
	pc = 0x8290E89C; continue 'dispatch;
	}
	// 8290E828: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290E82C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 8290E830: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290E834: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8290E838: 4B91A8D1  bl 0x82229108
	ctx.lr = 0x8290E83C;
	sub_82229108(ctx, base);
	// 8290E83C: 3D608291  lis r11, -0x7d6f
	ctx.r[11].s64 = -2104426496;
	// 8290E840: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8290E844: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8290E848: 3BCBECF8  addi r30, r11, -0x1308
	ctx.r[30].s64 = ctx.r[11].s64 + -4872;
	// 8290E84C: 4B919035  bl 0x82227880
	ctx.lr = 0x8290E850;
	sub_82227880(ctx, base);
	// 8290E850: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8290E854: 3D408278  lis r10, -0x7d88
	ctx.r[10].s64 = -2106064896;
	// 8290E858: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8290E85C: 388A3010  addi r4, r10, 0x3010
	ctx.r[4].s64 = ctx.r[10].s64 + 12304;
	// 8290E860: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8290E864: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 8290E868: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 8290E86C: 4B88C215  bl 0x8219aa80
	ctx.lr = 0x8290E870;
	sub_8219AA80(ctx, base);
	// 8290E870: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290E874: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8290E878: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8290E87C: 4BABFBA5  bl 0x823ce420
	ctx.lr = 0x8290E880;
	sub_823CE420(ctx, base);
	// 8290E880: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290E884: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 8290E888: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8290E88C: 48115E3D  bl 0x82a246c8
	ctx.lr = 0x8290E890;
	sub_82A246C8(ctx, base);
	// 8290E890: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290E894: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 8290E898: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x8290E89C; continue 'dispatch;
            }
            0x8290E89C => {
    //   block [0x8290E89C..0x8290E8AC)
	// 8290E89C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8290E8A0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8290E8A4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 8290E8A8: 419A0020  beq cr6, 0x8290e8c8
	if ctx.cr[6].eq {
	pc = 0x8290E8C8; continue 'dispatch;
	}
	pc = 0x8290E8AC; continue 'dispatch;
            }
            0x8290E8AC => {
    //   block [0x8290E8AC..0x8290E8C8)
	// 8290E8AC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8290E8B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290E8B4: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8290E8B8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8290E8BC: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8290E8C0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290E8C4: 4082FFE8  bne 0x8290e8ac
	if !ctx.cr[0].eq {
	pc = 0x8290E8AC; continue 'dispatch;
	}
	pc = 0x8290E8C8; continue 'dispatch;
            }
            0x8290E8C8 => {
    //   block [0x8290E8C8..0x8290E8E8)
	// 8290E8C8: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290E8CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8290E8D0: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 8290E8D4: 4B9E7075  bl 0x822f5948
	ctx.lr = 0x8290E8D8;
	sub_822F5948(ctx, base);
	// 8290E8D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290E8DC: 4B8A923D  bl 0x821b7b18
	ctx.lr = 0x8290E8E0;
	sub_821B7B18(ctx, base);
	// 8290E8E0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8290E8E4: 419A0040  beq cr6, 0x8290e924
	if ctx.cr[6].eq {
	pc = 0x8290E924; continue 'dispatch;
	}
	pc = 0x8290E8E8; continue 'dispatch;
            }
            0x8290E8E8 => {
    //   block [0x8290E8E8..0x8290E924)
	// 8290E8E8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8290E8EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290E8F0: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8290E8F4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8290E8F8: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8290E8FC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290E900: 4082FFE8  bne 0x8290e8e8
	if !ctx.cr[0].eq {
	pc = 0x8290E8E8; continue 'dispatch;
	}
	// 8290E904: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290E908: 409A001C  bne cr6, 0x8290e924
	if !ctx.cr[6].eq {
	pc = 0x8290E924; continue 'dispatch;
	}
	// 8290E90C: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290E910: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290E914: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8290E918: 4E800421  bctrl
	ctx.lr = 0x8290E91C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290E91C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8290E920: 4B90D419  bl 0x8221bd38
	ctx.lr = 0x8290E924;
	sub_8221BD38(ctx, base);
            }
            0x8290E924 => {
    //   block [0x8290E924..0x8290E934)
	// 8290E924: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8290E928: 4B8A91F1  bl 0x821b7b18
	ctx.lr = 0x8290E92C;
	sub_821B7B18(ctx, base);
	// 8290E92C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8290E930: 4839AB1C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290E938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290E938 size=516
    let mut pc: u32 = 0x8290E938;
    'dispatch: loop {
        match pc {
            0x8290E938 => {
    //   block [0x8290E938..0x8290E974)
	// 8290E938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290E93C: 4839AAC1  bl 0x82ca93fc
	ctx.lr = 0x8290E940;
	sub_82CA93D0(ctx, base);
	// 8290E940: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290E944: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8290E948: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 8290E94C: 3D408291  lis r10, -0x7d6f
	ctx.r[10].s64 = -2104426496;
	// 8290E950: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 8290E954: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 8290E958: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290E95C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 8290E960: 3BAADD18  addi r29, r10, -0x22e8
	ctx.r[29].s64 = ctx.r[10].s64 + -8936;
	// 8290E964: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290E968: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 8290E96C: 419A0008  beq cr6, 0x8290e974
	if ctx.cr[6].eq {
	pc = 0x8290E974; continue 'dispatch;
	}
	// 8290E970: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8290E974; continue 'dispatch;
            }
            0x8290E974 => {
    //   block [0x8290E974..0x8290EA08)
	// 8290E974: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290E978: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8290E97C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290E980: 4BABFC41  bl 0x823ce5c0
	ctx.lr = 0x8290E984;
	sub_823CE5C0(ctx, base);
	// 8290E984: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8290E988: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8290E98C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290E990: 4BABF781  bl 0x823ce110
	ctx.lr = 0x8290E994;
	sub_823CE110(ctx, base);
	// 8290E994: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8290E998: 4B8A9181  bl 0x821b7b18
	ctx.lr = 0x8290E99C;
	sub_821B7B18(ctx, base);
	// 8290E99C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8290E9A0: 4B9108B9  bl 0x8221f258
	ctx.lr = 0x8290E9A4;
	sub_8221F258(ctx, base);
	// 8290E9A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290E9A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8290E9AC: 419A005C  beq cr6, 0x8290ea08
	if ctx.cr[6].eq {
	pc = 0x8290EA08; continue 'dispatch;
	}
	// 8290E9B0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8290E9B4: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 8290E9B8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8290E9BC: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 8290E9C0: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8290E9C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8290E9C8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8290E9CC: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 8290E9D0: 4B8E1871  bl 0x821f0240
	ctx.lr = 0x8290E9D4;
	sub_821F0240(ctx, base);
	// 8290E9D4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8290E9D8: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 8290E9DC: 4B91087D  bl 0x8221f258
	ctx.lr = 0x8290E9E0;
	sub_8221F258(ctx, base);
	// 8290E9E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8290E9E4: 419A0028  beq cr6, 0x8290ea0c
	if ctx.cr[6].eq {
	pc = 0x8290EA0C; continue 'dispatch;
	}
	// 8290E9E8: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 8290E9EC: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 8290E9F0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290E9F4: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 8290E9F8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8290E9FC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8290EA00: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8290EA04: 4800000C  b 0x8290ea10
	pc = 0x8290EA10; continue 'dispatch;
            }
            0x8290EA08 => {
    //   block [0x8290EA08..0x8290EA0C)
	// 8290EA08: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x8290EA0C; continue 'dispatch;
            }
            0x8290EA0C => {
    //   block [0x8290EA0C..0x8290EA10)
	// 8290EA0C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x8290EA10; continue 'dispatch;
            }
            0x8290EA10 => {
    //   block [0x8290EA10..0x8290EA24)
	// 8290EA10: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290EA14: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 8290EA18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290EA1C: 419A0008  beq cr6, 0x8290ea24
	if ctx.cr[6].eq {
	pc = 0x8290EA24; continue 'dispatch;
	}
	// 8290EA20: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8290EA24; continue 'dispatch;
            }
            0x8290EA24 => {
    //   block [0x8290EA24..0x8290EAA4)
	// 8290EA24: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8290EA28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290EA2C: 419A0078  beq cr6, 0x8290eaa4
	if ctx.cr[6].eq {
	pc = 0x8290EAA4; continue 'dispatch;
	}
	// 8290EA30: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290EA34: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 8290EA38: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290EA3C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8290EA40: 4B91A6C9  bl 0x82229108
	ctx.lr = 0x8290EA44;
	sub_82229108(ctx, base);
	// 8290EA44: 3D608291  lis r11, -0x7d6f
	ctx.r[11].s64 = -2104426496;
	// 8290EA48: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8290EA4C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8290EA50: 3BCBEE88  addi r30, r11, -0x1178
	ctx.r[30].s64 = ctx.r[11].s64 + -4472;
	// 8290EA54: 4B918E2D  bl 0x82227880
	ctx.lr = 0x8290EA58;
	sub_82227880(ctx, base);
	// 8290EA58: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8290EA5C: 3D40826F  lis r10, -0x7d91
	ctx.r[10].s64 = -2106654720;
	// 8290EA60: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8290EA64: 388A5728  addi r4, r10, 0x5728
	ctx.r[4].s64 = ctx.r[10].s64 + 22312;
	// 8290EA68: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8290EA6C: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 8290EA70: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 8290EA74: 4B88C00D  bl 0x8219aa80
	ctx.lr = 0x8290EA78;
	sub_8219AA80(ctx, base);
	// 8290EA78: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290EA7C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8290EA80: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8290EA84: 4BABF99D  bl 0x823ce420
	ctx.lr = 0x8290EA88;
	sub_823CE420(ctx, base);
	// 8290EA88: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8290EA8C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 8290EA90: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8290EA94: 48115C35  bl 0x82a246c8
	ctx.lr = 0x8290EA98;
	sub_82A246C8(ctx, base);
	// 8290EA98: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290EA9C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 8290EAA0: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x8290EAA4; continue 'dispatch;
            }
            0x8290EAA4 => {
    //   block [0x8290EAA4..0x8290EAB4)
	// 8290EAA4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8290EAA8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8290EAAC: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 8290EAB0: 419A0020  beq cr6, 0x8290ead0
	if ctx.cr[6].eq {
	pc = 0x8290EAD0; continue 'dispatch;
	}
	pc = 0x8290EAB4; continue 'dispatch;
            }
            0x8290EAB4 => {
    //   block [0x8290EAB4..0x8290EAD0)
	// 8290EAB4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8290EAB8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290EABC: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8290EAC0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8290EAC4: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8290EAC8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290EACC: 4082FFE8  bne 0x8290eab4
	if !ctx.cr[0].eq {
	pc = 0x8290EAB4; continue 'dispatch;
	}
	pc = 0x8290EAD0; continue 'dispatch;
            }
            0x8290EAD0 => {
    //   block [0x8290EAD0..0x8290EAF0)
	// 8290EAD0: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290EAD4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8290EAD8: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 8290EADC: 4B9E6E6D  bl 0x822f5948
	ctx.lr = 0x8290EAE0;
	sub_822F5948(ctx, base);
	// 8290EAE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290EAE4: 4B8A9035  bl 0x821b7b18
	ctx.lr = 0x8290EAE8;
	sub_821B7B18(ctx, base);
	// 8290EAE8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8290EAEC: 419A0040  beq cr6, 0x8290eb2c
	if ctx.cr[6].eq {
	pc = 0x8290EB2C; continue 'dispatch;
	}
	pc = 0x8290EAF0; continue 'dispatch;
            }
            0x8290EAF0 => {
    //   block [0x8290EAF0..0x8290EB2C)
	// 8290EAF0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8290EAF4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290EAF8: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8290EAFC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8290EB00: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8290EB04: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290EB08: 4082FFE8  bne 0x8290eaf0
	if !ctx.cr[0].eq {
	pc = 0x8290EAF0; continue 'dispatch;
	}
	// 8290EB0C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290EB10: 409A001C  bne cr6, 0x8290eb2c
	if !ctx.cr[6].eq {
	pc = 0x8290EB2C; continue 'dispatch;
	}
	// 8290EB14: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290EB18: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290EB1C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8290EB20: 4E800421  bctrl
	ctx.lr = 0x8290EB24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290EB24: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8290EB28: 4B90D211  bl 0x8221bd38
	ctx.lr = 0x8290EB2C;
	sub_8221BD38(ctx, base);
            }
            0x8290EB2C => {
    //   block [0x8290EB2C..0x8290EB3C)
	// 8290EB2C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8290EB30: 4B8A8FE9  bl 0x821b7b18
	ctx.lr = 0x8290EB34;
	sub_821B7B18(ctx, base);
	// 8290EB34: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8290EB38: 4839A914  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290EB40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8290EB40 size=56
    let mut pc: u32 = 0x8290EB40;
    'dispatch: loop {
        match pc {
            0x8290EB40 => {
    //   block [0x8290EB40..0x8290EB5C)
	// 8290EB40: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8290EB44: 419A0018  beq cr6, 0x8290eb5c
	if ctx.cr[6].eq {
	pc = 0x8290EB5C; continue 'dispatch;
	}
	// 8290EB48: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 8290EB4C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8290EB50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290EB54: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290EB58: 409A0008  bne cr6, 0x8290eb60
	if !ctx.cr[6].eq {
	pc = 0x8290EB60; continue 'dispatch;
	}
	pc = 0x8290EB5C; continue 'dispatch;
            }
            0x8290EB5C => {
    //   block [0x8290EB5C..0x8290EB60)
	// 8290EB5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8290EB60; continue 'dispatch;
            }
            0x8290EB60 => {
    //   block [0x8290EB60..0x8290EB78)
	// 8290EB60: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290EB64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290EB68: 419A0010  beq cr6, 0x8290eb78
	if ctx.cr[6].eq {
		sub_8290EB78(ctx, base);
		return;
	}
	// 8290EB6C: 81640038  lwz r11, 0x38(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(56 as u32) ) } as u64;
	// 8290EB70: 5563D7FE  rlwinm r3, r11, 0x1a, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 8290EB74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290EB78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8290EB78 size=8
    let mut pc: u32 = 0x8290EB78;
    'dispatch: loop {
        match pc {
            0x8290EB78 => {
    //   block [0x8290EB78..0x8290EB80)
	// 8290EB78: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8290EB7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290EB80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290EB80 size=372
    let mut pc: u32 = 0x8290EB80;
    'dispatch: loop {
        match pc {
            0x8290EB80 => {
    //   block [0x8290EB80..0x8290EBA8)
	// 8290EB80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290EB84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8290EB88: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290EB8C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8290EB90: 419A0018  beq cr6, 0x8290eba8
	if ctx.cr[6].eq {
	pc = 0x8290EBA8; continue 'dispatch;
	}
	// 8290EB94: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 8290EB98: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8290EB9C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290EBA0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290EBA4: 409A0008  bne cr6, 0x8290ebac
	if !ctx.cr[6].eq {
	pc = 0x8290EBAC; continue 'dispatch;
	}
	pc = 0x8290EBA8; continue 'dispatch;
            }
            0x8290EBA8 => {
    //   block [0x8290EBA8..0x8290EBAC)
	// 8290EBA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8290EBAC; continue 'dispatch;
            }
            0x8290EBAC => {
    //   block [0x8290EBAC..0x8290EBF4)
	// 8290EBAC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290EBB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290EBB4: 419A012C  beq cr6, 0x8290ece0
	if ctx.cr[6].eq {
	pc = 0x8290ECE0; continue 'dispatch;
	}
	// 8290EBB8: 81440038  lwz r10, 0x38(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(56 as u32) ) } as u64;
	// 8290EBBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8290EBC0: 5549D7FE  rlwinm r9, r10, 0x1a, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 8290EBC4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8290EBC8: 419A00E8  beq cr6, 0x8290ecb0
	if ctx.cr[6].eq {
	pc = 0x8290ECB0; continue 'dispatch;
	}
	// 8290EBCC: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 8290EBD0: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 8290EBD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290EBD8: 419A001C  beq cr6, 0x8290ebf4
	if ctx.cr[6].eq {
	pc = 0x8290EBF4; continue 'dispatch;
	}
	// 8290EBDC: 896B00A6  lbz r11, 0xa6(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(166 as u32) ) } as u64;
	// 8290EBE0: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 8290EBE4: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8290EBE8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290EBEC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290EBF0: 480000C4  b 0x8290ecb4
	pc = 0x8290ECB4; continue 'dispatch;
            }
            0x8290EBF4 => {
    //   block [0x8290EBF4..0x8290EC10)
	// 8290EBF4: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 8290EBF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8290EBFC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8290EC00: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8290EC04: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8290EC08: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290EC0C: 40810054  ble 0x8290ec60
	if !ctx.cr[0].gt {
	pc = 0x8290EC60; continue 'dispatch;
	}
	pc = 0x8290EC10; continue 'dispatch;
            }
            0x8290EC10 => {
    //   block [0x8290EC10..0x8290EC30)
	// 8290EC10: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8290EC14: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8290EC18: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8290EC1C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290EC20: 2F0700A6  cmpwi cr6, r7, 0xa6
	ctx.cr[6].compare_i32(ctx.r[7].s32, 166, &mut ctx.xer);
	// 8290EC24: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8290EC28: 41980008  blt cr6, 0x8290ec30
	if ctx.cr[6].lt {
	pc = 0x8290EC30; continue 'dispatch;
	}
	// 8290EC2C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x8290EC30; continue 'dispatch;
            }
            0x8290EC30 => {
    //   block [0x8290EC30..0x8290EC4C)
	// 8290EC30: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8290EC34: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8290EC38: 419A0014  beq cr6, 0x8290ec4c
	if ctx.cr[6].eq {
	pc = 0x8290EC4C; continue 'dispatch;
	}
	// 8290EC3C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8290EC40: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8290EC44: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8290EC48: 4800000C  b 0x8290ec54
	pc = 0x8290EC54; continue 'dispatch;
            }
            0x8290EC4C => {
    //   block [0x8290EC4C..0x8290EC54)
	// 8290EC4C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8290EC50: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8290EC54; continue 'dispatch;
            }
            0x8290EC54 => {
    //   block [0x8290EC54..0x8290EC60)
	// 8290EC54: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290EC58: 4199FFB8  bgt cr6, 0x8290ec10
	if ctx.cr[6].gt {
	pc = 0x8290EC10; continue 'dispatch;
	}
	// 8290EC5C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8290EC60; continue 'dispatch;
            }
            0x8290EC60 => {
    //   block [0x8290EC60..0x8290EC7C)
	// 8290EC60: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8290EC64: 419A003C  beq cr6, 0x8290eca0
	if ctx.cr[6].eq {
	pc = 0x8290ECA0; continue 'dispatch;
	}
	// 8290EC68: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290EC6C: 2F0B00A6  cmpwi cr6, r11, 0xa6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 166, &mut ctx.xer);
	// 8290EC70: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290EC74: 41990008  bgt cr6, 0x8290ec7c
	if ctx.cr[6].gt {
	pc = 0x8290EC7C; continue 'dispatch;
	}
	// 8290EC78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8290EC7C; continue 'dispatch;
            }
            0x8290EC7C => {
    //   block [0x8290EC7C..0x8290ECA0)
	// 8290EC7C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290EC80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290EC84: 409A001C  bne cr6, 0x8290eca0
	if !ctx.cr[6].eq {
	pc = 0x8290ECA0; continue 'dispatch;
	}
	// 8290EC88: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8290EC8C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290EC90: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8290EC94: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8290EC98: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290EC9C: 48000018  b 0x8290ecb4
	pc = 0x8290ECB4; continue 'dispatch;
            }
            0x8290ECA0 => {
    //   block [0x8290ECA0..0x8290ECB0)
	// 8290ECA0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8290ECA4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290ECA8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290ECAC: 48000008  b 0x8290ecb4
	pc = 0x8290ECB4; continue 'dispatch;
            }
            0x8290ECB0 => {
    //   block [0x8290ECB0..0x8290ECB4)
	// 8290ECB0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x8290ECB4; continue 'dispatch;
            }
            0x8290ECB4 => {
    //   block [0x8290ECB4..0x8290ECE0)
	// 8290ECB4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8290ECB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290ECBC: 419A0024  beq cr6, 0x8290ece0
	if ctx.cr[6].eq {
	pc = 0x8290ECE0; continue 'dispatch;
	}
	// 8290ECC0: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290ECC4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8290ECC8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8290ECCC: 4E800421  bctrl
	ctx.lr = 0x8290ECD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290ECD0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8290ECD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8290ECD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290ECDC: 4E800020  blr
	return;
            }
            0x8290ECE0 => {
    //   block [0x8290ECE0..0x8290ECF4)
	// 8290ECE0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8290ECE4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8290ECE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8290ECEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290ECF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290ECF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290ECF8 size=396
    let mut pc: u32 = 0x8290ECF8;
    'dispatch: loop {
        match pc {
            0x8290ECF8 => {
    //   block [0x8290ECF8..0x8290ED24)
	// 8290ECF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290ECFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8290ED00: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290ED04: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 8290ED08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290ED0C: 419A0018  beq cr6, 0x8290ed24
	if ctx.cr[6].eq {
	pc = 0x8290ED24; continue 'dispatch;
	}
	// 8290ED10: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 8290ED14: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8290ED18: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290ED1C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8290ED20: 409A0008  bne cr6, 0x8290ed28
	if !ctx.cr[6].eq {
	pc = 0x8290ED28; continue 'dispatch;
	}
	pc = 0x8290ED24; continue 'dispatch;
            }
            0x8290ED24 => {
    //   block [0x8290ED24..0x8290ED28)
	// 8290ED24: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x8290ED28; continue 'dispatch;
            }
            0x8290ED28 => {
    //   block [0x8290ED28..0x8290ED74)
	// 8290ED28: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8290ED2C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290ED30: 419A0140  beq cr6, 0x8290ee70
	if ctx.cr[6].eq {
	pc = 0x8290EE70; continue 'dispatch;
	}
	// 8290ED34: 812B0038  lwz r9, 0x38(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 8290ED38: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8290ED3C: 5528D7FE  rlwinm r8, r9, 0x1a, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000003Fu64;
	// 8290ED40: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8290ED44: 419A00F8  beq cr6, 0x8290ee3c
	if ctx.cr[6].eq {
	pc = 0x8290EE3C; continue 'dispatch;
	}
	// 8290ED48: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8290ED4C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290ED50: 419A0024  beq cr6, 0x8290ed74
	if ctx.cr[6].eq {
	pc = 0x8290ED74; continue 'dispatch;
	}
	// 8290ED54: 892A00A6  lbz r9, 0xa6(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(166 as u32) ) } as u64;
	// 8290ED58: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8290ED5C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 8290ED60: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8290ED64: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290ED68: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8290ED6C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290ED70: 480000D0  b 0x8290ee40
	pc = 0x8290EE40; continue 'dispatch;
            }
            0x8290ED74 => {
    //   block [0x8290ED74..0x8290ED94)
	// 8290ED74: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8290ED78: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8290ED7C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8290ED80: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 8290ED84: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8290ED88: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8290ED8C: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290ED90: 40810054  ble 0x8290ede4
	if !ctx.cr[0].gt {
	pc = 0x8290EDE4; continue 'dispatch;
	}
	pc = 0x8290ED94; continue 'dispatch;
            }
            0x8290ED94 => {
    //   block [0x8290ED94..0x8290EDB4)
	// 8290ED94: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8290ED98: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8290ED9C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8290EDA0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290EDA4: 2F0700A6  cmpwi cr6, r7, 0xa6
	ctx.cr[6].compare_i32(ctx.r[7].s32, 166, &mut ctx.xer);
	// 8290EDA8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8290EDAC: 41980008  blt cr6, 0x8290edb4
	if ctx.cr[6].lt {
	pc = 0x8290EDB4; continue 'dispatch;
	}
	// 8290EDB0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x8290EDB4; continue 'dispatch;
            }
            0x8290EDB4 => {
    //   block [0x8290EDB4..0x8290EDD0)
	// 8290EDB4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8290EDB8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8290EDBC: 419A0014  beq cr6, 0x8290edd0
	if ctx.cr[6].eq {
	pc = 0x8290EDD0; continue 'dispatch;
	}
	// 8290EDC0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8290EDC4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8290EDC8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8290EDCC: 4800000C  b 0x8290edd8
	pc = 0x8290EDD8; continue 'dispatch;
            }
            0x8290EDD0 => {
    //   block [0x8290EDD0..0x8290EDD8)
	// 8290EDD0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8290EDD4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8290EDD8; continue 'dispatch;
            }
            0x8290EDD8 => {
    //   block [0x8290EDD8..0x8290EDE4)
	// 8290EDD8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290EDDC: 4199FFB8  bgt cr6, 0x8290ed94
	if ctx.cr[6].gt {
	pc = 0x8290ED94; continue 'dispatch;
	}
	// 8290EDE0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8290EDE4; continue 'dispatch;
            }
            0x8290EDE4 => {
    //   block [0x8290EDE4..0x8290EE00)
	// 8290EDE4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8290EDE8: 419A0040  beq cr6, 0x8290ee28
	if ctx.cr[6].eq {
	pc = 0x8290EE28; continue 'dispatch;
	}
	// 8290EDEC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290EDF0: 2F0B00A6  cmpwi cr6, r11, 0xa6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 166, &mut ctx.xer);
	// 8290EDF4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290EDF8: 41990008  bgt cr6, 0x8290ee00
	if ctx.cr[6].gt {
	pc = 0x8290EE00; continue 'dispatch;
	}
	// 8290EDFC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8290EE00; continue 'dispatch;
            }
            0x8290EE00 => {
    //   block [0x8290EE00..0x8290EE28)
	// 8290EE00: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290EE04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290EE08: 409A0020  bne cr6, 0x8290ee28
	if !ctx.cr[6].eq {
	pc = 0x8290EE28; continue 'dispatch;
	}
	// 8290EE0C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8290EE10: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8290EE14: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8290EE18: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290EE1C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8290EE20: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290EE24: 4800001C  b 0x8290ee40
	pc = 0x8290EE40; continue 'dispatch;
            }
            0x8290EE28 => {
    //   block [0x8290EE28..0x8290EE3C)
	// 8290EE28: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8290EE2C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290EE30: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8290EE34: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290EE38: 48000008  b 0x8290ee40
	pc = 0x8290EE40; continue 'dispatch;
            }
            0x8290EE3C => {
    //   block [0x8290EE3C..0x8290EE40)
	// 8290EE3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8290EE40; continue 'dispatch;
            }
            0x8290EE40 => {
    //   block [0x8290EE40..0x8290EE70)
	// 8290EE40: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290EE44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290EE48: 419A0028  beq cr6, 0x8290ee70
	if ctx.cr[6].eq {
	pc = 0x8290EE70; continue 'dispatch;
	}
	// 8290EE4C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290EE50: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 8290EE54: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 8290EE58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8290EE5C: 4E800421  bctrl
	ctx.lr = 0x8290EE60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290EE60: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8290EE64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8290EE68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290EE6C: 4E800020  blr
	return;
            }
            0x8290EE70 => {
    //   block [0x8290EE70..0x8290EE84)
	// 8290EE70: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8290EE74: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8290EE78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8290EE7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290EE80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290EE88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290EE88 size=424
    let mut pc: u32 = 0x8290EE88;
    'dispatch: loop {
        match pc {
            0x8290EE88 => {
    //   block [0x8290EE88..0x8290EEB4)
	// 8290EE88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290EE8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8290EE90: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290EE94: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8290EE98: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8290EE9C: 419A0018  beq cr6, 0x8290eeb4
	if ctx.cr[6].eq {
	pc = 0x8290EEB4; continue 'dispatch;
	}
	// 8290EEA0: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 8290EEA4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8290EEA8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290EEAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290EEB0: 409A0008  bne cr6, 0x8290eeb8
	if !ctx.cr[6].eq {
	pc = 0x8290EEB8; continue 'dispatch;
	}
	pc = 0x8290EEB4; continue 'dispatch;
            }
            0x8290EEB4 => {
    //   block [0x8290EEB4..0x8290EEB8)
	// 8290EEB4: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	pc = 0x8290EEB8; continue 'dispatch;
            }
            0x8290EEB8 => {
    //   block [0x8290EEB8..0x8290EF00)
	// 8290EEB8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290EEBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290EEC0: 419A012C  beq cr6, 0x8290efec
	if ctx.cr[6].eq {
	pc = 0x8290EFEC; continue 'dispatch;
	}
	// 8290EEC4: 81440038  lwz r10, 0x38(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(56 as u32) ) } as u64;
	// 8290EEC8: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 8290EECC: 5549D7FE  rlwinm r9, r10, 0x1a, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 8290EED0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8290EED4: 419A00E8  beq cr6, 0x8290efbc
	if ctx.cr[6].eq {
	pc = 0x8290EFBC; continue 'dispatch;
	}
	// 8290EED8: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 8290EEDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290EEE0: 419A0020  beq cr6, 0x8290ef00
	if ctx.cr[6].eq {
	pc = 0x8290EF00; continue 'dispatch;
	}
	// 8290EEE4: 894B00A6  lbz r10, 0xa6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(166 as u32) ) } as u64;
	// 8290EEE8: 81640048  lwz r11, 0x48(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 8290EEEC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8290EEF0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8290EEF4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290EEF8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290EEFC: 480000C4  b 0x8290efc0
	pc = 0x8290EFC0; continue 'dispatch;
            }
            0x8290EF00 => {
    //   block [0x8290EF00..0x8290EF1C)
	// 8290EF00: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 8290EF04: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 8290EF08: 90A10050  stw r5, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u32 ) };
	// 8290EF0C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8290EF10: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8290EF14: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290EF18: 40810054  ble 0x8290ef6c
	if !ctx.cr[0].gt {
	pc = 0x8290EF6C; continue 'dispatch;
	}
	pc = 0x8290EF1C; continue 'dispatch;
            }
            0x8290EF1C => {
    //   block [0x8290EF1C..0x8290EF3C)
	// 8290EF1C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8290EF20: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8290EF24: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8290EF28: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290EF2C: 2F0700A6  cmpwi cr6, r7, 0xa6
	ctx.cr[6].compare_i32(ctx.r[7].s32, 166, &mut ctx.xer);
	// 8290EF30: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8290EF34: 41980008  blt cr6, 0x8290ef3c
	if ctx.cr[6].lt {
	pc = 0x8290EF3C; continue 'dispatch;
	}
	// 8290EF38: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	pc = 0x8290EF3C; continue 'dispatch;
            }
            0x8290EF3C => {
    //   block [0x8290EF3C..0x8290EF58)
	// 8290EF3C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8290EF40: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8290EF44: 419A0014  beq cr6, 0x8290ef58
	if ctx.cr[6].eq {
	pc = 0x8290EF58; continue 'dispatch;
	}
	// 8290EF48: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8290EF4C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8290EF50: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8290EF54: 4800000C  b 0x8290ef60
	pc = 0x8290EF60; continue 'dispatch;
            }
            0x8290EF58 => {
    //   block [0x8290EF58..0x8290EF60)
	// 8290EF58: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8290EF5C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8290EF60; continue 'dispatch;
            }
            0x8290EF60 => {
    //   block [0x8290EF60..0x8290EF6C)
	// 8290EF60: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290EF64: 4199FFB8  bgt cr6, 0x8290ef1c
	if ctx.cr[6].gt {
	pc = 0x8290EF1C; continue 'dispatch;
	}
	// 8290EF68: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x8290EF6C; continue 'dispatch;
            }
            0x8290EF6C => {
    //   block [0x8290EF6C..0x8290EF88)
	// 8290EF6C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8290EF70: 419A003C  beq cr6, 0x8290efac
	if ctx.cr[6].eq {
	pc = 0x8290EFAC; continue 'dispatch;
	}
	// 8290EF74: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290EF78: 2F0B00A6  cmpwi cr6, r11, 0xa6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 166, &mut ctx.xer);
	// 8290EF7C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290EF80: 41990008  bgt cr6, 0x8290ef88
	if ctx.cr[6].gt {
	pc = 0x8290EF88; continue 'dispatch;
	}
	// 8290EF84: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	pc = 0x8290EF88; continue 'dispatch;
            }
            0x8290EF88 => {
    //   block [0x8290EF88..0x8290EFAC)
	// 8290EF88: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290EF8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290EF90: 409A001C  bne cr6, 0x8290efac
	if !ctx.cr[6].eq {
	pc = 0x8290EFAC; continue 'dispatch;
	}
	// 8290EF94: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8290EF98: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290EF9C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8290EFA0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8290EFA4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290EFA8: 48000018  b 0x8290efc0
	pc = 0x8290EFC0; continue 'dispatch;
            }
            0x8290EFAC => {
    //   block [0x8290EFAC..0x8290EFBC)
	// 8290EFAC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 8290EFB0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8290EFB4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290EFB8: 48000008  b 0x8290efc0
	pc = 0x8290EFC0; continue 'dispatch;
            }
            0x8290EFBC => {
    //   block [0x8290EFBC..0x8290EFC0)
	// 8290EFBC: 7CAA2B78  mr r10, r5
	ctx.r[10].u64 = ctx.r[5].u64;
	pc = 0x8290EFC0; continue 'dispatch;
            }
            0x8290EFC0 => {
    //   block [0x8290EFC0..0x8290EFEC)
	// 8290EFC0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8290EFC4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290EFC8: 419A0024  beq cr6, 0x8290efec
	if ctx.cr[6].eq {
	pc = 0x8290EFEC; continue 'dispatch;
	}
	// 8290EFCC: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8290EFD0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8290EFD4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8290EFD8: 4E800421  bctrl
	ctx.lr = 0x8290EFDC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290EFDC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8290EFE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8290EFE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290EFE8: 4E800020  blr
	return;
            }
            0x8290EFEC => {
    //   block [0x8290EFEC..0x8290EFF8)
	// 8290EFEC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8290EFF0: 90A10050  stw r5, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u32 ) };
	// 8290EFF4: 390B7088  addi r8, r11, 0x7088
	ctx.r[8].s64 = ctx.r[11].s64 + 28808;
	pc = 0x8290EFF8; continue 'dispatch;
            }
            0x8290EFF8 => {
    //   block [0x8290EFF8..0x8290F030)
	// 8290EFF8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8290EFFC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290F000: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8290F004: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8290F008: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8290F00C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290F010: 4082FFE8  bne 0x8290eff8
	if !ctx.cr[0].eq {
	pc = 0x8290EFF8; continue 'dispatch;
	}
	// 8290F014: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290F018: 4B905DC1  bl 0x82214dd8
	ctx.lr = 0x8290F01C;
	sub_82214DD8(ctx, base);
	// 8290F01C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290F020: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8290F024: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8290F028: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290F02C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290F030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290F030 size=60
    let mut pc: u32 = 0x8290F030;
    'dispatch: loop {
        match pc {
            0x8290F030 => {
    //   block [0x8290F030..0x8290F06C)
	// 8290F030: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290F034: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8290F038: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8290F03C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290F040: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8290F044: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8290F048: 388B9ABC  addi r4, r11, -0x6544
	ctx.r[4].s64 = ctx.r[11].s64 + -25924;
	// 8290F04C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290F050: 4B91DE81  bl 0x8222ced0
	ctx.lr = 0x8290F054;
	sub_8222CED0(ctx, base);
	// 8290F054: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290F058: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8290F05C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8290F060: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290F064: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8290F068: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290F070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8290F070 size=8
    let mut pc: u32 = 0x8290F070;
    'dispatch: loop {
        match pc {
            0x8290F070 => {
    //   block [0x8290F070..0x8290F078)
	// 8290F070: 88630014  lbz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 8290F074: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290F078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8290F078 size=8
    let mut pc: u32 = 0x8290F078;
    'dispatch: loop {
        match pc {
            0x8290F078 => {
    //   block [0x8290F078..0x8290F080)
	// 8290F078: 98830014  stb r4, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[4].u8 ) };
	// 8290F07C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290F080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290F080 size=80
    let mut pc: u32 = 0x8290F080;
    'dispatch: loop {
        match pc {
            0x8290F080 => {
    //   block [0x8290F080..0x8290F0B8)
	// 8290F080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290F084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8290F088: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8290F08C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8290F090: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290F094: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290F098: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8290F09C: 48000035  bl 0x8290f0d0
	ctx.lr = 0x8290F0A0;
	sub_8290F0D0(ctx, base);
	// 8290F0A0: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 8290F0A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8290F0A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290F0AC: 419A000C  beq cr6, 0x8290f0b8
	if ctx.cr[6].eq {
	pc = 0x8290F0B8; continue 'dispatch;
	}
	// 8290F0B0: 4B90CC89  bl 0x8221bd38
	ctx.lr = 0x8290F0B4;
	sub_8221BD38(ctx, base);
	// 8290F0B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x8290F0B8; continue 'dispatch;
            }
            0x8290F0B8 => {
    //   block [0x8290F0B8..0x8290F0D0)
	// 8290F0B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8290F0BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8290F0C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290F0C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8290F0C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8290F0CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290F0D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290F0D0 size=240
    let mut pc: u32 = 0x8290F0D0;
    'dispatch: loop {
        match pc {
            0x8290F0D0 => {
    //   block [0x8290F0D0..0x8290F0F4)
	// 8290F0D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290F0D4: 4839A339  bl 0x82ca940c
	ctx.lr = 0x8290F0D8;
	sub_82CA93D0(ctx, base);
	// 8290F0D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290F0DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290F0E0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8290F0E4: 807F003C  lwz r3, 0x3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 8290F0E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8290F0EC: 419A0040  beq cr6, 0x8290f12c
	if ctx.cr[6].eq {
	pc = 0x8290F12C; continue 'dispatch;
	}
	// 8290F0F0: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x8290F0F4; continue 'dispatch;
            }
            0x8290F0F4 => {
    //   block [0x8290F0F4..0x8290F128)
	// 8290F0F4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8290F0F8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290F0FC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8290F100: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8290F104: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8290F108: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290F10C: 4082FFE8  bne 0x8290f0f4
	if !ctx.cr[0].eq {
	pc = 0x8290F0F4; continue 'dispatch;
	}
	// 8290F110: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290F114: 409A0014  bne cr6, 0x8290f128
	if !ctx.cr[6].eq {
	pc = 0x8290F128; continue 'dispatch;
	}
	// 8290F118: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290F11C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290F120: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8290F124: 4E800421  bctrl
	ctx.lr = 0x8290F128;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8290F128 => {
    //   block [0x8290F128..0x8290F12C)
	// 8290F128: 93DF003C  stw r30, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[30].u32 ) };
	pc = 0x8290F12C; continue 'dispatch;
            }
            0x8290F12C => {
    //   block [0x8290F12C..0x8290F144)
	// 8290F12C: 387F0034  addi r3, r31, 0x34
	ctx.r[3].s64 = ctx.r[31].s64 + 52;
	// 8290F130: 4B8A89E9  bl 0x821b7b18
	ctx.lr = 0x8290F134;
	sub_821B7B18(ctx, base);
	// 8290F134: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8290F138: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8290F13C: 419A0040  beq cr6, 0x8290f17c
	if ctx.cr[6].eq {
	pc = 0x8290F17C; continue 'dispatch;
	}
	// 8290F140: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x8290F144; continue 'dispatch;
            }
            0x8290F144 => {
    //   block [0x8290F144..0x8290F178)
	// 8290F144: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8290F148: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290F14C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8290F150: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8290F154: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8290F158: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8290F15C: 4082FFE8  bne 0x8290f144
	if !ctx.cr[0].eq {
	pc = 0x8290F144; continue 'dispatch;
	}
	// 8290F160: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290F164: 409A0014  bne cr6, 0x8290f178
	if !ctx.cr[6].eq {
	pc = 0x8290F178; continue 'dispatch;
	}
	// 8290F168: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290F16C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290F170: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8290F174: 4E800421  bctrl
	ctx.lr = 0x8290F178;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8290F178 => {
    //   block [0x8290F178..0x8290F17C)
	// 8290F178: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	pc = 0x8290F17C; continue 'dispatch;
            }
            0x8290F17C => {
    //   block [0x8290F17C..0x8290F1C0)
	// 8290F17C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 8290F180: 4B8A8999  bl 0x821b7b18
	ctx.lr = 0x8290F184;
	sub_821B7B18(ctx, base);
	// 8290F184: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8290F188: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 8290F18C: 3BAB0B7C  addi r29, r11, 0xb7c
	ctx.r[29].s64 = ctx.r[11].s64 + 2940;
	// 8290F190: 93BF0020  stw r29, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[29].u32 ) };
	// 8290F194: 4B884CA5  bl 0x82193e38
	ctx.lr = 0x8290F198;
	sub_82193E38(ctx, base);
	// 8290F198: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 8290F19C: 93BF0018  stw r29, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 8290F1A0: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 8290F1A4: 4B884C95  bl 0x82193e38
	ctx.lr = 0x8290F1A8;
	sub_82193E38(ctx, base);
	// 8290F1A8: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 8290F1AC: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 8290F1B0: 392A2850  addi r9, r10, 0x2850
	ctx.r[9].s64 = ctx.r[10].s64 + 10320;
	// 8290F1B4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8290F1B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8290F1BC: 4839A2A0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290F1C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290F1C0 size=2836
    let mut pc: u32 = 0x8290F1C0;
    'dispatch: loop {
        match pc {
            0x8290F1C0 => {
    //   block [0x8290F1C0..0x8290FCD4)
	// 8290F1C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290F1C4: 4839A229  bl 0x82ca93ec
	ctx.lr = 0x8290F1C8;
	sub_82CA93D0(ctx, base);
	// 8290F1C8: DBE1FF98  stfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 8290F1CC: 9421FE30  stwu r1, -0x1d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-464 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290F1D0: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 8290F1D4: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 8290F1D8: 80770004  lwz r3, 4(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290F1DC: 4BA7E2DD  bl 0x8238d4b8
	ctx.lr = 0x8290F1E0;
	sub_8238D4B8(ctx, base);
	// 8290F1E0: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290F1E4: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 8290F1E8: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 8290F1EC: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290F1F0: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 8290F1F4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8290F1F8: 4E800421  bctrl
	ctx.lr = 0x8290F1FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8290F1FC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8290F200: 390100D0  addi r8, r1, 0xd0
	ctx.r[8].s64 = ctx.r[1].s64 + 208;
	// 8290F204: 3BCB9484  addi r30, r11, -0x6b7c
	ctx.r[30].s64 = ctx.r[11].s64 + -27516;
	// 8290F208: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290FCD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8290FCD8 size=120
    let mut pc: u32 = 0x8290FCD8;
    'dispatch: loop {
        match pc {
            0x8290FCD8 => {
    //   block [0x8290FCD8..0x8290FD20)
	// 8290FCD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290FCDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8290FCE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8290FCE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8290FCE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290FCEC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8290FCF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8290FCF4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8290FCF8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8290FCFC: 388B57D0  addi r4, r11, 0x57d0
	ctx.r[4].s64 = ctx.r[11].s64 + 22480;
	// 8290FD00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290FD04: 4B91D1CD  bl 0x8222ced0
	ctx.lr = 0x8290FD08;
	sub_8222CED0(ctx, base);
	// 8290FD08: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8290FD0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290FD10: 409A0010  bne cr6, 0x8290fd20
	if !ctx.cr[6].eq {
	pc = 0x8290FD20; continue 'dispatch;
	}
	// 8290FD14: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8290FD18: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 8290FD1C: 48000008  b 0x8290fd24
	pc = 0x8290FD24; continue 'dispatch;
            }
            0x8290FD20 => {
    //   block [0x8290FD20..0x8290FD24)
	// 8290FD20: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8290FD24; continue 'dispatch;
            }
            0x8290FD24 => {
    //   block [0x8290FD24..0x8290FD50)
	// 8290FD24: 38BF000C  addi r5, r31, 0xc
	ctx.r[5].s64 = ctx.r[31].s64 + 12;
	// 8290FD28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8290FD2C: 4BB70B25  bl 0x82480850
	ctx.lr = 0x8290FD30;
	sub_82480850(ctx, base);
	// 8290FD30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8290FD34: 4B9050A5  bl 0x82214dd8
	ctx.lr = 0x8290FD38;
	sub_82214DD8(ctx, base);
	// 8290FD38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8290FD3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8290FD40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8290FD44: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8290FD48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8290FD4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8290FD50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8290FD50 size=980
    let mut pc: u32 = 0x8290FD50;
    'dispatch: loop {
        match pc {
            0x8290FD50 => {
    //   block [0x8290FD50..0x8290FDA8)
	// 8290FD50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8290FD54: 483996B9  bl 0x82ca940c
	ctx.lr = 0x8290FD58;
	sub_82CA93D0(ctx, base);
	// 8290FD58: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 8290FD5C: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8290FD60: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8290FD64: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8290FD68: 387D0018  addi r3, r29, 0x18
	ctx.r[3].s64 = ctx.r[29].s64 + 24;
	// 8290FD6C: 817D001C  lwz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 8290FD70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290FD74: 419A0034  beq cr6, 0x8290fda8
	if ctx.cr[6].eq {
	pc = 0x8290FDA8; continue 'dispatch;
	}
	// 8290FD78: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290FD7C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290FD80: 419A020C  beq cr6, 0x8290ff8c
	if ctx.cr[6].eq {
	pc = 0x8290FF8C; continue 'dispatch;
	}
	// 8290FD84: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8290FD88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290FD8C: 419A001C  beq cr6, 0x8290fda8
	if ctx.cr[6].eq {
	pc = 0x8290FDA8; continue 'dispatch;
	}
	// 8290FD90: 4B8640A9  bl 0x82173e38
	ctx.lr = 0x8290FD94;
	sub_82173E38(ctx, base);
	// 8290FD94: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 8290FD98: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8290FD9C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290FDA0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290FDA4: 409A0008  bne cr6, 0x8290fdac
	if !ctx.cr[6].eq {
	pc = 0x8290FDAC; continue 'dispatch;
	}
	pc = 0x8290FDA8; continue 'dispatch;
            }
            0x8290FDA8 => {
    //   block [0x8290FDA8..0x8290FDAC)
	// 8290FDA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8290FDAC; continue 'dispatch;
            }
            0x8290FDAC => {
    //   block [0x8290FDAC..0x8290FE24)
	// 8290FDAC: 556A063E  clrlwi r10, r11, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290FDB0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8290FDB4: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 8290FDB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290FDBC: 3BCBB4D8  addi r30, r11, -0x4b28
	ctx.r[30].s64 = ctx.r[11].s64 + -19240;
	// 8290FDC0: 419A0064  beq cr6, 0x8290fe24
	if ctx.cr[6].eq {
	pc = 0x8290FE24; continue 'dispatch;
	}
	// 8290FDC4: 817D0028  lwz r11, 0x28(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 8290FDC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290FDCC: 419A0058  beq cr6, 0x8290fe24
	if ctx.cr[6].eq {
	pc = 0x8290FE24; continue 'dispatch;
	}
	// 8290FDD0: 817F6AB8  lwz r11, 0x6ab8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8290FDD4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8290FDD8: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8290FDDC: C84A0D30  lfd f2, 0xd30(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(3376 as u32) ) };
	// 8290FDE0: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 8290FDE4: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290FDE8: 80C70014  lwz r6, 0x14(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 8290FDEC: C0260004  lfs f1, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8290FDF0: 4B8F0B01  bl 0x822008f0
	ctx.lr = 0x8290FDF4;
	sub_822008F0(ctx, base);
	// 8290FDF4: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 8290FDF8: 807D0028  lwz r3, 0x28(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 8290FDFC: C01EFFA8  lfs f0, -0x58(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8290FE00: C0230028  lfs f1, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8290FE04: ECED0032  fmuls f7, f13, f0
	ctx.f[7].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8290FE08: 4B9C3841  bl 0x822d3648
	ctx.lr = 0x8290FE0C;
	sub_822D3648(ctx, base);
	// 8290FE0C: 807D0028  lwz r3, 0x28(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 8290FE10: EC2101F2  fmuls f1, f1, f7
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[7].f64) as f32) as f64);
	// 8290FE14: 80A30000  lwz r5, 0(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290FE18: 80850014  lwz r4, 0x14(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(20 as u32) ) } as u64;
	// 8290FE1C: 7C8903A6  mtctr r4
	ctx.ctr.u64 = ctx.r[4].u64;
	// 8290FE20: 4E800421  bctrl
	ctx.lr = 0x8290FE24;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8290FE24 => {
    //   block [0x8290FE24..0x8290FE64)
	// 8290FE24: 817D0024  lwz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 8290FE28: 387D0020  addi r3, r29, 0x20
	ctx.r[3].s64 = ctx.r[29].s64 + 32;
	// 8290FE2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290FE30: 419A0034  beq cr6, 0x8290fe64
	if ctx.cr[6].eq {
	pc = 0x8290FE64; continue 'dispatch;
	}
	// 8290FE34: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290FE38: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290FE3C: 419A0158  beq cr6, 0x8290ff94
	if ctx.cr[6].eq {
	pc = 0x8290FF94; continue 'dispatch;
	}
	// 8290FE40: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8290FE44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290FE48: 419A001C  beq cr6, 0x8290fe64
	if ctx.cr[6].eq {
	pc = 0x8290FE64; continue 'dispatch;
	}
	// 8290FE4C: 4B863FED  bl 0x82173e38
	ctx.lr = 0x8290FE50;
	sub_82173E38(ctx, base);
	// 8290FE50: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 8290FE54: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8290FE58: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290FE5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290FE60: 409A0008  bne cr6, 0x8290fe68
	if !ctx.cr[6].eq {
	pc = 0x8290FE68; continue 'dispatch;
	}
	pc = 0x8290FE64; continue 'dispatch;
            }
            0x8290FE64 => {
    //   block [0x8290FE64..0x8290FE68)
	// 8290FE64: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8290FE68; continue 'dispatch;
            }
            0x8290FE68 => {
    //   block [0x8290FE68..0x8290FEF4)
	// 8290FE68: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8290FE6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290FE70: 419A0084  beq cr6, 0x8290fef4
	if ctx.cr[6].eq {
	pc = 0x8290FEF4; continue 'dispatch;
	}
	// 8290FE74: 817D0034  lwz r11, 0x34(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 8290FE78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8290FE7C: 419A0078  beq cr6, 0x8290fef4
	if ctx.cr[6].eq {
	pc = 0x8290FEF4; continue 'dispatch;
	}
	// 8290FE80: 817F6AB8  lwz r11, 0x6ab8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8290FE84: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8290FE88: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8290FE8C: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 8290FE90: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290FE94: 81090014  lwz r8, 0x14(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 8290FE98: C1A80004  lfs f13, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8290FE9C: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8290FEA0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8290FEA4: 4B91C4ED  bl 0x8222c390
	ctx.lr = 0x8290FEA8;
	sub_8222C390(ctx, base);
	// 8290FEA8: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 8290FEAC: 807D0034  lwz r3, 0x34(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 8290FEB0: C0230028  lfs f1, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8290FEB4: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 8290FEB8: D9610058  stfd f11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[11].u64 ) };
	// 8290FEBC: 80E1005C  lwz r7, 0x5c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8290FEC0: 7CE607B4  extsw r6, r7
	ctx.r[6].s64 = ctx.r[7].s32 as i64;
	// 8290FEC4: F8C10058  std r6, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u64 ) };
	// 8290FEC8: C9410058  lfd f10, 0x58(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8290FECC: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 8290FED0: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 8290FED4: ECFF4028  fsubs f7, f31, f8
	ctx.f[7].f64 = (((ctx.f[31].f64 - ctx.f[8].f64) as f32) as f64);
	// 8290FED8: 4B9C3771  bl 0x822d3648
	ctx.lr = 0x8290FEDC;
	sub_822D3648(ctx, base);
	// 8290FEDC: 807D0034  lwz r3, 0x34(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 8290FEE0: EC2101F2  fmuls f1, f1, f7
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[7].f64) as f32) as f64);
	// 8290FEE4: 80A30000  lwz r5, 0(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290FEE8: 80850014  lwz r4, 0x14(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(20 as u32) ) } as u64;
	// 8290FEEC: 7C8903A6  mtctr r4
	ctx.ctr.u64 = ctx.r[4].u64;
	// 8290FEF0: 4E800421  bctrl
	ctx.lr = 0x8290FEF4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8290FEF4 => {
    //   block [0x8290FEF4..0x8290FF8C)
	// 8290FEF4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8290FEF8: C01D0010  lfs f0, 0x10(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8290FEFC: C1AB9A80  lfs f13, -0x6580(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8290FF00: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8290FF04: 40990210  ble cr6, 0x82910114
	if !ctx.cr[6].gt {
	pc = 0x82910114; continue 'dispatch;
	}
	// 8290FF08: 817F6AB8  lwz r11, 0x6ab8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27320 as u32) ) } as u64;
	// 8290FF0C: C1BD000C  lfs f13, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8290FF10: EC2D0024  fdivs f1, f13, f0
	ctx.f[1].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 8290FF14: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8290FF18: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 8290FF1C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290FF20: 81090014  lwz r8, 0x14(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 8290FF24: C3E80004  lfs f31, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8290FF28: 4B91C469  bl 0x8222c390
	ctx.lr = 0x8290FF2C;
	sub_8222C390(ctx, base);
	// 8290FF2C: C19D0010  lfs f12, 0x10(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8290FF30: FFC00818  frsp f30, f1
	ctx.f[30].f64 = (ctx.f[1].f64 as f32) as f64;
	// 8290FF34: EC3F6024  fdivs f1, f31, f12
	ctx.f[1].f64 = ((ctx.f[31].f64 / ctx.f[12].f64) as f32) as f64;
	// 8290FF38: 4B91C459  bl 0x8222c390
	ctx.lr = 0x8290FF3C;
	sub_8222C390(ctx, base);
	// 8290FF3C: FD600818  frsp f11, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].f64 = (ctx.f[1].f64 as f32) as f64;
	// 8290FF40: FF0BF000  fcmpu cr6, f11, f30
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[30].f64);
	// 8290FF44: 409901CC  ble cr6, 0x82910110
	if !ctx.cr[6].gt {
	pc = 0x82910110; continue 'dispatch;
	}
	// 8290FF48: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290FF4C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8290FF50: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 8290FF54: 5549CFFE  rlwinm r9, r10, 0x19, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 8290FF58: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8290FF5C: 419A0108  beq cr6, 0x82910064
	if ctx.cr[6].eq {
	pc = 0x82910064; continue 'dispatch;
	}
	// 8290FF60: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8290FF64: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8290FF68: 419A0034  beq cr6, 0x8290ff9c
	if ctx.cr[6].eq {
	pc = 0x8290FF9C; continue 'dispatch;
	}
	// 8290FF6C: 894A0087  lbz r10, 0x87(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(135 as u32) ) } as u64;
	// 8290FF70: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8290FF74: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8290FF78: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8290FF7C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8290FF80: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8290FF84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8290FF88: 480000E0  b 0x82910068
	pc = 0x82910068; continue 'dispatch;
            }
            0x8290FF8C => {
    //   block [0x8290FF8C..0x8290FF94)
	// 8290FF8C: 4B883EAD  bl 0x82193e38
	ctx.lr = 0x8290FF90;
	sub_82193E38(ctx, base);
	// 8290FF90: 4BFFFE18  b 0x8290fda8
	pc = 0x8290FDA8; continue 'dispatch;
            }
            0x8290FF94 => {
    //   block [0x8290FF94..0x8290FF9C)
	// 8290FF94: 4B883EA5  bl 0x82193e38
	ctx.lr = 0x8290FF98;
	sub_82193E38(ctx, base);
	// 8290FF98: 4BFFFECC  b 0x8290fe64
	pc = 0x8290FE64; continue 'dispatch;
            }
            0x8290FF9C => {
    //   block [0x8290FF9C..0x8290FFBC)
	// 8290FF9C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8290FFA0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8290FFA4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8290FFA8: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 8290FFAC: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8290FFB0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 8290FFB4: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8290FFB8: 40810054  ble 0x8291000c
	if !ctx.cr[0].gt {
	pc = 0x8291000C; continue 'dispatch;
	}
	pc = 0x8290FFBC; continue 'dispatch;
            }
            0x8290FFBC => {
    //   block [0x8290FFBC..0x8290FFDC)
	// 8290FFBC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8290FFC0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8290FFC4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 8290FFC8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8290FFCC: 2F070087  cmpwi cr6, r7, 0x87
	ctx.cr[6].compare_i32(ctx.r[7].s32, 135, &mut ctx.xer);
	// 8290FFD0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8290FFD4: 41980008  blt cr6, 0x8290ffdc
	if ctx.cr[6].lt {
	pc = 0x8290FFDC; continue 'dispatch;
	}
	// 8290FFD8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x8290FFDC; continue 'dispatch;
            }
            0x8290FFDC => {
    //   block [0x8290FFDC..0x8290FFF8)
	// 8290FFDC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8290FFE0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8290FFE4: 419A0014  beq cr6, 0x8290fff8
	if ctx.cr[6].eq {
	pc = 0x8290FFF8; continue 'dispatch;
	}
	// 8290FFE8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 8290FFEC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8290FFF0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8290FFF4: 4800000C  b 0x82910000
	pc = 0x82910000; continue 'dispatch;
            }
            0x8290FFF8 => {
    //   block [0x8290FFF8..0x82910000)
	// 8290FFF8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8290FFFC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82910000; continue 'dispatch;
            }
            0x82910000 => {
    //   block [0x82910000..0x8291000C)
	// 82910000: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82910004: 4199FFB8  bgt cr6, 0x8290ffbc
	if ctx.cr[6].gt {
	pc = 0x8290FFBC; continue 'dispatch;
	}
	// 82910008: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x8291000C; continue 'dispatch;
            }
            0x8291000C => {
    //   block [0x8291000C..0x82910028)
	// 8291000C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82910010: 419A0040  beq cr6, 0x82910050
	if ctx.cr[6].eq {
	pc = 0x82910050; continue 'dispatch;
	}
	// 82910014: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82910018: 2F0B0087  cmpwi cr6, r11, 0x87
	ctx.cr[6].compare_i32(ctx.r[11].s32, 135, &mut ctx.xer);
	// 8291001C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82910020: 41990008  bgt cr6, 0x82910028
	if ctx.cr[6].gt {
	pc = 0x82910028; continue 'dispatch;
	}
	// 82910024: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82910028; continue 'dispatch;
            }
            0x82910028 => {
    //   block [0x82910028..0x82910050)
	// 82910028: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8291002C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82910030: 409A0020  bne cr6, 0x82910050
	if !ctx.cr[6].eq {
	pc = 0x82910050; continue 'dispatch;
	}
	// 82910034: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82910038: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8291003C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82910040: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82910044: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82910048: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8291004C: 4800001C  b 0x82910068
	pc = 0x82910068; continue 'dispatch;
            }
            0x82910050 => {
    //   block [0x82910050..0x82910064)
	// 82910050: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82910054: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82910058: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8291005C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82910060: 48000008  b 0x82910068
	pc = 0x82910068; continue 'dispatch;
            }
            0x82910064 => {
    //   block [0x82910064..0x82910068)
	// 82910064: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82910068; continue 'dispatch;
            }
            0x82910068 => {
    //   block [0x82910068..0x82910108)
	// 82910068: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8291006C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82910070: 419A00A0  beq cr6, 0x82910110
	if ctx.cr[6].eq {
	pc = 0x82910110; continue 'dispatch;
	}
	// 82910074: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82910078: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8291007C: 4B8CA335  bl 0x821da3b0
	ctx.lr = 0x82910080;
	sub_821DA3B0(ctx, base);
	// 82910080: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82910084: 38EB57E4  addi r7, r11, 0x57e4
	ctx.r[7].s64 = ctx.r[11].s64 + 22500;
	// 82910088: 4B8A2471  bl 0x821b24f8
	ctx.lr = 0x8291008C;
	sub_821B24F8(ctx, base);
	// 8291008C: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 82910090: 4BA134B1  bl 0x82323540
	ctx.lr = 0x82910094;
	sub_82323540(ctx, base);
	// 82910094: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82910098: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8291009C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829100A0: 4B91CE31  bl 0x8222ced0
	ctx.lr = 0x829100A4;
	sub_8222CED0(ctx, base);
	// 829100A4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829100A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829100AC: 419A005C  beq cr6, 0x82910108
	if ctx.cr[6].eq {
	pc = 0x82910108; continue 'dispatch;
	}
	// 829100B0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829100B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829100B8: 419A0050  beq cr6, 0x82910108
	if ctx.cr[6].eq {
	pc = 0x82910108; continue 'dispatch;
	}
	// 829100BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829100C0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829100C4: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 829100C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829100CC: 4B91CE05  bl 0x8222ced0
	ctx.lr = 0x829100D0;
	sub_8222CED0(ctx, base);
	// 829100D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829100D4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829100D8: 4B9570D1  bl 0x822671a8
	ctx.lr = 0x829100DC;
	sub_822671A8(ctx, base);
	// 829100DC: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 829100E0: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 829100E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829100E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829100EC: 4B8C951D  bl 0x821d9608
	ctx.lr = 0x829100F0;
	sub_821D9608(ctx, base);
	// 829100F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829100F4: 482F5E05  bl 0x82c05ef8
	ctx.lr = 0x829100F8;
	sub_82C05EF8(ctx, base);
	// 829100F8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829100FC: 4B97994D  bl 0x82289a48
	ctx.lr = 0x82910100;
	sub_82289A48(ctx, base);
	// 82910100: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82910104: 4B904CD5  bl 0x82214dd8
	ctx.lr = 0x82910108;
	sub_82214DD8(ctx, base);
	pc = 0x82910108; continue 'dispatch;
            }
            0x82910108 => {
    //   block [0x82910108..0x82910110)
	// 82910108: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8291010C: 4B904CCD  bl 0x82214dd8
	ctx.lr = 0x82910110;
	sub_82214DD8(ctx, base);
	pc = 0x82910110; continue 'dispatch;
            }
            0x82910110 => {
    //   block [0x82910110..0x82910114)
	// 82910110: D3FD000C  stfs f31, 0xc(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x82910114; continue 'dispatch;
            }
            0x82910114 => {
    //   block [0x82910114..0x82910124)
	// 82910114: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82910118: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 8291011C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82910120: 4839933C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82910128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82910128 size=244
    let mut pc: u32 = 0x82910128;
    'dispatch: loop {
        match pc {
            0x82910128 => {
    //   block [0x82910128..0x8291021C)
	// 82910128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8291012C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82910130: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82910134: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82910138: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8291013C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82910140: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82910144: 3BCB57F8  addi r30, r11, 0x57f8
	ctx.r[30].s64 = ctx.r[11].s64 + 22520;
	// 82910148: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8291014C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82910150: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82910154: 4B91CD7D  bl 0x8222ced0
	ctx.lr = 0x82910158;
	sub_8222CED0(ctx, base);
	// 82910158: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8291015C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82910160: 480000C1  bl 0x82910220
	ctx.lr = 0x82910164;
	sub_82910220(ctx, base);
	// 82910164: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82910168: 4B904C71  bl 0x82214dd8
	ctx.lr = 0x8291016C;
	sub_82214DD8(ctx, base);
	// 8291016C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82910170: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82910174: 388AE244  addi r4, r10, -0x1dbc
	ctx.r[4].s64 = ctx.r[10].s64 + -7612;
	// 82910178: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8291017C: 4B91CD55  bl 0x8222ced0
	ctx.lr = 0x82910180;
	sub_8222CED0(ctx, base);
	// 82910180: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82910184: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82910188: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8291018C: 4B91CD45  bl 0x8222ced0
	ctx.lr = 0x82910190;
	sub_8222CED0(ctx, base);
	// 82910190: 3D208291  lis r9, -0x7d6f
	ctx.r[9].s64 = -2104426496;
	// 82910194: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82910198: 38C9F070  addi r6, r9, -0xf90
	ctx.r[6].s64 = ctx.r[9].s64 + -3984;
	// 8291019C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 829101A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829101A4: 480002C5  bl 0x82910468
	ctx.lr = 0x829101A8;
	sub_82910468(ctx, base);
	// 829101A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829101AC: 4B904C2D  bl 0x82214dd8
	ctx.lr = 0x829101B0;
	sub_82214DD8(ctx, base);
	// 829101B0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829101B4: 4B904C25  bl 0x82214dd8
	ctx.lr = 0x829101B8;
	sub_82214DD8(ctx, base);
	// 829101B8: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 829101BC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829101C0: 3888FF40  addi r4, r8, -0xc0
	ctx.r[4].s64 = ctx.r[8].s64 + -192;
	// 829101C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829101C8: 4B91CD09  bl 0x8222ced0
	ctx.lr = 0x829101CC;
	sub_8222CED0(ctx, base);
	// 829101CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829101D0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829101D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829101D8: 4B91CCF9  bl 0x8222ced0
	ctx.lr = 0x829101DC;
	sub_8222CED0(ctx, base);
	// 829101DC: 3CE08291  lis r7, -0x7d6f
	ctx.r[7].s64 = -2104426496;
	// 829101E0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829101E4: 38C7F078  addi r6, r7, -0xf88
	ctx.r[6].s64 = ctx.r[7].s64 + -3976;
	// 829101E8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 829101EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829101F0: 48000481  bl 0x82910670
	ctx.lr = 0x829101F4;
	sub_82910670(ctx, base);
	// 829101F4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829101F8: 4B904BE1  bl 0x82214dd8
	ctx.lr = 0x829101FC;
	sub_82214DD8(ctx, base);
	// 829101FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82910200: 4B904BD9  bl 0x82214dd8
	ctx.lr = 0x82910204;
	sub_82214DD8(ctx, base);
	// 82910204: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82910208: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8291020C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82910210: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82910214: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82910218: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82910220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82910220 size=584
    let mut pc: u32 = 0x82910220;
    'dispatch: loop {
        match pc {
            0x82910220 => {
    //   block [0x82910220..0x82910248)
	// 82910220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82910224: 483991DD  bl 0x82ca9400
	ctx.lr = 0x82910228;
	sub_82CA93D0(ctx, base);
	// 82910228: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8291022C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82910230: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82910234: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82910238: 409A0010  bne cr6, 0x82910248
	if !ctx.cr[6].eq {
	pc = 0x82910248; continue 'dispatch;
	}
	// 8291023C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82910240: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 82910244: 48000008  b 0x8291024c
	pc = 0x8291024C; continue 'dispatch;
            }
            0x82910248 => {
    //   block [0x82910248..0x8291024C)
	// 82910248: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8291024C; continue 'dispatch;
            }
            0x8291024C => {
    //   block [0x8291024C..0x829102C4)
	// 8291024C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82910250: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82910254: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82910258: 4BABE369  bl 0x823ce5c0
	ctx.lr = 0x8291025C;
	sub_823CE5C0(ctx, base);
	// 8291025C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82910260: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82910264: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82910268: 4BABDF99  bl 0x823ce200
	ctx.lr = 0x8291026C;
	sub_823CE200(ctx, base);
	// 8291026C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82910270: 4B8A78A9  bl 0x821b7b18
	ctx.lr = 0x82910274;
	sub_821B7B18(ctx, base);
	// 82910274: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82910278: 4B90EFE1  bl 0x8221f258
	ctx.lr = 0x8291027C;
	sub_8221F258(ctx, base);
	// 8291027C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82910280: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82910284: 419A0040  beq cr6, 0x829102c4
	if ctx.cr[6].eq {
	pc = 0x829102C4; continue 'dispatch;
	}
	// 82910288: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 8291028C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82910290: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 82910294: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82910298: 4B90EFC1  bl 0x8221f258
	ctx.lr = 0x8291029C;
	sub_8221F258(ctx, base);
	// 8291029C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829102A0: 419A0028  beq cr6, 0x829102c8
	if ctx.cr[6].eq {
	pc = 0x829102C8; continue 'dispatch;
	}
	// 829102A4: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 829102A8: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 829102AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829102B0: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 829102B4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829102B8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829102BC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 829102C0: 4800000C  b 0x829102cc
	pc = 0x829102CC; continue 'dispatch;
            }
            0x829102C4 => {
    //   block [0x829102C4..0x829102C8)
	// 829102C4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x829102C8; continue 'dispatch;
            }
            0x829102C8 => {
    //   block [0x829102C8..0x829102CC)
	// 829102C8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x829102CC; continue 'dispatch;
            }
            0x829102CC => {
    //   block [0x829102CC..0x829103D0)
	// 829102CC: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829102D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829102D4: 419A00FC  beq cr6, 0x829103d0
	if ctx.cr[6].eq {
	pc = 0x829103D0; continue 'dispatch;
	}
	// 829102D8: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829102DC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 829102E0: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829102E4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829102E8: 4B918E21  bl 0x82229108
	ctx.lr = 0x829102EC;
	sub_82229108(ctx, base);
	// 829102EC: 3D608291  lis r11, -0x7d6f
	ctx.r[11].s64 = -2104426496;
	// 829102F0: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 829102F4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829102F8: 3BCB0878  addi r30, r11, 0x878
	ctx.r[30].s64 = ctx.r[11].s64 + 2168;
	// 829102FC: 4B917585  bl 0x82227880
	ctx.lr = 0x82910300;
	sub_82227880(ctx, base);
	// 82910300: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82910304: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 82910308: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8291030C: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 82910310: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82910314: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82910318: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 8291031C: 4B88A765  bl 0x8219aa80
	ctx.lr = 0x82910320;
	sub_8219AA80(ctx, base);
	// 82910320: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82910324: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82910328: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 8291032C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82910330: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82910334: 4BABE0ED  bl 0x823ce420
	ctx.lr = 0x82910338;
	sub_823CE420(ctx, base);
	// 82910338: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8291033C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 82910340: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82910344: 48114385  bl 0x82a246c8
	ctx.lr = 0x82910348;
	sub_82A246C8(ctx, base);
	// 82910348: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 8291034C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 82910350: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 82910354: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82910358: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8291035C: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82910360: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82910364: 4B918DA5  bl 0x82229108
	ctx.lr = 0x82910368;
	sub_82229108(ctx, base);
	// 82910368: 3D608232  lis r11, -0x7dce
	ctx.r[11].s64 = -2110652416;
	// 8291036C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82910370: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82910374: 3BEB6D30  addi r31, r11, 0x6d30
	ctx.r[31].s64 = ctx.r[11].s64 + 27952;
	// 82910378: 4B917509  bl 0x82227880
	ctx.lr = 0x8291037C;
	sub_82227880(ctx, base);
	// 8291037C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82910380: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 82910384: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82910388: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 8291038C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82910390: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82910394: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82910398: 4B88A6E9  bl 0x8219aa80
	ctx.lr = 0x8291039C;
	sub_8219AA80(ctx, base);
	// 8291039C: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 829103A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829103A4: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 829103A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829103AC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829103B0: 4BABE071  bl 0x823ce420
	ctx.lr = 0x829103B4;
	sub_823CE420(ctx, base);
	// 829103B4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829103B8: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 829103BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829103C0: 48114309  bl 0x82a246c8
	ctx.lr = 0x829103C4;
	sub_82A246C8(ctx, base);
	// 829103C4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829103C8: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 829103CC: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	pc = 0x829103D0; continue 'dispatch;
            }
            0x829103D0 => {
    //   block [0x829103D0..0x829103E0)
	// 829103D0: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 829103D4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829103D8: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 829103DC: 419A0020  beq cr6, 0x829103fc
	if ctx.cr[6].eq {
	pc = 0x829103FC; continue 'dispatch;
	}
	pc = 0x829103E0; continue 'dispatch;
            }
            0x829103E0 => {
    //   block [0x829103E0..0x829103FC)
	// 829103E0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 829103E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829103E8: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 829103EC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829103F0: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829103F4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829103F8: 4082FFE8  bne 0x829103e0
	if !ctx.cr[0].eq {
	pc = 0x829103E0; continue 'dispatch;
	}
	pc = 0x829103FC; continue 'dispatch;
            }
            0x829103FC => {
    //   block [0x829103FC..0x8291041C)
	// 829103FC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82910400: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82910404: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 82910408: 4B9E5541  bl 0x822f5948
	ctx.lr = 0x8291040C;
	sub_822F5948(ctx, base);
	// 8291040C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82910410: 4B8A7709  bl 0x821b7b18
	ctx.lr = 0x82910414;
	sub_821B7B18(ctx, base);
	// 82910414: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82910418: 419A0040  beq cr6, 0x82910458
	if ctx.cr[6].eq {
	pc = 0x82910458; continue 'dispatch;
	}
	pc = 0x8291041C; continue 'dispatch;
            }
            0x8291041C => {
    //   block [0x8291041C..0x82910458)
	// 8291041C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82910420: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82910424: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82910428: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8291042C: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82910430: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82910434: 4082FFE8  bne 0x8291041c
	if !ctx.cr[0].eq {
	pc = 0x8291041C; continue 'dispatch;
	}
	// 82910438: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8291043C: 409A001C  bne cr6, 0x82910458
	if !ctx.cr[6].eq {
	pc = 0x82910458; continue 'dispatch;
	}
	// 82910440: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82910444: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82910448: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8291044C: 4E800421  bctrl
	ctx.lr = 0x82910450;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82910450: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82910454: 4B90B8E5  bl 0x8221bd38
	ctx.lr = 0x82910458;
	sub_8221BD38(ctx, base);
            }
            0x82910458 => {
    //   block [0x82910458..0x82910468)
	// 82910458: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8291045C: 4B8A76BD  bl 0x821b7b18
	ctx.lr = 0x82910460;
	sub_821B7B18(ctx, base);
	// 82910460: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82910464: 48398FEC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82910468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82910468 size=516
    let mut pc: u32 = 0x82910468;
    'dispatch: loop {
        match pc {
            0x82910468 => {
    //   block [0x82910468..0x829104A4)
	// 82910468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8291046C: 48398F91  bl 0x82ca93fc
	ctx.lr = 0x82910470;
	sub_82CA93D0(ctx, base);
	// 82910470: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82910474: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82910478: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 8291047C: 3D408291  lis r10, -0x7d6f
	ctx.r[10].s64 = -2104426496;
	// 82910480: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 82910484: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82910488: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8291048C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82910490: 3BAAF070  addi r29, r10, -0xf90
	ctx.r[29].s64 = ctx.r[10].s64 + -3984;
	// 82910494: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82910498: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 8291049C: 419A0008  beq cr6, 0x829104a4
	if ctx.cr[6].eq {
	pc = 0x829104A4; continue 'dispatch;
	}
	// 829104A0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829104A4; continue 'dispatch;
            }
            0x829104A4 => {
    //   block [0x829104A4..0x82910538)
	// 829104A4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829104A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829104AC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829104B0: 4BABE111  bl 0x823ce5c0
	ctx.lr = 0x829104B4;
	sub_823CE5C0(ctx, base);
	// 829104B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829104B8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829104BC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829104C0: 4BABDC51  bl 0x823ce110
	ctx.lr = 0x829104C4;
	sub_823CE110(ctx, base);
	// 829104C4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829104C8: 4B8A7651  bl 0x821b7b18
	ctx.lr = 0x829104CC;
	sub_821B7B18(ctx, base);
	// 829104CC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829104D0: 4B90ED89  bl 0x8221f258
	ctx.lr = 0x829104D4;
	sub_8221F258(ctx, base);
	// 829104D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829104D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829104DC: 419A005C  beq cr6, 0x82910538
	if ctx.cr[6].eq {
	pc = 0x82910538; continue 'dispatch;
	}
	// 829104E0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 829104E4: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 829104E8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829104EC: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 829104F0: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829104F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829104F8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829104FC: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82910500: 4B8DFD41  bl 0x821f0240
	ctx.lr = 0x82910504;
	sub_821F0240(ctx, base);
	// 82910504: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82910508: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 8291050C: 4B90ED4D  bl 0x8221f258
	ctx.lr = 0x82910510;
	sub_8221F258(ctx, base);
	// 82910510: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82910514: 419A0028  beq cr6, 0x8291053c
	if ctx.cr[6].eq {
	pc = 0x8291053C; continue 'dispatch;
	}
	// 82910518: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 8291051C: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82910520: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82910524: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 82910528: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8291052C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82910530: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82910534: 4800000C  b 0x82910540
	pc = 0x82910540; continue 'dispatch;
            }
            0x82910538 => {
    //   block [0x82910538..0x8291053C)
	// 82910538: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x8291053C; continue 'dispatch;
            }
            0x8291053C => {
    //   block [0x8291053C..0x82910540)
	// 8291053C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82910540; continue 'dispatch;
            }
            0x82910540 => {
    //   block [0x82910540..0x82910554)
	// 82910540: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82910544: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82910548: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8291054C: 419A0008  beq cr6, 0x82910554
	if ctx.cr[6].eq {
	pc = 0x82910554; continue 'dispatch;
	}
	// 82910550: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82910554; continue 'dispatch;
            }
            0x82910554 => {
    //   block [0x82910554..0x829105D4)
	// 82910554: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82910558: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8291055C: 419A0078  beq cr6, 0x829105d4
	if ctx.cr[6].eq {
	pc = 0x829105D4; continue 'dispatch;
	}
	// 82910560: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82910564: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 82910568: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8291056C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82910570: 4B918B99  bl 0x82229108
	ctx.lr = 0x82910574;
	sub_82229108(ctx, base);
	// 82910574: 3D608291  lis r11, -0x7d6f
	ctx.r[11].s64 = -2104426496;
	// 82910578: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8291057C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82910580: 3BCB08B8  addi r30, r11, 0x8b8
	ctx.r[30].s64 = ctx.r[11].s64 + 2232;
	// 82910584: 4B9172FD  bl 0x82227880
	ctx.lr = 0x82910588;
	sub_82227880(ctx, base);
	// 82910588: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8291058C: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 82910590: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82910594: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 82910598: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8291059C: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 829105A0: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829105A4: 4B88A4DD  bl 0x8219aa80
	ctx.lr = 0x829105A8;
	sub_8219AA80(ctx, base);
	// 829105A8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829105AC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829105B0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829105B4: 4BABDE6D  bl 0x823ce420
	ctx.lr = 0x829105B8;
	sub_823CE420(ctx, base);
	// 829105B8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829105BC: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 829105C0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829105C4: 48114105  bl 0x82a246c8
	ctx.lr = 0x829105C8;
	sub_82A246C8(ctx, base);
	// 829105C8: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 829105CC: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 829105D0: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x829105D4; continue 'dispatch;
            }
            0x829105D4 => {
    //   block [0x829105D4..0x829105E4)
	// 829105D4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829105D8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829105DC: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 829105E0: 419A0020  beq cr6, 0x82910600
	if ctx.cr[6].eq {
	pc = 0x82910600; continue 'dispatch;
	}
	pc = 0x829105E4; continue 'dispatch;
            }
            0x829105E4 => {
    //   block [0x829105E4..0x82910600)
	// 829105E4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 829105E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829105EC: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 829105F0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829105F4: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829105F8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829105FC: 4082FFE8  bne 0x829105e4
	if !ctx.cr[0].eq {
	pc = 0x829105E4; continue 'dispatch;
	}
	pc = 0x82910600; continue 'dispatch;
            }
            0x82910600 => {
    //   block [0x82910600..0x82910620)
	// 82910600: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82910604: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82910608: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 8291060C: 4B9E533D  bl 0x822f5948
	ctx.lr = 0x82910610;
	sub_822F5948(ctx, base);
	// 82910610: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82910614: 4B8A7505  bl 0x821b7b18
	ctx.lr = 0x82910618;
	sub_821B7B18(ctx, base);
	// 82910618: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8291061C: 419A0040  beq cr6, 0x8291065c
	if ctx.cr[6].eq {
	pc = 0x8291065C; continue 'dispatch;
	}
	pc = 0x82910620; continue 'dispatch;
            }
            0x82910620 => {
    //   block [0x82910620..0x8291065C)
	// 82910620: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82910624: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82910628: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8291062C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82910630: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82910634: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82910638: 4082FFE8  bne 0x82910620
	if !ctx.cr[0].eq {
	pc = 0x82910620; continue 'dispatch;
	}
	// 8291063C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82910640: 409A001C  bne cr6, 0x8291065c
	if !ctx.cr[6].eq {
	pc = 0x8291065C; continue 'dispatch;
	}
	// 82910644: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82910648: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8291064C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82910650: 4E800421  bctrl
	ctx.lr = 0x82910654;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82910654: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82910658: 4B90B6E1  bl 0x8221bd38
	ctx.lr = 0x8291065C;
	sub_8221BD38(ctx, base);
            }
            0x8291065C => {
    //   block [0x8291065C..0x8291066C)
	// 8291065C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82910660: 4B8A74B9  bl 0x821b7b18
	ctx.lr = 0x82910664;
	sub_821B7B18(ctx, base);
	// 82910664: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82910668: 48398DE4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82910670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82910670 size=516
    let mut pc: u32 = 0x82910670;
    'dispatch: loop {
        match pc {
            0x82910670 => {
    //   block [0x82910670..0x829106AC)
	// 82910670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82910674: 48398D89  bl 0x82ca93fc
	ctx.lr = 0x82910678;
	sub_82CA93D0(ctx, base);
	// 82910678: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8291067C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82910680: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 82910684: 3D408291  lis r10, -0x7d6f
	ctx.r[10].s64 = -2104426496;
	// 82910688: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 8291068C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82910690: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82910694: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82910698: 3BAAF078  addi r29, r10, -0xf88
	ctx.r[29].s64 = ctx.r[10].s64 + -3976;
	// 8291069C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829106A0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 829106A4: 419A0008  beq cr6, 0x829106ac
	if ctx.cr[6].eq {
	pc = 0x829106AC; continue 'dispatch;
	}
	// 829106A8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829106AC; continue 'dispatch;
            }
            0x829106AC => {
    //   block [0x829106AC..0x82910740)
	// 829106AC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829106B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829106B4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829106B8: 4BABDF09  bl 0x823ce5c0
	ctx.lr = 0x829106BC;
	sub_823CE5C0(ctx, base);
	// 829106BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829106C0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829106C4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829106C8: 4BABDA49  bl 0x823ce110
	ctx.lr = 0x829106CC;
	sub_823CE110(ctx, base);
	// 829106CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829106D0: 4B8A7449  bl 0x821b7b18
	ctx.lr = 0x829106D4;
	sub_821B7B18(ctx, base);
	// 829106D4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829106D8: 4B90EB81  bl 0x8221f258
	ctx.lr = 0x829106DC;
	sub_8221F258(ctx, base);
	// 829106DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829106E0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829106E4: 419A005C  beq cr6, 0x82910740
	if ctx.cr[6].eq {
	pc = 0x82910740; continue 'dispatch;
	}
	// 829106E8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 829106EC: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 829106F0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829106F4: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 829106F8: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829106FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82910700: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82910704: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82910708: 4B8DFB39  bl 0x821f0240
	ctx.lr = 0x8291070C;
	sub_821F0240(ctx, base);
	// 8291070C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82910710: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82910714: 4B90EB45  bl 0x8221f258
	ctx.lr = 0x82910718;
	sub_8221F258(ctx, base);
	// 82910718: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8291071C: 419A0028  beq cr6, 0x82910744
	if ctx.cr[6].eq {
	pc = 0x82910744; continue 'dispatch;
	}
	// 82910720: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 82910724: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82910728: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8291072C: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 82910730: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82910734: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82910738: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8291073C: 4800000C  b 0x82910748
	pc = 0x82910748; continue 'dispatch;
            }
            0x82910740 => {
    //   block [0x82910740..0x82910744)
	// 82910740: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x82910744; continue 'dispatch;
            }
            0x82910744 => {
    //   block [0x82910744..0x82910748)
	// 82910744: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82910748; continue 'dispatch;
            }
            0x82910748 => {
    //   block [0x82910748..0x8291075C)
	// 82910748: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8291074C: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82910750: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82910754: 419A0008  beq cr6, 0x8291075c
	if ctx.cr[6].eq {
	pc = 0x8291075C; continue 'dispatch;
	}
	// 82910758: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8291075C; continue 'dispatch;
            }
            0x8291075C => {
    //   block [0x8291075C..0x829107DC)
	// 8291075C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82910760: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82910764: 419A0078  beq cr6, 0x829107dc
	if ctx.cr[6].eq {
	pc = 0x829107DC; continue 'dispatch;
	}
	// 82910768: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8291076C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 82910770: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82910774: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82910778: 4B918991  bl 0x82229108
	ctx.lr = 0x8291077C;
	sub_82229108(ctx, base);
	// 8291077C: 3D608291  lis r11, -0x7d6f
	ctx.r[11].s64 = -2104426496;
	// 82910780: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82910784: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82910788: 3BCB0A30  addi r30, r11, 0xa30
	ctx.r[30].s64 = ctx.r[11].s64 + 2608;
	// 8291078C: 4B9170F5  bl 0x82227880
	ctx.lr = 0x82910790;
	sub_82227880(ctx, base);
	// 82910790: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82910794: 3D40827C  lis r10, -0x7d84
	ctx.r[10].s64 = -2105802752;
	// 82910798: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8291079C: 388AD6C8  addi r4, r10, -0x2938
	ctx.r[4].s64 = ctx.r[10].s64 + -10552;
	// 829107A0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829107A4: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 829107A8: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829107AC: 4B88A2D5  bl 0x8219aa80
	ctx.lr = 0x829107B0;
	sub_8219AA80(ctx, base);
	// 829107B0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829107B4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829107B8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829107BC: 4BABDC65  bl 0x823ce420
	ctx.lr = 0x829107C0;
	sub_823CE420(ctx, base);
	// 829107C0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829107C4: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 829107C8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829107CC: 48113EFD  bl 0x82a246c8
	ctx.lr = 0x829107D0;
	sub_82A246C8(ctx, base);
	// 829107D0: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 829107D4: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 829107D8: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x829107DC; continue 'dispatch;
            }
            0x829107DC => {
    //   block [0x829107DC..0x829107EC)
	// 829107DC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829107E0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829107E4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 829107E8: 419A0020  beq cr6, 0x82910808
	if ctx.cr[6].eq {
	pc = 0x82910808; continue 'dispatch;
	}
	pc = 0x829107EC; continue 'dispatch;
            }
            0x829107EC => {
    //   block [0x829107EC..0x82910808)
	// 829107EC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 829107F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829107F4: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 829107F8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829107FC: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82910800: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82910804: 4082FFE8  bne 0x829107ec
	if !ctx.cr[0].eq {
	pc = 0x829107EC; continue 'dispatch;
	}
	pc = 0x82910808; continue 'dispatch;
            }
            0x82910808 => {
    //   block [0x82910808..0x82910828)
	// 82910808: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 8291080C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82910810: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 82910814: 4B9E5135  bl 0x822f5948
	ctx.lr = 0x82910818;
	sub_822F5948(ctx, base);
	// 82910818: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8291081C: 4B8A72FD  bl 0x821b7b18
	ctx.lr = 0x82910820;
	sub_821B7B18(ctx, base);
	// 82910820: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82910824: 419A0040  beq cr6, 0x82910864
	if ctx.cr[6].eq {
	pc = 0x82910864; continue 'dispatch;
	}
	pc = 0x82910828; continue 'dispatch;
            }
            0x82910828 => {
    //   block [0x82910828..0x82910864)
	// 82910828: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8291082C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82910830: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82910834: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82910838: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8291083C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82910840: 4082FFE8  bne 0x82910828
	if !ctx.cr[0].eq {
	pc = 0x82910828; continue 'dispatch;
	}
	// 82910844: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82910848: 409A001C  bne cr6, 0x82910864
	if !ctx.cr[6].eq {
	pc = 0x82910864; continue 'dispatch;
	}
	// 8291084C: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82910850: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82910854: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82910858: 4E800421  bctrl
	ctx.lr = 0x8291085C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8291085C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82910860: 4B90B4D9  bl 0x8221bd38
	ctx.lr = 0x82910864;
	sub_8221BD38(ctx, base);
            }
            0x82910864 => {
    //   block [0x82910864..0x82910874)
	// 82910864: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82910868: 4B8A72B1  bl 0x821b7b18
	ctx.lr = 0x8291086C;
	sub_821B7B18(ctx, base);
	// 8291086C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82910870: 48398BDC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82910878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82910878 size=56
    let mut pc: u32 = 0x82910878;
    'dispatch: loop {
        match pc {
            0x82910878 => {
    //   block [0x82910878..0x82910894)
	// 82910878: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8291087C: 419A0018  beq cr6, 0x82910894
	if ctx.cr[6].eq {
	pc = 0x82910894; continue 'dispatch;
	}
	// 82910880: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 82910884: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82910888: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8291088C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82910890: 409A0008  bne cr6, 0x82910898
	if !ctx.cr[6].eq {
	pc = 0x82910898; continue 'dispatch;
	}
	pc = 0x82910894; continue 'dispatch;
            }
            0x82910894 => {
    //   block [0x82910894..0x82910898)
	// 82910894: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82910898; continue 'dispatch;
            }
            0x82910898 => {
    //   block [0x82910898..0x829108B0)
	// 82910898: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8291089C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829108A0: 419A0010  beq cr6, 0x829108b0
	if ctx.cr[6].eq {
		sub_829108B0(ctx, base);
		return;
	}
	// 829108A4: 81640038  lwz r11, 0x38(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(56 as u32) ) } as u64;
	// 829108A8: 5563A7FE  rlwinm r3, r11, 0x14, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x00000FFFu64;
	// 829108AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829108B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829108B0 size=8
    let mut pc: u32 = 0x829108B0;
    'dispatch: loop {
        match pc {
            0x829108B0 => {
    //   block [0x829108B0..0x829108B8)
	// 829108B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829108B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829108B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829108B8 size=372
    let mut pc: u32 = 0x829108B8;
    'dispatch: loop {
        match pc {
            0x829108B8 => {
    //   block [0x829108B8..0x829108E0)
	// 829108B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829108BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829108C0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829108C4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 829108C8: 419A0018  beq cr6, 0x829108e0
	if ctx.cr[6].eq {
	pc = 0x829108E0; continue 'dispatch;
	}
	// 829108CC: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 829108D0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829108D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829108D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829108DC: 409A0008  bne cr6, 0x829108e4
	if !ctx.cr[6].eq {
	pc = 0x829108E4; continue 'dispatch;
	}
	pc = 0x829108E0; continue 'dispatch;
            }
            0x829108E0 => {
    //   block [0x829108E0..0x829108E4)
	// 829108E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829108E4; continue 'dispatch;
            }
            0x829108E4 => {
    //   block [0x829108E4..0x8291092C)
	// 829108E4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829108E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829108EC: 419A012C  beq cr6, 0x82910a18
	if ctx.cr[6].eq {
	pc = 0x82910A18; continue 'dispatch;
	}
	// 829108F0: 81440038  lwz r10, 0x38(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(56 as u32) ) } as u64;
	// 829108F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829108F8: 5549A7FE  rlwinm r9, r10, 0x14, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000FFFu64;
	// 829108FC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82910900: 419A00E8  beq cr6, 0x829109e8
	if ctx.cr[6].eq {
	pc = 0x829109E8; continue 'dispatch;
	}
	// 82910904: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 82910908: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 8291090C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82910910: 419A001C  beq cr6, 0x8291092c
	if ctx.cr[6].eq {
	pc = 0x8291092C; continue 'dispatch;
	}
	// 82910914: 896B00AC  lbz r11, 0xac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(172 as u32) ) } as u64;
	// 82910918: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 8291091C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82910920: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82910924: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82910928: 480000C4  b 0x829109ec
	pc = 0x829109EC; continue 'dispatch;
            }
            0x8291092C => {
    //   block [0x8291092C..0x82910948)
	// 8291092C: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 82910930: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82910934: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82910938: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8291093C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82910940: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82910944: 40810054  ble 0x82910998
	if !ctx.cr[0].gt {
	pc = 0x82910998; continue 'dispatch;
	}
	pc = 0x82910948; continue 'dispatch;
            }
            0x82910948 => {
    //   block [0x82910948..0x82910968)
	// 82910948: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8291094C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82910950: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82910954: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82910958: 2F0700AC  cmpwi cr6, r7, 0xac
	ctx.cr[6].compare_i32(ctx.r[7].s32, 172, &mut ctx.xer);
	// 8291095C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82910960: 41980008  blt cr6, 0x82910968
	if ctx.cr[6].lt {
	pc = 0x82910968; continue 'dispatch;
	}
	// 82910964: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x82910968; continue 'dispatch;
            }
            0x82910968 => {
    //   block [0x82910968..0x82910984)
	// 82910968: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8291096C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82910970: 419A0014  beq cr6, 0x82910984
	if ctx.cr[6].eq {
	pc = 0x82910984; continue 'dispatch;
	}
	// 82910974: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82910978: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8291097C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82910980: 4800000C  b 0x8291098c
	pc = 0x8291098C; continue 'dispatch;
            }
            0x82910984 => {
    //   block [0x82910984..0x8291098C)
	// 82910984: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82910988: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x8291098C; continue 'dispatch;
            }
            0x8291098C => {
    //   block [0x8291098C..0x82910998)
	// 8291098C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82910990: 4199FFB8  bgt cr6, 0x82910948
	if ctx.cr[6].gt {
	pc = 0x82910948; continue 'dispatch;
	}
	// 82910994: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82910998; continue 'dispatch;
            }
            0x82910998 => {
    //   block [0x82910998..0x829109B4)
	// 82910998: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8291099C: 419A003C  beq cr6, 0x829109d8
	if ctx.cr[6].eq {
	pc = 0x829109D8; continue 'dispatch;
	}
	// 829109A0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829109A4: 2F0B00AC  cmpwi cr6, r11, 0xac
	ctx.cr[6].compare_i32(ctx.r[11].s32, 172, &mut ctx.xer);
	// 829109A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829109AC: 41990008  bgt cr6, 0x829109b4
	if ctx.cr[6].gt {
	pc = 0x829109B4; continue 'dispatch;
	}
	// 829109B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829109B4; continue 'dispatch;
            }
            0x829109B4 => {
    //   block [0x829109B4..0x829109D8)
	// 829109B4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829109B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829109BC: 409A001C  bne cr6, 0x829109d8
	if !ctx.cr[6].eq {
	pc = 0x829109D8; continue 'dispatch;
	}
	// 829109C0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829109C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829109C8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829109CC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829109D0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829109D4: 48000018  b 0x829109ec
	pc = 0x829109EC; continue 'dispatch;
            }
            0x829109D8 => {
    //   block [0x829109D8..0x829109E8)
	// 829109D8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829109DC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829109E0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829109E4: 48000008  b 0x829109ec
	pc = 0x829109EC; continue 'dispatch;
            }
            0x829109E8 => {
    //   block [0x829109E8..0x829109EC)
	// 829109E8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x829109EC; continue 'dispatch;
            }
            0x829109EC => {
    //   block [0x829109EC..0x82910A18)
	// 829109EC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 829109F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829109F4: 419A0024  beq cr6, 0x82910a18
	if ctx.cr[6].eq {
	pc = 0x82910A18; continue 'dispatch;
	}
	// 829109F8: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 829109FC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82910A00: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82910A04: 4E800421  bctrl
	ctx.lr = 0x82910A08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82910A08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82910A0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82910A10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82910A14: 4E800020  blr
	return;
            }
            0x82910A18 => {
    //   block [0x82910A18..0x82910A2C)
	// 82910A18: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82910A1C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82910A20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82910A24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82910A28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82910A30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82910A30 size=376
    let mut pc: u32 = 0x82910A30;
    'dispatch: loop {
        match pc {
            0x82910A30 => {
    //   block [0x82910A30..0x82910A5C)
	// 82910A30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82910A34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82910A38: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82910A3C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82910A40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82910A44: 419A0018  beq cr6, 0x82910a5c
	if ctx.cr[6].eq {
	pc = 0x82910A5C; continue 'dispatch;
	}
	// 82910A48: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 82910A4C: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82910A50: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82910A54: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82910A58: 409A0008  bne cr6, 0x82910a60
	if !ctx.cr[6].eq {
	pc = 0x82910A60; continue 'dispatch;
	}
	pc = 0x82910A5C; continue 'dispatch;
            }
            0x82910A5C => {
    //   block [0x82910A5C..0x82910A60)
	// 82910A5C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82910A60; continue 'dispatch;
            }
            0x82910A60 => {
    //   block [0x82910A60..0x82910AAC)
	// 82910A60: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82910A64: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82910A68: 419A0130  beq cr6, 0x82910b98
	if ctx.cr[6].eq {
	pc = 0x82910B98; continue 'dispatch;
	}
	// 82910A6C: 812B0038  lwz r9, 0x38(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82910A70: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82910A74: 5528A7FE  rlwinm r8, r9, 0x14, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000FFFu64;
	// 82910A78: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82910A7C: 419A00F8  beq cr6, 0x82910b74
	if ctx.cr[6].eq {
	pc = 0x82910B74; continue 'dispatch;
	}
	// 82910A80: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82910A84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82910A88: 419A0024  beq cr6, 0x82910aac
	if ctx.cr[6].eq {
	pc = 0x82910AAC; continue 'dispatch;
	}
	// 82910A8C: 892A00AC  lbz r9, 0xac(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(172 as u32) ) } as u64;
	// 82910A90: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82910A94: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 82910A98: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82910A9C: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82910AA0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82910AA4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82910AA8: 480000D0  b 0x82910b78
	pc = 0x82910B78; continue 'dispatch;
            }
            0x82910AAC => {
    //   block [0x82910AAC..0x82910ACC)
	// 82910AAC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82910AB0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82910AB4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82910AB8: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82910ABC: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82910AC0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82910AC4: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82910AC8: 40810054  ble 0x82910b1c
	if !ctx.cr[0].gt {
	pc = 0x82910B1C; continue 'dispatch;
	}
	pc = 0x82910ACC; continue 'dispatch;
            }
            0x82910ACC => {
    //   block [0x82910ACC..0x82910AEC)
	// 82910ACC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82910AD0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82910AD4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82910AD8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82910ADC: 2F0700AC  cmpwi cr6, r7, 0xac
	ctx.cr[6].compare_i32(ctx.r[7].s32, 172, &mut ctx.xer);
	// 82910AE0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82910AE4: 41980008  blt cr6, 0x82910aec
	if ctx.cr[6].lt {
	pc = 0x82910AEC; continue 'dispatch;
	}
	// 82910AE8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x82910AEC; continue 'dispatch;
            }
            0x82910AEC => {
    //   block [0x82910AEC..0x82910B08)
	// 82910AEC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82910AF0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82910AF4: 419A0014  beq cr6, 0x82910b08
	if ctx.cr[6].eq {
	pc = 0x82910B08; continue 'dispatch;
	}
	// 82910AF8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82910AFC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82910B00: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82910B04: 4800000C  b 0x82910b10
	pc = 0x82910B10; continue 'dispatch;
            }
            0x82910B08 => {
    //   block [0x82910B08..0x82910B10)
	// 82910B08: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82910B0C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82910B10; continue 'dispatch;
            }
            0x82910B10 => {
    //   block [0x82910B10..0x82910B1C)
	// 82910B10: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82910B14: 4199FFB8  bgt cr6, 0x82910acc
	if ctx.cr[6].gt {
	pc = 0x82910ACC; continue 'dispatch;
	}
	// 82910B18: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82910B1C; continue 'dispatch;
            }
            0x82910B1C => {
    //   block [0x82910B1C..0x82910B38)
	// 82910B1C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82910B20: 419A0040  beq cr6, 0x82910b60
	if ctx.cr[6].eq {
	pc = 0x82910B60; continue 'dispatch;
	}
	// 82910B24: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82910B28: 2F0B00AC  cmpwi cr6, r11, 0xac
	ctx.cr[6].compare_i32(ctx.r[11].s32, 172, &mut ctx.xer);
	// 82910B2C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82910B30: 41990008  bgt cr6, 0x82910b38
	if ctx.cr[6].gt {
	pc = 0x82910B38; continue 'dispatch;
	}
	// 82910B34: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82910B38; continue 'dispatch;
            }
            0x82910B38 => {
    //   block [0x82910B38..0x82910B60)
	// 82910B38: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82910B3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82910B40: 409A0020  bne cr6, 0x82910b60
	if !ctx.cr[6].eq {
	pc = 0x82910B60; continue 'dispatch;
	}
	// 82910B44: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82910B48: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82910B4C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82910B50: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82910B54: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82910B58: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82910B5C: 4800001C  b 0x82910b78
	pc = 0x82910B78; continue 'dispatch;
            }
            0x82910B60 => {
    //   block [0x82910B60..0x82910B74)
	// 82910B60: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82910B64: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82910B68: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82910B6C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82910B70: 48000008  b 0x82910b78
	pc = 0x82910B78; continue 'dispatch;
            }
            0x82910B74 => {
    //   block [0x82910B74..0x82910B78)
	// 82910B74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82910B78; continue 'dispatch;
            }
            0x82910B78 => {
    //   block [0x82910B78..0x82910B98)
	// 82910B78: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82910B7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82910B80: 419A0018  beq cr6, 0x82910b98
	if ctx.cr[6].eq {
	pc = 0x82910B98; continue 'dispatch;
	}
	// 82910B84: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82910B88: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82910B8C: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82910B90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82910B94: 4E800421  bctrl
	ctx.lr = 0x82910B98;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82910B98 => {
    //   block [0x82910B98..0x82910BA8)
	// 82910B98: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82910B9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82910BA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82910BA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82910BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82910BA8 size=60
    let mut pc: u32 = 0x82910BA8;
    'dispatch: loop {
        match pc {
            0x82910BA8 => {
    //   block [0x82910BA8..0x82910BE4)
	// 82910BA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82910BAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82910BB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82910BB4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82910BB8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82910BBC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82910BC0: 388B9D6C  addi r4, r11, -0x6294
	ctx.r[4].s64 = ctx.r[11].s64 + -25236;
	// 82910BC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82910BC8: 4B91C309  bl 0x8222ced0
	ctx.lr = 0x82910BCC;
	sub_8222CED0(ctx, base);
	// 82910BCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82910BD0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82910BD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82910BD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82910BDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82910BE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82910BE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82910BE8 size=124
    let mut pc: u32 = 0x82910BE8;
    'dispatch: loop {
        match pc {
            0x82910BE8 => {
    //   block [0x82910BE8..0x82910C20)
	// 82910BE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82910BEC: 48398821  bl 0x82ca940c
	ctx.lr = 0x82910BF0;
	sub_82CA93D0(ctx, base);
	// 82910BF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82910BF4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82910BF8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82910BFC: 3BFE0014  addi r31, r30, 0x14
	ctx.r[31].s64 = ctx.r[30].s64 + 20;
	// 82910C00: 809E0018  lwz r4, 0x18(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82910C04: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82910C08: 419A0018  beq cr6, 0x82910c20
	if ctx.cr[6].eq {
	pc = 0x82910C20; continue 'dispatch;
	}
	// 82910C0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82910C10: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82910C14: 48000CFD  bl 0x82911910
	ctx.lr = 0x82910C18;
	sub_82911910(ctx, base);
	// 82910C18: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82910C1C: 4B90B11D  bl 0x8221bd38
	ctx.lr = 0x82910C20;
	sub_8221BD38(ctx, base);
	pc = 0x82910C20; continue 'dispatch;
            }
            0x82910C20 => {
    //   block [0x82910C20..0x82910C5C)
	// 82910C20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82910C24: 387E000C  addi r3, r30, 0xc
	ctx.r[3].s64 = ctx.r[30].s64 + 12;
	// 82910C28: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82910C2C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82910C30: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82910C34: 4B9041A5  bl 0x82214dd8
	ctx.lr = 0x82910C38;
	sub_82214DD8(ctx, base);
	// 82910C38: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82910C3C: 57AA07FE  clrlwi r10, r29, 0x1f
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	// 82910C40: 392B2850  addi r9, r11, 0x2850
	ctx.r[9].s64 = ctx.r[11].s64 + 10320;
	// 82910C44: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82910C48: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82910C4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82910C50: 419A000C  beq cr6, 0x82910c5c
	if ctx.cr[6].eq {
	pc = 0x82910C5C; continue 'dispatch;
	}
	// 82910C54: 4B90B0E5  bl 0x8221bd38
	ctx.lr = 0x82910C58;
	sub_8221BD38(ctx, base);
	// 82910C58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x82910C5C; continue 'dispatch;
            }
            0x82910C5C => {
    //   block [0x82910C5C..0x82910C64)
	// 82910C5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82910C60: 483987FC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82910C68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82910C68 size=880
    let mut pc: u32 = 0x82910C68;
    'dispatch: loop {
        match pc {
            0x82910C68 => {
    //   block [0x82910C68..0x82910D50)
	// 82910C68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82910C6C: 48398765  bl 0x82ca93d0
	ctx.lr = 0x82910C70;
	sub_82CA93D0(ctx, base);
	// 82910C70: DBE1FF60  stfd f31, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 82910C74: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82910C78: 3D60811C  lis r11, -0x7ee4
	ctx.r[11].s64 = -2128871424;
	// 82910C7C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82910C80: 617A9DC5  ori r26, r11, 0x9dc5
	ctx.r[26].u64 = ctx.r[11].u64 | 40389;
	// 82910C84: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82910C88: 7C721B78  mr r18, r3
	ctx.r[18].u64 = ctx.r[3].u64;
	// 82910C8C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82910C90: 93C1015C  stw r30, 0x15c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(348 as u32), ctx.r[30].u32 ) };
	// 82910C94: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82910C98: 386A2EB4  addi r3, r10, 0x2eb4
	ctx.r[3].s64 = ctx.r[10].s64 + 11956;
	// 82910C9C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82910CA0: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 82910CA4: 4B8E30B5  bl 0x821f3d58
	ctx.lr = 0x82910CA8;
	sub_821F3D58(ctx, base);
	// 82910CA8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82910CAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82910CB0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82910CB4: 4B8C40DD  bl 0x821d4d90
	ctx.lr = 0x82910CB8;
	sub_821D4D90(ctx, base);
	// 82910CB8: 3872000C  addi r3, r18, 0xc
	ctx.r[3].s64 = ctx.r[18].s64 + 12;
	// 82910CBC: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82910CC0: 4B964779  bl 0x82275438
	ctx.lr = 0x82910CC4;
	sub_82275438(ctx, base);
	// 82910CC4: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 82910CC8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82910CCC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82910CD0: 38695840  addi r3, r9, 0x5840
	ctx.r[3].s64 = ctx.r[9].s64 + 22592;
	// 82910CD4: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 82910CD8: 4B8E3081  bl 0x821f3d58
	ctx.lr = 0x82910CDC;
	sub_821F3D58(ctx, base);
	// 82910CDC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82910CE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82910CE4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82910CE8: 4B96AB39  bl 0x8227b820
	ctx.lr = 0x82910CEC;
	sub_8227B820(ctx, base);
	// 82910CEC: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82910CF0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82910CF4: 419A026C  beq cr6, 0x82910f60
	if ctx.cr[6].eq {
	pc = 0x82910F60; continue 'dispatch;
	}
	// 82910CF8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82910CFC: 480EFC95  bl 0x82a00990
	ctx.lr = 0x82910D00;
	sub_82A00990(ctx, base);
	// 82910D00: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82910D04: 83010070  lwz r24, 0x70(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82910D08: 7F185840  cmplw cr6, r24, r11
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82910D0C: 419A024C  beq cr6, 0x82910f58
	if ctx.cr[6].eq {
	pc = 0x82910F58; continue 'dispatch;
	}
	// 82910D10: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82910D14: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82910D18: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82910D1C: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 82910D20: 3CE0820E  lis r7, -0x7df2
	ctx.r[7].s64 = -2113011712;
	// 82910D24: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 82910D28: 3CA0820C  lis r5, -0x7df4
	ctx.r[5].s64 = -2113142784;
	// 82910D2C: 3E208349  lis r17, -0x7cb7
	ctx.r[17].s64 = -2092367872;
	// 82910D30: 3DE0834A  lis r15, -0x7cb6
	ctx.r[15].s64 = -2092302336;
	// 82910D34: 3B2B7088  addi r25, r11, 0x7088
	ctx.r[25].s64 = ctx.r[11].s64 + 28808;
	// 82910D38: 3A0AE460  addi r16, r10, -0x1ba0
	ctx.r[16].s64 = ctx.r[10].s64 + -7072;
	// 82910D3C: 3AE9A1D8  addi r23, r9, -0x5e28
	ctx.r[23].s64 = ctx.r[9].s64 + -24104;
	// 82910D40: 3A885864  addi r20, r8, 0x5864
	ctx.r[20].s64 = ctx.r[8].s64 + 22628;
	// 82910D44: 3A675858  addi r19, r7, 0x5858
	ctx.r[19].s64 = ctx.r[7].s64 + 22616;
	// 82910D48: 3AC65850  addi r22, r6, 0x5850
	ctx.r[22].s64 = ctx.r[6].s64 + 22608;
	// 82910D4C: 3AA5A9A0  addi r21, r5, -0x5660
	ctx.r[21].s64 = ctx.r[5].s64 + -22112;
	pc = 0x82910D50; continue 'dispatch;
            }
            0x82910D50 => {
    //   block [0x82910D50..0x82910D90)
	// 82910D50: 570B083C  slwi r11, r24, 1
	ctx.r[11].u32 = ctx.r[24].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82910D54: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82910D58: 7D385A14  add r9, r24, r11
	ctx.r[9].u64 = ctx.r[24].u64 + ctx.r[11].u64;
	// 82910D5C: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82910D60: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82910D64: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82910D68: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82910D6C: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 82910D70: 419A0020  beq cr6, 0x82910d90
	if ctx.cr[6].eq {
	pc = 0x82910D90; continue 'dispatch;
	}
	// 82910D74: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82910D78: 409A0018  bne cr6, 0x82910d90
	if !ctx.cr[6].eq {
	pc = 0x82910D90; continue 'dispatch;
	}
	// 82910D7C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82910D80: 812FE454  lwz r9, -0x1bac(r15)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 82910D84: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82910D88: 409A0008  bne cr6, 0x82910d90
	if !ctx.cr[6].eq {
	pc = 0x82910D90; continue 'dispatch;
	}
	// 82910D8C: 7E0A8378  mr r10, r16
	ctx.r[10].u64 = ctx.r[16].u64;
	pc = 0x82910D90; continue 'dispatch;
            }
            0x82910D90 => {
    //   block [0x82910D90..0x82910E18)
	// 82910D90: 80716DA0  lwz r3, 0x6da0(r17)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(28064 as u32) ) } as u64;
	// 82910D94: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82910D98: 4B8D34B9  bl 0x821e4250
	ctx.lr = 0x82910D9C;
	sub_821E4250(ctx, base);
	// 82910D9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82910DA0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82910DA4: 419A01A4  beq cr6, 0x82910f48
	if ctx.cr[6].eq {
	pc = 0x82910F48; continue 'dispatch;
	}
	// 82910DA8: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82910DAC: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 82910DB0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82910DB4: 3BC10054  addi r30, r1, 0x54
	ctx.r[30].s64 = ctx.r[1].s64 + 84;
	// 82910DB8: 4B8E2FA1  bl 0x821f3d58
	ctx.lr = 0x82910DBC;
	sub_821F3D58(ctx, base);
	// 82910DBC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82910DC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82910DC4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82910DC8: 4B8C3FC9  bl 0x821d4d90
	ctx.lr = 0x82910DCC;
	sub_821D4D90(ctx, base);
	// 82910DCC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82910DD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82910DD4: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82910DD8: 4B91C0F9  bl 0x8222ced0
	ctx.lr = 0x82910DDC;
	sub_8222CED0(ctx, base);
	// 82910DDC: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82910DE0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82910DE4: 7F9BE378  mr r27, r28
	ctx.r[27].u64 = ctx.r[28].u64;
	// 82910DE8: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 82910DEC: 4B8E2F6D  bl 0x821f3d58
	ctx.lr = 0x82910DF0;
	sub_821F3D58(ctx, base);
	// 82910DF0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82910DF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82910DF8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82910DFC: 4B8D4C0D  bl 0x821e5a08
	ctx.lr = 0x82910E00;
	sub_821E5A08(ctx, base);
	// 82910E00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82910E04: 419A0014  beq cr6, 0x82910e18
	if ctx.cr[6].eq {
	pc = 0x82910E18; continue 'dispatch;
	}
	// 82910E08: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82910E0C: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82910E10: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82910E14: 693B0001  xori r27, r9, 1
	ctx.r[27].u64 = ctx.r[9].u64 ^ 1;
	pc = 0x82910E18; continue 'dispatch;
            }
            0x82910E18 => {
    //   block [0x82910E18..0x82910E48)
	// 82910E18: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 82910E1C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82910E20: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82910E24: 3BC1005C  addi r30, r1, 0x5c
	ctx.r[30].s64 = ctx.r[1].s64 + 92;
	// 82910E28: 4B8E2F31  bl 0x821f3d58
	ctx.lr = 0x82910E2C;
	sub_821F3D58(ctx, base);
	// 82910E2C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82910E30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82910E34: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82910E38: 4B8D4BD1  bl 0x821e5a08
	ctx.lr = 0x82910E3C;
	sub_821E5A08(ctx, base);
	// 82910E3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82910E40: 419A0008  beq cr6, 0x82910e48
	if ctx.cr[6].eq {
	pc = 0x82910E48; continue 'dispatch;
	}
	// 82910E44: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82910E48; continue 'dispatch;
            }
            0x82910E48 => {
    //   block [0x82910E48..0x82910E78)
	// 82910E48: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 82910E4C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82910E50: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82910E54: 39C10060  addi r14, r1, 0x60
	ctx.r[14].s64 = ctx.r[1].s64 + 96;
	// 82910E58: 4B8E2F01  bl 0x821f3d58
	ctx.lr = 0x82910E5C;
	sub_821F3D58(ctx, base);
	// 82910E5C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82910E60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82910E64: 7DC57378  mr r5, r14
	ctx.r[5].u64 = ctx.r[14].u64;
	// 82910E68: 4B8D4BA1  bl 0x821e5a08
	ctx.lr = 0x82910E6C;
	sub_821E5A08(ctx, base);
	// 82910E6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82910E70: 419A0008  beq cr6, 0x82910e78
	if ctx.cr[6].eq {
	pc = 0x82910E78; continue 'dispatch;
	}
	// 82910E74: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82910E78; continue 'dispatch;
            }
            0x82910E78 => {
    //   block [0x82910E78..0x82910EC0)
	// 82910E78: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82910E7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82910E80: 4B885D01  bl 0x82196b80
	ctx.lr = 0x82910E84;
	sub_82196B80(ctx, base);
	// 82910E84: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82910E88: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82910E8C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82910E90: 4B8DF3B1  bl 0x821f0240
	ctx.lr = 0x82910E94;
	sub_821F0240(ctx, base);
	// 82910E94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82910E98: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82910E9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82910EA0: 4B8DF3A1  bl 0x821f0240
	ctx.lr = 0x82910EA4;
	sub_821F0240(ctx, base);
	// 82910EA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82910EA8: D3E10090  stfs f31, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82910EAC: 9B610084  stb r27, 0x84(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[27].u8 ) };
	// 82910EB0: 93A10088  stw r29, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[29].u32 ) };
	// 82910EB4: 93C1008C  stw r30, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[30].u32 ) };
	// 82910EB8: 4B8B58B1  bl 0x821c6768
	ctx.lr = 0x82910EBC;
	sub_821C6768(ctx, base);
	// 82910EBC: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	pc = 0x82910EC0; continue 'dispatch;
            }
            0x82910EC0 => {
    //   block [0x82910EC0..0x82910EF8)
	// 82910EC0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82910EC4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82910EC8: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82910ECC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82910ED0: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82910ED4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82910ED8: 4082FFE8  bne 0x82910ec0
	if !ctx.cr[0].eq {
	pc = 0x82910EC0; continue 'dispatch;
	}
	// 82910EDC: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82910EE0: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82910EE4: 38720014  addi r3, r18, 0x14
	ctx.r[3].s64 = ctx.r[18].s64 + 20;
	// 82910EE8: 480007F1  bl 0x829116d8
	ctx.lr = 0x82910EEC;
	sub_829116D8(ctx, base);
	// 82910EEC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82910EF0: 4B8B5879  bl 0x821c6768
	ctx.lr = 0x82910EF4;
	sub_821C6768(ctx, base);
	// 82910EF4: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	pc = 0x82910EF8; continue 'dispatch;
            }
            0x82910EF8 => {
    //   block [0x82910EF8..0x82910F24)
	// 82910EF8: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 82910EFC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82910F00: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 82910F04: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 82910F08: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82910F0C: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82910F10: 4082FFE8  bne 0x82910ef8
	if !ctx.cr[0].eq {
	pc = 0x82910EF8; continue 'dispatch;
	}
	// 82910F14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82910F18: 93810080  stw r28, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[28].u32 ) };
	// 82910F1C: 4B8B584D  bl 0x821c6768
	ctx.lr = 0x82910F20;
	sub_821C6768(ctx, base);
	// 82910F20: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	pc = 0x82910F24; continue 'dispatch;
            }
            0x82910F24 => {
    //   block [0x82910F24..0x82910F48)
	// 82910F24: 7C8000A6  mfmsr r4
	ctx.r[4].u64 = ctx.msr;
	// 82910F28: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82910F2C: 7CA01828  lwarx r5, 0, r3
	// lwarx
	let ea = ctx.r[3].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[5].u64 = ctx.reserved.u32 as u64;
	// 82910F30: 38A5FFFF  addi r5, r5, -1
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	// 82910F34: 7CA0192D  stwcx. r5, 0, r3
	// stwcx.
	let addr = ctx.r[3].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[5].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82910F38: 7C810164  mtmsrd r4, 1
	ctx.msr = (ctx.r[4].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82910F3C: 4082FFE8  bne 0x82910f24
	if !ctx.cr[0].eq {
	pc = 0x82910F24; continue 'dispatch;
	}
	// 82910F40: 83C1015C  lwz r30, 0x15c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(348 as u32) ) } as u64;
	// 82910F44: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	pc = 0x82910F48; continue 'dispatch;
            }
            0x82910F48 => {
    //   block [0x82910F48..0x82910F58)
	// 82910F48: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82910F4C: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 82910F50: 7F185840  cmplw cr6, r24, r11
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82910F54: 409AFDFC  bne cr6, 0x82910d50
	if !ctx.cr[6].eq {
	pc = 0x82910D50; continue 'dispatch;
	}
	pc = 0x82910F58; continue 'dispatch;
            }
            0x82910F58 => {
    //   block [0x82910F58..0x82910F60)
	// 82910F58: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82910F5C: 4B90ADDD  bl 0x8221bd38
	ctx.lr = 0x82910F60;
	sub_8221BD38(ctx, base);
	pc = 0x82910F60; continue 'dispatch;
            }
            0x82910F60 => {
    //   block [0x82910F60..0x82910FD8)
	// 82910F60: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82910F64: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82910F68: 386B5870  addi r3, r11, 0x5870
	ctx.r[3].s64 = ctx.r[11].s64 + 22640;
	// 82910F6C: 3BF20010  addi r31, r18, 0x10
	ctx.r[31].s64 = ctx.r[18].s64 + 16;
	// 82910F70: 4B8E2DE9  bl 0x821f3d58
	ctx.lr = 0x82910F74;
	sub_821F3D58(ctx, base);
	// 82910F74: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82910F78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82910F7C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82910F80: 480EF431  bl 0x82a003b0
	ctx.lr = 0x82910F84;
	sub_82A003B0(ctx, base);
	// 82910F84: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 82910F88: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82910F8C: 386A5880  addi r3, r10, 0x5880
	ctx.r[3].s64 = ctx.r[10].s64 + 22656;
	// 82910F90: 3BF20011  addi r31, r18, 0x11
	ctx.r[31].s64 = ctx.r[18].s64 + 17;
	// 82910F94: 4B8E2DC5  bl 0x821f3d58
	ctx.lr = 0x82910F98;
	sub_821F3D58(ctx, base);
	// 82910F98: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82910F9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82910FA0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82910FA4: 480EF40D  bl 0x82a003b0
	ctx.lr = 0x82910FA8;
	sub_82A003B0(ctx, base);
	// 82910FA8: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 82910FAC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82910FB0: 38695890  addi r3, r9, 0x5890
	ctx.r[3].s64 = ctx.r[9].s64 + 22672;
	// 82910FB4: 3BF20012  addi r31, r18, 0x12
	ctx.r[31].s64 = ctx.r[18].s64 + 18;
	// 82910FB8: 4B8E2DA1  bl 0x821f3d58
	ctx.lr = 0x82910FBC;
	sub_821F3D58(ctx, base);
	// 82910FBC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82910FC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82910FC4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82910FC8: 480EF3E9  bl 0x82a003b0
	ctx.lr = 0x82910FCC;
	sub_82A003B0(ctx, base);
	// 82910FCC: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 82910FD0: CBE1FF60  lfd f31, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 82910FD4: 4839844C  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82910FD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82910FD8 size=1060
    let mut pc: u32 = 0x82910FD8;
    'dispatch: loop {
        match pc {
            0x82910FD8 => {
    //   block [0x82910FD8..0x82911010)
	// 82910FD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82910FDC: 48398425  bl 0x82ca9400
	ctx.lr = 0x82910FE0;
	sub_82CA93D0(ctx, base);
	// 82910FE0: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82910FE4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82910FE8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82910FEC: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82910FF0: 8123001C  lwz r9, 0x1c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82910FF4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82910FF8: 3B630014  addi r27, r3, 0x14
	ctx.r[27].s64 = ctx.r[3].s64 + 20;
	// 82910FFC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82911000: C3EA9484  lfs f31, -0x6b7c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82911004: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82911008: 40990008  ble cr6, 0x82911010
	if !ctx.cr[6].gt {
	pc = 0x82911010; continue 'dispatch;
	}
	// 8291100C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82911010; continue 'dispatch;
            }
            0x82911010 => {
    //   block [0x82911010..0x82911018)
	// 82911010: 811B0004  lwz r8, 4(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82911014: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82911018; continue 'dispatch;
            }
            0x82911018 => {
    //   block [0x82911018..0x82911024)
	// 82911018: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8291101C: 40990008  ble cr6, 0x82911024
	if !ctx.cr[6].gt {
	pc = 0x82911024; continue 'dispatch;
	}
	// 82911020: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82911024; continue 'dispatch;
            }
            0x82911024 => {
    //   block [0x82911024..0x82911030)
	// 82911024: 7F1BD840  cmplw cr6, r27, r27
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82911028: 419A0008  beq cr6, 0x82911030
	if ctx.cr[6].eq {
	pc = 0x82911030; continue 'dispatch;
	}
	// 8291102C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82911030; continue 'dispatch;
            }
            0x82911030 => {
    //   block [0x82911030..0x82911044)
	// 82911030: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82911034: 419A002C  beq cr6, 0x82911060
	if ctx.cr[6].eq {
	pc = 0x82911060; continue 'dispatch;
	}
	// 82911038: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8291103C: 41980008  blt cr6, 0x82911044
	if ctx.cr[6].lt {
	pc = 0x82911044; continue 'dispatch;
	}
	// 82911040: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82911044; continue 'dispatch;
            }
            0x82911044 => {
    //   block [0x82911044..0x82911058)
	// 82911044: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82911048: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8291104C: EC20082A  fadds f1, f0, f1
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	// 82911050: 41980008  blt cr6, 0x82911058
	if ctx.cr[6].lt {
	pc = 0x82911058; continue 'dispatch;
	}
	// 82911054: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82911058; continue 'dispatch;
            }
            0x82911058 => {
    //   block [0x82911058..0x82911060)
	// 82911058: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 8291105C: 4BFFFFBC  b 0x82911018
	pc = 0x82911018; continue 'dispatch;
            }
            0x82911060 => {
    //   block [0x82911060..0x82911090)
	// 82911060: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82911064: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 82911068: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8291106C: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 82911070: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82911074: 388B0078  addi r4, r11, 0x78
	ctx.r[4].s64 = ctx.r[11].s64 + 120;
	// 82911078: 4B8DF951  bl 0x821f09c8
	ctx.lr = 0x8291107C;
	sub_821F09C8(ctx, base);
	// 8291107C: 83DB0004  lwz r30, 4(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82911080: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82911084: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82911088: 40990008  ble cr6, 0x82911090
	if !ctx.cr[6].gt {
	pc = 0x82911090; continue 'dispatch;
	}
	// 8291108C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82911090; continue 'dispatch;
            }
            0x82911090 => {
    //   block [0x82911090..0x82911098)
	// 82911090: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82911094: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82911098; continue 'dispatch;
            }
            0x82911098 => {
    //   block [0x82911098..0x829110A4)
	// 82911098: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8291109C: 40990008  ble cr6, 0x829110a4
	if !ctx.cr[6].gt {
	pc = 0x829110A4; continue 'dispatch;
	}
	// 829110A0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829110A4; continue 'dispatch;
            }
            0x829110A4 => {
    //   block [0x829110A4..0x829110B0)
	// 829110A4: 7F1BD840  cmplw cr6, r27, r27
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[27].u32, &mut ctx.xer);
	// 829110A8: 419A0008  beq cr6, 0x829110b0
	if ctx.cr[6].eq {
	pc = 0x829110B0; continue 'dispatch;
	}
	// 829110AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829110B0; continue 'dispatch;
            }
            0x829110B0 => {
    //   block [0x829110B0..0x829110C4)
	// 829110B0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829110B4: 419A0338  beq cr6, 0x829113ec
	if ctx.cr[6].eq {
	pc = 0x829113EC; continue 'dispatch;
	}
	// 829110B8: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829110BC: 41980008  blt cr6, 0x829110c4
	if ctx.cr[6].lt {
	pc = 0x829110C4; continue 'dispatch;
	}
	// 829110C0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829110C4; continue 'dispatch;
            }
            0x829110C4 => {
    //   block [0x829110C4..0x829110E0)
	// 829110C4: C01E0010  lfs f0, 0x10(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829110C8: EC210028  fsubs f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 829110CC: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 829110D0: 41980018  blt cr6, 0x829110e8
	if ctx.cr[6].lt {
	pc = 0x829110E8; continue 'dispatch;
	}
	// 829110D4: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829110D8: 41980008  blt cr6, 0x829110e0
	if ctx.cr[6].lt {
	pc = 0x829110E0; continue 'dispatch;
	}
	// 829110DC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829110E0; continue 'dispatch;
            }
            0x829110E0 => {
    //   block [0x829110E0..0x829110E8)
	// 829110E0: 3BDE0014  addi r30, r30, 0x14
	ctx.r[30].s64 = ctx.r[30].s64 + 20;
	// 829110E4: 4BFFFFB4  b 0x82911098
	pc = 0x82911098; continue 'dispatch;
            }
            0x829110E8 => {
    //   block [0x829110E8..0x82911104)
	// 829110E8: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 829110EC: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 829110F0: 812B0040  lwz r9, 0x40(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 829110F4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 829110F8: 4198000C  blt cr6, 0x82911104
	if ctx.cr[6].lt {
	pc = 0x82911104; continue 'dispatch;
	}
	// 829110FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82911100: 4B868481  bl 0x82179580
	ctx.lr = 0x82911104;
	sub_82179580(ctx, base);
	pc = 0x82911104; continue 'dispatch;
            }
            0x82911104 => {
    //   block [0x82911104..0x8291114C)
	// 82911104: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82911108: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8291110C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82911110: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82911114: 4B91658D  bl 0x822276a0
	ctx.lr = 0x82911118;
	sub_822276A0(ctx, base);
	// 82911118: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 8291111C: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82911120: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82911124: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82911128: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8291112C: 392B0008  addi r9, r11, 8
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	// 82911130: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82911134: 810A0044  lwz r8, 0x44(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) } as u64;
	// 82911138: 80EA0040  lwz r7, 0x40(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 8291113C: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82911140: 4198000C  blt cr6, 0x8291114c
	if ctx.cr[6].lt {
	pc = 0x8291114C; continue 'dispatch;
	}
	// 82911144: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82911148: 4B868439  bl 0x82179580
	ctx.lr = 0x8291114C;
	sub_82179580(ctx, base);
	pc = 0x8291114C; continue 'dispatch;
            }
            0x8291114C => {
    //   block [0x8291114C..0x8291118C)
	// 8291114C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82911150: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82911154: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 82911158: 388B2C84  addi r4, r11, 0x2c84
	ctx.r[4].s64 = ctx.r[11].s64 + 11396;
	// 8291115C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82911160: 4B916C41  bl 0x82227da0
	ctx.lr = 0x82911164;
	sub_82227DA0(ctx, base);
	// 82911164: 3B400004  li r26, 4
	ctx.r[26].s64 = 4;
	// 82911168: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 8291116C: 935D0004  stw r26, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 82911170: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82911174: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82911178: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8291117C: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82911180: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82911184: 41980008  blt cr6, 0x8291118c
	if ctx.cr[6].lt {
	pc = 0x8291118C; continue 'dispatch;
	}
	// 82911188: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x8291118C; continue 'dispatch;
            }
            0x8291118C => {
    //   block [0x8291118C..0x829111A0)
	// 8291118C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82911190: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82911194: 409A0240  bne cr6, 0x829113d4
	if !ctx.cr[6].eq {
	pc = 0x829113D4; continue 'dispatch;
	}
	// 82911198: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8291119C: 3BABFFDF  addi r29, r11, -0x21
	ctx.r[29].s64 = ctx.r[11].s64 + -33;
	pc = 0x829111A0; continue 'dispatch;
            }
            0x829111A0 => {
    //   block [0x829111A0..0x829111A4)
	// 829111A0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829111A4; continue 'dispatch;
            }
            0x829111A4 => {
    //   block [0x829111A4..0x829111DC)
	// 829111A4: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829111A8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829111AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829111B0: 409AFFF4  bne cr6, 0x829111a4
	if !ctx.cr[6].eq {
	pc = 0x829111A4; continue 'dispatch;
	}
	// 829111B4: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 829111B8: 7D7D5850  subf r11, r29, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 829111BC: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 829111C0: 553C003E  slwi r28, r9, 0
	ctx.r[28].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 829111C4: 810A0044  lwz r8, 0x44(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) } as u64;
	// 829111C8: 80EA0040  lwz r7, 0x40(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 829111CC: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 829111D0: 4198000C  blt cr6, 0x829111dc
	if ctx.cr[6].lt {
	pc = 0x829111DC; continue 'dispatch;
	}
	// 829111D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829111D8: 4B8683A9  bl 0x82179580
	ctx.lr = 0x829111DC;
	sub_82179580(ctx, base);
	pc = 0x829111DC; continue 'dispatch;
            }
            0x829111DC => {
    //   block [0x829111DC..0x829111F8)
	// 829111DC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 829111E0: 839F0008  lwz r28, 8(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829111E4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829111E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829111EC: 4B916BB5  bl 0x82227da0
	ctx.lr = 0x829111F0;
	sub_82227DA0(ctx, base);
	// 829111F0: 907C0000  stw r3, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 829111F4: 935C0004  stw r26, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	pc = 0x829111F8; continue 'dispatch;
            }
            0x829111F8 => {
    //   block [0x829111F8..0x82911240)
	// 829111F8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829111FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82911200: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82911204: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82911208: 388BFFE8  addi r4, r11, -0x18
	ctx.r[4].s64 = ctx.r[11].s64 + -24;
	// 8291120C: 38CBFFF8  addi r6, r11, -8
	ctx.r[6].s64 = ctx.r[11].s64 + -8;
	// 82911210: 38ABFFF0  addi r5, r11, -0x10
	ctx.r[5].s64 = ctx.r[11].s64 + -16;
	// 82911214: 4B917B15  bl 0x82228d28
	ctx.lr = 0x82911218;
	sub_82228D28(ctx, base);
	// 82911218: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8291121C: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82911220: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 82911224: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82911228: 812A0044  lwz r9, 0x44(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) } as u64;
	// 8291122C: 810A0040  lwz r8, 0x40(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 82911230: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82911234: 4198000C  blt cr6, 0x82911240
	if ctx.cr[6].lt {
	pc = 0x82911240; continue 'dispatch;
	}
	// 82911238: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8291123C: 4B868345  bl 0x82179580
	ctx.lr = 0x82911240;
	sub_82179580(ctx, base);
	pc = 0x82911240; continue 'dispatch;
            }
            0x82911240 => {
    //   block [0x82911240..0x8291127C)
	// 82911240: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82911244: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82911248: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 8291124C: 388B5850  addi r4, r11, 0x5850
	ctx.r[4].s64 = ctx.r[11].s64 + 22608;
	// 82911250: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82911254: 4B916B4D  bl 0x82227da0
	ctx.lr = 0x82911258;
	sub_82227DA0(ctx, base);
	// 82911258: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 8291125C: 935D0004  stw r26, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 82911260: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82911264: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82911268: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8291126C: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82911270: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82911274: 41980008  blt cr6, 0x8291127c
	if ctx.cr[6].lt {
	pc = 0x8291127C; continue 'dispatch;
	}
	// 82911278: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x8291127C; continue 'dispatch;
            }
            0x8291127C => {
    //   block [0x8291127C..0x829112D4)
	// 8291127C: 893E0004  lbz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82911280: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82911284: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82911288: 7D280034  cntlzw r8, r9
	ctx.r[8].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 8291128C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82911290: 5507DFFE  rlwinm r7, r8, 0x1b, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 82911294: 68E60001  xori r6, r7, 1
	ctx.r[6].u64 = ctx.r[7].u64 ^ 1;
	// 82911298: 90CB0000  stw r6, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 8291129C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829112A0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 829112A4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 829112A8: 388BFFE8  addi r4, r11, -0x18
	ctx.r[4].s64 = ctx.r[11].s64 + -24;
	// 829112AC: 38CBFFF8  addi r6, r11, -8
	ctx.r[6].s64 = ctx.r[11].s64 + -8;
	// 829112B0: 38ABFFF0  addi r5, r11, -0x10
	ctx.r[5].s64 = ctx.r[11].s64 + -16;
	// 829112B4: 4B917A75  bl 0x82228d28
	ctx.lr = 0x829112B8;
	sub_82228D28(ctx, base);
	// 829112B8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829112BC: 38ABFFF0  addi r5, r11, -0x10
	ctx.r[5].s64 = ctx.r[11].s64 + -16;
	// 829112C0: 90BF0008  stw r5, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 829112C4: 809B0008  lwz r4, 8(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 829112C8: 7F1E2040  cmplw cr6, r30, r4
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[4].u32, &mut ctx.xer);
	// 829112CC: 41980008  blt cr6, 0x829112d4
	if ctx.cr[6].lt {
	pc = 0x829112D4; continue 'dispatch;
	}
	// 829112D0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x829112D4; continue 'dispatch;
            }
            0x829112D4 => {
    //   block [0x829112D4..0x82911304)
	// 829112D4: 897E0004  lbz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829112D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829112DC: 419A00E8  beq cr6, 0x829113c4
	if ctx.cr[6].eq {
	pc = 0x829113C4; continue 'dispatch;
	}
	// 829112E0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 829112E4: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 829112E8: 388B5858  addi r4, r11, 0x5858
	ctx.r[4].s64 = ctx.r[11].s64 + 22616;
	// 829112EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829112F0: 481131E9  bl 0x82a244d8
	ctx.lr = 0x829112F4;
	sub_82A244D8(ctx, base);
	// 829112F4: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 829112F8: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829112FC: 41980008  blt cr6, 0x82911304
	if ctx.cr[6].lt {
	pc = 0x82911304; continue 'dispatch;
	}
	// 82911300: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82911304; continue 'dispatch;
            }
            0x82911304 => {
    //   block [0x82911304..0x82911378)
	// 82911304: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82911308: 3BA00003  li r29, 3
	ctx.r[29].s64 = 3;
	// 8291130C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82911310: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82911314: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82911318: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8291131C: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82911320: 93AA0004  stw r29, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82911324: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82911328: D18A0000  stfs f12, 0(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8291132C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82911330: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82911334: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82911338: 388BFFE8  addi r4, r11, -0x18
	ctx.r[4].s64 = ctx.r[11].s64 + -24;
	// 8291133C: 38CBFFF8  addi r6, r11, -8
	ctx.r[6].s64 = ctx.r[11].s64 + -8;
	// 82911340: 38ABFFF0  addi r5, r11, -0x10
	ctx.r[5].s64 = ctx.r[11].s64 + -16;
	// 82911344: 4B9179E5  bl 0x82228d28
	ctx.lr = 0x82911348;
	sub_82228D28(ctx, base);
	// 82911348: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8291134C: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 82911350: 38EBFFF0  addi r7, r11, -0x10
	ctx.r[7].s64 = ctx.r[11].s64 + -16;
	// 82911354: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 82911358: 90FF0008  stw r7, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 8291135C: 38885864  addi r4, r8, 0x5864
	ctx.r[4].s64 = ctx.r[8].s64 + 22628;
	// 82911360: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82911364: 48113175  bl 0x82a244d8
	ctx.lr = 0x82911368;
	sub_82A244D8(ctx, base);
	// 82911368: 80DB0008  lwz r6, 8(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 8291136C: 7F1E3040  cmplw cr6, r30, r6
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82911370: 41980008  blt cr6, 0x82911378
	if ctx.cr[6].lt {
	pc = 0x82911378; continue 'dispatch;
	}
	// 82911374: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x82911378; continue 'dispatch;
            }
            0x82911378 => {
    //   block [0x82911378..0x829113C4)
	// 82911378: 813E000C  lwz r9, 0xc(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 8291137C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82911380: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82911384: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82911388: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8291138C: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82911390: 93AA0004  stw r29, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82911394: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82911398: D18A0000  stfs f12, 0(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8291139C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829113A0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 829113A4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 829113A8: 388BFFE8  addi r4, r11, -0x18
	ctx.r[4].s64 = ctx.r[11].s64 + -24;
	// 829113AC: 38CBFFF8  addi r6, r11, -8
	ctx.r[6].s64 = ctx.r[11].s64 + -8;
	// 829113B0: 38ABFFF0  addi r5, r11, -0x10
	ctx.r[5].s64 = ctx.r[11].s64 + -16;
	// 829113B4: 4B917975  bl 0x82228d28
	ctx.lr = 0x829113B8;
	sub_82228D28(ctx, base);
	// 829113B8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829113BC: 390BFFF0  addi r8, r11, -0x10
	ctx.r[8].s64 = ctx.r[11].s64 + -16;
	// 829113C0: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x829113C4; continue 'dispatch;
            }
            0x829113C4 => {
    //   block [0x829113C4..0x829113D4)
	// 829113C4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829113C8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829113CC: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 829113D0: 48398080  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x829113D4 => {
    //   block [0x829113D4..0x829113EC)
	// 829113D4: 83AA0000  lwz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829113D8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829113DC: 409AFDC4  bne cr6, 0x829111a0
	if !ctx.cr[6].eq {
	pc = 0x829111A0; continue 'dispatch;
	}
	// 829113E0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829113E4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829113E8: 4BFFFE10  b 0x829111f8
	pc = 0x829111F8; continue 'dispatch;
            }
            0x829113EC => {
    //   block [0x829113EC..0x829113FC)
	// 829113EC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829113F0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829113F4: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 829113F8: 48398058  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


