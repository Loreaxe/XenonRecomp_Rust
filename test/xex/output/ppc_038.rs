pub fn sub_82400068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82400068 size=1052
    let mut pc: u32 = 0x82400068;
    'dispatch: loop {
        match pc {
            0x82400068 => {
    //   block [0x82400068..0x82400100)
	// 82400068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240006C: 48135029  bl 0x82535094
	ctx.lr = 0x82400070;
	sub_82535080(ctx, base);
	// 82400070: 3981FF90  addi r12, r1, -0x70
	ctx.r[12].s64 = ctx.r[1].s64 + -112;
	// 82400074: 48135F69  bl 0x82535fdc
	ctx.lr = 0x82400078;
	sub_82535FB0(ctx, base);
	// 82400078: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240007C: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 82400080: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82400084: 7D595378  mr r25, r10
	ctx.r[25].u64 = ctx.r[10].u64;
	// 82400088: FF401890  fmr f26, f3
	ctx.f[26].f64 = ctx.f[3].f64;
	// 8240008C: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82400090: FF202090  fmr f25, f4
	ctx.f[25].f64 = ctx.f[4].f64;
	// 82400094: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82400098: FF802890  fmr f28, f5
	ctx.f[28].f64 = ctx.f[5].f64;
	// 8240009C: 7C942378  mr r20, r4
	ctx.r[20].u64 = ctx.r[4].u64;
	// 824000A0: C3CBBFFC  lfs f30, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 824000A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824000A8: 7CB52B78  mr r21, r5
	ctx.r[21].u64 = ctx.r[5].u64;
	// 824000AC: 7CD33378  mr r19, r6
	ctx.r[19].u64 = ctx.r[6].u64;
	// 824000B0: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	// 824000B4: EDBD07B2  fmuls f13, f29, f30
	ctx.f[13].f64 = (((ctx.f[29].f64 * ctx.f[30].f64) as f32) as f64);
	// 824000B8: C00B7588  lfs f0, 0x7588(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30088 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824000BC: EFE0E824  fdivs f31, f0, f29
	ctx.f[31].f64 = ((ctx.f[0].f64 / ctx.f[29].f64) as f32) as f64;
	// 824000C0: FC00681E  fctiwz f0, f13
	ctx.f[0].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 824000C4: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 824000C8: 83E10070  lwz r31, 0x70(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 824000CC: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 824000D0: 7FEB07B4  extsw r11, r31
	ctx.r[11].s64 = ctx.r[31].s32 as i64;
	// 824000D4: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 824000D8: C8010070  lfd f0, 0x70(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 824000DC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 824000E0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 824000E4: EC00F7FA  fmadds f0, f0, f31, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 + ctx.f[30].f64) as f32) as f64);
	// 824000E8: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 824000EC: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 824000F0: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 824000F4: 2F0B0100  cmpwi cr6, r11, 0x100
	ctx.cr[6].compare_i32(ctx.r[11].s32, 256, &mut ctx.xer);
	// 824000F8: 41980008  blt cr6, 0x82400100
	if ctx.cr[6].lt {
	pc = 0x82400100; continue 'dispatch;
	}
	// 824000FC: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	pc = 0x82400100; continue 'dispatch;
            }
            0x82400100 => {
    //   block [0x82400100..0x8240010C)
	// 82400100: 2F1F0064  cmpwi cr6, r31, 0x64
	ctx.cr[6].compare_i32(ctx.r[31].s32, 100, &mut ctx.xer);
	// 82400104: 40990008  ble cr6, 0x8240010c
	if !ctx.cr[6].gt {
	pc = 0x8240010C; continue 'dispatch;
	}
	// 82400108: 3BE00064  li r31, 0x64
	ctx.r[31].s64 = 100;
	pc = 0x8240010C; continue 'dispatch;
            }
            0x8240010C => {
    //   block [0x8240010C..0x82400130)
	// 8240010C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82400110: C1AB227C  lfs f13, 0x227c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8828 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82400114: EC020372  fmuls f0, f2, f13
	ctx.f[0].f64 = (((ctx.f[2].f64 * ctx.f[13].f64) as f32) as f64);
	// 82400118: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8240011C: 40980014  bge cr6, 0x82400130
	if !ctx.cr[6].lt {
	pc = 0x82400130; continue 'dispatch;
	}
	// 82400120: 39600064  li r11, 0x64
	ctx.r[11].s64 = 100;
	// 82400124: 0CDF0000  twi 6, r31, 0
	// 82400128: 7F6BFBD6  divw r27, r11, r31
	ctx.r[27].s32 = ctx.r[11].s32 / ctx.r[31].s32;
	// 8240012C: 48000008  b 0x82400134
	pc = 0x82400134; continue 'dispatch;
            }
            0x82400130 => {
    //   block [0x82400130..0x82400134)
	// 82400130: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	pc = 0x82400134; continue 'dispatch;
            }
            0x82400134 => {
    //   block [0x82400134..0x82400184)
	// 82400134: 7F6A07B4  extsw r10, r27
	ctx.r[10].s64 = ctx.r[27].s32 as i64;
	// 82400138: EDA00772  fmuls f13, f0, f29
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 8240013C: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 82400140: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82400144: 7EFBF9D6  mullw r23, r27, r31
	ctx.r[23].s32 = ((ctx.r[27].s32 as i64 * ctx.r[31].s32 as i64) as i32);
	ctx.r[23].s64 = ctx.r[23].s32 as i64;
	// 82400148: F9410078  std r10, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u64 ) };
	// 8240014C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82400150: 3B0BA628  addi r24, r11, -0x59d8
	ctx.r[24].s64 = ctx.r[11].s64 + -23000;
	// 82400154: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82400158: 3978001C  addi r11, r24, 0x1c
	ctx.r[11].s64 = ctx.r[24].s64 + 28;
	// 8240015C: C00AA668  lfs f0, -0x5998(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-22936 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400160: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82400164: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82400168: 7C004FAE  stfiwx f0, 0, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32, tmp.u32) };
	// 8240016C: 83A10070  lwz r29, 0x70(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82400170: 7EDDD9D6  mullw r22, r29, r27
	ctx.r[22].s32 = ((ctx.r[29].s32 as i64 * ctx.r[27].s32 as i64) as i32);
	ctx.r[22].s64 = ctx.r[22].s32 as i64;
	// 82400174: C8010078  lfd f0, 0x78(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 82400178: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8240017C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82400180: EF7F0024  fdivs f27, f31, f0
	ctx.f[27].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	pc = 0x82400184; continue 'dispatch;
            }
            0x82400184 => {
    //   block [0x82400184..0x824001A8)
	// 82400184: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400188: FF1D0000  fcmpu cr6, f29, f0
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[0].f64);
	// 8240018C: 4199001C  bgt cr6, 0x824001a8
	if ctx.cr[6].gt {
	pc = 0x824001A8; continue 'dispatch;
	}
	// 82400190: 3958001C  addi r10, r24, 0x1c
	ctx.r[10].s64 = ctx.r[24].s64 + 28;
	// 82400194: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82400198: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 8240019C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 824001A0: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 824001A4: 4198FFE0  blt cr6, 0x82400184
	if ctx.cr[6].lt {
	pc = 0x82400184; continue 'dispatch;
	}
	pc = 0x824001A8; continue 'dispatch;
            }
            0x824001A8 => {
    //   block [0x824001A8..0x82400240)
	// 824001A8: FC20D890  fmr f1, f27
	ctx.f[1].f64 = ctx.f[27].f64;
	// 824001AC: 4BFFDFBD  bl 0x823fe168
	ctx.lr = 0x824001B0;
	sub_823FE168(ctx, base);
	// 824001B0: 57C6103A  slwi r6, r30, 2
	ctx.r[6].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 824001B4: 83C10184  lwz r30, 0x184(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(388 as u32) ) } as u64;
	// 824001B8: 39780004  addi r11, r24, 4
	ctx.r[11].s64 = ctx.r[24].s64 + 4;
	// 824001BC: FC80E090  fmr f4, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[4].f64 = ctx.f[28].f64;
	// 824001C0: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 824001C4: 8341018C  lwz r26, 0x18c(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(396 as u32) ) } as u64;
	// 824001C8: 7EA8AB78  mr r8, r21
	ctx.r[8].u64 = ctx.r[21].u64;
	// 824001CC: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 824001D0: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 824001D4: FC60D890  fmr f3, f27
	ctx.f[3].f64 = ctx.f[27].f64;
	// 824001D8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 824001DC: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 824001E0: 7C065C2E  lfsx f0, r6, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824001E4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824001E8: EDA107BA  fmadds f13, f1, f30, f0
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64);
	// 824001EC: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 824001F0: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 824001F4: C00BA658  lfs f0, -0x59a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22952 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824001F8: EC2D0028  fsubs f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 824001FC: 48001B35  bl 0x82401d30
	ctx.lr = 0x82400200;
	sub_82401D30(ctx, base);
	// 82400200: C1BC0008  lfs f13, 8(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82400204: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82400208: EDADF82A  fadds f13, f13, f31
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64;
	// 8240020C: C19C0000  lfs f12, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82400210: C00BA664  lfs f0, -0x599c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22940 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400214: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82400218: EDAD603A  fmadds f13, f13, f0, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 8240021C: C00B2200  lfs f0, 0x2200(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8704 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400220: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82400224: C14B1FF8  lfs f10, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82400228: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 8240022C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82400230: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82400234: 4099000C  ble cr6, 0x82400240
	if !ctx.cr[6].gt {
	pc = 0x82400240; continue 'dispatch;
	}
	// 82400238: EC00F02A  fadds f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 8240023C: 48000008  b 0x82400244
	pc = 0x82400244; continue 'dispatch;
            }
            0x82400240 => {
    //   block [0x82400240..0x82400244)
	// 82400240: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	pc = 0x82400244; continue 'dispatch;
            }
            0x82400244 => {
    //   block [0x82400244..0x824002BC)
	// 82400244: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82400248: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 8240024C: E9410072  lwa r10, 0x70(r1)
	ctx.r[10].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as i32) as i64;
	// 82400250: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82400254: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82400258: D3FC0008  stfs f31, 8(r28)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8240025C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82400260: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82400264: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82400268: F9410078  std r10, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u64 ) };
	// 8240026C: C00B2204  lfs f0, 0x2204(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8708 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400270: C9810078  lfd f12, 0x78(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 82400274: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82400278: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8240027C: EC2C683C  fnmsubs f1, f12, f0, f13
	ctx.f[1].f64 = -(((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82400280: D03C0000  stfs f1, 0(r28)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400284: 4BFFFD35  bl 0x823fffb8
	ctx.lr = 0x82400288;
	sub_823FFFB8(ctx, base);
	// 82400288: 397FFFFF  addi r11, r31, -1
	ctx.r[11].s64 = ctx.r[31].s64 + -1;
	// 8240028C: 3957FFFF  addi r10, r23, -1
	ctx.r[10].s64 = ctx.r[23].s64 + -1;
	// 82400290: 7F0BE800  cmpw cr6, r11, r29
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82400294: 41980068  blt cr6, 0x824002fc
	if ctx.cr[6].lt {
	pc = 0x824002FC; continue 'dispatch;
	}
	// 82400298: 7D3D5850  subf r9, r29, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 8240029C: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 824002A0: 38E90001  addi r7, r9, 1
	ctx.r[7].s64 = ctx.r[9].s64 + 1;
	// 824002A4: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 824002A8: 5764103A  slwi r4, r27, 2
	ctx.r[4].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 824002AC: 7D29F214  add r9, r9, r30
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[30].u64;
	// 824002B0: 7CC8F214  add r6, r8, r30
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[30].u64;
	// 824002B4: 7C7ED050  subf r3, r30, r26
	ctx.r[3].s64 = ctx.r[26].s64 - ctx.r[30].s64;
	// 824002B8: 7D675850  subf r11, r7, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	pc = 0x824002BC; continue 'dispatch;
            }
            0x824002BC => {
    //   block [0x824002BC..0x824002D4)
	// 824002BC: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 824002C0: 40990030  ble cr6, 0x824002f0
	if !ctx.cr[6].gt {
	pc = 0x824002F0; continue 'dispatch;
	}
	// 824002C4: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 824002C8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 824002CC: 7D5B5050  subf r10, r27, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[27].s64;
	// 824002D0: 7D244850  subf r9, r4, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[4].s64;
	pc = 0x824002D4; continue 'dispatch;
            }
            0x824002D4 => {
    //   block [0x824002D4..0x824002F0)
	// 824002D4: 7C061C2E  lfsx f0, r6, r3
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824002D8: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 824002DC: 7C03452E  stfsx f0, r3, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[8].u32), tmp.u32) };
	// 824002E0: C0060000  lfs f0, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824002E4: D0080000  stfs f0, 0(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 824002E8: 3908FFFC  addi r8, r8, -4
	ctx.r[8].s64 = ctx.r[8].s64 + -4;
	// 824002EC: 4082FFE8  bne 0x824002d4
	if !ctx.cr[0].eq {
	pc = 0x824002D4; continue 'dispatch;
	}
	pc = 0x824002F0; continue 'dispatch;
            }
            0x824002F0 => {
    //   block [0x824002F0..0x824002FC)
	// 824002F0: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 824002F4: 38C6FFFC  addi r6, r6, -4
	ctx.r[6].s64 = ctx.r[6].s64 + -4;
	// 824002F8: 4082FFC4  bne 0x824002bc
	if !ctx.cr[0].eq {
	pc = 0x824002BC; continue 'dispatch;
	}
	pc = 0x824002FC; continue 'dispatch;
            }
            0x824002FC => {
    //   block [0x824002FC..0x82400310)
	// 824002FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82400300: 41980060  blt cr6, 0x82400360
	if ctx.cr[6].lt {
	pc = 0x82400360; continue 'dispatch;
	}
	// 82400304: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82400308: 7CDED050  subf r6, r30, r26
	ctx.r[6].s64 = ctx.r[26].s64 - ctx.r[30].s64;
	// 8240030C: 7CE9F214  add r7, r9, r30
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[30].u64;
	pc = 0x82400310; continue 'dispatch;
            }
            0x82400310 => {
    //   block [0x82400310..0x82400340)
	// 82400310: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82400314: 7C07342E  lfsx f0, r7, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400318: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 8240031C: 2F1B0001  cmpwi cr6, r27, 1
	ctx.cr[6].compare_i32(ctx.r[27].s32, 1, &mut ctx.xer);
	// 82400320: 7C09D52E  stfsx f0, r9, r26
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[26].u32), tmp.u32) };
	// 82400324: C0070000  lfs f0, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400328: 7C09F52E  stfsx f0, r9, r30
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[30].u32), tmp.u32) };
	// 8240032C: 40990028  ble cr6, 0x82400354
	if !ctx.cr[6].gt {
	pc = 0x82400354; continue 'dispatch;
	}
	// 82400330: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82400334: 393BFFFF  addi r9, r27, -1
	ctx.r[9].s64 = ctx.r[27].s64 + -1;
	// 82400338: 7D08F214  add r8, r8, r30
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[30].u64;
	// 8240033C: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	pc = 0x82400340; continue 'dispatch;
            }
            0x82400340 => {
    //   block [0x82400340..0x82400354)
	// 82400340: 7D48352E  stfsx f10, r8, r6
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[6].u32), tmp.u32) };
	// 82400344: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82400348: D1480000  stfs f10, 0(r8)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8240034C: 3908FFFC  addi r8, r8, -4
	ctx.r[8].s64 = ctx.r[8].s64 + -4;
	// 82400350: 4082FFF0  bne 0x82400340
	if !ctx.cr[0].eq {
	pc = 0x82400340; continue 'dispatch;
	}
	pc = 0x82400354; continue 'dispatch;
            }
            0x82400354 => {
    //   block [0x82400354..0x82400360)
	// 82400354: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82400358: 38E7FFFC  addi r7, r7, -4
	ctx.r[7].s64 = ctx.r[7].s64 + -4;
	// 8240035C: 4080FFB4  bge 0x82400310
	if !ctx.cr[0].lt {
	pc = 0x82400310; continue 'dispatch;
	}
	pc = 0x82400360; continue 'dispatch;
            }
            0x82400360 => {
    //   block [0x82400360..0x8240037C)
	// 82400360: 7F16B800  cmpw cr6, r22, r23
	ctx.cr[6].compare_i32(ctx.r[22].s32, ctx.r[23].s32, &mut ctx.xer);
	// 82400364: 40980080  bge cr6, 0x824003e4
	if !ctx.cr[6].lt {
	pc = 0x824003E4; continue 'dispatch;
	}
	// 82400368: 56CA103A  slwi r10, r22, 2
	ctx.r[10].u32 = ctx.r[22].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8240036C: 810101AC  lwz r8, 0x1ac(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(428 as u32) ) } as u64;
	// 82400370: C0180000  lfs f0, 0(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400374: 7D76B850  subf r11, r22, r23
	ctx.r[11].s64 = ctx.r[23].s64 - ctx.r[22].s64;
	// 82400378: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	pc = 0x8240037C; continue 'dispatch;
            }
            0x8240037C => {
    //   block [0x8240037C..0x824003E4)
	// 8240037C: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82400380: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82400384: 5527043E  clrlwi r7, r9, 0x10
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0x0000FFFFu64;
	// 82400388: 7D298670  srawi r9, r9, 0x10
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 16) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 16) as i64;
	// 8240038C: 1CE741A7  mulli r7, r7, 0x41a7
	ctx.r[7].s32 = ((ctx.r[7].s32 as i64 * 16807 as i64) as i32);
	ctx.r[7].s64 = ctx.r[7].s32 as i64;
	// 82400390: 1D2941A7  mulli r9, r9, 0x41a7
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * 16807 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82400394: 5525805E  rlwinm r5, r9, 0x10, 1, 0xf
	ctx.r[5].u64 = ctx.r[9].u32 as u64 & 0x0000FFFFu64;
	// 82400398: 55268BFE  srwi r6, r9, 0xf
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shr(15);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 8240039C: 7D272A14  add r9, r7, r5
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[5].u64;
	// 824003A0: 55250FFE  srwi r5, r9, 0x1f
	ctx.r[5].u32 = ctx.r[9].u32.wrapping_shr(31);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824003A4: 5527007E  clrlwi r7, r9, 1
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0x7FFFFFFFu64;
	// 824003A8: 7D262A14  add r9, r6, r5
	ctx.r[9].u64 = ctx.r[6].u64 + ctx.r[5].u64;
	// 824003AC: 7D293A14  add r9, r9, r7
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[7].u64;
	// 824003B0: 55270FFE  srwi r7, r9, 0x1f
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shr(31);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 824003B4: 7D274A14  add r9, r7, r9
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 824003B8: 5529007E  clrlwi r9, r9, 1
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x7FFFFFFFu64;
	// 824003BC: 7D2707B4  extsw r7, r9
	ctx.r[7].s64 = ctx.r[9].s32 as i64;
	// 824003C0: 91280000  stw r9, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824003C4: F8E10078  std r7, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[7].u64 ) };
	// 824003C8: C9A10078  lfd f13, 0x78(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 824003CC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 824003D0: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 824003D4: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 824003D8: D1AA0000  stfs f13, 0(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 824003DC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 824003E0: 4082FF9C  bne 0x8240037c
	if !ctx.cr[0].eq {
	pc = 0x8240037C; continue 'dispatch;
	}
	pc = 0x824003E4; continue 'dispatch;
            }
            0x824003E4 => {
    //   block [0x824003E4..0x82400404)
	// 824003E4: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 824003E8: 7EE903A6  mtctr r23
	ctx.ctr.u64 = ctx.r[23].u64;
	// 824003EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824003F0: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 824003F4: C1AB1850  lfs f13, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824003F8: 40990050  ble cr6, 0x82400448
	if !ctx.cr[6].gt {
	pc = 0x82400448; continue 'dispatch;
	}
	// 824003FC: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 82400400: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x82400404; continue 'dispatch;
            }
            0x82400404 => {
    //   block [0x82400404..0x8240042C)
	// 82400404: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400408: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8240040C: ED4A002A  fadds f10, f10, f0
	ctx.f[10].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82400410: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82400414: 4082FFF0  bne 0x82400404
	if !ctx.cr[0].eq {
	pc = 0x82400404; continue 'dispatch;
	}
	// 82400418: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8240041C: C00B2808  lfs f0, 0x2808(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400420: FF0A0000  fcmpu cr6, f10, f0
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[0].f64);
	// 82400424: 40990008  ble cr6, 0x8240042c
	if !ctx.cr[6].gt {
	pc = 0x8240042C; continue 'dispatch;
	}
	// 82400428: EDA05024  fdivs f13, f0, f10
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[10].f64) as f32) as f64;
	pc = 0x8240042C; continue 'dispatch;
            }
            0x8240042C => {
    //   block [0x8240042C..0x82400434)
	// 8240042C: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 82400430: 40990018  ble cr6, 0x82400448
	if !ctx.cr[6].gt {
	pc = 0x82400448; continue 'dispatch;
	}
	pc = 0x82400434; continue 'dispatch;
            }
            0x82400434 => {
    //   block [0x82400434..0x82400448)
	// 82400434: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400438: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8240043C: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400440: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82400444: 4200FFF0  bdnz 0x82400434
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82400434; continue 'dispatch;
	}
	pc = 0x82400448; continue 'dispatch;
            }
            0x82400448 => {
    //   block [0x82400448..0x82400484)
	// 82400448: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 8240044C: FC60C890  fmr f3, f25
	ctx.f[3].f64 = ctx.f[25].f64;
	// 82400450: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82400454: FC40D090  fmr f2, f26
	ctx.f[2].f64 = ctx.f[26].f64;
	// 82400458: 7E689B78  mr r8, r19
	ctx.r[8].u64 = ctx.r[19].u64;
	// 8240045C: FC20D890  fmr f1, f27
	ctx.f[1].f64 = ctx.f[27].f64;
	// 82400460: 7EA7AB78  mr r7, r21
	ctx.r[7].u64 = ctx.r[21].u64;
	// 82400464: 7E86A378  mr r6, r20
	ctx.r[6].u64 = ctx.r[20].u64;
	// 82400468: 38A000A0  li r5, 0xa0
	ctx.r[5].s64 = 160;
	// 8240046C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82400470: 4BFFBB01  bl 0x823fbf70
	ctx.lr = 0x82400474;
	sub_823FBF70(ctx, base);
	// 82400474: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82400478: 3981FF90  addi r12, r1, -0x70
	ctx.r[12].s64 = ctx.r[1].s64 + -112;
	// 8240047C: 48135BAD  bl 0x82536028
	ctx.lr = 0x82400480;
	sub_82535FFC(ctx, base);
	// 82400480: 48134C64  b 0x825350e4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82400488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82400488 size=492
    let mut pc: u32 = 0x82400488;
    'dispatch: loop {
        match pc {
            0x82400488 => {
    //   block [0x82400488..0x8240051C)
	// 82400488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240048C: 48134C25  bl 0x825350b0
	ctx.lr = 0x82400490;
	sub_82535080(ctx, base);
	// 82400490: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82400494: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 82400498: 3921FFB8  addi r9, r1, -0x48
	ctx.r[9].s64 = ctx.r[1].s64 + -72;
	// 8240049C: 3901FFB0  addi r8, r1, -0x50
	ctx.r[8].s64 = ctx.r[1].s64 + -80;
	// 824004A0: C00B7588  lfs f0, 0x7588(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30088 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824004A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824004A8: F941FFB8  std r10, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.r[10].u64 ) };
	// 824004AC: C981FFB8  lfd f12, -0x48(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 824004B0: EC000824  fdivs f0, f0, f1
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[1].f64) as f32) as f64;
	// 824004B4: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 824004B8: C1AB72B8  lfs f13, 0x72b8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(29368 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824004BC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824004C0: C0EB1FF8  lfs f7, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 824004C4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824004C8: C18BBFFC  lfs f12, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 824004CC: EDA0637A  fmadds f13, f0, f13, f12
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 824004D0: FD805818  frsp f12, f11
	ctx.f[12].f64 = (ctx.f[11].f64 as f32) as f64;
	// 824004D4: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 824004D8: EC0C0024  fdivs f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 824004DC: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 824004E0: 7C004FAE  stfiwx f0, 0, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32, tmp.u32) };
	// 824004E4: 7DA047AE  stfiwx f13, 0, r8
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32, tmp.u32) };
	// 824004E8: 83A1FFB0  lwz r29, -0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) } as u64;
	// 824004EC: 8361FFB8  lwz r27, -0x48(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) } as u64;
	// 824004F0: 7FBE0E70  srawi r30, r29, 1
	ctx.xer.ca = (ctx.r[29].s32 < 0) && ((ctx.r[29].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[29].s32 >> 1) as i64;
	// 824004F4: 2F1B0001  cmpwi cr6, r27, 1
	ctx.cr[6].compare_i32(ctx.r[27].s32, 1, &mut ctx.xer);
	// 824004F8: 397E4000  addi r11, r30, 0x4000
	ctx.r[11].s64 = ctx.r[30].s64 + 16384;
	// 824004FC: 7D637E70  srawi r3, r11, 0xf
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 15) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[11].s32 >> 15) as i64;
	// 82400500: 4198014C  blt cr6, 0x8240064c
	if ctx.cr[6].lt {
	pc = 0x8240064C; continue 'dispatch;
	}
	// 82400504: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82400508: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8240050C: 38E04000  li r7, 0x4000
	ctx.r[7].s64 = 16384;
	// 82400510: 7F7ADB78  mr r26, r27
	ctx.r[26].u64 = ctx.r[27].u64;
	// 82400514: 3B8BAC40  addi r28, r11, -0x53c0
	ctx.r[28].s64 = ctx.r[11].s64 + -21440;
	// 82400518: C0CAAFC0  lfs f6, -0x5040(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-20544 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	pc = 0x8240051C; continue 'dispatch;
            }
            0x8240051C => {
    //   block [0x8240051C..0x8240057C)
	// 8240051C: 7CE7EA14  add r7, r7, r29
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[29].u64;
	// 82400520: FC003090  fmr f0, f6
	ctx.f[0].f64 = ctx.f[6].f64;
	// 82400524: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82400528: 7D47F214  add r10, r7, r30
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[30].u64;
	// 8240052C: 55662834  slwi r6, r11, 5
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82400530: 7D437E70  srawi r3, r10, 0xf
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 15) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[10].s32 >> 15) as i64;
	// 82400534: 7CE87E70  srawi r8, r7, 0xf
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 15) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[7].s32 >> 15) as i64;
	// 82400538: 3947C200  addi r10, r7, -0x3e00
	ctx.r[10].s64 = ctx.r[7].s64 + -15872;
	// 8240053C: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82400540: 7D4A5670  srawi r10, r10, 0xa
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 10) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 10) as i64;
	// 82400544: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82400548: 7D4A3050  subf r10, r10, r6
	ctx.r[10].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 8240054C: 7CC92214  add r6, r9, r4
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[4].u64;
	// 82400550: 7D28242E  lfsx f9, r8, r4
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[4].u32)) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82400554: 7D292A14  add r9, r9, r5
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[5].u64;
	// 82400558: 7D082C2E  lfsx f8, r8, r5
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[5].u32)) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 8240055C: 2F0AFF90  cmpwi cr6, r10, -0x70
	ctx.cr[6].compare_i32(ctx.r[10].s32, -112, &mut ctx.xer);
	// 82400560: 41990040  bgt cr6, 0x824005a0
	if ctx.cr[6].gt {
	pc = 0x824005A0; continue 'dispatch;
	}
	// 82400564: 210AFF90  subfic r8, r10, -0x70
	ctx.xer.ca = ctx.r[10].u32 <= -112 as u32;
	ctx.r[8].s64 = (-112 as i64) - ctx.r[10].s64;
	// 82400568: 5508D97E  srwi r8, r8, 5
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(5);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8240056C: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82400570: 551F2834  slwi r31, r8, 5
	ctx.r[31].u32 = ctx.r[8].u32.wrapping_shl(5);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82400574: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82400578: 7D5F5214  add r10, r31, r10
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	pc = 0x8240057C; continue 'dispatch;
            }
            0x8240057C => {
    //   block [0x8240057C..0x824005A0)
	// 8240057C: C1860000  lfs f12, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82400580: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82400584: ED8C0332  fmuls f12, f12, f12
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82400588: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8240058C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82400590: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82400594: EDAD637A  fmadds f13, f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 82400598: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8240059C: 4082FFE0  bne 0x8240057c
	if !ctx.cr[0].eq {
	pc = 0x8240057C; continue 'dispatch;
	}
	pc = 0x824005A0; continue 'dispatch;
            }
            0x824005A0 => {
    //   block [0x824005A0..0x824005B8)
	// 824005A0: FD600090  fmr f11, f0
	ctx.f[11].f64 = ctx.f[0].f64;
	// 824005A4: 2F0A0070  cmpwi cr6, r10, 0x70
	ctx.cr[6].compare_i32(ctx.r[10].s32, 112, &mut ctx.xer);
	// 824005A8: 40980060  bge cr6, 0x82400608
	if !ctx.cr[6].lt {
	pc = 0x82400608; continue 'dispatch;
	}
	// 824005AC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824005B0: 391C01C0  addi r8, r28, 0x1c0
	ctx.r[8].s64 = ctx.r[28].s64 + 448;
	// 824005B4: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	pc = 0x824005B8; continue 'dispatch;
            }
            0x824005B8 => {
    //   block [0x824005B8..0x82400608)
	// 824005B8: 7F0B1800  cmpw cr6, r11, r3
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[3].s32, &mut ctx.xer);
	// 824005BC: 40980080  bge cr6, 0x8240063c
	if !ctx.cr[6].lt {
	pc = 0x8240063C; continue 'dispatch;
	}
	// 824005C0: C1860000  lfs f12, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 824005C4: 391C0380  addi r8, r28, 0x380
	ctx.r[8].s64 = ctx.r[28].s64 + 896;
	// 824005C8: ECAC0332  fmuls f5, f12, f12
	ctx.f[5].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 824005CC: C14A0000  lfs f10, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 824005D0: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824005D4: ED8A627C  fnmsubs f12, f10, f9, f12
	ctx.f[12].f64 = -(((ctx.f[10].f64 * ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 824005D8: ED4A6A3C  fnmsubs f10, f10, f8, f13
	ctx.f[10].f64 = -(((ctx.f[10].f64 * ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 824005DC: 394A0080  addi r10, r10, 0x80
	ctx.r[10].s64 = ctx.r[10].s64 + 128;
	// 824005E0: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 824005E4: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 824005E8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824005EC: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 824005F0: EDAD2B7A  fmadds f13, f13, f13, f5
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[5].f64) as f32) as f64);
	// 824005F4: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 824005F8: EDAC0332  fmuls f13, f12, f12
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 824005FC: EDAA6ABA  fmadds f13, f10, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64);
	// 82400600: ED6D582A  fadds f11, f13, f11
	ctx.f[11].f64 = ((ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64;
	// 82400604: 4198FFB4  blt cr6, 0x824005b8
	if ctx.cr[6].lt {
	pc = 0x824005B8; continue 'dispatch;
	}
	pc = 0x82400608; continue 'dispatch;
            }
            0x82400608 => {
    //   block [0x82400608..0x82400614)
	// 82400608: 7F0B1800  cmpw cr6, r11, r3
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[3].s32, &mut ctx.xer);
	// 8240060C: 40980030  bge cr6, 0x8240063c
	if !ctx.cr[6].lt {
	pc = 0x8240063C; continue 'dispatch;
	}
	// 82400610: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	pc = 0x82400614; continue 'dispatch;
            }
            0x82400614 => {
    //   block [0x82400614..0x8240063C)
	// 82400614: C1860000  lfs f12, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82400618: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8240061C: ED8C0332  fmuls f12, f12, f12
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82400620: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82400624: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82400628: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 8240062C: EDAD637A  fmadds f13, f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 82400630: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82400634: ED6B682A  fadds f11, f11, f13
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 82400638: 4082FFDC  bne 0x82400614
	if !ctx.cr[0].eq {
	pc = 0x82400614; continue 'dispatch;
	}
	pc = 0x8240063C; continue 'dispatch;
            }
            0x8240063C => {
    //   block [0x8240063C..0x8240064C)
	// 8240063C: EC0B0024  fdivs f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 / ctx.f[0].f64) as f32) as f64;
	// 82400640: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82400644: ECE0382A  fadds f7, f0, f7
	ctx.f[7].f64 = ((ctx.f[0].f64 + ctx.f[7].f64) as f32) as f64;
	// 82400648: 4082FED4  bne 0x8240051c
	if !ctx.cr[0].eq {
	pc = 0x8240051C; continue 'dispatch;
	}
	pc = 0x8240064C; continue 'dispatch;
            }
            0x8240064C => {
    //   block [0x8240064C..0x82400674)
	// 8240064C: 7F6B07B4  extsw r11, r27
	ctx.r[11].s64 = ctx.r[27].s32 as i64;
	// 82400650: F961FFB8  std r11, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.r[11].u64 ) };
	// 82400654: C801FFB8  lfd f0, -0x48(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82400658: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8240065C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82400660: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82400664: EDA70024  fdivs f13, f7, f0
	ctx.f[13].f64 = ((ctx.f[7].f64 / ctx.f[0].f64) as f32) as f64;
	// 82400668: C00B1850  lfs f0, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8240066C: EC206828  fsubs f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82400670: 48134A90  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82400678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82400678 size=68
    let mut pc: u32 = 0x82400678;
    'dispatch: loop {
        match pc {
            0x82400678 => {
    //   block [0x82400678..0x824006BC)
	// 82400678: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8240067C: 3921FFF0  addi r9, r1, -0x10
	ctx.r[9].s64 = ctx.r[1].s64 + -16;
	// 82400680: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82400684: C00A7588  lfs f0, 0x7588(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(30088 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400688: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8240068C: ED800824  fdivs f12, f0, f1
	ctx.f[12].f64 = ((ctx.f[0].f64 / ctx.f[1].f64) as f32) as f64;
	// 82400690: C00A317C  lfs f0, 0x317c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12668 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400694: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82400698: C1AABFFC  lfs f13, -0x4004(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8240069C: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 824006A0: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 824006A4: 7C004FAE  stfiwx f0, 0, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32, tmp.u32) };
	// 824006A8: 8061FFF0  lwz r3, -0x10(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 824006AC: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824006B0: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 824006B4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 824006B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824006C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824006C0 size=292
    let mut pc: u32 = 0x824006C0;
    'dispatch: loop {
        match pc {
            0x824006C0 => {
    //   block [0x824006C0..0x82400714)
	// 824006C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824006C4: 481349ED  bl 0x825350b0
	ctx.lr = 0x824006C8;
	sub_82535080(ctx, base);
	// 824006C8: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 824006CC: 4813591D  bl 0x82535fe8
	ctx.lr = 0x824006D0;
	sub_82535FB0(ctx, base);
	// 824006D0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824006D4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824006D8: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 824006DC: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 824006E0: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 824006E4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 824006E8: C3EB2074  lfs f31, 0x2074(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8308 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 824006EC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 824006F0: C3C7AFCC  lfs f30, -0x5034(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-20532 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 824006F4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 824006F8: C388AFC8  lfs f28, -0x5038(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-20536 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 824006FC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82400700: C3A92310  lfs f29, 0x2310(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8976 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82400704: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82400708: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8240070C: 39600049  li r11, 0x49
	ctx.r[11].s64 = 73;
	// 82400710: 3BAA8E38  addi r29, r10, -0x71c8
	ctx.r[29].s64 = ctx.r[10].s64 + -29128;
	pc = 0x82400714; continue 'dispatch;
            }
            0x82400714 => {
    //   block [0x82400714..0x82400750)
	// 82400714: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82400718: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 8240071C: 388B0001  addi r4, r11, 1
	ctx.r[4].s64 = ctx.r[11].s64 + 1;
	// 82400720: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82400724: 4BFFD585  bl 0x823fdca8
	ctx.lr = 0x82400728;
	sub_823FDCA8(ctx, base);
	// 82400728: EDBF0772  fmuls f13, f31, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[31].f64 * ctx.f[29].f64) as f32) as f64);
	// 8240072C: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400730: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82400734: 41980098  blt cr6, 0x824007cc
	if ctx.cr[6].lt {
	pc = 0x824007CC; continue 'dispatch;
	}
	// 82400738: EDBF0732  fmuls f13, f31, f28
	ctx.f[13].f64 = (((ctx.f[31].f64 * ctx.f[28].f64) as f32) as f64);
	// 8240073C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82400740: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82400744: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82400748: 41980008  blt cr6, 0x82400750
	if ctx.cr[6].lt {
	pc = 0x82400750; continue 'dispatch;
	}
	// 8240074C: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	pc = 0x82400750; continue 'dispatch;
            }
            0x82400750 => {
    //   block [0x82400750..0x8240077C)
	// 82400750: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82400754: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	// 82400758: C19D0000  lfs f12, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8240075C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82400760: 7D4AEA14  add r10, r10, r29
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 82400764: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82400768: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8240076C: EC0D07B2  fmuls f0, f13, f30
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[30].f64) as f32) as f64);
	// 82400770: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82400774: 41980058  blt cr6, 0x824007cc
	if ctx.cr[6].lt {
	pc = 0x824007CC; continue 'dispatch;
	}
	// 82400778: 48000010  b 0x82400788
	pc = 0x82400788; continue 'dispatch;
            }
            0x8240077C => {
    //   block [0x8240077C..0x82400788)
	// 8240077C: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 82400780: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82400784: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82400788; continue 'dispatch;
            }
            0x82400788 => {
    //   block [0x82400788..0x824007A0)
	// 82400788: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8240078C: 4199FFF0  bgt cr6, 0x8240077c
	if ctx.cr[6].gt {
	pc = 0x8240077C; continue 'dispatch;
	}
	// 82400790: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82400794: 41980038  blt cr6, 0x824007cc
	if ctx.cr[6].lt {
	pc = 0x824007CC; continue 'dispatch;
	}
	// 82400798: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8240079C: 7D4AE214  add r10, r10, r28
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	pc = 0x824007A0; continue 'dispatch;
            }
            0x824007A0 => {
    //   block [0x824007A0..0x824007BC)
	// 824007A0: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824007A4: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824007A8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 824007AC: 40980010  bge cr6, 0x824007bc
	if !ctx.cr[6].lt {
	pc = 0x824007BC; continue 'dispatch;
	}
	// 824007B0: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824007B4: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 824007B8: 4080FFE8  bge 0x824007a0
	if !ctx.cr[0].lt {
	pc = 0x824007A0; continue 'dispatch;
	}
	pc = 0x824007BC; continue 'dispatch;
            }
            0x824007BC => {
    //   block [0x824007BC..0x824007CC)
	// 824007BC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824007C0: 4198000C  blt cr6, 0x824007cc
	if ctx.cr[6].lt {
	pc = 0x824007CC; continue 'dispatch;
	}
	// 824007C4: 2F1F0005  cmpwi cr6, r31, 5
	ctx.cr[6].compare_i32(ctx.r[31].s32, 5, &mut ctx.xer);
	// 824007C8: 4198FF4C  blt cr6, 0x82400714
	if ctx.cr[6].lt {
	pc = 0x82400714; continue 'dispatch;
	}
	pc = 0x824007CC; continue 'dispatch;
            }
            0x824007CC => {
    //   block [0x824007CC..0x824007E4)
	// 824007CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824007D0: 937A0000  stw r27, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 824007D4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 824007D8: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 824007DC: 48135859  bl 0x82536034
	ctx.lr = 0x824007E0;
	sub_82535FFC(ctx, base);
	// 824007E0: 48134920  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824007E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824007E8 size=320
    let mut pc: u32 = 0x824007E8;
    'dispatch: loop {
        match pc {
            0x824007E8 => {
    //   block [0x824007E8..0x82400858)
	// 824007E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824007EC: 481348C5  bl 0x825350b0
	ctx.lr = 0x824007F0;
	sub_82535080(ctx, base);
	// 824007F0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824007F4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 824007F8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824007FC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82400800: 390B8E38  addi r8, r11, -0x71c8
	ctx.r[8].s64 = ctx.r[11].s64 + -29128;
	// 82400804: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82400808: 83DC0000  lwz r30, 0(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8240080C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82400810: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82400814: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82400818: C00976F4  lfs f0, 0x76f4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(30452 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8240081C: 835B0000  lwz r26, 0(r27)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82400820: 83EBFFFC  lwz r31, -4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82400824: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82400828: 7D4B4214  add r10, r11, r8
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 8240082C: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82400830: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82400834: 419900E4  bgt cr6, 0x82400918
	if ctx.cr[6].gt {
	pc = 0x82400918; continue 'dispatch;
	}
	// 82400838: 7D8B1C2E  lfsx f12, r11, r3
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8240083C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82400840: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82400844: C00BD6C8  lfs f0, -0x2938(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400848: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8240084C: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82400850: C00B2068  lfs f0, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400854: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x82400858; continue 'dispatch;
            }
            0x82400858 => {
    //   block [0x82400858..0x82400890)
	// 82400858: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 8240085C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82400860: C16A0000  lfs f11, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82400864: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 82400868: 4198FFF0  blt cr6, 0x82400858
	if ctx.cr[6].lt {
	pc = 0x82400858; continue 'dispatch;
	}
	// 8240086C: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82400870: 7D4B1A14  add r10, r11, r3
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82400874: C00AFFFC  lfs f0, -4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400878: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 8240087C: 40980014  bge cr6, 0x82400890
	if !ctx.cr[6].lt {
	pc = 0x82400890; continue 'dispatch;
	}
	// 82400880: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400884: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82400888: 40980008  bge cr6, 0x82400890
	if !ctx.cr[6].lt {
	pc = 0x82400890; continue 'dispatch;
	}
	// 8240088C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	pc = 0x82400890; continue 'dispatch;
            }
            0x82400890 => {
    //   block [0x82400890..0x824008A0)
	// 82400890: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82400894: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82400898: C00A2940  lfs f0, 0x2940(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10560 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8240089C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x824008A0; continue 'dispatch;
            }
            0x824008A0 => {
    //   block [0x824008A0..0x824008D8)
	// 824008A0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824008A4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 824008A8: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824008AC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 824008B0: 4198FFF0  blt cr6, 0x824008a0
	if ctx.cr[6].lt {
	pc = 0x824008A0; continue 'dispatch;
	}
	// 824008B4: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824008B8: 7C6B1A14  add r3, r11, r3
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 824008BC: C003FFFC  lfs f0, -4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824008C0: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 824008C4: 40980014  bge cr6, 0x824008d8
	if !ctx.cr[6].lt {
	pc = 0x824008D8; continue 'dispatch;
	}
	// 824008C8: C0030000  lfs f0, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824008CC: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 824008D0: 40980008  bge cr6, 0x824008d8
	if !ctx.cr[6].lt {
	pc = 0x824008D8; continue 'dispatch;
	}
	// 824008D4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	pc = 0x824008D8; continue 'dispatch;
            }
            0x824008D8 => {
    //   block [0x824008D8..0x82400908)
	// 824008D8: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 824008DC: 409A003C  bne cr6, 0x82400918
	if !ctx.cr[6].eq {
	pc = 0x82400918; continue 'dispatch;
	}
	// 824008E0: 2F1E0001  cmpwi cr6, r30, 1
	ctx.cr[6].compare_i32(ctx.r[30].s32, 1, &mut ctx.xer);
	// 824008E4: 409A0024  bne cr6, 0x82400908
	if !ctx.cr[6].eq {
	pc = 0x82400908; continue 'dispatch;
	}
	// 824008E8: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 824008EC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824008F0: 209F004A  subfic r4, r31, 0x4a
	ctx.xer.ca = ctx.r[31].u32 <= 74 as u32;
	ctx.r[4].s64 = (74 as i64) - ctx.r[31].s64;
	// 824008F4: 4BFFD3B5  bl 0x823fdca8
	ctx.lr = 0x824008F8;
	sub_823FDCA8(ctx, base);
	// 824008F8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824008FC: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82400900: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82400904: 48000014  b 0x82400918
	pc = 0x82400918; continue 'dispatch;
            }
            0x82400908 => {
    //   block [0x82400908..0x82400918)
	// 82400908: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 8240090C: 7F1AF000  cmpw cr6, r26, r30
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[30].s32, &mut ctx.xer);
	// 82400910: 409A0008  bne cr6, 0x82400918
	if !ctx.cr[6].eq {
	pc = 0x82400918; continue 'dispatch;
	}
	// 82400914: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	pc = 0x82400918; continue 'dispatch;
            }
            0x82400918 => {
    //   block [0x82400918..0x82400928)
	// 82400918: 935B0000  stw r26, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 8240091C: 93DC0000  stw r30, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82400920: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82400924: 481347DC  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82400928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82400928 size=972
    let mut pc: u32 = 0x82400928;
    'dispatch: loop {
        match pc {
            0x82400928 => {
    //   block [0x82400928..0x8240098C)
	// 82400928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240092C: 48134759  bl 0x82535084
	ctx.lr = 0x82400930;
	sub_82535080(ctx, base);
	// 82400930: 3981FF70  addi r12, r1, -0x90
	ctx.r[12].s64 = ctx.r[1].s64 + -144;
	// 82400934: 481356AD  bl 0x82535fe0
	ctx.lr = 0x82400938;
	sub_82535FB0(ctx, base);
	// 82400938: 9421FD90  stwu r1, -0x270(r1)
	ea = ctx.r[1].u32.wrapping_add(-624 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240093C: 7C912378  mr r17, r4
	ctx.r[17].u64 = ctx.r[4].u64;
	// 82400940: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82400944: 7C721B78  mr r18, r3
	ctx.r[18].u64 = ctx.r[3].u64;
	// 82400948: FF601090  fmr f27, f2
	ctx.f[27].f64 = ctx.f[2].f64;
	// 8240094C: 7CB02B78  mr r16, r5
	ctx.r[16].u64 = ctx.r[5].u64;
	// 82400950: 7E258B78  mr r5, r17
	ctx.r[5].u64 = ctx.r[17].u64;
	// 82400954: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 82400958: 7CCF3378  mr r15, r6
	ctx.r[15].u64 = ctx.r[6].u64;
	// 8240095C: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 82400960: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 82400964: 4BFFD2B5  bl 0x823fdc18
	ctx.lr = 0x82400968;
	sub_823FDC18(ctx, base);
	// 82400968: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8240096C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82400970: C00B2150  lfs f0, 0x2150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8528 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400974: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82400978: EDA1002A  fadds f13, f1, f0
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 8240097C: C00B2934  lfs f0, 0x2934(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10548 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400980: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82400984: 3A6B8E38  addi r19, r11, -0x71c8
	ctx.r[19].s64 = ctx.r[11].s64 + -29128;
	// 82400988: EF406824  fdivs f26, f0, f13
	ctx.f[26].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	pc = 0x8240098C; continue 'dispatch;
            }
            0x8240098C => {
    //   block [0x8240098C..0x824009C4)
	// 8240098C: 7E278B78  mr r7, r17
	ctx.r[7].u64 = ctx.r[17].u64;
	// 82400990: 7C3F9C2E  lfsx f1, r31, r19
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[19].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82400994: 7E469378  mr r6, r18
	ctx.r[6].u64 = ctx.r[18].u64;
	// 82400998: FC40D090  fmr f2, f26
	ctx.f[2].f64 = ctx.f[26].f64;
	// 8240099C: 7DE57B78  mr r5, r15
	ctx.r[5].u64 = ctx.r[15].u64;
	// 824009A0: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 824009A4: 480014F5  bl 0x82401e98
	ctx.lr = 0x824009A8;
	sub_82401E98(ctx, base);
	// 824009A8: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 824009AC: 7C3F5D2E  stfsx f1, r31, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 824009B0: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 824009B4: 2F1F0128  cmpwi cr6, r31, 0x128
	ctx.cr[6].compare_i32(ctx.r[31].s32, 296, &mut ctx.xer);
	// 824009B8: 4198FFD4  blt cr6, 0x8240098c
	if ctx.cr[6].lt {
	pc = 0x8240098C; continue 'dispatch;
	}
	// 824009BC: 39610084  addi r11, r1, 0x84
	ctx.r[11].s64 = ctx.r[1].s64 + 132;
	// 824009C0: 39400025  li r10, 0x25
	ctx.r[10].s64 = 37;
	pc = 0x824009C4; continue 'dispatch;
            }
            0x824009C4 => {
    //   block [0x824009C4..0x82400A04)
	// 824009C4: C00BFFFC  lfs f0, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824009C8: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824009CC: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 824009D0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 824009D4: 4082FFF0  bne 0x824009c4
	if !ctx.cr[0].eq {
	pc = 0x824009C4; continue 'dispatch;
	}
	// 824009D8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824009DC: C00B203C  lfs f0, 0x203c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824009E0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824009E4: EC1F0032  fmuls f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 824009E8: C1ABAFC4  lfs f13, -0x503c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20540 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824009EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824009F0: ED9F0372  fmuls f12, f31, f13
	ctx.f[12].f64 = (((ctx.f[31].f64 * ctx.f[13].f64) as f32) as f64);
	// 824009F4: C1B30000  lfs f13, 0(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824009F8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 824009FC: 4098001C  bge cr6, 0x82400a18
	if !ctx.cr[6].lt {
	pc = 0x82400A18; continue 'dispatch;
	}
	// 82400A00: 7E6A9B78  mr r10, r19
	ctx.r[10].u64 = ctx.r[19].u64;
	pc = 0x82400A04; continue 'dispatch;
            }
            0x82400A04 => {
    //   block [0x82400A04..0x82400A18)
	// 82400A04: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82400A08: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82400A0C: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82400A10: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82400A14: 4198FFF0  blt cr6, 0x82400a04
	if ctx.cr[6].lt {
	pc = 0x82400A04; continue 'dispatch;
	}
	pc = 0x82400A18; continue 'dispatch;
            }
            0x82400A18 => {
    //   block [0x82400A18..0x82400A28)
	// 82400A18: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82400A1C: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 82400A20: 7D755B78  mr r21, r11
	ctx.r[21].u64 = ctx.r[11].u64;
	// 82400A24: 7C0A4C2E  lfsx f0, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82400A28; continue 'dispatch;
            }
            0x82400A28 => {
    //   block [0x82400A28..0x82400A40)
	// 82400A28: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 82400A2C: 7DAA4C2E  lfsx f13, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82400A30: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82400A34: 4098000C  bge cr6, 0x82400a40
	if !ctx.cr[6].lt {
	pc = 0x82400A40; continue 'dispatch;
	}
	// 82400A38: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82400A3C: 7D755B78  mr r21, r11
	ctx.r[21].u64 = ctx.r[11].u64;
	pc = 0x82400A40; continue 'dispatch;
            }
            0x82400A40 => {
    //   block [0x82400A40..0x82400A5C)
	// 82400A40: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82400A44: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82400A48: 2F0A0128  cmpwi cr6, r10, 0x128
	ctx.cr[6].compare_i32(ctx.r[10].s32, 296, &mut ctx.xer);
	// 82400A4C: 40980010  bge cr6, 0x82400a5c
	if !ctx.cr[6].lt {
	pc = 0x82400A5C; continue 'dispatch;
	}
	// 82400A50: 7DAA9C2E  lfsx f13, r10, r19
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[19].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82400A54: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82400A58: 4099FFD0  ble cr6, 0x82400a28
	if !ctx.cr[6].gt {
	pc = 0x82400A28; continue 'dispatch;
	}
	pc = 0x82400A5C; continue 'dispatch;
            }
            0x82400A5C => {
    //   block [0x82400A5C..0x82400A74)
	// 82400A5C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82400A60: FF1B0000  fcmpu cr6, f27, f0
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[0].f64);
	// 82400A64: C38BBFFC  lfs f28, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82400A68: 4099000C  ble cr6, 0x82400a74
	if !ctx.cr[6].gt {
	pc = 0x82400A74; continue 'dispatch;
	}
	// 82400A6C: EC00D82A  fadds f0, f0, f27
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[27].f64) as f32) as f64;
	// 82400A70: EC000732  fmuls f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	pc = 0x82400A74; continue 'dispatch;
            }
            0x82400A74 => {
    //   block [0x82400A74..0x82400AD0)
	// 82400A74: 56BF103A  slwi r31, r21, 2
	ctx.r[31].u32 = ctx.r[21].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82400A78: 3BC10080  addi r30, r1, 0x80
	ctx.r[30].s64 = ctx.r[1].s64 + 128;
	// 82400A7C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82400A80: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82400A84: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82400A88: 7FFFF42E  lfsx f31, r31, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82400A8C: 7C1FF52E  stfsx f0, r31, r30
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32), tmp.u32) };
	// 82400A90: 4BFFFC31  bl 0x824006c0
	ctx.lr = 0x82400A94;
	sub_824006C0(ctx, base);
	// 82400A94: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82400A98: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82400A9C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82400AA0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82400AA4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82400AA8: 4BFFFD41  bl 0x824007e8
	ctx.lr = 0x82400AAC;
	sub_824007E8(ctx, base);
	// 82400AAC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82400AB0: 80E10058  lwz r7, 0x58(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82400AB4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82400AB8: 7D775B78  mr r23, r11
	ctx.r[23].u64 = ctx.r[11].u64;
	// 82400ABC: 7CF43B78  mr r20, r7
	ctx.r[20].u64 = ctx.r[7].u64;
	// 82400AC0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82400AC4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82400AC8: 40990030  ble cr6, 0x82400af8
	if !ctx.cr[6].gt {
	pc = 0x82400AF8; continue 'dispatch;
	}
	// 82400ACC: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	pc = 0x82400AD0; continue 'dispatch;
            }
            0x82400AD0 => {
    //   block [0x82400AD0..0x82400AE4)
	// 82400AD0: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82400AD4: 7F154000  cmpw cr6, r21, r8
	ctx.cr[6].compare_i32(ctx.r[21].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82400AD8: 409A000C  bne cr6, 0x82400ae4
	if !ctx.cr[6].eq {
	pc = 0x82400AE4; continue 'dispatch;
	}
	// 82400ADC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82400AE0: 7F154000  cmpw cr6, r21, r8
	ctx.cr[6].compare_i32(ctx.r[21].s32, ctx.r[8].s32, &mut ctx.xer);
	pc = 0x82400AE4; continue 'dispatch;
            }
            0x82400AE4 => {
    //   block [0x82400AE4..0x82400AF8)
	// 82400AE4: 41990014  bgt cr6, 0x82400af8
	if ctx.cr[6].gt {
	pc = 0x82400AF8; continue 'dispatch;
	}
	// 82400AE8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82400AEC: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82400AF0: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82400AF4: 4198FFDC  blt cr6, 0x82400ad0
	if ctx.cr[6].lt {
	pc = 0x82400AD0; continue 'dispatch;
	}
	pc = 0x82400AF8; continue 'dispatch;
            }
            0x82400AF8 => {
    //   block [0x82400AF8..0x82400B54)
	// 82400AF8: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82400AFC: 409A00B4  bne cr6, 0x82400bb0
	if !ctx.cr[6].eq {
	pc = 0x82400BB0; continue 'dispatch;
	}
	// 82400B00: 54E9103A  slwi r9, r7, 2
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82400B04: 7C1FF42E  lfsx f0, r31, r30
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400B08: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 82400B0C: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 82400B10: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82400B14: 7D29402E  lwzx r9, r9, r8
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82400B18: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82400B1C: 7D89342E  lfsx f12, r9, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82400B20: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82400B24: C1A9AFC8  lfs f13, -0x5038(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-20536 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82400B28: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82400B2C: 409A0028  bne cr6, 0x82400b54
	if !ctx.cr[6].eq {
	pc = 0x82400B54; continue 'dispatch;
	}
	// 82400B30: 81210060  lwz r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82400B34: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 82400B38: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82400B3C: 7D69442E  lfsx f11, r9, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82400B40: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82400B44: C1892A1C  lfs f12, 0x2a1c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(10780 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82400B48: ED8B0332  fmuls f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82400B4C: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82400B50: 40980014  bge cr6, 0x82400b64
	if !ctx.cr[6].lt {
	pc = 0x82400B64; continue 'dispatch;
	}
	pc = 0x82400B54; continue 'dispatch;
            }
            0x82400B54 => {
    //   block [0x82400B54..0x82400B64)
	// 82400B54: 7F0A3800  cmpw cr6, r10, r7
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82400B58: 40990058  ble cr6, 0x82400bb0
	if !ctx.cr[6].gt {
	pc = 0x82400BB0; continue 'dispatch;
	}
	// 82400B5C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82400B60: 41980050  blt cr6, 0x82400bb0
	if ctx.cr[6].lt {
	pc = 0x82400BB0; continue 'dispatch;
	}
	pc = 0x82400B64; continue 'dispatch;
            }
            0x82400B64 => {
    //   block [0x82400B64..0x82400B7C)
	// 82400B64: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82400B68: 4099002C  ble cr6, 0x82400b94
	if !ctx.cr[6].gt {
	pc = 0x82400B94; continue 'dispatch;
	}
	// 82400B6C: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82400B70: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82400B74: 7D0A5850  subf r8, r10, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82400B78: 7D293A14  add r9, r9, r7
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[7].u64;
	pc = 0x82400B7C; continue 'dispatch;
            }
            0x82400B7C => {
    //   block [0x82400B7C..0x82400B94)
	// 82400B7C: 80C9FFFC  lwz r6, -4(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82400B80: 38E9FFFC  addi r7, r9, -4
	ctx.r[7].s64 = ctx.r[9].s64 + -4;
	// 82400B84: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82400B88: 90C90000  stw r6, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82400B8C: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 82400B90: 4082FFEC  bne 0x82400b7c
	if !ctx.cr[0].eq {
	pc = 0x82400B7C; continue 'dispatch;
	}
	pc = 0x82400B94; continue 'dispatch;
            }
            0x82400B94 => {
    //   block [0x82400B94..0x82400BAC)
	// 82400B94: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82400B98: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82400B9C: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 82400BA0: 7EA9412E  stwx r21, r9, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), ctx.r[21].u32) };
	// 82400BA4: 41980008  blt cr6, 0x82400bac
	if ctx.cr[6].lt {
	pc = 0x82400BAC; continue 'dispatch;
	}
	// 82400BA8: 7D545378  mr r20, r10
	ctx.r[20].u64 = ctx.r[10].u64;
	pc = 0x82400BAC; continue 'dispatch;
            }
            0x82400BAC => {
    //   block [0x82400BAC..0x82400BB0)
	// 82400BAC: 3AEB0001  addi r23, r11, 1
	ctx.r[23].s64 = ctx.r[11].s64 + 1;
	pc = 0x82400BB0; continue 'dispatch;
            }
            0x82400BB0 => {
    //   block [0x82400BB0..0x82400BD0)
	// 82400BB0: 7FFFF52E  stfsx f31, r31, r30
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32), tmp.u32) };
	// 82400BB4: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82400BB8: 3AD7FFFF  addi r22, r23, -1
	ctx.r[22].s64 = ctx.r[23].s64 + -1;
	// 82400BBC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82400BC0: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 82400BC4: 4099011C  ble cr6, 0x82400ce0
	if !ctx.cr[6].gt {
	pc = 0x82400CE0; continue 'dispatch;
	}
	// 82400BC8: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 82400BCC: 7F1AE850  subf r24, r26, r29
	ctx.r[24].s64 = ctx.r[29].s64 - ctx.r[26].s64;
	pc = 0x82400BD0; continue 'dispatch;
            }
            0x82400BD0 => {
    //   block [0x82400BD0..0x82400BE8)
	// 82400BD0: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82400BD4: 419A0014  beq cr6, 0x82400be8
	if ctx.cr[6].eq {
	pc = 0x82400BE8; continue 'dispatch;
	}
	// 82400BD8: 7F1CB000  cmpw cr6, r28, r22
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[22].s32, &mut ctx.xer);
	// 82400BDC: 419A000C  beq cr6, 0x82400be8
	if ctx.cr[6].eq {
	pc = 0x82400BE8; continue 'dispatch;
	}
	// 82400BE0: 7F1CA000  cmpw cr6, r28, r20
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[20].s32, &mut ctx.xer);
	// 82400BE4: 409A00EC  bne cr6, 0x82400cd0
	if !ctx.cr[6].eq {
	pc = 0x82400CD0; continue 'dispatch;
	}
	pc = 0x82400BE8; continue 'dispatch;
            }
            0x82400BE8 => {
    //   block [0x82400BE8..0x82400BF8)
	// 82400BE8: 7F1CA000  cmpw cr6, r28, r20
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[20].s32, &mut ctx.xer);
	// 82400BEC: 409A000C  bne cr6, 0x82400bf8
	if !ctx.cr[6].eq {
	pc = 0x82400BF8; continue 'dispatch;
	}
	// 82400BF0: 816102C4  lwz r11, 0x2c4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(708 as u32) ) } as u64;
	// 82400BF4: 932B0000  stw r25, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	pc = 0x82400BF8; continue 'dispatch;
            }
            0x82400BF8 => {
    //   block [0x82400BF8..0x82400C30)
	// 82400BF8: 83DB0000  lwz r30, 0(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82400BFC: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 82400C00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82400C04: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82400C08: 2C1E0000  cmpwi r30, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82400C0C: 7D2A9A14  add r9, r10, r19
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[19].u64;
	// 82400C10: 7FEA442E  lfsx f31, r10, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82400C14: C3A90000  lfs f29, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82400C18: 40810018  ble 0x82400c30
	if !ctx.cr[0].gt {
	pc = 0x82400C30; continue 'dispatch;
	}
	// 82400C1C: C009FFFC  lfs f0, -4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400C20: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82400C24: EC00E82A  fadds f0, f0, f29
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64;
	// 82400C28: EC000732  fmuls f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	// 82400C2C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	pc = 0x82400C30; continue 'dispatch;
            }
            0x82400C30 => {
    //   block [0x82400C30..0x82400C5C)
	// 82400C30: 395E0001  addi r10, r30, 1
	ctx.r[10].s64 = ctx.r[30].s64 + 1;
	// 82400C34: 2F0A004A  cmpwi cr6, r10, 0x4a
	ctx.cr[6].compare_i32(ctx.r[10].s32, 74, &mut ctx.xer);
	// 82400C38: 40980024  bge cr6, 0x82400c5c
	if !ctx.cr[6].lt {
	pc = 0x82400C5C; continue 'dispatch;
	}
	// 82400C3C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82400C40: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82400C44: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82400C48: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82400C4C: 7C0A9C2E  lfsx f0, r10, r19
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[19].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400C50: EC00E82A  fadds f0, f0, f29
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64;
	// 82400C54: EC000732  fmuls f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	// 82400C58: 7C09452E  stfsx f0, r9, r8
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), tmp.u32) };
	pc = 0x82400C5C; continue 'dispatch;
            }
            0x82400C5C => {
    //   block [0x82400C5C..0x82400C6C)
	// 82400C5C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82400C60: 40990048  ble cr6, 0x82400ca8
	if !ctx.cr[6].gt {
	pc = 0x82400CA8; continue 'dispatch;
	}
	// 82400C64: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 82400C68: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	pc = 0x82400C6C; continue 'dispatch;
            }
            0x82400C6C => {
    //   block [0x82400C6C..0x82400C9C)
	// 82400C6C: C3DF0000  lfs f30, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82400C70: 7E278B78  mr r7, r17
	ctx.r[7].u64 = ctx.r[17].u64;
	// 82400C74: 7E469378  mr r6, r18
	ctx.r[6].u64 = ctx.r[18].u64;
	// 82400C78: FC40D090  fmr f2, f26
	ctx.f[2].f64 = ctx.f[26].f64;
	// 82400C7C: 7DE57B78  mr r5, r15
	ctx.r[5].u64 = ctx.r[15].u64;
	// 82400C80: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82400C84: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 82400C88: 48001211  bl 0x82401e98
	ctx.lr = 0x82400C8C;
	sub_82401E98(ctx, base);
	// 82400C8C: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 82400C90: 4099000C  ble cr6, 0x82400c9c
	if !ctx.cr[6].gt {
	pc = 0x82400C9C; continue 'dispatch;
	}
	// 82400C94: FFA0F090  fmr f29, f30
	ctx.f[29].f64 = ctx.f[30].f64;
	// 82400C98: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	pc = 0x82400C9C; continue 'dispatch;
            }
            0x82400C9C => {
    //   block [0x82400C9C..0x82400CA8)
	// 82400C9C: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82400CA0: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82400CA4: 4082FFC8  bne 0x82400c6c
	if !ctx.cr[0].eq {
	pc = 0x82400C6C; continue 'dispatch;
	}
	pc = 0x82400CA8; continue 'dispatch;
            }
            0x82400CA8 => {
    //   block [0x82400CA8..0x82400CC4)
	// 82400CA8: 7FB8D52E  stfsx f29, r24, r26
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[24].u32.wrapping_add(ctx.r[26].u32), tmp.u32) };
	// 82400CAC: 7F1EA800  cmpw cr6, r30, r21
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[21].s32, &mut ctx.xer);
	// 82400CB0: 409A0014  bne cr6, 0x82400cc4
	if !ctx.cr[6].eq {
	pc = 0x82400CC4; continue 'dispatch;
	}
	// 82400CB4: FF1BF800  fcmpu cr6, f27, f31
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[31].f64);
	// 82400CB8: 4099000C  ble cr6, 0x82400cc4
	if !ctx.cr[6].gt {
	pc = 0x82400CC4; continue 'dispatch;
	}
	// 82400CBC: EC1FD82A  fadds f0, f31, f27
	ctx.f[0].f64 = ((ctx.f[31].f64 + ctx.f[27].f64) as f32) as f64;
	// 82400CC0: EFE00732  fmuls f31, f0, f28
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	pc = 0x82400CC4; continue 'dispatch;
            }
            0x82400CC4 => {
    //   block [0x82400CC4..0x82400CD0)
	// 82400CC4: D3FA0000  stfs f31, 0(r26)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400CC8: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 82400CCC: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	pc = 0x82400CD0; continue 'dispatch;
            }
            0x82400CD0 => {
    //   block [0x82400CD0..0x82400CE0)
	// 82400CD0: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82400CD4: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82400CD8: 7F1CB800  cmpw cr6, r28, r23
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[23].s32, &mut ctx.xer);
	// 82400CDC: 4198FEF4  blt cr6, 0x82400bd0
	if ctx.cr[6].lt {
	pc = 0x82400BD0; continue 'dispatch;
	}
	pc = 0x82400CE0; continue 'dispatch;
            }
            0x82400CE0 => {
    //   block [0x82400CE0..0x82400CF4)
	// 82400CE0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82400CE4: 38210270  addi r1, r1, 0x270
	ctx.r[1].s64 = ctx.r[1].s64 + 624;
	// 82400CE8: 3981FF70  addi r12, r1, -0x90
	ctx.r[12].s64 = ctx.r[1].s64 + -144;
	// 82400CEC: 48135341  bl 0x8253602c
	ctx.lr = 0x82400CF0;
	sub_82535FFC(ctx, base);
	// 82400CF0: 481343E4  b 0x825350d4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82400CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82400CF8 size=288
    let mut pc: u32 = 0x82400CF8;
    'dispatch: loop {
        match pc {
            0x82400CF8 => {
    //   block [0x82400CF8..0x82400D50)
	// 82400CF8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82400CFC: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400D00: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82400D04: C1A40000  lfs f13, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82400D08: ED6D002A  fadds f11, f13, f0
	ctx.f[11].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82400D0C: D1630000  stfs f11, 0(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400D10: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82400D14: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 82400D18: 39040004  addi r8, r4, 4
	ctx.r[8].s64 = ctx.r[4].s64 + 4;
	// 82400D1C: C18A1FF8  lfs f12, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82400D20: 7D4B1A14  add r10, r11, r3
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82400D24: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 82400D28: D1840000  stfs f12, 0(r4)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400D2C: 2F050100  cmpwi cr6, r5, 0x100
	ctx.cr[6].compare_i32(ctx.r[5].s32, 256, &mut ctx.xer);
	// 82400D30: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82400D34: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400D38: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 82400D3C: D18B0000  stfs f12, 0(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400D40: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 82400D44: 409A000C  bne cr6, 0x82400d50
	if !ctx.cr[6].eq {
	pc = 0x82400D50; continue 'dispatch;
	}
	// 82400D48: 38C7AFD0  addi r6, r7, -0x5030
	ctx.r[6].s64 = ctx.r[7].s64 + -20528;
	// 82400D4C: 4800000C  b 0x82400d58
	pc = 0x82400D58; continue 'dispatch;
            }
            0x82400D50 => {
    //   block [0x82400D50..0x82400D58)
	// 82400D50: 38E7AFD0  addi r7, r7, -0x5030
	ctx.r[7].s64 = ctx.r[7].s64 + -20528;
	// 82400D54: 38C703F8  addi r6, r7, 0x3f8
	ctx.r[6].s64 = ctx.r[7].s64 + 1016;
	pc = 0x82400D58; continue 'dispatch;
            }
            0x82400D58 => {
    //   block [0x82400D58..0x82400D78)
	// 82400D58: 7CA70E70  srawi r7, r5, 1
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[5].s32 >> 1) as i64;
	// 82400D5C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82400D60: 2F070001  cmpwi cr6, r7, 1
	ctx.cr[6].compare_i32(ctx.r[7].s32, 1, &mut ctx.xer);
	// 82400D64: 409900A0  ble cr6, 0x82400e04
	if !ctx.cr[6].gt {
	pc = 0x82400E04; continue 'dispatch;
	}
	// 82400D68: 3CA0820D  lis r5, -0x7df3
	ctx.r[5].s64 = -2113077248;
	// 82400D6C: 38E7FFFF  addi r7, r7, -1
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	// 82400D70: 38670001  addi r3, r7, 1
	ctx.r[3].s64 = ctx.r[7].s64 + 1;
	// 82400D74: C005BFFC  lfs f0, -0x4004(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82400D78; continue 'dispatch;
            }
            0x82400D78 => {
    //   block [0x82400D78..0x82400E04)
	// 82400D78: C1880000  lfs f12, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82400D7C: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82400D80: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82400D84: ECCA602A  fadds f6, f10, f12
	ctx.f[6].f64 = ((ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64;
	// 82400D88: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82400D8C: C16A0000  lfs f11, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82400D90: ED4C5028  fsubs f10, f12, f10
	ctx.f[10].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82400D94: ECED5828  fsubs f7, f13, f11
	ctx.f[7].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82400D98: C1260000  lfs f9, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82400D9C: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82400DA0: ECAB682A  fadds f5, f11, f13
	ctx.f[5].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 82400DA4: C1060000  lfs f8, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82400DA8: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82400DAC: ED860032  fmuls f12, f6, f0
	ctx.f[12].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82400DB0: ED6A0032  fmuls f11, f10, f0
	ctx.f[11].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82400DB4: EDA70032  fmuls f13, f7, f0
	ctx.f[13].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 82400DB8: ED450032  fmuls f10, f5, f0
	ctx.f[10].f64 = (((ctx.f[5].f64 * ctx.f[0].f64) as f32) as f64);
	// 82400DBC: ECEC0232  fmuls f7, f12, f8
	ctx.f[7].f64 = (((ctx.f[12].f64 * ctx.f[8].f64) as f32) as f64);
	// 82400DC0: ED0D0232  fmuls f8, f13, f8
	ctx.f[8].f64 = (((ctx.f[13].f64 * ctx.f[8].f64) as f32) as f64);
	// 82400DC4: EDAD3A78  fmsubs f13, f13, f9, f7
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[9].f64 - ctx.f[7].f64) as f32) as f64);
	// 82400DC8: ED8C427A  fmadds f12, f12, f9, f8
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[9].f64 + ctx.f[8].f64) as f32) as f64);
	// 82400DCC: ED2D582A  fadds f9, f13, f11
	ctx.f[9].f64 = ((ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64;
	// 82400DD0: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82400DD4: D1A80000  stfs f13, 0(r8)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400DD8: EDAC502A  fadds f13, f12, f10
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[10].f64) as f32) as f64;
	// 82400DDC: D1A90000  stfs f13, 0(r9)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400DE0: EDAA6028  fsubs f13, f10, f12
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82400DE4: D1AA0000  stfs f13, 0(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400DE8: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82400DEC: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 82400DF0: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82400DF4: FDA04850  fneg f13, f9
	ctx.f[13].u64 = ctx.f[9].u64 ^ 0x8000_0000_0000_0000u64;
	// 82400DF8: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400DFC: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 82400E00: 4082FF78  bne 0x82400d78
	if !ctx.cr[0].eq {
	pc = 0x82400D78; continue 'dispatch;
	}
	pc = 0x82400E04; continue 'dispatch;
            }
            0x82400E04 => {
    //   block [0x82400E04..0x82400E18)
	// 82400E04: 546B103A  slwi r11, r3, 2
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82400E08: 7C0B242E  lfsx f0, r11, r4
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400E0C: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82400E10: 7C0B252E  stfsx f0, r11, r4
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32), tmp.u32) };
	// 82400E14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82400E18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82400E18 size=292
    let mut pc: u32 = 0x82400E18;
    'dispatch: loop {
        match pc {
            0x82400E18 => {
    //   block [0x82400E18..0x82400E7C)
	// 82400E18: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82400E1C: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82400E20: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400E24: C1A40000  lfs f13, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82400E28: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 82400E2C: 7D4B1A14  add r10, r11, r3
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82400E30: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 82400E34: 39040004  addi r8, r4, 4
	ctx.r[8].s64 = ctx.r[4].s64 + 4;
	// 82400E38: 38EBFFFC  addi r7, r11, -4
	ctx.r[7].s64 = ctx.r[11].s64 + -4;
	// 82400E3C: 2F050100  cmpwi cr6, r5, 0x100
	ctx.cr[6].compare_i32(ctx.r[5].s32, 256, &mut ctx.xer);
	// 82400E40: C18A0000  lfs f12, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82400E44: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 82400E48: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82400E4C: ED4C002A  fadds f10, f12, f0
	ctx.f[10].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82400E50: ED2B682A  fadds f9, f11, f13
	ctx.f[9].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 82400E54: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82400E58: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82400E5C: EDAD5828  fsubs f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82400E60: ED8A4828  fsubs f12, f10, f9
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[9].f64) as f32) as f64);
	// 82400E64: D1830000  stfs f12, 0(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400E68: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82400E6C: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400E70: 409A000C  bne cr6, 0x82400e7c
	if !ctx.cr[6].eq {
	pc = 0x82400E7C; continue 'dispatch;
	}
	// 82400E74: 3BEBAFD0  addi r31, r11, -0x5030
	ctx.r[31].s64 = ctx.r[11].s64 + -20528;
	// 82400E78: 4800000C  b 0x82400e84
	pc = 0x82400E84; continue 'dispatch;
            }
            0x82400E7C => {
    //   block [0x82400E7C..0x82400E84)
	// 82400E7C: 396BAFD0  addi r11, r11, -0x5030
	ctx.r[11].s64 = ctx.r[11].s64 + -20528;
	// 82400E80: 3BEB03F8  addi r31, r11, 0x3f8
	ctx.r[31].s64 = ctx.r[11].s64 + 1016;
	pc = 0x82400E84; continue 'dispatch;
            }
            0x82400E84 => {
    //   block [0x82400E84..0x82400EB8)
	// 82400E84: 7CA60E70  srawi r6, r5, 1
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[5].s32 >> 1) as i64;
	// 82400E88: 3CA0820D  lis r5, -0x7df3
	ctx.r[5].s64 = -2113077248;
	// 82400E8C: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82400E90: 2F060001  cmpwi cr6, r6, 1
	ctx.cr[6].compare_i32(ctx.r[6].s32, 1, &mut ctx.xer);
	// 82400E94: C0052068  lfs f0, 0x2068(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400E98: 7DAB1C2E  lfsx f13, r11, r3
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82400E9C: 7D8B242E  lfsx f12, r11, r4
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82400EA0: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82400EA4: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82400EA8: 7DAB1D2E  stfsx f13, r11, r3
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32), tmp.u32) };
	// 82400EAC: 7C0B252E  stfsx f0, r11, r4
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32), tmp.u32) };
	// 82400EB0: 40990084  ble cr6, 0x82400f34
	if !ctx.cr[6].gt {
	pc = 0x82400F34; continue 'dispatch;
	}
	// 82400EB4: 3966FFFF  addi r11, r6, -1
	ctx.r[11].s64 = ctx.r[6].s64 + -1;
	pc = 0x82400EB8; continue 'dispatch;
            }
            0x82400EB8 => {
    //   block [0x82400EB8..0x82400F34)
	// 82400EB8: C16A0000  lfs f11, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82400EBC: 38DF0004  addi r6, r31, 4
	ctx.r[6].s64 = ctx.r[31].s64 + 4;
	// 82400EC0: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82400EC4: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82400EC8: ED0D5828  fsubs f8, f13, f11
	ctx.f[8].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82400ECC: C1470000  lfs f10, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82400ED0: C1880000  lfs f12, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82400ED4: EDAB682A  fadds f13, f11, f13
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 82400ED8: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400EDC: ECEA602A  fadds f7, f10, f12
	ctx.f[7].f64 = ((ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64;
	// 82400EE0: C1260000  lfs f9, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82400EE4: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82400EE8: 3BE60004  addi r31, r6, 4
	ctx.r[31].s64 = ctx.r[6].s64 + 4;
	// 82400EEC: ED600232  fmuls f11, f0, f8
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[8].f64) as f32) as f64);
	// 82400EF0: ED490232  fmuls f10, f9, f8
	ctx.f[10].f64 = (((ctx.f[9].f64 * ctx.f[8].f64) as f32) as f64);
	// 82400EF4: ED6959FA  fmadds f11, f9, f7, f11
	ctx.f[11].f64 = (((ctx.f[9].f64 * ctx.f[7].f64 + ctx.f[11].f64) as f32) as f64);
	// 82400EF8: EC0051F8  fmsubs f0, f0, f7, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[7].f64 - ctx.f[10].f64) as f32) as f64);
	// 82400EFC: ED4C5828  fsubs f10, f12, f11
	ctx.f[10].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82400F00: ED8B602A  fadds f12, f11, f12
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 82400F04: D1880000  stfs f12, 0(r8)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400F08: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82400F0C: D1890000  stfs f12, 0(r9)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400F10: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82400F14: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400F18: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82400F1C: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82400F20: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 82400F24: FC005050  fneg f0, f10
	ctx.f[0].u64 = ctx.f[10].u64 ^ 0x8000_0000_0000_0000u64;
	// 82400F28: D0070000  stfs f0, 0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82400F2C: 38E7FFFC  addi r7, r7, -4
	ctx.r[7].s64 = ctx.r[7].s64 + -4;
	// 82400F30: 4082FF88  bne 0x82400eb8
	if !ctx.cr[0].eq {
	pc = 0x82400EB8; continue 'dispatch;
	}
	pc = 0x82400F34; continue 'dispatch;
            }
            0x82400F34 => {
    //   block [0x82400F34..0x82400F3C)
	// 82400F34: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82400F38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82400F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82400F40 size=760
    let mut pc: u32 = 0x82400F40;
    'dispatch: loop {
        match pc {
            0x82400F40 => {
    //   block [0x82400F40..0x82400F6C)
	// 82400F40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82400F44: 48134155  bl 0x82535098
	ctx.lr = 0x82400F48;
	sub_82535080(ctx, base);
	// 82400F48: DBC1FF88  stfd f30, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[30].u64 ) };
	// 82400F4C: DBE1FF90  stfd f31, -0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[31].u64 ) };
	// 82400F50: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82400F54: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82400F58: 396BB4C0  addi r11, r11, -0x4b40
	ctx.r[11].s64 = ctx.r[11].s64 + -19264;
	// 82400F5C: 2F050100  cmpwi cr6, r5, 0x100
	ctx.cr[6].compare_i32(ctx.r[5].s32, 256, &mut ctx.xer);
	// 82400F60: 3BEB0600  addi r31, r11, 0x600
	ctx.r[31].s64 = ctx.r[11].s64 + 1536;
	// 82400F64: 419A0008  beq cr6, 0x82400f6c
	if ctx.cr[6].eq {
	pc = 0x82400F6C; continue 'dispatch;
	}
	// 82400F68: 3BEB0780  addi r31, r11, 0x780
	ctx.r[31].s64 = ctx.r[11].s64 + 1920;
	pc = 0x82400F6C; continue 'dispatch;
            }
            0x82400F6C => {
    //   block [0x82400F6C..0x82400F74)
	// 82400F6C: 7CAB2670  srawi r11, r5, 4
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[5].s32 >> 4) as i64;
	// 82400F70: 1E8B0060  mulli r20, r11, 0x60
	ctx.r[20].s32 = ((ctx.r[11].s32 as i64 * 96 as i64) as i32);
	ctx.r[20].s64 = ctx.r[20].s32 as i64;
	pc = 0x82400F74; continue 'dispatch;
            }
            0x82400F74 => {
    //   block [0x82400F74..0x82400FA8)
	// 82400F74: 57AB2036  slwi r11, r29, 4
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82400F78: 7CBB1670  srawi r27, r5, 2
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[27].s64 = (ctx.r[5].s32 >> 2) as i64;
	// 82400F7C: 396BFFF4  addi r11, r11, -0xc
	ctx.r[11].s64 = ctx.r[11].s64 + -12;
	// 82400F80: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82400F84: 7D6BD9D6  mullw r11, r11, r27
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * ctx.r[27].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82400F88: 7D4B1A14  add r10, r11, r3
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82400F8C: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 82400F90: 3B8AFFF0  addi r28, r10, -0x10
	ctx.r[28].s64 = ctx.r[10].s64 + -16;
	// 82400F94: 394BFFF0  addi r10, r11, -0x10
	ctx.r[10].s64 = ctx.r[11].s64 + -16;
	// 82400F98: 4099014C  ble cr6, 0x824010e4
	if !ctx.cr[6].gt {
	pc = 0x824010E4; continue 'dispatch;
	}
	// 82400F9C: 3ABBFFFC  addi r21, r27, -4
	ctx.r[21].s64 = ctx.r[27].s64 + -4;
	// 82400FA0: 1F1B000C  mulli r24, r27, 0xc
	ctx.r[24].s32 = ((ctx.r[27].s32 as i64 * 12 as i64) as i32);
	ctx.r[24].s64 = ctx.r[24].s32 as i64;
	// 82400FA4: 7FB6EB78  mr r22, r29
	ctx.r[22].u64 = ctx.r[29].u64;
	pc = 0x82400FA8; continue 'dispatch;
            }
            0x82400FA8 => {
    //   block [0x82400FA8..0x82400FC4)
	// 82400FA8: 7FF4F850  subf r31, r20, r31
	ctx.r[31].s64 = ctx.r[31].s64 - ctx.r[20].s64;
	// 82400FAC: 2F150000  cmpwi cr6, r21, 0
	ctx.cr[6].compare_i32(ctx.r[21].s32, 0, &mut ctx.xer);
	// 82400FB0: 41980124  blt cr6, 0x824010d4
	if ctx.cr[6].lt {
	pc = 0x824010D4; continue 'dispatch;
	}
	// 82400FB4: 39750004  addi r11, r21, 4
	ctx.r[11].s64 = ctx.r[21].s64 + 4;
	// 82400FB8: 577A1838  slwi r26, r27, 3
	ctx.r[26].u32 = ctx.r[27].u32.wrapping_shl(3);
	ctx.r[26].u64 = ctx.r[26].u32 as u64;
	// 82400FBC: 5779103A  slwi r25, r27, 2
	ctx.r[25].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[25].u64 = ctx.r[25].u32 as u64;
	// 82400FC0: 5577F0BE  srwi r23, r11, 2
	ctx.r[23].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[23].u64 = ctx.r[23].u32 as u64;
	pc = 0x82400FC4; continue 'dispatch;
            }
            0x82400FC4 => {
    //   block [0x82400FC4..0x82400FDC)
	// 82400FC4: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82400FC8: 7CD85214  add r6, r24, r10
	ctx.r[6].u64 = ctx.r[24].u64 + ctx.r[10].u64;
	// 82400FCC: 7CFA5214  add r7, r26, r10
	ctx.r[7].u64 = ctx.r[26].u64 + ctx.r[10].u64;
	// 82400FD0: 7D195214  add r8, r25, r10
	ctx.r[8].u64 = ctx.r[25].u64 + ctx.r[10].u64;
	// 82400FD4: 7D6AE050  subf r11, r10, r28
	ctx.r[11].s64 = ctx.r[28].s64 - ctx.r[10].s64;
	// 82400FD8: 3BC00004  li r30, 4
	ctx.r[30].s64 = 4;
	pc = 0x82400FDC; continue 'dispatch;
            }
            0x82400FDC => {
    //   block [0x82400FDC..0x824010D4)
	// 82400FDC: 7D8B3C2E  lfsx f12, r11, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82400FE0: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82400FE4: 7D6B342E  lfsx f11, r11, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82400FE8: 7C0B4C2E  lfsx f0, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82400FEC: 7DAB442E  lfsx f13, r11, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82400FF0: EFEC002A  fadds f31, f12, f0
	ctx.f[31].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82400FF4: C1070000  lfs f8, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82400FF8: EFCB682A  fadds f30, f11, f13
	ctx.f[30].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 82400FFC: C0E60000  lfs f7, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82401000: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82401004: C1490000  lfs f10, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82401008: EDAD5828  fsubs f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 8240100C: C1280000  lfs f9, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82401010: ED88502A  fadds f12, f8, f10
	ctx.f[12].f64 = ((ctx.f[8].f64 + ctx.f[10].f64) as f32) as f64;
	// 82401014: ED67482A  fadds f11, f7, f9
	ctx.f[11].f64 = ((ctx.f[7].f64 + ctx.f[9].f64) as f32) as f64;
	// 82401018: C0BF0010  lfs f5, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 8240101C: ED4A4028  fsubs f10, f10, f8
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[8].f64) as f32) as f64);
	// 82401020: C0DF0000  lfs f6, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82401024: ED293828  fsubs f9, f9, f7
	ctx.f[9].f64 = (((ctx.f[9].f64 - ctx.f[7].f64) as f32) as f64);
	// 82401028: C07F0030  lfs f3, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8240102C: C09F0020  lfs f4, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82401030: C03F0050  lfs f1, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82401034: C05F0040  lfs f2, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82401038: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 8240103C: ECFEF82A  fadds f7, f30, f31
	ctx.f[7].f64 = ((ctx.f[30].f64 + ctx.f[31].f64) as f32) as f64;
	// 82401040: 7CEB4D2E  stfsx f7, r11, r9
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 82401044: ED1FF028  fsubs f8, f31, f30
	ctx.f[8].f64 = (((ctx.f[31].f64 - ctx.f[30].f64) as f32) as f64);
	// 82401048: ECEC5828  fsubs f7, f12, f11
	ctx.f[7].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 8240104C: EFEA6828  fsubs f31, f10, f13
	ctx.f[31].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82401050: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82401054: ED8B602A  fadds f12, f11, f12
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 82401058: D1890000  stfs f12, 0(r9)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8240105C: EFC9002A  fadds f30, f9, f0
	ctx.f[30].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	// 82401060: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82401064: EC004828  fsubs f0, f0, f9
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[9].f64) as f32) as f64);
	// 82401068: ED870172  fmuls f12, f7, f5
	ctx.f[12].f64 = (((ctx.f[7].f64 * ctx.f[5].f64) as f32) as f64);
	// 8240106C: ED6701B2  fmuls f11, f7, f6
	ctx.f[11].f64 = (((ctx.f[7].f64 * ctx.f[6].f64) as f32) as f64);
	// 82401070: ED5F00F2  fmuls f10, f31, f3
	ctx.f[10].f64 = (((ctx.f[31].f64 * ctx.f[3].f64) as f32) as f64);
	// 82401074: ED3F0132  fmuls f9, f31, f4
	ctx.f[9].f64 = (((ctx.f[31].f64 * ctx.f[4].f64) as f32) as f64);
	// 82401078: ECED0072  fmuls f7, f13, f1
	ctx.f[7].f64 = (((ctx.f[13].f64 * ctx.f[1].f64) as f32) as f64);
	// 8240107C: EDAD00B2  fmuls f13, f13, f2
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[2].f64) as f32) as f64);
	// 82401080: ED8861B8  fmsubs f12, f8, f6, f12
	ctx.f[12].f64 = (((ctx.f[8].f64 * ctx.f[6].f64 - ctx.f[12].f64) as f32) as f64);
	// 82401084: 7D8B452E  stfsx f12, r11, r8
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), tmp.u32) };
	// 82401088: ED88597A  fmadds f12, f8, f5, f11
	ctx.f[12].f64 = (((ctx.f[8].f64 * ctx.f[5].f64 + ctx.f[11].f64) as f32) as f64);
	// 8240108C: D1880000  stfs f12, 0(r8)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82401090: ED9E5138  fmsubs f12, f30, f4, f10
	ctx.f[12].f64 = (((ctx.f[30].f64 * ctx.f[4].f64 - ctx.f[10].f64) as f32) as f64);
	// 82401094: 7D8B3D2E  stfsx f12, r11, r7
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32), tmp.u32) };
	// 82401098: ED9E48FA  fmadds f12, f30, f3, f9
	ctx.f[12].f64 = (((ctx.f[30].f64 * ctx.f[3].f64 + ctx.f[9].f64) as f32) as f64);
	// 8240109C: D1870000  stfs f12, 0(r7)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 824010A0: ED8038B8  fmsubs f12, f0, f2, f7
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[2].f64 - ctx.f[7].f64) as f32) as f64);
	// 824010A4: 7D8B352E  stfsx f12, r11, r6
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[6].u32), tmp.u32) };
	// 824010A8: EC00687A  fmadds f0, f0, f1, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64 + ctx.f[13].f64) as f32) as f64);
	// 824010AC: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 824010B0: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 824010B4: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 824010B8: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 824010BC: 4082FF20  bne 0x82400fdc
	if !ctx.cr[0].eq {
	pc = 0x82400FDC; continue 'dispatch;
	}
	// 824010C0: 36F7FFFF  addic. r23, r23, -1
	ctx.xer.ca = (ctx.r[23].u32 > (!(-1 as u32)));
	ctx.r[23].s64 = ctx.r[23].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 824010C4: 3B9CFFF0  addi r28, r28, -0x10
	ctx.r[28].s64 = ctx.r[28].s64 + -16;
	// 824010C8: 394AFFF0  addi r10, r10, -0x10
	ctx.r[10].s64 = ctx.r[10].s64 + -16;
	// 824010CC: 3BFF0050  addi r31, r31, 0x50
	ctx.r[31].s64 = ctx.r[31].s64 + 80;
	// 824010D0: 4082FEF4  bne 0x82400fc4
	if !ctx.cr[0].eq {
	pc = 0x82400FC4; continue 'dispatch;
	}
	pc = 0x824010D4; continue 'dispatch;
            }
            0x824010D4 => {
    //   block [0x824010D4..0x824010E4)
	// 824010D4: 36D6FFFF  addic. r22, r22, -1
	ctx.xer.ca = (ctx.r[22].u32 > (!(-1 as u32)));
	ctx.r[22].s64 = ctx.r[22].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[22].s32, 0, &mut ctx.xer);
	// 824010D8: 7F98E050  subf r28, r24, r28
	ctx.r[28].s64 = ctx.r[28].s64 - ctx.r[24].s64;
	// 824010DC: 7D585050  subf r10, r24, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[24].s64;
	// 824010E0: 4082FEC8  bne 0x82400fa8
	if !ctx.cr[0].eq {
	pc = 0x82400FA8; continue 'dispatch;
	}
	pc = 0x824010E4; continue 'dispatch;
            }
            0x824010E4 => {
    //   block [0x824010E4..0x8240112C)
	// 824010E4: 7CAB1670  srawi r11, r5, 2
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[5].s32 >> 2) as i64;
	// 824010E8: 57BD103A  slwi r29, r29, 2
	ctx.r[29].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 824010EC: 7CAB0194  addze r5, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[5].s64 = tmp.s64;
	// 824010F0: 7CAB2670  srawi r11, r5, 4
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[5].s32 >> 4) as i64;
	// 824010F4: 2F050004  cmpwi cr6, r5, 4
	ctx.cr[6].compare_i32(ctx.r[5].s32, 4, &mut ctx.xer);
	// 824010F8: 1E8B0060  mulli r20, r11, 0x60
	ctx.r[20].s32 = ((ctx.r[11].s32 as i64 * 96 as i64) as i32);
	ctx.r[20].s64 = ctx.r[20].s32 as i64;
	// 824010FC: 7FF4FA14  add r31, r20, r31
	ctx.r[31].u64 = ctx.r[20].u64 + ctx.r[31].u64;
	// 82401100: 4199FE74  bgt cr6, 0x82400f74
	if ctx.cr[6].gt {
	pc = 0x82400F74; continue 'dispatch;
	}
	// 82401104: 57AB2036  slwi r11, r29, 4
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82401108: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8240110C: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82401110: 394BFFF0  addi r10, r11, -0x10
	ctx.r[10].s64 = ctx.r[11].s64 + -16;
	// 82401114: 409900A8  ble cr6, 0x824011bc
	if !ctx.cr[6].gt {
	pc = 0x824011BC; continue 'dispatch;
	}
	// 82401118: 7D635050  subf r11, r3, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[3].s64;
	// 8240111C: 7D041850  subf r8, r4, r3
	ctx.r[8].s64 = ctx.r[3].s64 - ctx.r[4].s64;
	// 82401120: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 82401124: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82401128: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x8240112C; continue 'dispatch;
            }
            0x8240112C => {
    //   block [0x8240112C..0x824011BC)
	// 8240112C: C18A0008  lfs f12, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82401130: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82401134: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401138: ECCC002A  fadds f6, f12, f0
	ctx.f[6].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 8240113C: C16A000C  lfs f11, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82401140: 7DA85C2E  lfsx f13, r8, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401144: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82401148: C10B0004  lfs f8, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 8240114C: ED8B682A  fadds f12, f11, f13
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 82401150: C14BFFFC  lfs f10, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82401154: EDAD5828  fsubs f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82401158: ED68502A  fadds f11, f8, f10
	ctx.f[11].f64 = ((ctx.f[8].f64 + ctx.f[10].f64) as f32) as f64;
	// 8240115C: C0EB0008  lfs f7, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82401160: C12B0000  lfs f9, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82401164: ED4A4028  fsubs f10, f10, f8
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[8].f64) as f32) as f64);
	// 82401168: ED07482A  fadds f8, f7, f9
	ctx.f[8].f64 = ((ctx.f[7].f64 + ctx.f[9].f64) as f32) as f64;
	// 8240116C: ED293828  fsubs f9, f9, f7
	ctx.f[9].f64 = (((ctx.f[9].f64 - ctx.f[7].f64) as f32) as f64);
	// 82401170: ECEC302A  fadds f7, f12, f6
	ctx.f[7].f64 = ((ctx.f[12].f64 + ctx.f[6].f64) as f32) as f64;
	// 82401174: D0EA0000  stfs f7, 0(r10)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82401178: ED866028  fsubs f12, f6, f12
	ctx.f[12].f64 = (((ctx.f[6].f64 - ctx.f[12].f64) as f32) as f64);
	// 8240117C: 7D885D2E  stfsx f12, r8, r11
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82401180: ED8A6828  fsubs f12, f10, f13
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82401184: D18B0004  stfs f12, 4(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82401188: ED88582A  fadds f12, f8, f11
	ctx.f[12].f64 = ((ctx.f[8].f64 + ctx.f[11].f64) as f32) as f64;
	// 8240118C: D18BFFFC  stfs f12, -4(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82401190: ED89002A  fadds f12, f9, f0
	ctx.f[12].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	// 82401194: D18A0008  stfs f12, 8(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82401198: EC004828  fsubs f0, f0, f9
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[9].f64) as f32) as f64);
	// 8240119C: D00A000C  stfs f0, 0xc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 824011A0: ED8B4028  fsubs f12, f11, f8
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[8].f64) as f32) as f64);
	// 824011A4: D18B0000  stfs f12, 0(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 824011A8: EC0A682A  fadds f0, f10, f13
	ctx.f[0].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 824011AC: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 824011B0: 394AFFF0  addi r10, r10, -0x10
	ctx.r[10].s64 = ctx.r[10].s64 + -16;
	// 824011B4: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 824011B8: 4082FF74  bne 0x8240112c
	if !ctx.cr[0].eq {
	pc = 0x8240112C; continue 'dispatch;
	}
	pc = 0x824011BC; continue 'dispatch;
            }
            0x824011BC => {
    //   block [0x824011BC..0x824011DC)
	// 824011BC: 57A6103A  slwi r6, r29, 2
	ctx.r[6].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 824011C0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 824011C4: 38A6FFFF  addi r5, r6, -1
	ctx.r[5].s64 = ctx.r[6].s64 + -1;
	// 824011C8: 7CC90E70  srawi r9, r6, 1
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[6].s32 >> 1) as i64;
	// 824011CC: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 824011D0: 4099005C  ble cr6, 0x8240122c
	if !ctx.cr[6].gt {
	pc = 0x8240122C; continue 'dispatch;
	}
	// 824011D4: 39440004  addi r10, r4, 4
	ctx.r[10].s64 = ctx.r[4].s64 + 4;
	// 824011D8: 7D041850  subf r8, r4, r3
	ctx.r[8].s64 = ctx.r[3].s64 - ctx.r[4].s64;
	pc = 0x824011DC; continue 'dispatch;
            }
            0x824011DC => {
    //   block [0x824011DC..0x82401208)
	// 824011DC: 7F074800  cmpw cr6, r7, r9
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824011E0: 40990028  ble cr6, 0x82401208
	if !ctx.cr[6].gt {
	pc = 0x82401208; continue 'dispatch;
	}
	// 824011E4: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824011E8: 7C0A442E  lfsx f0, r10, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824011EC: 7DAB1C2E  lfsx f13, r11, r3
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824011F0: 7DAA452E  stfsx f13, r10, r8
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32), tmp.u32) };
	// 824011F4: 7C0B1D2E  stfsx f0, r11, r3
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32), tmp.u32) };
	// 824011F8: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824011FC: 7DAB242E  lfsx f13, r11, r4
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401200: D1AA0000  stfs f13, 0(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82401204: 7C0B252E  stfsx f0, r11, r4
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32), tmp.u32) };
	pc = 0x82401208; continue 'dispatch;
            }
            0x82401208 => {
    //   block [0x82401208..0x8240120C)
	// 82401208: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x8240120C; continue 'dispatch;
            }
            0x8240120C => {
    //   block [0x8240120C..0x8240122C)
	// 8240120C: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82401210: 7D694A78  xor r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 ^ ctx.r[9].u64;
	// 82401214: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82401218: 4198FFF4  blt cr6, 0x8240120c
	if ctx.cr[6].lt {
	pc = 0x8240120C; continue 'dispatch;
	}
	// 8240121C: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 82401220: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82401224: 7F072800  cmpw cr6, r7, r5
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82401228: 4198FFB4  blt cr6, 0x824011dc
	if ctx.cr[6].lt {
	pc = 0x824011DC; continue 'dispatch;
	}
	pc = 0x8240122C; continue 'dispatch;
            }
            0x8240122C => {
    //   block [0x8240122C..0x82401238)
	// 8240122C: CBC1FF88  lfd f30, -0x78(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 82401230: CBE1FF90  lfd f31, -0x70(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 82401234: 48133EB4  b 0x825350e8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82401238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82401238 size=600
    let mut pc: u32 = 0x82401238;
    'dispatch: loop {
        match pc {
            0x82401238 => {
    //   block [0x82401238..0x82401294)
	// 82401238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240123C: 48133E79  bl 0x825350b4
	ctx.lr = 0x82401240;
	sub_82535080(ctx, base);
	// 82401240: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 82401244: 48134DA1  bl 0x82535fe4
	ctx.lr = 0x82401248;
	sub_82535FB0(ctx, base);
	// 82401248: 9421FDA0  stwu r1, -0x260(r1)
	ea = ctx.r[1].u32.wrapping_add(-608 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240124C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82401250: FF800890  fmr f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[1].f64;
	// 82401254: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82401258: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8240125C: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 82401260: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 82401264: C36BBFFC  lfs f27, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82401268: 7D3B4B78  mr r27, r9
	ctx.r[27].u64 = ctx.r[9].u64;
	// 8240126C: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82401270: 40990044  ble cr6, 0x824012b4
	if !ctx.cr[6].gt {
	pc = 0x824012B4; continue 'dispatch;
	}
	// 82401274: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 82401278: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 8240127C: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82401280: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 82401284: 7D2A2850  subf r9, r10, r5
	ctx.r[9].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 82401288: C1A72238  lfs f13, 0x2238(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8760 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8240128C: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82401290: C00827E4  lfs f0, 0x27e4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(10212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82401294; continue 'dispatch;
            }
            0x82401294 => {
    //   block [0x82401294..0x824012B4)
	// 82401294: 7D895C2E  lfsx f12, r9, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82401298: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8240129C: ED8C683A  fmadds f12, f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 824012A0: ED8CD82A  fadds f12, f12, f27
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[27].f64) as f32) as f64;
	// 824012A4: FD80601E  fctiwz f12, f12
	ctx.f[12].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 824012A8: 7D805FAE  stfiwx f12, 0, r11
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 824012AC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824012B0: 4082FFE4  bne 0x82401294
	if !ctx.cr[0].eq {
	pc = 0x82401294; continue 'dispatch;
	}
	pc = 0x824012B4; continue 'dispatch;
            }
            0x824012B4 => {
    //   block [0x824012B4..0x824012EC)
	// 824012B4: 3881006C  addi r4, r1, 0x6c
	ctx.r[4].s64 = ctx.r[1].s64 + 108;
	// 824012B8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 824012BC: 4BFFC435  bl 0x823fd6f0
	ctx.lr = 0x824012C0;
	sub_823FD6F0(ctx, base);
	// 824012C0: 81210068  lwz r9, 0x68(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 824012C4: D3810060  stfs f28, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 824012C8: 80E1006C  lwz r7, 0x6c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 824012CC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 824012D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824012D4: 2F070001  cmpwi cr6, r7, 1
	ctx.cr[6].compare_i32(ctx.r[7].s32, 1, &mut ctx.xer);
	// 824012D8: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824012DC: EC1C0028  fsubs f0, f28, f0
	ctx.f[0].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 824012E0: EDA00032  fmuls f13, f0, f0
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 824012E4: 4099006C  ble cr6, 0x82401350
	if !ctx.cr[6].gt {
	pc = 0x82401350; continue 'dispatch;
	}
	// 824012E8: 39090004  addi r8, r9, 4
	ctx.r[8].s64 = ctx.r[9].s64 + 4;
	pc = 0x824012EC; continue 'dispatch;
            }
            0x824012EC => {
    //   block [0x824012EC..0x82401308)
	// 824012EC: C0080000  lfs f0, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824012F0: EC1C0028  fsubs f0, f28, f0
	ctx.f[0].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 824012F4: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 824012F8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 824012FC: 4098000C  bge cr6, 0x82401308
	if !ctx.cr[6].lt {
	pc = 0x82401308; continue 'dispatch;
	}
	// 82401300: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82401304: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82401308; continue 'dispatch;
            }
            0x82401308 => {
    //   block [0x82401308..0x82401350)
	// 82401308: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8240130C: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82401310: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82401314: 4198FFD8  blt cr6, 0x824012ec
	if ctx.cr[6].lt {
	pc = 0x824012EC; continue 'dispatch;
	}
	// 82401318: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 8240131C: 41980034  blt cr6, 0x82401350
	if ctx.cr[6].lt {
	pc = 0x82401350; continue 'dispatch;
	}
	// 82401320: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82401324: 3907FFFF  addi r8, r7, -1
	ctx.r[8].s64 = ctx.r[7].s64 + -1;
	// 82401328: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 8240132C: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82401330: C00BFFFC  lfs f0, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401334: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401338: EFED0028  fsubs f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8240133C: 40980028  bge cr6, 0x82401364
	if !ctx.cr[6].lt {
	pc = 0x82401364; continue 'dispatch;
	}
	// 82401340: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401344: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82401348: EFE006F2  fmuls f31, f0, f27
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 8240134C: 48000018  b 0x82401364
	pc = 0x82401364; continue 'dispatch;
            }
            0x82401350 => {
    //   block [0x82401350..0x82401364)
	// 82401350: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82401354: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82401358: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8240135C: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401360: EFE06828  fsubs f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x82401364; continue 'dispatch;
            }
            0x82401364 => {
    //   block [0x82401364..0x8240137C)
	// 82401364: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82401368: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8240136C: C3ABBCA0  lfs f29, -0x4360(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17248 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82401370: 40990020  ble cr6, 0x82401390
	if !ctx.cr[6].gt {
	pc = 0x82401390; continue 'dispatch;
	}
	// 82401374: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 82401378: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x8240137C; continue 'dispatch;
            }
            0x8240137C => {
    //   block [0x8240137C..0x82401390)
	// 8240137C: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401380: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82401384: EFBD002A  fadds f29, f29, f0
	ctx.f[29].f64 = ((ctx.f[29].f64 + ctx.f[0].f64) as f32) as f64;
	// 82401388: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 8240138C: 4082FFF0  bne 0x8240137c
	if !ctx.cr[0].eq {
	pc = 0x8240137C; continue 'dispatch;
	}
	pc = 0x82401390; continue 'dispatch;
            }
            0x82401390 => {
    //   block [0x82401390..0x824013CC)
	// 82401390: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82401394: C00B203C  lfs f0, 0x203c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401398: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8240139C: EC1F0032  fmuls f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 824013A0: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824013A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824013A8: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 824013AC: C1AB2418  lfs f13, 0x2418(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9240 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824013B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824013B4: EC5C0028  fsubs f2, f28, f0
	ctx.f[2].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 824013B8: EC3F0372  fmuls f1, f31, f13
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[13].f64) as f32) as f64);
	// 824013BC: C3CB1848  lfs f30, 0x1848(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 824013C0: FF02F000  fcmpu cr6, f2, f30
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[30].f64);
	// 824013C4: 40980008  bge cr6, 0x824013cc
	if !ctx.cr[6].lt {
	pc = 0x824013CC; continue 'dispatch;
	}
	// 824013C8: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	pc = 0x824013CC; continue 'dispatch;
            }
            0x824013CC => {
    //   block [0x824013CC..0x824013E4)
	// 824013CC: EC60E02A  fadds f3, f0, f28
	ctx.f[3].f64 = ((ctx.f[0].f64 + ctx.f[28].f64) as f32) as f64;
	// 824013D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824013D4: C38B2ECC  lfs f28, 0x2ecc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11980 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 824013D8: FF03E000  fcmpu cr6, f3, f28
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[28].f64);
	// 824013DC: 40990008  ble cr6, 0x824013e4
	if !ctx.cr[6].gt {
	pc = 0x824013E4; continue 'dispatch;
	}
	// 824013E0: FC60E090  fmr f3, f28
	ctx.f[3].f64 = ctx.f[28].f64;
	pc = 0x824013E4; continue 'dispatch;
            }
            0x824013E4 => {
    //   block [0x824013E4..0x82401430)
	// 824013E4: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 824013E8: FC80E890  fmr f4, f29
	ctx.f[4].f64 = ctx.f[29].f64;
	// 824013EC: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 824013F0: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 824013F4: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 824013F8: 38C10064  addi r6, r1, 0x64
	ctx.r[6].s64 = ctx.r[1].s64 + 100;
	// 824013FC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82401400: 48000BF9  bl 0x82401ff8
	ctx.lr = 0x82401404;
	sub_82401FF8(ctx, base);
	// 82401404: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82401408: C00B2038  lfs f0, 0x2038(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8240140C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82401410: EC1F0032  fmuls f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 82401414: C1AB2144  lfs f13, 0x2144(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8516 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401418: EC3F0372  fmuls f1, f31, f13
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[13].f64) as f32) as f64);
	// 8240141C: C1A10060  lfs f13, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401420: EC4D0028  fsubs f2, f13, f0
	ctx.f[2].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82401424: FF02F000  fcmpu cr6, f2, f30
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[30].f64);
	// 82401428: 40980008  bge cr6, 0x82401430
	if !ctx.cr[6].lt {
	pc = 0x82401430; continue 'dispatch;
	}
	// 8240142C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	pc = 0x82401430; continue 'dispatch;
            }
            0x82401430 => {
    //   block [0x82401430..0x82401440)
	// 82401430: EC60682A  fadds f3, f0, f13
	ctx.f[3].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82401434: FF03E000  fcmpu cr6, f3, f28
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[28].f64);
	// 82401438: 40990008  ble cr6, 0x82401440
	if !ctx.cr[6].gt {
	pc = 0x82401440; continue 'dispatch;
	}
	// 8240143C: FC60E090  fmr f3, f28
	ctx.f[3].f64 = ctx.f[28].f64;
	pc = 0x82401440; continue 'dispatch;
            }
            0x82401440 => {
    //   block [0x82401440..0x82401490)
	// 82401440: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82401444: FC80E890  fmr f4, f29
	ctx.f[4].f64 = ctx.f[29].f64;
	// 82401448: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 8240144C: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82401450: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82401454: 38C10064  addi r6, r1, 0x64
	ctx.r[6].s64 = ctx.r[1].s64 + 100;
	// 82401458: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8240145C: 48000B9D  bl 0x82401ff8
	ctx.lr = 0x82401460;
	sub_82401FF8(ctx, base);
	// 82401460: C0010064  lfs f0, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401464: EC0006F2  fmuls f0, f0, f27
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82401468: D3BD0000  stfs f29, 0(r29)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8240146C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82401470: EC00E824  fdivs f0, f0, f29
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[29].f64) as f32) as f64;
	// 82401474: D01B0000  stfs f0, 0(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82401478: C0010060  lfs f0, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8240147C: D01C0000  stfs f0, 0(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82401480: 38210260  addi r1, r1, 0x260
	ctx.r[1].s64 = ctx.r[1].s64 + 608;
	// 82401484: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 82401488: 48134BA9  bl 0x82536030
	ctx.lr = 0x8240148C;
	sub_82535FFC(ctx, base);
	// 8240148C: 48133C78  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82401490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82401490 size=112
    let mut pc: u32 = 0x82401490;
    'dispatch: loop {
        match pc {
            0x82401490 => {
    //   block [0x82401490..0x824014A0)
	// 82401490: 3D200000  lis r9, 0
	ctx.r[9].s64 = 0;
	// 82401494: 396403FC  addi r11, r4, 0x3fc
	ctx.r[11].s64 = ctx.r[4].s64 + 1020;
	// 82401498: 6129A280  ori r9, r9, 0xa280
	ctx.r[9].u64 = ctx.r[9].u64 | 41600;
	// 8240149C: 394000FF  li r10, 0xff
	ctx.r[10].s64 = 255;
	pc = 0x824014A0; continue 'dispatch;
            }
            0x824014A0 => {
    //   block [0x824014A0..0x824014E0)
	// 824014A0: 3929FF5E  addi r9, r9, -0xa2
	ctx.r[9].s64 = ctx.r[9].s64 + -162;
	// 824014A4: 5528C23E  srwi r8, r9, 8
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shr(8);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 824014A8: 39080041  addi r8, r8, 0x41
	ctx.r[8].s64 = ctx.r[8].s64 + 65;
	// 824014AC: 7D0851D6  mullw r8, r8, r10
	ctx.r[8].s32 = ((ctx.r[8].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 824014B0: 390800D1  addi r8, r8, 0xd1
	ctx.r[8].s64 = ctx.r[8].s64 + 209;
	// 824014B4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 824014B8: 5508C23E  srwi r8, r8, 8
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(8);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 824014BC: 2B0A0056  cmplwi cr6, r10, 0x56
	ctx.cr[6].compare_u32(ctx.r[10].u32, 86 as u32, &mut ctx.xer);
	// 824014C0: 3908001D  addi r8, r8, 0x1d
	ctx.r[8].s64 = ctx.r[8].s64 + 29;
	// 824014C4: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 824014C8: 7C081C2E  lfsx f0, r8, r3
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824014CC: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 824014D0: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 824014D4: 4199FFCC  bgt cr6, 0x824014a0
	if ctx.cr[6].gt {
	pc = 0x824014A0; continue 'dispatch;
	}
	// 824014D8: 3940457D  li r10, 0x457d
	ctx.r[10].s64 = 17789;
	// 824014DC: 39200057  li r9, 0x57
	ctx.r[9].s64 = 87;
	pc = 0x824014E0; continue 'dispatch;
            }
            0x824014E0 => {
    //   block [0x824014E0..0x82401500)
	// 824014E0: 394AFF35  addi r10, r10, -0xcb
	ctx.r[10].s64 = ctx.r[10].s64 + -203;
	// 824014E4: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 824014E8: 5548D1BA  rlwinm r8, r10, 0x1a, 6, 0x1d
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 824014EC: 7C081C2E  lfsx f0, r8, r3
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824014F0: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 824014F4: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 824014F8: 4082FFE8  bne 0x824014e0
	if !ctx.cr[0].eq {
	pc = 0x824014E0; continue 'dispatch;
	}
	// 824014FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82401500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82401500 size=328
    let mut pc: u32 = 0x82401500;
    'dispatch: loop {
        match pc {
            0x82401500 => {
    //   block [0x82401500..0x82401518)
	// 82401500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82401504: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82401508: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240150C: 7C8B0735  extsh. r11, r4
	ctx.r[11].s64 = ctx.r[4].s16 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82401510: 41810008  bgt 0x82401518
	if ctx.cr[0].gt {
	pc = 0x82401518; continue 'dispatch;
	}
	// 82401514: 388000B0  li r4, 0xb0
	ctx.r[4].s64 = 176;
	pc = 0x82401518; continue 'dispatch;
            }
            0x82401518 => {
    //   block [0x82401518..0x82401554)
	// 82401518: 7C8B0734  extsh r11, r4
	ctx.r[11].s64 = ctx.r[4].s16 as i64;
	// 8240151C: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401520: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82401524: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82401528: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8240152C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82401530: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82401534: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82401538: C1AB184C  lfs f13, 0x184c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6220 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8240153C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82401540: C18BBCB4  lfs f12, -0x434c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17228 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82401544: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82401548: 4199000C  bgt cr6, 0x82401554
	if ctx.cr[6].gt {
	pc = 0x82401554; continue 'dispatch;
	}
	// 8240154C: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82401550: 40980028  bge cr6, 0x82401578
	if !ctx.cr[6].lt {
	pc = 0x82401578; continue 'dispatch;
	}
	pc = 0x82401554; continue 'dispatch;
            }
            0x82401554 => {
    //   block [0x82401554..0x82401564)
	// 82401554: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82401558: 4098000C  bge cr6, 0x82401564
	if !ctx.cr[6].lt {
	pc = 0x82401564; continue 'dispatch;
	}
	// 8240155C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82401560: 48000008  b 0x82401568
	pc = 0x82401568; continue 'dispatch;
            }
            0x82401564 => {
    //   block [0x82401564..0x82401568)
	// 82401564: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x82401568; continue 'dispatch;
            }
            0x82401568 => {
    //   block [0x82401568..0x82401578)
	// 82401568: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8240156C: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401570: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82401574: 409A000C  bne cr6, 0x82401580
	if !ctx.cr[6].eq {
	pc = 0x82401580; continue 'dispatch;
	}
	pc = 0x82401578; continue 'dispatch;
            }
            0x82401578 => {
    //   block [0x82401578..0x82401580)
	// 82401578: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8240157C: 480000BC  b 0x82401638
	pc = 0x82401638; continue 'dispatch;
            }
            0x82401580 => {
    //   block [0x82401580..0x824015BC)
	// 82401580: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82401584: 40980060  bge cr6, 0x824015e4
	if !ctx.cr[6].lt {
	pc = 0x824015E4; continue 'dispatch;
	}
	// 82401588: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8240158C: C1ABBCB0  lfs f13, -0x4350(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401590: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82401594: EC400372  fmuls f2, f0, f13
	ctx.f[2].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82401598: C82B2260  lfd f1, 0x2260(r11)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8800 as u32) ) };
	// 8240159C: 481321D5  bl 0x82533770
	ctx.lr = 0x824015A0;
	sub_82533770(ctx, base);
	// 824015A0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 824015A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824015A8: C1ABBCAC  lfs f13, -0x4354(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17236 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824015AC: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 824015B0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 824015B4: 40980008  bge cr6, 0x824015bc
	if !ctx.cr[6].lt {
	pc = 0x824015BC; continue 'dispatch;
	}
	// 824015B8: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x824015BC; continue 'dispatch;
            }
            0x824015BC => {
    //   block [0x824015BC..0x824015E4)
	// 824015BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824015C0: C1AB1850  lfs f13, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824015C4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824015C8: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 824015CC: C00B2898  lfs f0, 0x2898(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10392 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824015D0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 824015D4: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 824015D8: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 824015DC: A0610056  lhz r3, 0x56(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 824015E0: 48000058  b 0x82401638
	pc = 0x82401638; continue 'dispatch;
            }
            0x824015E4 => {
    //   block [0x824015E4..0x82401614)
	// 824015E4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824015E8: C1ABBCA8  lfs f13, -0x4358(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17240 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824015EC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824015F0: EC400372  fmuls f2, f0, f13
	ctx.f[2].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 824015F4: C82B2260  lfd f1, 0x2260(r11)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8800 as u32) ) };
	// 824015F8: 48132179  bl 0x82533770
	ctx.lr = 0x824015FC;
	sub_82533770(ctx, base);
	// 824015FC: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82401600: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82401604: C1ABBCA4  lfs f13, -0x435c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17244 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401608: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8240160C: 40990008  ble cr6, 0x82401614
	if !ctx.cr[6].gt {
	pc = 0x82401614; continue 'dispatch;
	}
	// 82401610: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82401614; continue 'dispatch;
            }
            0x82401614 => {
    //   block [0x82401614..0x82401638)
	// 82401614: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82401618: C1AB1850  lfs f13, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8240161C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82401620: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82401624: C00B2898  lfs f0, 0x2898(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10392 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401628: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8240162C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82401630: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82401634: A0610056  lhz r3, 0x56(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	pc = 0x82401638; continue 'dispatch;
            }
            0x82401638 => {
    //   block [0x82401638..0x82401648)
	// 82401638: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8240163C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82401640: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82401644: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82401648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82401648 size=268
    let mut pc: u32 = 0x82401648;
    'dispatch: loop {
        match pc {
            0x82401648 => {
    //   block [0x82401648..0x8240168C)
	// 82401648: 546BEEFE  rlwinm r11, r3, 0x1d, 0x1b, 0x1f
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00000007u64;
	// 8240164C: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82401650: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82401654: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82401658: C1A9BCB8  lfs f13, -0x4348(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8240165C: C1881850  lfs f12, 0x1850(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(6224 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82401660: 7D695B79  or. r9, r11, r11
	ctx.r[9].u64 = ctx.r[11].u64 | ctx.r[11].u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82401664: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82401668: 7C0B542E  lfsx f0, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8240166C: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82401670: EC00637A  fmadds f0, f0, f13, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 82401674: 7C0B552E  stfsx f0, r11, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 82401678: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8240167C: 7C0A5C2E  lfsx f0, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401680: 40810030  ble 0x824016b0
	if !ctx.cr[0].gt {
	pc = 0x824016B0; continue 'dispatch;
	}
	// 82401684: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82401688: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	pc = 0x8240168C; continue 'dispatch;
            }
            0x8240168C => {
    //   block [0x8240168C..0x824016B0)
	// 8240168C: 7D6B542E  lfsx f11, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82401690: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82401694: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82401698: 7D6B552E  stfsx f11, r11, r10
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 8240169C: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 824016A0: 7D6B542E  lfsx f11, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 824016A4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824016A8: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 824016AC: 4082FFE0  bne 0x8240168c
	if !ctx.cr[0].eq {
	pc = 0x8240168C; continue 'dispatch;
	}
	pc = 0x824016B0; continue 'dispatch;
            }
            0x824016B0 => {
    //   block [0x824016B0..0x824016C4)
	// 824016B0: 39690001  addi r11, r9, 1
	ctx.r[11].s64 = ctx.r[9].s64 + 1;
	// 824016B4: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 824016B8: 41990030  bgt cr6, 0x824016e8
	if ctx.cr[6].gt {
	pc = 0x824016E8; continue 'dispatch;
	}
	// 824016BC: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 824016C0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	pc = 0x824016C4; continue 'dispatch;
            }
            0x824016C4 => {
    //   block [0x824016C4..0x824016E8)
	// 824016C4: 7D6B542E  lfsx f11, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 824016C8: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 824016CC: 7D6B552E  stfsx f11, r11, r10
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 824016D0: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 824016D4: 7D6B542E  lfsx f11, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 824016D8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824016DC: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 824016E0: 2F0B0080  cmpwi cr6, r11, 0x80
	ctx.cr[6].compare_i32(ctx.r[11].s32, 128, &mut ctx.xer);
	// 824016E4: 4099FFE0  ble cr6, 0x824016c4
	if !ctx.cr[6].gt {
	pc = 0x824016C4; continue 'dispatch;
	}
	pc = 0x824016E8; continue 'dispatch;
            }
            0x824016E8 => {
    //   block [0x824016E8..0x82401700)
	// 824016E8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824016EC: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 824016F0: EC0C0024  fdivs f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 824016F4: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824016F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824016FC: D1A40004  stfs f13, 4(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	pc = 0x82401700; continue 'dispatch;
            }
            0x82401700 => {
    //   block [0x82401700..0x82401754)
	// 82401700: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82401704: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401708: C1840004  lfs f12, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8240170C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82401710: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82401714: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 82401718: F921FFF0  std r9, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u64 ) };
	// 8240171C: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82401720: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 82401724: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82401728: EDAB0372  fmuls f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 8240172C: EDAD603A  fmadds f13, f13, f0, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 82401730: D1A40004  stfs f13, 4(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82401734: 4099FFCC  ble cr6, 0x82401700
	if !ctx.cr[6].gt {
	pc = 0x82401700; continue 'dispatch;
	}
	// 82401738: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8240173C: C00B1848  lfs f0, 0x1848(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401740: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82401744: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82401748: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8240174C: B1640008  sth r11, 8(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u16 ) };
	// 82401750: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82401758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82401758 size=88
    let mut pc: u32 = 0x82401758;
    'dispatch: loop {
        match pc {
            0x82401758 => {
    //   block [0x82401758..0x82401770)
	// 82401758: A9630008  lha r11, 8(r3)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as i16) as i64;
	// 8240175C: 2F0B0054  cmpwi cr6, r11, 0x54
	ctx.cr[6].compare_i32(ctx.r[11].s32, 84, &mut ctx.xer);
	// 82401760: 41990038  bgt cr6, 0x82401798
	if ctx.cr[6].gt {
	pc = 0x82401798; continue 'dispatch;
	}
	// 82401764: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82401768: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8240176C: C00ABCBC  lfs f0, -0x4344(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17220 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82401770; continue 'dispatch;
            }
            0x82401770 => {
    //   block [0x82401770..0x82401798)
	// 82401770: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82401774: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82401778: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 8240177C: 7D0B0734  extsh r11, r8
	ctx.r[11].s64 = ctx.r[8].s16 as i64;
	// 82401780: 7DAA4C2E  lfsx f13, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401784: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 82401788: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8240178C: 7DAA4D2E  stfsx f13, r10, r9
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 82401790: 4099FFE0  ble cr6, 0x82401770
	if !ctx.cr[6].gt {
	pc = 0x82401770; continue 'dispatch;
	}
	// 82401794: 4800000C  b 0x824017a0
	pc = 0x824017A0; continue 'dispatch;
            }
            0x82401798 => {
    //   block [0x82401798..0x824017A0)
	// 82401798: 39600054  li r11, 0x54
	ctx.r[11].s64 = 84;
	// 8240179C: B1630008  sth r11, 8(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u16 ) };
	pc = 0x824017A0; continue 'dispatch;
            }
            0x824017A0 => {
    //   block [0x824017A0..0x824017B0)
	// 824017A0: A1630008  lhz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 824017A4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824017A8: B1630008  sth r11, 8(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u16 ) };
	// 824017AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824017B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824017B0 size=112
    let mut pc: u32 = 0x824017B0;
    'dispatch: loop {
        match pc {
            0x824017B0 => {
    //   block [0x824017B0..0x824017E4)
	// 824017B0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824017B4: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824017B8: C1ABBCD8  lfs f13, -0x4328(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824017BC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 824017C0: 40990024  ble cr6, 0x824017e4
	if !ctx.cr[6].gt {
	pc = 0x824017E4; continue 'dispatch;
	}
	// 824017C4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824017C8: C1ABBCD4  lfs f13, -0x432c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17196 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824017CC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824017D0: C18BBCD0  lfs f12, -0x4330(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17200 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 824017D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824017D8: ED80637C  fnmsubs f12, f0, f13, f12
	ctx.f[12].f64 = -(((ctx.f[0].f64 * ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 824017DC: C1ABBCCC  lfs f13, -0x4334(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17204 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824017E0: 48000020  b 0x82401800
	pc = 0x82401800; continue 'dispatch;
            }
            0x824017E4 => {
    //   block [0x824017E4..0x82401800)
	// 824017E4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824017E8: C1ABBCC8  lfs f13, -0x4338(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17208 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824017EC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824017F0: C18BBCC4  lfs f12, -0x433c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 824017F4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824017F8: ED80637C  fnmsubs f12, f0, f13, f12
	ctx.f[12].f64 = -(((ctx.f[0].f64 * ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 824017FC: C1ABBCC0  lfs f13, -0x4340(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82401800; continue 'dispatch;
            }
            0x82401800 => {
    //   block [0x82401800..0x82401818)
	// 82401800: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82401804: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82401808: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8240180C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82401810: 41990008  bgt cr6, 0x82401818
	if ctx.cr[6].gt {
	pc = 0x82401818; continue 'dispatch;
	}
	// 82401814: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82401818; continue 'dispatch;
            }
            0x82401818 => {
    //   block [0x82401818..0x82401820)
	// 82401818: 99640013  stb r11, 0x13(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(19 as u32), ctx.r[11].u8 ) };
	// 8240181C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82401820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82401820 size=132
    let mut pc: u32 = 0x82401820;
    'dispatch: loop {
        match pc {
            0x82401820 => {
    //   block [0x82401820..0x82401864)
	// 82401820: 89660013  lbz r11, 0x13(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(19 as u32) ) } as u64;
	// 82401824: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82401828: 419A006C  beq cr6, 0x82401894
	if ctx.cr[6].eq {
	pc = 0x82401894; continue 'dispatch;
	}
	// 8240182C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82401830: C00BBCE0  lfs f0, -0x4320(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401834: 7CAB0734  extsh r11, r5
	ctx.r[11].s64 = ctx.r[5].s16 as i64;
	// 82401838: EC020028  fsubs f0, f2, f0
	ctx.f[0].f64 = (((ctx.f[2].f64 - ctx.f[0].f64) as f32) as f64);
	// 8240183C: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82401840: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82401844: C9A1FFF0  lfd f13, -0x10(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82401848: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8240184C: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82401850: C1ABBCDC  lfs f13, -0x4324(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17188 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401854: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82401858: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8240185C: 40980008  bge cr6, 0x82401864
	if !ctx.cr[6].lt {
	pc = 0x82401864; continue 'dispatch;
	}
	// 82401860: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82401864; continue 'dispatch;
            }
            0x82401864 => {
    //   block [0x82401864..0x8240188C)
	// 82401864: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82401868: 4198002C  blt cr6, 0x82401894
	if ctx.cr[6].lt {
	pc = 0x82401894; continue 'dispatch;
	}
	// 8240186C: A166000E  lhz r11, 0xe(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(14 as u32) ) } as u64;
	// 82401870: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82401874: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 82401878: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8240187C: B166000E  sth r11, 0xe(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(14 as u32), ctx.r[11].u16 ) };
	// 82401880: 4099000C  ble cr6, 0x8240188c
	if !ctx.cr[6].gt {
	pc = 0x8240188C; continue 'dispatch;
	}
	// 82401884: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82401888: 48000010  b 0x82401898
	pc = 0x82401898; continue 'dispatch;
            }
            0x8240188C => {
    //   block [0x8240188C..0x82401894)
	// 8240188C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82401890: 4800000C  b 0x8240189c
	pc = 0x8240189C; continue 'dispatch;
            }
            0x82401894 => {
    //   block [0x82401894..0x82401898)
	// 82401894: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82401898; continue 'dispatch;
            }
            0x82401898 => {
    //   block [0x82401898..0x8240189C)
	// 82401898: B166000E  sth r11, 0xe(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(14 as u32), ctx.r[11].u16 ) };
	pc = 0x8240189C; continue 'dispatch;
            }
            0x8240189C => {
    //   block [0x8240189C..0x824018A4)
	// 8240189C: 99660014  stb r11, 0x14(r6)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[6].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 824018A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824018A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824018A8 size=440
    let mut pc: u32 = 0x824018A8;
    'dispatch: loop {
        match pc {
            0x824018A8 => {
    //   block [0x824018A8..0x824018E4)
	// 824018A8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824018AC: C1A40000  lfs f13, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824018B0: C00BBCD8  lfs f0, -0x4328(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824018B4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 824018B8: 4098002C  bge cr6, 0x824018e4
	if !ctx.cr[6].lt {
	pc = 0x824018E4; continue 'dispatch;
	}
	// 824018BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824018C0: C00BBCF8  lfs f0, -0x4308(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824018C4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824018C8: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 824018CC: C18B26A0  lfs f12, 0x26a0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9888 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 824018D0: ED8D602A  fadds f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 824018D4: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 824018D8: 40980034  bge cr6, 0x8240190c
	if !ctx.cr[6].lt {
	pc = 0x8240190C; continue 'dispatch;
	}
	// 824018DC: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	// 824018E0: 4800002C  b 0x8240190c
	pc = 0x8240190C; continue 'dispatch;
            }
            0x824018E4 => {
    //   block [0x824018E4..0x82401900)
	// 824018E4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824018E8: C00BBCF4  lfs f0, -0x430c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824018EC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 824018F0: 40980010  bge cr6, 0x82401900
	if !ctx.cr[6].lt {
	pc = 0x82401900; continue 'dispatch;
	}
	// 824018F4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824018F8: C00BBCF0  lfs f0, -0x4310(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17168 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824018FC: 4800000C  b 0x82401908
	pc = 0x82401908; continue 'dispatch;
            }
            0x82401900 => {
    //   block [0x82401900..0x82401908)
	// 82401900: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82401904: C00BBCEC  lfs f0, -0x4314(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17172 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82401908; continue 'dispatch;
            }
            0x82401908 => {
    //   block [0x82401908..0x8240190C)
	// 82401908: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x8240190C; continue 'dispatch;
            }
            0x8240190C => {
    //   block [0x8240190C..0x82401950)
	// 8240190C: FF016800  fcmpu cr6, f1, f13
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[13].f64);
	// 82401910: 409800F0  bge cr6, 0x82401a00
	if !ctx.cr[6].lt {
	pc = 0x82401A00; continue 'dispatch;
	}
	// 82401914: 89640012  lbz r11, 0x12(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(18 as u32) ) } as u64;
	// 82401918: 7D6B0775  extsb. r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8240191C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82401920: C12B1850  lfs f9, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82401924: 4181002C  bgt 0x82401950
	if ctx.cr[0].gt {
	pc = 0x82401950; continue 'dispatch;
	}
	// 82401928: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8240192C: ED81482A  fadds f12, f1, f9
	ctx.f[12].f64 = ((ctx.f[1].f64 + ctx.f[9].f64) as f32) as f64;
	// 82401930: C16B8E30  lfs f11, -0x71d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29136 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82401934: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82401938: ED6D02F2  fmuls f11, f13, f11
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 8240193C: C14B8E24  lfs f10, -0x71dc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29148 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82401940: ED0C5ABA  fmadds f8, f12, f10, f11
	ctx.f[8].f64 = (((ctx.f[12].f64 * ctx.f[10].f64 + ctx.f[11].f64) as f32) as f64);
	// 82401944: FF080000  fcmpu cr6, f8, f0
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[0].f64);
	// 82401948: 41990008  bgt cr6, 0x82401950
	if ctx.cr[6].gt {
	pc = 0x82401950; continue 'dispatch;
	}
	// 8240194C: EC0C5ABA  fmadds f0, f12, f10, f11
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[10].f64 + ctx.f[11].f64) as f32) as f64);
	pc = 0x82401950; continue 'dispatch;
            }
            0x82401950 => {
    //   block [0x82401950..0x82401998)
	// 82401950: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82401954: C18B2238  lfs f12, 0x2238(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8760 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82401958: ED8D0332  fmuls f12, f13, f12
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 8240195C: FF016000  fcmpu cr6, f1, f12
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[12].f64);
	// 82401960: 4199005C  bgt cr6, 0x824019bc
	if ctx.cr[6].gt {
	pc = 0x824019BC; continue 'dispatch;
	}
	// 82401964: FF014800  fcmpu cr6, f1, f9
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[9].f64);
	// 82401968: 40980030  bge cr6, 0x82401998
	if !ctx.cr[6].lt {
	pc = 0x82401998; continue 'dispatch;
	}
	// 8240196C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82401970: ED81482A  fadds f12, f1, f9
	ctx.f[12].f64 = ((ctx.f[1].f64 + ctx.f[9].f64) as f32) as f64;
	// 82401974: C16BBCE8  lfs f11, -0x4318(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17176 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82401978: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8240197C: EDAD02F2  fmuls f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 82401980: C16B2980  lfs f11, 0x2980(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10624 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82401984: ED4C6AFA  fmadds f10, f12, f11, f13
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 82401988: FF0A0000  fcmpu cr6, f10, f0
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[0].f64);
	// 8240198C: 419900A4  bgt cr6, 0x82401a30
	if ctx.cr[6].gt {
	pc = 0x82401A30; continue 'dispatch;
	}
	// 82401990: EC0C6AFA  fmadds f0, f12, f11, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 82401994: 4800009C  b 0x82401a30
	pc = 0x82401A30; continue 'dispatch;
            }
            0x82401998 => {
    //   block [0x82401998..0x824019A8)
	// 82401998: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8240199C: C18B2984  lfs f12, 0x2984(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10628 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 824019A0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824019A4: C16B8E34  lfs f11, -0x71cc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29132 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	pc = 0x824019A8; continue 'dispatch;
            }
            0x824019A8 => {
    //   block [0x824019A8..0x824019B0)
	// 824019A8: EDAD02F2  fmuls f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 824019AC: EDA16B3A  fmadds f13, f1, f12, f13
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	pc = 0x824019B0; continue 'dispatch;
            }
            0x824019B0 => {
    //   block [0x824019B0..0x824019BC)
	// 824019B0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 824019B4: 4199007C  bgt cr6, 0x82401a30
	if ctx.cr[6].gt {
	pc = 0x82401A30; continue 'dispatch;
	}
	// 824019B8: 48000074  b 0x82401a2c
	pc = 0x82401A2C; continue 'dispatch;
            }
            0x824019BC => {
    //   block [0x824019BC..0x824019E4)
	// 824019BC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824019C0: C18B20B0  lfs f12, 0x20b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8368 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 824019C4: ED8D0332  fmuls f12, f13, f12
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 824019C8: FF016000  fcmpu cr6, f1, f12
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[12].f64);
	// 824019CC: 41990018  bgt cr6, 0x824019e4
	if ctx.cr[6].gt {
	pc = 0x824019E4; continue 'dispatch;
	}
	// 824019D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824019D4: C18B20C8  lfs f12, 0x20c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8392 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 824019D8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824019DC: C16B8E28  lfs f11, -0x71d8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29144 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 824019E0: 4BFFFFC8  b 0x824019a8
	pc = 0x824019A8; continue 'dispatch;
            }
            0x824019E4 => {
    //   block [0x824019E4..0x82401A00)
	// 824019E4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824019E8: C18BD6C8  lfs f12, -0x2938(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 824019EC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824019F0: C16B207C  lfs f11, 0x207c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8316 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 824019F4: ED6102F2  fmuls f11, f1, f11
	ctx.f[11].f64 = (((ctx.f[1].f64 * ctx.f[11].f64) as f32) as f64);
	// 824019F8: EDAD5B3A  fmadds f13, f13, f12, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64);
	// 824019FC: 4BFFFFB4  b 0x824019b0
	pc = 0x824019B0; continue 'dispatch;
            }
            0x82401A00 => {
    //   block [0x82401A00..0x82401A2C)
	// 82401A00: 89640013  lbz r11, 0x13(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(19 as u32) ) } as u64;
	// 82401A04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82401A08: 409A0028  bne cr6, 0x82401a30
	if !ctx.cr[6].eq {
	pc = 0x82401A30; continue 'dispatch;
	}
	// 82401A0C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82401A10: C18B203C  lfs f12, 0x203c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8252 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82401A14: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82401A18: C16B2038  lfs f11, 0x2038(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8248 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82401A1C: ED6102F2  fmuls f11, f1, f11
	ctx.f[11].f64 = (((ctx.f[1].f64 * ctx.f[11].f64) as f32) as f64);
	// 82401A20: EDAD5B3A  fmadds f13, f13, f12, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64);
	// 82401A24: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82401A28: 41980008  blt cr6, 0x82401a30
	if ctx.cr[6].lt {
	pc = 0x82401A30; continue 'dispatch;
	}
	pc = 0x82401A2C; continue 'dispatch;
            }
            0x82401A2C => {
    //   block [0x82401A2C..0x82401A30)
	// 82401A2C: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82401A30; continue 'dispatch;
            }
            0x82401A30 => {
    //   block [0x82401A30..0x82401A44)
	// 82401A30: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82401A34: C1ABBCE4  lfs f13, -0x431c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17180 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401A38: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82401A3C: 40990008  ble cr6, 0x82401a44
	if !ctx.cr[6].gt {
	pc = 0x82401A44; continue 'dispatch;
	}
	// 82401A40: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82401A44; continue 'dispatch;
            }
            0x82401A44 => {
    //   block [0x82401A44..0x82401A58)
	// 82401A44: 89640012  lbz r11, 0x12(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(18 as u32) ) } as u64;
	// 82401A48: 7D6B0775  extsb. r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82401A4C: 4181000C  bgt 0x82401a58
	if ctx.cr[0].gt {
	pc = 0x82401A58; continue 'dispatch;
	}
	// 82401A50: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82401A54: 99640012  stb r11, 0x12(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(18 as u32), ctx.r[11].u8 ) };
	pc = 0x82401A58; continue 'dispatch;
            }
            0x82401A58 => {
    //   block [0x82401A58..0x82401A60)
	// 82401A58: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82401A5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82401A60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82401A60 size=204
    let mut pc: u32 = 0x82401A60;
    'dispatch: loop {
        match pc {
            0x82401A60 => {
    //   block [0x82401A60..0x82401A70)
	// 82401A60: 7C8B0734  extsh r11, r4
	ctx.r[11].s64 = ctx.r[4].s16 as i64;
	// 82401A64: 2F0B00FF  cmpwi cr6, r11, 0xff
	ctx.cr[6].compare_i32(ctx.r[11].s32, 255, &mut ctx.xer);
	// 82401A68: 41980008  blt cr6, 0x82401a70
	if ctx.cr[6].lt {
	pc = 0x82401A70; continue 'dispatch;
	}
	// 82401A6C: 388000FF  li r4, 0xff
	ctx.r[4].s64 = 255;
	pc = 0x82401A70; continue 'dispatch;
            }
            0x82401A70 => {
    //   block [0x82401A70..0x82401AB8)
	// 82401A70: 89660014  lbz r11, 0x14(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) } as u64;
	// 82401A74: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82401A78: 409A0040  bne cr6, 0x82401ab8
	if !ctx.cr[6].eq {
	pc = 0x82401AB8; continue 'dispatch;
	}
	// 82401A7C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82401A80: 89460015  lbz r10, 0x15(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(21 as u32) ) } as u64;
	// 82401A84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82401A88: B1660010  sth r11, 0x10(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(16 as u32), ctx.r[11].u16 ) };
	// 82401A8C: 409A0094  bne cr6, 0x82401b20
	if !ctx.cr[6].eq {
	pc = 0x82401B20; continue 'dispatch;
	}
	// 82401A90: 7C8B0734  extsh r11, r4
	ctx.r[11].s64 = ctx.r[4].s16 as i64;
	// 82401A94: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82401A98: C801FFF0  lfd f0, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82401A9C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82401AA0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82401AA4: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82401AA8: 41980078  blt cr6, 0x82401b20
	if ctx.cr[6].lt {
	pc = 0x82401B20; continue 'dispatch;
	}
	// 82401AAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82401AB0: 99660015  stb r11, 0x15(r6)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[6].u32.wrapping_add(21 as u32), ctx.r[11].u8 ) };
	// 82401AB4: 4800006C  b 0x82401b20
	pc = 0x82401B20; continue 'dispatch;
            }
            0x82401AB8 => {
    //   block [0x82401AB8..0x82401B20)
	// 82401AB8: 54A9043E  clrlwi r9, r5, 0x10
	ctx.r[9].u64 = ctx.r[5].u32 as u64 & 0x0000FFFFu64;
	// 82401ABC: A1460010  lhz r10, 0x10(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) } as u64;
	// 82401AC0: C1A60008  lfs f13, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401AC4: 396A0001  addi r11, r10, 1
	ctx.r[11].s64 = ctx.r[10].s64 + 1;
	// 82401AC8: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 82401ACC: F921FFF0  std r9, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u64 ) };
	// 82401AD0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82401AD4: B1660010  sth r11, 0x10(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(16 as u32), ctx.r[11].u16 ) };
	// 82401AD8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82401ADC: C801FFF0  lfd f0, -0x10(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82401AE0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82401AE4: FD800018  frsp f12, f0
	ctx.f[12].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82401AE8: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401AEC: EC0D033A  fmadds f0, f13, f12, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82401AF0: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82401AF4: D801FFF0  stfd f0, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[0].u64 ) };
	// 82401AF8: A961FFF6  lha r11, -0xa(r1)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(-10 as u32) ) } as i16) as i64;
	// 82401AFC: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82401B00: 40990020  ble cr6, 0x82401b20
	if !ctx.cr[6].gt {
	pc = 0x82401B20; continue 'dispatch;
	}
	// 82401B04: 7D4B0734  extsh r11, r10
	ctx.r[11].s64 = ctx.r[10].s16 as i64;
	// 82401B08: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82401B0C: 2F0B7FBC  cmpwi cr6, r11, 0x7fbc
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32700, &mut ctx.xer);
	// 82401B10: 99460015  stb r10, 0x15(r6)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[6].u32.wrapping_add(21 as u32), ctx.r[10].u8 ) };
	// 82401B14: 4099000C  ble cr6, 0x82401b20
	if !ctx.cr[6].gt {
	pc = 0x82401B20; continue 'dispatch;
	}
	// 82401B18: 39607FBC  li r11, 0x7fbc
	ctx.r[11].s64 = 32700;
	// 82401B1C: B1660010  sth r11, 0x10(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(16 as u32), ctx.r[11].u16 ) };
	pc = 0x82401B20; continue 'dispatch;
            }
            0x82401B20 => {
    //   block [0x82401B20..0x82401B2C)
	// 82401B20: 89660015  lbz r11, 0x15(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(21 as u32) ) } as u64;
	// 82401B24: 7D630774  extsb r3, r11
	ctx.r[3].s64 = ctx.r[11].s8 as i64;
	// 82401B28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82401B30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82401B30 size=64
    let mut pc: u32 = 0x82401B30;
    'dispatch: loop {
        match pc {
            0x82401B30 => {
    //   block [0x82401B30..0x82401B68)
	// 82401B30: 89630014  lbz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82401B34: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82401B38: 409A0030  bne cr6, 0x82401b68
	if !ctx.cr[6].eq {
	pc = 0x82401B68; continue 'dispatch;
	}
	// 82401B3C: 7C8B0734  extsh r11, r4
	ctx.r[11].s64 = ctx.r[4].s16 as i64;
	// 82401B40: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82401B44: 409A0024  bne cr6, 0x82401b68
	if !ctx.cr[6].eq {
	pc = 0x82401B68; continue 'dispatch;
	}
	// 82401B48: 89630015  lbz r11, 0x15(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(21 as u32) ) } as u64;
	// 82401B4C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82401B50: 409A0018  bne cr6, 0x82401b68
	if !ctx.cr[6].eq {
	pc = 0x82401B68; continue 'dispatch;
	}
	// 82401B54: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82401B58: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82401B5C: C00B2284  lfs f0, 0x2284(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8836 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401B60: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82401B64: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	pc = 0x82401B68; continue 'dispatch;
            }
            0x82401B68 => {
    //   block [0x82401B68..0x82401B70)
	// 82401B68: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82401B6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82401B70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82401B70 size=444
    let mut pc: u32 = 0x82401B70;
    'dispatch: loop {
        match pc {
            0x82401B70 => {
    //   block [0x82401B70..0x82401BB4)
	// 82401B70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82401B74: 48133541  bl 0x825350b4
	ctx.lr = 0x82401B78;
	sub_82535080(ctx, base);
	// 82401B78: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 82401B7C: 4813446D  bl 0x82535fe8
	ctx.lr = 0x82401B80;
	sub_82535FB0(ctx, base);
	// 82401B80: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82401B84: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82401B88: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 82401B8C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82401B90: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82401B94: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 82401B98: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82401B9C: 4BFFC10D  bl 0x823fdca8
	ctx.lr = 0x82401BA0;
	sub_823FDCA8(ctx, base);
	// 82401BA0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82401BA4: 395F0004  addi r10, r31, 4
	ctx.r[10].s64 = ctx.r[31].s64 + 4;
	// 82401BA8: C3EB1850  lfs f31, 0x1850(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82401BAC: 3960000B  li r11, 0xb
	ctx.r[11].s64 = 11;
	// 82401BB0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	pc = 0x82401BB4; continue 'dispatch;
            }
            0x82401BB4 => {
    //   block [0x82401BB4..0x82401C00)
	// 82401BB4: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401BB8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82401BBC: EC00F83C  fnmsubs f0, f0, f0, f31
	ctx.f[0].f64 = -(((ctx.f[0].f64 * ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82401BC0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82401BC4: EC200072  fmuls f1, f0, f1
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 82401BC8: 4082FFEC  bne 0x82401bb4
	if !ctx.cr[0].eq {
	pc = 0x82401BB4; continue 'dispatch;
	}
	// 82401BCC: 4BFFC59D  bl 0x823fe168
	ctx.lr = 0x82401BD0;
	sub_823FE168(ctx, base);
	// 82401BD0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82401BD4: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401BD8: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 82401BDC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82401BE0: EFE0F83A  fmadds f31, f0, f0, f31
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64);
	// 82401BE4: 3BC00005  li r30, 5
	ctx.r[30].s64 = 5;
	// 82401BE8: 3F808273  lis r28, -0x7d8d
	ctx.r[28].s64 = -2106392576;
	// 82401BEC: C3CBBFFC  lfs f30, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82401BF0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82401BF4: EFA1EFBC  fnmsubs f29, f1, f30, f29
	ctx.f[29].f64 = -(((ctx.f[1].f64 * ctx.f[30].f64 - ctx.f[29].f64) as f32) as f64);
	// 82401BF8: C1AB24DC  lfs f13, 0x24dc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9436 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401BFC: EF800372  fmuls f28, f0, f13
	ctx.f[28].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	pc = 0x82401C00; continue 'dispatch;
            }
            0x82401C00 => {
    //   block [0x82401C00..0x82401C44)
	// 82401C00: 817CD6E8  lwz r11, -0x2918(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-10520 as u32) ) } as u64;
	// 82401C04: 7C1F5C2E  lfsx f0, r31, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401C08: 3BFF0080  addi r31, r31, 0x80
	ctx.r[31].s64 = ctx.r[31].s64 + 128;
	// 82401C0C: EC20FF3A  fmadds f1, f0, f28, f31
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[28].f64 + ctx.f[31].f64) as f32) as f64);
	// 82401C10: 4BFFC559  bl 0x823fe168
	ctx.lr = 0x82401C14;
	sub_823FE168(ctx, base);
	// 82401C14: EC01EFBC  fnmsubs f0, f1, f30, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = -(((ctx.f[1].f64 * ctx.f[30].f64 - ctx.f[29].f64) as f32) as f64);
	// 82401C18: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82401C1C: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82401C20: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82401C24: 4082FFDC  bne 0x82401c00
	if !ctx.cr[0].eq {
	pc = 0x82401C00; continue 'dispatch;
	}
	// 82401C28: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82401C2C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82401C30: 394ABCFC  addi r10, r10, -0x4304
	ctx.r[10].s64 = ctx.r[10].s64 + -17156;
	// 82401C34: 393B0004  addi r9, r27, 4
	ctx.r[9].s64 = ctx.r[27].s64 + 4;
	// 82401C38: C18A0000  lfs f12, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82401C3C: C14A0004  lfs f10, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82401C40: C16A000C  lfs f11, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	pc = 0x82401C44; continue 'dispatch;
            }
            0x82401C44 => {
    //   block [0x82401C44..0x82401C94)
	// 82401C44: 5568073E  clrlwi r8, r11, 0x1c
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 82401C48: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401C4C: 7D6A2670  srawi r10, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 82401C50: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 82401C54: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82401C58: 38C10074  addi r6, r1, 0x74
	ctx.r[6].s64 = ctx.r[1].s64 + 116;
	// 82401C5C: F9010060  std r8, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u64 ) };
	// 82401C60: 7D0A342E  lfsx f8, r10, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82401C64: C8010060  lfd f0, 0x60(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82401C68: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82401C6C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82401C70: ED2002F2  fmuls f9, f0, f11
	ctx.f[9].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82401C74: 7C0A3C2E  lfsx f0, r10, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401C78: ED080028  fsubs f8, f8, f0
	ctx.f[8].f64 = (((ctx.f[8].f64 - ctx.f[0].f64) as f32) as f64);
	// 82401C7C: EC08027A  fmadds f0, f8, f9, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64);
	// 82401C80: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82401C84: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82401C88: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82401C8C: 40990008  ble cr6, 0x82401c94
	if !ctx.cr[6].gt {
	pc = 0x82401C94; continue 'dispatch;
	}
	// 82401C90: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	pc = 0x82401C94; continue 'dispatch;
            }
            0x82401C94 => {
    //   block [0x82401C94..0x82401CA0)
	// 82401C94: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82401C98: 41990008  bgt cr6, 0x82401ca0
	if ctx.cr[6].gt {
	pc = 0x82401CA0; continue 'dispatch;
	}
	// 82401C9C: FC005090  fmr f0, f10
	ctx.f[0].f64 = ctx.f[10].f64;
	pc = 0x82401CA0; continue 'dispatch;
            }
            0x82401CA0 => {
    //   block [0x82401CA0..0x82401CC4)
	// 82401CA0: 2F0B0010  cmpwi cr6, r11, 0x10
	ctx.cr[6].compare_i32(ctx.r[11].s32, 16, &mut ctx.xer);
	// 82401CA4: 40980020  bge cr6, 0x82401cc4
	if !ctx.cr[6].lt {
	pc = 0x82401CC4; continue 'dispatch;
	}
	// 82401CA8: 7D6A07B4  extsw r10, r11
	ctx.r[10].s64 = ctx.r[11].s32 as i64;
	// 82401CAC: F9410068  std r10, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u64 ) };
	// 82401CB0: C9210068  lfd f9, 0x68(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82401CB4: FD204E9C  fcfid f9, f9
	ctx.f[9].f64 = (ctx.f[9].s64 as f64);
	// 82401CB8: FD204818  frsp f9, f9
	ctx.f[9].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82401CBC: ED2902F2  fmuls f9, f9, f11
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[11].f64) as f32) as f64);
	// 82401CC0: EC090032  fmuls f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x82401CC4; continue 'dispatch;
            }
            0x82401CC4 => {
    //   block [0x82401CC4..0x82401D04)
	// 82401CC4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82401CC8: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82401CCC: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82401CD0: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82401CD4: 2F0B0040  cmpwi cr6, r11, 0x40
	ctx.cr[6].compare_i32(ctx.r[11].s32, 64, &mut ctx.xer);
	// 82401CD8: 4198FF6C  blt cr6, 0x82401c44
	if ctx.cr[6].lt {
	pc = 0x82401C44; continue 'dispatch;
	}
	// 82401CDC: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82401CE0: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82401CE4: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 82401CE8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82401CEC: 4BFFBFBD  bl 0x823fdca8
	ctx.lr = 0x82401CF0;
	sub_823FDCA8(ctx, base);
	// 82401CF0: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401CF4: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401CF8: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82401CFC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82401D00: 39400040  li r10, 0x40
	ctx.r[10].s64 = 64;
	pc = 0x82401D04; continue 'dispatch;
            }
            0x82401D04 => {
    //   block [0x82401D04..0x82401D2C)
	// 82401D04: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401D08: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82401D0C: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82401D10: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82401D14: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82401D18: 4082FFEC  bne 0x82401d04
	if !ctx.cr[0].eq {
	pc = 0x82401D04; continue 'dispatch;
	}
	// 82401D1C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82401D20: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 82401D24: 48134311  bl 0x82536034
	ctx.lr = 0x82401D28;
	sub_82535FFC(ctx, base);
	// 82401D28: 481333DC  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82401D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82401D30 size=356
    let mut pc: u32 = 0x82401D30;
    'dispatch: loop {
        match pc {
            0x82401D30 => {
    //   block [0x82401D30..0x82401DA0)
	// 82401D30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82401D34: 48133379  bl 0x825350ac
	ctx.lr = 0x82401D38;
	sub_82535080(ctx, base);
	// 82401D38: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82401D3C: 38880808  addi r4, r8, 0x808
	ctx.r[4].s64 = ctx.r[8].s64 + 2056;
	// 82401D40: FDA01090  fmr f13, f2
	ctx.f[13].f64 = ctx.f[2].f64;
	// 82401D44: 3868090C  addi r3, r8, 0x90c
	ctx.r[3].s64 = ctx.r[8].s64 + 2316;
	// 82401D48: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82401D4C: C00400FC  lfs f0, 0xfc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401D50: D0040100  stfs f0, 0x100(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82401D54: C00300FC  lfs f0, 0xfc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401D58: D0030100  stfs f0, 0x100(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82401D5C: 40990104  ble cr6, 0x82401e60
	if !ctx.cr[6].gt {
	pc = 0x82401E60; continue 'dispatch;
	}
	// 82401D60: 3F40820D  lis r26, -0x7df3
	ctx.r[26].s64 = -2113077248;
	// 82401D64: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82401D68: 3F808201  lis r28, -0x7dff
	ctx.r[28].s64 = -2113863680;
	// 82401D6C: 8361005C  lwz r27, 0x5c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82401D70: 3FA08201  lis r29, -0x7dff
	ctx.r[29].s64 = -2113863680;
	// 82401D74: 3FC08201  lis r30, -0x7dff
	ctx.r[30].s64 = -2113863680;
	// 82401D78: 3FE08201  lis r31, -0x7dff
	ctx.r[31].s64 = -2113863680;
	// 82401D7C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82401D80: C15A2038  lfs f10, 0x2038(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8248 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82401D84: C0DCBD10  lfs f6, -0x42f0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-17136 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82401D88: 7F284850  subf r25, r8, r9
	ctx.r[25].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82401D8C: C0FDBD14  lfs f7, -0x42ec(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-17132 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82401D90: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82401D94: C11EBD18  lfs f8, -0x42e8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-17128 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82401D98: C13FBD1C  lfs f9, -0x42e4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-17124 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82401D9C: C0ABBD20  lfs f5, -0x42e0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17120 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	pc = 0x82401DA0; continue 'dispatch;
            }
            0x82401DA0 => {
    //   block [0x82401DA0..0x82401DB4)
	// 82401DA0: FF0D2800  fcmpu cr6, f13, f5
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[5].f64);
	// 82401DA4: 40990010  ble cr6, 0x82401db4
	if !ctx.cr[6].gt {
	pc = 0x82401DB4; continue 'dispatch;
	}
	// 82401DA8: EC0D427C  fnmsubs f0, f13, f9, f8
	ctx.f[0].f64 = -(((ctx.f[13].f64 * ctx.f[9].f64 - ctx.f[8].f64) as f32) as f64);
	// 82401DAC: EC003B7A  fmadds f0, f0, f13, f7
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[7].f64) as f32) as f64);
	// 82401DB0: 48000008  b 0x82401db8
	pc = 0x82401DB8; continue 'dispatch;
            }
            0x82401DB4 => {
    //   block [0x82401DB4..0x82401DB8)
	// 82401DB4: EC0D01B2  fmuls f0, f13, f6
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[6].f64) as f32) as f64);
	pc = 0x82401DB8; continue 'dispatch;
            }
            0x82401DB8 => {
    //   block [0x82401DB8..0x82401E60)
	// 82401DB8: EC0002B2  fmuls f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 82401DBC: 3961FFA0  addi r11, r1, -0x60
	ctx.r[11].s64 = ctx.r[1].s64 + -96;
	// 82401DC0: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82401DC4: EDAD102A  fadds f13, f13, f2
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[2].f64) as f32) as f64;
	// 82401DC8: FD80001E  fctiwz f12, f0
	ctx.f[12].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82401DCC: 7D805FAE  stfiwx f12, 0, r11
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82401DD0: 8161FFA0  lwz r11, -0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) } as u64;
	// 82401DD4: 7D7F07B4  extsw r31, r11
	ctx.r[31].s64 = ctx.r[11].s32 as i64;
	// 82401DD8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82401DDC: 7FCB2214  add r30, r11, r4
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 82401DE0: 7FABDA14  add r29, r11, r27
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82401DE4: FBE1FFA8  std r31, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.r[31].u64 ) };
	// 82401DE8: 7FEB5214  add r31, r11, r10
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82401DEC: 7D8B542E  lfsx f12, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82401DF0: 7F8B1A14  add r28, r11, r3
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82401DF4: 7D6B242E  lfsx f11, r11, r4
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82401DF8: C3FE0004  lfs f31, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82401DFC: EFFF5828  fsubs f31, f31, f11
	ctx.f[31].f64 = (((ctx.f[31].f64 - ctx.f[11].f64) as f32) as f64);
	// 82401E00: C861FFA8  lfd f3, -0x58(r1)
	ctx.f[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 82401E04: FC601E9C  fcfid f3, f3
	ctx.f[3].f64 = (ctx.f[3].s64 as f64);
	// 82401E08: FC601818  frsp f3, f3
	ctx.f[3].f64 = (ctx.f[3].f64 as f32) as f64;
	// 82401E0C: EC001828  fsubs f0, f0, f3
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[3].f64) as f32) as f64);
	// 82401E10: C07F0004  lfs f3, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82401E14: EC636028  fsubs f3, f3, f12
	ctx.f[3].f64 = (((ctx.f[3].f64 - ctx.f[12].f64) as f32) as f64);
	// 82401E18: ED7F583A  fmadds f11, f31, f0, f11
	ctx.f[11].f64 = (((ctx.f[31].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82401E1C: ED83603A  fmadds f12, f3, f0, f12
	ctx.f[12].f64 = (((ctx.f[3].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 82401E20: ED6B6028  fsubs f11, f11, f12
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82401E24: ED8B613A  fmadds f12, f11, f4, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[4].f64 + ctx.f[12].f64) as f32) as f64);
	// 82401E28: 7D99452E  stfsx f12, r25, r8
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[25].u32.wrapping_add(ctx.r[8].u32), tmp.u32) };
	// 82401E2C: 7D8BDC2E  lfsx f12, r11, r27
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82401E30: C07D0004  lfs f3, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82401E34: 7D6B1C2E  lfsx f11, r11, r3
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82401E38: EC636028  fsubs f3, f3, f12
	ctx.f[3].f64 = (((ctx.f[3].f64 - ctx.f[12].f64) as f32) as f64);
	// 82401E3C: C3FC0004  lfs f31, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82401E40: EFFF5828  fsubs f31, f31, f11
	ctx.f[31].f64 = (((ctx.f[31].f64 - ctx.f[11].f64) as f32) as f64);
	// 82401E44: ED83603A  fmadds f12, f3, f0, f12
	ctx.f[12].f64 = (((ctx.f[3].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 82401E48: EC1F583A  fmadds f0, f31, f0, f11
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82401E4C: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82401E50: EC00613A  fmadds f0, f0, f4, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[4].f64 + ctx.f[12].f64) as f32) as f64);
	// 82401E54: D0080000  stfs f0, 0(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82401E58: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82401E5C: 4082FF44  bne 0x82401da0
	if !ctx.cr[0].eq {
	pc = 0x82401DA0; continue 'dispatch;
	}
	pc = 0x82401E60; continue 'dispatch;
            }
            0x82401E60 => {
    //   block [0x82401E60..0x82401E74)
	// 82401E60: 7F073000  cmpw cr6, r7, r6
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82401E64: 40980028  bge cr6, 0x82401e8c
	if !ctx.cr[6].lt {
	pc = 0x82401E8C; continue 'dispatch;
	}
	// 82401E68: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82401E6C: 7D473050  subf r10, r7, r6
	ctx.r[10].s64 = ctx.r[6].s64 - ctx.r[7].s64;
	// 82401E70: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x82401E74; continue 'dispatch;
            }
            0x82401E74 => {
    //   block [0x82401E74..0x82401E8C)
	// 82401E74: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401E78: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82401E7C: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82401E80: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82401E84: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82401E88: 4082FFEC  bne 0x82401e74
	if !ctx.cr[0].eq {
	pc = 0x82401E74; continue 'dispatch;
	}
	pc = 0x82401E8C; continue 'dispatch;
            }
            0x82401E8C => {
    //   block [0x82401E8C..0x82401E94)
	// 82401E8C: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82401E90: 4813326C  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82401E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82401E98 size=352
    let mut pc: u32 = 0x82401E98;
    'dispatch: loop {
        match pc {
            0x82401E98 => {
    //   block [0x82401E98..0x82401F10)
	// 82401E98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82401E9C: 4813321D  bl 0x825350b8
	ctx.lr = 0x82401EA0;
	sub_82535080(ctx, base);
	// 82401EA0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82401EA4: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82401EA8: 3941FFD0  addi r10, r1, -0x30
	ctx.r[10].s64 = ctx.r[1].s64 + -48;
	// 82401EAC: 3CA01000  lis r5, 0x1000
	ctx.r[5].s64 = 268435456;
	// 82401EB0: 3BE04000  li r31, 0x4000
	ctx.r[31].s64 = 16384;
	// 82401EB4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82401EB8: C00B2148  lfs f0, 0x2148(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8520 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401EBC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82401EC0: ED410032  fmuls f10, f1, f0
	ctx.f[10].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82401EC4: C00B2838  lfs f0, 0x2838(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401EC8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82401ECC: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82401ED0: C1ABAFC0  lfs f13, -0x5040(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20544 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401ED4: FD40501E  fctiwz f10, f10
	ctx.f[10].s64 = if ctx.f[10].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[10].f64.trunc() as i32 as i64 };
	// 82401ED8: 7D4057AE  stfiwx f10, 0, r10
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 82401EDC: 3941FFD0  addi r10, r1, -0x30
	ctx.r[10].s64 = ctx.r[1].s64 + -48;
	// 82401EE0: 83C1FFD0  lwz r30, -0x30(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) } as u64;
	// 82401EE4: FD806890  fmr f12, f13
	ctx.f[12].f64 = ctx.f[13].f64;
	// 82401EE8: 7D68F1D6  mullw r11, r8, r30
	ctx.r[11].s32 = ((ctx.r[8].s32 as i64 * ctx.r[30].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82401EEC: FD606890  fmr f11, f13
	ctx.f[11].f64 = ctx.f[13].f64;
	// 82401EF0: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82401EF4: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 82401EF8: 8141FFD0  lwz r10, -0x30(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) } as u64;
	// 82401EFC: 2F0B4000  cmpwi cr6, r11, 0x4000
	ctx.cr[6].compare_i32(ctx.r[11].s32, 16384, &mut ctx.xer);
	// 82401F00: 7F8553D6  divw r28, r5, r10
	ctx.r[28].s32 = ctx.r[5].s32 / ctx.r[10].s32;
	// 82401F04: 0CCA0000  twi 6, r10, 0
	// 82401F08: 40980020  bge cr6, 0x82401f28
	if !ctx.cr[6].lt {
	pc = 0x82401F28; continue 'dispatch;
	}
	// 82401F0C: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	pc = 0x82401F10; continue 'dispatch;
            }
            0x82401F10 => {
    //   block [0x82401F10..0x82401F28)
	// 82401F10: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82401F14: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82401F18: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82401F1C: 7D6BF1D6  mullw r11, r11, r30
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * ctx.r[30].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82401F20: 2F0B4000  cmpwi cr6, r11, 0x4000
	ctx.cr[6].compare_i32(ctx.r[11].s32, 16384, &mut ctx.xer);
	// 82401F24: 4198FFEC  blt cr6, 0x82401f10
	if ctx.cr[6].lt {
	pc = 0x82401F10; continue 'dispatch;
	}
	pc = 0x82401F28; continue 'dispatch;
            }
            0x82401F28 => {
    //   block [0x82401F28..0x82401F4C)
	// 82401F28: 395C0800  addi r10, r28, 0x800
	ctx.r[10].s64 = ctx.r[28].s64 + 2048;
	// 82401F2C: 7D456670  srawi r5, r10, 0xc
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 12) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[10].s32 >> 12) as i64;
	// 82401F30: 7F053800  cmpw cr6, r5, r7
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82401F34: 409800A4  bge cr6, 0x82401fd8
	if !ctx.cr[6].lt {
	pc = 0x82401FD8; continue 'dispatch;
	}
	// 82401F38: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82401F3C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82401F40: 3D408273  lis r10, -0x7d8d
	ctx.r[10].s64 = -2106392576;
	// 82401F44: C1481850  lfs f10, 0x1850(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(6224 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82401F48: 83AAD6E8  lwz r29, -0x2918(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10520 as u32) ) } as u64;
	pc = 0x82401F4C; continue 'dispatch;
            }
            0x82401F4C => {
    //   block [0x82401F4C..0x82401F68)
	// 82401F4C: 3FFF0001  addis r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 65536;
	// 82401F50: D1A1FFD0  stfs f13, -0x30(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), tmp.u32 ) };
	// 82401F54: 3BFF8000  addi r31, r31, -0x8000
	ctx.r[31].s64 = ctx.r[31].s64 + -32768;
	// 82401F58: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 82401F5C: 40980058  bge cr6, 0x82401fb4
	if !ctx.cr[6].lt {
	pc = 0x82401FB4; continue 'dispatch;
	}
	// 82401F60: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82401F64: 7D4A202E  lwzx r10, r10, r4
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	pc = 0x82401F68; continue 'dispatch;
            }
            0x82401F68 => {
    //   block [0x82401F68..0x82401F9C)
	// 82401F68: 7D6B3E70  srawi r11, r11, 7
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 7) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 7) as i64;
	// 82401F6C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82401F70: 556B15BA  rlwinm r11, r11, 2, 0x16, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 82401F74: 7C0A342E  lfsx f0, r10, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401F78: 8141FFD0  lwz r10, -0x30(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) } as u64;
	// 82401F7C: 7D2BEC2E  lfsx f9, r11, r29
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82401F80: ED29502A  fadds f9, f9, f10
	ctx.f[9].f64 = ((ctx.f[9].f64 + ctx.f[10].f64) as f32) as f64;
	// 82401F84: EC090032  fmuls f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82401F88: D001FFD4  stfs f0, -0x2c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-44 as u32), tmp.u32 ) };
	// 82401F8C: 8161FFD4  lwz r11, -0x2c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-44 as u32) ) } as u64;
	// 82401F90: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82401F94: 40990008  ble cr6, 0x82401f9c
	if !ctx.cr[6].gt {
	pc = 0x82401F9C; continue 'dispatch;
	}
	// 82401F98: 9161FFD0  stw r11, -0x30(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[11].u32 ) };
	pc = 0x82401F9C; continue 'dispatch;
            }
            0x82401F9C => {
    //   block [0x82401F9C..0x82401FB4)
	// 82401F9C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82401FA0: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82401FA4: 7D4B202E  lwzx r10, r11, r4
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 82401FA8: 7D6AF1D6  mullw r11, r10, r30
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * ctx.r[30].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82401FAC: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 82401FB0: 4198FFB8  blt cr6, 0x82401f68
	if ctx.cr[6].lt {
	pc = 0x82401F68; continue 'dispatch;
	}
	pc = 0x82401FB4; continue 'dispatch;
            }
            0x82401FB4 => {
    //   block [0x82401FB4..0x82401FD8)
	// 82401FB4: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82401FB8: C121FFD0  lfs f9, -0x30(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82401FBC: 7C63E214  add r3, r3, r28
	ctx.r[3].u64 = ctx.r[3].u64 + ctx.r[28].u64;
	// 82401FC0: 7C656670  srawi r5, r3, 0xc
	ctx.xer.ca = (ctx.r[3].s32 < 0) && ((ctx.r[3].u32 & ((1u32 << 12) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[3].s32 >> 12) as i64;
	// 82401FC4: 7C0A342E  lfsx f0, r10, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401FC8: 7F053800  cmpw cr6, r5, r7
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82401FCC: ED80627A  fmadds f12, f0, f9, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[9].f64 + ctx.f[12].f64) as f32) as f64);
	// 82401FD0: ED60583A  fmadds f11, f0, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82401FD4: 4198FF78  blt cr6, 0x82401f4c
	if ctx.cr[6].lt {
	pc = 0x82401F4C; continue 'dispatch;
	}
	pc = 0x82401FD8; continue 'dispatch;
            }
            0x82401FD8 => {
    //   block [0x82401FD8..0x82401FF8)
	// 82401FD8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82401FDC: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82401FE0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82401FE4: C1AB2418  lfs f13, 0x2418(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9240 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82401FE8: EDAB0372  fmuls f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82401FEC: EC0C6838  fmsubs f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82401FF0: EC2000B2  fmuls f1, f0, f2
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[2].f64) as f32) as f64);
	// 82401FF4: 48133114  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82401FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82401FF8 size=164
    let mut pc: u32 = 0x82401FF8;
    'dispatch: loop {
        match pc {
            0x82401FF8 => {
    //   block [0x82401FF8..0x82402018)
	// 82401FF8: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82401FFC: FF021800  fcmpu cr6, f2, f3
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[3].f64);
	// 82402000: 41990094  bgt cr6, 0x82402094
	if ctx.cr[6].gt {
	pc = 0x82402094; continue 'dispatch;
	}
	// 82402004: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82402008: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8240200C: 3C808273  lis r4, -0x7d8d
	ctx.r[4].s64 = -2106392576;
	// 82402010: C189BFFC  lfs f12, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82402014: C1AB2A2C  lfs f13, 0x2a2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10796 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82402018; continue 'dispatch;
            }
            0x82402018 => {
    //   block [0x82402018..0x82402040)
	// 82402018: ED62637A  fmadds f11, f2, f13, f12
	ctx.f[11].f64 = (((ctx.f[2].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 8240201C: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 82402020: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82402024: FC002090  fmr f0, f4
	ctx.f[0].f64 = ctx.f[4].f64;
	// 82402028: FD60581E  fctiwz f11, f11
	ctx.f[11].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 8240202C: 7D605FAE  stfiwx f11, 0, r11
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82402030: 40990040  ble cr6, 0x82402070
	if !ctx.cr[6].gt {
	pc = 0x82402070; continue 'dispatch;
	}
	// 82402034: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 82402038: 7CA85050  subf r5, r8, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 8240203C: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	pc = 0x82402040; continue 'dispatch;
            }
            0x82402040 => {
    //   block [0x82402040..0x82402070)
	// 82402040: 7C65582E  lwzx r3, r5, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82402044: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82402048: 83E1FFF0  lwz r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 8240204C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82402050: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82402054: 7C63F9D6  mullw r3, r3, r31
	ctx.r[3].s32 = ((ctx.r[3].s32 as i64 * ctx.r[31].s32 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82402058: 83E4D6E8  lwz r31, -0x2918(r4)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-10520 as u32) ) } as u64;
	// 8240205C: 3C630080  addis r3, r3, 0x80
	ctx.r[3].s64 = ctx.r[3].s64 + 8388608;
	// 82402060: 546355BA  rlwinm r3, r3, 0xa, 0x16, 0x1d
	ctx.r[3].u64 = ctx.r[3].u32 as u64 & 0x003FFFFFu64;
	// 82402064: 7D43FC2E  lfsx f10, r3, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82402068: EC0A02FA  fmadds f0, f10, f11, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 8240206C: 4082FFD4  bne 0x82402040
	if !ctx.cr[0].eq {
	pc = 0x82402040; continue 'dispatch;
	}
	pc = 0x82402070; continue 'dispatch;
            }
            0x82402070 => {
    //   block [0x82402070..0x82402088)
	// 82402070: C1660000  lfs f11, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82402074: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82402078: 40990010  ble cr6, 0x82402088
	if !ctx.cr[6].gt {
	pc = 0x82402088; continue 'dispatch;
	}
	// 8240207C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82402080: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82402084: D04B0000  stfs f2, 0(r11)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x82402088; continue 'dispatch;
            }
            0x82402088 => {
    //   block [0x82402088..0x82402094)
	// 82402088: EC41102A  fadds f2, f1, f2
	ctx.f[2].f64 = ((ctx.f[1].f64 + ctx.f[2].f64) as f32) as f64;
	// 8240208C: FF021800  fcmpu cr6, f2, f3
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[3].f64);
	// 82402090: 4099FF88  ble cr6, 0x82402018
	if !ctx.cr[6].gt {
	pc = 0x82402018; continue 'dispatch;
	}
	pc = 0x82402094; continue 'dispatch;
            }
            0x82402094 => {
    //   block [0x82402094..0x8240209C)
	// 82402094: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82402098: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824020A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824020A0 size=100
    let mut pc: u32 = 0x824020A0;
    'dispatch: loop {
        match pc {
            0x824020A0 => {
    //   block [0x824020A0..0x824020FC)
	// 824020A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824020A4: 48133009  bl 0x825350ac
	ctx.lr = 0x824020A8;
	sub_82535080(ctx, base);
	// 824020A8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824020AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824020B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 824020B4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 824020B8: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 824020BC: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 824020C0: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 824020C4: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 824020C8: 4BFC0299  bl 0x823c2360
	ctx.lr = 0x824020CC;
	sub_823C2360(ctx, base);
	// 824020CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 824020D0: 4082002C  bne 0x824020fc
	if !ctx.cr[0].eq {
	pc = 0x824020FC; continue 'dispatch;
	}
	// 824020D4: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 824020D8: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 824020DC: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 824020E0: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 824020E4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 824020E8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 824020EC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 824020F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 824020F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824020F8: 4830BB05  bl 0x8270dbfc
	ctx.lr = 0x824020FC;
	// extern call 0x8270DBFC  crate::xam::XamUserReadProfileSettings
	crate::xam::XamUserReadProfileSettings(ctx, base);
	pc = 0x824020FC; continue 'dispatch;
            }
            0x824020FC => {
    //   block [0x824020FC..0x82402104)
	// 824020FC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82402100: 48132FFC  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82402108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82402108 size=108
    let mut pc: u32 = 0x82402108;
    'dispatch: loop {
        match pc {
            0x82402108 => {
    //   block [0x82402108..0x8240216C)
	// 82402108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240210C: 48132F9D  bl 0x825350a8
	ctx.lr = 0x82402110;
	sub_82535080(ctx, base);
	// 82402110: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82402114: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82402118: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8240211C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82402120: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82402124: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82402128: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 8240212C: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 82402130: 7D585378  mr r24, r10
	ctx.r[24].u64 = ctx.r[10].u64;
	// 82402134: 4BFC022D  bl 0x823c2360
	ctx.lr = 0x82402138;
	sub_823C2360(ctx, base);
	// 82402138: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8240213C: 40820030  bne 0x8240216c
	if !ctx.cr[0].eq {
	pc = 0x8240216C; continue 'dispatch;
	}
	// 82402140: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82402144: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 82402148: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 8240214C: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82402150: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82402154: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82402158: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8240215C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82402160: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82402164: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82402168: 4830BA95  bl 0x8270dbfc
	ctx.lr = 0x8240216C;
	// extern call 0x8270DBFC  crate::xam::XamUserReadProfileSettings
	crate::xam::XamUserReadProfileSettings(ctx, base);
	pc = 0x8240216C; continue 'dispatch;
            }
            0x8240216C => {
    //   block [0x8240216C..0x82402174)
	// 8240216C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82402170: 48132F88  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82402178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82402178 size=72
    let mut pc: u32 = 0x82402178;
    'dispatch: loop {
        match pc {
            0x82402178 => {
    //   block [0x82402178..0x824021C0)
	// 82402178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240217C: 48132F3D  bl 0x825350b8
	ctx.lr = 0x82402180;
	sub_82535080(ctx, base);
	// 82402180: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82402184: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82402188: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8240218C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82402190: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82402194: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82402198: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 8240219C: 4830AF71  bl 0x8270d10c
	ctx.lr = 0x824021A0;
	// extern call 0x8270D10C  crate::xam::XamUserGetXUID
	crate::xam::XamUserGetXUID(ctx, base);
	// 824021A0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 824021A4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 824021A8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 824021AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824021B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824021B4: 4830BA99  bl 0x8270dc4c
	ctx.lr = 0x824021B8;
	// extern call 0x8270DC4C  crate::xam::XamUserWriteProfileSettings
	crate::xam::XamUserWriteProfileSettings(ctx, base);
	// 824021B8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 824021BC: 48132F4C  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824021C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824021C0 size=428
    let mut pc: u32 = 0x824021C0;
    'dispatch: loop {
        match pc {
            0x824021C0 => {
    //   block [0x824021C0..0x82402230)
	// 824021C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824021C4: 48132EDD  bl 0x825350a0
	ctx.lr = 0x824021C8;
	sub_82535080(ctx, base);
	// 824021C8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824021CC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 824021D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824021D4: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 824021D8: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 824021DC: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 824021E0: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 824021E4: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 824021E8: 7D565378  mr r22, r10
	ctx.r[22].u64 = ctx.r[10].u64;
	// 824021EC: 2B1D0004  cmplwi cr6, r29, 4
	ctx.cr[6].compare_u32(ctx.r[29].u32, 4 as u32, &mut ctx.xer);
	// 824021F0: 4098016C  bge cr6, 0x8240235c
	if !ctx.cr[6].lt {
	pc = 0x8240235C; continue 'dispatch;
	}
	// 824021F4: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 824021F8: 419A0164  beq cr6, 0x8240235c
	if ctx.cr[6].eq {
	pc = 0x8240235C; continue 'dispatch;
	}
	// 824021FC: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82402200: 419A015C  beq cr6, 0x8240235c
	if ctx.cr[6].eq {
	pc = 0x8240235C; continue 'dispatch;
	}
	// 82402204: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 82402208: 419A0154  beq cr6, 0x8240235c
	if ctx.cr[6].eq {
	pc = 0x8240235C; continue 'dispatch;
	}
	// 8240220C: 57EA0032  rlwinm r10, r31, 0, 0, 0x19
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 82402210: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82402214: 91760000  stw r11, 0(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82402218: 554A0625  rlwinm. r10, r10, 0, 0x18, 0x12
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8240221C: 40820140  bne 0x8240235c
	if !ctx.cr[0].eq {
	pc = 0x8240235C; continue 'dispatch;
	}
	// 82402220: 57EA0739  rlwinm. r10, r31, 0, 0x1c, 0x1c
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82402224: 4182000C  beq 0x82402230
	if ctx.cr[0].eq {
	pc = 0x82402230; continue 'dispatch;
	}
	// 82402228: 57EB06B5  rlwinm. r11, r31, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8240222C: 41820130  beq 0x8240235c
	if ctx.cr[0].eq {
	pc = 0x8240235C; continue 'dispatch;
	}
	pc = 0x82402230; continue 'dispatch;
            }
            0x82402230 => {
    //   block [0x82402230..0x82402240)
	// 82402230: 57EB06F7  rlwinm. r11, r31, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82402234: 4182000C  beq 0x82402240
	if ctx.cr[0].eq {
	pc = 0x82402240; continue 'dispatch;
	}
	// 82402238: 57E9077B  rlwinm. r9, r31, 0, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8240223C: 41820120  beq 0x8240235c
	if ctx.cr[0].eq {
	pc = 0x8240235C; continue 'dispatch;
	}
	pc = 0x82402240; continue 'dispatch;
            }
            0x82402240 => {
    //   block [0x82402240..0x82402250)
	// 82402240: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82402244: 419A000C  beq cr6, 0x82402250
	if ctx.cr[6].eq {
	pc = 0x82402250; continue 'dispatch;
	}
	// 82402248: 57EB06B5  rlwinm. r11, r31, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8240224C: 41820110  beq 0x8240235c
	if ctx.cr[0].eq {
	pc = 0x8240235C; continue 'dispatch;
	}
	pc = 0x82402250; continue 'dispatch;
            }
            0x82402250 => {
    //   block [0x82402250..0x82402264)
	// 82402250: 57EB07FF  clrlwi. r11, r31, 0x1f
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82402254: 41820010  beq 0x82402264
	if ctx.cr[0].eq {
	pc = 0x82402264; continue 'dispatch;
	}
	// 82402258: 73EB002C  andi. r11, r31, 0x2c
	ctx.r[11].u64 = ctx.r[31].u64 & 44;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8240225C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82402260: 418200FC  beq 0x8240235c
	if ctx.cr[0].eq {
	pc = 0x8240235C; continue 'dispatch;
	}
	pc = 0x82402264; continue 'dispatch;
            }
            0x82402264 => {
    //   block [0x82402264..0x82402294)
	// 82402264: 57EB052F  rlwinm. r11, r31, 0, 0x14, 0x17
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82402268: 4182003C  beq 0x824022a4
	if ctx.cr[0].eq {
	pc = 0x824022A4; continue 'dispatch;
	}
	// 8240226C: 73E9000A  andi. r9, r31, 0xa
	ctx.r[9].u64 = ctx.r[31].u64 & 10;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82402270: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82402274: 418200E8  beq 0x8240235c
	if ctx.cr[0].eq {
	pc = 0x8240235C; continue 'dispatch;
	}
	// 82402278: 57E907BD  rlwinm. r9, r31, 0, 0x1e, 0x1e
	ctx.r[9].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8240227C: 40820018  bne 0x82402294
	if !ctx.cr[0].eq {
	pc = 0x82402294; continue 'dispatch;
	}
	// 82402280: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82402284: 419A0010  beq cr6, 0x82402294
	if ctx.cr[6].eq {
	pc = 0x82402294; continue 'dispatch;
	}
	// 82402288: 57EA056A  rlwinm r10, r31, 0, 0x15, 0x15
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 8240228C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82402290: 409A00CC  bne cr6, 0x8240235c
	if !ctx.cr[6].eq {
	pc = 0x8240235C; continue 'dispatch;
	}
	pc = 0x82402294; continue 'dispatch;
            }
            0x82402294 => {
    //   block [0x82402294..0x824022A4)
	// 82402294: 57EB05AD  rlwinm. r11, r31, 0, 0x16, 0x16
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82402298: 4182000C  beq 0x824022a4
	if ctx.cr[0].eq {
	pc = 0x824022A4; continue 'dispatch;
	}
	// 8240229C: 57EB0529  rlwinm. r11, r31, 0, 0x14, 0x14
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824022A0: 408200BC  bne 0x8240235c
	if !ctx.cr[0].eq {
	pc = 0x8240235C; continue 'dispatch;
	}
	pc = 0x824022A4; continue 'dispatch;
            }
            0x824022A4 => {
    //   block [0x824022A4..0x8240231C)
	// 824022A4: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 824022A8: 4830B9C5  bl 0x8270dc6c
	ctx.lr = 0x824022AC;
	// extern call 0x8270DC6C  crate::xam::XamSessionCreateHandle
	crate::xam::XamSessionCreateHandle(ctx, base);
	// 824022AC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 824022B0: 408200B0  bne 0x82402360
	if !ctx.cr[0].eq {
	pc = 0x82402360; continue 'dispatch;
	}
	// 824022B4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 824022B8: 80760000  lwz r3, 0(r22)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 824022BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824022C0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 824022C4: 4830B999  bl 0x8270dc5c
	ctx.lr = 0x824022C8;
	// extern call 0x8270DC5C  crate::xam::XamSessionRefObjByHandle
	crate::xam::XamSessionRefObjByHandle(ctx, base);
	// 824022C8: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 824022CC: 40820094  bne 0x82402360
	if !ctx.cr[0].eq {
	pc = 0x82402360; continue 'dispatch;
	}
	// 824022D0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824022D4: 3C80000B  lis r4, 0xb
	ctx.r[4].s64 = 720896;
	// 824022D8: 38E0001C  li r7, 0x1c
	ctx.r[7].s64 = 28;
	// 824022DC: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 824022E0: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 824022E4: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 824022E8: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 824022EC: 92E1006C  stw r23, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[23].u32 ) };
	// 824022F0: 60840010  ori r4, r4, 0x10
	ctx.r[4].u64 = ctx.r[4].u64 | 16;
	// 824022F4: 93010068  stw r24, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[24].u32 ) };
	// 824022F8: 386000FB  li r3, 0xfb
	ctx.r[3].s64 = 251;
	// 824022FC: 93410074  stw r26, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[26].u32 ) };
	// 82402300: 93610078  stw r27, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[27].u32 ) };
	// 82402304: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82402308: 4830AD75  bl 0x8270d07c
	ctx.lr = 0x8240230C;
	// extern call 0x8270D07C  crate::xboxkrnl::XMsgStartIORequest
	crate::xboxkrnl::XMsgStartIORequest(ctx, base);
	// 8240230C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82402310: 4080000C  bge 0x8240231c
	if !ctx.cr[0].lt {
	pc = 0x8240231C; continue 'dispatch;
	}
	// 82402314: 3BC0065B  li r30, 0x65b
	ctx.r[30].s64 = 1627;
	// 82402318: 48000034  b 0x8240234c
	pc = 0x8240234C; continue 'dispatch;
            }
            0x8240231C => {
    //   block [0x8240231C..0x82402338)
	// 8240231C: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82402320: 409A0018  bne cr6, 0x82402338
	if !ctx.cr[6].eq {
	pc = 0x82402338; continue 'dispatch;
	}
	// 82402324: 4BFC001D  bl 0x823c2340
	ctx.lr = 0x82402328;
	sub_823C2340(ctx, base);
	// 82402328: 21630000  subfic r11, r3, 0
	ctx.xer.ca = ctx.r[3].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[3].s64;
	// 8240232C: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82402330: 717E065B  andi. r30, r11, 0x65b
	ctx.r[30].u64 = ctx.r[11].u64 & 1627;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82402334: 48000008  b 0x8240233c
	pc = 0x8240233C; continue 'dispatch;
            }
            0x82402338 => {
    //   block [0x82402338..0x8240233C)
	// 82402338: 3BC003E5  li r30, 0x3e5
	ctx.r[30].s64 = 997;
	pc = 0x8240233C; continue 'dispatch;
            }
            0x8240233C => {
    //   block [0x8240233C..0x8240234C)
	// 8240233C: 2B1E03E5  cmplwi cr6, r30, 0x3e5
	ctx.cr[6].compare_u32(ctx.r[30].u32, 997 as u32, &mut ctx.xer);
	// 82402340: 419A0020  beq cr6, 0x82402360
	if ctx.cr[6].eq {
	pc = 0x82402360; continue 'dispatch;
	}
	// 82402344: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82402348: 419A0018  beq cr6, 0x82402360
	if ctx.cr[6].eq {
	pc = 0x82402360; continue 'dispatch;
	}
	pc = 0x8240234C; continue 'dispatch;
            }
            0x8240234C => {
    //   block [0x8240234C..0x8240235C)
	// 8240234C: 80760000  lwz r3, 0(r22)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 82402350: 4BFBE609  bl 0x823c0958
	ctx.lr = 0x82402354;
	sub_823C0958(ctx, base);
	// 82402354: 93960000  stw r28, 0(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82402358: 48000008  b 0x82402360
	pc = 0x82402360; continue 'dispatch;
            }
            0x8240235C => {
    //   block [0x8240235C..0x82402360)
	// 8240235C: 3BC00057  li r30, 0x57
	ctx.r[30].s64 = 87;
	pc = 0x82402360; continue 'dispatch;
            }
            0x82402360 => {
    //   block [0x82402360..0x8240236C)
	// 82402360: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82402364: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82402368: 48132D88  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82402370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82402370 size=184
    let mut pc: u32 = 0x82402370;
    'dispatch: loop {
        match pc {
            0x82402370 => {
    //   block [0x82402370..0x824023A4)
	// 82402370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82402374: 48132D41  bl 0x825350b4
	ctx.lr = 0x82402378;
	sub_82535080(ctx, base);
	// 82402378: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240237C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82402380: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82402384: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82402388: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 8240238C: 57EB05AD  rlwinm. r11, r31, 0, 0x16, 0x16
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82402390: 41820014  beq 0x824023a4
	if ctx.cr[0].eq {
	pc = 0x824023A4; continue 'dispatch;
	}
	// 82402394: 57EB0529  rlwinm. r11, r31, 0, 0x14, 0x14
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82402398: 4182000C  beq 0x824023a4
	if ctx.cr[0].eq {
	pc = 0x824023A4; continue 'dispatch;
	}
	// 8240239C: 3BC00057  li r30, 0x57
	ctx.r[30].s64 = 87;
	// 824023A0: 4800007C  b 0x8240241c
	pc = 0x8240241C; continue 'dispatch;
            }
            0x824023A4 => {
    //   block [0x824023A4..0x824023F4)
	// 824023A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824023A8: 4830B8B5  bl 0x8270dc5c
	ctx.lr = 0x824023AC;
	// extern call 0x8270DC5C  crate::xam::XamSessionRefObjByHandle
	crate::xam::XamSessionRefObjByHandle(ctx, base);
	// 824023AC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 824023B0: 4082006C  bne 0x8240241c
	if !ctx.cr[0].eq {
	pc = 0x8240241C; continue 'dispatch;
	}
	// 824023B4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824023B8: 3C80000B  lis r4, 0xb
	ctx.r[4].s64 = 720896;
	// 824023BC: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 824023C0: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 824023C4: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 824023C8: 93810068  stw r28, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 824023CC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 824023D0: 9361006C  stw r27, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[27].u32 ) };
	// 824023D4: 60840018  ori r4, r4, 0x18
	ctx.r[4].u64 = ctx.r[4].u64 | 24;
	// 824023D8: 386000FB  li r3, 0xfb
	ctx.r[3].s64 = 251;
	// 824023DC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 824023E0: 4830AC9D  bl 0x8270d07c
	ctx.lr = 0x824023E4;
	// extern call 0x8270D07C  crate::xboxkrnl::XMsgStartIORequest
	crate::xboxkrnl::XMsgStartIORequest(ctx, base);
	// 824023E4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 824023E8: 4080000C  bge 0x824023f4
	if !ctx.cr[0].lt {
	pc = 0x824023F4; continue 'dispatch;
	}
	// 824023EC: 3BC0065B  li r30, 0x65b
	ctx.r[30].s64 = 1627;
	// 824023F0: 48000024  b 0x82402414
	pc = 0x82402414; continue 'dispatch;
            }
            0x824023F4 => {
    //   block [0x824023F4..0x82402410)
	// 824023F4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 824023F8: 409A0018  bne cr6, 0x82402410
	if !ctx.cr[6].eq {
	pc = 0x82402410; continue 'dispatch;
	}
	// 824023FC: 4BFBFF45  bl 0x823c2340
	ctx.lr = 0x82402400;
	sub_823C2340(ctx, base);
	// 82402400: 21630000  subfic r11, r3, 0
	ctx.xer.ca = ctx.r[3].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[3].s64;
	// 82402404: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82402408: 717E065B  andi. r30, r11, 0x65b
	ctx.r[30].u64 = ctx.r[11].u64 & 1627;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8240240C: 48000008  b 0x82402414
	pc = 0x82402414; continue 'dispatch;
            }
            0x82402410 => {
    //   block [0x82402410..0x82402414)
	// 82402410: 3BC003E5  li r30, 0x3e5
	ctx.r[30].s64 = 997;
	pc = 0x82402414; continue 'dispatch;
            }
            0x82402414 => {
    //   block [0x82402414..0x8240241C)
	// 82402414: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82402418: 4830B035  bl 0x8270d44c
	ctx.lr = 0x8240241C;
	// extern call 0x8270D44C  crate::xboxkrnl::ObDereferenceObject
	crate::xboxkrnl::ObDereferenceObject(ctx, base);
	pc = 0x8240241C; continue 'dispatch;
            }
            0x8240241C => {
    //   block [0x8240241C..0x82402428)
	// 8240241C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82402420: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82402424: 48132CE0  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82402428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82402428 size=172
    let mut pc: u32 = 0x82402428;
    'dispatch: loop {
        match pc {
            0x82402428 => {
    //   block [0x82402428..0x82402490)
	// 82402428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240242C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82402430: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82402434: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82402438: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240243C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82402440: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82402444: 4830B819  bl 0x8270dc5c
	ctx.lr = 0x82402448;
	// extern call 0x8270DC5C  crate::xam::XamSessionRefObjByHandle
	crate::xam::XamSessionRefObjByHandle(ctx, base);
	// 82402448: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8240244C: 4082006C  bne 0x824024b8
	if !ctx.cr[0].eq {
	pc = 0x824024B8; continue 'dispatch;
	}
	// 82402450: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82402454: 3C80000B  lis r4, 0xb
	ctx.r[4].s64 = 720896;
	// 82402458: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 8240245C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82402460: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82402464: 60840011  ori r4, r4, 0x11
	ctx.r[4].u64 = ctx.r[4].u64 | 17;
	// 82402468: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8240246C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82402470: 386000FB  li r3, 0xfb
	ctx.r[3].s64 = 251;
	// 82402474: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82402478: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 8240247C: 4830AC01  bl 0x8270d07c
	ctx.lr = 0x82402480;
	// extern call 0x8270D07C  crate::xboxkrnl::XMsgStartIORequest
	crate::xboxkrnl::XMsgStartIORequest(ctx, base);
	// 82402480: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82402484: 4080000C  bge 0x82402490
	if !ctx.cr[0].lt {
	pc = 0x82402490; continue 'dispatch;
	}
	// 82402488: 3BE0065B  li r31, 0x65b
	ctx.r[31].s64 = 1627;
	// 8240248C: 48000024  b 0x824024b0
	pc = 0x824024B0; continue 'dispatch;
            }
            0x82402490 => {
    //   block [0x82402490..0x824024AC)
	// 82402490: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82402494: 409A0018  bne cr6, 0x824024ac
	if !ctx.cr[6].eq {
	pc = 0x824024AC; continue 'dispatch;
	}
	// 82402498: 4BFBFEA9  bl 0x823c2340
	ctx.lr = 0x8240249C;
	sub_823C2340(ctx, base);
	// 8240249C: 21630000  subfic r11, r3, 0
	ctx.xer.ca = ctx.r[3].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[3].s64;
	// 824024A0: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 824024A4: 717F065B  andi. r31, r11, 0x65b
	ctx.r[31].u64 = ctx.r[11].u64 & 1627;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824024A8: 48000008  b 0x824024b0
	pc = 0x824024B0; continue 'dispatch;
            }
            0x824024AC => {
    //   block [0x824024AC..0x824024B0)
	// 824024AC: 3BE003E5  li r31, 0x3e5
	ctx.r[31].s64 = 997;
	pc = 0x824024B0; continue 'dispatch;
            }
            0x824024B0 => {
    //   block [0x824024B0..0x824024B8)
	// 824024B0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824024B4: 4830AF99  bl 0x8270d44c
	ctx.lr = 0x824024B8;
	// extern call 0x8270D44C  crate::xboxkrnl::ObDereferenceObject
	crate::xboxkrnl::ObDereferenceObject(ctx, base);
	pc = 0x824024B8; continue 'dispatch;
            }
            0x824024B8 => {
    //   block [0x824024B8..0x824024D4)
	// 824024B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824024BC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 824024C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824024C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824024C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824024CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824024D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824024D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824024D8 size=168
    let mut pc: u32 = 0x824024D8;
    'dispatch: loop {
        match pc {
            0x824024D8 => {
    //   block [0x824024D8..0x8240254C)
	// 824024D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824024DC: 48132BD9  bl 0x825350b4
	ctx.lr = 0x824024E0;
	sub_82535080(ctx, base);
	// 824024E0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824024E4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 824024E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824024EC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 824024F0: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 824024F4: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 824024F8: 4830B765  bl 0x8270dc5c
	ctx.lr = 0x824024FC;
	// extern call 0x8270DC5C  crate::xam::XamSessionRefObjByHandle
	crate::xam::XamSessionRefObjByHandle(ctx, base);
	// 824024FC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82402500: 40820074  bne 0x82402574
	if !ctx.cr[0].eq {
	pc = 0x82402574; continue 'dispatch;
	}
	// 82402504: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82402508: 3C80000B  lis r4, 0xb
	ctx.r[4].s64 = 720896;
	// 8240250C: 38E00014  li r7, 0x14
	ctx.r[7].s64 = 20;
	// 82402510: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82402514: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82402518: 9381006C  stw r28, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	// 8240251C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82402520: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 82402524: 60840012  ori r4, r4, 0x12
	ctx.r[4].u64 = ctx.r[4].u64 | 18;
	// 82402528: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8240252C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82402530: 386000FB  li r3, 0xfb
	ctx.r[3].s64 = 251;
	// 82402534: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82402538: 4830AB45  bl 0x8270d07c
	ctx.lr = 0x8240253C;
	// extern call 0x8270D07C  crate::xboxkrnl::XMsgStartIORequest
	crate::xboxkrnl::XMsgStartIORequest(ctx, base);
	// 8240253C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82402540: 4080000C  bge 0x8240254c
	if !ctx.cr[0].lt {
	pc = 0x8240254C; continue 'dispatch;
	}
	// 82402544: 3BE0065B  li r31, 0x65b
	ctx.r[31].s64 = 1627;
	// 82402548: 48000024  b 0x8240256c
	pc = 0x8240256C; continue 'dispatch;
            }
            0x8240254C => {
    //   block [0x8240254C..0x82402568)
	// 8240254C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82402550: 409A0018  bne cr6, 0x82402568
	if !ctx.cr[6].eq {
	pc = 0x82402568; continue 'dispatch;
	}
	// 82402554: 4BFBFDED  bl 0x823c2340
	ctx.lr = 0x82402558;
	sub_823C2340(ctx, base);
	// 82402558: 21630000  subfic r11, r3, 0
	ctx.xer.ca = ctx.r[3].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[3].s64;
	// 8240255C: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82402560: 717F065B  andi. r31, r11, 0x65b
	ctx.r[31].u64 = ctx.r[11].u64 & 1627;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82402564: 48000008  b 0x8240256c
	pc = 0x8240256C; continue 'dispatch;
            }
            0x82402568 => {
    //   block [0x82402568..0x8240256C)
	// 82402568: 3BE003E5  li r31, 0x3e5
	ctx.r[31].s64 = 997;
	pc = 0x8240256C; continue 'dispatch;
            }
            0x8240256C => {
    //   block [0x8240256C..0x82402574)
	// 8240256C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82402570: 4830AEDD  bl 0x8270d44c
	ctx.lr = 0x82402574;
	// extern call 0x8270D44C  crate::xboxkrnl::ObDereferenceObject
	crate::xboxkrnl::ObDereferenceObject(ctx, base);
	pc = 0x82402574; continue 'dispatch;
            }
            0x82402574 => {
    //   block [0x82402574..0x82402580)
	// 82402574: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82402578: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8240257C: 48132B88  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82402580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82402580 size=168
    let mut pc: u32 = 0x82402580;
    'dispatch: loop {
        match pc {
            0x82402580 => {
    //   block [0x82402580..0x824025F4)
	// 82402580: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82402584: 48132B31  bl 0x825350b4
	ctx.lr = 0x82402588;
	sub_82535080(ctx, base);
	// 82402588: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240258C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82402590: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82402594: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82402598: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 8240259C: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 824025A0: 4830B6BD  bl 0x8270dc5c
	ctx.lr = 0x824025A4;
	// extern call 0x8270DC5C  crate::xam::XamSessionRefObjByHandle
	crate::xam::XamSessionRefObjByHandle(ctx, base);
	// 824025A4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824025A8: 40820074  bne 0x8240261c
	if !ctx.cr[0].eq {
	pc = 0x8240261C; continue 'dispatch;
	}
	// 824025AC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824025B0: 3C80000B  lis r4, 0xb
	ctx.r[4].s64 = 720896;
	// 824025B4: 38E00014  li r7, 0x14
	ctx.r[7].s64 = 20;
	// 824025B8: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 824025BC: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 824025C0: 93810068  stw r28, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 824025C4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 824025C8: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 824025CC: 60840012  ori r4, r4, 0x12
	ctx.r[4].u64 = ctx.r[4].u64 | 18;
	// 824025D0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 824025D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824025D8: 386000FB  li r3, 0xfb
	ctx.r[3].s64 = 251;
	// 824025DC: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 824025E0: 4830AA9D  bl 0x8270d07c
	ctx.lr = 0x824025E4;
	// extern call 0x8270D07C  crate::xboxkrnl::XMsgStartIORequest
	crate::xboxkrnl::XMsgStartIORequest(ctx, base);
	// 824025E4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 824025E8: 4080000C  bge 0x824025f4
	if !ctx.cr[0].lt {
	pc = 0x824025F4; continue 'dispatch;
	}
	// 824025EC: 3BE0065B  li r31, 0x65b
	ctx.r[31].s64 = 1627;
	// 824025F0: 48000024  b 0x82402614
	pc = 0x82402614; continue 'dispatch;
            }
            0x824025F4 => {
    //   block [0x824025F4..0x82402610)
	// 824025F4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 824025F8: 409A0018  bne cr6, 0x82402610
	if !ctx.cr[6].eq {
	pc = 0x82402610; continue 'dispatch;
	}
	// 824025FC: 4BFBFD45  bl 0x823c2340
	ctx.lr = 0x82402600;
	sub_823C2340(ctx, base);
	// 82402600: 21630000  subfic r11, r3, 0
	ctx.xer.ca = ctx.r[3].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[3].s64;
	// 82402604: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82402608: 717F065B  andi. r31, r11, 0x65b
	ctx.r[31].u64 = ctx.r[11].u64 & 1627;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8240260C: 48000008  b 0x82402614
	pc = 0x82402614; continue 'dispatch;
            }
            0x82402610 => {
    //   block [0x82402610..0x82402614)
	// 82402610: 3BE003E5  li r31, 0x3e5
	ctx.r[31].s64 = 997;
	pc = 0x82402614; continue 'dispatch;
            }
            0x82402614 => {
    //   block [0x82402614..0x8240261C)
	// 82402614: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82402618: 4830AE35  bl 0x8270d44c
	ctx.lr = 0x8240261C;
	// extern call 0x8270D44C  crate::xboxkrnl::ObDereferenceObject
	crate::xboxkrnl::ObDereferenceObject(ctx, base);
	pc = 0x8240261C; continue 'dispatch;
            }
            0x8240261C => {
    //   block [0x8240261C..0x82402628)
	// 8240261C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82402620: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82402624: 48132AE0  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82402628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82402628 size=164
    let mut pc: u32 = 0x82402628;
    'dispatch: loop {
        match pc {
            0x82402628 => {
    //   block [0x82402628..0x82402698)
	// 82402628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240262C: 48132A8D  bl 0x825350b8
	ctx.lr = 0x82402630;
	sub_82535080(ctx, base);
	// 82402630: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82402634: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82402638: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8240263C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82402640: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82402644: 4830B619  bl 0x8270dc5c
	ctx.lr = 0x82402648;
	// extern call 0x8270DC5C  crate::xam::XamSessionRefObjByHandle
	crate::xam::XamSessionRefObjByHandle(ctx, base);
	// 82402648: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8240264C: 40820074  bne 0x824026c0
	if !ctx.cr[0].eq {
	pc = 0x824026C0; continue 'dispatch;
	}
	// 82402650: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82402654: 3C80000B  lis r4, 0xb
	ctx.r[4].s64 = 720896;
	// 82402658: 38E00014  li r7, 0x14
	ctx.r[7].s64 = 20;
	// 8240265C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82402660: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82402664: 9381006C  stw r28, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	// 82402668: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8240266C: 60840013  ori r4, r4, 0x13
	ctx.r[4].u64 = ctx.r[4].u64 | 19;
	// 82402670: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82402674: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82402678: 386000FB  li r3, 0xfb
	ctx.r[3].s64 = 251;
	// 8240267C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82402680: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82402684: 4830A9F9  bl 0x8270d07c
	ctx.lr = 0x82402688;
	// extern call 0x8270D07C  crate::xboxkrnl::XMsgStartIORequest
	crate::xboxkrnl::XMsgStartIORequest(ctx, base);
	// 82402688: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 8240268C: 4080000C  bge 0x82402698
	if !ctx.cr[0].lt {
	pc = 0x82402698; continue 'dispatch;
	}
	// 82402690: 3BE0065B  li r31, 0x65b
	ctx.r[31].s64 = 1627;
	// 82402694: 48000024  b 0x824026b8
	pc = 0x824026B8; continue 'dispatch;
            }
            0x82402698 => {
    //   block [0x82402698..0x824026B4)
	// 82402698: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8240269C: 409A0018  bne cr6, 0x824026b4
	if !ctx.cr[6].eq {
	pc = 0x824026B4; continue 'dispatch;
	}
	// 824026A0: 4BFBFCA1  bl 0x823c2340
	ctx.lr = 0x824026A4;
	sub_823C2340(ctx, base);
	// 824026A4: 21630000  subfic r11, r3, 0
	ctx.xer.ca = ctx.r[3].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[3].s64;
	// 824026A8: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 824026AC: 717F065B  andi. r31, r11, 0x65b
	ctx.r[31].u64 = ctx.r[11].u64 & 1627;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824026B0: 48000008  b 0x824026b8
	pc = 0x824026B8; continue 'dispatch;
            }
            0x824026B4 => {
    //   block [0x824026B4..0x824026B8)
	// 824026B4: 3BE003E5  li r31, 0x3e5
	ctx.r[31].s64 = 997;
	pc = 0x824026B8; continue 'dispatch;
            }
            0x824026B8 => {
    //   block [0x824026B8..0x824026C0)
	// 824026B8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824026BC: 4830AD91  bl 0x8270d44c
	ctx.lr = 0x824026C0;
	// extern call 0x8270D44C  crate::xboxkrnl::ObDereferenceObject
	crate::xboxkrnl::ObDereferenceObject(ctx, base);
	pc = 0x824026C0; continue 'dispatch;
            }
            0x824026C0 => {
    //   block [0x824026C0..0x824026CC)
	// 824026C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824026C4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824026C8: 48132A40  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824026D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824026D0 size=164
    let mut pc: u32 = 0x824026D0;
    'dispatch: loop {
        match pc {
            0x824026D0 => {
    //   block [0x824026D0..0x82402740)
	// 824026D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824026D4: 481329E5  bl 0x825350b8
	ctx.lr = 0x824026D8;
	sub_82535080(ctx, base);
	// 824026D8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824026DC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 824026E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824026E4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 824026E8: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 824026EC: 4830B571  bl 0x8270dc5c
	ctx.lr = 0x824026F0;
	// extern call 0x8270DC5C  crate::xam::XamSessionRefObjByHandle
	crate::xam::XamSessionRefObjByHandle(ctx, base);
	// 824026F0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824026F4: 40820074  bne 0x82402768
	if !ctx.cr[0].eq {
	pc = 0x82402768; continue 'dispatch;
	}
	// 824026F8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824026FC: 3C80000B  lis r4, 0xb
	ctx.r[4].s64 = 720896;
	// 82402700: 38E00014  li r7, 0x14
	ctx.r[7].s64 = 20;
	// 82402704: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82402708: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 8240270C: 93810068  stw r28, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 82402710: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82402714: 60840013  ori r4, r4, 0x13
	ctx.r[4].u64 = ctx.r[4].u64 | 19;
	// 82402718: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8240271C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82402720: 386000FB  li r3, 0xfb
	ctx.r[3].s64 = 251;
	// 82402724: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82402728: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 8240272C: 4830A951  bl 0x8270d07c
	ctx.lr = 0x82402730;
	// extern call 0x8270D07C  crate::xboxkrnl::XMsgStartIORequest
	crate::xboxkrnl::XMsgStartIORequest(ctx, base);
	// 82402730: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82402734: 4080000C  bge 0x82402740
	if !ctx.cr[0].lt {
	pc = 0x82402740; continue 'dispatch;
	}
	// 82402738: 3BE0065B  li r31, 0x65b
	ctx.r[31].s64 = 1627;
	// 8240273C: 48000024  b 0x82402760
	pc = 0x82402760; continue 'dispatch;
            }
            0x82402740 => {
    //   block [0x82402740..0x8240275C)
	// 82402740: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82402744: 409A0018  bne cr6, 0x8240275c
	if !ctx.cr[6].eq {
	pc = 0x8240275C; continue 'dispatch;
	}
	// 82402748: 4BFBFBF9  bl 0x823c2340
	ctx.lr = 0x8240274C;
	sub_823C2340(ctx, base);
	// 8240274C: 21630000  subfic r11, r3, 0
	ctx.xer.ca = ctx.r[3].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[3].s64;
	// 82402750: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82402754: 717F065B  andi. r31, r11, 0x65b
	ctx.r[31].u64 = ctx.r[11].u64 & 1627;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82402758: 48000008  b 0x82402760
	pc = 0x82402760; continue 'dispatch;
            }
            0x8240275C => {
    //   block [0x8240275C..0x82402760)
	// 8240275C: 3BE003E5  li r31, 0x3e5
	ctx.r[31].s64 = 997;
	pc = 0x82402760; continue 'dispatch;
            }
            0x82402760 => {
    //   block [0x82402760..0x82402768)
	// 82402760: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82402764: 4830ACE9  bl 0x8270d44c
	ctx.lr = 0x82402768;
	// extern call 0x8270D44C  crate::xboxkrnl::ObDereferenceObject
	crate::xboxkrnl::ObDereferenceObject(ctx, base);
	pc = 0x82402768; continue 'dispatch;
            }
            0x82402768 => {
    //   block [0x82402768..0x82402774)
	// 82402768: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8240276C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82402770: 48132998  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82402778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82402778 size=216
    let mut pc: u32 = 0x82402778;
    'dispatch: loop {
        match pc {
            0x82402778 => {
    //   block [0x82402778..0x8240280C)
	// 82402778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240277C: 48132935  bl 0x825350b0
	ctx.lr = 0x82402780;
	sub_82535080(ctx, base);
	// 82402780: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82402784: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 82402788: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 8240278C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82402790: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82402794: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 82402798: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8240279C: 419A009C  beq cr6, 0x82402838
	if ctx.cr[6].eq {
	pc = 0x82402838; continue 'dispatch;
	}
	// 824027A0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824027A4: 2B0B0E08  cmplwi cr6, r11, 0xe08
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3592 as u32, &mut ctx.xer);
	// 824027A8: 41980090  blt cr6, 0x82402838
	if ctx.cr[6].lt {
	pc = 0x82402838; continue 'dispatch;
	}
	// 824027AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824027B0: 4830B4AD  bl 0x8270dc5c
	ctx.lr = 0x824027B4;
	// extern call 0x8270DC5C  crate::xam::XamSessionRefObjByHandle
	crate::xam::XamSessionRefObjByHandle(ctx, base);
	// 824027B4: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 824027B8: 4082008C  bne 0x82402844
	if !ctx.cr[0].eq {
	pc = 0x82402844; continue 'dispatch;
	}
	// 824027BC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824027C0: 3C80000B  lis r4, 0xb
	ctx.r[4].s64 = 720896;
	// 824027C4: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 824027C8: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 824027CC: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 824027D0: FB410068  std r26, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[26].u64 ) };
	// 824027D4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 824027D8: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 824027DC: 6084001A  ori r4, r4, 0x1a
	ctx.r[4].u64 = ctx.r[4].u64 | 26;
	// 824027E0: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 824027E4: 386000FB  li r3, 0xfb
	ctx.r[3].s64 = 251;
	// 824027E8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824027EC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 824027F0: 3960012C  li r11, 0x12c
	ctx.r[11].s64 = 300;
	// 824027F4: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 824027F8: 4830A885  bl 0x8270d07c
	ctx.lr = 0x824027FC;
	// extern call 0x8270D07C  crate::xboxkrnl::XMsgStartIORequest
	crate::xboxkrnl::XMsgStartIORequest(ctx, base);
	// 824027FC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82402800: 4080000C  bge 0x8240280c
	if !ctx.cr[0].lt {
	pc = 0x8240280C; continue 'dispatch;
	}
	// 82402804: 3BA0065B  li r29, 0x65b
	ctx.r[29].s64 = 1627;
	// 82402808: 48000024  b 0x8240282c
	pc = 0x8240282C; continue 'dispatch;
            }
            0x8240280C => {
    //   block [0x8240280C..0x82402828)
	// 8240280C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82402810: 409A0018  bne cr6, 0x82402828
	if !ctx.cr[6].eq {
	pc = 0x82402828; continue 'dispatch;
	}
	// 82402814: 4BFBFB2D  bl 0x823c2340
	ctx.lr = 0x82402818;
	sub_823C2340(ctx, base);
	// 82402818: 21630000  subfic r11, r3, 0
	ctx.xer.ca = ctx.r[3].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[3].s64;
	// 8240281C: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82402820: 717D065B  andi. r29, r11, 0x65b
	ctx.r[29].u64 = ctx.r[11].u64 & 1627;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82402824: 48000008  b 0x8240282c
	pc = 0x8240282C; continue 'dispatch;
            }
            0x82402828 => {
    //   block [0x82402828..0x8240282C)
	// 82402828: 3BA003E5  li r29, 0x3e5
	ctx.r[29].s64 = 997;
	pc = 0x8240282C; continue 'dispatch;
            }
            0x8240282C => {
    //   block [0x8240282C..0x82402838)
	// 8240282C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82402830: 4830AC1D  bl 0x8270d44c
	ctx.lr = 0x82402834;
	// extern call 0x8270D44C  crate::xboxkrnl::ObDereferenceObject
	crate::xboxkrnl::ObDereferenceObject(ctx, base);
	// 82402834: 48000010  b 0x82402844
	pc = 0x82402844; continue 'dispatch;
            }
            0x82402838 => {
    //   block [0x82402838..0x82402844)
	// 82402838: 39600E08  li r11, 0xe08
	ctx.r[11].s64 = 3592;
	// 8240283C: 3BA0007A  li r29, 0x7a
	ctx.r[29].s64 = 122;
	// 82402840: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82402844; continue 'dispatch;
            }
            0x82402844 => {
    //   block [0x82402844..0x82402850)
	// 82402844: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82402848: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8240284C: 481328B4  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82402850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82402850 size=152
    let mut pc: u32 = 0x82402850;
    'dispatch: loop {
        match pc {
            0x82402850 => {
    //   block [0x82402850..0x824028B4)
	// 82402850: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82402854: 48132869  bl 0x825350bc
	ctx.lr = 0x82402858;
	sub_82535080(ctx, base);
	// 82402858: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240285C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82402860: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82402864: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82402868: 4830B3F5  bl 0x8270dc5c
	ctx.lr = 0x8240286C;
	// extern call 0x8270DC5C  crate::xam::XamSessionRefObjByHandle
	crate::xam::XamSessionRefObjByHandle(ctx, base);
	// 8240286C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82402870: 4082006C  bne 0x824028dc
	if !ctx.cr[0].eq {
	pc = 0x824028DC; continue 'dispatch;
	}
	// 82402874: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82402878: 3C80000B  lis r4, 0xb
	ctx.r[4].s64 = 720896;
	// 8240287C: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82402880: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82402884: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82402888: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8240288C: 60840014  ori r4, r4, 0x14
	ctx.r[4].u64 = ctx.r[4].u64 | 20;
	// 82402890: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82402894: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82402898: 386000FB  li r3, 0xfb
	ctx.r[3].s64 = 251;
	// 8240289C: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 824028A0: 4830A7DD  bl 0x8270d07c
	ctx.lr = 0x824028A4;
	// extern call 0x8270D07C  crate::xboxkrnl::XMsgStartIORequest
	crate::xboxkrnl::XMsgStartIORequest(ctx, base);
	// 824028A4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 824028A8: 4080000C  bge 0x824028b4
	if !ctx.cr[0].lt {
	pc = 0x824028B4; continue 'dispatch;
	}
	// 824028AC: 3BE0065B  li r31, 0x65b
	ctx.r[31].s64 = 1627;
	// 824028B0: 48000024  b 0x824028d4
	pc = 0x824028D4; continue 'dispatch;
            }
            0x824028B4 => {
    //   block [0x824028B4..0x824028D0)
	// 824028B4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 824028B8: 409A0018  bne cr6, 0x824028d0
	if !ctx.cr[6].eq {
	pc = 0x824028D0; continue 'dispatch;
	}
	// 824028BC: 4BFBFA85  bl 0x823c2340
	ctx.lr = 0x824028C0;
	sub_823C2340(ctx, base);
	// 824028C0: 21630000  subfic r11, r3, 0
	ctx.xer.ca = ctx.r[3].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[3].s64;
	// 824028C4: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 824028C8: 717F065B  andi. r31, r11, 0x65b
	ctx.r[31].u64 = ctx.r[11].u64 & 1627;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824028CC: 48000008  b 0x824028d4
	pc = 0x824028D4; continue 'dispatch;
            }
            0x824028D0 => {
    //   block [0x824028D0..0x824028D4)
	// 824028D0: 3BE003E5  li r31, 0x3e5
	ctx.r[31].s64 = 997;
	pc = 0x824028D4; continue 'dispatch;
            }
            0x824028D4 => {
    //   block [0x824028D4..0x824028DC)
	// 824028D4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824028D8: 4830AB75  bl 0x8270d44c
	ctx.lr = 0x824028DC;
	// extern call 0x8270D44C  crate::xboxkrnl::ObDereferenceObject
	crate::xboxkrnl::ObDereferenceObject(ctx, base);
	pc = 0x824028DC; continue 'dispatch;
            }
            0x824028DC => {
    //   block [0x824028DC..0x824028E8)
	// 824028DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824028E0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 824028E4: 48132828  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824028E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824028E8 size=172
    let mut pc: u32 = 0x824028E8;
    'dispatch: loop {
        match pc {
            0x824028E8 => {
    //   block [0x824028E8..0x82402950)
	// 824028E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824028EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824028F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824028F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824028F8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824028FC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82402900: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82402904: 4830B359  bl 0x8270dc5c
	ctx.lr = 0x82402908;
	// extern call 0x8270DC5C  crate::xam::XamSessionRefObjByHandle
	crate::xam::XamSessionRefObjByHandle(ctx, base);
	// 82402908: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8240290C: 4082006C  bne 0x82402978
	if !ctx.cr[0].eq {
	pc = 0x82402978; continue 'dispatch;
	}
	// 82402910: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82402914: 3C80000B  lis r4, 0xb
	ctx.r[4].s64 = 720896;
	// 82402918: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 8240291C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82402920: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82402924: 60840015  ori r4, r4, 0x15
	ctx.r[4].u64 = ctx.r[4].u64 | 21;
	// 82402928: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8240292C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82402930: 386000FB  li r3, 0xfb
	ctx.r[3].s64 = 251;
	// 82402934: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82402938: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 8240293C: 4830A741  bl 0x8270d07c
	ctx.lr = 0x82402940;
	// extern call 0x8270D07C  crate::xboxkrnl::XMsgStartIORequest
	crate::xboxkrnl::XMsgStartIORequest(ctx, base);
	// 82402940: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82402944: 4080000C  bge 0x82402950
	if !ctx.cr[0].lt {
	pc = 0x82402950; continue 'dispatch;
	}
	// 82402948: 3BE0065B  li r31, 0x65b
	ctx.r[31].s64 = 1627;
	// 8240294C: 48000024  b 0x82402970
	pc = 0x82402970; continue 'dispatch;
            }
            0x82402950 => {
    //   block [0x82402950..0x8240296C)
	// 82402950: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82402954: 409A0018  bne cr6, 0x8240296c
	if !ctx.cr[6].eq {
	pc = 0x8240296C; continue 'dispatch;
	}
	// 82402958: 4BFBF9E9  bl 0x823c2340
	ctx.lr = 0x8240295C;
	sub_823C2340(ctx, base);
	// 8240295C: 21630000  subfic r11, r3, 0
	ctx.xer.ca = ctx.r[3].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[3].s64;
	// 82402960: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82402964: 717F065B  andi. r31, r11, 0x65b
	ctx.r[31].u64 = ctx.r[11].u64 & 1627;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82402968: 48000008  b 0x82402970
	pc = 0x82402970; continue 'dispatch;
            }
            0x8240296C => {
    //   block [0x8240296C..0x82402970)
	// 8240296C: 3BE003E5  li r31, 0x3e5
	ctx.r[31].s64 = 997;
	pc = 0x82402970; continue 'dispatch;
            }
            0x82402970 => {
    //   block [0x82402970..0x82402978)
	// 82402970: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82402974: 4830AAD9  bl 0x8270d44c
	ctx.lr = 0x82402978;
	// extern call 0x8270D44C  crate::xboxkrnl::ObDereferenceObject
	crate::xboxkrnl::ObDereferenceObject(ctx, base);
	pc = 0x82402978; continue 'dispatch;
            }
            0x82402978 => {
    //   block [0x82402978..0x82402994)
	// 82402978: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8240297C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82402980: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82402984: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82402988: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8240298C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82402990: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82402998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82402998 size=240
    let mut pc: u32 = 0x82402998;
    'dispatch: loop {
        match pc {
            0x82402998 => {
    //   block [0x82402998..0x82402A54)
	// 82402998: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240299C: 48132709  bl 0x825350a4
	ctx.lr = 0x824029A0;
	sub_82535080(ctx, base);
	// 824029A0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824029A4: 83C10124  lwz r30, 0x124(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(292 as u32) ) } as u64;
	// 824029A8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 824029AC: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 824029B0: 1D7F052E  mulli r11, r31, 0x52e
	ctx.r[11].s32 = ((ctx.r[31].s32 as i64 * 1326 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 824029B4: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824029B8: 3AEB0008  addi r23, r11, 8
	ctx.r[23].s64 = ctx.r[11].s64 + 8;
	// 824029BC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 824029C0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 824029C4: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 824029C8: 7F07B840  cmplw cr6, r7, r23
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[23].u32, &mut ctx.xer);
	// 824029CC: 419800AC  blt cr6, 0x82402a78
	if ctx.cr[6].lt {
	pc = 0x82402A78; continue 'dispatch;
	}
	// 824029D0: 8161012C  lwz r11, 0x12c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(300 as u32) ) } as u64;
	// 824029D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824029D8: 419A00A0  beq cr6, 0x82402a78
	if ctx.cr[6].eq {
	pc = 0x82402A78; continue 'dispatch;
	}
	// 824029DC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 824029E0: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 824029E4: 83010134  lwz r24, 0x134(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 824029E8: 3C80000B  lis r4, 0xb
	ctx.r[4].s64 = 720896;
	// 824029EC: 38E00024  li r7, 0x24
	ctx.r[7].s64 = 36;
	// 824029F0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 824029F4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 824029F8: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 824029FC: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 82402A00: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82402A04: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82402A08: 6084001C  ori r4, r4, 0x1c
	ctx.r[4].u64 = ctx.r[4].u64 | 28;
	// 82402A0C: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82402A10: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82402A14: 386000FB  li r3, 0xfb
	ctx.r[3].s64 = 251;
	// 82402A18: 93410070  stw r26, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[26].u32 ) };
	// 82402A1C: B321005C  sth r25, 0x5c(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u16 ) };
	// 82402A20: B101005E  sth r8, 0x5e(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(94 as u32), ctx.r[8].u16 ) };
	// 82402A24: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 82402A28: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82402A2C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82402A30: 4830A64D  bl 0x8270d07c
	ctx.lr = 0x82402A34;
	// extern call 0x8270D07C  crate::xboxkrnl::XMsgStartIORequest
	crate::xboxkrnl::XMsgStartIORequest(ctx, base);
	// 82402A34: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82402A38: 4080001C  bge 0x82402a54
	if !ctx.cr[0].lt {
	pc = 0x82402A54; continue 'dispatch;
	}
	// 82402A3C: 3D608015  lis r11, -0x7feb
	ctx.r[11].s64 = -2146107392;
	// 82402A40: 616B5207  ori r11, r11, 0x5207
	ctx.r[11].u64 = ctx.r[11].u64 | 20999;
	// 82402A44: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82402A48: 419A0030  beq cr6, 0x82402a78
	if ctx.cr[6].eq {
	pc = 0x82402A78; continue 'dispatch;
	}
	// 82402A4C: 3860065B  li r3, 0x65b
	ctx.r[3].s64 = 1627;
	// 82402A50: 48000030  b 0x82402a80
	pc = 0x82402A80; continue 'dispatch;
            }
            0x82402A54 => {
    //   block [0x82402A54..0x82402A70)
	// 82402A54: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82402A58: 409A0018  bne cr6, 0x82402a70
	if !ctx.cr[6].eq {
	pc = 0x82402A70; continue 'dispatch;
	}
	// 82402A5C: 4BFBF8E5  bl 0x823c2340
	ctx.lr = 0x82402A60;
	sub_823C2340(ctx, base);
	// 82402A60: 21630000  subfic r11, r3, 0
	ctx.xer.ca = ctx.r[3].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[3].s64;
	// 82402A64: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82402A68: 7163065B  andi. r3, r11, 0x65b
	ctx.r[3].u64 = ctx.r[11].u64 & 1627;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82402A6C: 48000014  b 0x82402a80
	pc = 0x82402A80; continue 'dispatch;
            }
            0x82402A70 => {
    //   block [0x82402A70..0x82402A78)
	// 82402A70: 386003E5  li r3, 0x3e5
	ctx.r[3].s64 = 997;
	// 82402A74: 4800000C  b 0x82402a80
	pc = 0x82402A80; continue 'dispatch;
            }
            0x82402A78 => {
    //   block [0x82402A78..0x82402A80)
	// 82402A78: 92FE0000  stw r23, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 82402A7C: 3860007A  li r3, 0x7a
	ctx.r[3].s64 = 122;
	pc = 0x82402A80; continue 'dispatch;
            }
            0x82402A80 => {
    //   block [0x82402A80..0x82402A88)
	// 82402A80: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82402A84: 48132670  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82402A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82402A88 size=192
    let mut pc: u32 = 0x82402A88;
    'dispatch: loop {
        match pc {
            0x82402A88 => {
    //   block [0x82402A88..0x82402AC4)
	// 82402A88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82402A8C: 48132629  bl 0x825350b4
	ctx.lr = 0x82402A90;
	sub_82535080(ctx, base);
	// 82402A90: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82402A94: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82402A98: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82402A9C: 7BEB8420  rldicl r11, r31, 0x10, 0x30
	ctx.r[11].u64 = ctx.r[31].u64 & 0x0000FFFFFFFFFFFFu64;
	// 82402AA0: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82402AA4: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82402AA8: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 82402AAC: 556A073E  clrlwi r10, r11, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 82402AB0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82402AB4: 2B0A0009  cmplwi cr6, r10, 9
	ctx.cr[6].compare_u32(ctx.r[10].u32, 9 as u32, &mut ctx.xer);
	// 82402AB8: 409A000C  bne cr6, 0x82402ac4
	if !ctx.cr[6].eq {
	pc = 0x82402AC4; continue 'dispatch;
	}
	// 82402ABC: 556B0633  rlwinm. r11, r11, 0, 0x18, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82402AC0: 4082007C  bne 0x82402b3c
	if !ctx.cr[0].eq {
	pc = 0x82402B3C; continue 'dispatch;
	}
	pc = 0x82402AC4; continue 'dispatch;
            }
            0x82402AC4 => {
    //   block [0x82402AC4..0x82402B14)
	// 82402AC4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82402AC8: 4830B195  bl 0x8270dc5c
	ctx.lr = 0x82402ACC;
	// extern call 0x8270DC5C  crate::xam::XamSessionRefObjByHandle
	crate::xam::XamSessionRefObjByHandle(ctx, base);
	// 82402ACC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82402AD0: 4082006C  bne 0x82402b3c
	if !ctx.cr[0].eq {
	pc = 0x82402B3C; continue 'dispatch;
	}
	// 82402AD4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82402AD8: 3C80000B  lis r4, 0xb
	ctx.r[4].s64 = 720896;
	// 82402ADC: 38E00018  li r7, 0x18
	ctx.r[7].s64 = 24;
	// 82402AE0: FBE10068  std r31, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u64 ) };
	// 82402AE4: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82402AE8: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 82402AEC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82402AF0: 93610074  stw r27, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[27].u32 ) };
	// 82402AF4: 60840025  ori r4, r4, 0x25
	ctx.r[4].u64 = ctx.r[4].u64 | 37;
	// 82402AF8: 386000FB  li r3, 0xfb
	ctx.r[3].s64 = 251;
	// 82402AFC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82402B00: 4830A57D  bl 0x8270d07c
	ctx.lr = 0x82402B04;
	// extern call 0x8270D07C  crate::xboxkrnl::XMsgStartIORequest
	crate::xboxkrnl::XMsgStartIORequest(ctx, base);
	// 82402B04: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82402B08: 4080000C  bge 0x82402b14
	if !ctx.cr[0].lt {
	pc = 0x82402B14; continue 'dispatch;
	}
	// 82402B0C: 3BC0065B  li r30, 0x65b
	ctx.r[30].s64 = 1627;
	// 82402B10: 48000024  b 0x82402b34
	pc = 0x82402B34; continue 'dispatch;
            }
            0x82402B14 => {
    //   block [0x82402B14..0x82402B30)
	// 82402B14: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82402B18: 409A0018  bne cr6, 0x82402b30
	if !ctx.cr[6].eq {
	pc = 0x82402B30; continue 'dispatch;
	}
	// 82402B1C: 4BFBF825  bl 0x823c2340
	ctx.lr = 0x82402B20;
	sub_823C2340(ctx, base);
	// 82402B20: 21630000  subfic r11, r3, 0
	ctx.xer.ca = ctx.r[3].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[3].s64;
	// 82402B24: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82402B28: 717E065B  andi. r30, r11, 0x65b
	ctx.r[30].u64 = ctx.r[11].u64 & 1627;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82402B2C: 48000008  b 0x82402b34
	pc = 0x82402B34; continue 'dispatch;
            }
            0x82402B30 => {
    //   block [0x82402B30..0x82402B34)
	// 82402B30: 3BC003E5  li r30, 0x3e5
	ctx.r[30].s64 = 997;
	pc = 0x82402B34; continue 'dispatch;
            }
            0x82402B34 => {
    //   block [0x82402B34..0x82402B3C)
	// 82402B34: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82402B38: 4830A915  bl 0x8270d44c
	ctx.lr = 0x82402B3C;
	// extern call 0x8270D44C  crate::xboxkrnl::ObDereferenceObject
	crate::xboxkrnl::ObDereferenceObject(ctx, base);
	pc = 0x82402B3C; continue 'dispatch;
            }
            0x82402B3C => {
    //   block [0x82402B3C..0x82402B48)
	// 82402B3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82402B40: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82402B44: 481325C0  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82402B48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82402B48 size=80
    let mut pc: u32 = 0x82402B48;
    'dispatch: loop {
        match pc {
            0x82402B48 => {
    //   block [0x82402B48..0x82402B98)
	// 82402B48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82402B4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82402B50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82402B54: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82402B58: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 82402B5C: 3C800005  lis r4, 5
	ctx.r[4].s64 = 327680;
	// 82402B60: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82402B64: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82402B68: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82402B6C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82402B70: 6084800E  ori r4, r4, 0x800e
	ctx.r[4].u64 = ctx.r[4].u64 | 32782;
	// 82402B74: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 82402B78: 386000FC  li r3, 0xfc
	ctx.r[3].s64 = 252;
	// 82402B7C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82402B80: 4830B0FD  bl 0x8270dc7c
	ctx.lr = 0x82402B84;
	// extern call 0x8270DC7C  crate::xboxkrnl::XMsgInProcessCall
	crate::xboxkrnl::XMsgInProcessCall(ctx, base);
	// 82402B84: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82402B88: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82402B8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82402B90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82402B94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82402B98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82402B98 size=48
    let mut pc: u32 = 0x82402B98;
    'dispatch: loop {
        match pc {
            0x82402B98 => {
    //   block [0x82402B98..0x82402BC8)
	// 82402B98: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82402B9C: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 82402BA0: 7C8807B4  extsw r8, r4
	ctx.r[8].s64 = ctx.r[4].s32 as i64;
	// 82402BA4: 814B0200  lwz r10, 0x200(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(512 as u32) ) } as u64;
	// 82402BA8: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82402BAC: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82402BB0: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82402BB4: F90A0008  std r8, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[8].u64 ) };
	// 82402BB8: 806B0200  lwz r3, 0x200(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(512 as u32) ) } as u64;
	// 82402BBC: 39430001  addi r10, r3, 1
	ctx.r[10].s64 = ctx.r[3].s64 + 1;
	// 82402BC0: 914B0200  stw r10, 0x200(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(512 as u32), ctx.r[10].u32 ) };
	// 82402BC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82402BC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82402BC8 size=352
    let mut pc: u32 = 0x82402BC8;
    'dispatch: loop {
        match pc {
            0x82402BC8 => {
    //   block [0x82402BC8..0x82402CF4)
	// 82402BC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82402BCC: 481324ED  bl 0x825350b8
	ctx.lr = 0x82402BD0;
	sub_82535080(ctx, base);
	// 82402BD0: 9421FD30  stwu r1, -0x2d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-720 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82402BD4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82402BD8: 906102E4  stw r3, 0x2e4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(740 as u32), ctx.r[3].u32 ) };
	// 82402BDC: 908102EC  stw r4, 0x2ec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(748 as u32), ctx.r[4].u32 ) };
	// 82402BE0: 38600206  li r3, 0x206
	ctx.r[3].s64 = 518;
	// 82402BE4: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82402BE8: 90A102F4  stw r5, 0x2f4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(756 as u32), ctx.r[5].u32 ) };
	// 82402BEC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82402BF0: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82402BF4: 93C102A0  stw r30, 0x2a0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(672 as u32), ctx.r[30].u32 ) };
	// 82402BF8: 93C10080  stw r30, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 82402BFC: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 82402C00: 48000541  bl 0x82403140
	ctx.lr = 0x82402C04;
	sub_82403140(ctx, base);
	// 82402C04: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82402C08: 418000EC  blt 0x82402cf4
	if ctx.cr[0].lt {
	pc = 0x82402CF4; continue 'dispatch;
	}
	// 82402C0C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82402C10: 80610088  lwz r3, 0x88(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82402C14: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82402C18: 38E10084  addi r7, r1, 0x84
	ctx.r[7].s64 = ctx.r[1].s64 + 132;
	// 82402C1C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82402C20: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82402C24: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82402C28: 480005A1  bl 0x824031c8
	ctx.lr = 0x82402C2C;
	sub_824031C8(ctx, base);
	// 82402C2C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82402C30: 418000C4  blt 0x82402cf4
	if ctx.cr[0].lt {
	pc = 0x82402CF4; continue 'dispatch;
	}
	// 82402C34: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82402C38: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82402C3C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82402C40: 4830B05D  bl 0x8270dc9c
	ctx.lr = 0x82402C44;
	// extern call 0x8270DC9C  crate::xam::XamAlloc
	crate::xam::XamAlloc(ctx, base);
	// 82402C44: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82402C48: 418000AC  blt 0x82402cf4
	if ctx.cr[0].lt {
	pc = 0x82402CF4; continue 'dispatch;
	}
	// 82402C4C: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 82402C50: 81010084  lwz r8, 0x84(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82402C54: 38E10094  addi r7, r1, 0x94
	ctx.r[7].s64 = ctx.r[1].s64 + 148;
	// 82402C58: 80810088  lwz r4, 0x88(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82402C5C: 3961008C  addi r11, r1, 0x8c
	ctx.r[11].s64 = ctx.r[1].s64 + 140;
	// 82402C60: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82402C64: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82402C68: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82402C6C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82402C70: 90C1005C  stw r6, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[6].u32 ) };
	// 82402C74: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82402C78: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82402C7C: 90E10064  stw r7, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[7].u32 ) };
	// 82402C80: 38600206  li r3, 0x206
	ctx.r[3].s64 = 518;
	// 82402C84: 80E10080  lwz r7, 0x80(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82402C88: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82402C8C: 480005DD  bl 0x82403268
	ctx.lr = 0x82402C90;
	sub_82403268(ctx, base);
	// 82402C90: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82402C94: 41800060  blt 0x82402cf4
	if ctx.cr[0].lt {
	pc = 0x82402CF4; continue 'dispatch;
	}
	// 82402C98: 388102E4  addi r4, r1, 0x2e4
	ctx.r[4].s64 = ctx.r[1].s64 + 740;
	// 82402C9C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82402CA0: 4BFFFEF9  bl 0x82402b98
	ctx.lr = 0x82402CA4;
	sub_82402B98(ctx, base);
	// 82402CA4: 388102EC  addi r4, r1, 0x2ec
	ctx.r[4].s64 = ctx.r[1].s64 + 748;
	// 82402CA8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82402CAC: 4BFFFEED  bl 0x82402b98
	ctx.lr = 0x82402CB0;
	sub_82402B98(ctx, base);
	// 82402CB0: 388102F4  addi r4, r1, 0x2f4
	ctx.r[4].s64 = ctx.r[1].s64 + 756;
	// 82402CB4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82402CB8: 4BFFFEE1  bl 0x82402b98
	ctx.lr = 0x82402CBC;
	sub_82402B98(ctx, base);
	// 82402CBC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82402CC0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82402CC4: 4BFFFED5  bl 0x82402b98
	ctx.lr = 0x82402CC8;
	sub_82402B98(ctx, base);
	// 82402CC8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82402CCC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82402CD0: 4BFFFEC9  bl 0x82402b98
	ctx.lr = 0x82402CD4;
	sub_82402B98(ctx, base);
	// 82402CD4: 3C800005  lis r4, 5
	ctx.r[4].s64 = 327680;
	// 82402CD8: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 82402CDC: 80A1008C  lwz r5, 0x8c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82402CE0: 60848020  ori r4, r4, 0x8020
	ctx.r[4].u64 = ctx.r[4].u64 | 32800;
	// 82402CE4: 386000FC  li r3, 0xfc
	ctx.r[3].s64 = 252;
	// 82402CE8: 4830AF95  bl 0x8270dc7c
	ctx.lr = 0x82402CEC;
	// extern call 0x8270DC7C  crate::xboxkrnl::XMsgInProcessCall
	crate::xboxkrnl::XMsgInProcessCall(ctx, base);
	// 82402CEC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82402CF0: 40800024  bge 0x82402d14
	if !ctx.cr[0].lt {
	pc = 0x82402D14; continue 'dispatch;
	}
	pc = 0x82402CF4; continue 'dispatch;
            }
            0x82402CF4 => {
    //   block [0x82402CF4..0x82402D04)
	// 82402CF4: 80610080  lwz r3, 0x80(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82402CF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82402CFC: 419A0008  beq cr6, 0x82402d04
	if ctx.cr[6].eq {
	pc = 0x82402D04; continue 'dispatch;
	}
	// 82402D00: 4830AF8D  bl 0x8270dc8c
	ctx.lr = 0x82402D04;
	// extern call 0x8270DC8C  crate::xam::XamFree
	crate::xam::XamFree(ctx, base);
	pc = 0x82402D04; continue 'dispatch;
            }
            0x82402D04 => {
    //   block [0x82402D04..0x82402D14)
	// 82402D04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82402D08: 4BFBFA89  bl 0x823c2790
	ctx.lr = 0x82402D0C;
	sub_823C2790(ctx, base);
	// 82402D0C: 3BC0065B  li r30, 0x65b
	ctx.r[30].s64 = 1627;
	// 82402D10: 4800000C  b 0x82402d1c
	pc = 0x82402D1C; continue 'dispatch;
            }
            0x82402D14 => {
    //   block [0x82402D14..0x82402D1C)
	// 82402D14: 80610080  lwz r3, 0x80(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82402D18: 4830AF75  bl 0x8270dc8c
	ctx.lr = 0x82402D1C;
	// extern call 0x8270DC8C  crate::xam::XamFree
	crate::xam::XamFree(ctx, base);
	pc = 0x82402D1C; continue 'dispatch;
            }
            0x82402D1C => {
    //   block [0x82402D1C..0x82402D28)
	// 82402D1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82402D20: 382102D0  addi r1, r1, 0x2d0
	ctx.r[1].s64 = ctx.r[1].s64 + 720;
	// 82402D24: 481323E4  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82402D28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82402D28 size=304
    let mut pc: u32 = 0x82402D28;
    'dispatch: loop {
        match pc {
            0x82402D28 => {
    //   block [0x82402D28..0x82402E24)
	// 82402D28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82402D2C: 48132391  bl 0x825350bc
	ctx.lr = 0x82402D30;
	sub_82535080(ctx, base);
	// 82402D30: 9421FD30  stwu r1, -0x2d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-720 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82402D34: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82402D38: 906102E4  stw r3, 0x2e4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(740 as u32), ctx.r[3].u32 ) };
	// 82402D3C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82402D40: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82402D44: 38600586  li r3, 0x586
	ctx.r[3].s64 = 1414;
	// 82402D48: 93C102A0  stw r30, 0x2a0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(672 as u32), ctx.r[30].u32 ) };
	// 82402D4C: 93C10080  stw r30, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 82402D50: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 82402D54: 480003ED  bl 0x82403140
	ctx.lr = 0x82402D58;
	sub_82403140(ctx, base);
	// 82402D58: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82402D5C: 418000C8  blt 0x82402e24
	if ctx.cr[0].lt {
	pc = 0x82402E24; continue 'dispatch;
	}
	// 82402D60: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82402D64: 80610088  lwz r3, 0x88(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82402D68: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82402D6C: 38E10084  addi r7, r1, 0x84
	ctx.r[7].s64 = ctx.r[1].s64 + 132;
	// 82402D70: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82402D74: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82402D78: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82402D7C: 4800044D  bl 0x824031c8
	ctx.lr = 0x82402D80;
	sub_824031C8(ctx, base);
	// 82402D80: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82402D84: 418000A0  blt 0x82402e24
	if ctx.cr[0].lt {
	pc = 0x82402E24; continue 'dispatch;
	}
	// 82402D88: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82402D8C: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82402D90: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82402D94: 4830AF09  bl 0x8270dc9c
	ctx.lr = 0x82402D98;
	// extern call 0x8270DC9C  crate::xam::XamAlloc
	crate::xam::XamAlloc(ctx, base);
	// 82402D98: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82402D9C: 41800088  blt 0x82402e24
	if ctx.cr[0].lt {
	pc = 0x82402E24; continue 'dispatch;
	}
	// 82402DA0: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 82402DA4: 81010084  lwz r8, 0x84(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82402DA8: 38E10094  addi r7, r1, 0x94
	ctx.r[7].s64 = ctx.r[1].s64 + 148;
	// 82402DAC: 80810088  lwz r4, 0x88(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82402DB0: 3961008C  addi r11, r1, 0x8c
	ctx.r[11].s64 = ctx.r[1].s64 + 140;
	// 82402DB4: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82402DB8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82402DBC: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82402DC0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82402DC4: 90C1005C  stw r6, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[6].u32 ) };
	// 82402DC8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82402DCC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82402DD0: 90E10064  stw r7, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[7].u32 ) };
	// 82402DD4: 38600586  li r3, 0x586
	ctx.r[3].s64 = 1414;
	// 82402DD8: 80E10080  lwz r7, 0x80(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82402DDC: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82402DE0: 48000489  bl 0x82403268
	ctx.lr = 0x82402DE4;
	sub_82403268(ctx, base);
	// 82402DE4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82402DE8: 4180003C  blt 0x82402e24
	if ctx.cr[0].lt {
	pc = 0x82402E24; continue 'dispatch;
	}
	// 82402DEC: 388102E4  addi r4, r1, 0x2e4
	ctx.r[4].s64 = ctx.r[1].s64 + 740;
	// 82402DF0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82402DF4: 4BFFFDA5  bl 0x82402b98
	ctx.lr = 0x82402DF8;
	sub_82402B98(ctx, base);
	// 82402DF8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82402DFC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82402E00: 4BFFFD99  bl 0x82402b98
	ctx.lr = 0x82402E04;
	sub_82402B98(ctx, base);
	// 82402E04: 3C800005  lis r4, 5
	ctx.r[4].s64 = 327680;
	// 82402E08: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 82402E0C: 80A1008C  lwz r5, 0x8c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82402E10: 60848023  ori r4, r4, 0x8023
	ctx.r[4].u64 = ctx.r[4].u64 | 32803;
	// 82402E14: 386000FC  li r3, 0xfc
	ctx.r[3].s64 = 252;
	// 82402E18: 4830AE65  bl 0x8270dc7c
	ctx.lr = 0x82402E1C;
	// extern call 0x8270DC7C  crate::xboxkrnl::XMsgInProcessCall
	crate::xboxkrnl::XMsgInProcessCall(ctx, base);
	// 82402E1C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82402E20: 40800024  bge 0x82402e44
	if !ctx.cr[0].lt {
	pc = 0x82402E44; continue 'dispatch;
	}
	pc = 0x82402E24; continue 'dispatch;
            }
            0x82402E24 => {
    //   block [0x82402E24..0x82402E34)
	// 82402E24: 80610080  lwz r3, 0x80(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82402E28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82402E2C: 419A0008  beq cr6, 0x82402e34
	if ctx.cr[6].eq {
	pc = 0x82402E34; continue 'dispatch;
	}
	// 82402E30: 4830AE5D  bl 0x8270dc8c
	ctx.lr = 0x82402E34;
	// extern call 0x8270DC8C  crate::xam::XamFree
	crate::xam::XamFree(ctx, base);
	pc = 0x82402E34; continue 'dispatch;
            }
            0x82402E34 => {
    //   block [0x82402E34..0x82402E44)
	// 82402E34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82402E38: 4BFBF959  bl 0x823c2790
	ctx.lr = 0x82402E3C;
	sub_823C2790(ctx, base);
	// 82402E3C: 3BC0065B  li r30, 0x65b
	ctx.r[30].s64 = 1627;
	// 82402E40: 4800000C  b 0x82402e4c
	pc = 0x82402E4C; continue 'dispatch;
            }
            0x82402E44 => {
    //   block [0x82402E44..0x82402E4C)
	// 82402E44: 80610080  lwz r3, 0x80(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82402E48: 4830AE45  bl 0x8270dc8c
	ctx.lr = 0x82402E4C;
	// extern call 0x8270DC8C  crate::xam::XamFree
	crate::xam::XamFree(ctx, base);
	pc = 0x82402E4C; continue 'dispatch;
            }
            0x82402E4C => {
    //   block [0x82402E4C..0x82402E58)
	// 82402E4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82402E50: 382102D0  addi r1, r1, 0x2d0
	ctx.r[1].s64 = ctx.r[1].s64 + 720;
	// 82402E54: 481322B8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82402E58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82402E58 size=576
    let mut pc: u32 = 0x82402E58;
    'dispatch: loop {
        match pc {
            0x82402E58 => {
    //   block [0x82402E58..0x82402EF8)
	// 82402E58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82402E5C: 48132255  bl 0x825350b0
	ctx.lr = 0x82402E60;
	sub_82535080(ctx, base);
	// 82402E60: 9421FCE0  stwu r1, -0x320(r1)
	ea = ctx.r[1].u32.wrapping_add(-800 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82402E64: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82402E68: 90610334  stw r3, 0x334(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(820 as u32), ctx.r[3].u32 ) };
	// 82402E6C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82402E70: 90A10344  stw r5, 0x344(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(836 as u32), ctx.r[5].u32 ) };
	// 82402E74: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82402E78: 38600801  li r3, 0x801
	ctx.r[3].s64 = 2049;
	// 82402E7C: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82402E80: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 82402E84: 93E102E0  stw r31, 0x2e0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(736 as u32), ctx.r[31].u32 ) };
	// 82402E88: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 82402E8C: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 82402E90: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 82402E94: 93E10088  stw r31, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[31].u32 ) };
	// 82402E98: 480002A9  bl 0x82403140
	ctx.lr = 0x82402E9C;
	sub_82403140(ctx, base);
	// 82402E9C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82402EA0: 418001A0  blt 0x82403040
	if ctx.cr[0].lt {
	pc = 0x82403040; continue 'dispatch;
	}
	// 82402EA4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82402EA8: 80610080  lwz r3, 0x80(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82402EAC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82402EB0: 38E10088  addi r7, r1, 0x88
	ctx.r[7].s64 = ctx.r[1].s64 + 136;
	// 82402EB4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82402EB8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82402EBC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82402EC0: 48000309  bl 0x824031c8
	ctx.lr = 0x82402EC4;
	sub_824031C8(ctx, base);
	// 82402EC4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82402EC8: 41800178  blt 0x82403040
	if ctx.cr[0].lt {
	pc = 0x82403040; continue 'dispatch;
	}
	// 82402ECC: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 82402ED0: 80810088  lwz r4, 0x88(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82402ED4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82402ED8: 4830ADC5  bl 0x8270dc9c
	ctx.lr = 0x82402EDC;
	// extern call 0x8270DC9C  crate::xam::XamAlloc
	crate::xam::XamAlloc(ctx, base);
	// 82402EDC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82402EE0: 41800160  blt 0x82403040
	if ctx.cr[0].lt {
	pc = 0x82403040; continue 'dispatch;
	}
	// 82402EE4: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 82402EE8: 4830ADC5  bl 0x8270dcac
	ctx.lr = 0x82402EEC;
	// extern call 0x8270DCAC  crate::xboxkrnl::XNetLogonGetTitleID
	crate::xboxkrnl::XNetLogonGetTitleID(ctx, base);
	// 82402EEC: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82402EF0: 906100A0  stw r3, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[3].u32 ) };
	// 82402EF4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82402EF8; continue 'dispatch;
            }
            0x82402EF8 => {
    //   block [0x82402EF8..0x82403040)
	// 82402EF8: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82402EFC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82402F00: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82402F04: 409AFFF4  bne cr6, 0x82402ef8
	if !ctx.cr[6].eq {
	pc = 0x82402EF8; continue 'dispatch;
	}
	// 82402F08: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82402F0C: 81010088  lwz r8, 0x88(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82402F10: 39410098  addi r10, r1, 0x98
	ctx.r[10].s64 = ctx.r[1].s64 + 152;
	// 82402F14: 80E10090  lwz r7, 0x90(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 82402F18: 38C10094  addi r6, r1, 0x94
	ctx.r[6].s64 = ctx.r[1].s64 + 148;
	// 82402F1C: 80810080  lwz r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82402F20: 38A1009C  addi r5, r1, 0x9c
	ctx.r[5].s64 = ctx.r[1].s64 + 156;
	// 82402F24: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82402F28: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82402F2C: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 82402F30: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 82402F34: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 82402F38: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82402F3C: 83A10344  lwz r29, 0x344(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(836 as u32) ) } as u64;
	// 82402F40: 38600801  li r3, 0x801
	ctx.r[3].s64 = 2049;
	// 82402F44: 90C10064  stw r6, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[6].u32 ) };
	// 82402F48: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82402F4C: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 82402F50: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82402F54: B1610084  sth r11, 0x84(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u16 ) };
	// 82402F58: B3A1008C  sth r29, 0x8c(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[29].u16 ) };
	// 82402F5C: 4800030D  bl 0x82403268
	ctx.lr = 0x82402F60;
	sub_82403268(ctx, base);
	// 82402F60: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82402F64: 418000DC  blt 0x82403040
	if ctx.cr[0].lt {
	pc = 0x82403040; continue 'dispatch;
	}
	// 82402F68: 38810334  addi r4, r1, 0x334
	ctx.r[4].s64 = ctx.r[1].s64 + 820;
	// 82402F6C: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82402F70: 4BFFFC29  bl 0x82402b98
	ctx.lr = 0x82402F74;
	sub_82402B98(ctx, base);
	// 82402F74: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82402F78: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82402F7C: 4BFFFC1D  bl 0x82402b98
	ctx.lr = 0x82402F80;
	sub_82402B98(ctx, base);
	// 82402F80: 38810344  addi r4, r1, 0x344
	ctx.r[4].s64 = ctx.r[1].s64 + 836;
	// 82402F84: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82402F88: 4BFFFC11  bl 0x82402b98
	ctx.lr = 0x82402F8C;
	sub_82402B98(ctx, base);
	// 82402F8C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82402F90: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82402F94: 4BFFFC05  bl 0x82402b98
	ctx.lr = 0x82402F98;
	sub_82402B98(ctx, base);
	// 82402F98: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 82402F9C: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82402FA0: 4BFFFBF9  bl 0x82402b98
	ctx.lr = 0x82402FA4;
	sub_82402B98(ctx, base);
	// 82402FA4: 38810084  addi r4, r1, 0x84
	ctx.r[4].s64 = ctx.r[1].s64 + 132;
	// 82402FA8: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82402FAC: 4BFFFBED  bl 0x82402b98
	ctx.lr = 0x82402FB0;
	sub_82402B98(ctx, base);
	// 82402FB0: 3881008C  addi r4, r1, 0x8c
	ctx.r[4].s64 = ctx.r[1].s64 + 140;
	// 82402FB4: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82402FB8: 4BFFFBE1  bl 0x82402b98
	ctx.lr = 0x82402FBC;
	sub_82402B98(ctx, base);
	// 82402FBC: 39410094  addi r10, r1, 0x94
	ctx.r[10].s64 = ctx.r[1].s64 + 148;
	// 82402FC0: 390100E0  addi r8, r1, 0xe0
	ctx.r[8].s64 = ctx.r[1].s64 + 224;
	// 82402FC4: 8121009C  lwz r9, 0x9c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82402FC8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82402FCC: 80A10080  lwz r5, 0x80(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82402FD0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82402FD4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82402FD8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82402FDC: 48000375  bl 0x82403350
	ctx.lr = 0x82402FE0;
	sub_82403350(ctx, base);
	// 82402FE0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82402FE4: 4180005C  blt 0x82403040
	if ctx.cr[0].lt {
	pc = 0x82403040; continue 'dispatch;
	}
	// 82402FE8: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82402FEC: 396100B0  addi r11, r1, 0xb0
	ctx.r[11].s64 = ctx.r[1].s64 + 176;
	// 82402FF0: 81210098  lwz r9, 0x98(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 82402FF4: 38E00028  li r7, 0x28
	ctx.r[7].s64 = 40;
	// 82402FF8: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 82402FFC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82403000: 386000FC  li r3, 0xfc
	ctx.r[3].s64 = 252;
	// 82403004: 9149001C  stw r10, 0x1c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82403008: FBEB0000  std r31, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u64 ) };
	// 8240300C: FBEB0008  std r31, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[31].u64 ) };
	// 82403010: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82403014: FBEB0010  std r31, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[31].u64 ) };
	// 82403018: FBEB0018  std r31, 0x18(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[31].u64 ) };
	// 8240301C: 5544043E  clrlwi r4, r10, 0x10
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 82403020: FBEB0020  std r31, 0x20(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[31].u64 ) };
	// 82403024: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 82403028: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 8240302C: 5144801E  rlwimi r4, r10, 0x10, 0, 0xf
	ctx.r[4].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[4].u64 & 0xFFFFFFFF0000FFFF);
	// 82403030: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 82403034: 4830A049  bl 0x8270d07c
	ctx.lr = 0x82403038;
	// extern call 0x8270D07C  crate::xboxkrnl::XMsgStartIORequest
	crate::xboxkrnl::XMsgStartIORequest(ctx, base);
	// 82403038: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 8240303C: 40800030  bge 0x8240306c
	if !ctx.cr[0].lt {
	pc = 0x8240306C; continue 'dispatch;
	}
	pc = 0x82403040; continue 'dispatch;
            }
            0x82403040 => {
    //   block [0x82403040..0x82403054)
	// 82403040: 3BE0065B  li r31, 0x65b
	ctx.r[31].s64 = 1627;
	// 82403044: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82403048: 419A000C  beq cr6, 0x82403054
	if ctx.cr[6].eq {
	pc = 0x82403054; continue 'dispatch;
	}
	// 8240304C: 907E0018  stw r3, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[3].u32 ) };
	// 82403050: 48000008  b 0x82403058
	pc = 0x82403058; continue 'dispatch;
            }
            0x82403054 => {
    //   block [0x82403054..0x82403058)
	// 82403054: 4BFBF29D  bl 0x823c22f0
	ctx.lr = 0x82403058;
	sub_823C22F0(ctx, base);
	pc = 0x82403058; continue 'dispatch;
            }
            0x82403058 => {
    //   block [0x82403058..0x8240306C)
	// 82403058: 80610090  lwz r3, 0x90(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 8240305C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82403060: 419A002C  beq cr6, 0x8240308c
	if ctx.cr[6].eq {
	pc = 0x8240308C; continue 'dispatch;
	}
	// 82403064: 4830AC29  bl 0x8270dc8c
	ctx.lr = 0x82403068;
	// extern call 0x8270DC8C  crate::xam::XamFree
	crate::xam::XamFree(ctx, base);
	// 82403068: 48000024  b 0x8240308c
	pc = 0x8240308C; continue 'dispatch;
            }
            0x8240306C => {
    //   block [0x8240306C..0x8240307C)
	// 8240306C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82403070: 419A000C  beq cr6, 0x8240307c
	if ctx.cr[6].eq {
	pc = 0x8240307C; continue 'dispatch;
	}
	// 82403074: 3BE003E5  li r31, 0x3e5
	ctx.r[31].s64 = 997;
	// 82403078: 48000014  b 0x8240308c
	pc = 0x8240308C; continue 'dispatch;
            }
            0x8240307C => {
    //   block [0x8240307C..0x8240308C)
	// 8240307C: 4BFBF2C5  bl 0x823c2340
	ctx.lr = 0x82403080;
	sub_823C2340(ctx, base);
	// 82403080: 21630000  subfic r11, r3, 0
	ctx.xer.ca = ctx.r[3].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[3].s64;
	// 82403084: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82403088: 717F065B  andi. r31, r11, 0x65b
	ctx.r[31].u64 = ctx.r[11].u64 & 1627;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	pc = 0x8240308C; continue 'dispatch;
            }
            0x8240308C => {
    //   block [0x8240308C..0x82403098)
	// 8240308C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82403090: 38210320  addi r1, r1, 0x320
	ctx.r[1].s64 = ctx.r[1].s64 + 800;
	// 82403094: 4813206C  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824030A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824030A8 size=136
    let mut pc: u32 = 0x824030A8;
    'dispatch: loop {
        match pc {
            0x824030A8 => {
    //   block [0x824030A8..0x82403118)
	// 824030A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824030AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824030B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824030B4: 9421FE10  stwu r1, -0x1f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-496 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824030B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824030BC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 824030C0: 419A0058  beq cr6, 0x82403118
	if ctx.cr[6].eq {
	pc = 0x82403118; continue 'dispatch;
	}
	// 824030C4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824030C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824030CC: 419A004C  beq cr6, 0x82403118
	if ctx.cr[6].eq {
	pc = 0x82403118; continue 'dispatch;
	}
	// 824030D0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824030D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824030D8: 419A0040  beq cr6, 0x82403118
	if ctx.cr[6].eq {
	pc = 0x82403118; continue 'dispatch;
	}
	// 824030DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824030E0: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 824030E4: 4BFEE265  bl 0x823f1348
	ctx.lr = 0x824030E8;
	sub_823F1348(ctx, base);
	// 824030E8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 824030EC: 40820030  bne 0x8240311c
	if !ctx.cr[0].eq {
	pc = 0x8240311C; continue 'dispatch;
	}
	// 824030F0: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 824030F4: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824030F8: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824030FC: 386B37C0  addi r3, r11, 0x37c0
	ctx.r[3].s64 = ctx.r[11].s64 + 14272;
	// 82403100: 48000801  bl 0x82403900
	ctx.lr = 0x82403104;
	sub_82403900(ctx, base);
	// 82403104: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82403108: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8240310C: 40800010  bge 0x8240311c
	if !ctx.cr[0].lt {
	pc = 0x8240311C; continue 'dispatch;
	}
	// 82403110: 3860065B  li r3, 0x65b
	ctx.r[3].s64 = 1627;
	// 82403114: 48000008  b 0x8240311c
	pc = 0x8240311C; continue 'dispatch;
            }
            0x82403118 => {
    //   block [0x82403118..0x8240311C)
	// 82403118: 38600057  li r3, 0x57
	ctx.r[3].s64 = 87;
	pc = 0x8240311C; continue 'dispatch;
            }
            0x8240311C => {
    //   block [0x8240311C..0x82403130)
	// 8240311C: 382101F0  addi r1, r1, 0x1f0
	ctx.r[1].s64 = ctx.r[1].s64 + 496;
	// 82403120: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82403124: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82403128: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8240312C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82403130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82403130 size=12
    let mut pc: u32 = 0x82403130;
    'dispatch: loop {
        match pc {
            0x82403130 => {
    //   block [0x82403130..0x8240313C)
	// 82403130: 3D608273  lis r11, -0x7d8d
	ctx.r[11].s64 = -2106392576;
	// 82403134: 386B3198  addi r3, r11, 0x3198
	ctx.r[3].s64 = ctx.r[11].s64 + 12696;
	// 82403138: 4BFFFF70  b 0x824030a8
	sub_824030A8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82403140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82403140 size=136
    let mut pc: u32 = 0x82403140;
    'dispatch: loop {
        match pc {
            0x82403140 => {
    //   block [0x82403140..0x82403178)
	// 82403140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82403144: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82403148: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8240314C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82403150: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82403154: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82403158: 396B37C0  addi r11, r11, 0x37c0
	ctx.r[11].s64 = ctx.r[11].s64 + 14272;
	// 8240315C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82403160: 808B002C  lwz r4, 0x2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82403164: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82403168: 40820010  bne 0x82403178
	if !ctx.cr[0].eq {
	pc = 0x82403178; continue 'dispatch;
	}
	// 8240316C: 3C608015  lis r3, -0x7feb
	ctx.r[3].s64 = -2146107392;
	// 82403170: 60630005  ori r3, r3, 5
	ctx.r[3].u64 = ctx.r[3].u64 | 5;
	// 82403174: 48000040  b 0x824031b4
	pc = 0x824031B4; continue 'dispatch;
            }
            0x82403178 => {
    //   block [0x82403178..0x824031A8)
	// 82403178: A0AB0028  lhz r5, 0x28(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8240317C: 3D608240  lis r11, -0x7dc0
	ctx.r[11].s64 = -2109734912;
	// 82403180: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82403184: B1410050  sth r10, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u16 ) };
	// 82403188: 38EB3098  addi r7, r11, 0x3098
	ctx.r[7].s64 = ctx.r[11].s64 + 12440;
	// 8240318C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82403190: 48133439  bl 0x825365c8
	ctx.lr = 0x82403194;
	sub_825365C8(ctx, base);
	// 82403194: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82403198: 40820010  bne 0x824031a8
	if !ctx.cr[0].eq {
	pc = 0x824031A8; continue 'dispatch;
	}
	// 8240319C: 3C608015  lis r3, -0x7feb
	ctx.r[3].s64 = -2146107392;
	// 824031A0: 6063000E  ori r3, r3, 0xe
	ctx.r[3].u64 = ctx.r[3].u64 | 14;
	// 824031A4: 48000010  b 0x824031b4
	pc = 0x824031B4; continue 'dispatch;
            }
            0x824031A8 => {
    //   block [0x824031A8..0x824031B4)
	// 824031A8: A1630002  lhz r11, 2(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(2 as u32) ) } as u64;
	// 824031AC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824031B0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x824031B4; continue 'dispatch;
            }
            0x824031B4 => {
    //   block [0x824031B4..0x824031C8)
	// 824031B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824031B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824031BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824031C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824031C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824031C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824031C8 size=156
    let mut pc: u32 = 0x824031C8;
    'dispatch: loop {
        match pc {
            0x824031C8 => {
    //   block [0x824031C8..0x82403218)
	// 824031C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824031CC: 48131EE5  bl 0x825350b0
	ctx.lr = 0x824031D0;
	sub_82535080(ctx, base);
	// 824031D0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824031D4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 824031D8: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 824031DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 824031E0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 824031E4: 386A37C0  addi r3, r10, 0x37c0
	ctx.r[3].s64 = ctx.r[10].s64 + 14272;
	// 824031E8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824031EC: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 824031F0: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 824031F4: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 824031F8: 7D1F4378  mr r31, r8
	ctx.r[31].u64 = ctx.r[8].u64;
	// 824031FC: 7D3B4B78  mr r27, r9
	ctx.r[27].u64 = ctx.r[9].u64;
	// 82403200: 48000671  bl 0x82403870
	ctx.lr = 0x82403204;
	sub_82403870(ctx, base);
	// 82403204: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82403208: 41800054  blt 0x8240325c
	if ctx.cr[0].lt {
	pc = 0x8240325C; continue 'dispatch;
	}
	// 8240320C: 57CB0739  rlwinm. r11, r30, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82403210: 40820008  bne 0x82403218
	if !ctx.cr[0].eq {
	pc = 0x82403218; continue 'dispatch;
	}
	// 82403214: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	pc = 0x82403218; continue 'dispatch;
            }
            0x82403218 => {
    //   block [0x82403218..0x82403238)
	// 82403218: 1D7D0078  mulli r11, r29, 0x78
	ctx.r[11].s32 = ((ctx.r[29].s32 as i64 * 120 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8240321C: 39400064  li r10, 0x64
	ctx.r[10].s64 = 100;
	// 82403220: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82403224: 7D6B5396  divwu r11, r11, r10
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[10].u32;
	// 82403228: 396B0003  addi r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 + 3;
	// 8240322C: 556B003A  rlwinm r11, r11, 0, 0, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82403230: 419A0008  beq cr6, 0x82403238
	if ctx.cr[6].eq {
	pc = 0x82403238; continue 'dispatch;
	}
	// 82403234: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82403238; continue 'dispatch;
            }
            0x82403238 => {
    //   block [0x82403238..0x82403248)
	// 82403238: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8240323C: 419A000C  beq cr6, 0x82403248
	if ctx.cr[6].eq {
	pc = 0x82403248; continue 'dispatch;
	}
	// 82403240: 39401000  li r10, 0x1000
	ctx.r[10].s64 = 4096;
	// 82403244: 915B0000  stw r10, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82403248; continue 'dispatch;
            }
            0x82403248 => {
    //   block [0x82403248..0x8240325C)
	// 82403248: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8240324C: 419A0010  beq cr6, 0x8240325c
	if ctx.cr[6].eq {
	pc = 0x8240325C; continue 'dispatch;
	}
	// 82403250: 7D6BD214  add r11, r11, r26
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82403254: 396B2E6C  addi r11, r11, 0x2e6c
	ctx.r[11].s64 = ctx.r[11].s64 + 11884;
	// 82403258: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x8240325C; continue 'dispatch;
            }
            0x8240325C => {
    //   block [0x8240325C..0x82403264)
	// 8240325C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82403260: 48131EA0  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82403268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82403268 size=228
    let mut pc: u32 = 0x82403268;
    'dispatch: loop {
        match pc {
            0x82403268 => {
    //   block [0x82403268..0x824032C0)
	// 82403268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240326C: 48131E35  bl 0x825350a0
	ctx.lr = 0x82403270;
	sub_82535080(ctx, base);
	// 82403270: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82403274: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82403278: 3C800005  lis r4, 5
	ctx.r[4].s64 = 327680;
	// 8240327C: 3BC61E20  addi r30, r6, 0x1e20
	ctx.r[30].s64 = ctx.r[6].s64 + 7712;
	// 82403280: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82403284: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82403288: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8240328C: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 82403290: 60848004  ori r4, r4, 0x8004
	ctx.r[4].u64 = ctx.r[4].u64 | 32772;
	// 82403294: 386000FC  li r3, 0xfc
	ctx.r[3].s64 = 252;
	// 82403298: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 8240329C: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 824032A0: 7D384B78  mr r24, r9
	ctx.r[24].u64 = ctx.r[9].u64;
	// 824032A4: 7D575378  mr r23, r10
	ctx.r[23].u64 = ctx.r[10].u64;
	// 824032A8: 3ADE104C  addi r22, r30, 0x104c
	ctx.r[22].s64 = ctx.r[30].s64 + 4172;
	// 824032AC: 4830A9D1  bl 0x8270dc7c
	ctx.lr = 0x824032B0;
	// extern call 0x8270DC7C  crate::xboxkrnl::XMsgInProcessCall
	crate::xboxkrnl::XMsgInProcessCall(ctx, base);
	// 824032B0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 824032B4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 824032B8: 41800008  blt 0x824032c0
	if ctx.cr[0].lt {
	pc = 0x824032C0; continue 'dispatch;
	}
	// 824032BC: 81410090  lwz r10, 0x90(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	pc = 0x824032C0; continue 'dispatch;
            }
            0x824032C0 => {
    //   block [0x824032C0..0x82403344)
	// 824032C0: 81610144  lwz r11, 0x144(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(324 as u32) ) } as u64;
	// 824032C4: 39001000  li r8, 0x1000
	ctx.r[8].s64 = 4096;
	// 824032C8: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 824032CC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 824032D0: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 824032D4: 92E10084  stw r23, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[23].u32 ) };
	// 824032D8: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 824032DC: 9301007C  stw r24, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[24].u32 ) };
	// 824032E0: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 824032E4: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 824032E8: 397F004C  addi r11, r31, 0x4c
	ctx.r[11].s64 = ctx.r[31].s64 + 76;
	// 824032EC: 7FF6C850  subf r31, r22, r25
	ctx.r[31].s64 = ctx.r[25].s64 - ctx.r[22].s64;
	// 824032F0: 91010074  stw r8, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[8].u32 ) };
	// 824032F4: 7FDE5A14  add r30, r30, r11
	ctx.r[30].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 824032F8: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 824032FC: 7D7FF214  add r11, r31, r30
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[30].u64;
	// 82403300: 38AA37C0  addi r5, r10, 0x37c0
	ctx.r[5].s64 = ctx.r[10].s64 + 14272;
	// 82403304: 8141015C  lwz r10, 0x15c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(348 as u32) ) } as u64;
	// 82403308: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 8240330C: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82403310: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82403314: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82403318: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8240331C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82403320: 48000721  bl 0x82403a40
	ctx.lr = 0x82403324;
	sub_82403A40(ctx, base);
	// 82403324: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82403328: 4180001C  blt 0x82403344
	if ctx.cr[0].lt {
	pc = 0x82403344; continue 'dispatch;
	}
	// 8240332C: 8161014C  lwz r11, 0x14c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(332 as u32) ) } as u64;
	// 82403330: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82403334: 81610154  lwz r11, 0x154(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(340 as u32) ) } as u64;
	// 82403338: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8240333C: 81610164  lwz r11, 0x164(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(356 as u32) ) } as u64;
	// 82403340: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x82403344; continue 'dispatch;
            }
            0x82403344 => {
    //   block [0x82403344..0x8240334C)
	// 82403344: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82403348: 48131DA8  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82403350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82403350 size=212
    let mut pc: u32 = 0x82403350;
    'dispatch: loop {
        match pc {
            0x82403350 => {
    //   block [0x82403350..0x8240339C)
	// 82403350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82403354: 48131D55  bl 0x825350a8
	ctx.lr = 0x82403358;
	sub_82535080(ctx, base);
	// 82403358: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240335C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82403360: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82403364: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82403368: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 8240336C: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	// 82403370: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82403374: 7CCB30F8  nor r11, r6, r6
	ctx.r[11].u64 = !(ctx.r[6].u64 | ctx.r[6].u64);
	// 82403378: 7D595378  mr r25, r10
	ctx.r[25].u64 = ctx.r[10].u64;
	// 8240337C: 2B040440  cmplwi cr6, r4, 0x440
	ctx.cr[6].compare_u32(ctx.r[4].u32, 1088 as u32, &mut ctx.xer);
	// 82403380: 5578F7FE  rlwinm r24, r11, 0x1e, 0x1f, 0x1f
	ctx.r[24].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 82403384: 40980038  bge cr6, 0x824033bc
	if !ctx.cr[6].lt {
	pc = 0x824033BC; continue 'dispatch;
	}
	// 82403388: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8240338C: 419A0010  beq cr6, 0x8240339c
	if ctx.cr[6].eq {
	pc = 0x8240339C; continue 'dispatch;
	}
	// 82403390: 3FE08007  lis r31, -0x7ff9
	ctx.r[31].s64 = -2147024896;
	// 82403394: 63FF007A  ori r31, r31, 0x7a
	ctx.r[31].u64 = ctx.r[31].u64 | 122;
	// 82403398: 48000080  b 0x82403418
	pc = 0x82403418; continue 'dispatch;
            }
            0x8240339C => {
    //   block [0x8240339C..0x824033BC)
	// 8240339C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824033A0: 38800440  li r4, 0x440
	ctx.r[4].s64 = 1088;
	// 824033A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824033A8: 4830A8F5  bl 0x8270dc9c
	ctx.lr = 0x824033AC;
	// extern call 0x8270DC9C  crate::xam::XamAlloc
	crate::xam::XamAlloc(ctx, base);
	// 824033AC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824033B0: 41800058  blt 0x82403408
	if ctx.cr[0].lt {
	pc = 0x82403408; continue 'dispatch;
	}
	// 824033B4: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824033B8: 48000008  b 0x824033c0
	pc = 0x824033C0; continue 'dispatch;
            }
            0x824033BC => {
    //   block [0x824033BC..0x824033C0)
	// 824033BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	pc = 0x824033C0; continue 'dispatch;
            }
            0x824033C0 => {
    //   block [0x824033C0..0x82403408)
	// 824033C0: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 824033C4: 81390000  lwz r9, 0(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 824033C8: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 824033CC: 388B37C0  addi r4, r11, 0x37c0
	ctx.r[4].s64 = ctx.r[11].s64 + 14272;
	// 824033D0: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 824033D4: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 824033D8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 824033DC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 824033E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824033E4: 4800073D  bl 0x82403b20
	ctx.lr = 0x824033E8;
	sub_82403B20(ctx, base);
	// 824033E8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824033EC: 4180001C  blt 0x82403408
	if ctx.cr[0].lt {
	pc = 0x82403408; continue 'dispatch;
	}
	// 824033F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824033F4: 4800103D  bl 0x82404430
	ctx.lr = 0x824033F8;
	sub_82404430(ctx, base);
	// 824033F8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824033FC: 4180000C  blt 0x82403408
	if ctx.cr[0].lt {
	pc = 0x82403408; continue 'dispatch;
	}
	// 82403400: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82403404: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82403408; continue 'dispatch;
            }
            0x82403408 => {
    //   block [0x82403408..0x82403418)
	// 82403408: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8240340C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82403410: 419A0008  beq cr6, 0x82403418
	if ctx.cr[6].eq {
	pc = 0x82403418; continue 'dispatch;
	}
	// 82403414: 4830A879  bl 0x8270dc8c
	ctx.lr = 0x82403418;
	// extern call 0x8270DC8C  crate::xam::XamFree
	crate::xam::XamFree(ctx, base);
	pc = 0x82403418; continue 'dispatch;
            }
            0x82403418 => {
    //   block [0x82403418..0x82403424)
	// 82403418: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8240341C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82403420: 48131CD8  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82403428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82403428 size=44
    let mut pc: u32 = 0x82403428;
    'dispatch: loop {
        match pc {
            0x82403428 => {
    //   block [0x82403428..0x82403454)
	// 82403428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240342C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82403430: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82403434: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82403438: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8240343C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82403440: 48001481  bl 0x824048c0
	ctx.lr = 0x82403444;
	sub_824048C0(ctx, base);
	// 82403444: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82403448: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8240344C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82403450: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82403458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82403458 size=88
    let mut pc: u32 = 0x82403458;
    'dispatch: loop {
        match pc {
            0x82403458 => {
    //   block [0x82403458..0x82403498)
	// 82403458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240345C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82403460: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82403464: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82403468: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240346C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82403470: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82403474: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82403478: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8240347C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82403480: 48001441  bl 0x824048c0
	ctx.lr = 0x82403484;
	sub_824048C0(ctx, base);
	// 82403484: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82403488: 41800010  blt 0x82403498
	if ctx.cr[0].lt {
	pc = 0x82403498; continue 'dispatch;
	}
	// 8240348C: 389E0002  addi r4, r30, 2
	ctx.r[4].s64 = ctx.r[30].s64 + 2;
	// 82403490: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82403494: 480013FD  bl 0x82404890
	ctx.lr = 0x82403498;
	sub_82404890(ctx, base);
	pc = 0x82403498; continue 'dispatch;
            }
            0x82403498 => {
    //   block [0x82403498..0x824034B0)
	// 82403498: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8240349C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824034A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824034A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824034A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824034AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824034B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824034B0 size=44
    let mut pc: u32 = 0x824034B0;
    'dispatch: loop {
        match pc {
            0x824034B0 => {
    //   block [0x824034B0..0x824034DC)
	// 824034B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824034B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824034B8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824034BC: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 824034C0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824034C4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 824034C8: 480013F9  bl 0x824048c0
	ctx.lr = 0x824034CC;
	sub_824048C0(ctx, base);
	// 824034CC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824034D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824034D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824034D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824034E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824034E0 size=80
    let mut pc: u32 = 0x824034E0;
    'dispatch: loop {
        match pc {
            0x824034E0 => {
    //   block [0x824034E0..0x82403528)
	// 824034E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824034E4: 48131BD9  bl 0x825350bc
	ctx.lr = 0x824034E8;
	sub_82535080(ctx, base);
	// 824034E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824034EC: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 824034F0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 824034F4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824034F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824034FC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82403500: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82403504: 480013BD  bl 0x824048c0
	ctx.lr = 0x82403508;
	sub_824048C0(ctx, base);
	// 82403508: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 8240350C: 4180001C  blt 0x82403528
	if ctx.cr[0].lt {
	pc = 0x82403528; continue 'dispatch;
	}
	// 82403510: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82403514: 556B0673  rlwinm. r11, r11, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82403518: 41820010  beq 0x82403528
	if ctx.cr[0].eq {
	pc = 0x82403528; continue 'dispatch;
	}
	// 8240351C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82403520: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82403524: 4800136D  bl 0x82404890
	ctx.lr = 0x82403528;
	sub_82404890(ctx, base);
	pc = 0x82403528; continue 'dispatch;
            }
            0x82403528 => {
    //   block [0x82403528..0x82403530)
	// 82403528: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8240352C: 48131BE0  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82403530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82403530 size=832
    let mut pc: u32 = 0x82403530;
    'dispatch: loop {
        match pc {
            0x82403530 => {
    //   block [0x82403530..0x82403584)
	// 82403530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82403534: 48131B7D  bl 0x825350b0
	ctx.lr = 0x82403538;
	sub_82535080(ctx, base);
	// 82403538: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240353C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82403540: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82403544: 2B1A0010  cmplwi cr6, r26, 0x10
	ctx.cr[6].compare_u32(ctx.r[26].u32, 16 as u32, &mut ctx.xer);
	// 82403548: 40980164  bge cr6, 0x824036ac
	if !ctx.cr[6].lt {
	pc = 0x824036AC; continue 'dispatch;
	}
	// 8240354C: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82403550: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82403554: 38810051  addi r4, r1, 0x51
	ctx.r[4].s64 = ctx.r[1].s64 + 81;
	// 82403558: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 8240355C: 48001365  bl 0x824048c0
	ctx.lr = 0x82403560;
	sub_824048C0(ctx, base);
	// 82403560: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82403564: 41800150  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	// 82403568: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 8240356C: 556BF7BE  rlwinm r11, r11, 0x1e, 0x1e, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 82403570: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82403574: 41980138  blt cr6, 0x824036ac
	if ctx.cr[6].lt {
	pc = 0x824036AC; continue 'dispatch;
	}
	// 82403578: 419A000C  beq cr6, 0x82403584
	if ctx.cr[6].eq {
	pc = 0x82403584; continue 'dispatch;
	}
	// 8240357C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82403580: 4098012C  bge cr6, 0x824036ac
	if !ctx.cr[6].lt {
	pc = 0x824036AC; continue 'dispatch;
	}
	pc = 0x82403584; continue 'dispatch;
            }
            0x82403584 => {
    //   block [0x82403584..0x824035C0)
	// 82403584: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82403588: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8240358C: 48001305  bl 0x82404890
	ctx.lr = 0x82403590;
	sub_82404890(ctx, base);
	// 82403590: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82403594: 41800120  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	// 82403598: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 8240359C: 556B0031  rlwinm. r11, r11, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824035A0: 41820020  beq 0x824035c0
	if ctx.cr[0].eq {
	pc = 0x824035C0; continue 'dispatch;
	}
	// 824035A4: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 824035A8: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 824035AC: 38810053  addi r4, r1, 0x53
	ctx.r[4].s64 = ctx.r[1].s64 + 83;
	// 824035B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824035B4: 4800130D  bl 0x824048c0
	ctx.lr = 0x824035B8;
	sub_824048C0(ctx, base);
	// 824035B8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 824035BC: 418000F8  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	pc = 0x824035C0; continue 'dispatch;
            }
            0x824035C0 => {
    //   block [0x824035C0..0x824035E0)
	// 824035C0: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 824035C4: 556B0673  rlwinm. r11, r11, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824035C8: 41820018  beq 0x824035e0
	if ctx.cr[0].eq {
	pc = 0x824035E0; continue 'dispatch;
	}
	// 824035CC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 824035D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824035D4: 480012BD  bl 0x82404890
	ctx.lr = 0x824035D8;
	sub_82404890(ctx, base);
	// 824035D8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 824035DC: 418000D8  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	pc = 0x824035E0; continue 'dispatch;
            }
            0x824035E0 => {
    //   block [0x824035E0..0x8240362C)
	// 824035E0: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 824035E4: 3B800002  li r28, 2
	ctx.r[28].s64 = 2;
	// 824035E8: 556B06B5  rlwinm. r11, r11, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824035EC: 41820040  beq 0x8240362c
	if ctx.cr[0].eq {
	pc = 0x8240362C; continue 'dispatch;
	}
	// 824035F0: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 824035F4: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 824035F8: 38810056  addi r4, r1, 0x56
	ctx.r[4].s64 = ctx.r[1].s64 + 86;
	// 824035FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82403600: 480012C1  bl 0x824048c0
	ctx.lr = 0x82403604;
	sub_824048C0(ctx, base);
	// 82403604: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82403608: 418000AC  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	// 8240360C: 89610056  lbz r11, 0x56(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 82403610: 556B0031  rlwinm. r11, r11, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82403614: 41820018  beq 0x8240362c
	if ctx.cr[0].eq {
	pc = 0x8240362C; continue 'dispatch;
	}
	// 82403618: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8240361C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82403620: 48001271  bl 0x82404890
	ctx.lr = 0x82403624;
	sub_82404890(ctx, base);
	// 82403624: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82403628: 4180008C  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	pc = 0x8240362C; continue 'dispatch;
            }
            0x8240362C => {
    //   block [0x8240362C..0x8240365C)
	// 8240362C: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82403630: 556B073A  rlwinm r11, r11, 0, 0x1c, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82403634: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 82403638: 409A0024  bne cr6, 0x8240365c
	if !ctx.cr[6].eq {
	pc = 0x8240365C; continue 'dispatch;
	}
	// 8240363C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82403640: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82403644: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82403648: 4BFFFE99  bl 0x824034e0
	ctx.lr = 0x8240364C;
	sub_824034E0(ctx, base);
	// 8240364C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82403650: 41800064  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	// 82403654: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82403658: 48000008  b 0x82403660
	pc = 0x82403660; continue 'dispatch;
            }
            0x8240365C => {
    //   block [0x8240365C..0x82403660)
	// 8240365C: A3A10058  lhz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	pc = 0x82403660; continue 'dispatch;
            }
            0x82403660 => {
    //   block [0x82403660..0x824036A8)
	// 82403660: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82403664: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82403668: 556B073A  rlwinm r11, r11, 0, 0x1c, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8240366C: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 82403670: 409A00D4  bne cr6, 0x82403744
	if !ctx.cr[6].eq {
	pc = 0x82403744; continue 'dispatch;
	}
	// 82403674: 89610059  lbz r11, 0x59(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 82403678: 57AA043E  clrlwi r10, r29, 0x10
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0x0000FFFFu64;
	// 8240367C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82403680: 4198003C  blt cr6, 0x824036bc
	if ctx.cr[6].lt {
	pc = 0x824036BC; continue 'dispatch;
	}
	// 82403684: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82403688: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 8240368C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82403690: 48001231  bl 0x824048c0
	ctx.lr = 0x82403694;
	sub_824048C0(ctx, base);
	// 82403694: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82403698: 4180001C  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	// 8240369C: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824036A0: 556B073A  rlwinm r11, r11, 0, 0x1c, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824036A4: 2B0B000C  cmplwi cr6, r11, 0xc
	ctx.cr[6].compare_u32(ctx.r[11].u32, 12 as u32, &mut ctx.xer);
	pc = 0x824036A8; continue 'dispatch;
            }
            0x824036A8 => {
    //   block [0x824036A8..0x824036AC)
	// 824036A8: 419A00F0  beq cr6, 0x82403798
	if ctx.cr[6].eq {
	pc = 0x82403798; continue 'dispatch;
	}
	pc = 0x824036AC; continue 'dispatch;
            }
            0x824036AC => {
    //   block [0x824036AC..0x824036B4)
	// 824036AC: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 824036B0: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	pc = 0x824036B4; continue 'dispatch;
            }
            0x824036B4 => {
    //   block [0x824036B4..0x824036BC)
	// 824036B4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 824036B8: 48131A48  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x824036BC => {
    //   block [0x824036BC..0x824036DC)
	// 824036BC: 38810052  addi r4, r1, 0x52
	ctx.r[4].s64 = ctx.r[1].s64 + 82;
	// 824036C0: 48001179  bl 0x82404838
	ctx.lr = 0x824036C4;
	sub_82404838(ctx, base);
	// 824036C4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 824036C8: 4180FFEC  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	// 824036CC: 89610052  lbz r11, 0x52(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 824036D0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 824036D4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 824036D8: 41820028  beq 0x82403700
	if ctx.cr[0].eq {
	pc = 0x82403700; continue 'dispatch;
	}
	pc = 0x824036DC; continue 'dispatch;
            }
            0x824036DC => {
    //   block [0x824036DC..0x82403700)
	// 824036DC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 824036E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824036E4: 480011AD  bl 0x82404890
	ctx.lr = 0x824036E8;
	sub_82404890(ctx, base);
	// 824036E8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 824036EC: 4180FFC8  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	// 824036F0: 89610052  lbz r11, 0x52(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 824036F4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 824036F8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824036FC: 4198FFE0  blt cr6, 0x824036dc
	if ctx.cr[6].lt {
	pc = 0x824036DC; continue 'dispatch;
	}
	pc = 0x82403700; continue 'dispatch;
            }
            0x82403700 => {
    //   block [0x82403700..0x82403744)
	// 82403700: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82403704: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82403708: 48001189  bl 0x82404890
	ctx.lr = 0x8240370C;
	sub_82404890(ctx, base);
	// 8240370C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82403710: 4180FFA4  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	// 82403714: A1610054  lhz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82403718: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8240371C: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82403720: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82403724: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82403728: 480011E9  bl 0x82404910
	ctx.lr = 0x8240372C;
	sub_82404910(ctx, base);
	// 8240372C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82403730: 4180FF84  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	// 82403734: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82403738: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8240373C: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82403740: 48000058  b 0x82403798
	pc = 0x82403798; continue 'dispatch;
            }
            0x82403744 => {
    //   block [0x82403744..0x82403790)
	// 82403744: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82403748: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8240374C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82403750: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 82403754: 4800116D  bl 0x824048c0
	ctx.lr = 0x82403758;
	sub_824048C0(ctx, base);
	// 82403758: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 8240375C: 4180FF58  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	// 82403760: 89410050  lbz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82403764: 554BF7BE  rlwinm r11, r10, 0x1e, 0x1e, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 82403768: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8240376C: 4198005C  blt cr6, 0x824037c8
	if ctx.cr[6].lt {
	pc = 0x824037C8; continue 'dispatch;
	}
	// 82403770: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82403774: 4098FF34  bge cr6, 0x824036a8
	if !ctx.cr[6].lt {
	pc = 0x824036A8; continue 'dispatch;
	}
	// 82403778: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8240377C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82403780: 48000D01  bl 0x82404480
	ctx.lr = 0x82403784;
	sub_82404480(ctx, base);
	// 82403784: 389A0001  addi r4, r26, 1
	ctx.r[4].s64 = ctx.r[26].s64 + 1;
	// 82403788: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8240378C: 4BFFFDA5  bl 0x82403530
	ctx.lr = 0x82403790;
	sub_82403530(ctx, base);
	pc = 0x82403790; continue 'dispatch;
            }
            0x82403790 => {
    //   block [0x82403790..0x82403798)
	// 82403790: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82403794: 4180FF20  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	pc = 0x82403798; continue 'dispatch;
            }
            0x82403798 => {
    //   block [0x82403798..0x824037B4)
	// 82403798: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 8240379C: 556B073A  rlwinm r11, r11, 0, 0x1c, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824037A0: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 824037A4: 409A0010  bne cr6, 0x824037b4
	if !ctx.cr[6].eq {
	pc = 0x824037B4; continue 'dispatch;
	}
	// 824037A8: 57AB043E  clrlwi r11, r29, 0x10
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x0000FFFFu64;
	// 824037AC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824037B0: 557D043E  clrlwi r29, r11, 0x10
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	pc = 0x824037B4; continue 'dispatch;
            }
            0x824037B4 => {
    //   block [0x824037B4..0x824037C8)
	// 824037B4: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824037B8: 556B073A  rlwinm r11, r11, 0, 0x1c, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824037BC: 2B0B000C  cmplwi cr6, r11, 0xc
	ctx.cr[6].compare_u32(ctx.r[11].u32, 12 as u32, &mut ctx.xer);
	// 824037C0: 409AFEA0  bne cr6, 0x82403660
	if !ctx.cr[6].eq {
	pc = 0x82403660; continue 'dispatch;
	}
	// 824037C4: 4BFFFEF0  b 0x824036b4
	pc = 0x824036B4; continue 'dispatch;
            }
            0x824037C8 => {
    //   block [0x824037C8..0x824037EC)
	// 824037C8: 554B0031  rlwinm. r11, r10, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824037CC: 41820020  beq 0x824037ec
	if ctx.cr[0].eq {
	pc = 0x824037EC; continue 'dispatch;
	}
	// 824037D0: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 824037D4: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 824037D8: 38810053  addi r4, r1, 0x53
	ctx.r[4].s64 = ctx.r[1].s64 + 83;
	// 824037DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824037E0: 480010E1  bl 0x824048c0
	ctx.lr = 0x824037E4;
	sub_824048C0(ctx, base);
	// 824037E4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 824037E8: 4180FECC  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	pc = 0x824037EC; continue 'dispatch;
            }
            0x824037EC => {
    //   block [0x824037EC..0x8240380C)
	// 824037EC: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824037F0: 556B0673  rlwinm. r11, r11, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824037F4: 41820018  beq 0x8240380c
	if ctx.cr[0].eq {
	pc = 0x8240380C; continue 'dispatch;
	}
	// 824037F8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 824037FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82403800: 48001091  bl 0x82404890
	ctx.lr = 0x82403804;
	sub_82404890(ctx, base);
	// 82403804: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82403808: 4180FEAC  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	pc = 0x8240380C; continue 'dispatch;
            }
            0x8240380C => {
    //   block [0x8240380C..0x82403854)
	// 8240380C: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82403810: 556B06B5  rlwinm. r11, r11, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82403814: 41820040  beq 0x82403854
	if ctx.cr[0].eq {
	pc = 0x82403854; continue 'dispatch;
	}
	// 82403818: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 8240381C: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 82403820: 38810056  addi r4, r1, 0x56
	ctx.r[4].s64 = ctx.r[1].s64 + 86;
	// 82403824: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82403828: 48001099  bl 0x824048c0
	ctx.lr = 0x8240382C;
	sub_824048C0(ctx, base);
	// 8240382C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82403830: 4180FE84  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	// 82403834: 89610056  lbz r11, 0x56(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 82403838: 556B0031  rlwinm. r11, r11, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8240383C: 41820018  beq 0x82403854
	if ctx.cr[0].eq {
	pc = 0x82403854; continue 'dispatch;
	}
	// 82403840: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82403844: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82403848: 48001049  bl 0x82404890
	ctx.lr = 0x8240384C;
	sub_82404890(ctx, base);
	// 8240384C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82403850: 4180FE64  blt 0x824036b4
	if ctx.cr[0].lt {
	pc = 0x824036B4; continue 'dispatch;
	}
	pc = 0x82403854; continue 'dispatch;
            }
            0x82403854 => {
    //   block [0x82403854..0x82403870)
	// 82403854: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82403858: 556B06F7  rlwinm. r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8240385C: 4182FF3C  beq 0x82403798
	if ctx.cr[0].eq {
	pc = 0x82403798; continue 'dispatch;
	}
	// 82403860: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82403864: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82403868: 4BFFFBF1  bl 0x82403458
	ctx.lr = 0x8240386C;
	sub_82403458(ctx, base);
	// 8240386C: 4BFFFF24  b 0x82403790
	pc = 0x82403790; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82403870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82403870 size=88
    let mut pc: u32 = 0x82403870;
    'dispatch: loop {
        match pc {
            0x82403870 => {
    //   block [0x82403870..0x8240389C)
	// 82403870: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82403874: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82403878: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240387C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82403880: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82403884: A14B0028  lhz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82403888: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8240388C: 41980010  blt cr6, 0x8240389c
	if ctx.cr[6].lt {
	pc = 0x8240389C; continue 'dispatch;
	}
	// 82403890: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82403894: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 82403898: 48000020  b 0x824038b8
	pc = 0x824038B8; continue 'dispatch;
            }
            0x8240389C => {
    //   block [0x8240389C..0x824038B8)
	// 8240389C: A12B002A  lhz r9, 0x2a(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(42 as u32) ) } as u64;
	// 824038A0: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 824038A4: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 824038A8: 7D6921D6  mullw r11, r9, r4
	ctx.r[11].s32 = ((ctx.r[9].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 824038AC: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824038B0: 481312A1  bl 0x82534b50
	ctx.lr = 0x824038B4;
	sub_82534B50(ctx, base);
	// 824038B4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x824038B8; continue 'dispatch;
            }
            0x824038B8 => {
    //   block [0x824038B8..0x824038C8)
	// 824038B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824038BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824038C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824038C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824038C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824038C8 size=28
    let mut pc: u32 = 0x824038C8;
    'dispatch: loop {
        match pc {
            0x824038C8 => {
    //   block [0x824038C8..0x824038E4)
	// 824038C8: A1430018  lhz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 824038CC: 548B043E  clrlwi r11, r4, 0x10
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x0000FFFFu64;
	// 824038D0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 824038D4: 40990010  ble cr6, 0x824038e4
	if !ctx.cr[6].gt {
		crate::recompiler::externs::call(ctx, base, 0x824038E4);
		return;
	}
	// 824038D8: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 824038DC: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 824038E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82403900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82403900 size=196
    let mut pc: u32 = 0x82403900;
    'dispatch: loop {
        match pc {
            0x82403900 => {
    //   block [0x82403900..0x8240393C)
	// 82403900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82403904: 481317B9  bl 0x825350bc
	ctx.lr = 0x82403908;
	sub_82535080(ctx, base);
	// 82403908: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240390C: 38A0002C  li r5, 0x2c
	ctx.r[5].s64 = 44;
	// 82403910: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82403914: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82403918: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8240391C: 48131235  bl 0x82534b50
	ctx.lr = 0x82403920;
	sub_82534B50(ctx, base);
	// 82403920: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82403924: 393E002C  addi r9, r30, 0x2c
	ctx.r[9].s64 = ctx.r[30].s64 + 44;
	// 82403928: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8240392C: 41820010  beq 0x8240393c
	if ctx.cr[0].eq {
	pc = 0x8240393C; continue 'dispatch;
	}
	// 82403930: 3FA08000  lis r29, -0x8000
	ctx.r[29].s64 = -2147483648;
	// 82403934: 63BD4005  ori r29, r29, 0x4005
	ctx.r[29].u64 = ctx.r[29].u64 | 16389;
	// 82403938: 48000080  b 0x824039b8
	pc = 0x824039B8; continue 'dispatch;
            }
            0x8240393C => {
    //   block [0x8240393C..0x82403950)
	// 8240393C: A0DF0026  lhz r6, 0x26(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(38 as u32) ) } as u64;
	// 82403940: 28060000  cmplwi r6, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82403944: 4182000C  beq 0x82403950
	if ctx.cr[0].eq {
	pc = 0x82403950; continue 'dispatch;
	}
	// 82403948: 913F003C  stw r9, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[9].u32 ) };
	// 8240394C: 7D264A14  add r9, r6, r9
	ctx.r[9].u64 = ctx.r[6].u64 + ctx.r[9].u64;
	pc = 0x82403950; continue 'dispatch;
            }
            0x82403950 => {
    //   block [0x82403950..0x824039B8)
	// 82403950: A15F001A  lhz r10, 0x1a(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(26 as u32) ) } as u64;
	// 82403954: A11F0018  lhz r8, 0x18(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82403958: A17F0028  lhz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 8240395C: 7CEA41D6  mullw r7, r10, r8
	ctx.r[7].s32 = ((ctx.r[10].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[7].s64 = ctx.r[7].s32 as i64;
	// 82403960: A15F0020  lhz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82403964: 5548083E  rotlwi r8, r10, 1
	ctx.r[8].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 82403968: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8240396C: 913F002C  stw r9, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 82403970: A0BF002A  lhz r5, 0x2a(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(42 as u32) ) } as u64;
	// 82403974: 556A103E  rotlwi r10, r11, 2
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 82403978: 7D6559D6  mullw r11, r5, r11
	ctx.r[11].s32 = ((ctx.r[5].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8240397C: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82403980: 7D4A2050  subf r10, r10, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[10].s64;
	// 82403984: 7D465050  subf r10, r6, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[6].s64;
	// 82403988: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8240398C: 913F0030  stw r9, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[9].u32 ) };
	// 82403990: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82403994: 394AFFD4  addi r10, r10, -0x2c
	ctx.r[10].s64 = ctx.r[10].s64 + -44;
	// 82403998: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 8240399C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 824039A0: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 824039A4: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 824039A8: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 824039AC: 7D485A14  add r10, r8, r11
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 824039B0: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 824039B4: 915F0048  stw r10, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[10].u32 ) };
	pc = 0x824039B8; continue 'dispatch;
            }
            0x824039B8 => {
    //   block [0x824039B8..0x824039C4)
	// 824039B8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 824039BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824039C0: 4813174C  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824039C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824039C8 size=120
    let mut pc: u32 = 0x824039C8;
    'dispatch: loop {
        match pc {
            0x824039C8 => {
    //   block [0x824039C8..0x82403A14)
	// 824039C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824039CC: 481316ED  bl 0x825350b8
	ctx.lr = 0x824039D0;
	sub_82535080(ctx, base);
	// 824039D0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824039D4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824039D8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 824039DC: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 824039E0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824039E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824039E8: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 824039EC: 93FC0014  stw r31, 0x14(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	// 824039F0: 4BFFFE81  bl 0x82403870
	ctx.lr = 0x824039F4;
	sub_82403870(ctx, base);
	// 824039F4: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 824039F8: 4180003C  blt 0x82403a34
	if ctx.cr[0].lt {
	pc = 0x82403A34; continue 'dispatch;
	}
	// 824039FC: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82403A00: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82403A04: 419A0010  beq cr6, 0x82403a14
	if ctx.cr[6].eq {
	pc = 0x82403A14; continue 'dispatch;
	}
	// 82403A08: A0C10050  lhz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82403A0C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82403A10: 4800000C  b 0x82403a1c
	pc = 0x82403A1C; continue 'dispatch;
            }
            0x82403A14 => {
    //   block [0x82403A14..0x82403A1C)
	// 82403A14: A0C10052  lhz r6, 0x52(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82403A18: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	pc = 0x82403A1C; continue 'dispatch;
            }
            0x82403A1C => {
    //   block [0x82403A1C..0x82403A34)
	// 82403A1C: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82403A20: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82403A24: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82403A28: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82403A2C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82403A30: 48000A31  bl 0x82404460
	ctx.lr = 0x82403A34;
	sub_82404460(ctx, base);
	pc = 0x82403A34; continue 'dispatch;
            }
            0x82403A34 => {
    //   block [0x82403A34..0x82403A40)
	// 82403A34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82403A38: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82403A3C: 481316CC  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82403A40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82403A40 size=224
    let mut pc: u32 = 0x82403A40;
    'dispatch: loop {
        match pc {
            0x82403A40 => {
    //   block [0x82403A40..0x82403A84)
	// 82403A40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82403A44: 48131665  bl 0x825350a8
	ctx.lr = 0x82403A48;
	sub_82535080(ctx, base);
	// 82403A48: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82403A4C: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 82403A50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82403A54: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82403A58: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82403A5C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82403A60: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 82403A64: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 82403A68: 7D585378  mr r24, r10
	ctx.r[24].u64 = ctx.r[10].u64;
	// 82403A6C: 57CB0673  rlwinm. r11, r30, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82403A70: 41820014  beq 0x82403a84
	if ctx.cr[0].eq {
	pc = 0x82403A84; continue 'dispatch;
	}
	// 82403A74: 48309DE9  bl 0x8270d85c
	ctx.lr = 0x82403A78;
	// extern call 0x8270D85C  crate::xboxkrnl::KeGetCurrentProcessType
	crate::xboxkrnl::KeGetCurrentProcessType(ctx, base);
	// 82403A78: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82403A7C: 409A0008  bne cr6, 0x82403a84
	if !ctx.cr[6].eq {
	pc = 0x82403A84; continue 'dispatch;
	}
	// 82403A80: 63DE0010  ori r30, r30, 0x10
	ctx.r[30].u64 = ctx.r[30].u64 | 16;
	pc = 0x82403A84; continue 'dispatch;
            }
            0x82403A84 => {
    //   block [0x82403A84..0x82403B08)
	// 82403A84: 816100FC  lwz r11, 0xfc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(252 as u32) ) } as u64;
	// 82403A88: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82403A8C: 8061011C  lwz r3, 0x11c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(284 as u32) ) } as u64;
	// 82403A90: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82403A94: 81210104  lwz r9, 0x104(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82403A98: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82403A9C: 810100F4  lwz r8, 0xf4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82403AA0: 80A10114  lwz r5, 0x114(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	// 82403AA4: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82403AA8: 81610124  lwz r11, 0x124(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(292 as u32) ) } as u64;
	// 82403AAC: 907F002C  stw r3, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[3].u32 ) };
	// 82403AB0: 387F0034  addi r3, r31, 0x34
	ctx.r[3].s64 = ctx.r[31].s64 + 52;
	// 82403AB4: 8081010C  lwz r4, 0x10c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) } as u64;
	// 82403AB8: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82403ABC: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82403AC0: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 82403AC4: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82403AC8: 935F0010  stw r26, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[26].u32 ) };
	// 82403ACC: 933F0014  stw r25, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[25].u32 ) };
	// 82403AD0: 915F001C  stw r10, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82403AD4: 913F0020  stw r9, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 82403AD8: 931F0024  stw r24, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[24].u32 ) };
	// 82403ADC: 911F0028  stw r8, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[8].u32 ) };
	// 82403AE0: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82403AE4: 4800097D  bl 0x82404460
	ctx.lr = 0x82403AE8;
	sub_82404460(ctx, base);
	// 82403AE8: 8161012C  lwz r11, 0x12c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(300 as u32) ) } as u64;
	// 82403AEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82403AF0: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82403AF4: 419A0020  beq cr6, 0x82403b14
	if ctx.cr[6].eq {
	pc = 0x82403B14; continue 'dispatch;
	}
	// 82403AF8: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82403AFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82403B00: 41820008  beq 0x82403b08
	if ctx.cr[0].eq {
	pc = 0x82403B08; continue 'dispatch;
	}
	// 82403B04: 4BFBD93D  bl 0x823c1440
	ctx.lr = 0x82403B08;
	sub_823C1440(ctx, base);
	pc = 0x82403B08; continue 'dispatch;
            }
            0x82403B08 => {
    //   block [0x82403B08..0x82403B14)
	// 82403B08: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82403B0C: 394003E5  li r10, 0x3e5
	ctx.r[10].s64 = 997;
	// 82403B10: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82403B14; continue 'dispatch;
            }
            0x82403B14 => {
    //   block [0x82403B14..0x82403B20)
	// 82403B14: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82403B18: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82403B1C: 481315DC  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82403B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82403B20 size=192
    let mut pc: u32 = 0x82403B20;
    'dispatch: loop {
        match pc {
            0x82403B20 => {
    //   block [0x82403B20..0x82403B94)
	// 82403B20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82403B24: 48131589  bl 0x825350ac
	ctx.lr = 0x82403B28;
	sub_82535080(ctx, base);
	// 82403B28: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82403B2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82403B30: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82403B34: 3BDF001C  addi r30, r31, 0x1c
	ctx.r[30].s64 = ctx.r[31].s64 + 28;
	// 82403B38: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82403B3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82403B40: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82403B44: 909F0000  stw r4, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82403B48: 7D3D4B78  mr r29, r9
	ctx.r[29].u64 = ctx.r[9].u64;
	// 82403B4C: 90FF0004  stw r7, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82403B50: 7D5A5378  mr r26, r10
	ctx.r[26].u64 = ctx.r[10].u64;
	// 82403B54: 4BFFFE75  bl 0x824039c8
	ctx.lr = 0x82403B58;
	sub_824039C8(ctx, base);
	// 82403B58: 7C791B79  or. r25, r3, r3
	ctx.r[25].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 82403B5C: 40800038  bge 0x82403b94
	if !ctx.cr[0].lt {
	pc = 0x82403B94; continue 'dispatch;
	}
	// 82403B60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82403B64: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82403B68: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82403B6C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82403B70: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82403B74: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82403B78: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82403B7C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82403B80: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82403B84: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82403B88: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82403B8C: 917F0438  stw r11, 0x438(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1080 as u32), ctx.r[11].u32 ) };
	// 82403B90: 48000044  b 0x82403bd4
	pc = 0x82403BD4; continue 'dispatch;
            }
            0x82403B94 => {
    //   block [0x82403B94..0x82403BBC)
	// 82403B94: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82403B98: 939F0438  stw r28, 0x438(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1080 as u32), ctx.r[28].u32 ) };
	// 82403B9C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82403BA0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82403BA4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82403BA8: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82403BAC: 480008B5  bl 0x82404460
	ctx.lr = 0x82403BB0;
	sub_82404460(ctx, base);
	// 82403BB0: 395F0038  addi r10, r31, 0x38
	ctx.r[10].s64 = ctx.r[31].s64 + 56;
	// 82403BB4: 39200040  li r9, 0x40
	ctx.r[9].s64 = 64;
	// 82403BB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82403BBC; continue 'dispatch;
            }
            0x82403BBC => {
    //   block [0x82403BBC..0x82403BD4)
	// 82403BBC: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82403BC0: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82403BC4: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82403BC8: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82403BCC: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 82403BD0: 4082FFEC  bne 0x82403bbc
	if !ctx.cr[0].eq {
	pc = 0x82403BBC; continue 'dispatch;
	}
	pc = 0x82403BD4; continue 'dispatch;
            }
            0x82403BD4 => {
    //   block [0x82403BD4..0x82403BE0)
	// 82403BD4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82403BD8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82403BDC: 48131520  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82403BE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82403BE0 size=136
    let mut pc: u32 = 0x82403BE0;
    'dispatch: loop {
        match pc {
            0x82403BE0 => {
    //   block [0x82403BE0..0x82403C28)
	// 82403BE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82403BE4: 481314D9  bl 0x825350bc
	ctx.lr = 0x82403BE8;
	sub_82535080(ctx, base);
	// 82403BE8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82403BEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82403BF0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82403BF4: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82403BF8: 2B040001  cmplwi cr6, r4, 1
	ctx.cr[6].compare_u32(ctx.r[4].u32, 1 as u32, &mut ctx.xer);
	// 82403BFC: 4199005C  bgt cr6, 0x82403c58
	if ctx.cr[6].gt {
	pc = 0x82403C58; continue 'dispatch;
	}
	// 82403C00: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82403C04: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 82403C08: 4BFFF821  bl 0x82403428
	ctx.lr = 0x82403C0C;
	sub_82403428(ctx, base);
	// 82403C0C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82403C10: 41800050  blt 0x82403c60
	if ctx.cr[0].lt {
	pc = 0x82403C60; continue 'dispatch;
	}
	// 82403C14: 89410050  lbz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82403C18: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82403C1C: 419A000C  beq cr6, 0x82403c28
	if ctx.cr[6].eq {
	pc = 0x82403C28; continue 'dispatch;
	}
	// 82403C20: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82403C24: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82403C28; continue 'dispatch;
            }
            0x82403C28 => {
    //   block [0x82403C28..0x82403C48)
	// 82403C28: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82403C2C: 554A06FE  clrlwi r10, r10, 0x1b
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82403C30: 812B0200  lwz r9, 0x200(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(512 as u32) ) } as u64;
	// 82403C34: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82403C38: 40980010  bge cr6, 0x82403c48
	if !ctx.cr[6].lt {
	pc = 0x82403C48; continue 'dispatch;
	}
	// 82403C3C: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82403C40: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82403C44: 48000008  b 0x82403c4c
	pc = 0x82403C4C; continue 'dispatch;
            }
            0x82403C48 => {
    //   block [0x82403C48..0x82403C4C)
	// 82403C48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82403C4C; continue 'dispatch;
            }
            0x82403C4C => {
    //   block [0x82403C4C..0x82403C58)
	// 82403C4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82403C50: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82403C54: 409A000C  bne cr6, 0x82403c60
	if !ctx.cr[6].eq {
	pc = 0x82403C60; continue 'dispatch;
	}
	pc = 0x82403C58; continue 'dispatch;
            }
            0x82403C58 => {
    //   block [0x82403C58..0x82403C60)
	// 82403C58: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82403C5C: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	pc = 0x82403C60; continue 'dispatch;
            }
            0x82403C60 => {
    //   block [0x82403C60..0x82403C68)
	// 82403C60: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82403C64: 481314A8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82403C68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82403C68 size=1992
    let mut pc: u32 = 0x82403C68;
    'dispatch: loop {
        match pc {
            0x82403C68 => {
    //   block [0x82403C68..0x82403CA8)
	// 82403C68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82403C6C: 48131415  bl 0x82535080
	ctx.lr = 0x82403C70;
	sub_82535080(ctx, base);
	// 82403C70: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82403C74: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82403C78: 39C00000  li r14, 0
	ctx.r[14].s64 = 0;
	// 82403C7C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82403C80: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82403C84: 2B1C0010  cmplwi cr6, r28, 0x10
	ctx.cr[6].compare_u32(ctx.r[28].u32, 16 as u32, &mut ctx.xer);
	// 82403C88: 9381014C  stw r28, 0x14c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(332 as u32), ctx.r[28].u32 ) };
	// 82403C8C: B1C1005A  sth r14, 0x5a(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[14].u16 ) };
	// 82403C90: 93A10154  stw r29, 0x154(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(340 as u32), ctx.r[29].u32 ) };
	// 82403C94: 91C10078  stw r14, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[14].u32 ) };
	// 82403C98: 41980010  blt cr6, 0x82403ca8
	if ctx.cr[6].lt {
	pc = 0x82403CA8; continue 'dispatch;
	}
	// 82403C9C: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82403CA0: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 82403CA4: 48000250  b 0x82403ef4
	pc = 0x82403EF4; continue 'dispatch;
            }
            0x82403CA8 => {
    //   block [0x82403CA8..0x82403CB8)
	// 82403CA8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82403CAC: 419A000C  beq cr6, 0x82403cb8
	if ctx.cr[6].eq {
	pc = 0x82403CB8; continue 'dispatch;
	}
	// 82403CB0: 829D0000  lwz r20, 0(r29)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82403CB4: 48000008  b 0x82403cbc
	pc = 0x82403CBC; continue 'dispatch;
            }
            0x82403CB8 => {
    //   block [0x82403CB8..0x82403CBC)
	// 82403CB8: 7DD47378  mr r20, r14
	ctx.r[20].u64 = ctx.r[14].u64;
	pc = 0x82403CBC; continue 'dispatch;
            }
            0x82403CBC => {
    //   block [0x82403CBC..0x82403D00)
	// 82403CBC: 817B0028  lwz r11, 0x28(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 82403CC0: 3AFB001C  addi r23, r27, 0x1c
	ctx.r[23].s64 = ctx.r[27].s64 + 28;
	// 82403CC4: 38810051  addi r4, r1, 0x51
	ctx.r[4].s64 = ctx.r[1].s64 + 81;
	// 82403CC8: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82403CCC: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82403CD0: 4BFFF759  bl 0x82403428
	ctx.lr = 0x82403CD4;
	sub_82403428(ctx, base);
	// 82403CD4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82403CD8: 41800218  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82403CDC: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82403CE0: 556BF7BE  rlwinm r11, r11, 0x1e, 0x1e, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 82403CE4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82403CE8: 41980200  blt cr6, 0x82403ee8
	if ctx.cr[6].lt {
	pc = 0x82403EE8; continue 'dispatch;
	}
	// 82403CEC: 419A0014  beq cr6, 0x82403d00
	if ctx.cr[6].eq {
	pc = 0x82403D00; continue 'dispatch;
	}
	// 82403CF0: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82403CF4: 409801F4  bge cr6, 0x82403ee8
	if !ctx.cr[6].lt {
	pc = 0x82403EE8; continue 'dispatch;
	}
	// 82403CF8: 3881005A  addi r4, r1, 0x5a
	ctx.r[4].s64 = ctx.r[1].s64 + 90;
	// 82403CFC: 48000008  b 0x82403d04
	pc = 0x82403D04; continue 'dispatch;
            }
            0x82403D00 => {
    //   block [0x82403D00..0x82403D04)
	// 82403D00: 38810056  addi r4, r1, 0x56
	ctx.r[4].s64 = ctx.r[1].s64 + 86;
	pc = 0x82403D04; continue 'dispatch;
            }
            0x82403D04 => {
    //   block [0x82403D04..0x82403D60)
	// 82403D04: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82403D08: 48000B89  bl 0x82404890
	ctx.lr = 0x82403D0C;
	sub_82404890(ctx, base);
	// 82403D0C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82403D10: 418001E0  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82403D14: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82403D18: 39E00004  li r15, 4
	ctx.r[15].s64 = 4;
	// 82403D1C: 556B0031  rlwinm. r11, r11, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82403D20: 41820040  beq 0x82403d60
	if ctx.cr[0].eq {
	pc = 0x82403D60; continue 'dispatch;
	}
	// 82403D24: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82403D28: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 82403D2C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82403D30: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82403D34: 4BFFFEAD  bl 0x82403be0
	ctx.lr = 0x82403D38;
	sub_82403BE0(ctx, base);
	// 82403D38: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82403D3C: 418001B4  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82403D40: 815B0014  lwz r10, 0x14(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 82403D44: 813B0008  lwz r9, 8(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82403D48: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82403D4C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82403D50: 794A0020  clrldi r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 82403D54: EA8B0008  ld r20, 8(r11)
	ctx.r[20].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82403D58: 91EB0000  stw r15, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[15].u32 ) };
	// 82403D5C: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	pc = 0x82403D60; continue 'dispatch;
            }
            0x82403D60 => {
    //   block [0x82403D60..0x82403D80)
	// 82403D60: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82403D64: 556B0673  rlwinm. r11, r11, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82403D68: 41820018  beq 0x82403d80
	if ctx.cr[0].eq {
	pc = 0x82403D80; continue 'dispatch;
	}
	// 82403D6C: 38810062  addi r4, r1, 0x62
	ctx.r[4].s64 = ctx.r[1].s64 + 98;
	// 82403D70: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82403D74: 48000B1D  bl 0x82404890
	ctx.lr = 0x82403D78;
	sub_82404890(ctx, base);
	// 82403D78: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82403D7C: 41800174  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	pc = 0x82403D80; continue 'dispatch;
            }
            0x82403D80 => {
    //   block [0x82403D80..0x82403DB8)
	// 82403D80: 88810051  lbz r4, 0x51(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82403D84: 3A400001  li r18, 1
	ctx.r[18].s64 = 1;
	// 82403D88: 548B06B5  rlwinm. r11, r4, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82403D8C: 4182002C  beq 0x82403db8
	if ctx.cr[0].eq {
	pc = 0x82403DB8; continue 'dispatch;
	}
	// 82403D90: 817B0438  lwz r11, 0x438(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1080 as u32) ) } as u64;
	// 82403D94: 38E10074  addi r7, r1, 0x74
	ctx.r[7].s64 = ctx.r[1].s64 + 116;
	// 82403D98: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82403D9C: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 82403DA0: 387B0038  addi r3, r27, 0x38
	ctx.r[3].s64 = ctx.r[27].s64 + 56;
	// 82403DA4: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82403DA8: 48000CA1  bl 0x82404a48
	ctx.lr = 0x82403DAC;
	sub_82404A48(ctx, base);
	// 82403DAC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82403DB0: 41800140  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82403DB4: 48000008  b 0x82403dbc
	pc = 0x82403DBC; continue 'dispatch;
            }
            0x82403DB8 => {
    //   block [0x82403DB8..0x82403DBC)
	// 82403DB8: 92410074  stw r18, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[18].u32 ) };
	pc = 0x82403DBC; continue 'dispatch;
            }
            0x82403DBC => {
    //   block [0x82403DBC..0x82403E3C)
	// 82403DBC: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82403DC0: 7DD17378  mr r17, r14
	ctx.r[17].u64 = ctx.r[14].u64;
	// 82403DC4: 556B073A  rlwinm r11, r11, 0, 0x1c, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82403DC8: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 82403DCC: 409A008C  bne cr6, 0x82403e58
	if !ctx.cr[6].eq {
	pc = 0x82403E58; continue 'dispatch;
	}
	// 82403DD0: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82403DD4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82403DD8: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82403DDC: 4BFFF705  bl 0x824034e0
	ctx.lr = 0x82403DE0;
	sub_824034E0(ctx, base);
	// 82403DE0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82403DE4: 4180010C  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82403DE8: 89610054  lbz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82403DEC: 3BDB0038  addi r30, r27, 0x38
	ctx.r[30].s64 = ctx.r[27].s64 + 56;
	// 82403DF0: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82403DF4: 556406BE  clrlwi r4, r11, 0x1a
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82403DF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82403DFC: 48000B9D  bl 0x82404998
	ctx.lr = 0x82403E00;
	sub_82404998(ctx, base);
	// 82403E00: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82403E04: 418000EC  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82403E08: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82403E0C: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82403E10: EA0B0008  ld r16, 8(r11)
	ctx.r[16].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82403E14: 554A0673  rlwinm. r10, r10, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82403E18: 41820024  beq 0x82403e3c
	if ctx.cr[0].eq {
	pc = 0x82403E3C; continue 'dispatch;
	}
	// 82403E1C: 38A1006C  addi r5, r1, 0x6c
	ctx.r[5].s64 = ctx.r[1].s64 + 108;
	// 82403E20: A081005C  lhz r4, 0x5c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82403E24: 807B0030  lwz r3, 0x30(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(48 as u32) ) } as u64;
	// 82403E28: 4BFFFAA1  bl 0x824038c8
	ctx.lr = 0x82403E2C;
	sub_824038C8(ctx, base);
	// 82403E2C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82403E30: 418000C0  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82403E34: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82403E38: 7D708038  and r16, r11, r16
	ctx.r[16].u64 = ctx.r[11].u64 & ctx.r[16].u64;
	pc = 0x82403E3C; continue 'dispatch;
            }
            0x82403E3C => {
    //   block [0x82403E3C..0x82403E58)
	// 82403E3C: 89610054  lbz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82403E40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82403E44: 556406BE  clrlwi r4, r11, 0x1a
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82403E48: 48000BA1  bl 0x824049e8
	ctx.lr = 0x82403E4C;
	sub_824049E8(ctx, base);
	// 82403E4C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82403E50: 4080000C  bge 0x82403e5c
	if !ctx.cr[0].lt {
	pc = 0x82403E5C; continue 'dispatch;
	}
	// 82403E54: 4800009C  b 0x82403ef0
	pc = 0x82403EF0; continue 'dispatch;
            }
            0x82403E58 => {
    //   block [0x82403E58..0x82403E5C)
	// 82403E58: 82010084  lwz r16, 0x84(r1)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	pc = 0x82403E5C; continue 'dispatch;
            }
            0x82403E5C => {
    //   block [0x82403E5C..0x82403E70)
	// 82403E5C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82403E60: 827B0028  lwz r19, 0x28(r27)
	ctx.r[19].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 82403E64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82403E68: 419A0568  beq cr6, 0x824043d0
	if ctx.cr[6].eq {
	pc = 0x824043D0; continue 'dispatch;
	}
	// 82403E6C: EB010088  ld r24, 0x88(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	pc = 0x82403E70; continue 'dispatch;
            }
            0x82403E70 => {
    //   block [0x82403E70..0x82403E88)
	// 82403E70: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82403E74: 7DD67378  mr r22, r14
	ctx.r[22].u64 = ctx.r[14].u64;
	// 82403E78: 7DD57378  mr r21, r14
	ctx.r[21].u64 = ctx.r[14].u64;
	// 82403E7C: 716B00F3  andi. r11, r11, 0xf3
	ctx.r[11].u64 = ctx.r[11].u64 & 243;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82403E80: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82403E84: 48000008  b 0x82403e8c
	pc = 0x82403E8C; continue 'dispatch;
            }
            0x82403E88 => {
    //   block [0x82403E88..0x82403E8C)
	// 82403E88: 8381014C  lwz r28, 0x14c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(332 as u32) ) } as u64;
	pc = 0x82403E8C; continue 'dispatch;
            }
            0x82403E8C => {
    //   block [0x82403E8C..0x82403EE8)
	// 82403E8C: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82403E90: 556B073A  rlwinm r11, r11, 0, 0x1c, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82403E94: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 82403E98: 409A0114  bne cr6, 0x82403fac
	if !ctx.cr[6].eq {
	pc = 0x82403FAC; continue 'dispatch;
	}
	// 82403E9C: 89610055  lbz r11, 0x55(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(85 as u32) ) } as u64;
	// 82403EA0: 56CA043E  clrlwi r10, r22, 0x10
	ctx.r[10].u64 = ctx.r[22].u32 as u64 & 0x0000FFFFu64;
	// 82403EA4: 7DDD7378  mr r29, r14
	ctx.r[29].u64 = ctx.r[14].u64;
	// 82403EA8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82403EAC: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82403EB0: 4198004C  blt cr6, 0x82403efc
	if ctx.cr[6].lt {
	pc = 0x82403EFC; continue 'dispatch;
	}
	// 82403EB4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82403EB8: 4BFFF571  bl 0x82403428
	ctx.lr = 0x82403EBC;
	sub_82403428(ctx, base);
	// 82403EBC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82403EC0: 41800030  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82403EC4: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82403EC8: 556B073A  rlwinm r11, r11, 0, 0x1c, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82403ECC: 2B0B000C  cmplwi cr6, r11, 0xc
	ctx.cr[6].compare_u32(ctx.r[11].u32, 12 as u32, &mut ctx.xer);
	// 82403ED0: 409A0018  bne cr6, 0x82403ee8
	if !ctx.cr[6].eq {
	pc = 0x82403EE8; continue 'dispatch;
	}
	// 82403ED4: 2F150000  cmpwi cr6, r21, 0
	ctx.cr[6].compare_i32(ctx.r[21].s32, 0, &mut ctx.xer);
	// 82403ED8: 409A0498  bne cr6, 0x82404370
	if !ctx.cr[6].eq {
	pc = 0x82404370; continue 'dispatch;
	}
	// 82403EDC: 89610054  lbz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82403EE0: 556B0031  rlwinm. r11, r11, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82403EE4: 4182048C  beq 0x82404370
	if ctx.cr[0].eq {
	pc = 0x82404370; continue 'dispatch;
	}
	pc = 0x82403EE8; continue 'dispatch;
            }
            0x82403EE8 => {
    //   block [0x82403EE8..0x82403EF0)
	// 82403EE8: 3FE08000  lis r31, -0x8000
	ctx.r[31].s64 = -2147483648;
	// 82403EEC: 63FF4005  ori r31, r31, 0x4005
	ctx.r[31].u64 = ctx.r[31].u64 | 16389;
	pc = 0x82403EF0; continue 'dispatch;
            }
            0x82403EF0 => {
    //   block [0x82403EF0..0x82403EF4)
	// 82403EF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82403EF4; continue 'dispatch;
            }
            0x82403EF4 => {
    //   block [0x82403EF4..0x82403EFC)
	// 82403EF4: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82403EF8: 481311D8  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            0x82403EFC => {
    //   block [0x82403EFC..0x82403F1C)
	// 82403EFC: 38810052  addi r4, r1, 0x52
	ctx.r[4].s64 = ctx.r[1].s64 + 82;
	// 82403F00: 48000939  bl 0x82404838
	ctx.lr = 0x82403F04;
	sub_82404838(ctx, base);
	// 82403F04: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82403F08: 4180FFE8  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82403F0C: 89610052  lbz r11, 0x52(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82403F10: 7DDE7378  mr r30, r14
	ctx.r[30].u64 = ctx.r[14].u64;
	// 82403F14: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82403F18: 41820054  beq 0x82403f6c
	if ctx.cr[0].eq {
	pc = 0x82403F6C; continue 'dispatch;
	}
	pc = 0x82403F1C; continue 'dispatch;
            }
            0x82403F1C => {
    //   block [0x82403F1C..0x82403F5C)
	// 82403F1C: 38810056  addi r4, r1, 0x56
	ctx.r[4].s64 = ctx.r[1].s64 + 86;
	// 82403F20: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82403F24: 4800096D  bl 0x82404890
	ctx.lr = 0x82403F28;
	sub_82404890(ctx, base);
	// 82403F28: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82403F2C: 4180FFC4  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82403F30: 38A1006C  addi r5, r1, 0x6c
	ctx.r[5].s64 = ctx.r[1].s64 + 108;
	// 82403F34: A0810056  lhz r4, 0x56(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 82403F38: 807B0030  lwz r3, 0x30(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(48 as u32) ) } as u64;
	// 82403F3C: 4BFFF98D  bl 0x824038c8
	ctx.lr = 0x82403F40;
	sub_824038C8(ctx, base);
	// 82403F40: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82403F44: 4180FFAC  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82403F48: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82403F4C: 7F105840  cmplw cr6, r16, r11
	ctx.cr[6].compare_u32(ctx.r[16].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82403F50: 409A000C  bne cr6, 0x82403f5c
	if !ctx.cr[6].eq {
	pc = 0x82403F5C; continue 'dispatch;
	}
	// 82403F54: 7E5D9378  mr r29, r18
	ctx.r[29].u64 = ctx.r[18].u64;
	// 82403F58: 7E559378  mr r21, r18
	ctx.r[21].u64 = ctx.r[18].u64;
	pc = 0x82403F5C; continue 'dispatch;
            }
            0x82403F5C => {
    //   block [0x82403F5C..0x82403F6C)
	// 82403F5C: 89610052  lbz r11, 0x52(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82403F60: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82403F64: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82403F68: 4198FFB4  blt cr6, 0x82403f1c
	if ctx.cr[6].lt {
	pc = 0x82403F1C; continue 'dispatch;
	}
	pc = 0x82403F6C; continue 'dispatch;
            }
            0x82403F6C => {
    //   block [0x82403F6C..0x82403FA0)
	// 82403F6C: 38810056  addi r4, r1, 0x56
	ctx.r[4].s64 = ctx.r[1].s64 + 86;
	// 82403F70: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82403F74: 4800091D  bl 0x82404890
	ctx.lr = 0x82403F78;
	sub_82404890(ctx, base);
	// 82403F78: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82403F7C: 4180FF74  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82403F80: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82403F84: 409A0028  bne cr6, 0x82403fac
	if !ctx.cr[6].eq {
	pc = 0x82403FAC; continue 'dispatch;
	}
	// 82403F88: A1610056  lhz r11, 0x56(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 82403F8C: 38A1006C  addi r5, r1, 0x6c
	ctx.r[5].s64 = ctx.r[1].s64 + 108;
	// 82403F90: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82403F94: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82403F98: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82403F9C: 48000975  bl 0x82404910
	ctx.lr = 0x82403FA0;
	sub_82404910(ctx, base);
	pc = 0x82403FA0; continue 'dispatch;
            }
            0x82403FA0 => {
    //   block [0x82403FA0..0x82403FAC)
	// 82403FA0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82403FA4: 4180FF4C  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82403FA8: 480003C8  b 0x82404370
	pc = 0x82404370; continue 'dispatch;
            }
            0x82403FAC => {
    //   block [0x82403FAC..0x82403FE4)
	// 82403FAC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82403FB0: 83DB0028  lwz r30, 0x28(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 82403FB4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82403FB8: 4BFFF471  bl 0x82403428
	ctx.lr = 0x82403FBC;
	sub_82403428(ctx, base);
	// 82403FBC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82403FC0: 4180FF30  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82403FC4: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82403FC8: 556AF7BE  rlwinm r10, r11, 0x1e, 0x1e, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 82403FCC: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82403FD0: 41980080  blt cr6, 0x82404050
	if ctx.cr[6].lt {
	pc = 0x82404050; continue 'dispatch;
	}
	// 82403FD4: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 82403FD8: 4198000C  blt cr6, 0x82403fe4
	if ctx.cr[6].lt {
	pc = 0x82403FE4; continue 'dispatch;
	}
	// 82403FDC: 409AFF0C  bne cr6, 0x82403ee8
	if !ctx.cr[6].eq {
	pc = 0x82403EE8; continue 'dispatch;
	}
	// 82403FE0: 48000390  b 0x82404370
	pc = 0x82404370; continue 'dispatch;
            }
            0x82403FE4 => {
    //   block [0x82403FE4..0x82404014)
	// 82403FE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82403FE8: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82403FEC: 48000495  bl 0x82404480
	ctx.lr = 0x82403FF0;
	sub_82404480(ctx, base);
	// 82403FF0: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82403FF4: 556A06B5  rlwinm. r10, r11, 0, 0x1a, 0x1a
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82403FF8: 41820050  beq 0x82404048
	if ctx.cr[0].eq {
	pc = 0x82404048; continue 'dispatch;
	}
	// 82403FFC: 556B0031  rlwinm. r11, r11, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82404000: 40820048  bne 0x82404048
	if !ctx.cr[0].eq {
	pc = 0x82404048; continue 'dispatch;
	}
	// 82404004: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 82404008: 419A0038  beq cr6, 0x82404040
	if ctx.cr[6].eq {
	pc = 0x82404040; continue 'dispatch;
	}
	// 8240400C: 81740000  lwz r11, 0(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404010: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	pc = 0x82404014; continue 'dispatch;
            }
            0x82404014 => {
    //   block [0x82404014..0x82404040)
	// 82404014: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82404018: 389C0001  addi r4, r28, 1
	ctx.r[4].s64 = ctx.r[28].s64 + 1;
	// 8240401C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82404020: 4BFFFC49  bl 0x82403c68
	ctx.lr = 0x82404024;
	sub_82403C68(ctx, base);
	// 82404024: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82404028: 4180FEC8  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 8240402C: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82404030: 556B06B5  rlwinm. r11, r11, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82404034: 4182031C  beq 0x82404350
	if ctx.cr[0].eq {
	pc = 0x82404350; continue 'dispatch;
	}
	// 82404038: 3A940004  addi r20, r20, 4
	ctx.r[20].s64 = ctx.r[20].s64 + 4;
	// 8240403C: 48000334  b 0x82404370
	pc = 0x82404370; continue 'dispatch;
            }
            0x82404040 => {
    //   block [0x82404040..0x82404048)
	// 82404040: 91C10068  stw r14, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[14].u32 ) };
	// 82404044: 4BFFFFD0  b 0x82404014
	pc = 0x82404014; continue 'dispatch;
            }
            0x82404048 => {
    //   block [0x82404048..0x82404050)
	// 82404048: 92810068  stw r20, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[20].u32 ) };
	// 8240404C: 4BFFFFC8  b 0x82404014
	pc = 0x82404014; continue 'dispatch;
            }
            0x82404050 => {
    //   block [0x82404050..0x824040A4)
	// 82404050: 7DDA7378  mr r26, r14
	ctx.r[26].u64 = ctx.r[14].u64;
	// 82404054: 556B0031  rlwinm. r11, r11, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82404058: 7DD97378  mr r25, r14
	ctx.r[25].u64 = ctx.r[14].u64;
	// 8240405C: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 82404060: 41820044  beq 0x824040a4
	if ctx.cr[0].eq {
	pc = 0x824040A4; continue 'dispatch;
	}
	// 82404064: 38C1005C  addi r6, r1, 0x5c
	ctx.r[6].s64 = ctx.r[1].s64 + 92;
	// 82404068: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 8240406C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82404070: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82404074: 4BFFFB6D  bl 0x82403be0
	ctx.lr = 0x82404078;
	sub_82403BE0(ctx, base);
	// 82404078: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8240407C: 4180FE74  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82404080: 815B0014  lwz r10, 0x14(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 82404084: 813B0008  lwz r9, 8(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82404088: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 8240408C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82404090: 8341005C  lwz r26, 0x5c(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82404094: 794A0020  clrldi r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 82404098: EA8B0008  ld r20, 8(r11)
	ctx.r[20].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 8240409C: 91EB0000  stw r15, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[15].u32 ) };
	// 824040A0: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	pc = 0x824040A4; continue 'dispatch;
            }
            0x824040A4 => {
    //   block [0x824040A4..0x824040C4)
	// 824040A4: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824040A8: 556B0673  rlwinm. r11, r11, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824040AC: 41820018  beq 0x824040c4
	if ctx.cr[0].eq {
	pc = 0x824040C4; continue 'dispatch;
	}
	// 824040B0: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 824040B4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 824040B8: 480007D9  bl 0x82404890
	ctx.lr = 0x824040BC;
	sub_82404890(ctx, base);
	// 824040BC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824040C0: 4180FE30  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	pc = 0x824040C4; continue 'dispatch;
            }
            0x824040C4 => {
    //   block [0x824040C4..0x82404130)
	// 824040C4: 88810050  lbz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824040C8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 824040CC: 556A07BE  clrlwi r10, r11, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 824040D0: 556B06B5  rlwinm. r11, r11, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824040D4: 7E5C5030  slw r28, r18, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[28].u64 = 0;
	} else {
		ctx.r[28].u64 = ((ctx.r[18].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 824040D8: 418200C8  beq 0x824041a0
	if ctx.cr[0].eq {
	pc = 0x824041A0; continue 'dispatch;
	}
	// 824040DC: 817B0438  lwz r11, 0x438(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1080 as u32) ) } as u64;
	// 824040E0: 3BDB0038  addi r30, r27, 0x38
	ctx.r[30].s64 = ctx.r[27].s64 + 56;
	// 824040E4: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 824040E8: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 824040EC: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 824040F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824040F4: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 824040F8: 48000951  bl 0x82404a48
	ctx.lr = 0x824040FC;
	sub_82404A48(ctx, base);
	// 824040FC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82404100: 4180FDF0  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82404104: 89610058  lbz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82404108: 556A0031  rlwinm. r10, r11, 0, 0, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8240410C: 40820024  bne 0x82404130
	if !ctx.cr[0].eq {
	pc = 0x82404130; continue 'dispatch;
	}
	// 82404110: 89410050  lbz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82404114: 554A0031  rlwinm. r10, r10, 0, 0, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82404118: 40820018  bne 0x82404130
	if !ctx.cr[0].eq {
	pc = 0x82404130; continue 'dispatch;
	}
	// 8240411C: 7E5D9378  mr r29, r18
	ctx.r[29].u64 = ctx.r[18].u64;
	// 82404120: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 82404124: 419A006C  beq cr6, 0x82404190
	if ctx.cr[6].eq {
	pc = 0x82404190; continue 'dispatch;
	}
	// 82404128: 80740000  lwz r3, 0(r20)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 8240412C: 4800000C  b 0x82404138
	pc = 0x82404138; continue 'dispatch;
            }
            0x82404130 => {
    //   block [0x82404130..0x82404138)
	// 82404130: 7DDD7378  mr r29, r14
	ctx.r[29].u64 = ctx.r[14].u64;
	// 82404134: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	pc = 0x82404138; continue 'dispatch;
            }
            0x82404138 => {
    //   block [0x82404138..0x82404160)
	// 82404138: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 8240413C: 556B0673  rlwinm. r11, r11, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82404140: 41820020  beq 0x82404160
	if ctx.cr[0].eq {
	pc = 0x82404160; continue 'dispatch;
	}
	// 82404144: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82404148: 7E599378  mr r25, r18
	ctx.r[25].u64 = ctx.r[18].u64;
	// 8240414C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82404150: 409A0010  bne cr6, 0x82404160
	if !ctx.cr[6].eq {
	pc = 0x82404160; continue 'dispatch;
	}
	// 82404154: 481307CD  bl 0x82534920
	ctx.lr = 0x82404158;
	sub_82534920(ctx, base);
	// 82404158: 39630001  addi r11, r3, 1
	ctx.r[11].s64 = ctx.r[3].s64 + 1;
	// 8240415C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	pc = 0x82404160; continue 'dispatch;
            }
            0x82404160 => {
    //   block [0x82404160..0x82404190)
	// 82404160: 89610058  lbz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82404164: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82404168: 556406BE  clrlwi r4, r11, 0x1a
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 8240416C: 4800087D  bl 0x824049e8
	ctx.lr = 0x82404170;
	sub_824049E8(ctx, base);
	// 82404170: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82404174: 4180FD7C  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82404178: 80810068  lwz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8240417C: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82404180: 80A10070  lwz r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82404184: 419A0014  beq cr6, 0x82404198
	if ctx.cr[6].eq {
	pc = 0x82404198; continue 'dispatch;
	}
	// 82404188: 7DFC7B78  mr r28, r15
	ctx.r[28].u64 = ctx.r[15].u64;
	// 8240418C: 48000024  b 0x824041b0
	pc = 0x824041B0; continue 'dispatch;
            }
            0x82404190 => {
    //   block [0x82404190..0x82404198)
	// 82404190: 7DC37378  mr r3, r14
	ctx.r[3].u64 = ctx.r[14].u64;
	// 82404194: 4BFFFFA4  b 0x82404138
	pc = 0x82404138; continue 'dispatch;
            }
            0x82404198 => {
    //   block [0x82404198..0x824041A0)
	// 82404198: 7F85E1D6  mullw r28, r5, r28
	ctx.r[28].s32 = ((ctx.r[5].s32 as i64 * ctx.r[28].s32 as i64) as i32);
	ctx.r[28].s64 = ctx.r[28].s32 as i64;
	// 8240419C: 48000014  b 0x824041b0
	pc = 0x824041B0; continue 'dispatch;
            }
            0x824041A0 => {
    //   block [0x824041A0..0x824041B0)
	// 824041A0: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 824041A4: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 824041A8: 90A10070  stw r5, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[5].u32 ) };
	// 824041AC: 90810068  stw r4, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[4].u32 ) };
	pc = 0x824041B0; continue 'dispatch;
            }
            0x824041B0 => {
    //   block [0x824041B0..0x82404228)
	// 824041B0: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 824041B4: 419A0074  beq cr6, 0x82404228
	if ctx.cr[6].eq {
	pc = 0x82404228; continue 'dispatch;
	}
	// 824041B8: 3BFB0008  addi r31, r27, 8
	ctx.r[31].s64 = ctx.r[27].s64 + 8;
	// 824041BC: 3C600000  lis r3, 0
	ctx.r[3].s64 = 0;
	// 824041C0: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 824041C4: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 824041C8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 824041CC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824041D0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 824041D4: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824041D8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 824041DC: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824041E0: 557D003E  slwi r29, r11, 0
	ctx.r[29].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 824041E4: 7CEB4214  add r7, r11, r8
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 824041E8: 6063FDE9  ori r3, r3, 0xfde9
	ctx.r[3].u64 = ctx.r[3].u64 | 65001;
	// 824041EC: 7D1DF050  subf r8, r29, r30
	ctx.r[8].s64 = ctx.r[30].s64 - ctx.r[29].s64;
	// 824041F0: 48142489  bl 0x82546678
	ctx.lr = 0x824041F4;
	sub_82546678(ctx, base);
	// 824041F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824041F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824041FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82404200: 48000601  bl 0x82404800
	ctx.lr = 0x82404204;
	sub_82404800(ctx, base);
	// 82404204: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82404208: 4180FCE8  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 8240420C: 89610058  lbz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82404210: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82404214: 7BC50020  clrldi r5, r30, 0x20
	ctx.r[5].u64 = ctx.r[30].u64 & 0x00000000FFFFFFFFu64;
	// 82404218: 556406BE  clrlwi r4, r11, 0x1a
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 8240421C: 387B0038  addi r3, r27, 0x38
	ctx.r[3].s64 = ctx.r[27].s64 + 56;
	// 82404220: 48000939  bl 0x82404b58
	ctx.lr = 0x82404224;
	sub_82404B58(ctx, base);
	// 82404224: 4800008C  b 0x824042b0
	pc = 0x824042B0; continue 'dispatch;
            }
            0x82404228 => {
    //   block [0x82404228..0x8240426C)
	// 82404228: 7DDF7378  mr r31, r14
	ctx.r[31].u64 = ctx.r[14].u64;
	// 8240422C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82404230: 419A0090  beq cr6, 0x824042c0
	if ctx.cr[6].eq {
	pc = 0x824042C0; continue 'dispatch;
	}
	// 82404234: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82404238: 556B07BE  clrlwi r11, r11, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 8240423C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82404240: 4198005C  blt cr6, 0x8240429c
	if ctx.cr[6].lt {
	pc = 0x8240429C; continue 'dispatch;
	}
	// 82404244: 419A0040  beq cr6, 0x82404284
	if ctx.cr[6].eq {
	pc = 0x82404284; continue 'dispatch;
	}
	// 82404248: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 8240424C: 41980020  blt cr6, 0x8240426c
	if ctx.cr[6].lt {
	pc = 0x8240426C; continue 'dispatch;
	}
	// 82404250: 409A0070  bne cr6, 0x824042c0
	if !ctx.cr[6].eq {
	pc = 0x824042C0; continue 'dispatch;
	}
	// 82404254: EB040000  ld r24, 0(r4)
	ctx.r[24].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	// 82404258: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 8240425C: 409A0064  bne cr6, 0x824042c0
	if !ctx.cr[6].eq {
	pc = 0x824042C0; continue 'dispatch;
	}
	// 82404260: 387B0008  addi r3, r27, 8
	ctx.r[3].s64 = ctx.r[27].s64 + 8;
	// 82404264: 480004F5  bl 0x82404758
	ctx.lr = 0x82404268;
	sub_82404758(ctx, base);
	// 82404268: 48000048  b 0x824042b0
	pc = 0x824042B0; continue 'dispatch;
            }
            0x8240426C => {
    //   block [0x8240426C..0x82404284)
	// 8240426C: 83040000  lwz r24, 0(r4)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404270: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82404274: 409A004C  bne cr6, 0x824042c0
	if !ctx.cr[6].eq {
	pc = 0x824042C0; continue 'dispatch;
	}
	// 82404278: 387B0008  addi r3, r27, 8
	ctx.r[3].s64 = ctx.r[27].s64 + 8;
	// 8240427C: 48000455  bl 0x824046d0
	ctx.lr = 0x82404280;
	sub_824046D0(ctx, base);
	// 82404280: 48000030  b 0x824042b0
	pc = 0x824042B0; continue 'dispatch;
            }
            0x82404284 => {
    //   block [0x82404284..0x8240429C)
	// 82404284: A3040000  lhz r24, 0(r4)
	ctx.r[24].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404288: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 8240428C: 409A0034  bne cr6, 0x824042c0
	if !ctx.cr[6].eq {
	pc = 0x824042C0; continue 'dispatch;
	}
	// 82404290: 387B0008  addi r3, r27, 8
	ctx.r[3].s64 = ctx.r[27].s64 + 8;
	// 82404294: 480003BD  bl 0x82404650
	ctx.lr = 0x82404298;
	sub_82404650(ctx, base);
	// 82404298: 48000018  b 0x824042b0
	pc = 0x824042B0; continue 'dispatch;
            }
            0x8240429C => {
    //   block [0x8240429C..0x824042B0)
	// 8240429C: 8B040000  lbz r24, 0(r4)
	ctx.r[24].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 824042A0: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 824042A4: 409A001C  bne cr6, 0x824042c0
	if !ctx.cr[6].eq {
	pc = 0x824042C0; continue 'dispatch;
	}
	// 824042A8: 387B0008  addi r3, r27, 8
	ctx.r[3].s64 = ctx.r[27].s64 + 8;
	// 824042AC: 4800032D  bl 0x824045d8
	ctx.lr = 0x824042B0;
	sub_824045D8(ctx, base);
	pc = 0x824042B0; continue 'dispatch;
            }
            0x824042B0 => {
    //   block [0x824042B0..0x824042C0)
	// 824042B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824042B4: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824042B8: 4198FC38  blt cr6, 0x82403ef0
	if ctx.cr[6].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 824042BC: 80810068  lwz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	pc = 0x824042C0; continue 'dispatch;
            }
            0x824042C0 => {
    //   block [0x824042C0..0x824042D4)
	// 824042C0: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 824042C4: 556B073A  rlwinm r11, r11, 0, 0x1c, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824042C8: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 824042CC: 409A0008  bne cr6, 0x824042d4
	if !ctx.cr[6].eq {
	pc = 0x824042D4; continue 'dispatch;
	}
	// 824042D0: A381005A  lhz r28, 0x5a(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(90 as u32) ) } as u64;
	pc = 0x824042D4; continue 'dispatch;
            }
            0x824042D4 => {
    //   block [0x824042D4..0x824042E0)
	// 824042D4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 824042D8: 419A0008  beq cr6, 0x824042e0
	if ctx.cr[6].eq {
	pc = 0x824042E0; continue 'dispatch;
	}
	// 824042DC: 7E9CA214  add r20, r28, r20
	ctx.r[20].u64 = ctx.r[28].u64 + ctx.r[20].u64;
	pc = 0x824042E0; continue 'dispatch;
            }
            0x824042E0 => {
    //   block [0x824042E0..0x82404350)
	// 824042E0: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824042E4: 556B06F7  rlwinm. r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824042E8: 41820088  beq 0x82404370
	if ctx.cr[0].eq {
	pc = 0x82404370; continue 'dispatch;
	}
	// 824042EC: 3881007C  addi r4, r1, 0x7c
	ctx.r[4].s64 = ctx.r[1].s64 + 124;
	// 824042F0: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 824042F4: 4BFFF165  bl 0x82403458
	ctx.lr = 0x824042F8;
	sub_82403458(ctx, base);
	// 824042F8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824042FC: 4180FBF4  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82404300: 38A1006C  addi r5, r1, 0x6c
	ctx.r[5].s64 = ctx.r[1].s64 + 108;
	// 82404304: A081007E  lhz r4, 0x7e(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(126 as u32) ) } as u64;
	// 82404308: 807B0030  lwz r3, 0x30(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(48 as u32) ) } as u64;
	// 8240430C: 4BFFF5BD  bl 0x824038c8
	ctx.lr = 0x82404310;
	sub_824038C8(ctx, base);
	// 82404310: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82404314: 4180FBDC  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82404318: 8961007C  lbz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 8240431C: 3901007C  addi r8, r1, 0x7c
	ctx.r[8].s64 = ctx.r[1].s64 + 124;
	// 82404320: 815B0014  lwz r10, 0x14(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 82404324: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 82404328: 5565D1BE  srwi r5, r11, 6
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shr(6);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 8240432C: 80E1006C  lwz r7, 0x6c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82404330: 556406BE  clrlwi r4, r11, 0x1a
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82404334: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82404338: 387B0038  addi r3, r27, 0x38
	ctx.r[3].s64 = ctx.r[27].s64 + 56;
	// 8240433C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82404340: 7E4A2830  slw r10, r18, r5
	if (ctx.r[5].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[18].u32) << ((ctx.r[5].u8 & 0x1F) as u32)) as u64;
	}
	// 82404344: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82404348: 480005D1  bl 0x82404918
	ctx.lr = 0x8240434C;
	sub_82404918(ctx, base);
	// 8240434C: 4BFFFC54  b 0x82403fa0
	pc = 0x82403FA0; continue 'dispatch;
            }
            0x82404350 => {
    //   block [0x82404350..0x8240436C)
	// 82404350: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82404354: 556B073A  rlwinm r11, r11, 0, 0x1c, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82404358: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 8240435C: 409A0010  bne cr6, 0x8240436c
	if !ctx.cr[6].eq {
	pc = 0x8240436C; continue 'dispatch;
	}
	// 82404360: A161005A  lhz r11, 0x5a(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(90 as u32) ) } as u64;
	// 82404364: 7E8BA214  add r20, r11, r20
	ctx.r[20].u64 = ctx.r[11].u64 + ctx.r[20].u64;
	// 82404368: 48000008  b 0x82404370
	pc = 0x82404370; continue 'dispatch;
            }
            0x8240436C => {
    //   block [0x8240436C..0x82404370)
	// 8240436C: 82810068  lwz r20, 0x68(r1)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	pc = 0x82404370; continue 'dispatch;
            }
            0x82404370 => {
    //   block [0x82404370..0x8240438C)
	// 82404370: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82404374: 556B073A  rlwinm r11, r11, 0, 0x1c, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82404378: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 8240437C: 409A0010  bne cr6, 0x8240438c
	if !ctx.cr[6].eq {
	pc = 0x8240438C; continue 'dispatch;
	}
	// 82404380: 56CB043E  clrlwi r11, r22, 0x10
	ctx.r[11].u64 = ctx.r[22].u32 as u64 & 0x0000FFFFu64;
	// 82404384: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82404388: 5576043E  clrlwi r22, r11, 0x10
	ctx.r[22].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	pc = 0x8240438C; continue 'dispatch;
            }
            0x8240438C => {
    //   block [0x8240438C..0x824043CC)
	// 8240438C: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82404390: 556B073A  rlwinm r11, r11, 0, 0x1c, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82404394: 2B0B000C  cmplwi cr6, r11, 0xc
	ctx.cr[6].compare_u32(ctx.r[11].u32, 12 as u32, &mut ctx.xer);
	// 82404398: 409AFAF0  bne cr6, 0x82403e88
	if !ctx.cr[6].eq {
	pc = 0x82403E88; continue 'dispatch;
	}
	// 8240439C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 824043A0: 3A310001  addi r17, r17, 1
	ctx.r[17].s64 = ctx.r[17].s64 + 1;
	// 824043A4: 7F115840  cmplw cr6, r17, r11
	ctx.cr[6].compare_u32(ctx.r[17].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824043A8: 40980024  bge cr6, 0x824043cc
	if !ctx.cr[6].lt {
	pc = 0x824043CC; continue 'dispatch;
	}
	// 824043AC: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 824043B0: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 824043B4: 480000CD  bl 0x82404480
	ctx.lr = 0x824043B8;
	sub_82404480(ctx, base);
	// 824043B8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 824043BC: 7F115840  cmplw cr6, r17, r11
	ctx.cr[6].compare_u32(ctx.r[17].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824043C0: 4098000C  bge cr6, 0x824043cc
	if !ctx.cr[6].lt {
	pc = 0x824043CC; continue 'dispatch;
	}
	// 824043C4: 8381014C  lwz r28, 0x14c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(332 as u32) ) } as u64;
	// 824043C8: 4BFFFAA8  b 0x82403e70
	pc = 0x82403E70; continue 'dispatch;
            }
            0x824043CC => {
    //   block [0x824043CC..0x824043D0)
	// 824043CC: 83A10154  lwz r29, 0x154(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(340 as u32) ) } as u64;
	pc = 0x824043D0; continue 'dispatch;
            }
            0x824043D0 => {
    //   block [0x824043D0..0x824043F4)
	// 824043D0: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 824043D4: 556B06B5  rlwinm. r11, r11, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824043D8: 4182001C  beq 0x824043f4
	if ctx.cr[0].eq {
	pc = 0x824043F4; continue 'dispatch;
	}
	// 824043DC: 89610060  lbz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 824043E0: 387B0038  addi r3, r27, 0x38
	ctx.r[3].s64 = ctx.r[27].s64 + 56;
	// 824043E4: 556406BE  clrlwi r4, r11, 0x1a
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 824043E8: 48000601  bl 0x824049e8
	ctx.lr = 0x824043EC;
	sub_824049E8(ctx, base);
	// 824043EC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824043F0: 4180FB00  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	pc = 0x824043F4; continue 'dispatch;
            }
            0x824043F4 => {
    //   block [0x824043F4..0x82404428)
	// 824043F4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 824043F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824043FC: 409A002C  bne cr6, 0x82404428
	if !ctx.cr[6].eq {
	pc = 0x82404428; continue 'dispatch;
	}
	// 82404400: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82404404: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82404408: 48000079  bl 0x82404480
	ctx.lr = 0x8240440C;
	sub_82404480(ctx, base);
	// 8240440C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82404410: 4180FAE0  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	// 82404414: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82404418: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 8240441C: 4BFFF115  bl 0x82403530
	ctx.lr = 0x82404420;
	sub_82403530(ctx, base);
	// 82404420: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82404424: 4180FACC  blt 0x82403ef0
	if ctx.cr[0].lt {
	pc = 0x82403EF0; continue 'dispatch;
	}
	pc = 0x82404428; continue 'dispatch;
            }
            0x82404428 => {
    //   block [0x82404428..0x82404430)
	// 82404428: 929D0000  stw r20, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[20].u32 ) };
	// 8240442C: 4BFFFAC4  b 0x82403ef0
	pc = 0x82403EF0; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82404430 size=48
    let mut pc: u32 = 0x82404430;
    'dispatch: loop {
        match pc {
            0x82404430 => {
    //   block [0x82404430..0x82404460)
	// 82404430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82404434: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82404438: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240443C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82404440: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82404444: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82404448: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8240444C: 4BFFF81D  bl 0x82403c68
	ctx.lr = 0x82404450;
	sub_82403C68(ctx, base);
	// 82404450: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82404454: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82404458: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8240445C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404460 size=28
    let mut pc: u32 = 0x82404460;
    'dispatch: loop {
        match pc {
            0x82404460 => {
    //   block [0x82404460..0x8240447C)
	// 82404460: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82404464: 90830000  stw r4, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82404468: 90A30004  stw r5, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 8240446C: 90C30008  stw r6, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82404470: 90E30010  stw r7, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[7].u32 ) };
	// 82404474: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82404478: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404480 size=28
    let mut pc: u32 = 0x82404480;
    'dispatch: loop {
        match pc {
            0x82404480 => {
    //   block [0x82404480..0x8240449C)
	// 82404480: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82404484: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82404488: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8240448C: 40990010  ble cr6, 0x8240449c
	if !ctx.cr[6].gt {
		crate::recompiler::externs::call(ctx, base, 0x8240449C);
		return;
	}
	// 82404490: 3C608018  lis r3, -0x7fe8
	ctx.r[3].s64 = -2145910784;
	// 82404494: 60632001  ori r3, r3, 0x2001
	ctx.r[3].u64 = ctx.r[3].u64 | 8193;
	// 82404498: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824044A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824044A8 size=44
    let mut pc: u32 = 0x824044A8;
    'dispatch: loop {
        match pc {
            0x824044A8 => {
    //   block [0x824044A8..0x824044D4)
	// 824044A8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 824044AC: 81050000  lwz r8, 0(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 824044B0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824044B4: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 824044B8: 7D2A4850  subf r9, r10, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 824044BC: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 824044C0: 40980014  bge cr6, 0x824044d4
	if !ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x824044D4);
		return;
	}
	// 824044C4: 3C608018  lis r3, -0x7fe8
	ctx.r[3].s64 = -2145910784;
	// 824044C8: 91250000  stw r9, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824044CC: 60632001  ori r3, r3, 0x2001
	ctx.r[3].u64 = ctx.r[3].u64 | 8193;
	// 824044D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824044F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824044F8 size=220
    let mut pc: u32 = 0x824044F8;
    'dispatch: loop {
        match pc {
            0x824044F8 => {
    //   block [0x824044F8..0x82404554)
	// 824044F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824044FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82404500: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82404504: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82404508: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 8240450C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82404510: 4BFFFF99  bl 0x824044a8
	ctx.lr = 0x82404514;
	sub_824044A8(ctx, base);
	// 82404514: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82404518: 418000A4  blt 0x824045bc
	if ctx.cr[0].lt {
	pc = 0x824045BC; continue 'dispatch;
	}
	// 8240451C: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82404520: 419A008C  beq cr6, 0x824045ac
	if ctx.cr[6].eq {
	pc = 0x824045AC; continue 'dispatch;
	}
	// 82404524: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404528: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8240452C: 419A0070  beq cr6, 0x8240459c
	if ctx.cr[6].eq {
	pc = 0x8240459C; continue 'dispatch;
	}
	// 82404530: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82404534: 419A0050  beq cr6, 0x82404584
	if ctx.cr[6].eq {
	pc = 0x82404584; continue 'dispatch;
	}
	// 82404538: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 8240453C: 419A0038  beq cr6, 0x82404574
	if ctx.cr[6].eq {
	pc = 0x82404574; continue 'dispatch;
	}
	// 82404540: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 82404544: 419A0010  beq cr6, 0x82404554
	if ctx.cr[6].eq {
	pc = 0x82404554; continue 'dispatch;
	}
	// 82404548: 3FE08007  lis r31, -0x7ff9
	ctx.r[31].s64 = -2147024896;
	// 8240454C: 63FF000D  ori r31, r31, 0xd
	ctx.r[31].u64 = ctx.r[31].u64 | 13;
	// 82404550: 4800006C  b 0x824045bc
	pc = 0x824045BC; continue 'dispatch;
            }
            0x82404554 => {
    //   block [0x82404554..0x82404574)
	// 82404554: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82404558: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 8240455C: 7D605C2C  lwbrx r11, 0, r11
	ctx.r[11].u64 = (unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32) }).swap_bytes() as u64;
	// 82404560: 7D40542C  lwbrx r10, 0, r10
	ctx.r[10].u64 = (unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32) }).swap_bytes() as u64;
	// 82404564: 794A07E6  rldicr r10, r10, 0x20, 0x3f
	ctx.r[10].u64 = (ctx.r[10].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 82404568: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 8240456C: F9670000  std r11, 0(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82404570: 4800004C  b 0x824045bc
	pc = 0x824045BC; continue 'dispatch;
            }
            0x82404574 => {
    //   block [0x82404574..0x82404584)
	// 82404574: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82404578: 7D605C2C  lwbrx r11, 0, r11
	ctx.r[11].u64 = (unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32) }).swap_bytes() as u64;
	// 8240457C: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82404580: 4800003C  b 0x824045bc
	pc = 0x824045BC; continue 'dispatch;
            }
            0x82404584 => {
    //   block [0x82404584..0x8240459C)
	// 82404584: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82404588: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8240458C: 556AC63E  rlwinm r10, r11, 0x18, 0x18, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82404590: 516A442E  rlwimi r10, r11, 8, 0x10, 0x17
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF00FF);
	// 82404594: B1470000  sth r10, 0(r7)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 82404598: 48000024  b 0x824045bc
	pc = 0x824045BC; continue 'dispatch;
            }
            0x8240459C => {
    //   block [0x8240459C..0x824045AC)
	// 8240459C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824045A0: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824045A4: 99670000  stb r11, 0(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824045A8: 48000014  b 0x824045bc
	pc = 0x824045BC; continue 'dispatch;
            }
            0x824045AC => {
    //   block [0x824045AC..0x824045BC)
	// 824045AC: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 824045B0: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824045B4: 80A50000  lwz r5, 0(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 824045B8: 48130599  bl 0x82534b50
	ctx.lr = 0x824045BC;
	sub_82534B50(ctx, base);
	pc = 0x824045BC; continue 'dispatch;
            }
            0x824045BC => {
    //   block [0x824045BC..0x824045D4)
	// 824045BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824045C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824045C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824045C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824045CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824045D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824045D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824045D8 size=116
    let mut pc: u32 = 0x824045D8;
    'dispatch: loop {
        match pc {
            0x824045D8 => {
    //   block [0x824045D8..0x82404614)
	// 824045D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824045DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824045E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824045E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824045E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824045EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824045F0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 824045F4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824045F8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824045FC: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82404600: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82404604: 40980010  bge cr6, 0x82404614
	if !ctx.cr[6].lt {
	pc = 0x82404614; continue 'dispatch;
	}
	// 82404608: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 8240460C: 6063007A  ori r3, r3, 0x7a
	ctx.r[3].u64 = ctx.r[3].u64 | 122;
	// 82404610: 48000024  b 0x82404634
	pc = 0x82404634; continue 'dispatch;
            }
            0x82404614 => {
    //   block [0x82404614..0x82404634)
	// 82404614: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404618: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8240461C: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82404620: 48130531  bl 0x82534b50
	ctx.lr = 0x82404624;
	sub_82534B50(ctx, base);
	// 82404624: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82404628: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8240462C: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82404630: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x82404634; continue 'dispatch;
            }
            0x82404634 => {
    //   block [0x82404634..0x8240464C)
	// 82404634: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82404638: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8240463C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82404640: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82404644: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82404648: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404650 size=36
    let mut pc: u32 = 0x82404650;
    'dispatch: loop {
        match pc {
            0x82404650 => {
    //   block [0x82404650..0x82404674)
	// 82404650: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82404654: 54AA083C  slwi r10, r5, 1
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82404658: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8240465C: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82404660: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82404664: 40980010  bge cr6, 0x82404674
	if !ctx.cr[6].lt {
		sub_82404674(ctx, base);
		return;
	}
	// 82404668: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 8240466C: 6063007A  ori r3, r3, 0x7a
	ctx.r[3].u64 = ctx.r[3].u64 | 122;
	// 82404670: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404674(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404674 size=88
    let mut pc: u32 = 0x82404674;
    'dispatch: loop {
        match pc {
            0x82404674 => {
    //   block [0x82404674..0x82404684)
	// 82404674: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404678: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 8240467C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82404680: 419A0044  beq cr6, 0x824046c4
	if ctx.cr[6].eq {
	pc = 0x824046C4; continue 'dispatch;
	}
	pc = 0x82404684; continue 'dispatch;
            }
            0x82404684 => {
    //   block [0x82404684..0x824046A0)
	// 82404684: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82404688: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8240468C: 419A0014  beq cr6, 0x824046a0
	if ctx.cr[6].eq {
	pc = 0x824046A0; continue 'dispatch;
	}
	// 82404690: A1240000  lhz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404694: 552BC63E  rlwinm r11, r9, 0x18, 0x18, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82404698: 512B442E  rlwimi r11, r9, 8, 0x10, 0x17
	ctx.r[11].u64 = (((ctx.r[9].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[11].u64 & 0xFFFFFFFFFFFF00FF);
	// 8240469C: 48000008  b 0x824046a4
	pc = 0x824046A4; continue 'dispatch;
            }
            0x824046A0 => {
    //   block [0x824046A0..0x824046A4)
	// 824046A0: A1640000  lhz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x824046A4; continue 'dispatch;
            }
            0x824046A4 => {
    //   block [0x824046A4..0x824046C4)
	// 824046A4: B16A0000  sth r11, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 824046A8: 38840002  addi r4, r4, 2
	ctx.r[4].s64 = ctx.r[4].s64 + 2;
	// 824046AC: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 824046B0: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 824046B4: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 824046B8: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 824046BC: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 824046C0: 4082FFC4  bne 0x82404684
	if !ctx.cr[0].eq {
	pc = 0x82404684; continue 'dispatch;
	}
	pc = 0x824046C4; continue 'dispatch;
            }
            0x824046C4 => {
    //   block [0x824046C4..0x824046CC)
	// 824046C4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824046C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824046D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824046D0 size=36
    let mut pc: u32 = 0x824046D0;
    'dispatch: loop {
        match pc {
            0x824046D0 => {
    //   block [0x824046D0..0x824046F4)
	// 824046D0: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 824046D4: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824046D8: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 824046DC: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 824046E0: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 824046E4: 40980010  bge cr6, 0x824046f4
	if !ctx.cr[6].lt {
		sub_824046F4(ctx, base);
		return;
	}
	// 824046E8: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 824046EC: 6063007A  ori r3, r3, 0x7a
	ctx.r[3].u64 = ctx.r[3].u64 | 122;
	// 824046F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824046F4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824046F4 size=96
    let mut pc: u32 = 0x824046F4;
    'dispatch: loop {
        match pc {
            0x824046F4 => {
    //   block [0x824046F4..0x82404704)
	// 824046F4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824046F8: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 824046FC: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82404700: 419A004C  beq cr6, 0x8240474c
	if ctx.cr[6].eq {
	pc = 0x8240474C; continue 'dispatch;
	}
	pc = 0x82404704; continue 'dispatch;
            }
            0x82404704 => {
    //   block [0x82404704..0x82404728)
	// 82404704: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82404708: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8240470C: 419A001C  beq cr6, 0x82404728
	if ctx.cr[6].eq {
	pc = 0x82404728; continue 'dispatch;
	}
	// 82404710: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404714: 552B463E  srwi r11, r9, 0x18
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(24);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82404718: 512BC42E  rlwimi r11, r9, 0x18, 0x10, 0x17
	ctx.r[11].u64 = (((ctx.r[9].u32).rotate_left(24) as u64) & 0x000000000000FF00) | (ctx.r[11].u64 & 0xFFFFFFFFFFFF00FF);
	// 8240471C: 512B421E  rlwimi r11, r9, 8, 8, 0xf
	ctx.r[11].u64 = (((ctx.r[9].u32).rotate_left(8) as u64) & 0x0000000000FF0000) | (ctx.r[11].u64 & 0xFFFFFFFFFF00FFFF);
	// 82404720: 512BC00E  rlwimi r11, r9, 0x18, 0, 7
	ctx.r[11].u64 = (((ctx.r[9].u32).rotate_left(24) as u64) & 0x00000000FF000000) | (ctx.r[11].u64 & 0xFFFFFFFF00FFFFFF);
	// 82404724: 48000008  b 0x8240472c
	pc = 0x8240472C; continue 'dispatch;
            }
            0x82404728 => {
    //   block [0x82404728..0x8240472C)
	// 82404728: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8240472C; continue 'dispatch;
            }
            0x8240472C => {
    //   block [0x8240472C..0x8240474C)
	// 8240472C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82404730: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 82404734: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82404738: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8240473C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82404740: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82404744: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82404748: 4082FFBC  bne 0x82404704
	if !ctx.cr[0].eq {
	pc = 0x82404704; continue 'dispatch;
	}
	pc = 0x8240474C; continue 'dispatch;
            }
            0x8240474C => {
    //   block [0x8240474C..0x82404754)
	// 8240474C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82404750: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404758 size=36
    let mut pc: u32 = 0x82404758;
    'dispatch: loop {
        match pc {
            0x82404758 => {
    //   block [0x82404758..0x8240477C)
	// 82404758: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8240475C: 54AA1838  slwi r10, r5, 3
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82404760: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82404764: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82404768: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8240476C: 40980010  bge cr6, 0x8240477c
	if !ctx.cr[6].lt {
		sub_8240477C(ctx, base);
		return;
	}
	// 82404770: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82404774: 6063007A  ori r3, r3, 0x7a
	ctx.r[3].u64 = ctx.r[3].u64 | 122;
	// 82404778: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8240477C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8240477C size=128
    let mut pc: u32 = 0x8240477C;
    'dispatch: loop {
        match pc {
            0x8240477C => {
    //   block [0x8240477C..0x8240478C)
	// 8240477C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404780: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82404784: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82404788: 419A006C  beq cr6, 0x824047f4
	if ctx.cr[6].eq {
	pc = 0x824047F4; continue 'dispatch;
	}
	pc = 0x8240478C; continue 'dispatch;
            }
            0x8240478C => {
    //   block [0x8240478C..0x824047D8)
	// 8240478C: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82404790: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82404794: E9440000  ld r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	// 82404798: 38840008  addi r4, r4, 8
	ctx.r[4].s64 = ctx.r[4].s64 + 8;
	// 8240479C: 419A003C  beq cr6, 0x824047d8
	if ctx.cr[6].eq {
	pc = 0x824047D8; continue 'dispatch;
	}
	// 824047A0: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 824047A4: 8141FFF4  lwz r10, -0xc(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 824047A8: 8121FFF0  lwz r9, -0x10(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 824047AC: 5548463E  srwi r8, r10, 0x18
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shr(24);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 824047B0: 5527463E  srwi r7, r9, 0x18
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shr(24);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 824047B4: 5148C42E  rlwimi r8, r10, 0x18, 0x10, 0x17
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(24) as u64) & 0x000000000000FF00) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF00FF);
	// 824047B8: 5127C42E  rlwimi r7, r9, 0x18, 0x10, 0x17
	ctx.r[7].u64 = (((ctx.r[9].u32).rotate_left(24) as u64) & 0x000000000000FF00) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF00FF);
	// 824047BC: 5148421E  rlwimi r8, r10, 8, 8, 0xf
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(8) as u64) & 0x0000000000FF0000) | (ctx.r[8].u64 & 0xFFFFFFFFFF00FFFF);
	// 824047C0: 5127421E  rlwimi r7, r9, 8, 8, 0xf
	ctx.r[7].u64 = (((ctx.r[9].u32).rotate_left(8) as u64) & 0x0000000000FF0000) | (ctx.r[7].u64 & 0xFFFFFFFFFF00FFFF);
	// 824047C4: 5148C00E  rlwimi r8, r10, 0x18, 0, 7
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(24) as u64) & 0x00000000FF000000) | (ctx.r[8].u64 & 0xFFFFFFFF00FFFFFF);
	// 824047C8: 5127C00E  rlwimi r7, r9, 0x18, 0, 7
	ctx.r[7].u64 = (((ctx.r[9].u32).rotate_left(24) as u64) & 0x00000000FF000000) | (ctx.r[7].u64 & 0xFFFFFFFF00FFFFFF);
	// 824047CC: 790A07C6  sldi r10, r8, 0x20
	ctx.r[10].u64 = ctx.r[8].u64.wrapping_shl(32);
	ctx.r[10].u32 = ctx.r[10].u64 as u32;
	// 824047D0: 78E90020  clrldi r9, r7, 0x20
	ctx.r[9].u64 = ctx.r[7].u64 & 0x00000000FFFFFFFFu64;
	// 824047D4: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	pc = 0x824047D8; continue 'dispatch;
            }
            0x824047D8 => {
    //   block [0x824047D8..0x824047F4)
	// 824047D8: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 824047DC: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 824047E0: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 824047E4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 824047E8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 824047EC: 9143000C  stw r10, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 824047F0: 4082FF9C  bne 0x8240478c
	if !ctx.cr[0].eq {
	pc = 0x8240478C; continue 'dispatch;
	}
	pc = 0x824047F4; continue 'dispatch;
            }
            0x824047F4 => {
    //   block [0x824047F4..0x824047FC)
	// 824047F4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824047F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404800 size=36
    let mut pc: u32 = 0x82404800;
    'dispatch: loop {
        match pc {
            0x82404800 => {
    //   block [0x82404800..0x82404824)
	// 82404800: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82404804: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82404808: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8240480C: 7D2A4850  subf r9, r10, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82404810: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82404814: 40980010  bge cr6, 0x82404824
	if !ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x82404824);
		return;
	}
	// 82404818: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 8240481C: 6063007A  ori r3, r3, 0x7a
	ctx.r[3].u64 = ctx.r[3].u64 | 122;
	// 82404820: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82404838 size=88
    let mut pc: u32 = 0x82404838;
    'dispatch: loop {
        match pc {
            0x82404838 => {
    //   block [0x82404838..0x82404878)
	// 82404838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240483C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82404840: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82404844: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82404848: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8240484C: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 82404850: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82404854: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82404858: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8240485C: 4BFFFC4D  bl 0x824044a8
	ctx.lr = 0x82404860;
	sub_824044A8(ctx, base);
	// 82404860: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82404864: 41800014  blt 0x82404878
	if ctx.cr[0].lt {
	pc = 0x82404878; continue 'dispatch;
	}
	// 82404868: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 8240486C: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82404870: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82404874: 481302DD  bl 0x82534b50
	ctx.lr = 0x82404878;
	sub_82534B50(ctx, base);
	pc = 0x82404878; continue 'dispatch;
            }
            0x82404878 => {
    //   block [0x82404878..0x82404890)
	// 82404878: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8240487C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82404880: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82404884: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82404888: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8240488C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82404890 size=48
    let mut pc: u32 = 0x82404890;
    'dispatch: loop {
        match pc {
            0x82404890 => {
    //   block [0x82404890..0x824048C0)
	// 82404890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82404894: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82404898: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240489C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 824048A0: 80C30010  lwz r6, 0x10(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 824048A4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824048A8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 824048AC: 4BFFFC4D  bl 0x824044f8
	ctx.lr = 0x824048B0;
	sub_824044F8(ctx, base);
	// 824048B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824048B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824048B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824048BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824048C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824048C0 size=76
    let mut pc: u32 = 0x824048C0;
    'dispatch: loop {
        match pc {
            0x824048C0 => {
    //   block [0x824048C0..0x824048F4)
	// 824048C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824048C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824048C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824048CC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824048D0: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 824048D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824048D8: 4BFFFBD1  bl 0x824044a8
	ctx.lr = 0x824048DC;
	sub_824044A8(ctx, base);
	// 824048DC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824048E0: 41800014  blt 0x824048f4
	if ctx.cr[0].lt {
	pc = 0x824048F4; continue 'dispatch;
	}
	// 824048E4: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 824048E8: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824048EC: 80A50000  lwz r5, 0(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 824048F0: 48130261  bl 0x82534b50
	ctx.lr = 0x824048F4;
	sub_82534B50(ctx, base);
	pc = 0x824048F4; continue 'dispatch;
            }
            0x824048F4 => {
    //   block [0x824048F4..0x8240490C)
	// 824048F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824048F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824048FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82404900: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82404904: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82404908: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404910 size=4
    let mut pc: u32 = 0x82404910;
    'dispatch: loop {
        match pc {
            0x82404910 => {
    //   block [0x82404910..0x82404914)
	// 82404910: 4BFFFB98  b 0x824044a8
	sub_824044A8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404918 size=48
    let mut pc: u32 = 0x82404918;
    'dispatch: loop {
        match pc {
            0x82404918 => {
    //   block [0x82404918..0x82404948)
	// 82404918: 2B040040  cmplwi cr6, r4, 0x40
	ctx.cr[6].compare_u32(ctx.r[4].u32, 64 as u32, &mut ctx.xer);
	// 8240491C: 4098006C  bge cr6, 0x82404988
	if !ctx.cr[6].lt {
		sub_82404988(ctx, base);
		return;
	}
	// 82404920: 2B050003  cmplwi cr6, r5, 3
	ctx.cr[6].compare_u32(ctx.r[5].u32, 3 as u32, &mut ctx.xer);
	// 82404924: 41990064  bgt cr6, 0x82404988
	if ctx.cr[6].gt {
		sub_82404988(ctx, base);
		return;
	}
	// 82404928: 548B2036  slwi r11, r4, 4
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8240492C: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82404930: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404934: 554A0043  rlwinm. r10, r10, 0, 1, 1
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82404938: 41820010  beq 0x82404948
	if ctx.cr[0].eq {
		sub_82404948(ctx, base);
		return;
	}
	// 8240493C: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82404940: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 82404944: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404948 size=64
    let mut pc: u32 = 0x82404948;
    'dispatch: loop {
        match pc {
            0x82404948 => {
    //   block [0x82404948..0x82404970)
	// 82404948: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8240494C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82404950: 419A0020  beq cr6, 0x82404970
	if ctx.cr[6].eq {
	pc = 0x82404970; continue 'dispatch;
	}
	// 82404954: 89080001  lbz r8, 1(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(1 as u32) ) } as u64;
	// 82404958: 550807FF  clrlwi. r8, r8, 0x1f
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 8240495C: 41820014  beq 0x82404970
	if ctx.cr[0].eq {
	pc = 0x82404970; continue 'dispatch;
	}
	// 82404960: 7D482830  slw r8, r10, r5
	if (ctx.r[5].u8 & 0x20) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = ((ctx.r[10].u32) << ((ctx.r[5].u8 & 0x1F) as u32)) as u64;
	}
	// 82404964: 7D0807B4  extsw r8, r8
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82404968: 7CC64392  divdu r6, r6, r8
	ctx.r[6].u64 = ctx.r[6].u64 / ctx.r[8].u64;
	// 8240496C: 08C80000  tdi 6, r8, 0
	// tdi: trap doubleword immediate  TODO: implement trap semantics
	pc = 0x82404970; continue 'dispatch;
            }
            0x82404970 => {
    //   block [0x82404970..0x82404988)
	// 82404970: 5145F83A  rlwimi r5, r10, 0x1f, 0, 0x1d
	ctx.r[5].u64 = (((ctx.r[10].u32).rotate_left(31) as u64) & 0x00000000FFFFFFFC) | (ctx.r[5].u64 & 0xFFFFFFFF00000003);
	// 82404974: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82404978: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8240497C: F8CB0008  std r6, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[6].u64 ) };
	// 82404980: 90AB0000  stw r5, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82404984: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404988 size=12
    let mut pc: u32 = 0x82404988;
    'dispatch: loop {
        match pc {
            0x82404988 => {
    //   block [0x82404988..0x82404994)
	// 82404988: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 8240498C: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 82404990: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404998 size=20
    let mut pc: u32 = 0x82404998;
    'dispatch: loop {
        match pc {
            0x82404998 => {
    //   block [0x82404998..0x824049AC)
	// 82404998: 2B040040  cmplwi cr6, r4, 0x40
	ctx.cr[6].compare_u32(ctx.r[4].u32, 64 as u32, &mut ctx.xer);
	// 8240499C: 41980010  blt cr6, 0x824049ac
	if ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x824049AC);
		return;
	}
	// 824049A0: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 824049A4: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 824049A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824049E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824049E8 size=24
    let mut pc: u32 = 0x824049E8;
    'dispatch: loop {
        match pc {
            0x824049E8 => {
    //   block [0x824049E8..0x82404A00)
	// 824049E8: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 824049EC: 2B040040  cmplwi cr6, r4, 0x40
	ctx.cr[6].compare_u32(ctx.r[4].u32, 64 as u32, &mut ctx.xer);
	// 824049F0: 41980010  blt cr6, 0x82404a00
	if ctx.cr[6].lt {
		sub_82404A00(ctx, base);
		return;
	}
	// 824049F4: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 824049F8: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 824049FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404A00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404A00 size=16
    let mut pc: u32 = 0x82404A00;
    'dispatch: loop {
        match pc {
            0x82404A00 => {
    //   block [0x82404A00..0x82404A10)
	// 82404A00: 2B04003F  cmplwi cr6, r4, 0x3f
	ctx.cr[6].compare_u32(ctx.r[4].u32, 63 as u32, &mut ctx.xer);
	// 82404A04: 409A000C  bne cr6, 0x82404a10
	if !ctx.cr[6].eq {
		sub_82404A10(ctx, base);
		return;
	}
	// 82404A08: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82404A0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404A10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404A10 size=40
    let mut pc: u32 = 0x82404A10;
    'dispatch: loop {
        match pc {
            0x82404A10 => {
    //   block [0x82404A10..0x82404A38)
	// 82404A10: 548A2036  slwi r10, r4, 4
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82404A14: 7D6A482E  lwzx r11, r10, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82404A18: 55680001  rlwinm. r8, r11, 0, 0, 0
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82404A1C: 4182001C  beq 0x82404a38
	if ctx.cr[0].eq {
		sub_82404A38(ctx, base);
		return;
	}
	// 82404A20: 55680043  rlwinm. r8, r11, 0, 1, 1
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82404A24: 41820014  beq 0x82404a38
	if ctx.cr[0].eq {
		sub_82404A38(ctx, base);
		return;
	}
	// 82404A28: 556B0080  rlwinm r11, r11, 0, 2, 0
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82404A2C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82404A30: 7D6A492E  stwx r11, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[11].u32) };
	// 82404A34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404A38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404A38 size=12
    let mut pc: u32 = 0x82404A38;
    'dispatch: loop {
        match pc {
            0x82404A38 => {
    //   block [0x82404A38..0x82404A44)
	// 82404A38: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82404A3C: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 82404A40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404A48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82404A48 size=268
    let mut pc: u32 = 0x82404A48;
    'dispatch: loop {
        match pc {
            0x82404A48 => {
    //   block [0x82404A48..0x82404AFC)
	// 82404A48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82404A4C: 48130669  bl 0x825350b4
	ctx.lr = 0x82404A50;
	sub_82535080(ctx, base);
	// 82404A50: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82404A54: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82404A58: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82404A5C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82404A60: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82404A64: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82404A68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82404A6C: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82404A70: 4BFFEA41  bl 0x824034b0
	ctx.lr = 0x82404A74;
	sub_824034B0(ctx, base);
	// 82404A74: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82404A78: 418000C8  blt 0x82404b40
	if ctx.cr[0].lt {
	pc = 0x82404B40; continue 'dispatch;
	}
	// 82404A7C: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404A80: 556A06BE  clrlwi r10, r11, 0x1a
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82404A84: 2B0A003F  cmplwi cr6, r10, 0x3f
	ctx.cr[6].compare_u32(ctx.r[10].u32, 63 as u32, &mut ctx.xer);
	// 82404A88: 419A00B8  beq cr6, 0x82404b40
	if ctx.cr[6].eq {
	pc = 0x82404B40; continue 'dispatch;
	}
	// 82404A8C: 556B0031  rlwinm. r11, r11, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82404A90: 41820088  beq 0x82404b18
	if ctx.cr[0].eq {
	pc = 0x82404B18; continue 'dispatch;
	}
	// 82404A94: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82404A98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82404A9C: 4BFFFDF5  bl 0x82404890
	ctx.lr = 0x82404AA0;
	sub_82404890(ctx, base);
	// 82404AA0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82404AA4: 4180009C  blt 0x82404b40
	if ctx.cr[0].lt {
	pc = 0x82404B40; continue 'dispatch;
	}
	// 82404AA8: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82404AAC: A0810050  lhz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82404AB0: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82404AB4: 4BFFEE15  bl 0x824038c8
	ctx.lr = 0x82404AB8;
	sub_824038C8(ctx, base);
	// 82404AB8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82404ABC: 41800084  blt 0x82404b40
	if ctx.cr[0].lt {
	pc = 0x82404B40; continue 'dispatch;
	}
	// 82404AC0: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404AC4: 57A907BE  clrlwi r9, r29, 0x1e
	ctx.r[9].u64 = ctx.r[29].u32 as u64 & 0x00000003u64;
	// 82404AC8: 556B06BE  clrlwi r11, r11, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82404ACC: 2B0B0040  cmplwi cr6, r11, 0x40
	ctx.cr[6].compare_u32(ctx.r[11].u32, 64 as u32, &mut ctx.xer);
	// 82404AD0: 40980078  bge cr6, 0x82404b48
	if !ctx.cr[6].lt {
	pc = 0x82404B48; continue 'dispatch;
	}
	// 82404AD4: 2B090003  cmplwi cr6, r9, 3
	ctx.cr[6].compare_u32(ctx.r[9].u32, 3 as u32, &mut ctx.xer);
	// 82404AD8: 41990070  bgt cr6, 0x82404b48
	if ctx.cr[6].gt {
	pc = 0x82404B48; continue 'dispatch;
	}
	// 82404ADC: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82404AE0: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82404AE4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404AE8: 554A0043  rlwinm. r10, r10, 0, 1, 1
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82404AEC: 41820010  beq 0x82404afc
	if ctx.cr[0].eq {
	pc = 0x82404AFC; continue 'dispatch;
	}
	// 82404AF0: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82404AF4: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 82404AF8: 48000048  b 0x82404b40
	pc = 0x82404B40; continue 'dispatch;
            }
            0x82404AFC => {
    //   block [0x82404AFC..0x82404B18)
	// 82404AFC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82404B00: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82404B04: 5149F83A  rlwimi r9, r10, 0x1f, 0, 0x1d
	ctx.r[9].u64 = (((ctx.r[10].u32).rotate_left(31) as u64) & 0x00000000FFFFFFFC) | (ctx.r[9].u64 & 0xFFFFFFFF00000003);
	// 82404B08: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82404B0C: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82404B10: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 82404B14: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	pc = 0x82404B18; continue 'dispatch;
            }
            0x82404B18 => {
    //   block [0x82404B18..0x82404B40)
	// 82404B18: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404B1C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82404B20: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82404B24: 556406BE  clrlwi r4, r11, 0x1a
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82404B28: 4BFFFE71  bl 0x82404998
	ctx.lr = 0x82404B2C;
	sub_82404998(ctx, base);
	// 82404B2C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82404B30: 41800010  blt 0x82404b40
	if ctx.cr[0].lt {
	pc = 0x82404B40; continue 'dispatch;
	}
	// 82404B34: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82404B38: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82404B3C: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82404B40; continue 'dispatch;
            }
            0x82404B40 => {
    //   block [0x82404B40..0x82404B48)
	// 82404B40: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82404B44: 481305C0  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            0x82404B48 => {
    //   block [0x82404B48..0x82404B54)
	// 82404B48: 3C608007  lis r3, -0x7ff9
	ctx.r[3].s64 = -2147024896;
	// 82404B4C: 60630057  ori r3, r3, 0x57
	ctx.r[3].u64 = ctx.r[3].u64 | 87;
	// 82404B50: 4BFFFFF0  b 0x82404b40
	pc = 0x82404B40; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404B58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82404B58 size=240
    let mut pc: u32 = 0x82404B58;
    'dispatch: loop {
        match pc {
            0x82404B58 => {
    //   block [0x82404B58..0x82404BD8)
	// 82404B58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82404B5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82404B60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82404B64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82404B68: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82404B6C: 548B2036  slwi r11, r4, 4
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82404B70: F8A100B0  std r5, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[5].u64 ) };
	// 82404B74: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82404B78: 7FEB1A14  add r31, r11, r3
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82404B7C: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 82404B80: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82404B84: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82404B88: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404B8C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82404B90: 556B07BE  clrlwi r11, r11, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 82404B94: 7D465830  slw r6, r10, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = ((ctx.r[10].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 82404B98: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82404B9C: 90C10054  stw r6, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[6].u32 ) };
	// 82404BA0: 4BFFF8C1  bl 0x82404460
	ctx.lr = 0x82404BA4;
	sub_82404460(ctx, base);
	// 82404BA4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404BA8: 556B07BE  clrlwi r11, r11, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 82404BAC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82404BB0: 41980060  blt cr6, 0x82404c10
	if ctx.cr[6].lt {
	pc = 0x82404C10; continue 'dispatch;
	}
	// 82404BB4: 419A0040  beq cr6, 0x82404bf4
	if ctx.cr[6].eq {
	pc = 0x82404BF4; continue 'dispatch;
	}
	// 82404BB8: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82404BBC: 4198001C  blt cr6, 0x82404bd8
	if ctx.cr[6].lt {
	pc = 0x82404BD8; continue 'dispatch;
	}
	// 82404BC0: 409A006C  bne cr6, 0x82404c2c
	if !ctx.cr[6].eq {
	pc = 0x82404C2C; continue 'dispatch;
	}
	// 82404BC4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82404BC8: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82404BCC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82404BD0: 4BFFFB89  bl 0x82404758
	ctx.lr = 0x82404BD4;
	sub_82404758(ctx, base);
	// 82404BD4: 48000054  b 0x82404c28
	pc = 0x82404C28; continue 'dispatch;
            }
            0x82404BD8 => {
    //   block [0x82404BD8..0x82404BF4)
	// 82404BD8: E96100B0  ld r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 82404BDC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82404BE0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82404BE4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82404BE8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82404BEC: 4BFFFAE5  bl 0x824046d0
	ctx.lr = 0x82404BF0;
	sub_824046D0(ctx, base);
	// 82404BF0: 48000038  b 0x82404c28
	pc = 0x82404C28; continue 'dispatch;
            }
            0x82404BF4 => {
    //   block [0x82404BF4..0x82404C10)
	// 82404BF4: E96100B0  ld r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 82404BF8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82404BFC: 38810052  addi r4, r1, 0x52
	ctx.r[4].s64 = ctx.r[1].s64 + 82;
	// 82404C00: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82404C04: B1610052  sth r11, 0x52(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u16 ) };
	// 82404C08: 4BFFFA49  bl 0x82404650
	ctx.lr = 0x82404C0C;
	sub_82404650(ctx, base);
	// 82404C0C: 4800001C  b 0x82404c28
	pc = 0x82404C28; continue 'dispatch;
            }
            0x82404C10 => {
    //   block [0x82404C10..0x82404C28)
	// 82404C10: E96100B0  ld r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 82404C14: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82404C18: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82404C1C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82404C20: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82404C24: 4BFFF9B5  bl 0x824045d8
	ctx.lr = 0x82404C28;
	sub_824045D8(ctx, base);
	pc = 0x82404C28; continue 'dispatch;
            }
            0x82404C28 => {
    //   block [0x82404C28..0x82404C2C)
	// 82404C28: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	pc = 0x82404C2C; continue 'dispatch;
            }
            0x82404C2C => {
    //   block [0x82404C2C..0x82404C48)
	// 82404C2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82404C30: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82404C34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82404C38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82404C3C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82404C40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82404C44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404C48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82404C48 size=152
    let mut pc: u32 = 0x82404C48;
    'dispatch: loop {
        match pc {
            0x82404C48 => {
    //   block [0x82404C48..0x82404C88)
	// 82404C48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82404C4C: 48130471  bl 0x825350bc
	ctx.lr = 0x82404C50;
	sub_82535080(ctx, base);
	// 82404C50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82404C54: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82404C58: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82404C5C: 396BBD38  addi r11, r11, -0x42c8
	ctx.r[11].s64 = ctx.r[11].s64 + -17096;
	// 82404C60: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82404C64: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82404C68: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82404C6C: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82404C70: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82404C74: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82404C78: 41820058  beq 0x82404cd0
	if ctx.cr[0].eq {
	pc = 0x82404CD0; continue 'dispatch;
	}
	// 82404C7C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82404C80: 4182004C  beq 0x82404ccc
	if ctx.cr[0].eq {
	pc = 0x82404CCC; continue 'dispatch;
	}
	// 82404C84: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82404C88; continue 'dispatch;
            }
            0x82404C88 => {
    //   block [0x82404C88..0x82404CCC)
	// 82404C88: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404C8C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82404C90: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82404C94: 409AFFF4  bne cr6, 0x82404c88
	if !ctx.cr[6].eq {
	pc = 0x82404C88; continue 'dispatch;
	}
	// 82404C98: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82404C9C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82404CA0: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82404CA4: 3BEB0001  addi r31, r11, 1
	ctx.r[31].s64 = ctx.r[11].s64 + 1;
	// 82404CA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82404CAC: 4812EFC5  bl 0x82533c70
	ctx.lr = 0x82404CB0;
	sub_82533C70(ctx, base);
	// 82404CB0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82404CB4: 907E0004  stw r3, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82404CB8: 4182001C  beq 0x82404cd4
	if ctx.cr[0].eq {
	pc = 0x82404CD4; continue 'dispatch;
	}
	// 82404CBC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82404CC0: 80BD0004  lwz r5, 4(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82404CC4: 481305AD  bl 0x82535270
	ctx.lr = 0x82404CC8;
	sub_82535270(ctx, base);
	// 82404CC8: 4800000C  b 0x82404cd4
	pc = 0x82404CD4; continue 'dispatch;
            }
            0x82404CCC => {
    //   block [0x82404CCC..0x82404CD0)
	// 82404CCC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82404CD0; continue 'dispatch;
            }
            0x82404CD0 => {
    //   block [0x82404CD0..0x82404CD4)
	// 82404CD0: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82404CD4; continue 'dispatch;
            }
            0x82404CD4 => {
    //   block [0x82404CD4..0x82404CE0)
	// 82404CD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82404CD8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82404CDC: 48130430  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404CE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404CE0 size=24
    let mut pc: u32 = 0x82404CE0;
    'dispatch: loop {
        match pc {
            0x82404CE0 => {
    //   block [0x82404CE0..0x82404CF8)
	// 82404CE0: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82404CE4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82404CE8: 4C820020  bnelr
	if !ctx.cr[0].eq { return; }
	// 82404CEC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82404CF0: 386BBD24  addi r3, r11, -0x42dc
	ctx.r[3].s64 = ctx.r[11].s64 + -17116;
	// 82404CF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82404CF8 size=104
    let mut pc: u32 = 0x82404CF8;
    'dispatch: loop {
        match pc {
            0x82404CF8 => {
    //   block [0x82404CF8..0x82404D34)
	// 82404CF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82404CFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82404D00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82404D04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82404D08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82404D0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82404D10: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82404D14: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82404D18: 396BBD38  addi r11, r11, -0x42c8
	ctx.r[11].s64 = ctx.r[11].s64 + -17096;
	// 82404D1C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82404D20: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82404D24: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82404D28: 419A000C  beq cr6, 0x82404d34
	if ctx.cr[6].eq {
	pc = 0x82404D34; continue 'dispatch;
	}
	// 82404D2C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82404D30: 4812F009  bl 0x82533d38
	ctx.lr = 0x82404D34;
	sub_82533D38(ctx, base);
	pc = 0x82404D34; continue 'dispatch;
            }
            0x82404D34 => {
    //   block [0x82404D34..0x82404D44)
	// 82404D34: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82404D38: 4182000C  beq 0x82404d44
	if ctx.cr[0].eq {
	pc = 0x82404D44; continue 'dispatch;
	}
	// 82404D3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82404D40: 4812DE79  bl 0x82532bb8
	ctx.lr = 0x82404D44;
	sub_82532BB8(ctx, base);
	pc = 0x82404D44; continue 'dispatch;
            }
            0x82404D44 => {
    //   block [0x82404D44..0x82404D60)
	// 82404D44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82404D48: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82404D4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82404D50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82404D54: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82404D58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82404D5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404D60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404D60 size=40
    let mut pc: u32 = 0x82404D60;
    'dispatch: loop {
        match pc {
            0x82404D60 => {
    //   block [0x82404D60..0x82404D88)
	// 82404D60: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82404D64: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82404D68: 396BBD38  addi r11, r11, -0x42c8
	ctx.r[11].s64 = ctx.r[11].s64 + -17096;
	// 82404D6C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82404D70: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82404D74: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82404D78: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82404D7C: 4812EFBC  b 0x82533d38
	sub_82533D38(ctx, base);
	return;
	// 82404D80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404D88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82404D88 size=60
    let mut pc: u32 = 0x82404D88;
    'dispatch: loop {
        match pc {
            0x82404D88 => {
    //   block [0x82404D88..0x82404DC4)
	// 82404D88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82404D8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82404D90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82404D94: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82404D98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82404D9C: 4BFFFEAD  bl 0x82404c48
	ctx.lr = 0x82404DA0;
	sub_82404C48(ctx, base);
	// 82404DA0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82404DA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82404DA8: 396BBD38  addi r11, r11, -0x42c8
	ctx.r[11].s64 = ctx.r[11].s64 + -17096;
	// 82404DAC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82404DB0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82404DB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82404DB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82404DBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82404DC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404DC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82404DC8 size=192
    let mut pc: u32 = 0x82404DC8;
    'dispatch: loop {
        match pc {
            0x82404DC8 => {
    //   block [0x82404DC8..0x82404DE4)
	// 82404DC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82404DCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82404DD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82404DD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82404DD8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82404DDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82404DE0: 48000014  b 0x82404df4
	pc = 0x82404DF4; continue 'dispatch;
            }
            0x82404DE4 => {
    //   block [0x82404DE4..0x82404DF4)
	// 82404DE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82404DE8: 48131911  bl 0x825366f8
	ctx.lr = 0x82404DEC;
	sub_825366F8(ctx, base);
	// 82404DEC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82404DF0: 4182002C  beq 0x82404e1c
	if ctx.cr[0].eq {
	pc = 0x82404E1C; continue 'dispatch;
	}
	pc = 0x82404DF4; continue 'dispatch;
            }
            0x82404DF4 => {
    //   block [0x82404DF4..0x82404E1C)
	// 82404DF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82404DF8: 4812EE79  bl 0x82533c70
	ctx.lr = 0x82404DFC;
	sub_82533C70(ctx, base);
	// 82404DFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82404E00: 4182FFE4  beq 0x82404de4
	if ctx.cr[0].eq {
	pc = 0x82404DE4; continue 'dispatch;
	}
	// 82404E04: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82404E08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82404E0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82404E10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82404E14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82404E18: 4E800020  blr
	return;
            }
            0x82404E1C => {
    //   block [0x82404E1C..0x82404E68)
	// 82404E1C: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 82404E20: 816A381C  lwz r11, 0x381c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(14364 as u32) ) } as u64;
	// 82404E24: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82404E28: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82404E2C: 3BC9BD38  addi r30, r9, -0x42c8
	ctx.r[30].s64 = ctx.r[9].s64 + -17096;
	// 82404E30: 3D208288  lis r9, -0x7d78
	ctx.r[9].s64 = -2105016320;
	// 82404E34: 3BE93810  addi r31, r9, 0x3810
	ctx.r[31].s64 = ctx.r[9].s64 + 14352;
	// 82404E38: 40820030  bne 0x82404e68
	if !ctx.cr[0].eq {
	pc = 0x82404E68; continue 'dispatch;
	}
	// 82404E3C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82404E40: 3D208271  lis r9, -0x7d8f
	ctx.r[9].s64 = -2106523648;
	// 82404E44: 3869CC18  addi r3, r9, -0x33e8
	ctx.r[3].s64 = ctx.r[9].s64 + -13288;
	// 82404E48: 916A381C  stw r11, 0x381c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(14364 as u32), ctx.r[11].u32 ) };
	// 82404E4C: 3D608273  lis r11, -0x7d8d
	ctx.r[11].s64 = -2106392576;
	// 82404E50: 816B31A0  lwz r11, 0x31a0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12704 as u32) ) } as u64;
	// 82404E54: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82404E58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82404E5C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82404E60: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82404E64: 4812DCD5  bl 0x82532b38
	ctx.lr = 0x82404E68;
	sub_82532B38(ctx, base);
	pc = 0x82404E68; continue 'dispatch;
            }
            0x82404E68 => {
    //   block [0x82404E68..0x82404E88)
	// 82404E68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82404E6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82404E70: 4BFFFDD9  bl 0x82404c48
	ctx.lr = 0x82404E74;
	sub_82404C48(ctx, base);
	// 82404E74: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82404E78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82404E7C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82404E80: 388BA6AC  addi r4, r11, -0x5954
	ctx.r[4].s64 = ctx.r[11].s64 + -22868;
	// 82404E84: 481318BD  bl 0x82536740
	ctx.lr = 0x82404E88;
	sub_82536740(ctx, base);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404E88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82404E88 size=144
    let mut pc: u32 = 0x82404E88;
    'dispatch: loop {
        match pc {
            0x82404E88 => {
    //   block [0x82404E88..0x82404ED0)
	// 82404E88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82404E8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82404E90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82404E94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82404E98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82404E9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82404EA0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82404EA4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82404EA8: 48132221  bl 0x825370c8
	ctx.lr = 0x82404EAC;
	sub_825370C8(ctx, base);
	// 82404EAC: 48131C7D  bl 0x82536b28
	ctx.lr = 0x82404EB0;
	sub_82536B28(ctx, base);
	// 82404EB0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82404EB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82404EB8: 388B0040  addi r4, r11, 0x40
	ctx.r[4].s64 = ctx.r[11].s64 + 64;
	// 82404EBC: 48131A3D  bl 0x825368f8
	ctx.lr = 0x82404EC0;
	sub_825368F8(ctx, base);
	// 82404EC0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82404EC4: 409A000C  bne cr6, 0x82404ed0
	if !ctx.cr[6].eq {
	pc = 0x82404ED0; continue 'dispatch;
	}
	// 82404EC8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82404ECC: 3BEBCD5C  addi r31, r11, -0x32a4
	ctx.r[31].s64 = ctx.r[11].s64 + -12964;
	pc = 0x82404ED0; continue 'dispatch;
            }
            0x82404ED0 => {
    //   block [0x82404ED0..0x82404F18)
	// 82404ED0: 48131C59  bl 0x82536b28
	ctx.lr = 0x82404ED4;
	sub_82536B28(ctx, base);
	// 82404ED4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82404ED8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82404EDC: 388B0040  addi r4, r11, 0x40
	ctx.r[4].s64 = ctx.r[11].s64 + 64;
	// 82404EE0: 48131A19  bl 0x825368f8
	ctx.lr = 0x82404EE4;
	sub_825368F8(ctx, base);
	// 82404EE4: 48131C45  bl 0x82536b28
	ctx.lr = 0x82404EE8;
	sub_82536B28(ctx, base);
	// 82404EE8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82404EEC: 38830040  addi r4, r3, 0x40
	ctx.r[4].s64 = ctx.r[3].s64 + 64;
	// 82404EF0: 396B4CC4  addi r11, r11, 0x4cc4
	ctx.r[11].s64 = ctx.r[11].s64 + 19652;
	// 82404EF4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82404EF8: 48131A01  bl 0x825368f8
	ctx.lr = 0x82404EFC;
	sub_825368F8(ctx, base);
	// 82404EFC: 48131925  bl 0x82536820
	ctx.lr = 0x82404F00;
	sub_82536820(ctx, base);
	// 82404F00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82404F04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82404F08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82404F0C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82404F10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82404F14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404F18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82404F18 size=64
    let mut pc: u32 = 0x82404F18;
    'dispatch: loop {
        match pc {
            0x82404F18 => {
    //   block [0x82404F18..0x82404F58)
	// 82404F18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82404F1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82404F20: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82404F24: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82404F28: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82404F2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82404F30: 4E800421  bctrl
	ctx.lr = 0x82404F34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82404F34: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82404F38: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82404F3C: 396BBD40  addi r11, r11, -0x42c0
	ctx.r[11].s64 = ctx.r[11].s64 + -17088;
	// 82404F40: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82404F44: 4BFFFF45  bl 0x82404e88
	ctx.lr = 0x82404F48;
	sub_82404E88(ctx, base);
	// 82404F48: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82404F4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82404F50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82404F54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404F58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82404F58 size=4
    let mut pc: u32 = 0x82404F58;
    'dispatch: loop {
        match pc {
            0x82404F58 => {
    //   block [0x82404F58..0x82404F5C)
	// 82404F58: 4BFFFE70  b 0x82404dc8
	sub_82404DC8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82404F68 size=116
    let mut pc: u32 = 0x82404F68;
    'dispatch: loop {
        match pc {
            0x82404F68 => {
    //   block [0x82404F68..0x82404FDC)
	// 82404F68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82404F6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82404F70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82404F74: 3BE1FF50  addi r31, r1, -0xb0
	ctx.r[31].s64 = ctx.r[1].s64 + -176;
	// 82404F78: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82404F7C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82404F80: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 82404F84: 388BBD4C  addi r4, r11, -0x42b4
	ctx.r[4].s64 = ctx.r[11].s64 + -17076;
	// 82404F88: 4BF02371  bl 0x823072f8
	ctx.lr = 0x82404F8C;
	sub_823072F8(ctx, base);
	// 82404F8C: 389F0050  addi r4, r31, 0x50
	ctx.r[4].s64 = ctx.r[31].s64 + 80;
	// 82404F90: 387F0070  addi r3, r31, 0x70
	ctx.r[3].s64 = ctx.r[31].s64 + 112;
	// 82404F94: 4BF01DC5  bl 0x82306d58
	ctx.lr = 0x82404F98;
	sub_82306D58(ctx, base);
	// 82404F98: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82404F9C: 387F0070  addi r3, r31, 0x70
	ctx.r[3].s64 = ctx.r[31].s64 + 112;
	// 82404FA0: 388BA700  addi r4, r11, -0x5900
	ctx.r[4].s64 = ctx.r[11].s64 + -22784;
	// 82404FA4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82404FA8: 396BCD70  addi r11, r11, -0x3290
	ctx.r[11].s64 = ctx.r[11].s64 + -12944;
	// 82404FAC: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82404FB0: 48131791  bl 0x82536740
	ctx.lr = 0x82404FB4;
	sub_82536740(ctx, base);
	// 82404FB4: 3BECFF50  addi r31, r12, -0xb0
	ctx.r[31].s64 = ctx.r[12].s64 + -176;
	// 82404FB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82404FBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82404FC0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82404FC4: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 82404FC8: 4BF01FA1  bl 0x82306f68
	ctx.lr = 0x82404FCC;
	sub_82306F68(ctx, base);
	// 82404FCC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82404FD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82404FD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82404FD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82404FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82404FE8 size=112
    let mut pc: u32 = 0x82404FE8;
    'dispatch: loop {
        match pc {
            0x82404FE8 => {
    //   block [0x82404FE8..0x82405058)
	// 82404FE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82404FEC: 481300D1  bl 0x825350bc
	ctx.lr = 0x82404FF0;
	sub_82535080(ctx, base);
	// 82404FF0: 3BE1FF90  addi r31, r1, -0x70
	ctx.r[31].s64 = ctx.r[1].s64 + -112;
	// 82404FF4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82404FF8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82404FFC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82405000: 93DF0084  stw r30, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 82405004: 4BFFFC45  bl 0x82404c48
	ctx.lr = 0x82405008;
	sub_82404C48(ctx, base);
	// 82405008: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8240500C: 389D000C  addi r4, r29, 0xc
	ctx.r[4].s64 = ctx.r[29].s64 + 12;
	// 82405010: 396BCD64  addi r11, r11, -0x329c
	ctx.r[11].s64 = ctx.r[11].s64 + -12956;
	// 82405014: 387E000C  addi r3, r30, 0xc
	ctx.r[3].s64 = ctx.r[30].s64 + 12;
	// 82405018: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8240501C: 4BF01EFD  bl 0x82306f18
	ctx.lr = 0x82405020;
	sub_82306F18(ctx, base);
	// 82405020: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82405024: 383F0070  addi r1, r31, 0x70
	ctx.r[1].s64 = ctx.r[31].s64 + 112;
	// 82405028: 481300E4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
	// 8240502C: 3BECFF90  addi r31, r12, -0x70
	ctx.r[31].s64 = ctx.r[12].s64 + -112;
	// 82405030: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82405034: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82405038: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240503C: 807F0084  lwz r3, 0x84(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82405040: 4BFFFD21  bl 0x82404d60
	ctx.lr = 0x82405044;
	sub_82404D60(ctx, base);
	// 82405044: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82405048: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8240504C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82405050: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82405058 size=60
    let mut pc: u32 = 0x82405058;
    'dispatch: loop {
        match pc {
            0x82405058 => {
    //   block [0x82405058..0x82405094)
	// 82405058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240505C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82405060: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82405064: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82405068: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8240506C: 4BFFFF7D  bl 0x82404fe8
	ctx.lr = 0x82405070;
	sub_82404FE8(ctx, base);
	// 82405070: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82405074: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82405078: 396BCD70  addi r11, r11, -0x3290
	ctx.r[11].s64 = ctx.r[11].s64 + -12944;
	// 8240507C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82405080: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82405084: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82405088: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8240508C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82405090: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824050A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824050A0 size=116
    let mut pc: u32 = 0x824050A0;
    'dispatch: loop {
        match pc {
            0x824050A0 => {
    //   block [0x824050A0..0x82405114)
	// 824050A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824050A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824050A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824050AC: 3BE1FF50  addi r31, r1, -0xb0
	ctx.r[31].s64 = ctx.r[1].s64 + -176;
	// 824050B0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824050B4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824050B8: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 824050BC: 388BBDD0  addi r4, r11, -0x4230
	ctx.r[4].s64 = ctx.r[11].s64 + -16944;
	// 824050C0: 4BF02239  bl 0x823072f8
	ctx.lr = 0x824050C4;
	sub_823072F8(ctx, base);
	// 824050C4: 389F0050  addi r4, r31, 0x50
	ctx.r[4].s64 = ctx.r[31].s64 + 80;
	// 824050C8: 387F0070  addi r3, r31, 0x70
	ctx.r[3].s64 = ctx.r[31].s64 + 112;
	// 824050CC: 4BF01C8D  bl 0x82306d58
	ctx.lr = 0x824050D0;
	sub_82306D58(ctx, base);
	// 824050D0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 824050D4: 387F0070  addi r3, r31, 0x70
	ctx.r[3].s64 = ctx.r[31].s64 + 112;
	// 824050D8: 388BA758  addi r4, r11, -0x58a8
	ctx.r[4].s64 = ctx.r[11].s64 + -22696;
	// 824050DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824050E0: 396B05F4  addi r11, r11, 0x5f4
	ctx.r[11].s64 = ctx.r[11].s64 + 1524;
	// 824050E4: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 824050E8: 48131659  bl 0x82536740
	ctx.lr = 0x824050EC;
	sub_82536740(ctx, base);
	// 824050EC: 3BECFF50  addi r31, r12, -0xb0
	ctx.r[31].s64 = ctx.r[12].s64 + -176;
	// 824050F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824050F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824050F8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824050FC: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 82405100: 4BF01E69  bl 0x82306f68
	ctx.lr = 0x82405104;
	sub_82306F68(ctx, base);
	// 82405104: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82405108: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8240510C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82405110: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82405118 size=60
    let mut pc: u32 = 0x82405118;
    'dispatch: loop {
        match pc {
            0x82405118 => {
    //   block [0x82405118..0x82405154)
	// 82405118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240511C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82405120: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82405124: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82405128: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8240512C: 4BFFFEBD  bl 0x82404fe8
	ctx.lr = 0x82405130;
	sub_82404FE8(ctx, base);
	// 82405130: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82405134: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82405138: 396B05F4  addi r11, r11, 0x5f4
	ctx.r[11].s64 = ctx.r[11].s64 + 1524;
	// 8240513C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82405140: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82405144: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82405148: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8240514C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82405150: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82405158 size=48
    let mut pc: u32 = 0x82405158;
    'dispatch: loop {
        match pc {
            0x82405158 => {
    //   block [0x82405158..0x82405188)
	// 82405158: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8240515C: 816B5868  lwz r11, 0x5868(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22632 as u32) ) } as u64;
	// 82405160: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82405164: 40980024  bge cr6, 0x82405188
	if !ctx.cr[6].lt {
		sub_82405188(ctx, base);
		return;
	}
	// 82405168: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 8240516C: 4198001C  blt cr6, 0x82405188
	if ctx.cr[6].lt {
		sub_82405188(ctx, base);
		return;
	}
	// 82405170: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82405174: 1D43132C  mulli r10, r3, 0x132c
	ctx.r[10].s32 = ((ctx.r[3].s32 as i64 * 4908 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82405178: 396B5870  addi r11, r11, 0x5870
	ctx.r[11].s64 = ctx.r[11].s64 + 22640;
	// 8240517C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82405180: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82405184: 480025E4  b 0x82407768
	crate::recompiler::externs::call(ctx, base, 0x82407768);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82405188 size=12
    let mut pc: u32 = 0x82405188;
    'dispatch: loop {
        match pc {
            0x82405188 => {
    //   block [0x82405188..0x82405194)
	// 82405188: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 8240518C: 6063000A  ori r3, r3, 0xa
	ctx.r[3].u64 = ctx.r[3].u64 | 10;
	// 82405190: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82405198 size=48
    let mut pc: u32 = 0x82405198;
    'dispatch: loop {
        match pc {
            0x82405198 => {
    //   block [0x82405198..0x824051C8)
	// 82405198: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8240519C: 816B5868  lwz r11, 0x5868(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22632 as u32) ) } as u64;
	// 824051A0: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824051A4: 40980024  bge cr6, 0x824051c8
	if !ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x824051C8);
		return;
	}
	// 824051A8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 824051AC: 4198001C  blt cr6, 0x824051c8
	if ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x824051C8);
		return;
	}
	// 824051B0: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 824051B4: 1D43132C  mulli r10, r3, 0x132c
	ctx.r[10].s32 = ((ctx.r[3].s32 as i64 * 4908 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 824051B8: 396B5870  addi r11, r11, 0x5870
	ctx.r[11].s64 = ctx.r[11].s64 + 22640;
	// 824051BC: 396B0050  addi r11, r11, 0x50
	ctx.r[11].s64 = ctx.r[11].s64 + 80;
	// 824051C0: 7C6A5AAE  lhax r3, r10, r11
	ctx.r[3].s64 = (unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as i16) as i64;
	// 824051C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824051D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824051D8 size=56
    let mut pc: u32 = 0x824051D8;
    'dispatch: loop {
        match pc {
            0x824051D8 => {
    //   block [0x824051D8..0x82405204)
	// 824051D8: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 824051DC: 816B5868  lwz r11, 0x5868(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22632 as u32) ) } as u64;
	// 824051E0: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824051E4: 40980020  bge cr6, 0x82405204
	if !ctx.cr[6].lt {
	pc = 0x82405204; continue 'dispatch;
	}
	// 824051E8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 824051EC: 41980018  blt cr6, 0x82405204
	if ctx.cr[6].lt {
	pc = 0x82405204; continue 'dispatch;
	}
	// 824051F0: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 824051F4: 1D43132C  mulli r10, r3, 0x132c
	ctx.r[10].s32 = ((ctx.r[3].s32 as i64 * 4908 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 824051F8: 396B5870  addi r11, r11, 0x5870
	ctx.r[11].s64 = ctx.r[11].s64 + 22640;
	// 824051FC: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82405200: 48002540  b 0x82407740
	crate::recompiler::externs::call(ctx, base, 0x82407740);
	return;
            }
            0x82405204 => {
    //   block [0x82405204..0x82405210)
	// 82405204: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82405208: 6063000A  ori r3, r3, 0xa
	ctx.r[3].u64 = ctx.r[3].u64 | 10;
	// 8240520C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82405210 size=12
    let mut pc: u32 = 0x82405210;
    'dispatch: loop {
        match pc {
            0x82405210 => {
    //   block [0x82405210..0x8240521C)
	// 82405210: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82405214: 806B5868  lwz r3, 0x5868(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22632 as u32) ) } as u64;
	// 82405218: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82405220 size=316
    let mut pc: u32 = 0x82405220;
    'dispatch: loop {
        match pc {
            0x82405220 => {
    //   block [0x82405220..0x82405278)
	// 82405220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82405224: 4812FE91  bl 0x825350b4
	ctx.lr = 0x82405228;
	sub_82535080(ctx, base);
	// 82405228: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240522C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82405230: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82405234: 48001C1D  bl 0x82406e50
	ctx.lr = 0x82405238;
	sub_82406E50(ctx, base);
	// 82405238: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8240523C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82405240: 3BEB3824  addi r31, r11, 0x3824
	ctx.r[31].s64 = ctx.r[11].s64 + 14372;
	// 82405244: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82405248: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8240524C: 409A00F4  bne cr6, 0x82405340
	if !ctx.cr[6].eq {
	pc = 0x82405340; continue 'dispatch;
	}
	// 82405250: 3FA08273  lis r29, -0x7d8d
	ctx.r[29].s64 = -2106392576;
	// 82405254: 3C600002  lis r3, 2
	ctx.r[3].s64 = 131072;
	// 82405258: 60632A24  ori r3, r3, 0x2a24
	ctx.r[3].u64 = ctx.r[3].u64 | 10788;
	// 8240525C: 817D3800  lwz r11, 0x3800(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14336 as u32) ) } as u64;
	// 82405260: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82405264: 4E800421  bctrl
	ctx.lr = 0x82405268;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82405268: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8240526C: 4182000C  beq 0x82405278
	if ctx.cr[0].eq {
	pc = 0x82405278; continue 'dispatch;
	}
	// 82405270: 48002551  bl 0x824077c0
	ctx.lr = 0x82405274;
	sub_824077C0(ctx, base);
	// 82405274: 48000008  b 0x8240527c
	pc = 0x8240527C; continue 'dispatch;
            }
            0x82405278 => {
    //   block [0x82405278..0x8240527C)
	// 82405278: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x8240527C; continue 'dispatch;
            }
            0x8240527C => {
    //   block [0x8240527C..0x824052A8)
	// 8240527C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82405280: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82405284: 48002585  bl 0x82407808
	ctx.lr = 0x82405288;
	sub_82407808(ctx, base);
	// 82405288: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8240528C: 2F040001  cmpwi cr6, r4, 1
	ctx.cr[6].compare_i32(ctx.r[4].s32, 1, &mut ctx.xer);
	// 82405290: 419A0018  beq cr6, 0x824052a8
	if ctx.cr[6].eq {
	pc = 0x824052A8; continue 'dispatch;
	}
	// 82405294: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82405298: 386BBE54  addi r3, r11, -0x41ac
	ctx.r[3].s64 = ctx.r[11].s64 + -16812;
	// 8240529C: 4BEADCE5  bl 0x822b2f80
	ctx.lr = 0x824052A0;
	sub_822B2F80(ctx, base);
	// 824052A0: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 824052A4: 480000B0  b 0x82405354
	pc = 0x82405354; continue 'dispatch;
            }
            0x824052A8 => {
    //   block [0x824052A8..0x824052D4)
	// 824052A8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824052AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 824052B0: 409A002C  bne cr6, 0x824052dc
	if !ctx.cr[6].eq {
	pc = 0x824052DC; continue 'dispatch;
	}
	// 824052B4: 817D3800  lwz r11, 0x3800(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14336 as u32) ) } as u64;
	// 824052B8: 38601C5C  li r3, 0x1c5c
	ctx.r[3].s64 = 7260;
	// 824052BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824052C0: 4E800421  bctrl
	ctx.lr = 0x824052C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824052C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 824052C8: 4182000C  beq 0x824052d4
	if ctx.cr[0].eq {
	pc = 0x824052D4; continue 'dispatch;
	}
	// 824052CC: 4800288D  bl 0x82407b58
	ctx.lr = 0x824052D0;
	sub_82407B58(ctx, base);
	// 824052D0: 48000008  b 0x824052d8
	pc = 0x824052D8; continue 'dispatch;
            }
            0x824052D4 => {
    //   block [0x824052D4..0x824052D8)
	// 824052D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x824052D8; continue 'dispatch;
            }
            0x824052D8 => {
    //   block [0x824052D8..0x824052DC)
	// 824052D8: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	pc = 0x824052DC; continue 'dispatch;
            }
            0x824052DC => {
    //   block [0x824052DC..0x82405310)
	// 824052DC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824052E0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824052E4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824052E8: 38AB0004  addi r5, r11, 4
	ctx.r[5].s64 = ctx.r[11].s64 + 4;
	// 824052EC: 48004B15  bl 0x82409e00
	ctx.lr = 0x824052F0;
	sub_82409E00(ctx, base);
	// 824052F0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 824052F4: 40820060  bne 0x82405354
	if !ctx.cr[0].eq {
	pc = 0x82405354; continue 'dispatch;
	}
	// 824052F8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 824052FC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82405300: 48002669  bl 0x82407968
	ctx.lr = 0x82405304;
	sub_82407968(ctx, base);
	// 82405304: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82405308: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 8240530C: 4099002C  ble cr6, 0x82405338
	if !ctx.cr[6].gt {
	pc = 0x82405338; continue 'dispatch;
	}
	pc = 0x82405310; continue 'dispatch;
            }
            0x82405310 => {
    //   block [0x82405310..0x82405338)
	// 82405310: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82405314: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82405318: 480031E1  bl 0x824084f8
	ctx.lr = 0x8240531C;
	sub_824084F8(ctx, base);
	// 8240531C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82405320: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82405324: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82405328: 48002569  bl 0x82407890
	ctx.lr = 0x8240532C;
	sub_82407890(ctx, base);
	// 8240532C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82405330: 7F1EE000  cmpw cr6, r30, r28
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[28].s32, &mut ctx.xer);
	// 82405334: 4198FFDC  blt cr6, 0x82405310
	if ctx.cr[6].lt {
	pc = 0x82405310; continue 'dispatch;
	}
	pc = 0x82405338; continue 'dispatch;
            }
            0x82405338 => {
    //   block [0x82405338..0x82405340)
	// 82405338: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8240533C: 48000018  b 0x82405354
	pc = 0x82405354; continue 'dispatch;
            }
            0x82405340 => {
    //   block [0x82405340..0x82405354)
	// 82405340: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82405344: 386BBE20  addi r3, r11, -0x41e0
	ctx.r[3].s64 = ctx.r[11].s64 + -16864;
	// 82405348: 4BEADC39  bl 0x822b2f80
	ctx.lr = 0x8240534C;
	sub_822B2F80(ctx, base);
	// 8240534C: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82405350: 60630028  ori r3, r3, 0x28
	ctx.r[3].u64 = ctx.r[3].u64 | 40;
	pc = 0x82405354; continue 'dispatch;
            }
            0x82405354 => {
    //   block [0x82405354..0x8240535C)
	// 82405354: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82405358: 4812FDAC  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82405360 size=16
    let mut pc: u32 = 0x82405360;
    'dispatch: loop {
        match pc {
            0x82405360 => {
    //   block [0x82405360..0x82405370)
	// 82405360: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82405364: 806B3828  lwz r3, 0x3828(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14376 as u32) ) } as u64;
	// 82405368: 480036C0  b 0x82408a28
	sub_82408A28(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82405370 size=16
    let mut pc: u32 = 0x82405370;
    'dispatch: loop {
        match pc {
            0x82405370 => {
    //   block [0x82405370..0x82405380)
	// 82405370: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82405374: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82405378: 806B3828  lwz r3, 0x3828(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14376 as u32) ) } as u64;
	// 8240537C: 48002A1C  b 0x82407d98
	sub_82407D98(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82405380 size=16
    let mut pc: u32 = 0x82405380;
    'dispatch: loop {
        match pc {
            0x82405380 => {
    //   block [0x82405380..0x82405390)
	// 82405380: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82405384: 806B3828  lwz r3, 0x3828(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14376 as u32) ) } as u64;
	// 82405388: 4800F1A8  b 0x82414530
	sub_82414530(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82405390 size=24
    let mut pc: u32 = 0x82405390;
    'dispatch: loop {
        match pc {
            0x82405390 => {
    //   block [0x82405390..0x824053A8)
	// 82405390: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82405394: 816B3828  lwz r11, 0x3828(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14376 as u32) ) } as u64;
	// 82405398: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8240539C: 419A000C  beq cr6, 0x824053a8
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x824053A8);
		return;
	}
	// 824053A0: C02B1C1C  lfs f1, 0x1c1c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7196 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 824053A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824053B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824053B8 size=16
    let mut pc: u32 = 0x824053B8;
    'dispatch: loop {
        match pc {
            0x824053B8 => {
    //   block [0x824053B8..0x824053C8)
	// 824053B8: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 824053BC: 816B3828  lwz r11, 0x3828(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14376 as u32) ) } as u64;
	// 824053C0: C02B1C20  lfs f1, 0x1c20(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7200 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 824053C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824053C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824053C8 size=32
    let mut pc: u32 = 0x824053C8;
    'dispatch: loop {
        match pc {
            0x824053C8 => {
    //   block [0x824053C8..0x824053E8)
	// 824053C8: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 824053CC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 824053D0: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 824053D4: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 824053D8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 824053DC: 814A3828  lwz r10, 0x3828(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(14376 as u32) ) } as u64;
	// 824053E0: 806A1C38  lwz r3, 0x1c38(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(7224 as u32) ) } as u64;
	// 824053E4: 480072D4  b 0x8240c6b8
	sub_8240C6B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824053E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824053E8 size=32
    let mut pc: u32 = 0x824053E8;
    'dispatch: loop {
        match pc {
            0x824053E8 => {
    //   block [0x824053E8..0x82405408)
	// 824053E8: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 824053EC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 824053F0: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 824053F4: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 824053F8: 814A3828  lwz r10, 0x3828(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(14376 as u32) ) } as u64;
	// 824053FC: 806A1C38  lwz r3, 0x1c38(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(7224 as u32) ) } as u64;
	// 82405400: 48006FD8  b 0x8240c3d8
	sub_8240C3D8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82405408 size=32
    let mut pc: u32 = 0x82405408;
    'dispatch: loop {
        match pc {
            0x82405408 => {
    //   block [0x82405408..0x82405428)
	// 82405408: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8240540C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82405410: 816B3828  lwz r11, 0x3828(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14376 as u32) ) } as u64;
	// 82405414: 816B1C38  lwz r11, 0x1c38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7224 as u32) ) } as u64;
	// 82405418: 3C6B0008  addis r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 524288;
	// 8240541C: 3863030C  addi r3, r3, 0x30c
	ctx.r[3].s64 = ctx.r[3].s64 + 780;
	// 82405420: 48001650  b 0x82406a70
	sub_82406A70(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82405428 size=408
    let mut pc: u32 = 0x82405428;
    'dispatch: loop {
        match pc {
            0x82405428 => {
    //   block [0x82405428..0x82405474)
	// 82405428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240542C: 4812FC8D  bl 0x825350b8
	ctx.lr = 0x82405430;
	sub_82535080(ctx, base);
	// 82405430: 9421FE20  stwu r1, -0x1e0(r1)
	ea = ctx.r[1].u32.wrapping_add(-480 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82405434: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82405438: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8240543C: 3BAB3824  addi r29, r11, 0x3824
	ctx.r[29].s64 = ctx.r[11].s64 + 14372;
	// 82405440: 80BF00C8  lwz r5, 0xc8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82405444: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82405448: 809F00C4  lwz r4, 0xc4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 8240544C: 806B1C38  lwz r3, 0x1c38(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7224 as u32) ) } as u64;
	// 82405450: 48007331  bl 0x8240c780
	ctx.lr = 0x82405454;
	sub_8240C780(ctx, base);
	// 82405454: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82405458: 4080001C  bge 0x82405474
	if !ctx.cr[0].lt {
	pc = 0x82405474; continue 'dispatch;
	}
	// 8240545C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82405460: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82405464: 386BBE80  addi r3, r11, -0x4180
	ctx.r[3].s64 = ctx.r[11].s64 + -16768;
	// 82405468: 4BEADB19  bl 0x822b2f80
	ctx.lr = 0x8240546C;
	sub_822B2F80(ctx, base);
	// 8240546C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82405470: 48000148  b 0x824055b8
	pc = 0x824055B8; continue 'dispatch;
            }
            0x82405474 => {
    //   block [0x82405474..0x824054D8)
	// 82405474: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82405478: 809F00CC  lwz r4, 0xcc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 8240547C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82405480: 3C6B0002  addis r3, r11, 2
	ctx.r[3].s64 = ctx.r[11].s64 + 131072;
	// 82405484: 3863000C  addi r3, r3, 0xc
	ctx.r[3].s64 = ctx.r[3].s64 + 12;
	// 82405488: 48005A29  bl 0x8240aeb0
	ctx.lr = 0x8240548C;
	sub_8240AEB0(ctx, base);
	// 8240548C: 809F00C0  lwz r4, 0xc0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82405490: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82405494: 4800539D  bl 0x8240a830
	ctx.lr = 0x82405498;
	sub_8240A830(ctx, base);
	// 82405498: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8240549C: C05F00A0  lfs f2, 0xa0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 824054A0: C03F009C  lfs f1, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 824054A4: 48005335  bl 0x8240a7d8
	ctx.lr = 0x824054A8;
	sub_8240A7D8(ctx, base);
	// 824054A8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 824054AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824054B0: 811F00BC  lwz r8, 0xbc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 824054B4: 80FF00B8  lwz r7, 0xb8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 824054B8: 80DF00B4  lwz r6, 0xb4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 824054BC: 809F00B0  lwz r4, 0xb0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 824054C0: 480057C9  bl 0x8240ac88
	ctx.lr = 0x824054C4;
	sub_8240AC88(ctx, base);
	// 824054C4: 2F03FFFD  cmpwi cr6, r3, -3
	ctx.cr[6].compare_i32(ctx.r[3].s32, -3, &mut ctx.xer);
	// 824054C8: 409A0010  bne cr6, 0x824054d8
	if !ctx.cr[6].eq {
	pc = 0x824054D8; continue 'dispatch;
	}
	// 824054CC: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 824054D0: 60630017  ori r3, r3, 0x17
	ctx.r[3].u64 = ctx.r[3].u64 | 23;
	// 824054D4: 480000E4  b 0x824055b8
	pc = 0x824055B8; continue 'dispatch;
            }
            0x824054D8 => {
    //   block [0x824054D8..0x824054E8)
	// 824054D8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 824054DC: 4098000C  bge cr6, 0x824054e8
	if !ctx.cr[6].lt {
	pc = 0x824054E8; continue 'dispatch;
	}
	// 824054E0: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 824054E4: 480000D4  b 0x824055b8
	pc = 0x824055B8; continue 'dispatch;
            }
            0x824054E8 => {
    //   block [0x824054E8..0x824055AC)
	// 824054E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824054EC: C03F0000  lfs f1, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 824054F0: 48004BD9  bl 0x8240a0c8
	ctx.lr = 0x824054F4;
	sub_8240A0C8(ctx, base);
	// 824054F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824054F8: C03F0008  lfs f1, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 824054FC: 48004C75  bl 0x8240a170
	ctx.lr = 0x82405500;
	sub_8240A170(ctx, base);
	// 82405500: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82405504: C03F00A8  lfs f1, 0xa8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82405508: 4BEEBEC9  bl 0x822f13d0
	ctx.lr = 0x8240550C;
	sub_822F13D0(ctx, base);
	// 8240550C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82405510: C03F00AC  lfs f1, 0xac(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82405514: 4BEEBEBD  bl 0x822f13d0
	ctx.lr = 0x82405518;
	sub_822F13D0(ctx, base);
	// 82405518: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8240551C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82405520: 809F00CC  lwz r4, 0xcc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 82405524: C00B1850  lfs f0, 0x1850(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82405528: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8240552C: D001019C  stfs f0, 0x19c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 82405530: D00101AC  stfs f0, 0x1ac(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(428 as u32), tmp.u32 ) };
	// 82405534: D00101B0  stfs f0, 0x1b0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(432 as u32), tmp.u32 ) };
	// 82405538: 916101A4  stw r11, 0x1a4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(420 as u32), ctx.r[11].u32 ) };
	// 8240553C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82405540: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82405544: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82405548: D1A101A0  stfs f13, 0x1a0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 8240554C: D1A101A8  stfs f13, 0x1a8(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(424 as u32), tmp.u32 ) };
	// 82405550: 806B1C3C  lwz r3, 0x1c3c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7228 as u32) ) } as u64;
	// 82405554: 48005E0D  bl 0x8240b360
	ctx.lr = 0x82405558;
	sub_8240B360(ctx, base);
	// 82405558: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 8240555C: 80C10088  lwz r6, 0x88(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82405560: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82405564: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82405568: 48004C81  bl 0x8240a1e8
	ctx.lr = 0x8240556C;
	sub_8240A1E8(ctx, base);
	// 8240556C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82405570: 806B1C3C  lwz r3, 0x1c3c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7228 as u32) ) } as u64;
	// 82405574: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 82405578: 616B0B00  ori r11, r11, 0xb00
	ctx.r[11].u64 = ctx.r[11].u64 | 2816;
	// 8240557C: 7D63582E  lwzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82405580: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82405584: 409A0028  bne cr6, 0x824055ac
	if !ctx.cr[6].eq {
	pc = 0x824055AC; continue 'dispatch;
	}
	// 82405588: 809F00CC  lwz r4, 0xcc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 8240558C: 4800625D  bl 0x8240b7e8
	ctx.lr = 0x82405590;
	sub_8240B7E8(ctx, base);
	// 82405590: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82405594: 40820018  bne 0x824055ac
	if !ctx.cr[0].eq {
	pc = 0x824055AC; continue 'dispatch;
	}
	// 82405598: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8240559C: 48004A45  bl 0x82409fe0
	ctx.lr = 0x824055A0;
	sub_82409FE0(ctx, base);
	// 824055A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824055A4: 48004AB5  bl 0x8240a058
	ctx.lr = 0x824055A8;
	sub_8240A058(ctx, base);
	// 824055A8: 4800000C  b 0x824055b4
	pc = 0x824055B4; continue 'dispatch;
            }
            0x824055AC => {
    //   block [0x824055AC..0x824055B4)
	// 824055AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824055B0: 480049C9  bl 0x82409f78
	ctx.lr = 0x824055B4;
	sub_82409F78(ctx, base);
	pc = 0x824055B4; continue 'dispatch;
            }
            0x824055B4 => {
    //   block [0x824055B4..0x824055B8)
	// 824055B4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x824055B8; continue 'dispatch;
            }
            0x824055B8 => {
    //   block [0x824055B8..0x824055C0)
	// 824055B8: 382101E0  addi r1, r1, 0x1e0
	ctx.r[1].s64 = ctx.r[1].s64 + 480;
	// 824055BC: 4812FB4C  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824055C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824055C0 size=132
    let mut pc: u32 = 0x824055C0;
    'dispatch: loop {
        match pc {
            0x824055C0 => {
    //   block [0x824055C0..0x824055DC)
	// 824055C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824055C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824055C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824055CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824055D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 824055D4: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 824055D8: 40980010  bge cr6, 0x824055e8
	if !ctx.cr[6].lt {
	pc = 0x824055E8; continue 'dispatch;
	}
	pc = 0x824055DC; continue 'dispatch;
            }
            0x824055DC => {
    //   block [0x824055DC..0x824055E8)
	// 824055DC: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 824055E0: 60630016  ori r3, r3, 0x16
	ctx.r[3].u64 = ctx.r[3].u64 | 22;
	// 824055E4: 4800004C  b 0x82405630
	pc = 0x82405630; continue 'dispatch;
            }
            0x824055E8 => {
    //   block [0x824055E8..0x82405630)
	// 824055E8: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 824055EC: 816B3824  lwz r11, 0x3824(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14372 as u32) ) } as u64;
	// 824055F0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824055F4: 3C6B0002  addis r3, r11, 2
	ctx.r[3].s64 = ctx.r[11].s64 + 131072;
	// 824055F8: 3863000C  addi r3, r3, 0xc
	ctx.r[3].s64 = ctx.r[3].s64 + 12;
	// 824055FC: 480058B5  bl 0x8240aeb0
	ctx.lr = 0x82405600;
	sub_8240AEB0(ctx, base);
	// 82405600: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82405604: 4182FFD8  beq 0x824055dc
	if ctx.cr[0].eq {
	pc = 0x824055DC; continue 'dispatch;
	}
	// 82405608: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8240560C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82405610: C04B1FF8  lfs f2, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82405614: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82405618: 480051C1  bl 0x8240a7d8
	ctx.lr = 0x8240561C;
	sub_8240A7D8(ctx, base);
	// 8240561C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82405620: 480049D9  bl 0x82409ff8
	ctx.lr = 0x82405624;
	sub_82409FF8(ctx, base);
	// 82405624: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82405628: 480048E9  bl 0x82409f10
	ctx.lr = 0x8240562C;
	sub_82409F10(ctx, base);
	// 8240562C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82405630; continue 'dispatch;
            }
            0x82405630 => {
    //   block [0x82405630..0x82405644)
	// 82405630: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82405634: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82405638: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8240563C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82405640: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82405648 size=144
    let mut pc: u32 = 0x82405648;
    'dispatch: loop {
        match pc {
            0x82405648 => {
    //   block [0x82405648..0x82405668)
	// 82405648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240564C: 4812FA69  bl 0x825350b4
	ctx.lr = 0x82405650;
	sub_82535080(ctx, base);
	// 82405650: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82405654: 3FC08288  lis r30, -0x7d78
	ctx.r[30].s64 = -2105016320;
	// 82405658: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8240565C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82405660: 817E3828  lwz r11, 0x3828(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14376 as u32) ) } as u64;
	// 82405664: 836B1C3C  lwz r27, 0x1c3c(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7228 as u32) ) } as u64;
	pc = 0x82405668; continue 'dispatch;
            }
            0x82405668 => {
    //   block [0x82405668..0x824056A8)
	// 82405668: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8240566C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82405670: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82405674: 48005BFD  bl 0x8240b270
	ctx.lr = 0x82405678;
	sub_8240B270(ctx, base);
	// 82405678: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8240567C: 7F0BE000  cmpw cr6, r11, r28
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[28].s32, &mut ctx.xer);
	// 82405680: 409A0034  bne cr6, 0x824056b4
	if !ctx.cr[6].eq {
	pc = 0x824056B4; continue 'dispatch;
	}
	// 82405684: 817E3828  lwz r11, 0x3828(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14376 as u32) ) } as u64;
	// 82405688: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8240568C: 83AB1C3C  lwz r29, 0x1c3c(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7228 as u32) ) } as u64;
	// 82405690: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82405694: 48005F85  bl 0x8240b618
	ctx.lr = 0x82405698;
	sub_8240B618(ctx, base);
	// 82405698: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 8240569C: 409A000C  bne cr6, 0x824056a8
	if !ctx.cr[6].eq {
	pc = 0x824056A8; continue 'dispatch;
	}
	// 824056A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824056A4: 4BFFFF1D  bl 0x824055c0
	ctx.lr = 0x824056A8;
	sub_824055C0(ctx, base);
	pc = 0x824056A8; continue 'dispatch;
            }
            0x824056A8 => {
    //   block [0x824056A8..0x824056B4)
	// 824056A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824056AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 824056B0: 48005929  bl 0x8240afd8
	ctx.lr = 0x824056B4;
	sub_8240AFD8(ctx, base);
	pc = 0x824056B4; continue 'dispatch;
            }
            0x824056B4 => {
    //   block [0x824056B4..0x824056D8)
	// 824056B4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 824056B8: 2F1F00C0  cmpwi cr6, r31, 0xc0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 192, &mut ctx.xer);
	// 824056BC: 4198FFAC  blt cr6, 0x82405668
	if ctx.cr[6].lt {
	pc = 0x82405668; continue 'dispatch;
	}
	// 824056C0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 824056C4: 807E3828  lwz r3, 0x3828(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14376 as u32) ) } as u64;
	// 824056C8: 48003091  bl 0x82408758
	ctx.lr = 0x824056CC;
	sub_82408758(ctx, base);
	// 824056CC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824056D0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 824056D4: 4812FA30  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824056D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824056D8 size=96
    let mut pc: u32 = 0x824056D8;
    'dispatch: loop {
        match pc {
            0x824056D8 => {
    //   block [0x824056D8..0x82405700)
	// 824056D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824056DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824056E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824056E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824056E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824056EC: 3FC08288  lis r30, -0x7d78
	ctx.r[30].s64 = -2105016320;
	// 824056F0: 817E3828  lwz r11, 0x3828(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14376 as u32) ) } as u64;
	// 824056F4: 806B1C3C  lwz r3, 0x1c3c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7228 as u32) ) } as u64;
	// 824056F8: 480059A1  bl 0x8240b098
	ctx.lr = 0x824056FC;
	sub_8240B098(ctx, base);
	// 824056FC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82405700; continue 'dispatch;
            }
            0x82405700 => {
    //   block [0x82405700..0x82405738)
	// 82405700: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82405704: 4BFFFEBD  bl 0x824055c0
	ctx.lr = 0x82405708;
	sub_824055C0(ctx, base);
	// 82405708: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 8240570C: 2F1F00C0  cmpwi cr6, r31, 0xc0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 192, &mut ctx.xer);
	// 82405710: 4198FFF0  blt cr6, 0x82405700
	if ctx.cr[6].lt {
	pc = 0x82405700; continue 'dispatch;
	}
	// 82405714: 807E3828  lwz r3, 0x3828(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14376 as u32) ) } as u64;
	// 82405718: 48003051  bl 0x82408768
	ctx.lr = 0x8240571C;
	sub_82408768(ctx, base);
	// 8240571C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82405720: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82405724: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82405728: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8240572C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82405730: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82405734: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82405738 size=16
    let mut pc: u32 = 0x82405738;
    'dispatch: loop {
        match pc {
            0x82405738 => {
    //   block [0x82405738..0x82405748)
	// 82405738: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8240573C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82405740: 806B3828  lwz r3, 0x3828(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14376 as u32) ) } as u64;
	// 82405744: 480028A4  b 0x82407fe8
	sub_82407FE8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82405748 size=16
    let mut pc: u32 = 0x82405748;
    'dispatch: loop {
        match pc {
            0x82405748 => {
    //   block [0x82405748..0x82405758)
	// 82405748: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8240574C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82405750: 806B3828  lwz r3, 0x3828(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14376 as u32) ) } as u64;
	// 82405754: 48002984  b 0x824080d8
	sub_824080D8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82405758 size=24
    let mut pc: u32 = 0x82405758;
    'dispatch: loop {
        match pc {
            0x82405758 => {
    //   block [0x82405758..0x82405770)
	// 82405758: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8240575C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82405760: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82405764: 806B3828  lwz r3, 0x3828(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14376 as u32) ) } as u64;
	// 82405768: 48002A28  b 0x82408190
	sub_82408190(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82405770 size=32
    let mut pc: u32 = 0x82405770;
    'dispatch: loop {
        match pc {
            0x82405770 => {
    //   block [0x82405770..0x82405790)
	// 82405770: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82405774: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82405778: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 8240577C: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 82405780: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 82405784: 806B3828  lwz r3, 0x3828(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14376 as u32) ) } as u64;
	// 82405788: 48003A20  b 0x824091a8
	sub_824091A8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82405790 size=16
    let mut pc: u32 = 0x82405790;
    'dispatch: loop {
        match pc {
            0x82405790 => {
    //   block [0x82405790..0x824057A0)
	// 82405790: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82405794: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82405798: 806B3828  lwz r3, 0x3828(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14376 as u32) ) } as u64;
	// 8240579C: 4800267C  b 0x82407e18
	sub_82407E18(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824057A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824057A0 size=16
    let mut pc: u32 = 0x824057A0;
    'dispatch: loop {
        match pc {
            0x824057A0 => {
    //   block [0x824057A0..0x824057B0)
	// 824057A0: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 824057A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 824057A8: 806B3828  lwz r3, 0x3828(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14376 as u32) ) } as u64;
	// 824057AC: 480026DC  b 0x82407e88
	sub_82407E88(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824057B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824057B0 size=24
    let mut pc: u32 = 0x824057B0;
    'dispatch: loop {
        match pc {
            0x824057B0 => {
    //   block [0x824057B0..0x824057C8)
	// 824057B0: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 824057B4: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 824057B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 824057BC: 806B3828  lwz r3, 0x3828(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14376 as u32) ) } as u64;
	// 824057C0: 48002A80  b 0x82408240
	sub_82408240(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824057C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824057C8 size=24
    let mut pc: u32 = 0x824057C8;
    'dispatch: loop {
        match pc {
            0x824057C8 => {
    //   block [0x824057C8..0x824057E0)
	// 824057C8: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 824057CC: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 824057D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 824057D4: 806B3828  lwz r3, 0x3828(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14376 as u32) ) } as u64;
	// 824057D8: 48002AE8  b 0x824082c0
	sub_824082C0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824057E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824057E0 size=24
    let mut pc: u32 = 0x824057E0;
    'dispatch: loop {
        match pc {
            0x824057E0 => {
    //   block [0x824057E0..0x824057F8)
	// 824057E0: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 824057E4: 1D430164  mulli r10, r3, 0x164
	ctx.r[10].s32 = ((ctx.r[3].s32 as i64 * 356 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 824057E8: 816B3828  lwz r11, 0x3828(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14376 as u32) ) } as u64;
	// 824057EC: 816B1C3C  lwz r11, 0x1c3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7228 as u32) ) } as u64;
	// 824057F0: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824057F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824057F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824057F8 size=12
    let mut pc: u32 = 0x824057F8;
    'dispatch: loop {
        match pc {
            0x824057F8 => {
    //   block [0x824057F8..0x82405804)
	// 824057F8: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 824057FC: 806B3824  lwz r3, 0x3824(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14372 as u32) ) } as u64;
	// 82405800: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82405808 size=12
    let mut pc: u32 = 0x82405808;
    'dispatch: loop {
        match pc {
            0x82405808 => {
    //   block [0x82405808..0x82405814)
	// 82405808: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8240580C: 806B3828  lwz r3, 0x3828(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14376 as u32) ) } as u64;
	// 82405810: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82405818 size=8
    let mut pc: u32 = 0x82405818;
    'dispatch: loop {
        match pc {
            0x82405818 => {
    //   block [0x82405818..0x82405820)
	// 82405818: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8240581C: 4BFFFA04  b 0x82405220
	sub_82405220(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82405820 size=188
    let mut pc: u32 = 0x82405820;
    'dispatch: loop {
        match pc {
            0x82405820 => {
    //   block [0x82405820..0x82405860)
	// 82405820: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82405824: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82405828: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8240582C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82405830: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82405834: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82405838: 3BEB3824  addi r31, r11, 0x3824
	ctx.r[31].s64 = ctx.r[11].s64 + 14372;
	// 8240583C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82405840: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82405844: 409A001C  bne cr6, 0x82405860
	if !ctx.cr[6].eq {
	pc = 0x82405860; continue 'dispatch;
	}
	// 82405848: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8240584C: 386BBEC4  addi r3, r11, -0x413c
	ctx.r[3].s64 = ctx.r[11].s64 + -16700;
	// 82405850: 4BEAD731  bl 0x822b2f80
	ctx.lr = 0x82405854;
	sub_822B2F80(ctx, base);
	// 82405854: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82405858: 60630029  ori r3, r3, 0x29
	ctx.r[3].u64 = ctx.r[3].u64 | 41;
	// 8240585C: 48000068  b 0x824058c4
	pc = 0x824058C4; continue 'dispatch;
            }
            0x82405860 => {
    //   block [0x82405860..0x82405898)
	// 82405860: 4BFFFE79  bl 0x824056d8
	ctx.lr = 0x82405864;
	sub_824056D8(ctx, base);
	// 82405864: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82405868: 3FC08273  lis r30, -0x7d8d
	ctx.r[30].s64 = -2106392576;
	// 8240586C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82405870: 419A0028  beq cr6, 0x82405898
	if ctx.cr[6].eq {
	pc = 0x82405898; continue 'dispatch;
	}
	// 82405874: 480024ED  bl 0x82407d60
	ctx.lr = 0x82405878;
	sub_82407D60(ctx, base);
	// 82405878: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8240587C: 48002F8D  bl 0x82408808
	ctx.lr = 0x82405880;
	sub_82408808(ctx, base);
	// 82405880: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82405884: 817E3804  lwz r11, 0x3804(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14340 as u32) ) } as u64;
	// 82405888: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8240588C: 4E800421  bctrl
	ctx.lr = 0x82405890;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82405890: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82405894: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
            }
            0x82405898 => {
    //   block [0x82405898..0x824058C4)
	// 82405898: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8240589C: 4800227D  bl 0x82407b18
	ctx.lr = 0x824058A0;
	sub_82407B18(ctx, base);
	// 824058A0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824058A4: 48001F5D  bl 0x82407800
	ctx.lr = 0x824058A8;
	sub_82407800(ctx, base);
	// 824058A8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824058AC: 817E3804  lwz r11, 0x3804(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14340 as u32) ) } as u64;
	// 824058B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824058B4: 4E800421  bctrl
	ctx.lr = 0x824058B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824058B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824058BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824058C0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
            }
            0x824058C4 => {
    //   block [0x824058C4..0x824058DC)
	// 824058C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824058C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824058CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824058D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824058D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824058D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824058E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824058E0 size=556
    let mut pc: u32 = 0x824058E0;
    'dispatch: loop {
        match pc {
            0x824058E0 => {
    //   block [0x824058E0..0x82405918)
	// 824058E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824058E4: 4812F7C9  bl 0x825350ac
	ctx.lr = 0x824058E8;
	sub_82535080(ctx, base);
	// 824058E8: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 824058EC: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 824058F0: 9421FD30  stwu r1, -0x2d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-720 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824058F4: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 824058F8: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 824058FC: 3BCB3824  addi r30, r11, 0x3824
	ctx.r[30].s64 = ctx.r[11].s64 + 14372;
	// 82405900: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82405904: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82405908: 409A0010  bne cr6, 0x82405918
	if !ctx.cr[6].eq {
	pc = 0x82405918; continue 'dispatch;
	}
	// 8240590C: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82405910: 60630029  ori r3, r3, 0x29
	ctx.r[3].u64 = ctx.r[3].u64 | 41;
	// 82405914: 480001E8  b 0x82405afc
	pc = 0x82405AFC; continue 'dispatch;
            }
            0x82405918 => {
    //   block [0x82405918..0x82405940)
	// 82405918: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 8240591C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82405920: 48004141  bl 0x82409a60
	ctx.lr = 0x82405924;
	sub_82409A60(ctx, base);
	// 82405924: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82405928: 48004059  bl 0x82409980
	ctx.lr = 0x8240592C;
	sub_82409980(ctx, base);
	// 8240592C: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82405930: 4081002C  ble 0x8240595c
	if !ctx.cr[0].gt {
	pc = 0x8240595C; continue 'dispatch;
	}
	// 82405934: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82405938: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8240593C: 40990020  ble cr6, 0x8240595c
	if !ctx.cr[6].gt {
	pc = 0x8240595C; continue 'dispatch;
	}
	pc = 0x82405940; continue 'dispatch;
            }
            0x82405940 => {
    //   block [0x82405940..0x8240595C)
	// 82405940: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82405944: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82405948: 480024B1  bl 0x82407df8
	ctx.lr = 0x8240594C;
	sub_82407DF8(ctx, base);
	// 8240594C: 4BFFFADD  bl 0x82405428
	ctx.lr = 0x82405950;
	sub_82405428(ctx, base);
	// 82405950: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82405954: 7F1FE800  cmpw cr6, r31, r29
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82405958: 4198FFE8  blt cr6, 0x82405940
	if ctx.cr[6].lt {
	pc = 0x82405940; continue 'dispatch;
	}
	pc = 0x8240595C; continue 'dispatch;
            }
            0x8240595C => {
    //   block [0x8240595C..0x82405984)
	// 8240595C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82405960: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82405964: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82405968: 48006F89  bl 0x8240c8f0
	ctx.lr = 0x8240596C;
	sub_8240C8F0(ctx, base);
	// 8240596C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82405970: 834B1C3C  lwz r26, 0x1c3c(r11)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7228 as u32) ) } as u64;
	// 82405974: 480014DD  bl 0x82406e50
	ctx.lr = 0x82405978;
	sub_82406E50(ctx, base);
	// 82405978: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8240597C: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82405980: 4081003C  ble 0x824059bc
	if !ctx.cr[0].gt {
	pc = 0x824059BC; continue 'dispatch;
	}
	pc = 0x82405984; continue 'dispatch;
            }
            0x82405984 => {
    //   block [0x82405984..0x824059B0)
	// 82405984: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82405988: 48001881  bl 0x82407208
	ctx.lr = 0x8240598C;
	sub_82407208(ctx, base);
	// 8240598C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82405990: 409A0020  bne cr6, 0x824059b0
	if !ctx.cr[6].eq {
	pc = 0x824059B0; continue 'dispatch;
	}
	// 82405994: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82405998: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8240599C: 48002B5D  bl 0x824084f8
	ctx.lr = 0x824059A0;
	sub_824084F8(ctx, base);
	// 824059A0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 824059A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824059A8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824059AC: 48001EE5  bl 0x82407890
	ctx.lr = 0x824059B0;
	sub_82407890(ctx, base);
	pc = 0x824059B0; continue 'dispatch;
            }
            0x824059B0 => {
    //   block [0x824059B0..0x824059BC)
	// 824059B0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 824059B4: 7F1FE800  cmpw cr6, r31, r29
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[29].s32, &mut ctx.xer);
	// 824059B8: 4198FFCC  blt cr6, 0x82405984
	if ctx.cr[6].lt {
	pc = 0x82405984; continue 'dispatch;
	}
	pc = 0x824059BC; continue 'dispatch;
            }
            0x824059BC => {
    //   block [0x824059BC..0x824059DC)
	// 824059BC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824059C0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 824059C4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 824059C8: 3F6B0002  addis r27, r11, 2
	ctx.r[27].s64 = ctx.r[11].s64 + 131072;
	// 824059CC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824059D0: 3B7B0010  addi r27, r27, 0x10
	ctx.r[27].s64 = ctx.r[27].s64 + 16;
	// 824059D4: C3CA1850  lfs f30, 0x1850(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6224 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 824059D8: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x824059DC; continue 'dispatch;
            }
            0x824059DC => {
    //   block [0x824059DC..0x82405A58)
	// 824059DC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824059E0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 824059E4: 480054CD  bl 0x8240aeb0
	ctx.lr = 0x824059E8;
	sub_8240AEB0(ctx, base);
	// 824059E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824059EC: 48004975  bl 0x8240a360
	ctx.lr = 0x824059F0;
	sub_8240A360(ctx, base);
	// 824059F0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 824059F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824059F8: 48004501  bl 0x82409ef8
	ctx.lr = 0x824059FC;
	sub_82409EF8(ctx, base);
	// 824059FC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82405A00: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82405A04: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82405A08: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82405A0C: 480056E5  bl 0x8240b0f0
	ctx.lr = 0x82405A10;
	sub_8240B0F0(ctx, base);
	// 82405A10: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82405A14: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82405A18: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82405A1C: 48003995  bl 0x824093b0
	ctx.lr = 0x82405A20;
	sub_824093B0(ctx, base);
	// 82405A20: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82405A24: 408200B0  bne 0x82405ad4
	if !ctx.cr[0].eq {
	pc = 0x82405AD4; continue 'dispatch;
	}
	// 82405A28: 81610104  lwz r11, 0x104(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82405A2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82405A30: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82405A34: 409A0024  bne cr6, 0x82405a58
	if !ctx.cr[6].eq {
	pc = 0x82405A58; continue 'dispatch;
	}
	// 82405A38: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82405A3C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82405A40: 48004D99  bl 0x8240a7d8
	ctx.lr = 0x82405A44;
	sub_8240A7D8(ctx, base);
	// 82405A44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82405A48: 480045B1  bl 0x82409ff8
	ctx.lr = 0x82405A4C;
	sub_82409FF8(ctx, base);
	// 82405A4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82405A50: 480044C1  bl 0x82409f10
	ctx.lr = 0x82405A54;
	sub_82409F10(ctx, base);
	// 82405A54: 48000080  b 0x82405ad4
	pc = 0x82405AD4; continue 'dispatch;
            }
            0x82405A58 => {
    //   block [0x82405A58..0x82405AD4)
	// 82405A58: C0210060  lfs f1, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82405A5C: 4800466D  bl 0x8240a0c8
	ctx.lr = 0x82405A60;
	sub_8240A0C8(ctx, base);
	// 82405A60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82405A64: C0210068  lfs f1, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82405A68: 48004709  bl 0x8240a170
	ctx.lr = 0x82405A6C;
	sub_8240A170(ctx, base);
	// 82405A6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82405A70: C0410100  lfs f2, 0x100(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82405A74: C02100FC  lfs f1, 0xfc(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(252 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82405A78: 48004D61  bl 0x8240a7d8
	ctx.lr = 0x82405A7C;
	sub_8240A7D8(ctx, base);
	// 82405A7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82405A80: C0210108  lfs f1, 0x108(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(264 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82405A84: 4BEEB94D  bl 0x822f13d0
	ctx.lr = 0x82405A88;
	sub_822F13D0(ctx, base);
	// 82405A88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82405A8C: C021010C  lfs f1, 0x10c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82405A90: 4BEEB941  bl 0x822f13d0
	ctx.lr = 0x82405A94;
	sub_822F13D0(ctx, base);
	// 82405A94: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82405A98: 38A10110  addi r5, r1, 0x110
	ctx.r[5].s64 = ctx.r[1].s64 + 272;
	// 82405A9C: D3C1025C  stfs f30, 0x25c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(604 as u32), tmp.u32 ) };
	// 82405AA0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82405AA4: D3E10260  stfs f31, 0x260(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(608 as u32), tmp.u32 ) };
	// 82405AA8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82405AAC: D3E10268  stfs f31, 0x268(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(616 as u32), tmp.u32 ) };
	// 82405AB0: D3C1026C  stfs f30, 0x26c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(620 as u32), tmp.u32 ) };
	// 82405AB4: D3C10270  stfs f30, 0x270(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(624 as u32), tmp.u32 ) };
	// 82405AB8: 91610264  stw r11, 0x264(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(612 as u32), ctx.r[11].u32 ) };
	// 82405ABC: 480058A5  bl 0x8240b360
	ctx.lr = 0x82405AC0;
	sub_8240B360(ctx, base);
	// 82405AC0: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 82405AC4: 3881006C  addi r4, r1, 0x6c
	ctx.r[4].s64 = ctx.r[1].s64 + 108;
	// 82405AC8: 80C10148  lwz r6, 0x148(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(328 as u32) ) } as u64;
	// 82405ACC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82405AD0: 48004719  bl 0x8240a1e8
	ctx.lr = 0x82405AD4;
	sub_8240A1E8(ctx, base);
	pc = 0x82405AD4; continue 'dispatch;
            }
            0x82405AD4 => {
    //   block [0x82405AD4..0x82405AFC)
	// 82405AD4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82405AD8: 2F1D00C0  cmpwi cr6, r29, 0xc0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 192, &mut ctx.xer);
	// 82405ADC: 4198FF00  blt cr6, 0x824059dc
	if ctx.cr[6].lt {
	pc = 0x824059DC; continue 'dispatch;
	}
	// 82405AE0: 7B2B0020  clrldi r11, r25, 0x20
	ctx.r[11].u64 = ctx.r[25].u64 & 0x00000000FFFFFFFFu64;
	// 82405AE4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82405AE8: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82405AEC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82405AF0: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82405AF4: 48000A8D  bl 0x82406580
	ctx.lr = 0x82405AF8;
	sub_82406580(ctx, base);
	// 82405AF8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82405AFC; continue 'dispatch;
            }
            0x82405AFC => {
    //   block [0x82405AFC..0x82405B0C)
	// 82405AFC: 382102D0  addi r1, r1, 0x2d0
	ctx.r[1].s64 = ctx.r[1].s64 + 720;
	// 82405B00: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82405B04: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82405B08: 4812F5F4  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405B10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82405B10 size=132
    let mut pc: u32 = 0x82405B10;
    'dispatch: loop {
        match pc {
            0x82405B10 => {
    //   block [0x82405B10..0x82405B30)
	// 82405B10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82405B14: 4812F5A5  bl 0x825350b8
	ctx.lr = 0x82405B18;
	sub_82535080(ctx, base);
	// 82405B18: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82405B1C: 3FE08288  lis r31, -0x7d78
	ctx.r[31].s64 = -2105016320;
	// 82405B20: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82405B24: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82405B28: 817F3828  lwz r11, 0x3828(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(14376 as u32) ) } as u64;
	// 82405B2C: 838B1C3C  lwz r28, 0x1c3c(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7228 as u32) ) } as u64;
	pc = 0x82405B30; continue 'dispatch;
            }
            0x82405B30 => {
    //   block [0x82405B30..0x82405B64)
	// 82405B30: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82405B34: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82405B38: 480056A1  bl 0x8240b1d8
	ctx.lr = 0x82405B3C;
	sub_8240B1D8(ctx, base);
	// 82405B3C: 7F03E800  cmpw cr6, r3, r29
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82405B40: 409A0024  bne cr6, 0x82405b64
	if !ctx.cr[6].eq {
	pc = 0x82405B64; continue 'dispatch;
	}
	// 82405B44: 817F3828  lwz r11, 0x3828(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(14376 as u32) ) } as u64;
	// 82405B48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82405B4C: 806B1C3C  lwz r3, 0x1c3c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7228 as u32) ) } as u64;
	// 82405B50: 48005501  bl 0x8240b050
	ctx.lr = 0x82405B54;
	sub_8240B050(ctx, base);
	// 82405B54: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82405B58: 4082000C  bne 0x82405b64
	if !ctx.cr[0].eq {
	pc = 0x82405B64; continue 'dispatch;
	}
	// 82405B5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82405B60: 4BFFFA61  bl 0x824055c0
	ctx.lr = 0x82405B64;
	sub_824055C0(ctx, base);
	pc = 0x82405B64; continue 'dispatch;
            }
            0x82405B64 => {
    //   block [0x82405B64..0x82405B94)
	// 82405B64: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82405B68: 2F1E00C0  cmpwi cr6, r30, 0xc0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 192, &mut ctx.xer);
	// 82405B6C: 4198FFC4  blt cr6, 0x82405b30
	if ctx.cr[6].lt {
	pc = 0x82405B30; continue 'dispatch;
	}
	// 82405B70: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82405B74: 807F3828  lwz r3, 0x3828(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(14376 as u32) ) } as u64;
	// 82405B78: 48002BE9  bl 0x82408760
	ctx.lr = 0x82405B7C;
	sub_82408760(ctx, base);
	// 82405B7C: 817F3828  lwz r11, 0x3828(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(14376 as u32) ) } as u64;
	// 82405B80: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82405B84: 806B1C38  lwz r3, 0x1c38(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7224 as u32) ) } as u64;
	// 82405B88: 480066B1  bl 0x8240c238
	ctx.lr = 0x82405B8C;
	sub_8240C238(ctx, base);
	// 82405B8C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82405B90: 4812F578  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405B98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82405B98 size=168
    let mut pc: u32 = 0x82405B98;
    'dispatch: loop {
        match pc {
            0x82405B98 => {
    //   block [0x82405B98..0x82405BFC)
	// 82405B98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82405B9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82405BA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82405BA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82405BA8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82405BAC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82405BB0: 814100E4  lwz r10, 0xe4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 82405BB4: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 82405BB8: 3FE08288  lis r31, -0x7d78
	ctx.r[31].s64 = -2105016320;
	// 82405BBC: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82405BC0: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82405BC4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82405BC8: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82405BCC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82405BD0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82405BD4: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 82405BD8: 807F3828  lwz r3, 0x3828(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(14376 as u32) ) } as u64;
	// 82405BDC: 90E10064  stw r7, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[7].u32 ) };
	// 82405BE0: 48003F61  bl 0x82409b40
	ctx.lr = 0x82405BE4;
	sub_82409B40(ctx, base);
	// 82405BE4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82405BE8: 40820040  bne 0x82405c28
	if !ctx.cr[0].eq {
	pc = 0x82405C28; continue 'dispatch;
	}
	// 82405BEC: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82405BF0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82405BF4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82405BF8: 4099002C  ble cr6, 0x82405c24
	if !ctx.cr[6].gt {
	pc = 0x82405C24; continue 'dispatch;
	}
	pc = 0x82405BFC; continue 'dispatch;
            }
            0x82405BFC => {
    //   block [0x82405BFC..0x82405C24)
	// 82405BFC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82405C00: 807F3828  lwz r3, 0x3828(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(14376 as u32) ) } as u64;
	// 82405C04: 480021F5  bl 0x82407df8
	ctx.lr = 0x82405C08;
	sub_82407DF8(ctx, base);
	// 82405C08: 4BFFF821  bl 0x82405428
	ctx.lr = 0x82405C0C;
	sub_82405428(ctx, base);
	// 82405C0C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82405C10: 40820018  bne 0x82405c28
	if !ctx.cr[0].eq {
	pc = 0x82405C28; continue 'dispatch;
	}
	// 82405C14: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82405C18: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82405C1C: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82405C20: 4198FFDC  blt cr6, 0x82405bfc
	if ctx.cr[6].lt {
	pc = 0x82405BFC; continue 'dispatch;
	}
	pc = 0x82405C24; continue 'dispatch;
            }
            0x82405C24 => {
    //   block [0x82405C24..0x82405C28)
	// 82405C24: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82405C28; continue 'dispatch;
            }
            0x82405C28 => {
    //   block [0x82405C28..0x82405C40)
	// 82405C28: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82405C2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82405C30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82405C34: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82405C38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82405C3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405C40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82405C40 size=52
    let mut pc: u32 = 0x82405C40;
    'dispatch: loop {
        match pc {
            0x82405C40 => {
    //   block [0x82405C40..0x82405C74)
	// 82405C40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82405C44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82405C48: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82405C4C: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 82405C50: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82405C54: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82405C58: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 82405C5C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82405C60: 4BFFFF39  bl 0x82405b98
	ctx.lr = 0x82405C64;
	sub_82405B98(ctx, base);
	// 82405C64: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82405C68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82405C6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82405C70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405C78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82405C78 size=44
    let mut pc: u32 = 0x82405C78;
    'dispatch: loop {
        match pc {
            0x82405C78 => {
    //   block [0x82405C78..0x82405CA4)
	// 82405C78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82405C7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82405C80: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82405C84: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82405C88: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82405C8C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82405C90: 4BFFFF09  bl 0x82405b98
	ctx.lr = 0x82405C94;
	sub_82405B98(ctx, base);
	// 82405C94: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82405C98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82405C9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82405CA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405CA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82405CA8 size=240
    let mut pc: u32 = 0x82405CA8;
    'dispatch: loop {
        match pc {
            0x82405CA8 => {
    //   block [0x82405CA8..0x82405CE0)
	// 82405CA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82405CAC: 4812F401  bl 0x825350ac
	ctx.lr = 0x82405CB0;
	sub_82535080(ctx, base);
	// 82405CB0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82405CB4: 3F808288  lis r28, -0x7d78
	ctx.r[28].s64 = -2105016320;
	// 82405CB8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82405CBC: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82405CC0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82405CC4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82405CC8: 807C3828  lwz r3, 0x3828(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(14376 as u32) ) } as u64;
	// 82405CCC: 81631C3C  lwz r11, 0x1c3c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(7228 as u32) ) } as u64;
	// 82405CD0: 409A0020  bne cr6, 0x82405cf0
	if !ctx.cr[6].eq {
	pc = 0x82405CF0; continue 'dispatch;
	}
	// 82405CD4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82405CD8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82405CDC: 386BBF34  addi r3, r11, -0x40cc
	ctx.r[3].s64 = ctx.r[11].s64 + -16588;
	pc = 0x82405CE0; continue 'dispatch;
            }
            0x82405CE0 => {
    //   block [0x82405CE0..0x82405CF0)
	// 82405CE0: 4BEAD2A1  bl 0x822b2f80
	ctx.lr = 0x82405CE4;
	sub_822B2F80(ctx, base);
	// 82405CE4: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82405CE8: 60630012  ori r3, r3, 0x12
	ctx.r[3].u64 = ctx.r[3].u64 | 18;
	// 82405CEC: 480000A4  b 0x82405d90
	pc = 0x82405D90; continue 'dispatch;
            }
            0x82405CF0 => {
    //   block [0x82405CF0..0x82405CF8)
	// 82405CF0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82405CF4: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	pc = 0x82405CF8; continue 'dispatch;
            }
            0x82405CF8 => {
    //   block [0x82405CF8..0x82405D2C)
	// 82405CF8: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82405CFC: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82405D00: 409A005C  bne cr6, 0x82405d5c
	if !ctx.cr[6].eq {
	pc = 0x82405D5C; continue 'dispatch;
	}
	// 82405D04: 2B190001  cmplwi cr6, r25, 1
	ctx.cr[6].compare_u32(ctx.r[25].u32, 1 as u32, &mut ctx.xer);
	// 82405D08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82405D0C: 409A0030  bne cr6, 0x82405d3c
	if !ctx.cr[6].eq {
	pc = 0x82405D3C; continue 'dispatch;
	}
	// 82405D10: 83C31C3C  lwz r30, 0x1c3c(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(7228 as u32) ) } as u64;
	// 82405D14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82405D18: 48005901  bl 0x8240b618
	ctx.lr = 0x82405D1C;
	sub_8240B618(ctx, base);
	// 82405D1C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82405D20: 409A000C  bne cr6, 0x82405d2c
	if !ctx.cr[6].eq {
	pc = 0x82405D2C; continue 'dispatch;
	}
	// 82405D24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82405D28: 4BFFF899  bl 0x824055c0
	ctx.lr = 0x82405D2C;
	sub_824055C0(ctx, base);
	pc = 0x82405D2C; continue 'dispatch;
            }
            0x82405D2C => {
    //   block [0x82405D2C..0x82405D3C)
	// 82405D2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82405D30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82405D34: 480052A5  bl 0x8240afd8
	ctx.lr = 0x82405D38;
	sub_8240AFD8(ctx, base);
	// 82405D38: 4800001C  b 0x82405d54
	pc = 0x82405D54; continue 'dispatch;
            }
            0x82405D3C => {
    //   block [0x82405D3C..0x82405D54)
	// 82405D3C: 80631C3C  lwz r3, 0x1c3c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(7228 as u32) ) } as u64;
	// 82405D40: 48005311  bl 0x8240b050
	ctx.lr = 0x82405D44;
	sub_8240B050(ctx, base);
	// 82405D44: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82405D48: 4082000C  bne 0x82405d54
	if !ctx.cr[0].eq {
	pc = 0x82405D54; continue 'dispatch;
	}
	// 82405D4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82405D50: 4BFFF871  bl 0x824055c0
	ctx.lr = 0x82405D54;
	sub_824055C0(ctx, base);
	pc = 0x82405D54; continue 'dispatch;
            }
            0x82405D54 => {
    //   block [0x82405D54..0x82405D5C)
	// 82405D54: 807C3828  lwz r3, 0x3828(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(14376 as u32) ) } as u64;
	// 82405D58: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	pc = 0x82405D5C; continue 'dispatch;
            }
            0x82405D5C => {
    //   block [0x82405D5C..0x82405D8C)
	// 82405D5C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82405D60: 3B5A0164  addi r26, r26, 0x164
	ctx.r[26].s64 = ctx.r[26].s64 + 356;
	// 82405D64: 2F1F00C0  cmpwi cr6, r31, 0xc0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 192, &mut ctx.xer);
	// 82405D68: 4198FF90  blt cr6, 0x82405cf8
	if ctx.cr[6].lt {
	pc = 0x82405CF8; continue 'dispatch;
	}
	// 82405D6C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82405D70: 480029E1  bl 0x82408750
	ctx.lr = 0x82405D74;
	sub_82408750(ctx, base);
	// 82405D74: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82405D78: 409A0014  bne cr6, 0x82405d8c
	if !ctx.cr[6].eq {
	pc = 0x82405D8C; continue 'dispatch;
	}
	// 82405D7C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82405D80: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82405D84: 386BBEF8  addi r3, r11, -0x4108
	ctx.r[3].s64 = ctx.r[11].s64 + -16648;
	// 82405D88: 4BFFFF58  b 0x82405ce0
	pc = 0x82405CE0; continue 'dispatch;
            }
            0x82405D8C => {
    //   block [0x82405D8C..0x82405D90)
	// 82405D8C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82405D90; continue 'dispatch;
            }
            0x82405D90 => {
    //   block [0x82405D90..0x82405D98)
	// 82405D90: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82405D94: 4812F368  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405D98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82405D98 size=8
    let mut pc: u32 = 0x82405D98;
    'dispatch: loop {
        match pc {
            0x82405D98 => {
    //   block [0x82405D98..0x82405DA0)
	// 82405D98: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82405D9C: 4BFFFF0C  b 0x82405ca8
	sub_82405CA8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405DA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82405DA0 size=52
    let mut pc: u32 = 0x82405DA0;
    'dispatch: loop {
        match pc {
            0x82405DA0 => {
    //   block [0x82405DA0..0x82405DD4)
	// 82405DA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82405DA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82405DA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82405DAC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82405DB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82405DB4: 4BFFFA45  bl 0x824057f8
	ctx.lr = 0x82405DB8;
	sub_824057F8(ctx, base);
	// 82405DB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82405DBC: 48001B65  bl 0x82407920
	ctx.lr = 0x82405DC0;
	sub_82407920(ctx, base);
	// 82405DC0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82405DC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82405DC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82405DCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82405DD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405DD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82405DD8 size=244
    let mut pc: u32 = 0x82405DD8;
    'dispatch: loop {
        match pc {
            0x82405DD8 => {
    //   block [0x82405DD8..0x82405E28)
	// 82405DD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82405DDC: 4812F2D9  bl 0x825350b4
	ctx.lr = 0x82405DE0;
	sub_82535080(ctx, base);
	// 82405DE0: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 82405DE4: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82405DE8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82405DEC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82405DF0: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82405DF4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82405DF8: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 82405DFC: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82405E00: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 82405E04: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 82405E08: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82405E0C: 409A001C  bne cr6, 0x82405e28
	if !ctx.cr[6].eq {
	pc = 0x82405E28; continue 'dispatch;
	}
	// 82405E10: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82405E14: 386BBFBC  addi r3, r11, -0x4044
	ctx.r[3].s64 = ctx.r[11].s64 + -16452;
	// 82405E18: 4BEAD169  bl 0x822b2f80
	ctx.lr = 0x82405E1C;
	sub_822B2F80(ctx, base);
	// 82405E1C: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82405E20: 60630031  ori r3, r3, 0x31
	ctx.r[3].u64 = ctx.r[3].u64 | 49;
	// 82405E24: 48000098  b 0x82405ebc
	pc = 0x82405EBC; continue 'dispatch;
            }
            0x82405E28 => {
    //   block [0x82405E28..0x82405E48)
	// 82405E28: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82405E2C: 409A001C  bne cr6, 0x82405e48
	if !ctx.cr[6].eq {
	pc = 0x82405E48; continue 'dispatch;
	}
	// 82405E30: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82405E34: 386BBF94  addi r3, r11, -0x406c
	ctx.r[3].s64 = ctx.r[11].s64 + -16492;
	// 82405E38: 4BEAD149  bl 0x822b2f80
	ctx.lr = 0x82405E3C;
	sub_822B2F80(ctx, base);
	// 82405E3C: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82405E40: 60630032  ori r3, r3, 0x32
	ctx.r[3].u64 = ctx.r[3].u64 | 50;
	// 82405E44: 48000078  b 0x82405ebc
	pc = 0x82405EBC; continue 'dispatch;
            }
            0x82405E48 => {
    //   block [0x82405E48..0x82405E68)
	// 82405E48: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82405E4C: 409A001C  bne cr6, 0x82405e68
	if !ctx.cr[6].eq {
	pc = 0x82405E68; continue 'dispatch;
	}
	// 82405E50: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82405E54: 386BBF6C  addi r3, r11, -0x4094
	ctx.r[3].s64 = ctx.r[11].s64 + -16532;
	// 82405E58: 4BEAD129  bl 0x822b2f80
	ctx.lr = 0x82405E5C;
	sub_822B2F80(ctx, base);
	// 82405E5C: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82405E60: 60630033  ori r3, r3, 0x33
	ctx.r[3].u64 = ctx.r[3].u64 | 51;
	// 82405E64: 48000058  b 0x82405ebc
	pc = 0x82405EBC; continue 'dispatch;
            }
            0x82405E68 => {
    //   block [0x82405E68..0x82405EBC)
	// 82405E68: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 82405E6C: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 82405E70: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82405E74: 4BFBAD8D  bl 0x823c0c00
	ctx.lr = 0x82405E78;
	sub_823C0C00(ctx, base);
	// 82405E78: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 82405E7C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82405E80: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82405E84: 4BFBAD7D  bl 0x823c0c00
	ctx.lr = 0x82405E88;
	sub_823C0C00(ctx, base);
	// 82405E88: 81610114  lwz r11, 0x114(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	// 82405E8C: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82405E90: D3C10078  stfs f30, 0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82405E94: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 82405E98: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82405E9C: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 82405EA0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82405EA4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82405EA8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82405EAC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82405EB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82405EB4: C04B1FF8  lfs f2, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82405EB8: 4BFFFCE1  bl 0x82405b98
	ctx.lr = 0x82405EBC;
	sub_82405B98(ctx, base);
	pc = 0x82405EBC; continue 'dispatch;
            }
            0x82405EBC => {
    //   block [0x82405EBC..0x82405ECC)
	// 82405EBC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82405EC0: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82405EC4: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82405EC8: 4812F23C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405ED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82405ED0 size=280
    let mut pc: u32 = 0x82405ED0;
    'dispatch: loop {
        match pc {
            0x82405ED0 => {
    //   block [0x82405ED0..0x82405F20)
	// 82405ED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82405ED4: 4812F1E5  bl 0x825350b8
	ctx.lr = 0x82405ED8;
	sub_82535080(ctx, base);
	// 82405ED8: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82405EDC: 4813010D  bl 0x82535fe8
	ctx.lr = 0x82405EE0;
	sub_82535FB0(ctx, base);
	// 82405EE0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82405EE4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82405EE8: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82405EEC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82405EF0: FFA01090  fmr f29, f2
	ctx.f[29].f64 = ctx.f[2].f64;
	// 82405EF4: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 82405EF8: FF801890  fmr f28, f3
	ctx.f[28].f64 = ctx.f[3].f64;
	// 82405EFC: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 82405F00: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82405F04: 409A001C  bne cr6, 0x82405f20
	if !ctx.cr[6].eq {
	pc = 0x82405F20; continue 'dispatch;
	}
	// 82405F08: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82405F0C: 386BC090  addi r3, r11, -0x3f70
	ctx.r[3].s64 = ctx.r[11].s64 + -16240;
	// 82405F10: 4BEAD071  bl 0x822b2f80
	ctx.lr = 0x82405F14;
	sub_822B2F80(ctx, base);
	// 82405F14: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82405F18: 60630031  ori r3, r3, 0x31
	ctx.r[3].u64 = ctx.r[3].u64 | 49;
	// 82405F1C: 480000BC  b 0x82405fd8
	pc = 0x82405FD8; continue 'dispatch;
            }
            0x82405F20 => {
    //   block [0x82405F20..0x82405F40)
	// 82405F20: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82405F24: 409A001C  bne cr6, 0x82405f40
	if !ctx.cr[6].eq {
	pc = 0x82405F40; continue 'dispatch;
	}
	// 82405F28: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82405F2C: 386BC058  addi r3, r11, -0x3fa8
	ctx.r[3].s64 = ctx.r[11].s64 + -16296;
	// 82405F30: 4BEAD051  bl 0x822b2f80
	ctx.lr = 0x82405F34;
	sub_822B2F80(ctx, base);
	// 82405F34: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82405F38: 60630032  ori r3, r3, 0x32
	ctx.r[3].u64 = ctx.r[3].u64 | 50;
	// 82405F3C: 4800009C  b 0x82405fd8
	pc = 0x82405FD8; continue 'dispatch;
            }
            0x82405F40 => {
    //   block [0x82405F40..0x82405F60)
	// 82405F40: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82405F44: 409A001C  bne cr6, 0x82405f60
	if !ctx.cr[6].eq {
	pc = 0x82405F60; continue 'dispatch;
	}
	// 82405F48: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82405F4C: 386BC01C  addi r3, r11, -0x3fe4
	ctx.r[3].s64 = ctx.r[11].s64 + -16356;
	// 82405F50: 4BEAD031  bl 0x822b2f80
	ctx.lr = 0x82405F54;
	sub_822B2F80(ctx, base);
	// 82405F54: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82405F58: 60630033  ori r3, r3, 0x33
	ctx.r[3].u64 = ctx.r[3].u64 | 51;
	// 82405F5C: 4800007C  b 0x82405fd8
	pc = 0x82405FD8; continue 'dispatch;
            }
            0x82405F60 => {
    //   block [0x82405F60..0x82405F94)
	// 82405F60: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82405F64: C3CB1FF8  lfs f30, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82405F68: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 82405F6C: 40980028  bge cr6, 0x82405f94
	if !ctx.cr[6].lt {
	pc = 0x82405F94; continue 'dispatch;
	}
	// 82405F70: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82405F74: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82405F78: D8210018  stfd f1, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.f[1].u64 ) };
	// 82405F7C: E8810018  ld r4, 0x18(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(24 as u32) ) };
	// 82405F80: 386BBFE4  addi r3, r11, -0x401c
	ctx.r[3].s64 = ctx.r[11].s64 + -16412;
	// 82405F84: 4BEACFFD  bl 0x822b2f80
	ctx.lr = 0x82405F88;
	sub_822B2F80(ctx, base);
	// 82405F88: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82405F8C: 60630018  ori r3, r3, 0x18
	ctx.r[3].u64 = ctx.r[3].u64 | 24;
	// 82405F90: 48000048  b 0x82405fd8
	pc = 0x82405FD8; continue 'dispatch;
            }
            0x82405F94 => {
    //   block [0x82405F94..0x82405FD8)
	// 82405F94: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 82405F98: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 82405F9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82405FA0: 4BFBAC61  bl 0x823c0c00
	ctx.lr = 0x82405FA4;
	sub_823C0C00(ctx, base);
	// 82405FA4: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 82405FA8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82405FAC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82405FB0: 4BFBAC51  bl 0x823c0c00
	ctx.lr = 0x82405FB4;
	sub_823C0C00(ctx, base);
	// 82405FB4: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82405FB8: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 82405FBC: D3810068  stfs f28, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82405FC0: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82405FC4: FC60E890  fmr f3, f29
	ctx.f[3].f64 = ctx.f[29].f64;
	// 82405FC8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82405FCC: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82405FD0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82405FD4: 4BFFF79D  bl 0x82405770
	ctx.lr = 0x82405FD8;
	sub_82405770(ctx, base);
	pc = 0x82405FD8; continue 'dispatch;
            }
            0x82405FD8 => {
    //   block [0x82405FD8..0x82405FE8)
	// 82405FD8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82405FDC: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82405FE0: 48130055  bl 0x82536034
	ctx.lr = 0x82405FE4;
	sub_82535FFC(ctx, base);
	// 82405FE4: 4812F124  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82405FE8 size=4
    let mut pc: u32 = 0x82405FE8;
    'dispatch: loop {
        match pc {
            0x82405FE8 => {
    //   block [0x82405FE8..0x82405FEC)
	// 82405FE8: 4BFFFDB0  b 0x82405d98
	sub_82405D98(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82405FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82405FF0 size=160
    let mut pc: u32 = 0x82405FF0;
    'dispatch: loop {
        match pc {
            0x82405FF0 => {
    //   block [0x82405FF0..0x82406054)
	// 82405FF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82405FF4: 4812F0BD  bl 0x825350b0
	ctx.lr = 0x82405FF8;
	sub_82535080(ctx, base);
	// 82405FF8: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 82405FFC: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82406000: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82406004: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 82406008: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8240600C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82406010: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 82406014: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82406018: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 8240601C: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 82406020: 7D254B78  mr r5, r9
	ctx.r[5].u64 = ctx.r[9].u64;
	// 82406024: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82406028: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8240602C: 7D5A5378  mr r26, r10
	ctx.r[26].u64 = ctx.r[10].u64;
	// 82406030: 480004E1  bl 0x82406510
	ctx.lr = 0x82406034;
	sub_82406510(ctx, base);
	// 82406034: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82406038: 4182001C  beq 0x82406054
	if ctx.cr[0].eq {
	pc = 0x82406054; continue 'dispatch;
	}
	// 8240603C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82406040: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82406044: 386BC0CC  addi r3, r11, -0x3f34
	ctx.r[3].s64 = ctx.r[11].s64 + -16180;
	// 82406048: 4BEACF39  bl 0x822b2f80
	ctx.lr = 0x8240604C;
	sub_822B2F80(ctx, base);
	// 8240604C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82406050: 48000030  b 0x82406080
	pc = 0x82406080; continue 'dispatch;
            }
            0x82406054 => {
    //   block [0x82406054..0x82406080)
	// 82406054: 8161011C  lwz r11, 0x11c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(284 as u32) ) } as u64;
	// 82406058: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 8240605C: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 82406060: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82406064: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82406068: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8240606C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82406070: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82406074: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82406078: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8240607C: 4BFFFD5D  bl 0x82405dd8
	ctx.lr = 0x82406080;
	sub_82405DD8(ctx, base);
	pc = 0x82406080; continue 'dispatch;
            }
            0x82406080 => {
    //   block [0x82406080..0x82406090)
	// 82406080: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82406084: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82406088: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 8240608C: 4812F074  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82406090 size=68
    let mut pc: u32 = 0x82406090;
    'dispatch: loop {
        match pc {
            0x82406090 => {
    //   block [0x82406090..0x824060D4)
	// 82406090: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82406094: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82406098: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240609C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 824060A0: FC400890  fmr f2, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[1].f64;
	// 824060A4: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	// 824060A8: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 824060AC: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 824060B0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 824060B4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 824060B8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824060BC: C02B1850  lfs f1, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 824060C0: 4BFFFD19  bl 0x82405dd8
	ctx.lr = 0x824060C4;
	sub_82405DD8(ctx, base);
	// 824060C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824060C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824060CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824060D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824060D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824060D8 size=124
    let mut pc: u32 = 0x824060D8;
    'dispatch: loop {
        match pc {
            0x824060D8 => {
    //   block [0x824060D8..0x82406148)
	// 824060D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824060DC: 4812EFDD  bl 0x825350b8
	ctx.lr = 0x824060E0;
	sub_82535080(ctx, base);
	// 824060E0: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 824060E4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824060E8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 824060EC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 824060F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824060F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824060F8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 824060FC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82406100: 4BFFF6B1  bl 0x824057b0
	ctx.lr = 0x82406104;
	sub_824057B0(ctx, base);
	// 82406104: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82406108: 40820040  bne 0x82406148
	if !ctx.cr[0].eq {
	pc = 0x82406148; continue 'dispatch;
	}
	// 8240610C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82406110: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82406114: 4BFFF6B5  bl 0x824057c8
	ctx.lr = 0x82406118;
	sub_824057C8(ctx, base);
	// 82406118: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 8240611C: 4082002C  bne 0x82406148
	if !ctx.cr[0].eq {
	pc = 0x82406148; continue 'dispatch;
	}
	// 82406120: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82406124: C0210050  lfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82406128: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 8240612C: 80A10054  lwz r5, 0x54(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82406130: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82406134: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82406138: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 8240613C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82406140: C04B1FF8  lfs f2, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82406144: 4BFFFD8D  bl 0x82405ed0
	ctx.lr = 0x82406148;
	sub_82405ED0(ctx, base);
	pc = 0x82406148; continue 'dispatch;
            }
            0x82406148 => {
    //   block [0x82406148..0x82406154)
	// 82406148: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8240614C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82406150: 4812EFB8  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82406158 size=48
    let mut pc: u32 = 0x82406158;
    'dispatch: loop {
        match pc {
            0x82406158 => {
    //   block [0x82406158..0x82406188)
	// 82406158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240615C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82406160: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82406164: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82406168: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 8240616C: 386B3838  addi r3, r11, 0x3838
	ctx.r[3].s64 = ctx.r[11].s64 + 14392;
	// 82406170: 48006D19  bl 0x8240ce88
	ctx.lr = 0x82406174;
	sub_8240CE88(ctx, base);
	// 82406174: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82406178: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8240617C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82406180: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82406184: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82406188 size=220
    let mut pc: u32 = 0x82406188;
    'dispatch: loop {
        match pc {
            0x82406188 => {
    //   block [0x82406188..0x82406204)
	// 82406188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240618C: 4812EF29  bl 0x825350b4
	ctx.lr = 0x82406190;
	sub_82535080(ctx, base);
	// 82406190: DBA1FFB8  stfd f29, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[29].u64 ) };
	// 82406194: DBC1FFC0  stfd f30, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 82406198: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 8240619C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824061A0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824061A4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 824061A8: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 824061AC: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 824061B0: FFA01890  fmr f29, f3
	ctx.f[29].f64 = ctx.f[3].f64;
	// 824061B4: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 824061B8: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 824061BC: 3BE00006  li r31, 6
	ctx.r[31].s64 = 6;
	// 824061C0: C00B2F80  lfs f0, 0x2f80(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824061C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824061C8: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 824061CC: C00B76F4  lfs f0, 0x76f4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30452 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824061D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824061D4: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 824061D8: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824061DC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824061E0: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 824061E4: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 824061E8: C1ABC10C  lfs f13, -0x3ef4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824061EC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824061F0: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 824061F4: C1AB236C  lfs f13, 0x236c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824061F8: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 824061FC: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82406200: 3B6B3838  addi r27, r11, 0x3838
	ctx.r[27].s64 = ctx.r[11].s64 + 14392;
	pc = 0x82406204; continue 'dispatch;
            }
            0x82406204 => {
    //   block [0x82406204..0x82406240)
	// 82406204: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82406208: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 8240620C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82406210: FC60E890  fmr f3, f29
	ctx.f[3].f64 = ctx.f[29].f64;
	// 82406214: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82406218: EC20F82A  fadds f1, f0, f31
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 8240621C: 48006C6D  bl 0x8240ce88
	ctx.lr = 0x82406220;
	sub_8240CE88(ctx, base);
	// 82406220: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82406224: 3BDE0018  addi r30, r30, 0x18
	ctx.r[30].s64 = ctx.r[30].s64 + 24;
	// 82406228: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 8240622C: 4082FFD8  bne 0x82406204
	if !ctx.cr[0].eq {
	pc = 0x82406204; continue 'dispatch;
	}
	// 82406230: 397C0048  addi r11, r28, 0x48
	ctx.r[11].s64 = ctx.r[28].s64 + 72;
	// 82406234: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82406238: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 8240623C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82406240; continue 'dispatch;
            }
            0x82406240 => {
    //   block [0x82406240..0x82406264)
	// 82406240: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82406244: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82406248: 4200FFF8  bdnz 0x82406240
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82406240; continue 'dispatch;
	}
	// 8240624C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82406250: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82406254: CBA1FFB8  lfd f29, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82406258: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 8240625C: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82406260: 4812EEA4  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82406268 size=188
    let mut pc: u32 = 0x82406268;
    'dispatch: loop {
        match pc {
            0x82406268 => {
    //   block [0x82406268..0x824062BC)
	// 82406268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240626C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82406270: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82406274: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82406278: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 8240627C: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82406280: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82406284: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82406288: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8240628C: ED81102A  fadds f12, f1, f2
	ctx.f[12].f64 = ((ctx.f[1].f64 + ctx.f[2].f64) as f32) as f64;
	// 82406290: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 82406294: FFE01890  fmr f31, f3
	ctx.f[31].f64 = ctx.f[3].f64;
	// 82406298: FFC02090  fmr f30, f4
	ctx.f[30].f64 = ctx.f[4].f64;
	// 8240629C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 824062A0: 39400024  li r10, 0x24
	ctx.r[10].s64 = 36;
	// 824062A4: C00B76F4  lfs f0, 0x76f4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30452 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824062A8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 824062AC: EDA10028  fsubs f13, f1, f0
	ctx.f[13].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 824062B0: EFAC002A  fadds f29, f12, f0
	ctx.f[29].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 824062B4: EC2D1028  fsubs f1, f13, f2
	ctx.f[1].f64 = (((ctx.f[13].f64 - ctx.f[2].f64) as f32) as f64);
	// 824062B8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x824062BC; continue 'dispatch;
            }
            0x824062BC => {
    //   block [0x824062BC..0x82406324)
	// 824062BC: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824062C0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824062C4: 4200FFF8  bdnz 0x824062bc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x824062BC; continue 'dispatch;
	}
	// 824062C8: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 824062CC: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 824062D0: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 824062D4: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 824062D8: 3BCB3838  addi r30, r11, 0x3838
	ctx.r[30].s64 = ctx.r[11].s64 + 14392;
	// 824062DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824062E0: 48006BA9  bl 0x8240ce88
	ctx.lr = 0x824062E4;
	sub_8240CE88(ctx, base);
	// 824062E4: 38FF0018  addi r7, r31, 0x18
	ctx.r[7].s64 = ctx.r[31].s64 + 24;
	// 824062E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824062EC: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 824062F0: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 824062F4: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 824062F8: 48006B91  bl 0x8240ce88
	ctx.lr = 0x824062FC;
	sub_8240CE88(ctx, base);
	// 824062FC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82406300: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82406304: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82406308: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8240630C: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82406310: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82406314: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82406318: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8240631C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82406320: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82406328 size=248
    let mut pc: u32 = 0x82406328;
    'dispatch: loop {
        match pc {
            0x82406328 => {
    //   block [0x82406328..0x82406368)
	// 82406328: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240632C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82406330: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82406334: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82406338: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240633C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82406340: FC001890  fmr f0, f3
	ctx.f[0].f64 = ctx.f[3].f64;
	// 82406344: FFE02890  fmr f31, f5
	ctx.f[31].f64 = ctx.f[5].f64;
	// 82406348: 7D3F4B78  mr r31, r9
	ctx.r[31].u64 = ctx.r[9].u64;
	// 8240634C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82406350: 41990018  bgt cr6, 0x82406368
	if ctx.cr[6].gt {
	pc = 0x82406368; continue 'dispatch;
	}
	// 82406354: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82406358: 386BC110  addi r3, r11, -0x3ef0
	ctx.r[3].s64 = ctx.r[11].s64 + -16112;
	// 8240635C: 4BEACC25  bl 0x822b2f80
	ctx.lr = 0x82406360;
	sub_822B2F80(ctx, base);
	// 82406360: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82406364: 480000A4  b 0x82406408
	pc = 0x82406408; continue 'dispatch;
            }
            0x82406368 => {
    //   block [0x82406368..0x82406390)
	// 82406368: 2F040001  cmpwi cr6, r4, 1
	ctx.cr[6].compare_i32(ctx.r[4].s32, 1, &mut ctx.xer);
	// 8240636C: 409A0058  bne cr6, 0x824063c4
	if !ctx.cr[6].eq {
	pc = 0x824063C4; continue 'dispatch;
	}
	// 82406370: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82406374: FC602090  fmr f3, f4
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[4].f64;
	// 82406378: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 8240637C: FC400090  fmr f2, f0
	ctx.f[2].f64 = ctx.f[0].f64;
	// 82406380: 386B3838  addi r3, r11, 0x3838
	ctx.r[3].s64 = ctx.r[11].s64 + 14392;
	// 82406384: 48006B05  bl 0x8240ce88
	ctx.lr = 0x82406388;
	sub_8240CE88(ctx, base);
	// 82406388: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 8240638C: 38E00006  li r7, 6
	ctx.r[7].s64 = 6;
	pc = 0x82406390; continue 'dispatch;
            }
            0x82406390 => {
    //   block [0x82406390..0x824063A0)
	// 82406390: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82406394: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82406398: 39000006  li r8, 6
	ctx.r[8].s64 = 6;
	// 8240639C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x824063A0; continue 'dispatch;
            }
            0x824063A0 => {
    //   block [0x824063A0..0x824063C4)
	// 824063A0: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 824063A4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 824063A8: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 824063AC: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 824063B0: 4200FFF0  bdnz 0x824063a0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x824063A0; continue 'dispatch;
	}
	// 824063B4: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 824063B8: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 824063BC: 4082FFD4  bne 0x82406390
	if !ctx.cr[0].eq {
	pc = 0x82406390; continue 'dispatch;
	}
	// 824063C0: 4800002C  b 0x824063ec
	pc = 0x824063EC; continue 'dispatch;
            }
            0x824063C4 => {
    //   block [0x824063C4..0x824063DC)
	// 824063C4: 2F040002  cmpwi cr6, r4, 2
	ctx.cr[6].compare_i32(ctx.r[4].s32, 2, &mut ctx.xer);
	// 824063C8: 409A0014  bne cr6, 0x824063dc
	if !ctx.cr[6].eq {
	pc = 0x824063DC; continue 'dispatch;
	}
	// 824063CC: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 824063D0: FC600090  fmr f3, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[0].f64;
	// 824063D4: 4BFFFE95  bl 0x82406268
	ctx.lr = 0x824063D8;
	sub_82406268(ctx, base);
	// 824063D8: 48000014  b 0x824063ec
	pc = 0x824063EC; continue 'dispatch;
            }
            0x824063DC => {
    //   block [0x824063DC..0x824063EC)
	// 824063DC: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 824063E0: FC602090  fmr f3, f4
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[4].f64;
	// 824063E4: FC400090  fmr f2, f0
	ctx.f[2].f64 = ctx.f[0].f64;
	// 824063E8: 4BFFFDA1  bl 0x82406188
	ctx.lr = 0x824063EC;
	sub_82406188(ctx, base);
	pc = 0x824063EC; continue 'dispatch;
            }
            0x824063EC => {
    //   block [0x824063EC..0x824063F4)
	// 824063EC: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 824063F0: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	pc = 0x824063F4; continue 'dispatch;
            }
            0x824063F4 => {
    //   block [0x824063F4..0x82406408)
	// 824063F4: D3EA0000  stfs f31, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 824063F8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824063FC: 394A0018  addi r10, r10, 0x18
	ctx.r[10].s64 = ctx.r[10].s64 + 24;
	// 82406400: 4082FFF4  bne 0x824063f4
	if !ctx.cr[0].eq {
	pc = 0x824063F4; continue 'dispatch;
	}
	// 82406404: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82406408; continue 'dispatch;
            }
            0x82406408 => {
    //   block [0x82406408..0x82406420)
	// 82406408: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8240640C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82406410: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82406414: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82406418: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8240641C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82406420 size=164
    let mut pc: u32 = 0x82406420;
    'dispatch: loop {
        match pc {
            0x82406420 => {
    //   block [0x82406420..0x82406450)
	// 82406420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82406424: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82406428: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240642C: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82406430: FC001090  fmr f0, f2
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[2].f64;
	// 82406434: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82406438: 806B3830  lwz r3, 0x3830(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14384 as u32) ) } as u64;
	// 8240643C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82406440: 409A0010  bne cr6, 0x82406450
	if !ctx.cr[6].eq {
	pc = 0x82406450; continue 'dispatch;
	}
	// 82406444: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82406448: 6063002E  ori r3, r3, 0x2e
	ctx.r[3].u64 = ctx.r[3].u64 | 46;
	// 8240644C: 48000068  b 0x824064b4
	pc = 0x824064B4; continue 'dispatch;
            }
            0x82406450 => {
    //   block [0x82406450..0x82406484)
	// 82406450: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 82406454: 419A0050  beq cr6, 0x824064a4
	if ctx.cr[6].eq {
	pc = 0x824064A4; continue 'dispatch;
	}
	// 82406458: 2F090002  cmpwi cr6, r9, 2
	ctx.cr[6].compare_i32(ctx.r[9].s32, 2, &mut ctx.xer);
	// 8240645C: 419A003C  beq cr6, 0x82406498
	if ctx.cr[6].eq {
	pc = 0x82406498; continue 'dispatch;
	}
	// 82406460: 2F090004  cmpwi cr6, r9, 4
	ctx.cr[6].compare_i32(ctx.r[9].s32, 4, &mut ctx.xer);
	// 82406464: 419A0020  beq cr6, 0x82406484
	if ctx.cr[6].eq {
	pc = 0x82406484; continue 'dispatch;
	}
	// 82406468: 2F090006  cmpwi cr6, r9, 6
	ctx.cr[6].compare_i32(ctx.r[9].s32, 6, &mut ctx.xer);
	// 8240646C: 419A0018  beq cr6, 0x82406484
	if ctx.cr[6].eq {
	pc = 0x82406484; continue 'dispatch;
	}
	// 82406470: 2F090008  cmpwi cr6, r9, 8
	ctx.cr[6].compare_i32(ctx.r[9].s32, 8, &mut ctx.xer);
	// 82406474: 419A0010  beq cr6, 0x82406484
	if ctx.cr[6].eq {
	pc = 0x82406484; continue 'dispatch;
	}
	// 82406478: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 8240647C: 6063001A  ori r3, r3, 0x1a
	ctx.r[3].u64 = ctx.r[3].u64 | 26;
	// 82406480: 48000034  b 0x824064b4
	pc = 0x824064B4; continue 'dispatch;
            }
            0x82406484 => {
    //   block [0x82406484..0x82406498)
	// 82406484: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82406488: FC401890  fmr f2, f3
	ctx.f[2].f64 = ctx.f[3].f64;
	// 8240648C: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 82406490: 48008009  bl 0x8240e498
	ctx.lr = 0x82406494;
	sub_8240E498(ctx, base);
	// 82406494: 48000020  b 0x824064b4
	pc = 0x824064B4; continue 'dispatch;
            }
            0x82406498 => {
    //   block [0x82406498..0x824064A4)
	// 82406498: FC400090  fmr f2, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[0].f64;
	// 8240649C: 48007FCD  bl 0x8240e468
	ctx.lr = 0x824064A0;
	sub_8240E468(ctx, base);
	// 824064A0: 48000014  b 0x824064b4
	pc = 0x824064B4; continue 'dispatch;
            }
            0x824064A4 => {
    //   block [0x824064A4..0x824064B4)
	// 824064A4: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 824064A8: FC401890  fmr f2, f3
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[3].f64;
	// 824064AC: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 824064B0: 48007F81  bl 0x8240e430
	ctx.lr = 0x824064B4;
	sub_8240E430(ctx, base);
	pc = 0x824064B4; continue 'dispatch;
            }
            0x824064B4 => {
    //   block [0x824064B4..0x824064C4)
	// 824064B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824064B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824064BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824064C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824064C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824064C8 size=32
    let mut pc: u32 = 0x824064C8;
    'dispatch: loop {
        match pc {
            0x824064C8 => {
    //   block [0x824064C8..0x824064E8)
	// 824064C8: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 824064CC: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 824064D0: 816B3830  lwz r11, 0x3830(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14384 as u32) ) } as u64;
	// 824064D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824064D8: 409A0010  bne cr6, 0x824064e8
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x824064E8);
		return;
	}
	// 824064DC: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 824064E0: 6063002E  ori r3, r3, 0x2e
	ctx.r[3].u64 = ctx.r[3].u64 | 46;
	// 824064E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82406500 size=16
    let mut pc: u32 = 0x82406500;
    'dispatch: loop {
        match pc {
            0x82406500 => {
    //   block [0x82406500..0x82406510)
	// 82406500: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82406504: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82406508: 386B3838  addi r3, r11, 0x3838
	ctx.r[3].s64 = ctx.r[11].s64 + 14392;
	// 8240650C: 480063F4  b 0x8240c900
	sub_8240C900(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82406510 size=32
    let mut pc: u32 = 0x82406510;
    'dispatch: loop {
        match pc {
            0x82406510 => {
    //   block [0x82406510..0x82406530)
	// 82406510: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82406514: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 82406518: 816B3830  lwz r11, 0x3830(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14384 as u32) ) } as u64;
	// 8240651C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82406520: 409A0010  bne cr6, 0x82406530
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82406530);
		return;
	}
	// 82406524: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82406528: 6063002E  ori r3, r3, 0x2e
	ctx.r[3].u64 = ctx.r[3].u64 | 46;
	// 8240652C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82406548 size=16
    let mut pc: u32 = 0x82406548;
    'dispatch: loop {
        match pc {
            0x82406548 => {
    //   block [0x82406548..0x82406558)
	// 82406548: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8240654C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82406550: 386B3838  addi r3, r11, 0x3838
	ctx.r[3].s64 = ctx.r[11].s64 + 14392;
	// 82406554: 480068F4  b 0x8240ce48
	sub_8240CE48(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82406558 size=40
    let mut pc: u32 = 0x82406558;
    'dispatch: loop {
        match pc {
            0x82406558 => {
    //   block [0x82406558..0x82406580)
	// 82406558: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 8240655C: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 82406560: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82406564: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 82406568: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 8240656C: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82406570: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82406574: 386A3838  addi r3, r10, 0x3838
	ctx.r[3].s64 = ctx.r[10].s64 + 14392;
	// 82406578: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 8240657C: 4800646C  b 0x8240c9e8
	sub_8240C9E8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82406580 size=28
    let mut pc: u32 = 0x82406580;
    'dispatch: loop {
        match pc {
            0x82406580 => {
    //   block [0x82406580..0x8240659C)
	// 82406580: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82406584: 806B3830  lwz r3, 0x3830(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14384 as u32) ) } as u64;
	// 82406588: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8240658C: 409A0010  bne cr6, 0x8240659c
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x8240659C);
		return;
	}
	// 82406590: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82406594: 6063002E  ori r3, r3, 0x2e
	ctx.r[3].u64 = ctx.r[3].u64 | 46;
	// 82406598: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824065A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824065A0 size=220
    let mut pc: u32 = 0x824065A0;
    'dispatch: loop {
        match pc {
            0x824065A0 => {
    //   block [0x824065A0..0x824065CC)
	// 824065A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824065A4: 4812EB19  bl 0x825350bc
	ctx.lr = 0x824065A8;
	sub_82535080(ctx, base);
	// 824065A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824065AC: 3FA08288  lis r29, -0x7d78
	ctx.r[29].s64 = -2105016320;
	// 824065B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824065B4: 807D3830  lwz r3, 0x3830(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14384 as u32) ) } as u64;
	// 824065B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 824065BC: 409A0010  bne cr6, 0x824065cc
	if !ctx.cr[6].eq {
	pc = 0x824065CC; continue 'dispatch;
	}
	// 824065C0: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 824065C4: 6063002E  ori r3, r3, 0x2e
	ctx.r[3].u64 = ctx.r[3].u64 | 46;
	// 824065C8: 480000AC  b 0x82406674
	pc = 0x82406674; continue 'dispatch;
            }
            0x824065CC => {
    //   block [0x824065CC..0x824065E0)
	// 824065CC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 824065D0: 409A0010  bne cr6, 0x824065e0
	if !ctx.cr[6].eq {
	pc = 0x824065E0; continue 'dispatch;
	}
	// 824065D4: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 824065D8: 60630037  ori r3, r3, 0x37
	ctx.r[3].u64 = ctx.r[3].u64 | 55;
	// 824065DC: 48000098  b 0x82406674
	pc = 0x82406674; continue 'dispatch;
            }
            0x824065E0 => {
    //   block [0x824065E0..0x82406608)
	// 824065E0: 889F0005  lbz r4, 5(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(5 as u32) ) } as u64;
	// 824065E4: 2B040002  cmplwi cr6, r4, 2
	ctx.cr[6].compare_u32(ctx.r[4].u32, 2 as u32, &mut ctx.xer);
	// 824065E8: 419A0020  beq cr6, 0x82406608
	if ctx.cr[6].eq {
	pc = 0x82406608; continue 'dispatch;
	}
	// 824065EC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824065F0: 88BF0006  lbz r5, 6(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 824065F4: 386BC150  addi r3, r11, -0x3eb0
	ctx.r[3].s64 = ctx.r[11].s64 + -16048;
	// 824065F8: 4BEAC989  bl 0x822b2f80
	ctx.lr = 0x824065FC;
	sub_822B2F80(ctx, base);
	// 824065FC: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82406600: 60630036  ori r3, r3, 0x36
	ctx.r[3].u64 = ctx.r[3].u64 | 54;
	// 82406604: 48000070  b 0x82406674
	pc = 0x82406674; continue 'dispatch;
            }
            0x82406608 => {
    //   block [0x82406608..0x82406644)
	// 82406608: C03F0010  lfs f1, 0x10(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8240660C: 4800715D  bl 0x8240d768
	ctx.lr = 0x82406610;
	sub_8240D768(ctx, base);
	// 82406610: 807D3830  lwz r3, 0x3830(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14384 as u32) ) } as u64;
	// 82406614: C03F0014  lfs f1, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82406618: 480071A9  bl 0x8240d7c0
	ctx.lr = 0x8240661C;
	sub_8240D7C0(ctx, base);
	// 8240661C: 807D3830  lwz r3, 0x3830(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14384 as u32) ) } as u64;
	// 82406620: C03F0018  lfs f1, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82406624: 480071F5  bl 0x8240d818
	ctx.lr = 0x82406628;
	sub_8240D818(ctx, base);
	// 82406628: 807D3830  lwz r3, 0x3830(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14384 as u32) ) } as u64;
	// 8240662C: C03F001C  lfs f1, 0x1c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82406630: 48007251  bl 0x8240d880
	ctx.lr = 0x82406634;
	sub_8240D880(ctx, base);
	// 82406634: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82406638: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8240663C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82406640: 40990030  ble cr6, 0x82406670
	if !ctx.cr[6].gt {
	pc = 0x82406670; continue 'dispatch;
	}
	pc = 0x82406644; continue 'dispatch;
            }
            0x82406644 => {
    //   block [0x82406644..0x82406670)
	// 82406644: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82406648: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8240664C: 807D3830  lwz r3, 0x3830(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14384 as u32) ) } as u64;
	// 82406650: 7D7E59D6  mullw r11, r30, r11
	ctx.r[11].s32 = ((ctx.r[30].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82406654: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82406658: 38AB0020  addi r5, r11, 0x20
	ctx.r[5].s64 = ctx.r[11].s64 + 32;
	// 8240665C: 480074AD  bl 0x8240db08
	ctx.lr = 0x82406660;
	sub_8240DB08(ctx, base);
	// 82406660: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82406664: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82406668: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8240666C: 4198FFD8  blt cr6, 0x82406644
	if ctx.cr[6].lt {
	pc = 0x82406644; continue 'dispatch;
	}
	pc = 0x82406670; continue 'dispatch;
            }
            0x82406670 => {
    //   block [0x82406670..0x82406674)
	// 82406670: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82406674; continue 'dispatch;
            }
            0x82406674 => {
    //   block [0x82406674..0x8240667C)
	// 82406674: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82406678: 4812EA94  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82406680 size=132
    let mut pc: u32 = 0x82406680;
    'dispatch: loop {
        match pc {
            0x82406680 => {
    //   block [0x82406680..0x824066D0)
	// 82406680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82406684: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82406688: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8240668C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82406690: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82406694: 3FE08288  lis r31, -0x7d78
	ctx.r[31].s64 = -2105016320;
	// 82406698: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8240669C: 817F3830  lwz r11, 0x3830(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(14384 as u32) ) } as u64;
	// 824066A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824066A4: 409A0040  bne cr6, 0x824066e4
	if !ctx.cr[6].eq {
	pc = 0x824066E4; continue 'dispatch;
	}
	// 824066A8: 3D608273  lis r11, -0x7d8d
	ctx.r[11].s64 = -2106392576;
	// 824066AC: 38602618  li r3, 0x2618
	ctx.r[3].s64 = 9752;
	// 824066B0: 816B3800  lwz r11, 0x3800(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14336 as u32) ) } as u64;
	// 824066B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824066B8: 4E800421  bctrl
	ctx.lr = 0x824066BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824066BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 824066C0: 41820010  beq 0x824066d0
	if ctx.cr[0].eq {
	pc = 0x824066D0; continue 'dispatch;
	}
	// 824066C4: 48006DAD  bl 0x8240d470
	ctx.lr = 0x824066C8;
	sub_8240D470(ctx, base);
	// 824066C8: 907F3830  stw r3, 0x3830(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(14384 as u32), ctx.r[3].u32 ) };
	// 824066CC: 4800000C  b 0x824066d8
	pc = 0x824066D8; continue 'dispatch;
            }
            0x824066D0 => {
    //   block [0x824066D0..0x824066D8)
	// 824066D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824066D4: 917F3830  stw r11, 0x3830(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(14384 as u32), ctx.r[11].u32 ) };
	pc = 0x824066D8; continue 'dispatch;
            }
            0x824066D8 => {
    //   block [0x824066D8..0x824066E4)
	// 824066D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824066DC: 4BFFFEC5  bl 0x824065a0
	ctx.lr = 0x824066E0;
	sub_824065A0(ctx, base);
	// 824066E0: 4800000C  b 0x824066ec
	pc = 0x824066EC; continue 'dispatch;
            }
            0x824066E4 => {
    //   block [0x824066E4..0x824066EC)
	// 824066E4: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 824066E8: 60630030  ori r3, r3, 0x30
	ctx.r[3].u64 = ctx.r[3].u64 | 48;
	pc = 0x824066EC; continue 'dispatch;
            }
            0x824066EC => {
    //   block [0x824066EC..0x82406704)
	// 824066EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824066F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824066F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824066F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824066FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82406700: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82406708 size=112
    let mut pc: u32 = 0x82406708;
    'dispatch: loop {
        match pc {
            0x82406708 => {
    //   block [0x82406708..0x82406724)
	// 82406708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240670C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82406710: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82406714: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82406718: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240671C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82406720: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82406724; continue 'dispatch;
            }
            0x82406724 => {
    //   block [0x82406724..0x82406758)
	// 82406724: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82406728: 4BFFF0B9  bl 0x824057e0
	ctx.lr = 0x8240672C;
	sub_824057E0(ctx, base);
	// 8240672C: 7F03F040  cmplw cr6, r3, r30
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82406730: 419A0040  beq cr6, 0x82406770
	if ctx.cr[6].eq {
	pc = 0x82406770; continue 'dispatch;
	}
	// 82406734: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82406738: 2F1F00C0  cmpwi cr6, r31, 0xc0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 192, &mut ctx.xer);
	// 8240673C: 4198FFE8  blt cr6, 0x82406724
	if ctx.cr[6].lt {
	pc = 0x82406724; continue 'dispatch;
	}
	// 82406740: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82406744: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82406748: 386BC188  addi r3, r11, -0x3e78
	ctx.r[3].s64 = ctx.r[11].s64 + -15992;
	// 8240674C: 4BEAC835  bl 0x822b2f80
	ctx.lr = 0x82406750;
	sub_822B2F80(ctx, base);
	// 82406750: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82406754: 60630012  ori r3, r3, 0x12
	ctx.r[3].u64 = ctx.r[3].u64 | 18;
	pc = 0x82406758; continue 'dispatch;
            }
            0x82406758 => {
    //   block [0x82406758..0x82406770)
	// 82406758: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8240675C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82406760: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82406764: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82406768: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8240676C: 4E800020  blr
	return;
            }
            0x82406770 => {
    //   block [0x82406770..0x82406778)
	// 82406770: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82406774: 4BFFFFE4  b 0x82406758
	pc = 0x82406758; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82406778 size=172
    let mut pc: u32 = 0x82406778;
    'dispatch: loop {
        match pc {
            0x82406778 => {
    //   block [0x82406778..0x824067AC)
	// 82406778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240677C: 4812E93D  bl 0x825350b8
	ctx.lr = 0x82406780;
	sub_82535080(ctx, base);
	// 82406780: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82406784: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82406788: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8240678C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82406790: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82406794: 4099007C  ble cr6, 0x82406810
	if !ctx.cr[6].gt {
	pc = 0x82406810; continue 'dispatch;
	}
	// 82406798: 4BFFFF71  bl 0x82406708
	ctx.lr = 0x8240679C;
	sub_82406708(ctx, base);
	// 8240679C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824067A0: 4080000C  bge 0x824067ac
	if !ctx.cr[0].lt {
	pc = 0x824067AC; continue 'dispatch;
	}
	// 824067A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824067A8: 48000074  b 0x8240681c
	pc = 0x8240681C; continue 'dispatch;
            }
            0x824067AC => {
    //   block [0x824067AC..0x82406810)
	// 824067AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824067B0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824067B4: 4BFFEFFD  bl 0x824057b0
	ctx.lr = 0x824067B8;
	sub_824057B0(ctx, base);
	// 824067B8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 824067BC: 40820060  bne 0x8240681c
	if !ctx.cr[0].eq {
	pc = 0x8240681C; continue 'dispatch;
	}
	// 824067C0: 7FAA07B4  extsw r10, r29
	ctx.r[10].s64 = ctx.r[29].s32 as i64;
	// 824067C4: C1A10050  lfs f13, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824067C8: 57EB2036  slwi r11, r31, 4
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824067CC: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 824067D0: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 824067D4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 824067D8: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 824067DC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 824067E0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 824067E4: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 824067E8: C1AA1FF8  lfs f13, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824067EC: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 824067F0: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 824067F4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 824067F8: 40980018  bge cr6, 0x82406810
	if !ctx.cr[6].lt {
	pc = 0x82406810; continue 'dispatch;
	}
	// 824067FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82406800: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82406804: 938B000C  stw r28, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82406808: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8240680C: 4800000C  b 0x82406818
	pc = 0x82406818; continue 'dispatch;
            }
            0x82406810 => {
    //   block [0x82406810..0x82406818)
	// 82406810: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82406814: 4BFFF585  bl 0x82405d98
	ctx.lr = 0x82406818;
	sub_82405D98(ctx, base);
	pc = 0x82406818; continue 'dispatch;
            }
            0x82406818 => {
    //   block [0x82406818..0x8240681C)
	// 82406818: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x8240681C; continue 'dispatch;
            }
            0x8240681C => {
    //   block [0x8240681C..0x82406824)
	// 8240681C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82406820: 4812E8E8  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82406828 size=220
    let mut pc: u32 = 0x82406828;
    'dispatch: loop {
        match pc {
            0x82406828 => {
    //   block [0x82406828..0x82406850)
	// 82406828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240682C: 4812E88D  bl 0x825350b8
	ctx.lr = 0x82406830;
	sub_82535080(ctx, base);
	// 82406830: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82406834: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82406838: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8240683C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82406840: 3BE3000C  addi r31, r3, 0xc
	ctx.r[31].s64 = ctx.r[3].s64 + 12;
	// 82406844: 3B8000C0  li r28, 0xc0
	ctx.r[28].s64 = 192;
	// 82406848: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8240684C: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82406850; continue 'dispatch;
            }
            0x82406850 => {
    //   block [0x82406850..0x82406880)
	// 82406850: 817FFFF8  lwz r11, -8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82406854: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82406858: 40990084  ble cr6, 0x824068dc
	if !ctx.cr[6].gt {
	pc = 0x824068DC; continue 'dispatch;
	}
	// 8240685C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82406860: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82406864: 41820078  beq 0x824068dc
	if ctx.cr[0].eq {
	pc = 0x824068DC; continue 'dispatch;
	}
	// 82406868: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8240686C: 4BFFEF45  bl 0x824057b0
	ctx.lr = 0x82406870;
	sub_824057B0(ctx, base);
	// 82406870: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82406874: 4182000C  beq 0x82406880
	if ctx.cr[0].eq {
	pc = 0x82406880; continue 'dispatch;
	}
	// 82406878: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8240687C: 4800006C  b 0x824068e8
	pc = 0x824068E8; continue 'dispatch;
            }
            0x82406880 => {
    //   block [0x82406880..0x824068AC)
	// 82406880: 7BAB0020  clrldi r11, r29, 0x20
	ctx.r[11].u64 = ctx.r[29].u64 & 0x00000000FFFFFFFFu64;
	// 82406884: C01FFFF4  lfs f0, -0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82406888: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8240688C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82406890: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82406894: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82406898: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8240689C: EC20637A  fmadds f1, f0, f13, f12
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 824068A0: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 824068A4: 40980008  bge cr6, 0x824068ac
	if !ctx.cr[6].lt {
	pc = 0x824068AC; continue 'dispatch;
	}
	// 824068A8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	pc = 0x824068AC; continue 'dispatch;
            }
            0x824068AC => {
    //   block [0x824068AC..0x824068DC)
	// 824068AC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824068B0: 4BFFEE89  bl 0x82405738
	ctx.lr = 0x824068B4;
	sub_82405738(ctx, base);
	// 824068B4: 817FFFF8  lwz r11, -8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824068B8: 7D7D5851  subf. r11, r29, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824068BC: 917FFFF8  stw r11, -8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-8 as u32), ctx.r[11].u32 ) };
	// 824068C0: 4181001C  bgt 0x824068dc
	if ctx.cr[0].gt {
	pc = 0x824068DC; continue 'dispatch;
	}
	// 824068C4: 817FFFFC  lwz r11, -4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 824068C8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824068CC: 419A0010  beq cr6, 0x824068dc
	if ctx.cr[6].eq {
	pc = 0x824068DC; continue 'dispatch;
	}
	// 824068D0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824068D4: 4BFFF4C5  bl 0x82405d98
	ctx.lr = 0x824068D8;
	sub_82405D98(ctx, base);
	// 824068D8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x824068DC; continue 'dispatch;
            }
            0x824068DC => {
    //   block [0x824068DC..0x824068E8)
	// 824068DC: 817FFFF8  lwz r11, -8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824068E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824068E4: 41990008  bgt cr6, 0x824068ec
	if ctx.cr[6].gt {
	pc = 0x824068EC; continue 'dispatch;
	}
	pc = 0x824068E8; continue 'dispatch;
            }
            0x824068E8 => {
    //   block [0x824068E8..0x824068EC)
	// 824068E8: 93DFFFF8  stw r30, -8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-8 as u32), ctx.r[30].u32 ) };
	pc = 0x824068EC; continue 'dispatch;
            }
            0x824068EC => {
    //   block [0x824068EC..0x82406904)
	// 824068EC: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 824068F0: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 824068F4: 4082FF5C  bne 0x82406850
	if !ctx.cr[0].eq {
	pc = 0x82406850; continue 'dispatch;
	}
	// 824068F8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 824068FC: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82406900: 4812E808  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82406908 size=24
    let mut pc: u32 = 0x82406908;
    'dispatch: loop {
        match pc {
            0x82406908 => {
    //   block [0x82406908..0x82406920)
	// 82406908: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8240690C: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 82406910: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82406914: 386A3A68  addi r3, r10, 0x3a68
	ctx.r[3].s64 = ctx.r[10].s64 + 14952;
	// 82406918: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 8240691C: 4BFFFE5C  b 0x82406778
	sub_82406778(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82406920 size=16
    let mut pc: u32 = 0x82406920;
    'dispatch: loop {
        match pc {
            0x82406920 => {
    //   block [0x82406920..0x82406930)
	// 82406920: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82406924: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82406928: 386B3A68  addi r3, r11, 0x3a68
	ctx.r[3].s64 = ctx.r[11].s64 + 14952;
	// 8240692C: 4BFFFEFC  b 0x82406828
	sub_82406828(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82406930 size=60
    let mut pc: u32 = 0x82406930;
    'dispatch: loop {
        match pc {
            0x82406930 => {
    //   block [0x82406930..0x8240694C)
	// 82406930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82406934: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82406938: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240693C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82406940: 419A000C  beq cr6, 0x8240694c
	if ctx.cr[6].eq {
	pc = 0x8240694C; continue 'dispatch;
	}
	// 82406944: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82406948: 48000014  b 0x8240695c
	pc = 0x8240695C; continue 'dispatch;
            }
            0x8240694C => {
    //   block [0x8240694C..0x8240695C)
	// 8240694C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82406950: 386BC1D0  addi r3, r11, -0x3e30
	ctx.r[3].s64 = ctx.r[11].s64 + -15920;
	// 82406954: 4BEAC62D  bl 0x822b2f80
	ctx.lr = 0x82406958;
	sub_822B2F80(ctx, base);
	// 82406958: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x8240695C; continue 'dispatch;
            }
            0x8240695C => {
    //   block [0x8240695C..0x8240696C)
	// 8240695C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82406960: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82406964: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82406968: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82406970 size=60
    let mut pc: u32 = 0x82406970;
    'dispatch: loop {
        match pc {
            0x82406970 => {
    //   block [0x82406970..0x8240698C)
	// 82406970: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82406974: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82406978: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240697C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82406980: 419A000C  beq cr6, 0x8240698c
	if ctx.cr[6].eq {
	pc = 0x8240698C; continue 'dispatch;
	}
	// 82406984: 88640000  lbz r3, 0(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82406988: 48000014  b 0x8240699c
	pc = 0x8240699C; continue 'dispatch;
            }
            0x8240698C => {
    //   block [0x8240698C..0x8240699C)
	// 8240698C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82406990: 386BC228  addi r3, r11, -0x3dd8
	ctx.r[3].s64 = ctx.r[11].s64 + -15832;
	// 82406994: 4BEAC5ED  bl 0x822b2f80
	ctx.lr = 0x82406998;
	sub_822B2F80(ctx, base);
	// 82406998: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x8240699C; continue 'dispatch;
            }
            0x8240699C => {
    //   block [0x8240699C..0x824069AC)
	// 8240699C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824069A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824069A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824069A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824069B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824069B0 size=60
    let mut pc: u32 = 0x824069B0;
    'dispatch: loop {
        match pc {
            0x824069B0 => {
    //   block [0x824069B0..0x824069CC)
	// 824069B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824069B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824069B8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824069BC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 824069C0: 419A000C  beq cr6, 0x824069cc
	if ctx.cr[6].eq {
	pc = 0x824069CC; continue 'dispatch;
	}
	// 824069C4: 88640001  lbz r3, 1(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(1 as u32) ) } as u64;
	// 824069C8: 48000014  b 0x824069dc
	pc = 0x824069DC; continue 'dispatch;
            }
            0x824069CC => {
    //   block [0x824069CC..0x824069DC)
	// 824069CC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824069D0: 386BC278  addi r3, r11, -0x3d88
	ctx.r[3].s64 = ctx.r[11].s64 + -15752;
	// 824069D4: 4BEAC5AD  bl 0x822b2f80
	ctx.lr = 0x824069D8;
	sub_822B2F80(ctx, base);
	// 824069D8: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x824069DC; continue 'dispatch;
            }
            0x824069DC => {
    //   block [0x824069DC..0x824069EC)
	// 824069DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824069E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824069E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824069E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824069F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824069F0 size=60
    let mut pc: u32 = 0x824069F0;
    'dispatch: loop {
        match pc {
            0x824069F0 => {
    //   block [0x824069F0..0x82406A0C)
	// 824069F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824069F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824069F8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824069FC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82406A00: 419A000C  beq cr6, 0x82406a0c
	if ctx.cr[6].eq {
	pc = 0x82406A0C; continue 'dispatch;
	}
	// 82406A04: 88640002  lbz r3, 2(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(2 as u32) ) } as u64;
	// 82406A08: 48000014  b 0x82406a1c
	pc = 0x82406A1C; continue 'dispatch;
            }
            0x82406A0C => {
    //   block [0x82406A0C..0x82406A1C)
	// 82406A0C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82406A10: 386BC2D0  addi r3, r11, -0x3d30
	ctx.r[3].s64 = ctx.r[11].s64 + -15664;
	// 82406A14: 4BEAC56D  bl 0x822b2f80
	ctx.lr = 0x82406A18;
	sub_822B2F80(ctx, base);
	// 82406A18: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82406A1C; continue 'dispatch;
            }
            0x82406A1C => {
    //   block [0x82406A1C..0x82406A2C)
	// 82406A1C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82406A20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82406A24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82406A28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406A30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82406A30 size=60
    let mut pc: u32 = 0x82406A30;
    'dispatch: loop {
        match pc {
            0x82406A30 => {
    //   block [0x82406A30..0x82406A4C)
	// 82406A30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82406A34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82406A38: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82406A3C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82406A40: 419A000C  beq cr6, 0x82406a4c
	if ctx.cr[6].eq {
	pc = 0x82406A4C; continue 'dispatch;
	}
	// 82406A44: 80640008  lwz r3, 8(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82406A48: 48000014  b 0x82406a5c
	pc = 0x82406A5C; continue 'dispatch;
            }
            0x82406A4C => {
    //   block [0x82406A4C..0x82406A5C)
	// 82406A4C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82406A50: 386BC328  addi r3, r11, -0x3cd8
	ctx.r[3].s64 = ctx.r[11].s64 + -15576;
	// 82406A54: 4BEAC52D  bl 0x822b2f80
	ctx.lr = 0x82406A58;
	sub_822B2F80(ctx, base);
	// 82406A58: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82406A5C; continue 'dispatch;
            }
            0x82406A5C => {
    //   block [0x82406A5C..0x82406A6C)
	// 82406A5C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82406A60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82406A64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82406A68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406A70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82406A70 size=60
    let mut pc: u32 = 0x82406A70;
    'dispatch: loop {
        match pc {
            0x82406A70 => {
    //   block [0x82406A70..0x82406A8C)
	// 82406A70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82406A74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82406A78: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82406A7C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82406A80: 419A000C  beq cr6, 0x82406a8c
	if ctx.cr[6].eq {
	pc = 0x82406A8C; continue 'dispatch;
	}
	// 82406A84: 8064000C  lwz r3, 0xc(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82406A88: 48000014  b 0x82406a9c
	pc = 0x82406A9C; continue 'dispatch;
            }
            0x82406A8C => {
    //   block [0x82406A8C..0x82406A9C)
	// 82406A8C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82406A90: 386BC378  addi r3, r11, -0x3c88
	ctx.r[3].s64 = ctx.r[11].s64 + -15496;
	// 82406A94: 4BEAC4ED  bl 0x822b2f80
	ctx.lr = 0x82406A98;
	sub_822B2F80(ctx, base);
	// 82406A98: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82406A9C; continue 'dispatch;
            }
            0x82406A9C => {
    //   block [0x82406A9C..0x82406AAC)
	// 82406A9C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82406AA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82406AA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82406AA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406AB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82406AB0 size=60
    let mut pc: u32 = 0x82406AB0;
    'dispatch: loop {
        match pc {
            0x82406AB0 => {
    //   block [0x82406AB0..0x82406ACC)
	// 82406AB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82406AB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82406AB8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82406ABC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82406AC0: 419A000C  beq cr6, 0x82406acc
	if ctx.cr[6].eq {
	pc = 0x82406ACC; continue 'dispatch;
	}
	// 82406AC4: 80640010  lwz r3, 0x10(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82406AC8: 48000014  b 0x82406adc
	pc = 0x82406ADC; continue 'dispatch;
            }
            0x82406ACC => {
    //   block [0x82406ACC..0x82406ADC)
	// 82406ACC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82406AD0: 386BC3C8  addi r3, r11, -0x3c38
	ctx.r[3].s64 = ctx.r[11].s64 + -15416;
	// 82406AD4: 4BEAC4AD  bl 0x822b2f80
	ctx.lr = 0x82406AD8;
	sub_822B2F80(ctx, base);
	// 82406AD8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82406ADC; continue 'dispatch;
            }
            0x82406ADC => {
    //   block [0x82406ADC..0x82406AEC)
	// 82406ADC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82406AE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82406AE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82406AE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406AF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82406AF0 size=60
    let mut pc: u32 = 0x82406AF0;
    'dispatch: loop {
        match pc {
            0x82406AF0 => {
    //   block [0x82406AF0..0x82406B0C)
	// 82406AF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82406AF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82406AF8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82406AFC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82406B00: 419A000C  beq cr6, 0x82406b0c
	if ctx.cr[6].eq {
	pc = 0x82406B0C; continue 'dispatch;
	}
	// 82406B04: 80640014  lwz r3, 0x14(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82406B08: 48000014  b 0x82406b1c
	pc = 0x82406B1C; continue 'dispatch;
            }
            0x82406B0C => {
    //   block [0x82406B0C..0x82406B1C)
	// 82406B0C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82406B10: 386BC420  addi r3, r11, -0x3be0
	ctx.r[3].s64 = ctx.r[11].s64 + -15328;
	// 82406B14: 4BEAC46D  bl 0x822b2f80
	ctx.lr = 0x82406B18;
	sub_822B2F80(ctx, base);
	// 82406B18: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82406B1C; continue 'dispatch;
            }
            0x82406B1C => {
    //   block [0x82406B1C..0x82406B2C)
	// 82406B1C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82406B20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82406B24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82406B28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406B30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82406B30 size=108
    let mut pc: u32 = 0x82406B30;
    'dispatch: loop {
        match pc {
            0x82406B30 => {
    //   block [0x82406B30..0x82406B5C)
	// 82406B30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82406B34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82406B38: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82406B3C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82406B40: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82406B44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82406B48: 409A0014  bne cr6, 0x82406b5c
	if !ctx.cr[6].eq {
	pc = 0x82406B5C; continue 'dispatch;
	}
	// 82406B4C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82406B50: 386BC4D0  addi r3, r11, -0x3b30
	ctx.r[3].s64 = ctx.r[11].s64 + -15152;
	// 82406B54: 4BEAC42D  bl 0x822b2f80
	ctx.lr = 0x82406B58;
	sub_822B2F80(ctx, base);
	// 82406B58: 48000030  b 0x82406b88
	pc = 0x82406B88; continue 'dispatch;
            }
            0x82406B5C => {
    //   block [0x82406B5C..0x82406B78)
	// 82406B5C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82406B60: 41980018  blt cr6, 0x82406b78
	if ctx.cr[6].lt {
	pc = 0x82406B78; continue 'dispatch;
	}
	// 82406B64: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82406B68: 7F045000  cmpw cr6, r4, r10
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82406B6C: 4098000C  bge cr6, 0x82406b78
	if !ctx.cr[6].lt {
	pc = 0x82406B78; continue 'dispatch;
	}
	// 82406B70: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82406B74: 48000018  b 0x82406b8c
	pc = 0x82406B8C; continue 'dispatch;
            }
            0x82406B78 => {
    //   block [0x82406B78..0x82406B88)
	// 82406B78: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82406B7C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82406B80: 386BC478  addi r3, r11, -0x3b88
	ctx.r[3].s64 = ctx.r[11].s64 + -15240;
	// 82406B84: 4BEAC3FD  bl 0x822b2f80
	ctx.lr = 0x82406B88;
	sub_822B2F80(ctx, base);
	pc = 0x82406B88; continue 'dispatch;
            }
            0x82406B88 => {
    //   block [0x82406B88..0x82406B8C)
	// 82406B88: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82406B8C; continue 'dispatch;
            }
            0x82406B8C => {
    //   block [0x82406B8C..0x82406B9C)
	// 82406B8C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82406B90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82406B94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82406B98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82406BA0 size=104
    let mut pc: u32 = 0x82406BA0;
    'dispatch: loop {
        match pc {
            0x82406BA0 => {
    //   block [0x82406BA0..0x82406BDC)
	// 82406BA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82406BA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82406BA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82406BAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82406BB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82406BB4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82406BB8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82406BBC: 4BFFFF75  bl 0x82406b30
	ctx.lr = 0x82406BC0;
	sub_82406B30(ctx, base);
	// 82406BC0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82406BC4: 40800018  bge 0x82406bdc
	if !ctx.cr[0].lt {
	pc = 0x82406BDC; continue 'dispatch;
	}
	// 82406BC8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82406BCC: 386BC520  addi r3, r11, -0x3ae0
	ctx.r[3].s64 = ctx.r[11].s64 + -15072;
	// 82406BD0: 4BEAC3B1  bl 0x822b2f80
	ctx.lr = 0x82406BD4;
	sub_822B2F80(ctx, base);
	// 82406BD4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82406BD8: 48000018  b 0x82406bf0
	pc = 0x82406BF0; continue 'dispatch;
            }
            0x82406BDC => {
    //   block [0x82406BDC..0x82406BF0)
	// 82406BDC: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82406BE0: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82406BE4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82406BE8: 7D6BF82E  lwzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82406BEC: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	pc = 0x82406BF0; continue 'dispatch;
            }
            0x82406BF0 => {
    //   block [0x82406BF0..0x82406C08)
	// 82406BF0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82406BF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82406BF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82406BFC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82406C00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82406C04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406C08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82406C08 size=64
    let mut pc: u32 = 0x82406C08;
    'dispatch: loop {
        match pc {
            0x82406C08 => {
    //   block [0x82406C08..0x82406C34)
	// 82406C08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82406C0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82406C10: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82406C14: 4BFFFF8D  bl 0x82406ba0
	ctx.lr = 0x82406C18;
	sub_82406BA0(ctx, base);
	// 82406C18: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82406C1C: 40820018  bne 0x82406c34
	if !ctx.cr[0].eq {
	pc = 0x82406C34; continue 'dispatch;
	}
	// 82406C20: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82406C24: 386BC55C  addi r3, r11, -0x3aa4
	ctx.r[3].s64 = ctx.r[11].s64 + -15012;
	// 82406C28: 4BEAC359  bl 0x822b2f80
	ctx.lr = 0x82406C2C;
	sub_822B2F80(ctx, base);
	// 82406C2C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82406C30: 48000008  b 0x82406c38
	pc = 0x82406C38; continue 'dispatch;
            }
            0x82406C34 => {
    //   block [0x82406C34..0x82406C38)
	// 82406C34: 38630030  addi r3, r3, 0x30
	ctx.r[3].s64 = ctx.r[3].s64 + 48;
	pc = 0x82406C38; continue 'dispatch;
            }
            0x82406C38 => {
    //   block [0x82406C38..0x82406C48)
	// 82406C38: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82406C3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82406C40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82406C44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406C48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82406C48 size=56
    let mut pc: u32 = 0x82406C48;
    'dispatch: loop {
        match pc {
            0x82406C48 => {
    //   block [0x82406C48..0x82406C70)
	// 82406C48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82406C4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82406C50: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82406C54: 4BFFFF4D  bl 0x82406ba0
	ctx.lr = 0x82406C58;
	sub_82406BA0(ctx, base);
	// 82406C58: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82406C5C: 40820014  bne 0x82406c70
	if !ctx.cr[0].eq {
	pc = 0x82406C70; continue 'dispatch;
	}
	// 82406C60: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82406C64: 386BC59C  addi r3, r11, -0x3a64
	ctx.r[3].s64 = ctx.r[11].s64 + -14948;
	// 82406C68: 4BEAC319  bl 0x822b2f80
	ctx.lr = 0x82406C6C;
	sub_822B2F80(ctx, base);
	// 82406C6C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82406C70; continue 'dispatch;
            }
            0x82406C70 => {
    //   block [0x82406C70..0x82406C80)
	// 82406C70: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82406C74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82406C78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82406C7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406C80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82406C80 size=76
    let mut pc: u32 = 0x82406C80;
    'dispatch: loop {
        match pc {
            0x82406C80 => {
    //   block [0x82406C80..0x82406CA8)
	// 82406C80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82406C84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82406C88: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82406C8C: 4BFFFF15  bl 0x82406ba0
	ctx.lr = 0x82406C90;
	sub_82406BA0(ctx, base);
	// 82406C90: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82406C94: 40820014  bne 0x82406ca8
	if !ctx.cr[0].eq {
	pc = 0x82406CA8; continue 'dispatch;
	}
	// 82406C98: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82406C9C: 386BC5D8  addi r3, r11, -0x3a28
	ctx.r[3].s64 = ctx.r[11].s64 + -14888;
	// 82406CA0: 4BEAC2E1  bl 0x822b2f80
	ctx.lr = 0x82406CA4;
	sub_822B2F80(ctx, base);
	// 82406CA4: 48000014  b 0x82406cb8
	pc = 0x82406CB8; continue 'dispatch;
            }
            0x82406CA8 => {
    //   block [0x82406CA8..0x82406CB8)
	// 82406CA8: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82406CAC: 386300BC  addi r3, r3, 0xbc
	ctx.r[3].s64 = ctx.r[3].s64 + 188;
	// 82406CB0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82406CB4: 41990008  bgt cr6, 0x82406cbc
	if ctx.cr[6].gt {
	pc = 0x82406CBC; continue 'dispatch;
	}
	pc = 0x82406CB8; continue 'dispatch;
            }
            0x82406CB8 => {
    //   block [0x82406CB8..0x82406CBC)
	// 82406CB8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82406CBC; continue 'dispatch;
            }
            0x82406CBC => {
    //   block [0x82406CBC..0x82406CCC)
	// 82406CBC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82406CC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82406CC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82406CC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406CD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82406CD0 size=124
    let mut pc: u32 = 0x82406CD0;
    'dispatch: loop {
        match pc {
            0x82406CD0 => {
    //   block [0x82406CD0..0x82406CF4)
	// 82406CD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82406CD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82406CD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82406CDC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82406CE0: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82406CE4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82406CE8: 409A0018  bne cr6, 0x82406d00
	if !ctx.cr[6].eq {
	pc = 0x82406D00; continue 'dispatch;
	}
	// 82406CEC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82406CF0: 386BC648  addi r3, r11, -0x39b8
	ctx.r[3].s64 = ctx.r[11].s64 + -14776;
	pc = 0x82406CF4; continue 'dispatch;
            }
            0x82406CF4 => {
    //   block [0x82406CF4..0x82406D00)
	// 82406CF4: 4BEAC28D  bl 0x822b2f80
	ctx.lr = 0x82406CF8;
	sub_822B2F80(ctx, base);
	// 82406CF8: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82406CFC: 4800003C  b 0x82406d38
	pc = 0x82406D38; continue 'dispatch;
            }
            0x82406D00 => {
    //   block [0x82406D00..0x82406D2C)
	// 82406D00: 4BFFFEA1  bl 0x82406ba0
	ctx.lr = 0x82406D04;
	sub_82406BA0(ctx, base);
	// 82406D04: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82406D08: 40820024  bne 0x82406d2c
	if !ctx.cr[0].eq {
	pc = 0x82406D2C; continue 'dispatch;
	}
	// 82406D0C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82406D10: 386BC59C  addi r3, r11, -0x3a64
	ctx.r[3].s64 = ctx.r[11].s64 + -14948;
	// 82406D14: 4BEAC26D  bl 0x822b2f80
	ctx.lr = 0x82406D18;
	sub_822B2F80(ctx, base);
	// 82406D18: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82406D1C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82406D20: 386BC610  addi r3, r11, -0x39f0
	ctx.r[3].s64 = ctx.r[11].s64 + -14832;
	// 82406D24: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82406D28: 4BFFFFCC  b 0x82406cf4
	pc = 0x82406CF4; continue 'dispatch;
            }
            0x82406D2C => {
    //   block [0x82406D2C..0x82406D38)
	// 82406D2C: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82406D30: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82406D34: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82406D38; continue 'dispatch;
            }
            0x82406D38 => {
    //   block [0x82406D38..0x82406D4C)
	// 82406D38: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82406D3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82406D40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82406D44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82406D48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406D50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82406D50 size=124
    let mut pc: u32 = 0x82406D50;
    'dispatch: loop {
        match pc {
            0x82406D50 => {
    //   block [0x82406D50..0x82406D74)
	// 82406D50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82406D54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82406D58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82406D5C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82406D60: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82406D64: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82406D68: 409A0018  bne cr6, 0x82406d80
	if !ctx.cr[6].eq {
	pc = 0x82406D80; continue 'dispatch;
	}
	// 82406D6C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82406D70: 386BC6C0  addi r3, r11, -0x3940
	ctx.r[3].s64 = ctx.r[11].s64 + -14656;
	pc = 0x82406D74; continue 'dispatch;
            }
            0x82406D74 => {
    //   block [0x82406D74..0x82406D80)
	// 82406D74: 4BEAC20D  bl 0x822b2f80
	ctx.lr = 0x82406D78;
	sub_822B2F80(ctx, base);
	// 82406D78: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82406D7C: 4800003C  b 0x82406db8
	pc = 0x82406DB8; continue 'dispatch;
            }
            0x82406D80 => {
    //   block [0x82406D80..0x82406DAC)
	// 82406D80: 4BFFFE21  bl 0x82406ba0
	ctx.lr = 0x82406D84;
	sub_82406BA0(ctx, base);
	// 82406D84: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82406D88: 40820024  bne 0x82406dac
	if !ctx.cr[0].eq {
	pc = 0x82406DAC; continue 'dispatch;
	}
	// 82406D8C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82406D90: 386BC59C  addi r3, r11, -0x3a64
	ctx.r[3].s64 = ctx.r[11].s64 + -14948;
	// 82406D94: 4BEAC1ED  bl 0x822b2f80
	ctx.lr = 0x82406D98;
	sub_822B2F80(ctx, base);
	// 82406D98: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82406D9C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82406DA0: 386BC68C  addi r3, r11, -0x3974
	ctx.r[3].s64 = ctx.r[11].s64 + -14708;
	// 82406DA4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82406DA8: 4BFFFFCC  b 0x82406d74
	pc = 0x82406D74; continue 'dispatch;
            }
            0x82406DAC => {
    //   block [0x82406DAC..0x82406DB8)
	// 82406DAC: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82406DB0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82406DB4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82406DB8; continue 'dispatch;
            }
            0x82406DB8 => {
    //   block [0x82406DB8..0x82406DCC)
	// 82406DB8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82406DBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82406DC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82406DC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82406DC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406DD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82406DD0 size=124
    let mut pc: u32 = 0x82406DD0;
    'dispatch: loop {
        match pc {
            0x82406DD0 => {
    //   block [0x82406DD0..0x82406DF4)
	// 82406DD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82406DD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82406DD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82406DDC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82406DE0: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82406DE4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82406DE8: 409A0018  bne cr6, 0x82406e00
	if !ctx.cr[6].eq {
	pc = 0x82406E00; continue 'dispatch;
	}
	// 82406DEC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82406DF0: 386BC740  addi r3, r11, -0x38c0
	ctx.r[3].s64 = ctx.r[11].s64 + -14528;
	pc = 0x82406DF4; continue 'dispatch;
            }
            0x82406DF4 => {
    //   block [0x82406DF4..0x82406E00)
	// 82406DF4: 4BEAC18D  bl 0x822b2f80
	ctx.lr = 0x82406DF8;
	sub_822B2F80(ctx, base);
	// 82406DF8: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82406DFC: 4800003C  b 0x82406e38
	pc = 0x82406E38; continue 'dispatch;
            }
            0x82406E00 => {
    //   block [0x82406E00..0x82406E2C)
	// 82406E00: 4BFFFDA1  bl 0x82406ba0
	ctx.lr = 0x82406E04;
	sub_82406BA0(ctx, base);
	// 82406E04: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82406E08: 40820024  bne 0x82406e2c
	if !ctx.cr[0].eq {
	pc = 0x82406E2C; continue 'dispatch;
	}
	// 82406E0C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82406E10: 386BC59C  addi r3, r11, -0x3a64
	ctx.r[3].s64 = ctx.r[11].s64 + -14948;
	// 82406E14: 4BEAC16D  bl 0x822b2f80
	ctx.lr = 0x82406E18;
	sub_822B2F80(ctx, base);
	// 82406E18: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82406E1C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82406E20: 386BC704  addi r3, r11, -0x38fc
	ctx.r[3].s64 = ctx.r[11].s64 + -14588;
	// 82406E24: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82406E28: 4BFFFFCC  b 0x82406df4
	pc = 0x82406DF4; continue 'dispatch;
            }
            0x82406E2C => {
    //   block [0x82406E2C..0x82406E38)
	// 82406E2C: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82406E30: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82406E34: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82406E38; continue 'dispatch;
            }
            0x82406E38 => {
    //   block [0x82406E38..0x82406E4C)
	// 82406E38: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82406E3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82406E40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82406E44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82406E48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82406E50 size=12
    let mut pc: u32 = 0x82406E50;
    'dispatch: loop {
        match pc {
            0x82406E50 => {
    //   block [0x82406E50..0x82406E5C)
	// 82406E50: 3D608273  lis r11, -0x7d8d
	ctx.r[11].s64 = -2106392576;
	// 82406E54: 806B3254  lwz r3, 0x3254(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12884 as u32) ) } as u64;
	// 82406E58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406E60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82406E60 size=232
    let mut pc: u32 = 0x82406E60;
    'dispatch: loop {
        match pc {
            0x82406E60 => {
    //   block [0x82406E60..0x82406E80)
	// 82406E60: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82406E64: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82406E68: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82406E6C: 390B4768  addi r8, r11, 0x4768
	ctx.r[8].s64 = ctx.r[11].s64 + 18280;
	// 82406E70: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82406E74: 39680018  addi r11, r8, 0x18
	ctx.r[11].s64 = ctx.r[8].s64 + 24;
	// 82406E78: C1A92268  lfs f13, 0x2268(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8808 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82406E7C: C00A1FF8  lfs f0, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82406E80; continue 'dispatch;
            }
            0x82406E80 => {
    //   block [0x82406E80..0x82406EA8)
	// 82406E80: 894BFFFC  lbz r10, -4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82406E84: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 82406E88: 409A0044  bne cr6, 0x82406ecc
	if !ctx.cr[6].eq {
	pc = 0x82406ECC; continue 'dispatch;
	}
	// 82406E8C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82406E90: 7D435051  subf. r10, r3, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[3].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82406E94: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82406E98: 41810010  bgt 0x82406ea8
	if ctx.cr[0].gt {
	pc = 0x82406EA8; continue 'dispatch;
	}
	// 82406E9C: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82406EA0: 98EBFFFC  stb r7, -4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[7].u8 ) };
	// 82406EA4: 48000024  b 0x82406ec8
	pc = 0x82406EC8; continue 'dispatch;
            }
            0x82406EA8 => {
    //   block [0x82406EA8..0x82406EC8)
	// 82406EA8: 786A0020  clrldi r10, r3, 0x20
	ctx.r[10].u64 = ctx.r[3].u64 & 0x00000000FFFFFFFFu64;
	// 82406EAC: C18BFFEC  lfs f12, -0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82406EB0: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82406EB4: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 82406EB8: C941FFF0  lfd f10, -0x10(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82406EBC: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 82406EC0: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82406EC4: ED8B62BA  fmadds f12, f11, f10, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64);
	pc = 0x82406EC8; continue 'dispatch;
            }
            0x82406EC8 => {
    //   block [0x82406EC8..0x82406ECC)
	// 82406EC8: D18BFFEC  stfs f12, -0x14(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-20 as u32), tmp.u32 ) };
	pc = 0x82406ECC; continue 'dispatch;
            }
            0x82406ECC => {
    //   block [0x82406ECC..0x82406F00)
	// 82406ECC: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82406ED0: 2C0A0000  cmpwi r10, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82406ED4: 4081005C  ble 0x82406f30
	if !ctx.cr[0].gt {
	pc = 0x82406F30; continue 'dispatch;
	}
	// 82406ED8: 7D435051  subf. r10, r3, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[3].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82406EDC: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82406EE0: 4181002C  bgt 0x82406f0c
	if ctx.cr[0].gt {
	pc = 0x82406F0C; continue 'dispatch;
	}
	// 82406EE4: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82406EE8: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82406EEC: 409A0014  bne cr6, 0x82406f00
	if !ctx.cr[6].eq {
	pc = 0x82406F00; continue 'dispatch;
	}
	// 82406EF0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82406EF4: D00B0018  stfs f0, 0x18(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82406EF8: 914B0020  stw r10, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 82406EFC: 48000034  b 0x82406f30
	pc = 0x82406F30; continue 'dispatch;
            }
            0x82406F00 => {
    //   block [0x82406F00..0x82406F0C)
	// 82406F00: D1AB0018  stfs f13, 0x18(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82406F04: 90EB0024  stw r7, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[7].u32 ) };
	// 82406F08: 48000028  b 0x82406f30
	pc = 0x82406F30; continue 'dispatch;
            }
            0x82406F0C => {
    //   block [0x82406F0C..0x82406F30)
	// 82406F0C: 786A0020  clrldi r10, r3, 0x20
	ctx.r[10].u64 = ctx.r[3].u64 & 0x00000000FFFFFFFFu64;
	// 82406F10: C18B0018  lfs f12, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82406F14: C16B001C  lfs f11, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82406F18: F941FFF8  std r10, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[10].u64 ) };
	// 82406F1C: C941FFF8  lfd f10, -8(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82406F20: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 82406F24: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82406F28: ED8B62BA  fmadds f12, f11, f10, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64);
	// 82406F2C: D18B0018  stfs f12, 0x18(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	pc = 0x82406F30; continue 'dispatch;
            }
            0x82406F30 => {
    //   block [0x82406F30..0x82406F48)
	// 82406F30: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 82406F34: 39481118  addi r10, r8, 0x1118
	ctx.r[10].s64 = ctx.r[8].s64 + 4376;
	// 82406F38: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82406F3C: 4198FF44  blt cr6, 0x82406e80
	if ctx.cr[6].lt {
	pc = 0x82406E80; continue 'dispatch;
	}
	// 82406F40: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82406F44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406F48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82406F48 size=24
    let mut pc: u32 = 0x82406F48;
    'dispatch: loop {
        match pc {
            0x82406F48 => {
    //   block [0x82406F48..0x82406F60)
	// 82406F48: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82406F4C: 546A1838  slwi r10, r3, 3
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82406F50: 396B4668  addi r11, r11, 0x4668
	ctx.r[11].s64 = ctx.r[11].s64 + 18024;
	// 82406F54: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82406F58: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82406F5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82406F60 size=76
    let mut pc: u32 = 0x82406F60;
    'dispatch: loop {
        match pc {
            0x82406F60 => {
    //   block [0x82406F60..0x82406FA4)
	// 82406F60: 39430040  addi r10, r3, 0x40
	ctx.r[10].s64 = ctx.r[3].s64 + 64;
	// 82406F64: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82406F68: 4198003C  blt cr6, 0x82406fa4
	if ctx.cr[6].lt {
	pc = 0x82406FA4; continue 'dispatch;
	}
	// 82406F6C: 3D608273  lis r11, -0x7d8d
	ctx.r[11].s64 = -2106392576;
	// 82406F70: 816B3254  lwz r11, 0x3254(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12884 as u32) ) } as u64;
	// 82406F74: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82406F78: 4098002C  bge cr6, 0x82406fa4
	if !ctx.cr[6].lt {
	pc = 0x82406FA4; continue 'dispatch;
	}
	// 82406F7C: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82406F80: 55493032  slwi r9, r10, 6
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(6);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82406F84: 396B4768  addi r11, r11, 0x4768
	ctx.r[11].s64 = ctx.r[11].s64 + 18280;
	// 82406F88: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 82406F8C: 7D6958AE  lbzx r11, r9, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82406F90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82406F94: 419A0010  beq cr6, 0x82406fa4
	if ctx.cr[6].eq {
	pc = 0x82406FA4; continue 'dispatch;
	}
	// 82406F98: 2B0A0043  cmplwi cr6, r10, 0x43
	ctx.cr[6].compare_u32(ctx.r[10].u32, 67 as u32, &mut ctx.xer);
	// 82406F9C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82406FA0: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	pc = 0x82406FA4; continue 'dispatch;
            }
            0x82406FA4 => {
    //   block [0x82406FA4..0x82406FAC)
	// 82406FA4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82406FA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82406FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82406FB0 size=88
    let mut pc: u32 = 0x82406FB0;
    'dispatch: loop {
        match pc {
            0x82406FB0 => {
    //   block [0x82406FB0..0x82406FC0)
	// 82406FB0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82406FB4: 4198004C  blt cr6, 0x82407000
	if ctx.cr[6].lt {
	pc = 0x82407000; continue 'dispatch;
	}
	// 82406FB8: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82406FBC: 394B4768  addi r10, r11, 0x4768
	ctx.r[10].s64 = ctx.r[11].s64 + 18280;
	pc = 0x82406FC0; continue 'dispatch;
            }
            0x82406FC0 => {
    //   block [0x82406FC0..0x82407000)
	// 82406FC0: 546B3032  slwi r11, r3, 6
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82406FC4: 392A0014  addi r9, r10, 0x14
	ctx.r[9].s64 = ctx.r[10].s64 + 20;
	// 82406FC8: 7D2B48AE  lbzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82406FCC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82406FD0: 419A0030  beq cr6, 0x82407000
	if ctx.cr[6].eq {
	pc = 0x82407000; continue 'dispatch;
	}
	// 82406FD4: 2B030043  cmplwi cr6, r3, 0x43
	ctx.cr[6].compare_u32(ctx.r[3].u32, 67 as u32, &mut ctx.xer);
	// 82406FD8: 41990028  bgt cr6, 0x82407000
	if ctx.cr[6].gt {
	pc = 0x82407000; continue 'dispatch;
	}
	// 82406FDC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82406FE0: 812B003C  lwz r9, 0x3c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82406FE4: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82406FE8: 419A0020  beq cr6, 0x82407008
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82407008);
		return;
	}
	// 82406FEC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82406FF0: 2F030040  cmpwi cr6, r3, 0x40
	ctx.cr[6].compare_i32(ctx.r[3].s32, 64, &mut ctx.xer);
	// 82406FF4: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82406FF8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82406FFC: 4098FFC4  bge cr6, 0x82406fc0
	if !ctx.cr[6].lt {
	pc = 0x82406FC0; continue 'dispatch;
	}
	pc = 0x82407000; continue 'dispatch;
            }
            0x82407000 => {
    //   block [0x82407000..0x82407008)
	// 82407000: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82407004: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82407010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82407010 size=52
    let mut pc: u32 = 0x82407010;
    'dispatch: loop {
        match pc {
            0x82407010 => {
    //   block [0x82407010..0x82407034)
	// 82407010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82407014: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82407018: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240701C: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82407020: 4BFFFF41  bl 0x82406f60
	ctx.lr = 0x82407024;
	sub_82406F60(ctx, base);
	// 82407024: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82407028: 4182000C  beq 0x82407034
	if ctx.cr[0].eq {
	pc = 0x82407034; continue 'dispatch;
	}
	// 8240702C: 38680040  addi r3, r8, 0x40
	ctx.r[3].s64 = ctx.r[8].s64 + 64;
	// 82407030: 4BFFFF81  bl 0x82406fb0
	ctx.lr = 0x82407034;
	sub_82406FB0(ctx, base);
	pc = 0x82407034; continue 'dispatch;
            }
            0x82407034 => {
    //   block [0x82407034..0x82407044)
	// 82407034: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82407038: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8240703C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82407040: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82407048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82407048 size=48
    let mut pc: u32 = 0x82407048;
    'dispatch: loop {
        match pc {
            0x82407048 => {
    //   block [0x82407048..0x8240706C)
	// 82407048: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 8240704C: 546B3032  slwi r11, r3, 6
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82407050: 394A4768  addi r10, r10, 0x4768
	ctx.r[10].s64 = ctx.r[10].s64 + 18280;
	// 82407054: 392A0014  addi r9, r10, 0x14
	ctx.r[9].s64 = ctx.r[10].s64 + 20;
	// 82407058: 7D2B48AE  lbzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8240705C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82407060: 419A000C  beq cr6, 0x8240706c
	if ctx.cr[6].eq {
	pc = 0x8240706C; continue 'dispatch;
	}
	// 82407064: 2B030043  cmplwi cr6, r3, 0x43
	ctx.cr[6].compare_u32(ctx.r[3].u32, 67 as u32, &mut ctx.xer);
	// 82407068: 40990010  ble cr6, 0x82407078
	if !ctx.cr[6].gt {
		crate::recompiler::externs::call(ctx, base, 0x82407078);
		return;
	}
	pc = 0x8240706C; continue 'dispatch;
            }
            0x8240706C => {
    //   block [0x8240706C..0x82407078)
	// 8240706C: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82407070: 60630001  ori r3, r3, 1
	ctx.r[3].u64 = ctx.r[3].u64 | 1;
	// 82407074: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82407088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82407088 size=48
    let mut pc: u32 = 0x82407088;
    'dispatch: loop {
        match pc {
            0x82407088 => {
    //   block [0x82407088..0x824070AC)
	// 82407088: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 8240708C: 546B3032  slwi r11, r3, 6
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82407090: 394A4768  addi r10, r10, 0x4768
	ctx.r[10].s64 = ctx.r[10].s64 + 18280;
	// 82407094: 392A0014  addi r9, r10, 0x14
	ctx.r[9].s64 = ctx.r[10].s64 + 20;
	// 82407098: 7D2B48AE  lbzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8240709C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 824070A0: 419A000C  beq cr6, 0x824070ac
	if ctx.cr[6].eq {
	pc = 0x824070AC; continue 'dispatch;
	}
	// 824070A4: 2B030043  cmplwi cr6, r3, 0x43
	ctx.cr[6].compare_u32(ctx.r[3].u32, 67 as u32, &mut ctx.xer);
	// 824070A8: 40990010  ble cr6, 0x824070b8
	if !ctx.cr[6].gt {
		sub_824070B8(ctx, base);
		return;
	}
	pc = 0x824070AC; continue 'dispatch;
            }
            0x824070AC => {
    //   block [0x824070AC..0x824070B8)
	// 824070AC: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 824070B0: 60630001  ori r3, r3, 1
	ctx.r[3].u64 = ctx.r[3].u64 | 1;
	// 824070B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824070B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824070B8 size=96
    let mut pc: u32 = 0x824070B8;
    'dispatch: loop {
        match pc {
            0x824070B8 => {
    //   block [0x824070B8..0x82407118)
	// 824070B8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824070BC: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 824070C0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 824070C4: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 824070C8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824070CC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824070D0: C0091FF8  lfs f0, 0x1ff8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824070D4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 824070D8: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824070DC: D1AB0004  stfs f13, 4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 824070E0: C1AA0008  lfs f13, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824070E4: D1AB0008  stfs f13, 8(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 824070E8: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824070EC: D00B0028  stfs f0, 0x28(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 824070F0: 990B0014  stb r8, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[8].u8 ) };
	// 824070F4: D00B0030  stfs f0, 0x30(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 824070F8: 912B002C  stw r9, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 824070FC: D00B0034  stfs f0, 0x34(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82407100: 912B0038  stw r9, 0x38(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 82407104: 912B003C  stw r9, 0x3c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), ctx.r[9].u32 ) };
	// 82407108: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 8240710C: 912B0024  stw r9, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[9].u32 ) };
	// 82407110: 90EB0010  stw r7, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[7].u32 ) };
	// 82407114: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82407118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82407118 size=156
    let mut pc: u32 = 0x82407118;
    'dispatch: loop {
        match pc {
            0x82407118 => {
    //   block [0x82407118..0x82407154)
	// 82407118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240711C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82407120: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82407124: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82407128: 390B4668  addi r8, r11, 0x4668
	ctx.r[8].s64 = ctx.r[11].s64 + 18024;
	// 8240712C: 546B3032  slwi r11, r3, 6
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82407130: 39480100  addi r10, r8, 0x100
	ctx.r[10].s64 = ctx.r[8].s64 + 256;
	// 82407134: 394A1000  addi r10, r10, 0x1000
	ctx.r[10].s64 = ctx.r[10].s64 + 4096;
	// 82407138: 7CEB5214  add r7, r11, r10
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8240713C: 4BFFFE25  bl 0x82406f60
	ctx.lr = 0x82407140;
	sub_82406F60(ctx, base);
	// 82407140: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82407144: 40820010  bne 0x82407154
	if !ctx.cr[0].eq {
	pc = 0x82407154; continue 'dispatch;
	}
	// 82407148: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 8240714C: 60630006  ori r3, r3, 6
	ctx.r[3].u64 = ctx.r[3].u64 | 6;
	// 82407150: 48000054  b 0x824071a4
	pc = 0x824071A4; continue 'dispatch;
            }
            0x82407154 => {
    //   block [0x82407154..0x82407174)
	// 82407154: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82407158: 41980038  blt cr6, 0x82407190
	if ctx.cr[6].lt {
	pc = 0x82407190; continue 'dispatch;
	}
	// 8240715C: 2F040020  cmpwi cr6, r4, 0x20
	ctx.cr[6].compare_i32(ctx.r[4].s32, 32, &mut ctx.xer);
	// 82407160: 40980014  bge cr6, 0x82407174
	if !ctx.cr[6].lt {
	pc = 0x82407174; continue 'dispatch;
	}
	// 82407164: 548B1838  slwi r11, r4, 3
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82407168: 7D6B402E  lwzx r11, r11, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 8240716C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82407170: 409A0010  bne cr6, 0x82407180
	if !ctx.cr[6].eq {
	pc = 0x82407180; continue 'dispatch;
	}
	pc = 0x82407174; continue 'dispatch;
            }
            0x82407174 => {
    //   block [0x82407174..0x82407180)
	// 82407174: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82407178: 60630007  ori r3, r3, 7
	ctx.r[3].u64 = ctx.r[3].u64 | 7;
	// 8240717C: 48000028  b 0x824071a4
	pc = 0x824071A4; continue 'dispatch;
            }
            0x82407180 => {
    //   block [0x82407180..0x82407190)
	// 82407180: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82407184: 90870010  stw r4, 0x10(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(16 as u32), ctx.r[4].u32 ) };
	// 82407188: 91670024  stw r11, 0x24(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 8240718C: 48000014  b 0x824071a0
	pc = 0x824071A0; continue 'dispatch;
            }
            0x82407190 => {
    //   block [0x82407190..0x824071A0)
	// 82407190: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82407194: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82407198: 91670010  stw r11, 0x10(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 8240719C: 91470024  stw r10, 0x24(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	pc = 0x824071A0; continue 'dispatch;
            }
            0x824071A0 => {
    //   block [0x824071A0..0x824071A4)
	// 824071A0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x824071A4; continue 'dispatch;
            }
            0x824071A4 => {
    //   block [0x824071A4..0x824071B4)
	// 824071A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824071A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824071AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824071B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824071B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824071B8 size=80
    let mut pc: u32 = 0x824071B8;
    'dispatch: loop {
        match pc {
            0x824071B8 => {
    //   block [0x824071B8..0x824071E0)
	// 824071B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824071BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824071C0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824071C4: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 824071C8: 4BFFFD99  bl 0x82406f60
	ctx.lr = 0x824071CC;
	sub_82406F60(ctx, base);
	// 824071CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 824071D0: 40820010  bne 0x824071e0
	if !ctx.cr[0].eq {
	pc = 0x824071E0; continue 'dispatch;
	}
	// 824071D4: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 824071D8: 60630006  ori r3, r3, 6
	ctx.r[3].u64 = ctx.r[3].u64 | 6;
	// 824071DC: 4800001C  b 0x824071f8
	pc = 0x824071F8; continue 'dispatch;
            }
            0x824071E0 => {
    //   block [0x824071E0..0x824071F8)
	// 824071E0: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 824071E4: 550A3032  slwi r10, r8, 6
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824071E8: 396B4768  addi r11, r11, 0x4768
	ctx.r[11].s64 = ctx.r[11].s64 + 18280;
	// 824071EC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824071F0: 396B1004  addi r11, r11, 0x1004
	ctx.r[11].s64 = ctx.r[11].s64 + 4100;
	// 824071F4: 7C2A5D2E  stfsx f1, r10, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	pc = 0x824071F8; continue 'dispatch;
            }
            0x824071F8 => {
    //   block [0x824071F8..0x82407208)
	// 824071F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824071FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82407200: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82407204: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82407208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82407208 size=76
    let mut pc: u32 = 0x82407208;
    'dispatch: loop {
        match pc {
            0x82407208 => {
    //   block [0x82407208..0x82407244)
	// 82407208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240720C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82407210: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82407214: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82407218: 4BFFFD49  bl 0x82406f60
	ctx.lr = 0x8240721C;
	sub_82406F60(ctx, base);
	// 8240721C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82407220: 41820024  beq 0x82407244
	if ctx.cr[0].eq {
	pc = 0x82407244; continue 'dispatch;
	}
	// 82407224: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82407228: 550A3032  slwi r10, r8, 6
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8240722C: 396B4768  addi r11, r11, 0x4768
	ctx.r[11].s64 = ctx.r[11].s64 + 18280;
	// 82407230: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82407234: 396B1000  addi r11, r11, 0x1000
	ctx.r[11].s64 = ctx.r[11].s64 + 4096;
	// 82407238: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8240723C: 806B0024  lwz r3, 0x24(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82407240: 912B0024  stw r9, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[9].u32 ) };
	pc = 0x82407244; continue 'dispatch;
            }
            0x82407244 => {
    //   block [0x82407244..0x82407254)
	// 82407244: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82407248: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8240724C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82407250: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82407258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82407258 size=52
    let mut pc: u32 = 0x82407258;
    'dispatch: loop {
        match pc {
            0x82407258 => {
    //   block [0x82407258..0x82407280)
	// 82407258: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 8240725C: 546B3032  slwi r11, r3, 6
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82407260: 394A4768  addi r10, r10, 0x4768
	ctx.r[10].s64 = ctx.r[10].s64 + 18280;
	// 82407264: 392A0014  addi r9, r10, 0x14
	ctx.r[9].s64 = ctx.r[10].s64 + 20;
	// 82407268: 7D2B48AE  lbzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8240726C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82407270: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82407274: 419A000C  beq cr6, 0x82407280
	if ctx.cr[6].eq {
	pc = 0x82407280; continue 'dispatch;
	}
	// 82407278: 2B030043  cmplwi cr6, r3, 0x43
	ctx.cr[6].compare_u32(ctx.r[3].u32, 67 as u32, &mut ctx.xer);
	// 8240727C: 40990010  ble cr6, 0x8240728c
	if !ctx.cr[6].gt {
		crate::recompiler::externs::call(ctx, base, 0x8240728C);
		return;
	}
	pc = 0x82407280; continue 'dispatch;
            }
            0x82407280 => {
    //   block [0x82407280..0x8240728C)
	// 82407280: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82407284: 60630001  ori r3, r3, 1
	ctx.r[3].u64 = ctx.r[3].u64 | 1;
	// 82407288: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82407298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82407298 size=196
    let mut pc: u32 = 0x82407298;
    'dispatch: loop {
        match pc {
            0x82407298 => {
    //   block [0x82407298..0x824072B4)
	// 82407298: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8240729C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 824072A0: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824072A4: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 824072A8: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 824072AC: 9104000C  stw r8, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 824072B0: 38EB4768  addi r7, r11, 0x4768
	ctx.r[7].s64 = ctx.r[11].s64 + 18280;
	pc = 0x824072B4; continue 'dispatch;
            }
            0x824072B4 => {
    //   block [0x824072B4..0x8240730C)
	// 824072B4: 546B3032  slwi r11, r3, 6
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824072B8: 39470014  addi r10, r7, 0x14
	ctx.r[10].s64 = ctx.r[7].s64 + 20;
	// 824072BC: 7D4B50AE  lbzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824072C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824072C4: 419A0098  beq cr6, 0x8240735c
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x8240735C);
		return;
	}
	// 824072C8: 2B030043  cmplwi cr6, r3, 0x43
	ctx.cr[6].compare_u32(ctx.r[3].u32, 67 as u32, &mut ctx.xer);
	// 824072CC: 41990090  bgt cr6, 0x8240735c
	if ctx.cr[6].gt {
		crate::recompiler::externs::call(ctx, base, 0x8240735C);
		return;
	}
	// 824072D0: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 824072D4: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824072D8: 2C0A0000  cmpwi r10, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 824072DC: 41800030  blt 0x8240730c
	if ctx.cr[0].lt {
	pc = 0x8240730C; continue 'dispatch;
	}
	// 824072E0: 8124000C  lwz r9, 0xc(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 824072E4: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 824072E8: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 824072EC: 7D49212E  stwx r10, r9, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[4].u32), ctx.r[10].u32) };
	// 824072F0: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 824072F4: 394A0024  addi r10, r10, 0x24
	ctx.r[10].s64 = ctx.r[10].s64 + 36;
	// 824072F8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824072FC: 7C6A212E  stwx r3, r10, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[4].u32), ctx.r[3].u32) };
	// 82407300: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82407304: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82407308: 9144000C  stw r10, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	pc = 0x8240730C; continue 'dispatch;
            }
            0x8240730C => {
    //   block [0x8240730C..0x8240735C)
	// 8240730C: C16B0028  lfs f11, 0x28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82407310: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82407314: C18B0030  lfs f12, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82407318: 2F030040  cmpwi cr6, r3, 0x40
	ctx.cr[6].compare_i32(ctx.r[3].s32, 64, &mut ctx.xer);
	// 8240731C: ED8C582A  fadds f12, f12, f11
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64;
	// 82407320: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82407324: C14B0008  lfs f10, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82407328: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8240732C: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82407330: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82407334: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82407338: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 8240733C: ED8C582A  fadds f12, f12, f11
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64;
	// 82407340: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82407344: 4098FF70  bge cr6, 0x824072b4
	if !ctx.cr[6].lt {
	pc = 0x824072B4; continue 'dispatch;
	}
	// 82407348: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8240734C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82407350: D1A40004  stfs f13, 4(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82407354: 91040008  stw r8, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82407358: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82407368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82407368 size=48
    let mut pc: u32 = 0x82407368;
    'dispatch: loop {
        match pc {
            0x82407368 => {
    //   block [0x82407368..0x8240738C)
	// 82407368: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 8240736C: 546B3032  slwi r11, r3, 6
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82407370: 394A4768  addi r10, r10, 0x4768
	ctx.r[10].s64 = ctx.r[10].s64 + 18280;
	// 82407374: 392A0014  addi r9, r10, 0x14
	ctx.r[9].s64 = ctx.r[10].s64 + 20;
	// 82407378: 7D2B48AE  lbzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8240737C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82407380: 419A000C  beq cr6, 0x8240738c
	if ctx.cr[6].eq {
	pc = 0x8240738C; continue 'dispatch;
	}
	// 82407384: 2B030043  cmplwi cr6, r3, 0x43
	ctx.cr[6].compare_u32(ctx.r[3].u32, 67 as u32, &mut ctx.xer);
	// 82407388: 40990010  ble cr6, 0x82407398
	if !ctx.cr[6].gt {
		crate::recompiler::externs::call(ctx, base, 0x82407398);
		return;
	}
	pc = 0x8240738C; continue 'dispatch;
            }
            0x8240738C => {
    //   block [0x8240738C..0x82407398)
	// 8240738C: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82407390: 60630001  ori r3, r3, 1
	ctx.r[3].u64 = ctx.r[3].u64 | 1;
	// 82407394: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824073A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824073A8 size=48
    let mut pc: u32 = 0x824073A8;
    'dispatch: loop {
        match pc {
            0x824073A8 => {
    //   block [0x824073A8..0x824073CC)
	// 824073A8: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 824073AC: 546B3032  slwi r11, r3, 6
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824073B0: 394A4768  addi r10, r10, 0x4768
	ctx.r[10].s64 = ctx.r[10].s64 + 18280;
	// 824073B4: 392A0014  addi r9, r10, 0x14
	ctx.r[9].s64 = ctx.r[10].s64 + 20;
	// 824073B8: 7D2B48AE  lbzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 824073BC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 824073C0: 419A000C  beq cr6, 0x824073cc
	if ctx.cr[6].eq {
	pc = 0x824073CC; continue 'dispatch;
	}
	// 824073C4: 2B030043  cmplwi cr6, r3, 0x43
	ctx.cr[6].compare_u32(ctx.r[3].u32, 67 as u32, &mut ctx.xer);
	// 824073C8: 40990010  ble cr6, 0x824073d8
	if !ctx.cr[6].gt {
		crate::recompiler::externs::call(ctx, base, 0x824073D8);
		return;
	}
	pc = 0x824073CC; continue 'dispatch;
            }
            0x824073CC => {
    //   block [0x824073CC..0x824073D8)
	// 824073CC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824073D0: C02B1FF8  lfs f1, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 824073D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824073F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824073F8 size=64
    let mut pc: u32 = 0x824073F8;
    'dispatch: loop {
        match pc {
            0x824073F8 => {
    //   block [0x824073F8..0x82407424)
	// 824073F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824073FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82407400: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82407404: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82407408: 38630040  addi r3, r3, 0x40
	ctx.r[3].s64 = ctx.r[3].s64 + 64;
	// 8240740C: 4BFFFE8D  bl 0x82407298
	ctx.lr = 0x82407410;
	sub_82407298(ctx, base);
	// 82407410: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82407414: 41820010  beq 0x82407424
	if ctx.cr[0].eq {
	pc = 0x82407424; continue 'dispatch;
	}
	// 82407418: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8240741C: C02B1FF8  lfs f1, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82407420: 48000008  b 0x82407428
	pc = 0x82407428; continue 'dispatch;
            }
            0x82407424 => {
    //   block [0x82407424..0x82407428)
	// 82407424: C0210050  lfs f1, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	pc = 0x82407428; continue 'dispatch;
            }
            0x82407428 => {
    //   block [0x82407428..0x82407438)
	// 82407428: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 8240742C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82407430: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82407434: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82407438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82407438 size=352
    let mut pc: u32 = 0x82407438;
    'dispatch: loop {
        match pc {
            0x82407438 => {
    //   block [0x82407438..0x8240748C)
	// 82407438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240743C: 4812DC6D  bl 0x825350a8
	ctx.lr = 0x82407440;
	sub_82535080(ctx, base);
	// 82407440: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82407444: 4BFFE3C5  bl 0x82405808
	ctx.lr = 0x82407448;
	sub_82405808(ctx, base);
	// 82407448: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8240744C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82407450: 388B4668  addi r4, r11, 0x4668
	ctx.r[4].s64 = ctx.r[11].s64 + 18024;
	// 82407454: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82407458: 39640100  addi r11, r4, 0x100
	ctx.r[11].s64 = ctx.r[4].s64 + 256;
	// 8240745C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82407460: 38CB0008  addi r6, r11, 8
	ctx.r[6].s64 = ctx.r[11].s64 + 8;
	// 82407464: 81631C4C  lwz r11, 0x1c4c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(7244 as u32) ) } as u64;
	// 82407468: 392B043C  addi r9, r11, 0x43c
	ctx.r[9].s64 = ctx.r[11].s64 + 1084;
	// 8240746C: 3BEB003C  addi r31, r11, 0x3c
	ctx.r[31].s64 = ctx.r[11].s64 + 60;
	// 82407470: 3B4B047C  addi r26, r11, 0x47c
	ctx.r[26].s64 = ctx.r[11].s64 + 1148;
	// 82407474: 832B0000  lwz r25, 0(r11)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82407478: 3BC9FC00  addi r30, r9, -0x400
	ctx.r[30].s64 = ctx.r[9].s64 + -1024;
	// 8240747C: 836B0004  lwz r27, 4(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82407480: 830B0008  lwz r24, 8(r11)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82407484: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82407488: C18B1FF8  lfs f12, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x8240748C; continue 'dispatch;
            }
            0x8240748C => {
    //   block [0x8240748C..0x824074B0)
	// 8240748C: 2F050040  cmpwi cr6, r5, 0x40
	ctx.cr[6].compare_i32(ctx.r[5].s32, 64, &mut ctx.xer);
	// 82407490: 40980020  bge cr6, 0x824074b0
	if !ctx.cr[6].lt {
	pc = 0x824074B0; continue 'dispatch;
	}
	// 82407494: 7F05C800  cmpw cr6, r5, r25
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[25].s32, &mut ctx.xer);
	// 82407498: 40980088  bge cr6, 0x82407520
	if !ctx.cr[6].lt {
	pc = 0x82407520; continue 'dispatch;
	}
	// 8240749C: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 824074A0: 9BA6000C  stb r29, 0xc(r6)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	// 824074A4: 93E6FFF8  stw r31, -8(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(-8 as u32), ctx.r[31].u32 ) };
	// 824074A8: 4BFFFBE1  bl 0x82407088
	ctx.lr = 0x824074AC;
	sub_82407088(ctx, base);
	// 824074AC: 4800007C  b 0x82407528
	pc = 0x82407528; continue 'dispatch;
            }
            0x824074B0 => {
    //   block [0x824074B0..0x82407520)
	// 824074B0: 3865FFC0  addi r3, r5, -0x40
	ctx.r[3].s64 = ctx.r[5].s64 + -64;
	// 824074B4: 7F03D800  cmpw cr6, r3, r27
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[27].s32, &mut ctx.xer);
	// 824074B8: 40980068  bge cr6, 0x82407520
	if !ctx.cr[6].lt {
	pc = 0x82407520; continue 'dispatch;
	}
	// 824074BC: 9BA6000C  stb r29, 0xc(r6)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	// 824074C0: 93C6FFF8  stw r30, -8(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(-8 as u32), ctx.r[30].u32 ) };
	// 824074C4: 4BFFFA9D  bl 0x82406f60
	ctx.lr = 0x824074C8;
	sub_82406F60(ctx, base);
	// 824074C8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 824074CC: 4182005C  beq 0x82407528
	if ctx.cr[0].eq {
	pc = 0x82407528; continue 'dispatch;
	}
	// 824074D0: 57CB003E  slwi r11, r30, 0
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824074D4: 81460008  lwz r10, 8(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 824074D8: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824074DC: 93860004  stw r28, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 824074E0: D006FFFC  stfs f0, -4(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 824074E4: 9BA6000C  stb r29, 0xc(r6)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	// 824074E8: D1860000  stfs f12, 0(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 824074EC: 93860024  stw r28, 0x24(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(36 as u32), ctx.r[28].u32 ) };
	// 824074F0: D1860020  stfs f12, 0x20(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 824074F4: 93860030  stw r28, 0x30(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(48 as u32), ctx.r[28].u32 ) };
	// 824074F8: D1860028  stfs f12, 0x28(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 824074FC: 93860034  stw r28, 0x34(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(52 as u32), ctx.r[28].u32 ) };
	// 82407500: D186002C  stfs f12, 0x2c(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82407504: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82407508: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 8240750C: 419A001C  beq cr6, 0x82407528
	if ctx.cr[6].eq {
	pc = 0x82407528; continue 'dispatch;
	}
	// 82407510: 93A6001C  stw r29, 0x1c(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	// 82407514: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82407518: 91660008  stw r11, 8(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8240751C: 4800000C  b 0x82407528
	pc = 0x82407528; continue 'dispatch;
            }
            0x82407520 => {
    //   block [0x82407520..0x82407528)
	// 82407520: 9386FFF8  stw r28, -8(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(-8 as u32), ctx.r[28].u32 ) };
	// 82407524: 9B86000C  stb r28, 0xc(r6)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), ctx.r[28].u8 ) };
	pc = 0x82407528; continue 'dispatch;
            }
            0x82407528 => {
    //   block [0x82407528..0x82407558)
	// 82407528: 39640100  addi r11, r4, 0x100
	ctx.r[11].s64 = ctx.r[4].s64 + 256;
	// 8240752C: 93A6001C  stw r29, 0x1c(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	// 82407530: 38C60040  addi r6, r6, 0x40
	ctx.r[6].s64 = ctx.r[6].s64 + 64;
	// 82407534: 396B1108  addi r11, r11, 0x1108
	ctx.r[11].s64 = ctx.r[11].s64 + 4360;
	// 82407538: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 8240753C: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 82407540: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 82407544: 7F065800  cmpw cr6, r6, r11
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82407548: 4198FF44  blt cr6, 0x8240748c
	if ctx.cr[6].lt {
	pc = 0x8240748C; continue 'dispatch;
	}
	// 8240754C: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 82407550: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 82407554: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	pc = 0x82407558; continue 'dispatch;
            }
            0x82407558 => {
    //   block [0x82407558..0x8240756C)
	// 82407558: 7F09C000  cmpw cr6, r9, r24
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[24].s32, &mut ctx.xer);
	// 8240755C: 40980010  bge cr6, 0x8240756c
	if !ctx.cr[6].lt {
	pc = 0x8240756C; continue 'dispatch;
	}
	// 82407560: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82407564: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82407568: 4800000C  b 0x82407574
	pc = 0x82407574; continue 'dispatch;
            }
            0x8240756C => {
    //   block [0x8240756C..0x82407574)
	// 8240756C: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82407570: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	pc = 0x82407574; continue 'dispatch;
            }
            0x82407574 => {
    //   block [0x82407574..0x82407598)
	// 82407574: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82407578: 39040100  addi r8, r4, 0x100
	ctx.r[8].s64 = ctx.r[4].s64 + 256;
	// 8240757C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82407580: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 82407584: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82407588: 4198FFD0  blt cr6, 0x82407558
	if ctx.cr[6].lt {
	pc = 0x82407558; continue 'dispatch;
	}
	// 8240758C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82407590: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82407594: 4812DB64  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82407598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82407598 size=4
    let mut pc: u32 = 0x82407598;
    'dispatch: loop {
        match pc {
            0x82407598 => {
    //   block [0x82407598..0x8240759C)
	// 82407598: 4BFFFEA0  b 0x82407438
	sub_82407438(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824075A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824075A0 size=412
    let mut pc: u32 = 0x824075A0;
    'dispatch: loop {
        match pc {
            0x824075A0 => {
    //   block [0x824075A0..0x824075D4)
	// 824075A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824075A4: 4812DB09  bl 0x825350ac
	ctx.lr = 0x824075A8;
	sub_82535080(ctx, base);
	// 824075A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824075AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824075B0: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 824075B4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 824075B8: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 824075BC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 824075C0: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 824075C4: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 824075C8: 4198000C  blt cr6, 0x824075d4
	if ctx.cr[6].lt {
	pc = 0x824075D4; continue 'dispatch;
	}
	// 824075CC: 9B7F0211  stb r27, 0x211(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(529 as u32), ctx.r[27].u8 ) };
	// 824075D0: 48000008  b 0x824075d8
	pc = 0x824075D8; continue 'dispatch;
            }
            0x824075D4 => {
    //   block [0x824075D4..0x824075D8)
	// 824075D4: 9BBF0211  stb r29, 0x211(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(529 as u32), ctx.r[29].u8 ) };
	pc = 0x824075D8; continue 'dispatch;
            }
            0x824075D8 => {
    //   block [0x824075D8..0x82407624)
	// 824075D8: 80BF0084  lwz r5, 0x84(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 824075DC: 90FF0214  stw r7, 0x214(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(532 as u32), ctx.r[7].u32 ) };
	// 824075E0: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 824075E4: 41820040  beq 0x82407624
	if ctx.cr[0].eq {
	pc = 0x82407624; continue 'dispatch;
	}
	// 824075E8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824075EC: 809F0080  lwz r4, 0x80(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 824075F0: 386BC7D4  addi r3, r11, -0x382c
	ctx.r[3].s64 = ctx.r[11].s64 + -14380;
	// 824075F4: 4BEAB98D  bl 0x822b2f80
	ctx.lr = 0x824075F8;
	sub_822B2F80(ctx, base);
	// 824075F8: 3BDF1310  addi r30, r31, 0x1310
	ctx.r[30].s64 = ctx.r[31].s64 + 4880;
	// 824075FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82407600: 48305C5D  bl 0x8270d25c
	ctx.lr = 0x82407604;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 82407604: 39600009  li r11, 9
	ctx.r[11].s64 = 9;
	// 82407608: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8240760C: 939F00F0  stw r28, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[28].u32 ) };
	// 82407610: 93BF00EC  stw r29, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[29].u32 ) };
	// 82407614: 937F00F4  stw r27, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[27].u32 ) };
	// 82407618: 917F0134  stw r11, 0x134(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[11].u32 ) };
	// 8240761C: 48305C51  bl 0x8270d26c
	ctx.lr = 0x82407620;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 82407620: 48000034  b 0x82407654
	pc = 0x82407654; continue 'dispatch;
            }
            0x82407624 => {
    //   block [0x82407624..0x82407654)
	// 82407624: 3BDF1310  addi r30, r31, 0x1310
	ctx.r[30].s64 = ctx.r[31].s64 + 4880;
	// 82407628: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8240762C: 48305C31  bl 0x8270d25c
	ctx.lr = 0x82407630;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 82407630: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82407634: 939F00F0  stw r28, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[28].u32 ) };
	// 82407638: 937F00F4  stw r27, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[27].u32 ) };
	// 8240763C: 937F0134  stw r27, 0x134(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[27].u32 ) };
	// 82407640: 48305C2D  bl 0x8270d26c
	ctx.lr = 0x82407644;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 82407644: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82407648: 809F0080  lwz r4, 0x80(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 8240764C: 386BC7A4  addi r3, r11, -0x385c
	ctx.r[3].s64 = ctx.r[11].s64 + -14428;
	// 82407650: 4BEAB931  bl 0x822b2f80
	ctx.lr = 0x82407654;
	sub_822B2F80(ctx, base);
	pc = 0x82407654; continue 'dispatch;
            }
            0x82407654 => {
    //   block [0x82407654..0x824076A8)
	// 82407654: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82407658: 3B9F01FC  addi r28, r31, 0x1fc
	ctx.r[28].s64 = ctx.r[31].s64 + 508;
	// 8240765C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82407660: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82407664: C04B1FF8  lfs f2, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82407668: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8240766C: C02B1850  lfs f1, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82407670: 48000101  bl 0x82407770
	ctx.lr = 0x82407674;
	sub_82407770(ctx, base);
	// 82407674: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82407678: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8240767C: 48000105  bl 0x82407780
	ctx.lr = 0x82407680;
	sub_82407780(ctx, base);
	// 82407680: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82407684: 935F00E8  stw r26, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[26].u32 ) };
	// 82407688: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8240768C: 93BF00EC  stw r29, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[29].u32 ) };
	// 82407690: 93BF01F0  stw r29, 0x1f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(496 as u32), ctx.r[29].u32 ) };
	// 82407694: 9BBF00FA  stb r29, 0xfa(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(250 as u32), ctx.r[29].u8 ) };
	// 82407698: 9BBF0210  stb r29, 0x210(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(528 as u32), ctx.r[29].u8 ) };
	// 8240769C: 419A004C  beq cr6, 0x824076e8
	if ctx.cr[6].eq {
	pc = 0x824076E8; continue 'dispatch;
	}
	// 824076A0: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 824076A4: 397F0090  addi r11, r31, 0x90
	ctx.r[11].s64 = ctx.r[31].s64 + 144;
	pc = 0x824076A8; continue 'dispatch;
            }
            0x824076A8 => {
    //   block [0x824076A8..0x824076CC)
	// 824076A8: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824076AC: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 824076B0: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 824076B4: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 824076B8: 41820014  beq 0x824076cc
	if ctx.cr[0].eq {
	pc = 0x824076CC; continue 'dispatch;
	}
	// 824076BC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824076C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824076C4: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 824076C8: 419AFFE0  beq cr6, 0x824076a8
	if ctx.cr[6].eq {
	pc = 0x824076A8; continue 'dispatch;
	}
	pc = 0x824076CC; continue 'dispatch;
            }
            0x824076CC => {
    //   block [0x824076CC..0x824076E8)
	// 824076CC: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 824076D0: 41820018  beq 0x824076e8
	if ctx.cr[0].eq {
	pc = 0x824076E8; continue 'dispatch;
	}
	// 824076D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824076D8: 48305B85  bl 0x8270d25c
	ctx.lr = 0x824076DC;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 824076DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824076E0: 9B7F00F8  stb r27, 0xf8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[27].u8 ) };
	// 824076E4: 48305B89  bl 0x8270d26c
	ctx.lr = 0x824076E8;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x824076E8; continue 'dispatch;
            }
            0x824076E8 => {
    //   block [0x824076E8..0x824076F0)
	// 824076E8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 824076EC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x824076F0; continue 'dispatch;
            }
            0x824076F0 => {
    //   block [0x824076F0..0x8240772C)
	// 824076F0: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824076F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824076F8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 824076FC: 409AFFF4  bne cr6, 0x824076f0
	if !ctx.cr[6].eq {
	pc = 0x824076F0; continue 'dispatch;
	}
	// 82407700: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82407704: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82407708: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8240770C: 38AB0001  addi r5, r11, 1
	ctx.r[5].s64 = ctx.r[11].s64 + 1;
	// 82407710: 2F050050  cmpwi cr6, r5, 0x50
	ctx.cr[6].compare_i32(ctx.r[5].s32, 80, &mut ctx.xer);
	// 82407714: 40980018  bge cr6, 0x8240772c
	if !ctx.cr[6].lt {
	pc = 0x8240772C; continue 'dispatch;
	}
	// 82407718: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 8240771C: 387F0090  addi r3, r31, 0x90
	ctx.r[3].s64 = ctx.r[31].s64 + 144;
	// 82407720: 4BFB94E1  bl 0x823c0c00
	ctx.lr = 0x82407724;
	sub_823C0C00(ctx, base);
	// 82407724: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82407728: 4800000C  b 0x82407734
	pc = 0x82407734; continue 'dispatch;
            }
            0x8240772C => {
    //   block [0x8240772C..0x82407734)
	// 8240772C: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82407730: 6063000C  ori r3, r3, 0xc
	ctx.r[3].u64 = ctx.r[3].u64 | 12;
	pc = 0x82407734; continue 'dispatch;
            }
            0x82407734 => {
    //   block [0x82407734..0x8240773C)
	// 82407734: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82407738: 4812D9C4  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82407770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82407770 size=16
    let mut pc: u32 = 0x82407770;
    'dispatch: loop {
        match pc {
            0x82407770 => {
    //   block [0x82407770..0x82407780)
	// 82407770: D0230000  stfs f1, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82407774: 90830008  stw r4, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 82407778: D0430004  stfs f2, 4(r3)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8240777C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82407780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82407780 size=20
    let mut pc: u32 = 0x82407780;
    'dispatch: loop {
        match pc {
            0x82407780 => {
    //   block [0x82407780..0x82407794)
	// 82407780: 7C8B0034  cntlzw r11, r4
	ctx.r[11].u64 = if ctx.r[4].u32 == 0 { 32 } else { ctx.r[4].u32.leading_zeros() as u64 };
	// 82407784: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82407788: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 8240778C: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82407790: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82407798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82407798 size=40
    let mut pc: u32 = 0x82407798;
    'dispatch: loop {
        match pc {
            0x82407798 => {
    //   block [0x82407798..0x824077C0)
	// 82407798: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8240779C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 824077A0: C00B1850  lfs f0, 0x1850(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824077A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824077A8: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 824077AC: 9143000C  stw r10, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 824077B0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 824077B4: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824077B8: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 824077BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824077C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824077C0 size=60
    let mut pc: u32 = 0x824077C0;
    'dispatch: loop {
        match pc {
            0x824077C0 => {
    //   block [0x824077C0..0x824077FC)
	// 824077C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824077C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824077C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824077CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824077D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824077D4: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 824077D8: 48005001  bl 0x8240c7d8
	ctx.lr = 0x824077DC;
	sub_8240C7D8(ctx, base);
	// 824077DC: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 824077E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824077E4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824077E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824077EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824077F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824077F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824077F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82407800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82407800 size=8
    let mut pc: u32 = 0x82407800;
    'dispatch: loop {
        match pc {
            0x82407800 => {
    //   block [0x82407800..0x82407808)
	// 82407800: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 82407804: 48005014  b 0x8240c818
	sub_8240C818(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82407808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82407808 size=136
    let mut pc: u32 = 0x82407808;
    'dispatch: loop {
        match pc {
            0x82407808 => {
    //   block [0x82407808..0x8240786C)
	// 82407808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240780C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82407810: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82407814: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82407818: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8240781C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82407820: 38A0000B  li r5, 0xb
	ctx.r[5].s64 = 11;
	// 82407824: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82407828: 38610059  addi r3, r1, 0x59
	ctx.r[3].s64 = ctx.r[1].s64 + 89;
	// 8240782C: 99610058  stb r11, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 82407830: 4812D9A1  bl 0x825351d0
	ctx.lr = 0x82407834;
	sub_825351D0(ctx, base);
	// 82407834: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82407838: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 8240783C: 396B6490  addi r11, r11, 0x6490
	ctx.r[11].s64 = ctx.r[11].s64 + 25744;
	// 82407840: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82407844: 99410059  stb r10, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[10].u8 ) };
	// 82407848: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8240784C: 4817CA75  bl 0x825842c0
	ctx.lr = 0x82407850;
	sub_825842C0(ctx, base);
	// 82407850: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82407854: 40800018  bge 0x8240786c
	if !ctx.cr[0].lt {
	pc = 0x8240786C; continue 'dispatch;
	}
	// 82407858: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8240785C: 386BC80C  addi r3, r11, -0x37f4
	ctx.r[3].s64 = ctx.r[11].s64 + -14324;
	// 82407860: 4BEAB721  bl 0x822b2f80
	ctx.lr = 0x82407864;
	sub_822B2F80(ctx, base);
	// 82407864: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82407868: 48000014  b 0x8240787c
	pc = 0x8240787C; continue 'dispatch;
            }
            0x8240786C => {
    //   block [0x8240786C..0x8240787C)
	// 8240786C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82407870: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82407874: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82407878: 48004FE1  bl 0x8240c858
	ctx.lr = 0x8240787C;
	sub_8240C858(ctx, base);
	pc = 0x8240787C; continue 'dispatch;
            }
            0x8240787C => {
    //   block [0x8240787C..0x82407890)
	// 8240787C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82407880: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82407884: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82407888: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8240788C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82407890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82407890 size=144
    let mut pc: u32 = 0x82407890;
    'dispatch: loop {
        match pc {
            0x82407890 => {
    //   block [0x82407890..0x824078B0)
	// 82407890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82407894: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82407898: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240789C: 2B040003  cmplwi cr6, r4, 3
	ctx.cr[6].compare_u32(ctx.r[4].u32, 3 as u32, &mut ctx.xer);
	// 824078A0: 41990060  bgt cr6, 0x82407900
	if ctx.cr[6].gt {
	pc = 0x82407900; continue 'dispatch;
	}
	// 824078A4: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 824078A8: 40980008  bge cr6, 0x824078b0
	if !ctx.cr[6].lt {
	pc = 0x824078B0; continue 'dispatch;
	}
	// 824078AC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	pc = 0x824078B0; continue 'dispatch;
            }
            0x824078B0 => {
    //   block [0x824078B0..0x824078F8)
	// 824078B0: 3D240001  addis r9, r4, 1
	ctx.r[9].s64 = ctx.r[4].s64 + 65536;
	// 824078B4: 3D608273  lis r11, -0x7d8d
	ctx.r[11].s64 = -2106392576;
	// 824078B8: 39298A85  addi r9, r9, -0x757b
	ctx.r[9].s64 = ctx.r[9].s64 + -30075;
	// 824078BC: 396B3258  addi r11, r11, 0x3258
	ctx.r[11].s64 = ctx.r[11].s64 + 12888;
	// 824078C0: 1D450030  mulli r10, r5, 0x30
	ctx.r[10].s32 = ((ctx.r[5].s32 as i64 * 48 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 824078C4: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 824078C8: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 824078CC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 824078D0: 7C69182E  lwzx r3, r9, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 824078D4: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 824078D8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 824078DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 824078E0: 41820018  beq 0x824078f8
	if ctx.cr[0].eq {
	pc = 0x824078F8; continue 'dispatch;
	}
	// 824078E4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 824078E8: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 824078EC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 824078F0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 824078F4: 4817C31D  bl 0x82583c10
	ctx.lr = 0x824078F8;
	sub_82583C10(ctx, base);
	pc = 0x824078F8; continue 'dispatch;
            }
            0x824078F8 => {
    //   block [0x824078F8..0x82407900)
	// 824078F8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824078FC: 48000014  b 0x82407910
	pc = 0x82407910; continue 'dispatch;
            }
            0x82407900 => {
    //   block [0x82407900..0x82407910)
	// 82407900: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82407904: 386BC83C  addi r3, r11, -0x37c4
	ctx.r[3].s64 = ctx.r[11].s64 + -14276;
	// 82407908: 4BEAB679  bl 0x822b2f80
	ctx.lr = 0x8240790C;
	sub_822B2F80(ctx, base);
	// 8240790C: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82407910; continue 'dispatch;
            }
            0x82407910 => {
    //   block [0x82407910..0x82407920)
	// 82407910: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82407914: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82407918: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8240791C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82407920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82407920 size=72
    let mut pc: u32 = 0x82407920;
    'dispatch: loop {
        match pc {
            0x82407920 => {
    //   block [0x82407920..0x82407948)
	// 82407920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82407924: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82407928: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240792C: 2B040003  cmplwi cr6, r4, 3
	ctx.cr[6].compare_u32(ctx.r[4].u32, 3 as u32, &mut ctx.xer);
	// 82407930: 41990018  bgt cr6, 0x82407948
	if ctx.cr[6].gt {
	pc = 0x82407948; continue 'dispatch;
	}
	// 82407934: 3D640001  addis r11, r4, 1
	ctx.r[11].s64 = ctx.r[4].s64 + 65536;
	// 82407938: 396B8A85  addi r11, r11, -0x757b
	ctx.r[11].s64 = ctx.r[11].s64 + -30075;
	// 8240793C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82407940: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82407944: 48000014  b 0x82407958
	pc = 0x82407958; continue 'dispatch;
            }
            0x82407948 => {
    //   block [0x82407948..0x82407958)
	// 82407948: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8240794C: 386BC878  addi r3, r11, -0x3788
	ctx.r[3].s64 = ctx.r[11].s64 + -14216;
	// 82407950: 4BEAB631  bl 0x822b2f80
	ctx.lr = 0x82407954;
	sub_822B2F80(ctx, base);
	// 82407954: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82407958; continue 'dispatch;
            }
            0x82407958 => {
    //   block [0x82407958..0x82407968)
	// 82407958: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8240795C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82407960: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82407964: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82407968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82407968 size=336
    let mut pc: u32 = 0x82407968;
    'dispatch: loop {
        match pc {
            0x82407968 => {
    //   block [0x82407968..0x82407A7C)
	// 82407968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240796C: 4812D749  bl 0x825350b4
	ctx.lr = 0x82407970;
	sub_82535080(ctx, base);
	// 82407970: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82407974: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82407978: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 8240797C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82407980: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82407984: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82407988: C00B1850  lfs f0, 0x1850(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8240798C: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82407990: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82407994: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82407998: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 8240799C: D00100A4  stfs f0, 0xa4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 824079A0: 3B800006  li r28, 6
	ctx.r[28].s64 = 6;
	// 824079A4: D00100AC  stfs f0, 0xac(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 824079A8: 38A0001B  li r5, 0x1b
	ctx.r[5].s64 = 27;
	// 824079AC: D00100B4  stfs f0, 0xb4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 824079B0: 99610058  stb r11, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 824079B4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 824079B8: 996100B9  stb r11, 0xb9(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(185 as u32), ctx.r[11].u8 ) };
	// 824079BC: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 824079C0: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 824079C4: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 824079C8: 38610081  addi r3, r1, 0x81
	ctx.r[3].s64 = ctx.r[1].s64 + 129;
	// 824079CC: D00100BC  stfs f0, 0xbc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 824079D0: D00100C4  stfs f0, 0xc4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 824079D4: 93BB0000  stw r29, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 824079D8: D00100CC  stfs f0, 0xcc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 824079DC: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 824079E0: 996100C1  stb r11, 0xc1(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(193 as u32), ctx.r[11].u8 ) };
	// 824079E4: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 824079E8: 9BC10070  stb r30, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u8 ) };
	// 824079EC: 9BE100A0  stb r31, 0xa0(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[31].u8 ) };
	// 824079F0: 9BE100A1  stb r31, 0xa1(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(161 as u32), ctx.r[31].u8 ) };
	// 824079F4: 9BE100A8  stb r31, 0xa8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[31].u8 ) };
	// 824079F8: 996100C9  stb r11, 0xc9(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(201 as u32), ctx.r[11].u8 ) };
	// 824079FC: 396100A0  addi r11, r1, 0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + 160;
	// 82407A00: 9BC100A9  stb r30, 0xa9(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(169 as u32), ctx.r[30].u8 ) };
	// 82407A04: 9BE100B0  stb r31, 0xb0(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[31].u8 ) };
	// 82407A08: 994100B1  stb r10, 0xb1(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(177 as u32), ctx.r[10].u8 ) };
	// 82407A0C: 9BE100B8  stb r31, 0xb8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[31].u8 ) };
	// 82407A10: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82407A14: 39610068  addi r11, r1, 0x68
	ctx.r[11].s64 = ctx.r[1].s64 + 104;
	// 82407A18: 9BE100C0  stb r31, 0xc0(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[31].u8 ) };
	// 82407A1C: 9BE100C8  stb r31, 0xc8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[31].u8 ) };
	// 82407A20: 9B810060  stb r28, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u8 ) };
	// 82407A24: 9BC10078  stb r30, 0x78(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[30].u8 ) };
	// 82407A28: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82407A2C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82407A30: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 82407A34: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82407A38: 4812D799  bl 0x825351d0
	ctx.lr = 0x82407A3C;
	sub_825351D0(ctx, base);
	// 82407A3C: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 82407A40: 9B810089  stb r28, 0x89(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(137 as u32), ctx.r[28].u8 ) };
	// 82407A44: 9BE10080  stb r31, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u8 ) };
	// 82407A48: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82407A4C: 9BC10081  stb r30, 0x81(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(129 as u32), ctx.r[30].u8 ) };
	// 82407A50: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82407A54: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82407A58: 616BBB80  ori r11, r11, 0xbb80
	ctx.r[11].u64 = ctx.r[11].u64 | 48000;
	// 82407A5C: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82407A60: 39610078  addi r11, r1, 0x78
	ctx.r[11].s64 = ctx.r[1].s64 + 120;
	// 82407A64: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82407A68: 40990044  ble cr6, 0x82407aac
	if !ctx.cr[6].gt {
	pc = 0x82407AAC; continue 'dispatch;
	}
	// 82407A6C: 3FDB0002  addis r30, r27, 2
	ctx.r[30].s64 = ctx.r[27].s64 + 131072;
	// 82407A70: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82407A74: 3BDE2A14  addi r30, r30, 0x2a14
	ctx.r[30].s64 = ctx.r[30].s64 + 10772;
	// 82407A78: 3BABC8B4  addi r29, r11, -0x374c
	ctx.r[29].s64 = ctx.r[11].s64 + -14156;
	pc = 0x82407A7C; continue 'dispatch;
            }
            0x82407A7C => {
    //   block [0x82407A7C..0x82407A98)
	// 82407A7C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82407A80: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82407A84: 4817C8A5  bl 0x82584328
	ctx.lr = 0x82407A88;
	sub_82584328(ctx, base);
	// 82407A88: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82407A8C: 4080000C  bge 0x82407a98
	if !ctx.cr[0].lt {
	pc = 0x82407A98; continue 'dispatch;
	}
	// 82407A90: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82407A94: 4BEAB4ED  bl 0x822b2f80
	ctx.lr = 0x82407A98;
	sub_822B2F80(ctx, base);
	pc = 0x82407A98; continue 'dispatch;
            }
            0x82407A98 => {
    //   block [0x82407A98..0x82407AAC)
	// 82407A98: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82407A9C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82407AA0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82407AA4: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82407AA8: 4198FFD4  blt cr6, 0x82407a7c
	if ctx.cr[6].lt {
	pc = 0x82407A7C; continue 'dispatch;
	}
	pc = 0x82407AAC; continue 'dispatch;
            }
            0x82407AAC => {
    //   block [0x82407AAC..0x82407AB8)
	// 82407AAC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82407AB0: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82407AB4: 4812D650  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82407AB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82407AB8 size=92
    let mut pc: u32 = 0x82407AB8;
    'dispatch: loop {
        match pc {
            0x82407AB8 => {
    //   block [0x82407AB8..0x82407AE0)
	// 82407AB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82407ABC: 4812D601  bl 0x825350bc
	ctx.lr = 0x82407AC0;
	sub_82535080(ctx, base);
	// 82407AC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82407AC4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82407AC8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82407ACC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82407AD0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82407AD4: 40990038  ble cr6, 0x82407b0c
	if !ctx.cr[6].gt {
	pc = 0x82407B0C; continue 'dispatch;
	}
	// 82407AD8: 3FFE0002  addis r31, r30, 2
	ctx.r[31].s64 = ctx.r[30].s64 + 131072;
	// 82407ADC: 3BFF2A14  addi r31, r31, 0x2a14
	ctx.r[31].s64 = ctx.r[31].s64 + 10772;
	pc = 0x82407AE0; continue 'dispatch;
            }
            0x82407AE0 => {
    //   block [0x82407AE0..0x82407AF8)
	// 82407AE0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82407AE4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82407AE8: 41820010  beq 0x82407af8
	if ctx.cr[0].eq {
	pc = 0x82407AF8; continue 'dispatch;
	}
	// 82407AEC: 4817C0BD  bl 0x82583ba8
	ctx.lr = 0x82407AF0;
	sub_82583BA8(ctx, base);
	// 82407AF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82407AF4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82407AF8; continue 'dispatch;
            }
            0x82407AF8 => {
    //   block [0x82407AF8..0x82407B0C)
	// 82407AF8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82407AFC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82407B00: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82407B04: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82407B08: 4198FFD8  blt cr6, 0x82407ae0
	if ctx.cr[6].lt {
	pc = 0x82407AE0; continue 'dispatch;
	}
	pc = 0x82407B0C; continue 'dispatch;
            }
            0x82407B0C => {
    //   block [0x82407B0C..0x82407B14)
	// 82407B0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82407B10: 4812D5FC  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82407B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82407B18 size=60
    let mut pc: u32 = 0x82407B18;
    'dispatch: loop {
        match pc {
            0x82407B18 => {
    //   block [0x82407B18..0x82407B54)
	// 82407B18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82407B1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82407B20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82407B24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82407B28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82407B2C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82407B30: 48004D81  bl 0x8240c8b0
	ctx.lr = 0x82407B34;
	sub_8240C8B0(ctx, base);
	// 82407B34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82407B38: 4BFFFF81  bl 0x82407ab8
	ctx.lr = 0x82407B3C;
	sub_82407AB8(ctx, base);
	// 82407B3C: 4817C68D  bl 0x825841c8
	ctx.lr = 0x82407B40;
	sub_825841C8(ctx, base);
	// 82407B40: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82407B44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82407B48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82407B4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82407B50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82407B58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82407B58 size=516
    let mut pc: u32 = 0x82407B58;
    'dispatch: loop {
        match pc {
            0x82407B58 => {
    //   block [0x82407B58..0x82407BB8)
	// 82407B58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82407B5C: 4812D561  bl 0x825350bc
	ctx.lr = 0x82407B60;
	sub_82535080(ctx, base);
	// 82407B60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82407B64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82407B68: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82407B6C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82407B70: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82407B74: 3FC08273  lis r30, -0x7d8d
	ctx.r[30].s64 = -2106392576;
	// 82407B78: 3C600008  lis r3, 8
	ctx.r[3].s64 = 524288;
	// 82407B7C: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82407B80: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82407B84: 60630310  ori r3, r3, 0x310
	ctx.r[3].u64 = ctx.r[3].u64 | 784;
	// 82407B88: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82407B8C: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82407B90: 93BF0010  stw r29, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 82407B94: 93BF0014  stw r29, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 82407B98: 817E3800  lwz r11, 0x3800(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14336 as u32) ) } as u64;
	// 82407B9C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82407BA0: 4E800421  bctrl
	ctx.lr = 0x82407BA4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82407BA4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82407BA8: 41820010  beq 0x82407bb8
	if ctx.cr[0].eq {
	pc = 0x82407BB8; continue 'dispatch;
	}
	// 82407BAC: 4800428D  bl 0x8240be38
	ctx.lr = 0x82407BB0;
	sub_8240BE38(ctx, base);
	// 82407BB0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82407BB4: 48000008  b 0x82407bbc
	pc = 0x82407BBC; continue 'dispatch;
            }
            0x82407BB8 => {
    //   block [0x82407BB8..0x82407BBC)
	// 82407BB8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82407BBC; continue 'dispatch;
            }
            0x82407BBC => {
    //   block [0x82407BBC..0x82407BE8)
	// 82407BBC: 3C600001  lis r3, 1
	ctx.r[3].s64 = 65536;
	// 82407BC0: 917F1C38  stw r11, 0x1c38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(7224 as u32), ctx.r[11].u32 ) };
	// 82407BC4: 817E3800  lwz r11, 0x3800(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14336 as u32) ) } as u64;
	// 82407BC8: 60630D08  ori r3, r3, 0xd08
	ctx.r[3].u64 = ctx.r[3].u64 | 3336;
	// 82407BCC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82407BD0: 4E800421  bctrl
	ctx.lr = 0x82407BD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82407BD4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82407BD8: 41820010  beq 0x82407be8
	if ctx.cr[0].eq {
	pc = 0x82407BE8; continue 'dispatch;
	}
	// 82407BDC: 4800408D  bl 0x8240bc68
	ctx.lr = 0x82407BE0;
	sub_8240BC68(ctx, base);
	// 82407BE0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82407BE4: 48000008  b 0x82407bec
	pc = 0x82407BEC; continue 'dispatch;
            }
            0x82407BE8 => {
    //   block [0x82407BE8..0x82407BEC)
	// 82407BE8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82407BEC; continue 'dispatch;
            }
            0x82407BEC => {
    //   block [0x82407BEC..0x82407C2C)
	// 82407BEC: 917F1C3C  stw r11, 0x1c3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(7228 as u32), ctx.r[11].u32 ) };
	// 82407BF0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82407BF4: 817E3800  lwz r11, 0x3800(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14336 as u32) ) } as u64;
	// 82407BF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82407BFC: 4E800421  bctrl
	ctx.lr = 0x82407C00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82407C00: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82407C04: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 82407C08: 917F1C40  stw r11, 0x1c40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(7232 as u32), ctx.r[11].u32 ) };
	// 82407C0C: 817E3800  lwz r11, 0x3800(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14336 as u32) ) } as u64;
	// 82407C10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82407C14: 4E800421  bctrl
	ctx.lr = 0x82407C18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82407C18: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82407C1C: 41820010  beq 0x82407c2c
	if ctx.cr[0].eq {
	pc = 0x82407C2C; continue 'dispatch;
	}
	// 82407C20: 48007751  bl 0x8240f370
	ctx.lr = 0x82407C24;
	sub_8240F370(ctx, base);
	// 82407C24: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82407C28: 48000008  b 0x82407c30
	pc = 0x82407C30; continue 'dispatch;
            }
            0x82407C2C => {
    //   block [0x82407C2C..0x82407C30)
	// 82407C2C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82407C30; continue 'dispatch;
            }
            0x82407C30 => {
    //   block [0x82407C30..0x82407C70)
	// 82407C30: 917F1C44  stw r11, 0x1c44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(7236 as u32), ctx.r[11].u32 ) };
	// 82407C34: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82407C38: 817E3800  lwz r11, 0x3800(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14336 as u32) ) } as u64;
	// 82407C3C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82407C40: 4E800421  bctrl
	ctx.lr = 0x82407C44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82407C44: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82407C48: 38600DBC  li r3, 0xdbc
	ctx.r[3].s64 = 3516;
	// 82407C4C: 917F1C48  stw r11, 0x1c48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(7240 as u32), ctx.r[11].u32 ) };
	// 82407C50: 817E3800  lwz r11, 0x3800(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14336 as u32) ) } as u64;
	// 82407C54: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82407C58: 4E800421  bctrl
	ctx.lr = 0x82407C5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82407C5C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82407C60: 41820010  beq 0x82407c70
	if ctx.cr[0].eq {
	pc = 0x82407C70; continue 'dispatch;
	}
	// 82407C64: 4800717D  bl 0x8240ede0
	ctx.lr = 0x82407C68;
	sub_8240EDE0(ctx, base);
	// 82407C68: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82407C6C: 48000008  b 0x82407c74
	pc = 0x82407C74; continue 'dispatch;
            }
            0x82407C70 => {
    //   block [0x82407C70..0x82407C74)
	// 82407C70: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82407C74; continue 'dispatch;
            }
            0x82407C74 => {
    //   block [0x82407C74..0x82407C9C)
	// 82407C74: 917F1C4C  stw r11, 0x1c4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(7244 as u32), ctx.r[11].u32 ) };
	// 82407C78: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82407C7C: 817E3800  lwz r11, 0x3800(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14336 as u32) ) } as u64;
	// 82407C80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82407C84: 4E800421  bctrl
	ctx.lr = 0x82407C88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82407C88: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82407C8C: 41820010  beq 0x82407c9c
	if ctx.cr[0].eq {
	pc = 0x82407C9C; continue 'dispatch;
	}
	// 82407C90: 4BEAB2F1  bl 0x822b2f80
	ctx.lr = 0x82407C94;
	sub_822B2F80(ctx, base);
	// 82407C94: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82407C98: 48000008  b 0x82407ca0
	pc = 0x82407CA0; continue 'dispatch;
            }
            0x82407C9C => {
    //   block [0x82407C9C..0x82407CA0)
	// 82407C9C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82407CA0; continue 'dispatch;
            }
            0x82407CA0 => {
    //   block [0x82407CA0..0x82407CC8)
	// 82407CA0: 917F1C54  stw r11, 0x1c54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(7252 as u32), ctx.r[11].u32 ) };
	// 82407CA4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82407CA8: 817E3800  lwz r11, 0x3800(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14336 as u32) ) } as u64;
	// 82407CAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82407CB0: 4E800421  bctrl
	ctx.lr = 0x82407CB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82407CB4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82407CB8: 41820010  beq 0x82407cc8
	if ctx.cr[0].eq {
	pc = 0x82407CC8; continue 'dispatch;
	}
	// 82407CBC: 4BEAB2C5  bl 0x822b2f80
	ctx.lr = 0x82407CC0;
	sub_822B2F80(ctx, base);
	// 82407CC0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82407CC4: 48000008  b 0x82407ccc
	pc = 0x82407CCC; continue 'dispatch;
            }
            0x82407CC8 => {
    //   block [0x82407CC8..0x82407CCC)
	// 82407CC8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82407CCC; continue 'dispatch;
            }
            0x82407CCC => {
    //   block [0x82407CCC..0x82407CF0)
	// 82407CCC: 917F1C58  stw r11, 0x1c58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(7256 as u32), ctx.r[11].u32 ) };
	// 82407CD0: 38602500  li r3, 0x2500
	ctx.r[3].s64 = 9472;
	// 82407CD4: 817E3800  lwz r11, 0x3800(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14336 as u32) ) } as u64;
	// 82407CD8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82407CDC: 4E800421  bctrl
	ctx.lr = 0x82407CE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82407CE0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82407CE4: 4182000C  beq 0x82407cf0
	if ctx.cr[0].eq {
	pc = 0x82407CF0; continue 'dispatch;
	}
	// 82407CE8: 48006F89  bl 0x8240ec70
	ctx.lr = 0x82407CEC;
	sub_8240EC70(ctx, base);
	// 82407CEC: 48000008  b 0x82407cf4
	pc = 0x82407CF4; continue 'dispatch;
            }
            0x82407CF0 => {
    //   block [0x82407CF0..0x82407CF4)
	// 82407CF0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	pc = 0x82407CF4; continue 'dispatch;
            }
            0x82407CF4 => {
    //   block [0x82407CF4..0x82407D3C)
	// 82407CF4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82407CF8: 907F1C50  stw r3, 0x1c50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(7248 as u32), ctx.r[3].u32 ) };
	// 82407CFC: 39400040  li r10, 0x40
	ctx.r[10].s64 = 64;
	// 82407D00: C1AB293C  lfs f13, 0x293c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10556 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82407D04: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82407D08: D1BF1C18  stfs f13, 0x1c18(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(7192 as u32), tmp.u32 ) };
	// 82407D0C: C00B2268  lfs f0, 0x2268(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8808 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82407D10: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82407D14: D01F1C1C  stfs f0, 0x1c1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(7196 as u32), tmp.u32 ) };
	// 82407D18: C1AB2424  lfs f13, 0x2424(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9252 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82407D1C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82407D20: D1BF1C20  stfs f13, 0x1c20(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(7200 as u32), tmp.u32 ) };
	// 82407D24: C18BC8EC  lfs f12, -0x3714(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82407D28: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82407D2C: D19F1C24  stfs f12, 0x1c24(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(7204 as u32), tmp.u32 ) };
	// 82407D30: C1AB8E30  lfs f13, -0x71d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82407D34: 397F0118  addi r11, r31, 0x118
	ctx.r[11].s64 = ctx.r[31].s64 + 280;
	// 82407D38: D1BF1C28  stfs f13, 0x1c28(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(7208 as u32), tmp.u32 ) };
	pc = 0x82407D3C; continue 'dispatch;
            }
            0x82407D3C => {
    //   block [0x82407D3C..0x82407D5C)
	// 82407D3C: D00BFF00  stfs f0, -0x100(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-256 as u32), tmp.u32 ) };
	// 82407D40: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82407D44: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82407D48: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82407D4C: 4082FFF0  bne 0x82407d3c
	if !ctx.cr[0].eq {
	pc = 0x82407D3C; continue 'dispatch;
	}
	// 82407D50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82407D54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82407D58: 4812D3B4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82407D60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82407D60 size=56
    let mut pc: u32 = 0x82407D60;
    'dispatch: loop {
        match pc {
            0x82407D60 => {
    //   block [0x82407D60..0x82407D98)
	// 82407D60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82407D64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82407D68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82407D6C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82407D70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82407D74: 807F1C50  lwz r3, 0x1c50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7248 as u32) ) } as u64;
	// 82407D78: 4BEE9659  bl 0x822f13d0
	ctx.lr = 0x82407D7C;
	sub_822F13D0(ctx, base);
	// 82407D7C: 807F1C38  lwz r3, 0x1c38(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7224 as u32) ) } as u64;
	// 82407D80: 480048F9  bl 0x8240c678
	ctx.lr = 0x82407D84;
	sub_8240C678(ctx, base);
	// 82407D84: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82407D88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82407D8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82407D90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82407D94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82407D98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82407D98 size=96
    let mut pc: u32 = 0x82407D98;
    'dispatch: loop {
        match pc {
            0x82407D98 => {
    //   block [0x82407D98..0x82407DD4)
	// 82407D98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82407D9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82407DA0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82407DA4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82407DA8: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82407DAC: 814B1C4C  lwz r10, 0x1c4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7244 as u32) ) } as u64;
	// 82407DB0: 80AA0010  lwz r5, 0x10(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82407DB4: 41980020  blt cr6, 0x82407dd4
	if ctx.cr[6].lt {
	pc = 0x82407DD4; continue 'dispatch;
	}
	// 82407DB8: 7F042800  cmpw cr6, r4, r5
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82407DBC: 40980018  bge cr6, 0x82407dd4
	if !ctx.cr[6].lt {
	pc = 0x82407DD4; continue 'dispatch;
	}
	// 82407DC0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82407DC4: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 82407DC8: 4BFFE781  bl 0x82406548
	ctx.lr = 0x82407DCC;
	sub_82406548(ctx, base);
	// 82407DCC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82407DD0: 48000018  b 0x82407de8
	pc = 0x82407DE8; continue 'dispatch;
            }
            0x82407DD4 => {
    //   block [0x82407DD4..0x82407DE8)
	// 82407DD4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82407DD8: 386BC8F0  addi r3, r11, -0x3710
	ctx.r[3].s64 = ctx.r[11].s64 + -14096;
	// 82407DDC: 4BEAB1A5  bl 0x822b2f80
	ctx.lr = 0x82407DE0;
	sub_822B2F80(ctx, base);
	// 82407DE0: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82407DE4: 6063002B  ori r3, r3, 0x2b
	ctx.r[3].u64 = ctx.r[3].u64 | 43;
	pc = 0x82407DE8; continue 'dispatch;
            }
            0x82407DE8 => {
    //   block [0x82407DE8..0x82407DF8)
	// 82407DE8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82407DEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82407DF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82407DF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82407DF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82407DF8 size=24
    let mut pc: u32 = 0x82407DF8;
    'dispatch: loop {
        match pc {
            0x82407DF8 => {
    //   block [0x82407DF8..0x82407E10)
	// 82407DF8: 2B04001F  cmplwi cr6, r4, 0x1f
	ctx.cr[6].compare_u32(ctx.r[4].u32, 31 as u32, &mut ctx.xer);
	// 82407DFC: 41990014  bgt cr6, 0x82407e10
	if ctx.cr[6].gt {
		crate::recompiler::externs::call(ctx, base, 0x82407E10);
		return;
	}
	// 82407E00: 1D6400D0  mulli r11, r4, 0xd0
	ctx.r[11].s32 = ((ctx.r[4].s32 as i64 * 208 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82407E04: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82407E08: 386B0218  addi r3, r11, 0x218
	ctx.r[3].s64 = ctx.r[11].s64 + 536;
	// 82407E0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82407E18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82407E18 size=108
    let mut pc: u32 = 0x82407E18;
    'dispatch: loop {
        match pc {
            0x82407E18 => {
    //   block [0x82407E18..0x82407E40)
	// 82407E18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82407E1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82407E20: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82407E24: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82407E28: 419A0048  beq cr6, 0x82407e70
	if ctx.cr[6].eq {
	pc = 0x82407E70; continue 'dispatch;
	}
	// 82407E2C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82407E30: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82407E34: 4199003C  bgt cr6, 0x82407e70
	if ctx.cr[6].gt {
	pc = 0x82407E70; continue 'dispatch;
	}
	// 82407E38: 81631C3C  lwz r11, 0x1c3c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(7228 as u32) ) } as u64;
	// 82407E3C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82407E40; continue 'dispatch;
            }
            0x82407E40 => {
    //   block [0x82407E40..0x82407E70)
	// 82407E40: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82407E44: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82407E48: 419A0028  beq cr6, 0x82407e70
	if ctx.cr[6].eq {
	pc = 0x82407E70; continue 'dispatch;
	}
	// 82407E4C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82407E50: 396B0164  addi r11, r11, 0x164
	ctx.r[11].s64 = ctx.r[11].s64 + 356;
	// 82407E54: 2F0A00C0  cmpwi cr6, r10, 0xc0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 192, &mut ctx.xer);
	// 82407E58: 4198FFE8  blt cr6, 0x82407e40
	if ctx.cr[6].lt {
	pc = 0x82407E40; continue 'dispatch;
	}
	// 82407E5C: 80631C50  lwz r3, 0x1c50(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(7248 as u32) ) } as u64;
	// 82407E60: 48006B19  bl 0x8240e978
	ctx.lr = 0x82407E64;
	sub_8240E978(ctx, base);
	// 82407E64: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82407E68: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82407E6C: 40810008  ble 0x82407e74
	if !ctx.cr[0].gt {
	pc = 0x82407E74; continue 'dispatch;
	}
	pc = 0x82407E70; continue 'dispatch;
            }
            0x82407E70 => {
    //   block [0x82407E70..0x82407E74)
	// 82407E70: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82407E74; continue 'dispatch;
            }
            0x82407E74 => {
    //   block [0x82407E74..0x82407E84)
	// 82407E74: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82407E78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82407E7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82407E80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82407E88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82407E88 size=116
    let mut pc: u32 = 0x82407E88;
    'dispatch: loop {
        match pc {
            0x82407E88 => {
    //   block [0x82407E88..0x82407EB0)
	// 82407E88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82407E8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82407E90: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82407E94: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82407E98: 419A0048  beq cr6, 0x82407ee0
	if ctx.cr[6].eq {
	pc = 0x82407EE0; continue 'dispatch;
	}
	// 82407E9C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82407EA0: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82407EA4: 4199003C  bgt cr6, 0x82407ee0
	if ctx.cr[6].gt {
	pc = 0x82407EE0; continue 'dispatch;
	}
	// 82407EA8: 81631C3C  lwz r11, 0x1c3c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(7228 as u32) ) } as u64;
	// 82407EAC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82407EB0; continue 'dispatch;
            }
            0x82407EB0 => {
    //   block [0x82407EB0..0x82407EE0)
	// 82407EB0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82407EB4: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82407EB8: 419A003C  beq cr6, 0x82407ef4
	if ctx.cr[6].eq {
	pc = 0x82407EF4; continue 'dispatch;
	}
	// 82407EBC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82407EC0: 396B0164  addi r11, r11, 0x164
	ctx.r[11].s64 = ctx.r[11].s64 + 356;
	// 82407EC4: 2F0A00C0  cmpwi cr6, r10, 0xc0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 192, &mut ctx.xer);
	// 82407EC8: 4198FFE8  blt cr6, 0x82407eb0
	if ctx.cr[6].lt {
	pc = 0x82407EB0; continue 'dispatch;
	}
	// 82407ECC: 80631C50  lwz r3, 0x1c50(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(7248 as u32) ) } as u64;
	// 82407ED0: 48006AA9  bl 0x8240e978
	ctx.lr = 0x82407ED4;
	sub_8240E978(ctx, base);
	// 82407ED4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82407ED8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82407EDC: 41810008  bgt 0x82407ee4
	if ctx.cr[0].gt {
	pc = 0x82407EE4; continue 'dispatch;
	}
	pc = 0x82407EE0; continue 'dispatch;
            }
            0x82407EE0 => {
    //   block [0x82407EE0..0x82407EE4)
	// 82407EE0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82407EE4; continue 'dispatch;
            }
            0x82407EE4 => {
    //   block [0x82407EE4..0x82407EF4)
	// 82407EE4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82407EE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82407EEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82407EF0: 4E800020  blr
	return;
            }
            0x82407EF4 => {
    //   block [0x82407EF4..0x82407EFC)
	// 82407EF4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82407EF8: 4BFFFFEC  b 0x82407ee4
	pc = 0x82407EE4; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82407F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82407F00 size=228
    let mut pc: u32 = 0x82407F00;
    'dispatch: loop {
        match pc {
            0x82407F00 => {
    //   block [0x82407F00..0x82407F4C)
	// 82407F00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82407F04: 4812D1B1  bl 0x825350b4
	ctx.lr = 0x82407F08;
	sub_82535080(ctx, base);
	// 82407F08: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82407F0C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82407F10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82407F14: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82407F18: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82407F1C: 419A0030  beq cr6, 0x82407f4c
	if ctx.cr[6].eq {
	pc = 0x82407F4C; continue 'dispatch;
	}
	// 82407F20: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82407F24: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82407F28: 41990024  bgt cr6, 0x82407f4c
	if ctx.cr[6].gt {
	pc = 0x82407F4C; continue 'dispatch;
	}
	// 82407F2C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82407F30: 807F1C38  lwz r3, 0x1c38(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7224 as u32) ) } as u64;
	// 82407F34: 4800454D  bl 0x8240c480
	ctx.lr = 0x82407F38;
	sub_8240C480(ctx, base);
	// 82407F38: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82407F3C: 4182001C  beq 0x82407f58
	if ctx.cr[0].eq {
	pc = 0x82407F58; continue 'dispatch;
	}
	// 82407F40: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82407F44: 386BC938  addi r3, r11, -0x36c8
	ctx.r[3].s64 = ctx.r[11].s64 + -14024;
	// 82407F48: 4BEAB039  bl 0x822b2f80
	ctx.lr = 0x82407F4C;
	sub_822B2F80(ctx, base);
	pc = 0x82407F4C; continue 'dispatch;
            }
            0x82407F4C => {
    //   block [0x82407F4C..0x82407F50)
	// 82407F4C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82407F50; continue 'dispatch;
            }
            0x82407F50 => {
    //   block [0x82407F50..0x82407F58)
	// 82407F50: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82407F54: 4812D1B0  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            0x82407F58 => {
    //   block [0x82407F58..0x82407F80)
	// 82407F58: 817F1C38  lwz r11, 0x1c38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7224 as u32) ) } as u64;
	// 82407F5C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82407F60: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82407F64: 3C6B0008  addis r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 524288;
	// 82407F68: 3863030C  addi r3, r3, 0x30c
	ctx.r[3].s64 = ctx.r[3].s64 + 780;
	// 82407F6C: 4BFFEC9D  bl 0x82406c08
	ctx.lr = 0x82407F70;
	sub_82406C08(ctx, base);
	// 82407F70: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82407F74: 4182FFD8  beq 0x82407f4c
	if ctx.cr[0].eq {
	pc = 0x82407F4C; continue 'dispatch;
	}
	// 82407F78: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82407F7C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82407F80; continue 'dispatch;
            }
            0x82407F80 => {
    //   block [0x82407F80..0x82407FA0)
	// 82407F80: 807F1C3C  lwz r3, 0x1c3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7228 as u32) ) } as u64;
	// 82407F84: 7D7E182E  lwzx r11, r30, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82407F88: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82407F8C: 409A0014  bne cr6, 0x82407fa0
	if !ctx.cr[6].eq {
	pc = 0x82407FA0; continue 'dispatch;
	}
	// 82407F90: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82407F94: 4800332D  bl 0x8240b2c0
	ctx.lr = 0x82407F98;
	sub_8240B2C0(ctx, base);
	// 82407F98: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82407F9C: 419A0024  beq cr6, 0x82407fc0
	if ctx.cr[6].eq {
	pc = 0x82407FC0; continue 'dispatch;
	}
	pc = 0x82407FA0; continue 'dispatch;
            }
            0x82407FA0 => {
    //   block [0x82407FA0..0x82407FC0)
	// 82407FA0: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 82407FA4: 3BDE0164  addi r30, r30, 0x164
	ctx.r[30].s64 = ctx.r[30].s64 + 356;
	// 82407FA8: 616B0B00  ori r11, r11, 0xb00
	ctx.r[11].u64 = ctx.r[11].u64 | 2816;
	// 82407FAC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82407FB0: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82407FB4: 4198FFCC  blt cr6, 0x82407f80
	if ctx.cr[6].lt {
	pc = 0x82407F80; continue 'dispatch;
	}
	// 82407FB8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82407FBC: 4BFFFF94  b 0x82407f50
	pc = 0x82407F50; continue 'dispatch;
            }
            0x82407FC0 => {
    //   block [0x82407FC0..0x82407FE4)
	// 82407FC0: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82407FC4: 807F1C3C  lwz r3, 0x1c3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7228 as u32) ) } as u64;
	// 82407FC8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82407FCC: 48003255  bl 0x8240b220
	ctx.lr = 0x82407FD0;
	sub_8240B220(ctx, base);
	// 82407FD0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82407FD4: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 82407FD8: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82407FDC: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82407FE0: 4BFFFF70  b 0x82407f50
	pc = 0x82407F50; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82407FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82407FE8 size=236
    let mut pc: u32 = 0x82407FE8;
    'dispatch: loop {
        match pc {
            0x82407FE8 => {
    //   block [0x82407FE8..0x82408018)
	// 82407FE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82407FEC: 4812D0C9  bl 0x825350b4
	ctx.lr = 0x82407FF0;
	sub_82535080(ctx, base);
	// 82407FF0: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82407FF4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82407FF8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82407FFC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82408000: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82408004: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82408008: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8240800C: 409A001C  bne cr6, 0x82408028
	if !ctx.cr[6].eq {
	pc = 0x82408028; continue 'dispatch;
	}
	// 82408010: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82408014: 386BC9F8  addi r3, r11, -0x3608
	ctx.r[3].s64 = ctx.r[11].s64 + -13832;
	pc = 0x82408018; continue 'dispatch;
            }
            0x82408018 => {
    //   block [0x82408018..0x82408028)
	// 82408018: 4BEAAF69  bl 0x822b2f80
	ctx.lr = 0x8240801C;
	sub_822B2F80(ctx, base);
	// 8240801C: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82408020: 60630012  ori r3, r3, 0x12
	ctx.r[3].u64 = ctx.r[3].u64 | 18;
	// 82408024: 480000A4  b 0x824080c8
	pc = 0x824080C8; continue 'dispatch;
            }
            0x82408028 => {
    //   block [0x82408028..0x8240805C)
	// 82408028: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8240802C: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82408030: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82408034: 40980028  bge cr6, 0x8240805c
	if !ctx.cr[6].lt {
	pc = 0x8240805C; continue 'dispatch;
	}
	// 82408038: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8240803C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82408040: D8210018  stfd f1, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.f[1].u64 ) };
	// 82408044: E8810018  ld r4, 0x18(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(24 as u32) ) };
	// 82408048: 386BC9C4  addi r3, r11, -0x363c
	ctx.r[3].s64 = ctx.r[11].s64 + -13884;
	// 8240804C: 4BEAAF35  bl 0x822b2f80
	ctx.lr = 0x82408050;
	sub_822B2F80(ctx, base);
	// 82408050: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82408054: 60630018  ori r3, r3, 0x18
	ctx.r[3].u64 = ctx.r[3].u64 | 24;
	// 82408058: 48000070  b 0x824080c8
	pc = 0x824080C8; continue 'dispatch;
            }
            0x8240805C => {
    //   block [0x8240805C..0x82408074)
	// 8240805C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82408060: 807C1C50  lwz r3, 0x1c50(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7248 as u32) ) } as u64;
	// 82408064: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82408068: 480067B9  bl 0x8240e820
	ctx.lr = 0x8240806C;
	sub_8240E820(ctx, base);
	// 8240806C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82408070: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82408074; continue 'dispatch;
            }
            0x82408074 => {
    //   block [0x82408074..0x82408094)
	// 82408074: 807C1C3C  lwz r3, 0x1c3c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7228 as u32) ) } as u64;
	// 82408078: 7D7E182E  lwzx r11, r30, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 8240807C: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82408080: 409A0014  bne cr6, 0x82408094
	if !ctx.cr[6].eq {
	pc = 0x82408094; continue 'dispatch;
	}
	// 82408084: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82408088: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8240808C: 4800346D  bl 0x8240b4f8
	ctx.lr = 0x82408090;
	sub_8240B4F8(ctx, base);
	// 82408090: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	pc = 0x82408094; continue 'dispatch;
            }
            0x82408094 => {
    //   block [0x82408094..0x824080C4)
	// 82408094: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 82408098: 3BDE0164  addi r30, r30, 0x164
	ctx.r[30].s64 = ctx.r[30].s64 + 356;
	// 8240809C: 616B0B00  ori r11, r11, 0xb00
	ctx.r[11].u64 = ctx.r[11].u64 | 2816;
	// 824080A0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 824080A4: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824080A8: 4198FFCC  blt cr6, 0x82408074
	if ctx.cr[6].lt {
	pc = 0x82408074; continue 'dispatch;
	}
	// 824080AC: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 824080B0: 409A0014  bne cr6, 0x824080c4
	if !ctx.cr[6].eq {
	pc = 0x824080C4; continue 'dispatch;
	}
	// 824080B4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824080B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824080BC: 386BC984  addi r3, r11, -0x367c
	ctx.r[3].s64 = ctx.r[11].s64 + -13948;
	// 824080C0: 4BFFFF58  b 0x82408018
	pc = 0x82408018; continue 'dispatch;
            }
            0x824080C4 => {
    //   block [0x824080C4..0x824080C8)
	// 824080C4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x824080C8; continue 'dispatch;
            }
            0x824080C8 => {
    //   block [0x824080C8..0x824080D4)
	// 824080C8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 824080CC: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 824080D0: 4812D034  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824080D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824080D8 size=184
    let mut pc: u32 = 0x824080D8;
    'dispatch: loop {
        match pc {
            0x824080D8 => {
    //   block [0x824080D8..0x82408108)
	// 824080D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824080DC: 4812CFD9  bl 0x825350b4
	ctx.lr = 0x824080E0;
	sub_82535080(ctx, base);
	// 824080E0: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 824080E4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824080E8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824080EC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 824080F0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 824080F4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 824080F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 824080FC: 409A001C  bne cr6, 0x82408118
	if !ctx.cr[6].eq {
	pc = 0x82408118; continue 'dispatch;
	}
	// 82408100: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82408104: 386BCA70  addi r3, r11, -0x3590
	ctx.r[3].s64 = ctx.r[11].s64 + -13712;
	pc = 0x82408108; continue 'dispatch;
            }
            0x82408108 => {
    //   block [0x82408108..0x82408118)
	// 82408108: 4BEAAE79  bl 0x822b2f80
	ctx.lr = 0x8240810C;
	sub_822B2F80(ctx, base);
	// 8240810C: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82408110: 60630012  ori r3, r3, 0x12
	ctx.r[3].u64 = ctx.r[3].u64 | 18;
	// 82408114: 48000070  b 0x82408184
	pc = 0x82408184; continue 'dispatch;
            }
            0x82408118 => {
    //   block [0x82408118..0x82408130)
	// 82408118: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8240811C: 807C1C50  lwz r3, 0x1c50(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7248 as u32) ) } as u64;
	// 82408120: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82408124: 4800672D  bl 0x8240e850
	ctx.lr = 0x82408128;
	sub_8240E850(ctx, base);
	// 82408128: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8240812C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82408130; continue 'dispatch;
            }
            0x82408130 => {
    //   block [0x82408130..0x82408150)
	// 82408130: 807C1C3C  lwz r3, 0x1c3c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7228 as u32) ) } as u64;
	// 82408134: 7D7E182E  lwzx r11, r30, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82408138: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8240813C: 409A0014  bne cr6, 0x82408150
	if !ctx.cr[6].eq {
	pc = 0x82408150; continue 'dispatch;
	}
	// 82408140: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82408144: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82408148: 48003481  bl 0x8240b5c8
	ctx.lr = 0x8240814C;
	sub_8240B5C8(ctx, base);
	// 8240814C: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	pc = 0x82408150; continue 'dispatch;
            }
            0x82408150 => {
    //   block [0x82408150..0x82408180)
	// 82408150: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 82408154: 3BDE0164  addi r30, r30, 0x164
	ctx.r[30].s64 = ctx.r[30].s64 + 356;
	// 82408158: 616B0B00  ori r11, r11, 0xb00
	ctx.r[11].u64 = ctx.r[11].u64 | 2816;
	// 8240815C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82408160: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82408164: 4198FFCC  blt cr6, 0x82408130
	if ctx.cr[6].lt {
	pc = 0x82408130; continue 'dispatch;
	}
	// 82408168: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 8240816C: 409A0014  bne cr6, 0x82408180
	if !ctx.cr[6].eq {
	pc = 0x82408180; continue 'dispatch;
	}
	// 82408170: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82408174: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82408178: 386BCA34  addi r3, r11, -0x35cc
	ctx.r[3].s64 = ctx.r[11].s64 + -13772;
	// 8240817C: 4BFFFF8C  b 0x82408108
	pc = 0x82408108; continue 'dispatch;
            }
            0x82408180 => {
    //   block [0x82408180..0x82408184)
	// 82408180: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82408184; continue 'dispatch;
            }
            0x82408184 => {
    //   block [0x82408184..0x82408190)
	// 82408184: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82408188: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 8240818C: 4812CF78  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82408190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82408190 size=176
    let mut pc: u32 = 0x82408190;
    'dispatch: loop {
        match pc {
            0x82408190 => {
    //   block [0x82408190..0x824081BC)
	// 82408190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82408194: 4812CF1D  bl 0x825350b0
	ctx.lr = 0x82408198;
	sub_82535080(ctx, base);
	// 82408198: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240819C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824081A0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 824081A4: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 824081A8: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 824081AC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 824081B0: 409A001C  bne cr6, 0x824081cc
	if !ctx.cr[6].eq {
	pc = 0x824081CC; continue 'dispatch;
	}
	// 824081B4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824081B8: 386BCAE4  addi r3, r11, -0x351c
	ctx.r[3].s64 = ctx.r[11].s64 + -13596;
	pc = 0x824081BC; continue 'dispatch;
            }
            0x824081BC => {
    //   block [0x824081BC..0x824081CC)
	// 824081BC: 4BEAADC5  bl 0x822b2f80
	ctx.lr = 0x824081C0;
	sub_822B2F80(ctx, base);
	// 824081C0: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 824081C4: 60630012  ori r3, r3, 0x12
	ctx.r[3].u64 = ctx.r[3].u64 | 18;
	// 824081C8: 48000070  b 0x82408238
	pc = 0x82408238; continue 'dispatch;
            }
            0x824081CC => {
    //   block [0x824081CC..0x824081E4)
	// 824081CC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 824081D0: 807C1C50  lwz r3, 0x1c50(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7248 as u32) ) } as u64;
	// 824081D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824081D8: 480066A9  bl 0x8240e880
	ctx.lr = 0x824081DC;
	sub_8240E880(ctx, base);
	// 824081DC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 824081E0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x824081E4; continue 'dispatch;
            }
            0x824081E4 => {
    //   block [0x824081E4..0x82408204)
	// 824081E4: 807C1C3C  lwz r3, 0x1c3c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7228 as u32) ) } as u64;
	// 824081E8: 7D7E182E  lwzx r11, r30, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 824081EC: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 824081F0: 409A0014  bne cr6, 0x82408204
	if !ctx.cr[6].eq {
	pc = 0x82408204; continue 'dispatch;
	}
	// 824081F4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 824081F8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824081FC: 4800337D  bl 0x8240b578
	ctx.lr = 0x82408200;
	sub_8240B578(ctx, base);
	// 82408200: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	pc = 0x82408204; continue 'dispatch;
            }
            0x82408204 => {
    //   block [0x82408204..0x82408234)
	// 82408204: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 82408208: 3BDE0164  addi r30, r30, 0x164
	ctx.r[30].s64 = ctx.r[30].s64 + 356;
	// 8240820C: 616B0B00  ori r11, r11, 0xb00
	ctx.r[11].u64 = ctx.r[11].u64 | 2816;
	// 82408210: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82408214: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82408218: 4198FFCC  blt cr6, 0x824081e4
	if ctx.cr[6].lt {
	pc = 0x824081E4; continue 'dispatch;
	}
	// 8240821C: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82408220: 409A0014  bne cr6, 0x82408234
	if !ctx.cr[6].eq {
	pc = 0x82408234; continue 'dispatch;
	}
	// 82408224: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82408228: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8240822C: 386BCAA8  addi r3, r11, -0x3558
	ctx.r[3].s64 = ctx.r[11].s64 + -13656;
	// 82408230: 4BFFFF8C  b 0x824081bc
	pc = 0x824081BC; continue 'dispatch;
            }
            0x82408234 => {
    //   block [0x82408234..0x82408238)
	// 82408234: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82408238; continue 'dispatch;
            }
            0x82408238 => {
    //   block [0x82408238..0x82408240)
	// 82408238: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8240823C: 4812CEC4  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82408240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82408240 size=124
    let mut pc: u32 = 0x82408240;
    'dispatch: loop {
        match pc {
            0x82408240 => {
    //   block [0x82408240..0x82408254)
	// 82408240: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82408244: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82408248: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240824C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82408250: 409A001C  bne cr6, 0x8240826c
	if !ctx.cr[6].eq {
	pc = 0x8240826C; continue 'dispatch;
	}
	pc = 0x82408254; continue 'dispatch;
            }
            0x82408254 => {
    //   block [0x82408254..0x8240826C)
	// 82408254: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82408258: 386BCB20  addi r3, r11, -0x34e0
	ctx.r[3].s64 = ctx.r[11].s64 + -13536;
	// 8240825C: 4BEAAD25  bl 0x822b2f80
	ctx.lr = 0x82408260;
	sub_822B2F80(ctx, base);
	// 82408260: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82408264: 60630012  ori r3, r3, 0x12
	ctx.r[3].u64 = ctx.r[3].u64 | 18;
	// 82408268: 48000044  b 0x824082ac
	pc = 0x824082AC; continue 'dispatch;
            }
            0x8240826C => {
    //   block [0x8240826C..0x82408278)
	// 8240826C: 80631C3C  lwz r3, 0x1c3c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(7228 as u32) ) } as u64;
	// 82408270: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82408274: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	pc = 0x82408278; continue 'dispatch;
            }
            0x82408278 => {
    //   block [0x82408278..0x82408298)
	// 82408278: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8240827C: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82408280: 419A0018  beq cr6, 0x82408298
	if ctx.cr[6].eq {
	pc = 0x82408298; continue 'dispatch;
	}
	// 82408284: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82408288: 394A0164  addi r10, r10, 0x164
	ctx.r[10].s64 = ctx.r[10].s64 + 356;
	// 8240828C: 2F0B00C0  cmpwi cr6, r11, 0xc0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 192, &mut ctx.xer);
	// 82408290: 4198FFE8  blt cr6, 0x82408278
	if ctx.cr[6].lt {
	pc = 0x82408278; continue 'dispatch;
	}
	// 82408294: 4BFFFFC0  b 0x82408254
	pc = 0x82408254; continue 'dispatch;
            }
            0x82408298 => {
    //   block [0x82408298..0x824082AC)
	// 82408298: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8240829C: 4198FFB8  blt cr6, 0x82408254
	if ctx.cr[6].lt {
	pc = 0x82408254; continue 'dispatch;
	}
	// 824082A0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 824082A4: 48003115  bl 0x8240b3b8
	ctx.lr = 0x824082A8;
	sub_8240B3B8(ctx, base);
	// 824082A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x824082AC; continue 'dispatch;
            }
            0x824082AC => {
    //   block [0x824082AC..0x824082BC)
	// 824082AC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824082B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824082B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824082B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824082C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824082C0 size=136
    let mut pc: u32 = 0x824082C0;
    'dispatch: loop {
        match pc {
            0x824082C0 => {
    //   block [0x824082C0..0x824082DC)
	// 824082C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824082C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824082C8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824082CC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 824082D0: 409A001C  bne cr6, 0x824082ec
	if !ctx.cr[6].eq {
	pc = 0x824082EC; continue 'dispatch;
	}
	// 824082D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824082D8: 386BCB60  addi r3, r11, -0x34a0
	ctx.r[3].s64 = ctx.r[11].s64 + -13472;
	pc = 0x824082DC; continue 'dispatch;
            }
            0x824082DC => {
    //   block [0x824082DC..0x824082EC)
	// 824082DC: 4BEAACA5  bl 0x822b2f80
	ctx.lr = 0x824082E0;
	sub_822B2F80(ctx, base);
	// 824082E0: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 824082E4: 60630012  ori r3, r3, 0x12
	ctx.r[3].u64 = ctx.r[3].u64 | 18;
	// 824082E8: 48000050  b 0x82408338
	pc = 0x82408338; continue 'dispatch;
            }
            0x824082EC => {
    //   block [0x824082EC..0x824082F8)
	// 824082EC: 80631C3C  lwz r3, 0x1c3c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(7228 as u32) ) } as u64;
	// 824082F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824082F4: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	pc = 0x824082F8; continue 'dispatch;
            }
            0x824082F8 => {
    //   block [0x824082F8..0x82408318)
	// 824082F8: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 824082FC: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82408300: 419A0018  beq cr6, 0x82408318
	if ctx.cr[6].eq {
	pc = 0x82408318; continue 'dispatch;
	}
	// 82408304: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82408308: 394A0164  addi r10, r10, 0x164
	ctx.r[10].s64 = ctx.r[10].s64 + 356;
	// 8240830C: 2F0B00C0  cmpwi cr6, r11, 0xc0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 192, &mut ctx.xer);
	// 82408310: 4198FFE8  blt cr6, 0x824082f8
	if ctx.cr[6].lt {
	pc = 0x824082F8; continue 'dispatch;
	}
	// 82408314: 4800000C  b 0x82408320
	pc = 0x82408320; continue 'dispatch;
            }
            0x82408318 => {
    //   block [0x82408318..0x82408320)
	// 82408318: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8240831C: 40980010  bge cr6, 0x8240832c
	if !ctx.cr[6].lt {
	pc = 0x8240832C; continue 'dispatch;
	}
	pc = 0x82408320; continue 'dispatch;
            }
            0x82408320 => {
    //   block [0x82408320..0x8240832C)
	// 82408320: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82408324: 386BCB9C  addi r3, r11, -0x3464
	ctx.r[3].s64 = ctx.r[11].s64 + -13412;
	// 82408328: 4BFFFFB4  b 0x824082dc
	pc = 0x824082DC; continue 'dispatch;
            }
            0x8240832C => {
    //   block [0x8240832C..0x82408338)
	// 8240832C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82408330: 480030D9  bl 0x8240b408
	ctx.lr = 0x82408334;
	sub_8240B408(ctx, base);
	// 82408334: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82408338; continue 'dispatch;
            }
            0x82408338 => {
    //   block [0x82408338..0x82408348)
	// 82408338: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8240833C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82408340: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82408344: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82408348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82408348 size=124
    let mut pc: u32 = 0x82408348;
    'dispatch: loop {
        match pc {
            0x82408348 => {
    //   block [0x82408348..0x8240835C)
	// 82408348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240834C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82408350: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82408354: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82408358: 409A001C  bne cr6, 0x82408374
	if !ctx.cr[6].eq {
	pc = 0x82408374; continue 'dispatch;
	}
	pc = 0x8240835C; continue 'dispatch;
            }
            0x8240835C => {
    //   block [0x8240835C..0x82408374)
	// 8240835C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82408360: 386BCBE0  addi r3, r11, -0x3420
	ctx.r[3].s64 = ctx.r[11].s64 + -13344;
	// 82408364: 4BEAAC1D  bl 0x822b2f80
	ctx.lr = 0x82408368;
	sub_822B2F80(ctx, base);
	// 82408368: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 8240836C: 60630012  ori r3, r3, 0x12
	ctx.r[3].u64 = ctx.r[3].u64 | 18;
	// 82408370: 48000044  b 0x824083b4
	pc = 0x824083B4; continue 'dispatch;
            }
            0x82408374 => {
    //   block [0x82408374..0x82408380)
	// 82408374: 80631C3C  lwz r3, 0x1c3c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(7228 as u32) ) } as u64;
	// 82408378: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8240837C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	pc = 0x82408380; continue 'dispatch;
            }
            0x82408380 => {
    //   block [0x82408380..0x824083A0)
	// 82408380: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82408384: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82408388: 419A0018  beq cr6, 0x824083a0
	if ctx.cr[6].eq {
	pc = 0x824083A0; continue 'dispatch;
	}
	// 8240838C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82408390: 394A0164  addi r10, r10, 0x164
	ctx.r[10].s64 = ctx.r[10].s64 + 356;
	// 82408394: 2F0B00C0  cmpwi cr6, r11, 0xc0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 192, &mut ctx.xer);
	// 82408398: 4198FFE8  blt cr6, 0x82408380
	if ctx.cr[6].lt {
	pc = 0x82408380; continue 'dispatch;
	}
	// 8240839C: 4BFFFFC0  b 0x8240835c
	pc = 0x8240835C; continue 'dispatch;
            }
            0x824083A0 => {
    //   block [0x824083A0..0x824083B4)
	// 824083A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824083A4: 4198FFB8  blt cr6, 0x8240835c
	if ctx.cr[6].lt {
	pc = 0x8240835C; continue 'dispatch;
	}
	// 824083A8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 824083AC: 480030AD  bl 0x8240b458
	ctx.lr = 0x824083B0;
	sub_8240B458(ctx, base);
	// 824083B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x824083B4; continue 'dispatch;
            }
            0x824083B4 => {
    //   block [0x824083B4..0x824083C4)
	// 824083B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824083B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824083BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824083C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824083C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824083C8 size=124
    let mut pc: u32 = 0x824083C8;
    'dispatch: loop {
        match pc {
            0x824083C8 => {
    //   block [0x824083C8..0x824083DC)
	// 824083C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824083CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824083D0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824083D4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 824083D8: 409A001C  bne cr6, 0x824083f4
	if !ctx.cr[6].eq {
	pc = 0x824083F4; continue 'dispatch;
	}
	pc = 0x824083DC; continue 'dispatch;
            }
            0x824083DC => {
    //   block [0x824083DC..0x824083F4)
	// 824083DC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824083E0: 386BCC28  addi r3, r11, -0x33d8
	ctx.r[3].s64 = ctx.r[11].s64 + -13272;
	// 824083E4: 4BEAAB9D  bl 0x822b2f80
	ctx.lr = 0x824083E8;
	sub_822B2F80(ctx, base);
	// 824083E8: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 824083EC: 60630012  ori r3, r3, 0x12
	ctx.r[3].u64 = ctx.r[3].u64 | 18;
	// 824083F0: 48000044  b 0x82408434
	pc = 0x82408434; continue 'dispatch;
            }
            0x824083F4 => {
    //   block [0x824083F4..0x82408400)
	// 824083F4: 80631C3C  lwz r3, 0x1c3c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(7228 as u32) ) } as u64;
	// 824083F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824083FC: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	pc = 0x82408400; continue 'dispatch;
            }
            0x82408400 => {
    //   block [0x82408400..0x82408420)
	// 82408400: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82408404: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82408408: 419A0018  beq cr6, 0x82408420
	if ctx.cr[6].eq {
	pc = 0x82408420; continue 'dispatch;
	}
	// 8240840C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82408410: 394A0164  addi r10, r10, 0x164
	ctx.r[10].s64 = ctx.r[10].s64 + 356;
	// 82408414: 2F0B00C0  cmpwi cr6, r11, 0xc0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 192, &mut ctx.xer);
	// 82408418: 4198FFE8  blt cr6, 0x82408400
	if ctx.cr[6].lt {
	pc = 0x82408400; continue 'dispatch;
	}
	// 8240841C: 4BFFFFC0  b 0x824083dc
	pc = 0x824083DC; continue 'dispatch;
            }
            0x82408420 => {
    //   block [0x82408420..0x82408434)
	// 82408420: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82408424: 4198FFB8  blt cr6, 0x824083dc
	if ctx.cr[6].lt {
	pc = 0x824083DC; continue 'dispatch;
	}
	// 82408428: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 8240842C: 4800307D  bl 0x8240b4a8
	ctx.lr = 0x82408430;
	sub_8240B4A8(ctx, base);
	// 82408430: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82408434; continue 'dispatch;
            }
            0x82408434 => {
    //   block [0x82408434..0x82408444)
	// 82408434: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82408438: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8240843C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82408440: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82408448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82408448 size=24
    let mut pc: u32 = 0x82408448;
    'dispatch: loop {
        match pc {
            0x82408448 => {
    //   block [0x82408448..0x82408460)
	// 82408448: C0031C1C  lfs f0, 0x1c1c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(7196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8240844C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82408450: 41990010  bgt cr6, 0x82408460
	if ctx.cr[6].gt {
		sub_82408460(ctx, base);
		return;
	}
	// 82408454: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82408458: C02B1FF8  lfs f1, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8240845C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82408460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82408460 size=40
    let mut pc: u32 = 0x82408460;
    'dispatch: loop {
        match pc {
            0x82408460 => {
    //   block [0x82408460..0x82408488)
	// 82408460: C1A31C24  lfs f13, 0x1c24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(7204 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82408464: C1831C28  lfs f12, 0x1c28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(7208 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82408468: FF016800  fcmpu cr6, f1, f13
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[13].f64);
	// 8240846C: 4199001C  bgt cr6, 0x82408488
	if ctx.cr[6].gt {
		sub_82408488(ctx, base);
		return;
	}
	// 82408470: C0031C1C  lfs f0, 0x1c1c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(7196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82408474: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82408478: EC010028  fsubs f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 8240847C: EDAC6824  fdivs f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 / ctx.f[13].f64) as f32) as f64;
	// 82408480: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82408484: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82408488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82408488 size=24
    let mut pc: u32 = 0x82408488;
    'dispatch: loop {
        match pc {
            0x82408488 => {
    //   block [0x82408488..0x824084A0)
	// 82408488: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8240848C: C00B1850  lfs f0, 0x1850(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82408490: ED8C0028  fsubs f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82408494: EDAC6824  fdivs f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 / ctx.f[13].f64) as f32) as f64;
	// 82408498: EC2D007A  fmadds f1, f13, f1, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64);
	// 8240849C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824084A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824084A0 size=24
    let mut pc: u32 = 0x824084A0;
    'dispatch: loop {
        match pc {
            0x824084A0 => {
    //   block [0x824084A0..0x824084B8)
	// 824084A0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824084A4: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824084A8: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 824084AC: 4199000C  bgt cr6, 0x824084b8
	if ctx.cr[6].gt {
		sub_824084B8(ctx, base);
		return;
	}
	// 824084B0: C0231C1C  lfs f1, 0x1c1c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(7196 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 824084B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824084B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824084B8 size=36
    let mut pc: u32 = 0x824084B8;
    'dispatch: loop {
        match pc {
            0x824084B8 => {
    //   block [0x824084B8..0x824084DC)
	// 824084B8: C1A31C28  lfs f13, 0x1c28(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(7208 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824084BC: C1831C24  lfs f12, 0x1c24(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(7204 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 824084C0: FF016800  fcmpu cr6, f1, f13
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[13].f64);
	// 824084C4: 41990018  bgt cr6, 0x824084dc
	if ctx.cr[6].gt {
		sub_824084DC(ctx, base);
		return;
	}
	// 824084C8: C0031C1C  lfs f0, 0x1c1c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(7196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824084CC: ED8C0028  fsubs f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 824084D0: EDAC6824  fdivs f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 / ctx.f[13].f64) as f32) as f64;
	// 824084D4: EC2D007A  fmadds f1, f13, f1, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64);
	// 824084D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824084DC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824084DC size=28
    let mut pc: u32 = 0x824084DC;
    'dispatch: loop {
        match pc {
            0x824084DC => {
    //   block [0x824084DC..0x824084F8)
	// 824084DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824084E0: C00B1850  lfs f0, 0x1850(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824084E4: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 824084E8: EC010028  fsubs f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 824084EC: EDAC6824  fdivs f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 / ctx.f[13].f64) as f32) as f64;
	// 824084F0: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 824084F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824084F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824084F8 size=80
    let mut pc: u32 = 0x824084F8;
    'dispatch: loop {
        match pc {
            0x824084F8 => {
    //   block [0x824084F8..0x82408534)
	// 824084F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824084FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82408500: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82408504: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82408508: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8240850C: 386B0040  addi r3, r11, 0x40
	ctx.r[3].s64 = ctx.r[11].s64 + 64;
	// 82408510: 4BFFED89  bl 0x82407298
	ctx.lr = 0x82408514;
	sub_82407298(ctx, base);
	// 82408514: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82408518: 4082001C  bne 0x82408534
	if !ctx.cr[0].eq {
	pc = 0x82408534; continue 'dispatch;
	}
	// 8240851C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82408520: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82408524: 40990010  ble cr6, 0x82408534
	if !ctx.cr[6].gt {
	pc = 0x82408534; continue 'dispatch;
	}
	// 82408528: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8240852C: 4BFFEA1D  bl 0x82406f48
	ctx.lr = 0x82408530;
	sub_82406F48(ctx, base);
	// 82408530: 48000008  b 0x82408538
	pc = 0x82408538; continue 'dispatch;
            }
            0x82408534 => {
    //   block [0x82408534..0x82408538)
	// 82408534: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82408538; continue 'dispatch;
            }
            0x82408538 => {
    //   block [0x82408538..0x82408548)
	// 82408538: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 8240853C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82408540: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82408544: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82408548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82408548 size=328
    let mut pc: u32 = 0x82408548;
    'dispatch: loop {
        match pc {
            0x82408548 => {
    //   block [0x82408548..0x82408570)
	// 82408548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240854C: 4812CB5D  bl 0x825350a8
	ctx.lr = 0x82408550;
	sub_82535080(ctx, base);
	// 82408550: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82408554: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82408558: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8240855C: 81781C4C  lwz r11, 0x1c4c(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(7244 as u32) ) } as u64;
	// 82408560: 3B2B0A7C  addi r25, r11, 0xa7c
	ctx.r[25].s64 = ctx.r[11].s64 + 2684;
	// 82408564: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82408568: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8240856C: 409900E4  ble cr6, 0x82408650
	if !ctx.cr[6].gt {
	pc = 0x82408650; continue 'dispatch;
	}
	pc = 0x82408570; continue 'dispatch;
            }
            0x82408570 => {
    //   block [0x82408570..0x82408580)
	// 82408570: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82408574: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 82408578: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 8240857C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82408580; continue 'dispatch;
            }
            0x82408580 => {
    //   block [0x82408580..0x82408650)
	// 82408580: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82408584: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82408588: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8240858C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82408590: 4200FFF0  bdnz 0x82408580
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82408580; continue 'dispatch;
	}
	// 82408594: 83C10094  lwz r30, 0x94(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82408598: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8240859C: 83A10090  lwz r29, 0x90(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 824085A0: 83810088  lwz r28, 0x88(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 824085A4: 7FCB07B4  extsw r11, r30
	ctx.r[11].s64 = ctx.r[30].s32 as i64;
	// 824085A8: 83610084  lwz r27, 0x84(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 824085AC: 7FAA07B4  extsw r10, r29
	ctx.r[10].s64 = ctx.r[29].s32 as i64;
	// 824085B0: 83410080  lwz r26, 0x80(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 824085B4: 7F8907B4  extsw r9, r28
	ctx.r[9].s64 = ctx.r[28].s32 as i64;
	// 824085B8: 7F6807B4  extsw r8, r27
	ctx.r[8].s64 = ctx.r[27].s32 as i64;
	// 824085BC: 7F4707B4  extsw r7, r26
	ctx.r[7].s64 = ctx.r[26].s32 as i64;
	// 824085C0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 824085C4: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 824085C8: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 824085CC: F9010068  std r8, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[8].u64 ) };
	// 824085D0: F8E10070  std r7, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[7].u64 ) };
	// 824085D4: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 824085D8: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 824085DC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 824085E0: C9810060  lfd f12, 0x60(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 824085E4: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 824085E8: C9610068  lfd f11, 0x68(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 824085EC: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 824085F0: C9410070  lfd f10, 0x70(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 824085F4: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 824085F8: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 824085FC: FCA00018  frsp f5, f0
	ctx.f[5].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82408600: FC806818  frsp f4, f13
	ctx.f[4].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82408604: FC606018  frsp f3, f12
	ctx.f[3].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82408608: FC405818  frsp f2, f11
	ctx.f[2].f64 = (ctx.f[11].f64 as f32) as f64;
	// 8240860C: FC205018  frsp f1, f10
	ctx.f[1].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82408610: 4BFFDEF1  bl 0x82406500
	ctx.lr = 0x82408614;
	sub_82406500(ctx, base);
	// 82408614: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82408618: 40820070  bne 0x82408688
	if !ctx.cr[0].eq {
	pc = 0x82408688; continue 'dispatch;
	}
	// 8240861C: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82408620: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82408624: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82408628: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 8240862C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82408630: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82408634: 4BFFDF25  bl 0x82406558
	ctx.lr = 0x82408638;
	sub_82406558(ctx, base);
	// 82408638: 81781C4C  lwz r11, 0x1c4c(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(7244 as u32) ) } as u64;
	// 8240863C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82408640: 3B390020  addi r25, r25, 0x20
	ctx.r[25].s64 = ctx.r[25].s64 + 32;
	// 82408644: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82408648: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8240864C: 4198FF24  blt cr6, 0x82408570
	if ctx.cr[6].lt {
	pc = 0x82408570; continue 'dispatch;
	}
	pc = 0x82408650; continue 'dispatch;
            }
            0x82408650 => {
    //   block [0x82408650..0x82408674)
	// 82408650: 81781C4C  lwz r11, 0x1c4c(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(7244 as u32) ) } as u64;
	// 82408654: 80AB0010  lwz r5, 0x10(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82408658: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 8240865C: 41990018  bgt cr6, 0x82408674
	if ctx.cr[6].gt {
	pc = 0x82408674; continue 'dispatch;
	}
	// 82408660: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82408664: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82408668: 386BC8F0  addi r3, r11, -0x3710
	ctx.r[3].s64 = ctx.r[11].s64 + -14096;
	// 8240866C: 4BEAA915  bl 0x822b2f80
	ctx.lr = 0x82408670;
	sub_822B2F80(ctx, base);
	// 82408670: 48000014  b 0x82408684
	pc = 0x82408684; continue 'dispatch;
            }
            0x82408674 => {
    //   block [0x82408674..0x82408684)
	// 82408674: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82408678: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8240867C: 91780008  stw r11, 8(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82408680: 4BFFDEC9  bl 0x82406548
	ctx.lr = 0x82408684;
	sub_82406548(ctx, base);
	pc = 0x82408684; continue 'dispatch;
            }
            0x82408684 => {
    //   block [0x82408684..0x82408688)
	// 82408684: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82408688; continue 'dispatch;
            }
            0x82408688 => {
    //   block [0x82408688..0x82408690)
	// 82408688: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 8240868C: 4812CA6C  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82408690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82408690 size=188
    let mut pc: u32 = 0x82408690;
    'dispatch: loop {
        match pc {
            0x82408690 => {
    //   block [0x82408690..0x824086C8)
	// 82408690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82408694: 4812CA25  bl 0x825350b8
	ctx.lr = 0x82408698;
	sub_82535080(ctx, base);
	// 82408698: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 8240869C: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 824086A0: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 824086A4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824086A8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824086AC: FFA00890  fmr f29, f1
	ctx.f[29].f64 = ctx.f[1].f64;
	// 824086B0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824086B4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 824086B8: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 824086BC: C3FE1C1C  lfs f31, 0x1c1c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(7196 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 824086C0: C3CB1FF8  lfs f30, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 824086C4: 41980070  blt cr6, 0x82408734
	if ctx.cr[6].lt {
	pc = 0x82408734; continue 'dispatch;
	}
	pc = 0x824086C8; continue 'dispatch;
            }
            0x824086C8 => {
    //   block [0x824086C8..0x824086D8)
	// 824086C8: EC5EE82A  fadds f2, f30, f29
	ctx.f[2].f64 = ((ctx.f[30].f64 + ctx.f[29].f64) as f32) as f64;
	// 824086CC: FF02F800  fcmpu cr6, f2, f31
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[31].f64);
	// 824086D0: 40980008  bge cr6, 0x824086d8
	if !ctx.cr[6].lt {
	pc = 0x824086D8; continue 'dispatch;
	}
	// 824086D4: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	pc = 0x824086D8; continue 'dispatch;
            }
            0x824086D8 => {
    //   block [0x824086D8..0x824086FC)
	// 824086D8: 397F0046  addi r11, r31, 0x46
	ctx.r[11].s64 = ctx.r[31].s64 + 70;
	// 824086DC: 557C103A  slwi r28, r11, 2
	ctx.r[28].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 824086E0: 7D7CF02E  lwzx r11, r28, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824086E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824086E8: 397F0006  addi r11, r31, 6
	ctx.r[11].s64 = ctx.r[31].s64 + 6;
	// 824086EC: 409A0010  bne cr6, 0x824086fc
	if !ctx.cr[6].eq {
	pc = 0x824086FC; continue 'dispatch;
	}
	// 824086F0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824086F4: 7C4BF52E  stfsx f2, r11, r30
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), tmp.u32) };
	// 824086F8: 48000014  b 0x8240870c
	pc = 0x8240870C; continue 'dispatch;
            }
            0x824086FC => {
    //   block [0x824086FC..0x8240870C)
	// 824086FC: 557D103A  slwi r29, r11, 2
	ctx.r[29].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 82408700: 7C3DF42E  lfsx f1, r29, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82408704: 48005EAD  bl 0x8240e5b0
	ctx.lr = 0x82408708;
	sub_8240E5B0(ctx, base);
	// 82408708: 7C3DF52E  stfsx f1, r29, r30
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[30].u32), tmp.u32) };
	pc = 0x8240870C; continue 'dispatch;
            }
            0x8240870C => {
    //   block [0x8240870C..0x82408734)
	// 8240870C: 7D7CF02E  lwzx r11, r28, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82408710: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82408714: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82408718: 7D7CF12E  stwx r11, r28, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[28].u32.wrapping_add(ctx.r[30].u32), ctx.r[11].u32) };
	// 8240871C: 4BFFEC8D  bl 0x824073a8
	ctx.lr = 0x82408720;
	sub_824073A8(ctx, base);
	// 82408720: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82408724: EFC1F02A  fadds f30, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ((ctx.f[1].f64 + ctx.f[30].f64) as f32) as f64;
	// 82408728: 4BFFEC41  bl 0x82407368
	ctx.lr = 0x8240872C;
	sub_82407368(ctx, base);
	// 8240872C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82408730: 4080FF98  bge 0x824086c8
	if !ctx.cr[0].lt {
	pc = 0x824086C8; continue 'dispatch;
	}
	pc = 0x82408734; continue 'dispatch;
            }
            0x82408734 => {
    //   block [0x82408734..0x8240874C)
	// 82408734: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82408738: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8240873C: CBA1FFC0  lfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82408740: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82408744: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82408748: 4812C9C0  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82408750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82408750 size=8
    let mut pc: u32 = 0x82408750;
    'dispatch: loop {
        match pc {
            0x82408750 => {
    //   block [0x82408750..0x82408758)
	// 82408750: 80631C50  lwz r3, 0x1c50(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(7248 as u32) ) } as u64;
	// 82408754: 480063BC  b 0x8240eb10
	sub_8240EB10(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82408758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82408758 size=8
    let mut pc: u32 = 0x82408758;
    'dispatch: loop {
        match pc {
            0x82408758 => {
    //   block [0x82408758..0x82408760)
	// 82408758: 80631C50  lwz r3, 0x1c50(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(7248 as u32) ) } as u64;
	// 8240875C: 48006424  b 0x8240eb80
	sub_8240EB80(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82408760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82408760 size=8
    let mut pc: u32 = 0x82408760;
    'dispatch: loop {
        match pc {
            0x82408760 => {
    //   block [0x82408760..0x82408768)
	// 82408760: 80631C50  lwz r3, 0x1c50(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(7248 as u32) ) } as u64;
	// 82408764: 4800646C  b 0x8240ebd0
	sub_8240EBD0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82408768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82408768 size=8
    let mut pc: u32 = 0x82408768;
    'dispatch: loop {
        match pc {
            0x82408768 => {
    //   block [0x82408768..0x82408770)
	// 82408768: 80631C50  lwz r3, 0x1c50(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(7248 as u32) ) } as u64;
	// 8240876C: 480065A4  b 0x8240ed10
	crate::recompiler::externs::call(ctx, base, 0x8240ED10);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82408770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82408770 size=152
    let mut pc: u32 = 0x82408770;
    'dispatch: loop {
        match pc {
            0x82408770 => {
    //   block [0x82408770..0x8240878C)
	// 82408770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82408774: 4812C945  bl 0x825350b8
	ctx.lr = 0x82408778;
	sub_82535080(ctx, base);
	// 82408778: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240877C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82408780: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82408784: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82408788: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	pc = 0x8240878C; continue 'dispatch;
            }
            0x8240878C => {
    //   block [0x8240878C..0x824087D8)
	// 8240878C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82408790: 807F1C50  lwz r3, 0x1c50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7248 as u32) ) } as u64;
	// 82408794: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82408798: 48005F91  bl 0x8240e728
	ctx.lr = 0x8240879C;
	sub_8240E728(ctx, base);
	// 8240879C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824087A0: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824087A4: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 824087A8: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824087AC: 419A002C  beq cr6, 0x824087d8
	if ctx.cr[6].eq {
	pc = 0x824087D8; continue 'dispatch;
	}
	// 824087B0: 80A10058  lwz r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 824087B4: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 824087B8: 41980020  blt cr6, 0x824087d8
	if ctx.cr[6].lt {
	pc = 0x824087D8; continue 'dispatch;
	}
	// 824087BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824087C0: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 824087C4: 4BFFF73D  bl 0x82407f00
	ctx.lr = 0x824087C8;
	sub_82407F00(ctx, base);
	// 824087C8: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 824087CC: 409A000C  bne cr6, 0x824087d8
	if !ctx.cr[6].eq {
	pc = 0x824087D8; continue 'dispatch;
	}
	// 824087D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824087D4: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x824087D8; continue 'dispatch;
            }
            0x824087D8 => {
    //   block [0x824087D8..0x82408808)
	// 824087D8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 824087DC: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 824087E0: 2F1E0040  cmpwi cr6, r30, 0x40
	ctx.cr[6].compare_i32(ctx.r[30].s32, 64, &mut ctx.xer);
	// 824087E4: 4198FFA8  blt cr6, 0x8240878c
	if ctx.cr[6].lt {
	pc = 0x8240878C; continue 'dispatch;
	}
	// 824087E8: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 824087EC: 80BF0014  lwz r5, 0x14(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 824087F0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 824087F4: 807F1C50  lwz r3, 0x1c50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7248 as u32) ) } as u64;
	// 824087F8: 48005EA1  bl 0x8240e698
	ctx.lr = 0x824087FC;
	sub_8240E698(ctx, base);
	// 824087FC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82408800: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 82408804: 4812C904  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82408808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82408808 size=308
    let mut pc: u32 = 0x82408808;
    'dispatch: loop {
        match pc {
            0x82408808 => {
    //   block [0x82408808..0x82408844)
	// 82408808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240880C: 4812C8B1  bl 0x825350bc
	ctx.lr = 0x82408810;
	sub_82535080(ctx, base);
	// 82408810: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82408814: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82408818: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8240881C: 3FC08273  lis r30, -0x7d8d
	ctx.r[30].s64 = -2106392576;
	// 82408820: 807F1C50  lwz r3, 0x1c50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7248 as u32) ) } as u64;
	// 82408824: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82408828: 4182001C  beq 0x82408844
	if ctx.cr[0].eq {
	pc = 0x82408844; continue 'dispatch;
	}
	// 8240882C: 4BEAA755  bl 0x822b2f80
	ctx.lr = 0x82408830;
	sub_822B2F80(ctx, base);
	// 82408830: 807F1C50  lwz r3, 0x1c50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7248 as u32) ) } as u64;
	// 82408834: 817E3804  lwz r11, 0x3804(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14340 as u32) ) } as u64;
	// 82408838: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8240883C: 4E800421  bctrl
	ctx.lr = 0x82408840;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82408840: 93BF1C50  stw r29, 0x1c50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(7248 as u32), ctx.r[29].u32 ) };
            }
            0x82408844 => {
    //   block [0x82408844..0x82408868)
	// 82408844: 807F1C58  lwz r3, 0x1c58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7256 as u32) ) } as u64;
	// 82408848: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8240884C: 4182001C  beq 0x82408868
	if ctx.cr[0].eq {
	pc = 0x82408868; continue 'dispatch;
	}
	// 82408850: 4BEAA731  bl 0x822b2f80
	ctx.lr = 0x82408854;
	sub_822B2F80(ctx, base);
	// 82408854: 807F1C58  lwz r3, 0x1c58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7256 as u32) ) } as u64;
	// 82408858: 817E3804  lwz r11, 0x3804(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14340 as u32) ) } as u64;
	// 8240885C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82408860: 4E800421  bctrl
	ctx.lr = 0x82408864;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82408864: 93BF1C58  stw r29, 0x1c58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(7256 as u32), ctx.r[29].u32 ) };
            }
            0x82408868 => {
    //   block [0x82408868..0x8240888C)
	// 82408868: 807F1C54  lwz r3, 0x1c54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7252 as u32) ) } as u64;
	// 8240886C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82408870: 4182001C  beq 0x8240888c
	if ctx.cr[0].eq {
	pc = 0x8240888C; continue 'dispatch;
	}
	// 82408874: 4BEAA70D  bl 0x822b2f80
	ctx.lr = 0x82408878;
	sub_822B2F80(ctx, base);
	// 82408878: 807F1C54  lwz r3, 0x1c54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7252 as u32) ) } as u64;
	// 8240887C: 817E3804  lwz r11, 0x3804(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14340 as u32) ) } as u64;
	// 82408880: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82408884: 4E800421  bctrl
	ctx.lr = 0x82408888;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82408888: 93BF1C54  stw r29, 0x1c54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(7252 as u32), ctx.r[29].u32 ) };
            }
            0x8240888C => {
    //   block [0x8240888C..0x824088A8)
	// 8240888C: 807F1C4C  lwz r3, 0x1c4c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7244 as u32) ) } as u64;
	// 82408890: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82408894: 41820014  beq 0x824088a8
	if ctx.cr[0].eq {
	pc = 0x824088A8; continue 'dispatch;
	}
	// 82408898: 817E3804  lwz r11, 0x3804(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14340 as u32) ) } as u64;
	// 8240889C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824088A0: 4E800421  bctrl
	ctx.lr = 0x824088A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824088A4: 93BF1C4C  stw r29, 0x1c4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(7244 as u32), ctx.r[29].u32 ) };
            }
            0x824088A8 => {
    //   block [0x824088A8..0x824088C4)
	// 824088A8: 807F1C48  lwz r3, 0x1c48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7240 as u32) ) } as u64;
	// 824088AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 824088B0: 41820014  beq 0x824088c4
	if ctx.cr[0].eq {
	pc = 0x824088C4; continue 'dispatch;
	}
	// 824088B4: 817E3804  lwz r11, 0x3804(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14340 as u32) ) } as u64;
	// 824088B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824088BC: 4E800421  bctrl
	ctx.lr = 0x824088C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824088C0: 93BF1C48  stw r29, 0x1c48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(7240 as u32), ctx.r[29].u32 ) };
            }
            0x824088C4 => {
    //   block [0x824088C4..0x824088E0)
	// 824088C4: 807F1C44  lwz r3, 0x1c44(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7236 as u32) ) } as u64;
	// 824088C8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 824088CC: 41820014  beq 0x824088e0
	if ctx.cr[0].eq {
	pc = 0x824088E0; continue 'dispatch;
	}
	// 824088D0: 817E3804  lwz r11, 0x3804(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14340 as u32) ) } as u64;
	// 824088D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824088D8: 4E800421  bctrl
	ctx.lr = 0x824088DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824088DC: 93BF1C44  stw r29, 0x1c44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(7236 as u32), ctx.r[29].u32 ) };
            }
            0x824088E0 => {
    //   block [0x824088E0..0x824088FC)
	// 824088E0: 807F1C40  lwz r3, 0x1c40(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7232 as u32) ) } as u64;
	// 824088E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 824088E8: 41820014  beq 0x824088fc
	if ctx.cr[0].eq {
	pc = 0x824088FC; continue 'dispatch;
	}
	// 824088EC: 817E3804  lwz r11, 0x3804(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14340 as u32) ) } as u64;
	// 824088F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824088F4: 4E800421  bctrl
	ctx.lr = 0x824088F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824088F8: 93BF1C40  stw r29, 0x1c40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(7232 as u32), ctx.r[29].u32 ) };
            }
            0x824088FC => {
    //   block [0x824088FC..0x82408918)
	// 824088FC: 807F1C3C  lwz r3, 0x1c3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7228 as u32) ) } as u64;
	// 82408900: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82408904: 41820014  beq 0x82408918
	if ctx.cr[0].eq {
	pc = 0x82408918; continue 'dispatch;
	}
	// 82408908: 817E3804  lwz r11, 0x3804(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14340 as u32) ) } as u64;
	// 8240890C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82408910: 4E800421  bctrl
	ctx.lr = 0x82408914;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82408914: 93BF1C3C  stw r29, 0x1c3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(7228 as u32), ctx.r[29].u32 ) };
            }
            0x82408918 => {
    //   block [0x82408918..0x82408934)
	// 82408918: 807F1C38  lwz r3, 0x1c38(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7224 as u32) ) } as u64;
	// 8240891C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82408920: 41820014  beq 0x82408934
	if ctx.cr[0].eq {
	pc = 0x82408934; continue 'dispatch;
	}
	// 82408924: 817E3804  lwz r11, 0x3804(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(14340 as u32) ) } as u64;
	// 82408928: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8240892C: 4E800421  bctrl
	ctx.lr = 0x82408930;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82408930: 93BF1C38  stw r29, 0x1c38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(7224 as u32), ctx.r[29].u32 ) };
            }
            0x82408934 => {
    //   block [0x82408934..0x8240893C)
	// 82408934: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82408938: 4812C7D4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82408940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82408940 size=228
    let mut pc: u32 = 0x82408940;
    'dispatch: loop {
        match pc {
            0x82408940 => {
    //   block [0x82408940..0x82408988)
	// 82408940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82408944: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82408948: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8240894C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82408950: 9421FD90  stwu r1, -0x270(r1)
	ea = ctx.r[1].u32.wrapping_add(-624 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82408954: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82408958: 4BFFEC41  bl 0x82407598
	ctx.lr = 0x8240895C;
	sub_82407598(ctx, base);
	// 8240895C: 817F1C4C  lwz r11, 0x1c4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7244 as u32) ) } as u64;
	// 82408960: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 82408964: 387F1C18  addi r3, r31, 0x1c18
	ctx.r[3].s64 = ctx.r[31].s64 + 7192;
	// 82408968: 388B001C  addi r4, r11, 0x1c
	ctx.r[4].s64 = ctx.r[11].s64 + 28;
	// 8240896C: 4BFB8295  bl 0x823c0c00
	ctx.lr = 0x82408970;
	sub_823C0C00(ctx, base);
	// 82408970: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82408974: 4BFFFBD5  bl 0x82408548
	ctx.lr = 0x82408978;
	sub_82408548(ctx, base);
	// 82408978: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8240897C: 4182001C  beq 0x82408998
	if ctx.cr[0].eq {
	pc = 0x82408998; continue 'dispatch;
	}
	// 82408980: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82408984: 386BCCB0  addi r3, r11, -0x3350
	ctx.r[3].s64 = ctx.r[11].s64 + -13136;
	pc = 0x82408988; continue 'dispatch;
            }
            0x82408988 => {
    //   block [0x82408988..0x82408998)
	// 82408988: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8240898C: 4BEAA5F5  bl 0x822b2f80
	ctx.lr = 0x82408990;
	sub_822B2F80(ctx, base);
	// 82408990: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82408994: 48000078  b 0x82408a0c
	pc = 0x82408A0C; continue 'dispatch;
            }
            0x82408998 => {
    //   block [0x82408998..0x824089A4)
	// 82408998: 813F1C4C  lwz r9, 0x1c4c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7244 as u32) ) } as u64;
	// 8240899C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824089A0: 3949067C  addi r10, r9, 0x67c
	ctx.r[10].s64 = ctx.r[9].s64 + 1660;
	pc = 0x824089A4; continue 'dispatch;
            }
            0x824089A4 => {
    //   block [0x824089A4..0x824089F4)
	// 824089A4: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 824089A8: 38E10150  addi r7, r1, 0x150
	ctx.r[7].s64 = ctx.r[1].s64 + 336;
	// 824089AC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 824089B0: 7D0B392E  stwx r8, r11, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32), ctx.r[8].u32) };
	// 824089B4: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824089B8: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 824089BC: 7D0B312E  stwx r8, r11, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[6].u32), ctx.r[8].u32) };
	// 824089C0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824089C4: 2F0B0100  cmpwi cr6, r11, 0x100
	ctx.cr[6].compare_i32(ctx.r[11].s32, 256, &mut ctx.xer);
	// 824089C8: 4198FFDC  blt cr6, 0x824089a4
	if ctx.cr[6].lt {
	pc = 0x824089A4; continue 'dispatch;
	}
	// 824089CC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824089D0: 80C9000C  lwz r6, 0xc(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 824089D4: 38810150  addi r4, r1, 0x150
	ctx.r[4].s64 = ctx.r[1].s64 + 336;
	// 824089D8: 807F1C3C  lwz r3, 0x1c3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7228 as u32) ) } as u64;
	// 824089DC: 48002C8D  bl 0x8240b668
	ctx.lr = 0x824089E0;
	sub_8240B668(ctx, base);
	// 824089E0: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 824089E4: 41820010  beq 0x824089f4
	if ctx.cr[0].eq {
	pc = 0x824089F4; continue 'dispatch;
	}
	// 824089E8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824089EC: 386BCC70  addi r3, r11, -0x3390
	ctx.r[3].s64 = ctx.r[11].s64 + -13200;
	// 824089F0: 4BFFFF98  b 0x82408988
	pc = 0x82408988; continue 'dispatch;
            }
            0x824089F4 => {
    //   block [0x824089F4..0x82408A0C)
	// 824089F4: 817F1C4C  lwz r11, 0x1c4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7244 as u32) ) } as u64;
	// 824089F8: 807F1C44  lwz r3, 0x1c44(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7236 as u32) ) } as u64;
	// 824089FC: 388B0BBC  addi r4, r11, 0xbbc
	ctx.r[4].s64 = ctx.r[11].s64 + 3004;
	// 82408A00: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82408A04: 4BEE89CD  bl 0x822f13d0
	ctx.lr = 0x82408A08;
	sub_822F13D0(ctx, base);
	// 82408A08: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82408A0C; continue 'dispatch;
            }
            0x82408A0C => {
    //   block [0x82408A0C..0x82408A24)
	// 82408A0C: 38210270  addi r1, r1, 0x270
	ctx.r[1].s64 = ctx.r[1].s64 + 624;
	// 82408A10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82408A14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82408A18: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82408A1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82408A20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82408A28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82408A28 size=92
    let mut pc: u32 = 0x82408A28;
    'dispatch: loop {
        match pc {
            0x82408A28 => {
    //   block [0x82408A28..0x82408A64)
	// 82408A28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82408A2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82408A30: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82408A34: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82408A38: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82408A3C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82408A40: 40980024  bge cr6, 0x82408a64
	if !ctx.cr[6].lt {
	pc = 0x82408A64; continue 'dispatch;
	}
	// 82408A44: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82408A48: D8210018  stfd f1, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.f[1].u64 ) };
	// 82408A4C: E8810018  ld r4, 0x18(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(24 as u32) ) };
	// 82408A50: 386BCCF4  addi r3, r11, -0x330c
	ctx.r[3].s64 = ctx.r[11].s64 + -13068;
	// 82408A54: 4BEAA52D  bl 0x822b2f80
	ctx.lr = 0x82408A58;
	sub_822B2F80(ctx, base);
	// 82408A58: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82408A5C: 6063002A  ori r3, r3, 0x2a
	ctx.r[3].u64 = ctx.r[3].u64 | 42;
	// 82408A60: 48000014  b 0x82408a74
	pc = 0x82408A74; continue 'dispatch;
            }
            0x82408A64 => {
    //   block [0x82408A64..0x82408A74)
	// 82408A64: 4BFFFA3D  bl 0x824084a0
	ctx.lr = 0x82408A68;
	sub_824084A0(ctx, base);
	// 82408A68: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82408A6C: 4BFFE7ED  bl 0x82407258
	ctx.lr = 0x82408A70;
	sub_82407258(ctx, base);
	// 82408A70: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82408A74; continue 'dispatch;
            }
            0x82408A74 => {
    //   block [0x82408A74..0x82408A84)
	// 82408A74: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82408A78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82408A7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82408A80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82408A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82408A88 size=344
    let mut pc: u32 = 0x82408A88;
    'dispatch: loop {
        match pc {
            0x82408A88 => {
    //   block [0x82408A88..0x82408AF4)
	// 82408A88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82408A8C: 4812C61D  bl 0x825350a8
	ctx.lr = 0x82408A90;
	sub_82535080(ctx, base);
	// 82408A90: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 82408A94: 4812D555  bl 0x82535fe8
	ctx.lr = 0x82408A98;
	sub_82535FB0(ctx, base);
	// 82408A98: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82408A9C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82408AA0: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 82408AA4: 3D400008  lis r10, 8
	ctx.r[10].s64 = 524288;
	// 82408AA8: FF801090  fmr f28, f2
	ctx.f[28].f64 = ctx.f[2].f64;
	// 82408AAC: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82408AB0: 615E030C  ori r30, r10, 0x30c
	ctx.r[30].u64 = ctx.r[10].u64 | 780;
	// 82408AB4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82408AB8: 817C1C38  lwz r11, 0x1c38(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7224 as u32) ) } as u64;
	// 82408ABC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82408AC0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82408AC4: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82408AC8: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 82408ACC: 7D184378  mr r24, r8
	ctx.r[24].u64 = ctx.r[8].u64;
	// 82408AD0: 4BFFE139  bl 0x82406c08
	ctx.lr = 0x82408AD4;
	sub_82406C08(ctx, base);
	// 82408AD4: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82408AD8: 4082001C  bne 0x82408af4
	if !ctx.cr[0].eq {
	pc = 0x82408AF4; continue 'dispatch;
	}
	// 82408ADC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82408AE0: 386BCD30  addi r3, r11, -0x32d0
	ctx.r[3].s64 = ctx.r[11].s64 + -13008;
	// 82408AE4: 4BEAA49D  bl 0x822b2f80
	ctx.lr = 0x82408AE8;
	sub_822B2F80(ctx, base);
	// 82408AE8: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82408AEC: 6063000F  ori r3, r3, 0xf
	ctx.r[3].u64 = ctx.r[3].u64 | 15;
	// 82408AF0: 480000E0  b 0x82408bd0
	pc = 0x82408BD0; continue 'dispatch;
            }
            0x82408AF4 => {
    //   block [0x82408AF4..0x82408B10)
	// 82408AF4: 817D001C  lwz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82408AF8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82408AFC: 41990014  bgt cr6, 0x82408b10
	if ctx.cr[6].gt {
	pc = 0x82408B10; continue 'dispatch;
	}
	// 82408B00: 2F180000  cmpwi cr6, r24, 0
	ctx.cr[6].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 82408B04: 4098000C  bge cr6, 0x82408b10
	if !ctx.cr[6].lt {
	pc = 0x82408B10; continue 'dispatch;
	}
	// 82408B08: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82408B0C: 480000C4  b 0x82408bd0
	pc = 0x82408BD0; continue 'dispatch;
            }
            0x82408B10 => {
    //   block [0x82408B10..0x82408B9C)
	// 82408B10: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82408B14: 815C1C38  lwz r10, 0x1c38(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7224 as u32) ) } as u64;
	// 82408B18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82408B1C: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 82408B20: 7C6AF214  add r3, r10, r30
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82408B24: C3EB1850  lfs f31, 0x1850(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82408B28: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82408B2C: D3E100C0  stfs f31, 0xc0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82408B30: D3E100D0  stfs f31, 0xd0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82408B34: D3E100D4  stfs f31, 0xd4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82408B38: C3CB1FF8  lfs f30, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82408B3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82408B40: D3C100C4  stfs f30, 0xc4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82408B44: D3C100CC  stfs f30, 0xcc(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82408B48: 916100C8  stw r11, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 82408B4C: 8161019C  lwz r11, 0x19c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(412 as u32) ) } as u64;
	// 82408B50: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82408B54: 4BFFDEDD  bl 0x82406a30
	ctx.lr = 0x82408B58;
	sub_82406A30(ctx, base);
	// 82408B58: 816101A4  lwz r11, 0x1a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(420 as u32) ) } as u64;
	// 82408B5C: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 82408B60: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 82408B64: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82408B68: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 82408B6C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82408B70: 93210068  stw r25, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[25].u32 ) };
	// 82408B74: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82408B78: 409A0024  bne cr6, 0x82408b9c
	if !ctx.cr[6].eq {
	pc = 0x82408B9C; continue 'dispatch;
	}
	// 82408B7C: 38A00034  li r5, 0x34
	ctx.r[5].s64 = 52;
	// 82408B80: 808101AC  lwz r4, 0x1ac(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(428 as u32) ) } as u64;
	// 82408B84: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82408B88: 4BFB8079  bl 0x823c0c00
	ctx.lr = 0x82408B8C;
	sub_823C0C00(ctx, base);
	// 82408B8C: 38A0001C  li r5, 0x1c
	ctx.r[5].s64 = 28;
	// 82408B90: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 82408B94: 808101B4  lwz r4, 0x1b4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82408B98: 4BFB8069  bl 0x823c0c00
	ctx.lr = 0x82408B9C;
	sub_823C0C00(ctx, base);
	pc = 0x82408B9C; continue 'dispatch;
            }
            0x82408B9C => {
    //   block [0x82408B9C..0x82408BD0)
	// 82408B9C: 81610194  lwz r11, 0x194(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(404 as u32) ) } as u64;
	// 82408BA0: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 82408BA4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82408BA8: D3A100C0  stfs f29, 0xc0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82408BAC: D38100C4  stfs f28, 0xc4(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82408BB0: 807C1C50  lwz r3, 0x1c50(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(7248 as u32) ) } as u64;
	// 82408BB4: D3C100CC  stfs f30, 0xcc(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82408BB8: D3E100D4  stfs f31, 0xd4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82408BBC: D3E100D0  stfs f31, 0xd0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82408BC0: 916100C8  stw r11, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 82408BC4: 80BD001C  lwz r5, 0x1c(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82408BC8: 48005BC9  bl 0x8240e790
	ctx.lr = 0x82408BCC;
	sub_8240E790(ctx, base);
	// 82408BCC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82408BD0; continue 'dispatch;
            }
            0x82408BD0 => {
    //   block [0x82408BD0..0x82408BE0)
	// 82408BD0: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 82408BD4: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 82408BD8: 4812D45D  bl 0x82536034
	ctx.lr = 0x82408BDC;
	sub_82535FFC(ctx, base);
	// 82408BDC: 4812C51C  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82408BE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82408BE0 size=1476
    let mut pc: u32 = 0x82408BE0;
    'dispatch: loop {
        match pc {
            0x82408BE0 => {
    //   block [0x82408BE0..0x82408C54)
	// 82408BE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82408BE4: 4812C4A1  bl 0x82535084
	ctx.lr = 0x82408BE8;
	sub_82535080(ctx, base);
	// 82408BE8: 3981FF70  addi r12, r1, -0x90
	ctx.r[12].s64 = ctx.r[1].s64 + -144;
	// 82408BEC: 4812D3E1  bl 0x82535fcc
	ctx.lr = 0x82408BF0;
	sub_82535FB0(ctx, base);
	// 82408BF0: 9421FAF0  stwu r1, -0x510(r1)
	ea = ctx.r[1].u32.wrapping_add(-1296 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82408BF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82408BF8: FEA00890  fmr f21, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[21].f64 = ctx.f[1].f64;
	// 82408BFC: 7D4F5378  mr r15, r10
	ctx.r[15].u64 = ctx.r[10].u64;
	// 82408C00: FEE01090  fmr f23, f2
	ctx.f[23].f64 = ctx.f[2].f64;
	// 82408C04: 3D400008  lis r10, 8
	ctx.r[10].s64 = 524288;
	// 82408C08: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82408C0C: 615E030C  ori r30, r10, 0x30c
	ctx.r[30].u64 = ctx.r[10].u64 | 780;
	// 82408C10: 817F1C38  lwz r11, 0x1c38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7224 as u32) ) } as u64;
	// 82408C14: 7CB02B78  mr r16, r5
	ctx.r[16].u64 = ctx.r[5].u64;
	// 82408C18: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82408C1C: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82408C20: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82408C24: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 82408C28: 4BFFDFE1  bl 0x82406c08
	ctx.lr = 0x82408C2C;
	sub_82406C08(ctx, base);
	// 82408C2C: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82408C30: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82408C34: 40820020  bne 0x82408c54
	if !ctx.cr[0].eq {
	pc = 0x82408C54; continue 'dispatch;
	}
	// 82408C38: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82408C3C: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 82408C40: 386BCDB8  addi r3, r11, -0x3248
	ctx.r[3].s64 = ctx.r[11].s64 + -12872;
	// 82408C44: 4BEAA33D  bl 0x822b2f80
	ctx.lr = 0x82408C48;
	sub_822B2F80(ctx, base);
	// 82408C48: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82408C4C: 6063000F  ori r3, r3, 0xf
	ctx.r[3].u64 = ctx.r[3].u64 | 15;
	// 82408C50: 48000544  b 0x82409194
	pc = 0x82409194; continue 'dispatch;
            }
            0x82408C54 => {
    //   block [0x82408C54..0x82408D3C)
	// 82408C54: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82408C58: 815F1C38  lwz r10, 0x1c38(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7224 as u32) ) } as u64;
	// 82408C5C: 3A600000  li r19, 0
	ctx.r[19].s64 = 0;
	// 82408C60: 7C6AF214  add r3, r10, r30
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82408C64: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82408C68: C2CB1850  lfs f22, 0x1850(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 82408C6C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82408C70: D2C101AC  stfs f22, 0x1ac(r1)
	tmp.f32 = (ctx.f[22].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(428 as u32), tmp.u32 ) };
	// 82408C74: 926101B4  stw r19, 0x1b4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(436 as u32), ctx.r[19].u32 ) };
	// 82408C78: D2C101BC  stfs f22, 0x1bc(r1)
	tmp.f32 = (ctx.f[22].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(444 as u32), tmp.u32 ) };
	// 82408C7C: D2C101C0  stfs f22, 0x1c0(r1)
	tmp.f32 = (ctx.f[22].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(448 as u32), tmp.u32 ) };
	// 82408C80: C38B1FF8  lfs f28, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82408C84: D38101B0  stfs f28, 0x1b0(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(432 as u32), tmp.u32 ) };
	// 82408C88: D38101B8  stfs f28, 0x1b8(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(440 as u32), tmp.u32 ) };
	// 82408C8C: 4BFFDFBD  bl 0x82406c48
	ctx.lr = 0x82408C90;
	sub_82406C48(ctx, base);
	// 82408C90: 817F1C38  lwz r11, 0x1c38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7224 as u32) ) } as u64;
	// 82408C94: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82408C98: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82408C9C: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82408CA0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82408CA4: 4BFFDEFD  bl 0x82406ba0
	ctx.lr = 0x82408CA8;
	sub_82406BA0(ctx, base);
	// 82408CA8: 817F1C38  lwz r11, 0x1c38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7224 as u32) ) } as u64;
	// 82408CAC: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82408CB0: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82408CB4: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82408CB8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82408CBC: 4BFFDFC5  bl 0x82406c80
	ctx.lr = 0x82408CC0;
	sub_82406C80(ctx, base);
	// 82408CC0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82408CC4: 807B000C  lwz r3, 0xc(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 82408CC8: 48006D09  bl 0x8240f9d0
	ctx.lr = 0x82408CCC;
	sub_8240F9D0(ctx, base);
	// 82408CCC: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82408CD0: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 82408CD4: 807F1C40  lwz r3, 0x1c40(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7232 as u32) ) } as u64;
	// 82408CD8: 48006B89  bl 0x8240f860
	ctx.lr = 0x82408CDC;
	sub_8240F860(ctx, base);
	// 82408CDC: 82E1056C  lwz r23, 0x56c(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1388 as u32) ) } as u64;
	// 82408CE0: 8221057C  lwz r17, 0x57c(r1)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1404 as u32) ) } as u64;
	// 82408CE4: FF400890  fmr f26, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[26].f64 = ctx.f[1].f64;
	// 82408CE8: 82410574  lwz r18, 0x574(r1)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1396 as u32) ) } as u64;
	// 82408CEC: 2B170001  cmplwi cr6, r23, 1
	ctx.cr[6].compare_u32(ctx.r[23].u32, 1 as u32, &mut ctx.xer);
	// 82408CF0: 409A006C  bne cr6, 0x82408d5c
	if !ctx.cr[6].eq {
	pc = 0x82408D5C; continue 'dispatch;
	}
	// 82408CF4: 394101D0  addi r10, r1, 0x1d0
	ctx.r[10].s64 = ctx.r[1].s64 + 464;
	// 82408CF8: C07C0020  lfs f3, 0x20(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82408CFC: 7E258B78  mr r5, r17
	ctx.r[5].u64 = ctx.r[17].u64;
	// 82408D00: C03C0014  lfs f1, 0x14(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82408D04: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 82408D08: 80DC0024  lwz r6, 0x24(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 82408D0C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82408D10: FC40D090  fmr f2, f26
	ctx.f[2].f64 = ctx.f[26].f64;
	// 82408D14: 4BFFD70D  bl 0x82406420
	ctx.lr = 0x82408D18;
	sub_82406420(ctx, base);
	// 82408D18: 7C651B79  or. r5, r3, r3
	ctx.r[5].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82408D1C: 41820020  beq 0x82408d3c
	if ctx.cr[0].eq {
	pc = 0x82408D3C; continue 'dispatch;
	}
	// 82408D20: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82408D24: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82408D28: 386BCD70  addi r3, r11, -0x3290
	ctx.r[3].s64 = ctx.r[11].s64 + -12944;
	// 82408D2C: 4BEAA255  bl 0x822b2f80
	ctx.lr = 0x82408D30;
	sub_822B2F80(ctx, base);
	// 82408D30: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82408D34: 6063002D  ori r3, r3, 0x2d
	ctx.r[3].u64 = ctx.r[3].u64 | 45;
	// 82408D38: 4800045C  b 0x82409194
	pc = 0x82409194; continue 'dispatch;
            }
            0x82408D3C => {
    //   block [0x82408D3C..0x82408D5C)
	// 82408D3C: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 82408D40: 807F1C3C  lwz r3, 0x1c3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7228 as u32) ) } as u64;
	// 82408D44: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82408D48: C021026C  lfs f1, 0x26c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(620 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82408D4C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82408D50: 80810564  lwz r4, 0x564(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1380 as u32) ) } as u64;
	// 82408D54: 48002FDD  bl 0x8240bd30
	ctx.lr = 0x82408D58;
	sub_8240BD30(ctx, base);
	// 82408D58: 4800001C  b 0x82408d74
	pc = 0x82408D74; continue 'dispatch;
            }
            0x82408D5C => {
    //   block [0x82408D5C..0x82408D74)
	// 82408D5C: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 82408D60: 807F1C3C  lwz r3, 0x1c3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7228 as u32) ) } as u64;
	// 82408D64: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82408D68: 80810564  lwz r4, 0x564(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1380 as u32) ) } as u64;
	// 82408D6C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82408D70: 48002FB1  bl 0x8240bd20
	ctx.lr = 0x82408D74;
	sub_8240BD20(ctx, base);
	pc = 0x82408D74; continue 'dispatch;
            }
            0x82408D74 => {
    //   block [0x82408D74..0x82408D84)
	// 82408D74: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82408D78: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 82408D7C: 40980008  bge cr6, 0x82408d84
	if !ctx.cr[6].lt {
	pc = 0x82408D84; continue 'dispatch;
	}
	// 82408D80: 48000414  b 0x82409194
	pc = 0x82409194; continue 'dispatch;
            }
            0x82408D84 => {
    //   block [0x82408D84..0x82408EA0)
	// 82408D84: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82408D88: 807F1C3C  lwz r3, 0x1c3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7228 as u32) ) } as u64;
	// 82408D8C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82408D90: 480025D1  bl 0x8240b360
	ctx.lr = 0x82408D94;
	sub_8240B360(ctx, base);
	// 82408D94: 38810280  addi r4, r1, 0x280
	ctx.r[4].s64 = ctx.r[1].s64 + 640;
	// 82408D98: 82BB000C  lwz r21, 0xc(r27)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 82408D9C: 829B0020  lwz r20, 0x20(r27)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 82408DA0: 837B0024  lwz r27, 0x24(r27)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(36 as u32) ) } as u64;
	// 82408DA4: 807C0030  lwz r3, 0x30(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) } as u64;
	// 82408DA8: 4BFFE4F1  bl 0x82407298
	ctx.lr = 0x82408DAC;
	sub_82407298(ctx, base);
	// 82408DAC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82408DB0: 408203E4  bne 0x82409194
	if !ctx.cr[0].eq {
	pc = 0x82409194; continue 'dispatch;
	}
	// 82408DB4: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82408DB8: 807F1C40  lwz r3, 0x1c40(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7232 as u32) ) } as u64;
	// 82408DBC: 4800695D  bl 0x8240f718
	ctx.lr = 0x82408DC0;
	sub_8240F718(ctx, base);
	// 82408DC0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82408DC4: FF600890  fmr f27, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[27].f64 = ctx.f[1].f64;
	// 82408DC8: 4BFFE5E1  bl 0x824073a8
	ctx.lr = 0x82408DCC;
	sub_824073A8(ctx, base);
	// 82408DCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82408DD0: 4BFFF679  bl 0x82408448
	ctx.lr = 0x82408DD4;
	sub_82408448(ctx, base);
	// 82408DD4: FF01E000  fcmpu cr6, f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[28].f64);
	// 82408DD8: 409900FC  ble cr6, 0x82408ed4
	if !ctx.cr[6].gt {
	pc = 0x82408ED4; continue 'dispatch;
	}
	// 82408DDC: C01F1C1C  lfs f0, 0x1c1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82408DE0: C1A10280  lfs f13, 0x280(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(640 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82408DE4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82408DE8: 409900EC  ble cr6, 0x82408ed4
	if !ctx.cr[6].gt {
	pc = 0x82408ED4; continue 'dispatch;
	}
	// 82408DEC: FF15E000  fcmpu cr6, f21, f28
	ctx.cr[6].compare_f64(ctx.f[21].f64, ctx.f[28].f64);
	// 82408DF0: 409900E4  ble cr6, 0x82408ed4
	if !ctx.cr[6].gt {
	pc = 0x82408ED4; continue 'dispatch;
	}
	// 82408DF4: 807C0030  lwz r3, 0x30(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) } as u64;
	// 82408DF8: 4BFFE1B9  bl 0x82406fb0
	ctx.lr = 0x82408DFC;
	sub_82406FB0(ctx, base);
	// 82408DFC: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82408E00: 419A00D4  beq cr6, 0x82408ed4
	if ctx.cr[6].eq {
	pc = 0x82408ED4; continue 'dispatch;
	}
	// 82408E04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82408E08: FC20A890  fmr f1, f21
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[21].f64;
	// 82408E0C: 4BFFF695  bl 0x824084a0
	ctx.lr = 0x82408E10;
	sub_824084A0(ctx, base);
	// 82408E10: FC400890  fmr f2, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[1].f64;
	// 82408E14: C0BF1C24  lfs f5, 0x1c24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7204 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82408E18: 807F1C40  lwz r3, 0x1c40(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7232 as u32) ) } as u64;
	// 82408E1C: C09C0064  lfs f4, 0x64(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(100 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82408E20: FC20D890  fmr f1, f27
	ctx.f[1].f64 = ctx.f[27].f64;
	// 82408E24: C0610280  lfs f3, 0x280(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(640 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82408E28: 480065F1  bl 0x8240f418
	ctx.lr = 0x82408E2C;
	sub_8240F418(ctx, base);
	// 82408E2C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82408E30: 2B170001  cmplwi cr6, r23, 1
	ctx.cr[6].compare_u32(ctx.r[23].u32, 1 as u32, &mut ctx.xer);
	// 82408E34: 409A006C  bne cr6, 0x82408ea0
	if !ctx.cr[6].eq {
	pc = 0x82408EA0; continue 'dispatch;
	}
	// 82408E38: 817F1C4C  lwz r11, 0x1c4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7244 as u32) ) } as u64;
	// 82408E3C: C0210274  lfs f1, 0x274(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(628 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82408E40: 83D20030  lwz r30, 0x30(r18)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(48 as u32) ) } as u64;
	// 82408E44: 3BAB0CBC  addi r29, r11, 0xcbc
	ctx.r[29].s64 = ctx.r[11].s64 + 3260;
	// 82408E48: 480056C9  bl 0x8240e510
	ctx.lr = 0x82408E4C;
	sub_8240E510(ctx, base);
	// 82408E4C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82408E50: EFE1F82A  fadds f31, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ((ctx.f[1].f64 + ctx.f[31].f64) as f32) as f64;
	// 82408E54: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82408E58: 409A0048  bne cr6, 0x82408ea0
	if !ctx.cr[6].eq {
	pc = 0x82408EA0; continue 'dispatch;
	}
	// 82408E5C: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82408E60: 41980040  blt cr6, 0x82408ea0
	if ctx.cr[6].lt {
	pc = 0x82408EA0; continue 'dispatch;
	}
	// 82408E64: 817F1C4C  lwz r11, 0x1c4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7244 as u32) ) } as u64;
	// 82408E68: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82408E6C: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82408E70: 40980030  bge cr6, 0x82408ea0
	if !ctx.cr[6].lt {
	pc = 0x82408EA0; continue 'dispatch;
	}
	// 82408E74: 57CB2834  slwi r11, r30, 5
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82408E78: 807F1C48  lwz r3, 0x1c48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7240 as u32) ) } as u64;
	// 82408E7C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82408E80: C0210278  lfs f1, 0x278(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(632 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82408E84: 7CABEA14  add r5, r11, r29
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82408E88: C045001C  lfs f2, 0x1c(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(28 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82408E8C: 48006A45  bl 0x8240f8d0
	ctx.lr = 0x82408E90;
	sub_8240F8D0(ctx, base);
	// 82408E90: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82408E94: 4082000C  bne 0x82408ea0
	if !ctx.cr[0].eq {
	pc = 0x82408EA0; continue 'dispatch;
	}
	// 82408E98: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82408E9C: EFE0F82A  fadds f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	pc = 0x82408EA0; continue 'dispatch;
            }
            0x82408EA0 => {
    //   block [0x82408EA0..0x82408ED4)
	// 82408EA0: C01F1C18  lfs f0, 0x1c18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82408EA4: EFDF0028  fsubs f30, f31, f0
	ctx.f[30].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82408EA8: C1A10280  lfs f13, 0x280(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(640 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82408EAC: EFBF6828  fsubs f29, f31, f13
	ctx.f[29].f64 = (((ctx.f[31].f64 - ctx.f[13].f64) as f32) as f64);
	// 82408EB0: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82408EB4: 480056A5  bl 0x8240e558
	ctx.lr = 0x82408EB8;
	sub_8240E558(ctx, base);
	// 82408EB8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82408EBC: 809C0050  lwz r4, 0x50(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(80 as u32) ) } as u64;
	// 82408EC0: 807F1C40  lwz r3, 0x1c40(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7232 as u32) ) } as u64;
	// 82408EC4: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82408EC8: 480065F9  bl 0x8240f4c0
	ctx.lr = 0x82408ECC;
	sub_8240F4C0(ctx, base);
	// 82408ECC: EF2107F2  fmuls f25, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[25].f64 = (((ctx.f[1].f64 * ctx.f[31].f64) as f32) as f64);
	// 82408ED0: 48000010  b 0x82408ee0
	pc = 0x82408EE0; continue 'dispatch;
            }
            0x82408ED4 => {
    //   block [0x82408ED4..0x82408EE0)
	// 82408ED4: C3DF1C1C  lfs f30, 0x1c1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7196 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82408ED8: FF20E090  fmr f25, f28
	ctx.f[25].f64 = ctx.f[28].f64;
	// 82408EDC: FFA0F090  fmr f29, f30
	ctx.f[29].f64 = ctx.f[30].f64;
	pc = 0x82408EE0; continue 'dispatch;
            }
            0x82408EE0 => {
    //   block [0x82408EE0..0x82408F10)
	// 82408EE0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82408EE4: 807F1C40  lwz r3, 0x1c40(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7232 as u32) ) } as u64;
	// 82408EE8: D361007C  stfs f27, 0x7c(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82408EEC: D3A100A0  stfs f29, 0xa0(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82408EF0: 48006879  bl 0x8240f768
	ctx.lr = 0x82408EF4;
	sub_8240F768(ctx, base);
	// 82408EF4: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82408EF8: 2B170001  cmplwi cr6, r23, 1
	ctx.cr[6].compare_u32(ctx.r[23].u32, 1 as u32, &mut ctx.xer);
	// 82408EFC: FC40E090  fmr f2, f28
	ctx.f[2].f64 = ctx.f[28].f64;
	// 82408F00: 409A0010  bne cr6, 0x82408f10
	if !ctx.cr[6].eq {
	pc = 0x82408F10; continue 'dispatch;
	}
	// 82408F04: C0210270  lfs f1, 0x270(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(624 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82408F08: 48005759  bl 0x8240e660
	ctx.lr = 0x82408F0C;
	sub_8240E660(ctx, base);
	// 82408F0C: FC400890  fmr f2, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[1].f64;
	pc = 0x82408F10; continue 'dispatch;
            }
            0x82408F10 => {
    //   block [0x82408F10..0x82408F40)
	// 82408F10: 7DE57B78  mr r5, r15
	ctx.r[5].u64 = ctx.r[15].u64;
	// 82408F14: 80C10288  lwz r6, 0x288(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(648 as u32) ) } as u64;
	// 82408F18: C07C0078  lfs f3, 0x78(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(120 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82408F1C: 807F1C40  lwz r3, 0x1c40(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7232 as u32) ) } as u64;
	// 82408F20: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82408F24: 4800650D  bl 0x8240f430
	ctx.lr = 0x82408F28;
	sub_8240F430(ctx, base);
	// 82408F28: D3E10084  stfs f31, 0x84(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82408F2C: FF000890  fmr f24, f1
	ctx.f[24].f64 = ctx.f[1].f64;
	// 82408F30: 2B170001  cmplwi cr6, r23, 1
	ctx.cr[6].compare_u32(ctx.r[23].u32, 1 as u32, &mut ctx.xer);
	// 82408F34: 409A0060  bne cr6, 0x82408f94
	if !ctx.cr[6].eq {
	pc = 0x82408F94; continue 'dispatch;
	}
	// 82408F38: 3BC101DC  addi r30, r1, 0x1dc
	ctx.r[30].s64 = ctx.r[1].s64 + 476;
	// 82408F3C: 3BA00006  li r29, 6
	ctx.r[29].s64 = 6;
	pc = 0x82408F40; continue 'dispatch;
            }
            0x82408F40 => {
    //   block [0x82408F40..0x82408F94)
	// 82408F40: C03E0000  lfs f1, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82408F44: 480055CD  bl 0x8240e510
	ctx.lr = 0x82408F48;
	sub_8240E510(ctx, base);
	// 82408F48: C01C0008  lfs f0, 8(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82408F4C: EC00F02A  fadds f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82408F50: EC20082A  fadds f1, f0, f1
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	// 82408F54: 48005605  bl 0x8240e558
	ctx.lr = 0x82408F58;
	sub_8240E558(ctx, base);
	// 82408F58: D03E0000  stfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82408F5C: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82408F60: 3BDE0018  addi r30, r30, 0x18
	ctx.r[30].s64 = ctx.r[30].s64 + 24;
	// 82408F64: 4082FFDC  bne 0x82408f40
	if !ctx.cr[0].eq {
	pc = 0x82408F40; continue 'dispatch;
	}
	// 82408F68: 38A00090  li r5, 0x90
	ctx.r[5].s64 = 144;
	// 82408F6C: 388101D0  addi r4, r1, 0x1d0
	ctx.r[4].s64 = ctx.r[1].s64 + 464;
	// 82408F70: 38610390  addi r3, r1, 0x390
	ctx.r[3].s64 = ctx.r[1].s64 + 912;
	// 82408F74: 4812C065  bl 0x82534fd8
	ctx.lr = 0x82408F78;
	sub_82534FD8(ctx, base);
	// 82408F78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82408F7C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82408F80: 388101D0  addi r4, r1, 0x1d0
	ctx.r[4].s64 = ctx.r[1].s64 + 464;
	// 82408F84: 38A000AC  li r5, 0xac
	ctx.r[5].s64 = 172;
	// 82408F88: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 82408F8C: 4812BBC5  bl 0x82534b50
	ctx.lr = 0x82408F90;
	sub_82534B50(ctx, base);
	// 82408F90: 48000068  b 0x82408ff8
	pc = 0x82408FF8; continue 'dispatch;
            }
            0x82408F94 => {
    //   block [0x82408F94..0x82408FF8)
	// 82408F94: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82408F98: 807F1C40  lwz r3, 0x1c40(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7232 as u32) ) } as u64;
	// 82408F9C: 48006875  bl 0x8240f810
	ctx.lr = 0x82408FA0;
	sub_8240F810(ctx, base);
	// 82408FA0: 807F1C40  lwz r3, 0x1c40(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7232 as u32) ) } as u64;
	// 82408FA4: C0610284  lfs f3, 0x284(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(644 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82408FA8: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82408FAC: FC40B890  fmr f2, f23
	ctx.f[2].f64 = ctx.f[23].f64;
	// 82408FB0: 48006501  bl 0x8240f4b0
	ctx.lr = 0x82408FB4;
	sub_8240F4B0(ctx, base);
	// 82408FB4: C01C0008  lfs f0, 8(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82408FB8: FFA00890  fmr f29, f1
	ctx.f[29].f64 = ctx.f[1].f64;
	// 82408FBC: EC20F02A  fadds f1, f0, f30
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82408FC0: 48005599  bl 0x8240e558
	ctx.lr = 0x82408FC4;
	sub_8240E558(ctx, base);
	// 82408FC4: 39210390  addi r9, r1, 0x390
	ctx.r[9].s64 = ctx.r[1].s64 + 912;
	// 82408FC8: FCA00890  fmr f5, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[5].f64 = ctx.f[1].f64;
	// 82408FCC: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82408FD0: C09C0020  lfs f4, 0x20(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82408FD4: C05C0014  lfs f2, 0x14(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82408FD8: FC60D090  fmr f3, f26
	ctx.f[3].f64 = ctx.f[26].f64;
	// 82408FDC: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82408FE0: 4BFFD349  bl 0x82406328
	ctx.lr = 0x82408FE4;
	sub_82406328(ctx, base);
	// 82408FE4: D3E10080  stfs f31, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82408FE8: 92610094  stw r19, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[19].u32 ) };
	// 82408FEC: D3410088  stfs f26, 0x88(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82408FF0: C01C0020  lfs f0, 0x20(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82408FF4: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	pc = 0x82408FF8; continue 'dispatch;
            }
            0x82408FF8 => {
    //   block [0x82408FF8..0x82409040)
	// 82408FF8: 807C0038  lwz r3, 0x38(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) } as u64;
	// 82408FFC: 4BFFE3FD  bl 0x824073f8
	ctx.lr = 0x82409000;
	sub_824073F8(ctx, base);
	// 82409000: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82409004: C01F1C1C  lfs f0, 0x1c1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82409008: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 8240900C: 40990064  ble cr6, 0x82409070
	if !ctx.cr[6].gt {
	pc = 0x82409070; continue 'dispatch;
	}
	// 82409010: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 82409014: 4099005C  ble cr6, 0x82409070
	if !ctx.cr[6].gt {
	pc = 0x82409070; continue 'dispatch;
	}
	// 82409018: 807C0038  lwz r3, 0x38(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) } as u64;
	// 8240901C: 4BFFDFF5  bl 0x82407010
	ctx.lr = 0x82409020;
	sub_82407010(ctx, base);
	// 82409020: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82409024: 419A004C  beq cr6, 0x82409070
	if ctx.cr[6].eq {
	pc = 0x82409070; continue 'dispatch;
	}
	// 82409028: C01C003C  lfs f0, 0x3c(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8240902C: 2B170001  cmplwi cr6, r23, 1
	ctx.cr[6].compare_u32(ctx.r[23].u32, 1 as u32, &mut ctx.xer);
	// 82409030: EFE0F82A  fadds f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82409034: 409A000C  bne cr6, 0x82409040
	if !ctx.cr[6].eq {
	pc = 0x82409040; continue 'dispatch;
	}
	// 82409038: C0010260  lfs f0, 0x260(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(608 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8240903C: EFE0F82A  fadds f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	pc = 0x82409040; continue 'dispatch;
            }
            0x82409040 => {
    //   block [0x82409040..0x8240904C)
	// 82409040: FF1FE000  fcmpu cr6, f31, f28
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[28].f64);
	// 82409044: 40990008  ble cr6, 0x8240904c
	if !ctx.cr[6].gt {
	pc = 0x8240904C; continue 'dispatch;
	}
	// 82409048: FFE0E090  fmr f31, f28
	ctx.f[31].f64 = ctx.f[28].f64;
	pc = 0x8240904C; continue 'dispatch;
            }
            0x8240904C => {
    //   block [0x8240904C..0x82409068)
	// 8240904C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82409050: 48005509  bl 0x8240e558
	ctx.lr = 0x82409054;
	sub_8240E558(ctx, base);
	// 82409054: FF600890  fmr f27, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[27].f64 = ctx.f[1].f64;
	// 82409058: FF1EE000  fcmpu cr6, f30, f28
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[28].f64);
	// 8240905C: 4098000C  bge cr6, 0x82409068
	if !ctx.cr[6].lt {
	pc = 0x82409068; continue 'dispatch;
	}
	// 82409060: EC3FF02A  fadds f1, f31, f30
	ctx.f[1].f64 = ((ctx.f[31].f64 + ctx.f[30].f64) as f32) as f64;
	// 82409064: 48000014  b 0x82409078
	pc = 0x82409078; continue 'dispatch;
            }
            0x82409068 => {
    //   block [0x82409068..0x82409070)
	// 82409068: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8240906C: 4800000C  b 0x82409078
	pc = 0x82409078; continue 'dispatch;
            }
            0x82409070 => {
    //   block [0x82409070..0x82409078)
	// 82409070: FF60E090  fmr f27, f28
	ctx.f[27].f64 = ctx.f[28].f64;
	// 82409074: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	pc = 0x82409078; continue 'dispatch;
            }
            0x82409078 => {
    //   block [0x82409078..0x824090D0)
	// 82409078: 480054E1  bl 0x8240e558
	ctx.lr = 0x8240907C;
	sub_8240E558(ctx, base);
	// 8240907C: 817C004C  lwz r11, 0x4c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(76 as u32) ) } as u64;
	// 82409080: 83DC0038  lwz r30, 0x38(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) } as u64;
	// 82409084: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 82409088: D2A101AC  stfs f21, 0x1ac(r1)
	tmp.f32 = (ctx.f[21].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(428 as u32), tmp.u32 ) };
	// 8240908C: 2B170001  cmplwi cr6, r23, 1
	ctx.cr[6].compare_u32(ctx.r[23].u32, 1 as u32, &mut ctx.xer);
	// 82409090: D2E101B0  stfs f23, 0x1b0(r1)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(432 as u32), tmp.u32 ) };
	// 82409094: 92010064  stw r16, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[16].u32 ) };
	// 82409098: D38101B8  stfs f28, 0x1b8(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(440 as u32), tmp.u32 ) };
	// 8240909C: 557DFFFE  rlwinm r29, r11, 0x1f, 0x1f, 0x1f
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 824090A0: D2C101C0  stfs f22, 0x1c0(r1)
	tmp.f32 = (ctx.f[22].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(448 as u32), tmp.u32 ) };
	// 824090A4: 91E101B4  stw r15, 0x1b4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(436 as u32), ctx.r[15].u32 ) };
	// 824090A8: D2C101BC  stfs f22, 0x1bc(r1)
	tmp.f32 = (ctx.f[22].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(444 as u32), tmp.u32 ) };
	// 824090AC: 409A0024  bne cr6, 0x824090d0
	if !ctx.cr[6].eq {
	pc = 0x824090D0; continue 'dispatch;
	}
	// 824090B0: 38A00034  li r5, 0x34
	ctx.r[5].s64 = 52;
	// 824090B4: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 824090B8: 3861015C  addi r3, r1, 0x15c
	ctx.r[3].s64 = ctx.r[1].s64 + 348;
	// 824090BC: 4BFB7B45  bl 0x823c0c00
	ctx.lr = 0x824090C0;
	sub_823C0C00(ctx, base);
	// 824090C0: 38A0001C  li r5, 0x1c
	ctx.r[5].s64 = 28;
	// 824090C4: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 824090C8: 38610190  addi r3, r1, 0x190
	ctx.r[3].s64 = ctx.r[1].s64 + 400;
	// 824090CC: 4BFB7B35  bl 0x823c0c00
	ctx.lr = 0x824090D0;
	sub_823C0C00(ctx, base);
	pc = 0x824090D0; continue 'dispatch;
            }
            0x824090D0 => {
    //   block [0x824090D0..0x8240910C)
	// 824090D0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 824090D4: 807F1C3C  lwz r3, 0x1c3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7228 as u32) ) } as u64;
	// 824090D8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 824090DC: D321009C  stfs f25, 0x9c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 824090E0: D30100A4  stfs f24, 0xa4(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 824090E4: 92C10098  stw r22, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[22].u32 ) };
	// 824090E8: 48002221  bl 0x8240b308
	ctx.lr = 0x824090EC;
	sub_8240B308(ctx, base);
	// 824090EC: C3DC0028  lfs f30, 0x28(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 824090F0: C3FC002C  lfs f31, 0x2c(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 824090F4: 2B170001  cmplwi cr6, r23, 1
	ctx.cr[6].compare_u32(ctx.r[23].u32, 1 as u32, &mut ctx.xer);
	// 824090F8: 409A0024  bne cr6, 0x8240911c
	if !ctx.cr[6].eq {
	pc = 0x8240911C; continue 'dispatch;
	}
	// 824090FC: C0010264  lfs f0, 0x264(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(612 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82409100: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 82409104: 40990008  ble cr6, 0x8240910c
	if !ctx.cr[6].gt {
	pc = 0x8240910C; continue 'dispatch;
	}
	// 82409108: FFC00090  fmr f30, f0
	ctx.f[30].f64 = ctx.f[0].f64;
	pc = 0x8240910C; continue 'dispatch;
            }
            0x8240910C => {
    //   block [0x8240910C..0x8240911C)
	// 8240910C: C0010268  lfs f0, 0x268(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(616 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82409110: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82409114: 40990008  ble cr6, 0x8240911c
	if !ctx.cr[6].gt {
	pc = 0x8240911C; continue 'dispatch;
	}
	// 82409118: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	pc = 0x8240911C; continue 'dispatch;
            }
            0x8240911C => {
    //   block [0x8240911C..0x82409128)
	// 8240911C: FF1EB000  fcmpu cr6, f30, f22
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[22].f64);
	// 82409120: 40990008  ble cr6, 0x82409128
	if !ctx.cr[6].gt {
	pc = 0x82409128; continue 'dispatch;
	}
	// 82409124: FFC0B090  fmr f30, f22
	ctx.f[30].f64 = ctx.f[22].f64;
	pc = 0x82409128; continue 'dispatch;
            }
            0x82409128 => {
    //   block [0x82409128..0x82409134)
	// 82409128: FF1FB000  fcmpu cr6, f31, f22
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[22].f64);
	// 8240912C: 40990008  ble cr6, 0x82409134
	if !ctx.cr[6].gt {
	pc = 0x82409134; continue 'dispatch;
	}
	// 82409130: FFE0B090  fmr f31, f22
	ctx.f[31].f64 = ctx.f[22].f64;
	pc = 0x82409134; continue 'dispatch;
            }
            0x82409134 => {
    //   block [0x82409134..0x82409194)
	// 82409134: 83E10584  lwz r31, 0x584(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1412 as u32) ) } as u64;
	// 82409138: FC20C890  fmr f1, f25
	ctx.f[1].f64 = ctx.f[25].f64;
	// 8240913C: D33F0000  stfs f25, 0(r31)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82409140: 480053D1  bl 0x8240e510
	ctx.lr = 0x82409144;
	sub_8240E510(ctx, base);
	// 82409144: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82409148: D03F0004  stfs f1, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8240914C: 38A00090  li r5, 0x90
	ctx.r[5].s64 = 144;
	// 82409150: D31F0008  stfs f24, 8(r31)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82409154: 38810390  addi r4, r1, 0x390
	ctx.r[4].s64 = ctx.r[1].s64 + 912;
	// 82409158: D37F009C  stfs f27, 0x9c(r31)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 8240915C: D3BF00A0  stfs f29, 0xa0(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82409160: 927F00A4  stw r19, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[19].u32 ) };
	// 82409164: D3DF00A8  stfs f30, 0xa8(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82409168: D3FF00AC  stfs f31, 0xac(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 8240916C: 4812BE6D  bl 0x82534fd8
	ctx.lr = 0x82409170;
	sub_82534FD8(ctx, base);
	// 82409170: 92BF00B0  stw r21, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[21].u32 ) };
	// 82409174: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82409178: 93BF00B4  stw r29, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[29].u32 ) };
	// 8240917C: 929F00B8  stw r20, 0xb8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[20].u32 ) };
	// 82409180: 937F00BC  stw r27, 0xbc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[27].u32 ) };
	// 82409184: 93DF00C0  stw r30, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 82409188: 921F00C4  stw r16, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[16].u32 ) };
	// 8240918C: 935F00C8  stw r26, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[26].u32 ) };
	// 82409190: 933F00CC  stw r25, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[25].u32 ) };
	pc = 0x82409194; continue 'dispatch;
            }
            0x82409194 => {
    //   block [0x82409194..0x824091A4)
	// 82409194: 38210510  addi r1, r1, 0x510
	ctx.r[1].s64 = ctx.r[1].s64 + 1296;
	// 82409198: 3981FF70  addi r12, r1, -0x90
	ctx.r[12].s64 = ctx.r[1].s64 + -144;
	// 8240919C: 4812CE7D  bl 0x82536018
	ctx.lr = 0x824091A0;
	sub_82535FFC(ctx, base);
	// 824091A0: 4812BF34  b 0x825350d4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824091A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824091A8 size=520
    let mut pc: u32 = 0x824091A8;
    'dispatch: loop {
        match pc {
            0x824091A8 => {
    //   block [0x824091A8..0x82409224)
	// 824091A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824091AC: 4812BEFD  bl 0x825350a8
	ctx.lr = 0x824091B0;
	sub_82535080(ctx, base);
	// 824091B0: DBC1FFA8  stfd f30, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 824091B4: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 824091B8: 9421FD10  stwu r1, -0x2f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-752 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824091BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824091C0: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 824091C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824091C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 824091CC: 7D3B4B78  mr r27, r9
	ctx.r[27].u64 = ctx.r[9].u64;
	// 824091D0: C3EB1850  lfs f31, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 824091D4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824091D8: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 824091DC: 7D5C5378  mr r28, r10
	ctx.r[28].u64 = ctx.r[10].u64;
	// 824091E0: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 824091E4: 7F38CB78  mr r24, r25
	ctx.r[24].u64 = ctx.r[25].u64;
	// 824091E8: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 824091EC: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 824091F0: C3CB1FF8  lfs f30, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 824091F4: D3C10054  stfs f30, 0x54(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 824091F8: FF01F000  fcmpu cr6, f1, f30
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[30].f64);
	// 824091FC: D3C1005C  stfs f30, 0x5c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82409200: 40980024  bge cr6, 0x82409224
	if !ctx.cr[6].lt {
	pc = 0x82409224; continue 'dispatch;
	}
	// 82409204: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82409208: D8210018  stfd f1, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.f[1].u64 ) };
	// 8240920C: E8810018  ld r4, 0x18(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(24 as u32) ) };
	// 82409210: 386BCE90  addi r3, r11, -0x3170
	ctx.r[3].s64 = ctx.r[11].s64 + -12656;
	// 82409214: 4BEA9D6D  bl 0x822b2f80
	ctx.lr = 0x82409218;
	sub_822B2F80(ctx, base);
	// 82409218: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 8240921C: 60630018  ori r3, r3, 0x18
	ctx.r[3].u64 = ctx.r[3].u64 | 24;
	// 82409220: 48000160  b 0x82409380
	pc = 0x82409380; continue 'dispatch;
            }
            0x82409224 => {
    //   block [0x82409224..0x8240923C)
	// 82409224: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82409228: 409A0020  bne cr6, 0x82409248
	if !ctx.cr[6].eq {
	pc = 0x82409248; continue 'dispatch;
	}
	// 8240922C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82409230: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82409234: 386BCE50  addi r3, r11, -0x31b0
	ctx.r[3].s64 = ctx.r[11].s64 + -12720;
	// 82409238: 4BEA9D49  bl 0x822b2f80
	ctx.lr = 0x8240923C;
	sub_822B2F80(ctx, base);
	pc = 0x8240923C; continue 'dispatch;
            }
            0x8240923C => {
    //   block [0x8240923C..0x82409248)
	// 8240923C: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82409240: 60630012  ori r3, r3, 0x12
	ctx.r[3].u64 = ctx.r[3].u64 | 18;
	// 82409244: 4800013C  b 0x82409380
	pc = 0x82409380; continue 'dispatch;
            }
            0x82409248 => {
    //   block [0x82409248..0x824092A4)
	// 82409248: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 8240924C: D0210050  stfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82409250: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82409254: D0410054  stfs f2, 0x54(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82409258: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8240925C: D061005C  stfs f3, 0x5c(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82409260: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 82409264: 4BFFF0E5  bl 0x82408348
	ctx.lr = 0x82409268;
	sub_82408348(ctx, base);
	// 82409268: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8240926C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82409270: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82409274: 4BFFF155  bl 0x824083c8
	ctx.lr = 0x82409278;
	sub_824083C8(ctx, base);
	// 82409278: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8240927C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82409280: 807F1C50  lwz r3, 0x1c50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7248 as u32) ) } as u64;
	// 82409284: 4800562D  bl 0x8240e8b0
	ctx.lr = 0x82409288;
	sub_8240E8B0(ctx, base);
	// 82409288: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 8240928C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82409290: 807F1C50  lwz r3, 0x1c50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7248 as u32) ) } as u64;
	// 82409294: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82409298: 48005669  bl 0x8240e900
	ctx.lr = 0x8240929C;
	sub_8240E900(ctx, base);
	// 8240929C: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 824092A0: 7F3ACB78  mr r26, r25
	ctx.r[26].u64 = ctx.r[25].u64;
	pc = 0x824092A4; continue 'dispatch;
            }
            0x824092A4 => {
    //   block [0x824092A4..0x82409338)
	// 824092A4: 807F1C3C  lwz r3, 0x1c3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7228 as u32) ) } as u64;
	// 824092A8: 7D7A182E  lwzx r11, r26, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 824092AC: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 824092B0: 409A00AC  bne cr6, 0x8240935c
	if !ctx.cr[6].eq {
	pc = 0x8240935C; continue 'dispatch;
	}
	// 824092B4: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 824092B8: D3E101BC  stfs f31, 0x1bc(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(444 as u32), tmp.u32 ) };
	// 824092BC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824092C0: D3C101C0  stfs f30, 0x1c0(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(448 as u32), tmp.u32 ) };
	// 824092C4: D3C101C8  stfs f30, 0x1c8(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(456 as u32), tmp.u32 ) };
	// 824092C8: 932101C4  stw r25, 0x1c4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(452 as u32), ctx.r[25].u32 ) };
	// 824092CC: D3E101CC  stfs f31, 0x1cc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(460 as u32), tmp.u32 ) };
	// 824092D0: D3E101D0  stfs f31, 0x1d0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(464 as u32), tmp.u32 ) };
	// 824092D4: 4800208D  bl 0x8240b360
	ctx.lr = 0x824092D8;
	sub_8240B360(ctx, base);
	// 824092D8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 824092DC: 419A005C  beq cr6, 0x82409338
	if ctx.cr[6].eq {
	pc = 0x82409338; continue 'dispatch;
	}
	// 824092E0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 824092E4: 419A0054  beq cr6, 0x82409338
	if ctx.cr[6].eq {
	pc = 0x82409338; continue 'dispatch;
	}
	// 824092E8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824092EC: 807F1C3C  lwz r3, 0x1c3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7228 as u32) ) } as u64;
	// 824092F0: 48001FD1  bl 0x8240b2c0
	ctx.lr = 0x824092F4;
	sub_8240B2C0(ctx, base);
	// 824092F4: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824092F8: 41820098  beq 0x82409390
	if ctx.cr[0].eq {
	pc = 0x82409390; continue 'dispatch;
	}
	// 824092FC: 394101E0  addi r10, r1, 0x1e0
	ctx.r[10].s64 = ctx.r[1].s64 + 480;
	// 82409300: C06B0020  lfs f3, 0x20(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82409304: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82409308: C02B0014  lfs f1, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8240930C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82409310: 806100A8  lwz r3, 0xa8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 82409314: 80CB0024  lwz r6, 0x24(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82409318: C0410098  lfs f2, 0x98(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8240931C: 4BFFD105  bl 0x82406420
	ctx.lr = 0x82409320;
	sub_82406420(ctx, base);
	// 82409320: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82409324: 40820074  bne 0x82409398
	if !ctx.cr[0].eq {
	pc = 0x82409398; continue 'dispatch;
	}
	// 82409328: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 8240932C: 388101E0  addi r4, r1, 0x1e0
	ctx.r[4].s64 = ctx.r[1].s64 + 480;
	// 82409330: 38A000AC  li r5, 0xac
	ctx.r[5].s64 = 172;
	// 82409334: 4812B81D  bl 0x82534b50
	ctx.lr = 0x82409338;
	sub_82534B50(ctx, base);
	pc = 0x82409338; continue 'dispatch;
            }
            0x82409338 => {
    //   block [0x82409338..0x8240935C)
	// 82409338: 386101BC  addi r3, r1, 0x1bc
	ctx.r[3].s64 = ctx.r[1].s64 + 444;
	// 8240933C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82409340: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 82409344: 4812B80D  bl 0x82534b50
	ctx.lr = 0x82409348;
	sub_82534B50(ctx, base);
	// 82409348: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 8240934C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82409350: 807F1C3C  lwz r3, 0x1c3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7228 as u32) ) } as u64;
	// 82409354: 48001FB5  bl 0x8240b308
	ctx.lr = 0x82409358;
	sub_8240B308(ctx, base);
	// 82409358: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	pc = 0x8240935C; continue 'dispatch;
            }
            0x8240935C => {
    //   block [0x8240935C..0x82409380)
	// 8240935C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 82409360: 3B5A0164  addi r26, r26, 0x164
	ctx.r[26].s64 = ctx.r[26].s64 + 356;
	// 82409364: 616B0B00  ori r11, r11, 0xb00
	ctx.r[11].u64 = ctx.r[11].u64 | 2816;
	// 82409368: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 8240936C: 7F1A5800  cmpw cr6, r26, r11
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82409370: 4198FF34  blt cr6, 0x824092a4
	if ctx.cr[6].lt {
	pc = 0x824092A4; continue 'dispatch;
	}
	// 82409374: 2F180000  cmpwi cr6, r24, 0
	ctx.cr[6].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 82409378: 419AFEC4  beq cr6, 0x8240923c
	if ctx.cr[6].eq {
	pc = 0x8240923C; continue 'dispatch;
	}
	// 8240937C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82409380; continue 'dispatch;
            }
            0x82409380 => {
    //   block [0x82409380..0x82409390)
	// 82409380: 382102F0  addi r1, r1, 0x2f0
	ctx.r[1].s64 = ctx.r[1].s64 + 752;
	// 82409384: CBC1FFA8  lfd f30, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 82409388: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 8240938C: 4812BD6C  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            0x82409390 => {
    //   block [0x82409390..0x82409398)
	// 82409390: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82409394: 4BFFFFEC  b 0x82409380
	pc = 0x82409380; continue 'dispatch;
            }
            0x82409398 => {
    //   block [0x82409398..0x824093B0)
	// 82409398: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8240939C: 386BCE10  addi r3, r11, -0x31f0
	ctx.r[3].s64 = ctx.r[11].s64 + -12784;
	// 824093A0: 4BEA9BE1  bl 0x822b2f80
	ctx.lr = 0x824093A4;
	sub_822B2F80(ctx, base);
	// 824093A4: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 824093A8: 6063002D  ori r3, r3, 0x2d
	ctx.r[3].u64 = ctx.r[3].u64 | 45;
	// 824093AC: 4BFFFFD4  b 0x82409380
	pc = 0x82409380; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824093B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824093B0 size=1108
    let mut pc: u32 = 0x824093B0;
    'dispatch: loop {
        match pc {
            0x824093B0 => {
    //   block [0x824093B0..0x8240941C)
	// 824093B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824093B4: 4812BCF9  bl 0x825350ac
	ctx.lr = 0x824093B8;
	sub_82535080(ctx, base);
	// 824093B8: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 824093BC: 4812CC29  bl 0x82535fe4
	ctx.lr = 0x824093C0;
	sub_82535FB0(ctx, base);
	// 824093C0: 9421FC20  stwu r1, -0x3e0(r1)
	ea = ctx.r[1].u32.wrapping_add(-992 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824093C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824093C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824093CC: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 824093D0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 824093D4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 824093D8: C36B1850  lfs f27, 0x1850(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 824093DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824093E0: 807E1C3C  lwz r3, 0x1c3c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(7228 as u32) ) } as u64;
	// 824093E4: D36101AC  stfs f27, 0x1ac(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(428 as u32), tmp.u32 ) };
	// 824093E8: D36101BC  stfs f27, 0x1bc(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(444 as u32), tmp.u32 ) };
	// 824093EC: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 824093F0: D36101C0  stfs f27, 0x1c0(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(448 as u32), tmp.u32 ) };
	// 824093F4: 934101B4  stw r26, 0x1b4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(436 as u32), ctx.r[26].u32 ) };
	// 824093F8: C3CB1FF8  lfs f30, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 824093FC: D3C101B0  stfs f30, 0x1b0(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(432 as u32), tmp.u32 ) };
	// 82409400: D3C101B8  stfs f30, 0x1b8(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(440 as u32), tmp.u32 ) };
	// 82409404: 48001F5D  bl 0x8240b360
	ctx.lr = 0x82409408;
	sub_8240B360(ctx, base);
	// 82409408: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 8240940C: 408203E8  bne 0x824097f4
	if !ctx.cr[0].eq {
	pc = 0x824097F4; continue 'dispatch;
	}
	// 82409410: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82409414: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82409418: 409A000C  bne cr6, 0x82409424
	if !ctx.cr[6].eq {
	pc = 0x82409424; continue 'dispatch;
	}
	pc = 0x8240941C; continue 'dispatch;
            }
            0x8240941C => {
    //   block [0x8240941C..0x82409424)
	// 8240941C: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82409420: 480003D4  b 0x824097f4
	pc = 0x824097F4; continue 'dispatch;
            }
            0x82409424 => {
    //   block [0x82409424..0x82409524)
	// 82409424: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82409428: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8240942C: 419AFFF0  beq cr6, 0x8240941c
	if ctx.cr[6].eq {
	pc = 0x8240941C; continue 'dispatch;
	}
	// 82409430: 388101D0  addi r4, r1, 0x1d0
	ctx.r[4].s64 = ctx.r[1].s64 + 464;
	// 82409434: 806B0030  lwz r3, 0x30(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82409438: 3BAB0030  addi r29, r11, 0x30
	ctx.r[29].s64 = ctx.r[11].s64 + 48;
	// 8240943C: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 82409440: 4BFFDE59  bl 0x82407298
	ctx.lr = 0x82409444;
	sub_82407298(ctx, base);
	// 82409444: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82409448: 408203AC  bne 0x824097f4
	if !ctx.cr[0].eq {
	pc = 0x824097F4; continue 'dispatch;
	}
	// 8240944C: 4BFFDF5D  bl 0x824073a8
	ctx.lr = 0x82409450;
	sub_824073A8(ctx, base);
	// 82409450: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82409454: 4BFFEFF5  bl 0x82408448
	ctx.lr = 0x82409458;
	sub_82408448(ctx, base);
	// 82409458: FF01F000  fcmpu cr6, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[30].f64);
	// 8240945C: 409900E8  ble cr6, 0x82409544
	if !ctx.cr[6].gt {
	pc = 0x82409544; continue 'dispatch;
	}
	// 82409460: C01E1C1C  lfs f0, 0x1c1c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(7196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82409464: C1A101D0  lfs f13, 0x1d0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(464 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82409468: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8240946C: 409900D8  ble cr6, 0x82409544
	if !ctx.cr[6].gt {
	pc = 0x82409544; continue 'dispatch;
	}
	// 82409470: C00101AC  lfs f0, 0x1ac(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(428 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82409474: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82409478: 409900CC  ble cr6, 0x82409544
	if !ctx.cr[6].gt {
	pc = 0x82409544; continue 'dispatch;
	}
	// 8240947C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82409480: 4BFFDB31  bl 0x82406fb0
	ctx.lr = 0x82409484;
	sub_82406FB0(ctx, base);
	// 82409484: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82409488: 419A00BC  beq cr6, 0x82409544
	if ctx.cr[6].eq {
	pc = 0x82409544; continue 'dispatch;
	}
	// 8240948C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82409490: C02101AC  lfs f1, 0x1ac(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(428 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82409494: 4BFFF00D  bl 0x824084a0
	ctx.lr = 0x82409498;
	sub_824084A0(ctx, base);
	// 82409498: FC400890  fmr f2, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[1].f64;
	// 8240949C: C0BE1C24  lfs f5, 0x1c24(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(7204 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 824094A0: 807E1C40  lwz r3, 0x1c40(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(7232 as u32) ) } as u64;
	// 824094A4: C09B0064  lfs f4, 0x64(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(100 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 824094A8: C06101D0  lfs f3, 0x1d0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(464 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 824094AC: C021007C  lfs f1, 0x7c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 824094B0: 48005F69  bl 0x8240f418
	ctx.lr = 0x824094B4;
	sub_8240F418(ctx, base);
	// 824094B4: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 824094B8: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 824094BC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 824094C0: 409A0064  bne cr6, 0x82409524
	if !ctx.cr[6].eq {
	pc = 0x82409524; continue 'dispatch;
	}
	// 824094C4: 817E1C4C  lwz r11, 0x1c4c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(7244 as u32) ) } as u64;
	// 824094C8: C0210154  lfs f1, 0x154(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(340 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 824094CC: 83A1018C  lwz r29, 0x18c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(396 as u32) ) } as u64;
	// 824094D0: 3B8B0CBC  addi r28, r11, 0xcbc
	ctx.r[28].s64 = ctx.r[11].s64 + 3260;
	// 824094D4: 4800503D  bl 0x8240e510
	ctx.lr = 0x824094D8;
	sub_8240E510(ctx, base);
	// 824094D8: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 824094DC: EFE1F82A  fadds f31, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ((ctx.f[1].f64 + ctx.f[31].f64) as f32) as f64;
	// 824094E0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 824094E4: 409A0040  bne cr6, 0x82409524
	if !ctx.cr[6].eq {
	pc = 0x82409524; continue 'dispatch;
	}
	// 824094E8: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 824094EC: 41980038  blt cr6, 0x82409524
	if ctx.cr[6].lt {
	pc = 0x82409524; continue 'dispatch;
	}
	// 824094F0: 817E1C4C  lwz r11, 0x1c4c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(7244 as u32) ) } as u64;
	// 824094F4: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824094F8: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824094FC: 40980028  bge cr6, 0x82409524
	if !ctx.cr[6].lt {
	pc = 0x82409524; continue 'dispatch;
	}
	// 82409500: 57AB2834  slwi r11, r29, 5
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82409504: 807E1C48  lwz r3, 0x1c48(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(7240 as u32) ) } as u64;
	// 82409508: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 8240950C: C0210158  lfs f1, 0x158(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(344 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82409510: 7CABE214  add r5, r11, r28
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82409514: C045001C  lfs f2, 0x1c(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(28 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82409518: 480063B9  bl 0x8240f8d0
	ctx.lr = 0x8240951C;
	sub_8240F8D0(ctx, base);
	// 8240951C: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82409520: EFE0F82A  fadds f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	pc = 0x82409524; continue 'dispatch;
            }
            0x82409524 => {
    //   block [0x82409524..0x82409544)
	// 82409524: C01E1C18  lfs f0, 0x1c18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(7192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82409528: EFBF0028  fsubs f29, f31, f0
	ctx.f[29].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 8240952C: C1A101D0  lfs f13, 0x1d0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(464 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82409530: EF9F6828  fsubs f28, f31, f13
	ctx.f[28].f64 = (((ctx.f[31].f64 - ctx.f[13].f64) as f32) as f64);
	// 82409534: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82409538: 48005021  bl 0x8240e558
	ctx.lr = 0x8240953C;
	sub_8240E558(ctx, base);
	// 8240953C: D03F0000  stfs f1, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82409540: 48000014  b 0x82409554
	pc = 0x82409554; continue 'dispatch;
            }
            0x82409544 => {
    //   block [0x82409544..0x82409554)
	// 82409544: C01E1C1C  lfs f0, 0x1c1c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(7196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82409548: D3DF0000  stfs f30, 0(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8240954C: FFA00090  fmr f29, f0
	ctx.f[29].f64 = ctx.f[0].f64;
	// 82409550: FF800090  fmr f28, f0
	ctx.f[28].f64 = ctx.f[0].f64;
	pc = 0x82409554; continue 'dispatch;
            }
            0x82409554 => {
    //   block [0x82409554..0x824095B4)
	// 82409554: 807B0038  lwz r3, 0x38(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(56 as u32) ) } as u64;
	// 82409558: 4BFFDEA1  bl 0x824073f8
	ctx.lr = 0x8240955C;
	sub_824073F8(ctx, base);
	// 8240955C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82409560: C01E1C1C  lfs f0, 0x1c1c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(7196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82409564: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82409568: 4099007C  ble cr6, 0x824095e4
	if !ctx.cr[6].gt {
	pc = 0x824095E4; continue 'dispatch;
	}
	// 8240956C: C1A101B8  lfs f13, 0x1b8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(440 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82409570: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82409574: 40990070  ble cr6, 0x824095e4
	if !ctx.cr[6].gt {
	pc = 0x824095E4; continue 'dispatch;
	}
	// 82409578: FF1D0000  fcmpu cr6, f29, f0
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[0].f64);
	// 8240957C: 40990068  ble cr6, 0x824095e4
	if !ctx.cr[6].gt {
	pc = 0x824095E4; continue 'dispatch;
	}
	// 82409580: 807B0038  lwz r3, 0x38(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(56 as u32) ) } as u64;
	// 82409584: 4BFFDA8D  bl 0x82407010
	ctx.lr = 0x82409588;
	sub_82407010(ctx, base);
	// 82409588: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 8240958C: 419A0058  beq cr6, 0x824095e4
	if ctx.cr[6].eq {
	pc = 0x824095E4; continue 'dispatch;
	}
	// 82409590: C01B003C  lfs f0, 0x3c(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82409594: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82409598: C1A101B8  lfs f13, 0x1b8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(440 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8240959C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 824095A0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 824095A4: EFE0F82A  fadds f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 824095A8: 409A000C  bne cr6, 0x824095b4
	if !ctx.cr[6].eq {
	pc = 0x824095B4; continue 'dispatch;
	}
	// 824095AC: C0010140  lfs f0, 0x140(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(320 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824095B0: EFE0F82A  fadds f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	pc = 0x824095B4; continue 'dispatch;
            }
            0x824095B4 => {
    //   block [0x824095B4..0x824095C0)
	// 824095B4: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 824095B8: 40990008  ble cr6, 0x824095c0
	if !ctx.cr[6].gt {
	pc = 0x824095C0; continue 'dispatch;
	}
	// 824095BC: FFE0F090  fmr f31, f30
	ctx.f[31].f64 = ctx.f[30].f64;
	pc = 0x824095C0; continue 'dispatch;
            }
            0x824095C0 => {
    //   block [0x824095C0..0x824095DC)
	// 824095C0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 824095C4: 48004F95  bl 0x8240e558
	ctx.lr = 0x824095C8;
	sub_8240E558(ctx, base);
	// 824095C8: D03F009C  stfs f1, 0x9c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 824095CC: FF1DF000  fcmpu cr6, f29, f30
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[30].f64);
	// 824095D0: 4098000C  bge cr6, 0x824095dc
	if !ctx.cr[6].lt {
	pc = 0x824095DC; continue 'dispatch;
	}
	// 824095D4: EC3FE82A  fadds f1, f31, f29
	ctx.f[1].f64 = ((ctx.f[31].f64 + ctx.f[29].f64) as f32) as f64;
	// 824095D8: 48000014  b 0x824095ec
	pc = 0x824095EC; continue 'dispatch;
            }
            0x824095DC => {
    //   block [0x824095DC..0x824095E4)
	// 824095DC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 824095E0: 4800000C  b 0x824095ec
	pc = 0x824095EC; continue 'dispatch;
            }
            0x824095E4 => {
    //   block [0x824095E4..0x824095EC)
	// 824095E4: D3DF009C  stfs f30, 0x9c(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 824095E8: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	pc = 0x824095EC; continue 'dispatch;
            }
            0x824095EC => {
    //   block [0x824095EC..0x82409664)
	// 824095EC: 48004F6D  bl 0x8240e558
	ctx.lr = 0x824095F0;
	sub_8240E558(ctx, base);
	// 824095F0: D03F00A0  stfs f1, 0xa0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 824095F4: 80A100A8  lwz r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 824095F8: 809B0050  lwz r4, 0x50(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(80 as u32) ) } as u64;
	// 824095FC: 807E1C40  lwz r3, 0x1c40(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(7232 as u32) ) } as u64;
	// 82409600: 48005EC1  bl 0x8240f4c0
	ctx.lr = 0x82409604;
	sub_8240F4C0(ctx, base);
	// 82409604: 80A100AC  lwz r5, 0xac(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82409608: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8240960C: 809B0060  lwz r4, 0x60(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(96 as u32) ) } as u64;
	// 82409610: 807E1C40  lwz r3, 0x1c40(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(7232 as u32) ) } as u64;
	// 82409614: 48005F3D  bl 0x8240f550
	ctx.lr = 0x82409618;
	sub_8240F550(ctx, base);
	// 82409618: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8240961C: 816100AC  lwz r11, 0xac(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82409620: C1BF00A0  lfs f13, 0xa0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82409624: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82409628: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 8240962C: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82409630: D1BF00A0  stfs f13, 0xa0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82409634: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82409638: 935F00A4  stw r26, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[26].u32 ) };
	// 8240963C: 40990028  ble cr6, 0x82409664
	if !ctx.cr[6].gt {
	pc = 0x82409664; continue 'dispatch;
	}
	// 82409640: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 82409644: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82409648: EDAD0072  fmuls f13, f13, f1
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[1].f64) as f32) as f64);
	// 8240964C: D1BF00A0  stfs f13, 0xa0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82409650: FF01F000  fcmpu cr6, f1, f30
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[30].f64);
	// 82409654: 41990010  bgt cr6, 0x82409664
	if ctx.cr[6].gt {
	pc = 0x82409664; continue 'dispatch;
	}
	// 82409658: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8240965C: D3DF0000  stfs f30, 0(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82409660: 917F00A4  stw r11, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	pc = 0x82409664; continue 'dispatch;
            }
            0x82409664 => {
    //   block [0x82409664..0x8240968C)
	// 82409664: C03F0000  lfs f1, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82409668: 48004EA9  bl 0x8240e510
	ctx.lr = 0x8240966C;
	sub_8240E510(ctx, base);
	// 8240966C: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82409670: D03F0004  stfs f1, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82409674: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82409678: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8240967C: 409A0010  bne cr6, 0x8240968c
	if !ctx.cr[6].eq {
	pc = 0x8240968C; continue 'dispatch;
	}
	// 82409680: C0210150  lfs f1, 0x150(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(336 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82409684: 48004FDD  bl 0x8240e660
	ctx.lr = 0x82409688;
	sub_8240E660(ctx, base);
	// 82409688: FC400890  fmr f2, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[1].f64;
	pc = 0x8240968C; continue 'dispatch;
            }
            0x8240968C => {
    //   block [0x8240968C..0x824096BC)
	// 8240968C: 80C101D8  lwz r6, 0x1d8(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(472 as u32) ) } as u64;
	// 82409690: C07B0078  lfs f3, 0x78(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(120 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82409694: 80A101B4  lwz r5, 0x1b4(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(436 as u32) ) } as u64;
	// 82409698: C0210084  lfs f1, 0x84(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8240969C: 807E1C40  lwz r3, 0x1c40(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(7232 as u32) ) } as u64;
	// 824096A0: 48005D91  bl 0x8240f430
	ctx.lr = 0x824096A4;
	sub_8240F430(ctx, base);
	// 824096A4: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 824096A8: D03F0008  stfs f1, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 824096AC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 824096B0: 409A003C  bne cr6, 0x824096ec
	if !ctx.cr[6].eq {
	pc = 0x824096EC; continue 'dispatch;
	}
	// 824096B4: 3BA100BC  addi r29, r1, 0xbc
	ctx.r[29].s64 = ctx.r[1].s64 + 188;
	// 824096B8: 3B800006  li r28, 6
	ctx.r[28].s64 = 6;
	pc = 0x824096BC; continue 'dispatch;
            }
            0x824096BC => {
    //   block [0x824096BC..0x824096EC)
	// 824096BC: C03D0000  lfs f1, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 824096C0: 48004E51  bl 0x8240e510
	ctx.lr = 0x824096C4;
	sub_8240E510(ctx, base);
	// 824096C4: C01B0008  lfs f0, 8(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824096C8: EC1D002A  fadds f0, f29, f0
	ctx.f[0].f64 = ((ctx.f[29].f64 + ctx.f[0].f64) as f32) as f64;
	// 824096CC: EC20082A  fadds f1, f0, f1
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	// 824096D0: 48004E89  bl 0x8240e558
	ctx.lr = 0x824096D4;
	sub_8240E558(ctx, base);
	// 824096D4: D03D0000  stfs f1, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 824096D8: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 824096DC: 3BBD0018  addi r29, r29, 0x18
	ctx.r[29].s64 = ctx.r[29].s64 + 24;
	// 824096E0: 4082FFDC  bne 0x824096bc
	if !ctx.cr[0].eq {
	pc = 0x824096BC; continue 'dispatch;
	}
	// 824096E4: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 824096E8: 4800004C  b 0x82409734
	pc = 0x82409734; continue 'dispatch;
            }
            0x824096EC => {
    //   block [0x824096EC..0x82409734)
	// 824096EC: 807E1C40  lwz r3, 0x1c40(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(7232 as u32) ) } as u64;
	// 824096F0: C06101D4  lfs f3, 0x1d4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 824096F4: C04101B0  lfs f2, 0x1b0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(432 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 824096F8: C0210080  lfs f1, 0x80(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 824096FC: 48005DB5  bl 0x8240f4b0
	ctx.lr = 0x82409700;
	sub_8240F4B0(ctx, base);
	// 82409700: C01B0008  lfs f0, 8(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82409704: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82409708: EC20E82A  fadds f1, f0, f29
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64;
	// 8240970C: 48004E4D  bl 0x8240e558
	ctx.lr = 0x82409710;
	sub_8240E558(ctx, base);
	// 82409710: 392102E0  addi r9, r1, 0x2e0
	ctx.r[9].s64 = ctx.r[1].s64 + 736;
	// 82409714: FCA00890  fmr f5, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[5].f64 = ctx.f[1].f64;
	// 82409718: 80610098  lwz r3, 0x98(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 8240971C: C05B0014  lfs f2, 0x14(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82409720: C081008C  lfs f4, 0x8c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82409724: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82409728: C0610088  lfs f3, 0x88(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8240972C: 4BFFCBFD  bl 0x82406328
	ctx.lr = 0x82409730;
	sub_82406328(ctx, base);
	// 82409730: 388102E0  addi r4, r1, 0x2e0
	ctx.r[4].s64 = ctx.r[1].s64 + 736;
	pc = 0x82409734; continue 'dispatch;
            }
            0x82409734 => {
    //   block [0x82409734..0x82409758)
	// 82409734: 38A00090  li r5, 0x90
	ctx.r[5].s64 = 144;
	// 82409738: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 8240973C: 4812B89D  bl 0x82534fd8
	ctx.lr = 0x82409740;
	sub_82534FD8(ctx, base);
	// 82409740: C01B0028  lfs f0, 0x28(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82409744: C1A101C0  lfs f13, 0x1c0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(448 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82409748: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8240974C: 4099000C  ble cr6, 0x82409758
	if !ctx.cr[6].gt {
	pc = 0x82409758; continue 'dispatch;
	}
	// 82409750: D1BF00A8  stfs f13, 0xa8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82409754: 48000008  b 0x8240975c
	pc = 0x8240975C; continue 'dispatch;
            }
            0x82409758 => {
    //   block [0x82409758..0x8240975C)
	// 82409758: D01F00A8  stfs f0, 0xa8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	pc = 0x8240975C; continue 'dispatch;
            }
            0x8240975C => {
    //   block [0x8240975C..0x82409774)
	// 8240975C: C01B002C  lfs f0, 0x2c(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82409760: C1A101BC  lfs f13, 0x1bc(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(444 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82409764: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82409768: 4099000C  ble cr6, 0x82409774
	if !ctx.cr[6].gt {
	pc = 0x82409774; continue 'dispatch;
	}
	// 8240976C: D1BF00AC  stfs f13, 0xac(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82409770: 48000008  b 0x82409778
	pc = 0x82409778; continue 'dispatch;
            }
            0x82409774 => {
    //   block [0x82409774..0x82409778)
	// 82409774: D01F00AC  stfs f0, 0xac(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	pc = 0x82409778; continue 'dispatch;
            }
            0x82409778 => {
    //   block [0x82409778..0x82409798)
	// 82409778: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 8240977C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82409780: 409A002C  bne cr6, 0x824097ac
	if !ctx.cr[6].eq {
	pc = 0x824097AC; continue 'dispatch;
	}
	// 82409784: C1BF00A8  lfs f13, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82409788: C0010144  lfs f0, 0x144(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(324 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8240978C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82409790: 40990008  ble cr6, 0x82409798
	if !ctx.cr[6].gt {
	pc = 0x82409798; continue 'dispatch;
	}
	// 82409794: D01F00A8  stfs f0, 0xa8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	pc = 0x82409798; continue 'dispatch;
            }
            0x82409798 => {
    //   block [0x82409798..0x824097AC)
	// 82409798: C1BF00AC  lfs f13, 0xac(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8240979C: C0010148  lfs f0, 0x148(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(328 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824097A0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 824097A4: 40990008  ble cr6, 0x824097ac
	if !ctx.cr[6].gt {
	pc = 0x824097AC; continue 'dispatch;
	}
	// 824097A8: D01F00AC  stfs f0, 0xac(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	pc = 0x824097AC; continue 'dispatch;
            }
            0x824097AC => {
    //   block [0x824097AC..0x824097BC)
	// 824097AC: C01F00A8  lfs f0, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824097B0: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 824097B4: 40990008  ble cr6, 0x824097bc
	if !ctx.cr[6].gt {
	pc = 0x824097BC; continue 'dispatch;
	}
	// 824097B8: D37F00A8  stfs f27, 0xa8(r31)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	pc = 0x824097BC; continue 'dispatch;
            }
            0x824097BC => {
    //   block [0x824097BC..0x824097CC)
	// 824097BC: C01F00AC  lfs f0, 0xac(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824097C0: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 824097C4: 40990008  ble cr6, 0x824097cc
	if !ctx.cr[6].gt {
	pc = 0x824097CC; continue 'dispatch;
	}
	// 824097C8: D37F00AC  stfs f27, 0xac(r31)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	pc = 0x824097CC; continue 'dispatch;
            }
            0x824097CC => {
    //   block [0x824097CC..0x824097F4)
	// 824097CC: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824097D0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 824097D4: D001009C  stfs f0, 0x9c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 824097D8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 824097DC: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824097E0: 807E1C3C  lwz r3, 0x1c3c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(7228 as u32) ) } as u64;
	// 824097E4: D00100A4  stfs f0, 0xa4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 824097E8: D38100A0  stfs f28, 0xa0(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 824097EC: 48001B1D  bl 0x8240b308
	ctx.lr = 0x824097F0;
	sub_8240B308(ctx, base);
	// 824097F0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x824097F4; continue 'dispatch;
            }
            0x824097F4 => {
    //   block [0x824097F4..0x82409804)
	// 824097F4: 382103E0  addi r1, r1, 0x3e0
	ctx.r[1].s64 = ctx.r[1].s64 + 992;
	// 824097F8: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 824097FC: 4812C835  bl 0x82536030
	ctx.lr = 0x82409800;
	sub_82535FFC(ctx, base);
	// 82409800: 4812B8FC  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82409808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82409808 size=372
    let mut pc: u32 = 0x82409808;
    'dispatch: loop {
        match pc {
            0x82409808 => {
    //   block [0x82409808..0x8240983C)
	// 82409808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8240980C: 4812B8A5  bl 0x825350b0
	ctx.lr = 0x82409810;
	sub_82535080(ctx, base);
	// 82409810: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 82409814: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82409818: 9421FDF0  stwu r1, -0x210(r1)
	ea = ctx.r[1].u32.wrapping_add(-528 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240981C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82409820: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82409824: 4BFFB9ED  bl 0x82405210
	ctx.lr = 0x82409828;
	sub_82405210(ctx, base);
	// 82409828: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 8240982C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82409830: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 82409834: 397F0118  addi r11, r31, 0x118
	ctx.r[11].s64 = ctx.r[31].s64 + 280;
	// 82409838: 39400040  li r10, 0x40
	ctx.r[10].s64 = 64;
	pc = 0x8240983C; continue 'dispatch;
            }
            0x8240983C => {
    //   block [0x8240983C..0x82409860)
	// 8240983C: C01F1C1C  lfs f0, 0x1c1c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82409840: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82409844: D00BFF00  stfs f0, -0x100(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-256 as u32), tmp.u32 ) };
	// 82409848: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8240984C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82409850: 4082FFEC  bne 0x8240983c
	if !ctx.cr[0].eq {
	pc = 0x8240983C; continue 'dispatch;
	}
	// 82409854: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 82409858: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 8240985C: 40990040  ble cr6, 0x8240989c
	if !ctx.cr[6].gt {
	pc = 0x8240989C; continue 'dispatch;
	}
	pc = 0x82409860; continue 'dispatch;
            }
            0x82409860 => {
    //   block [0x82409860..0x82409890)
	// 82409860: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82409864: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82409868: 4BFFB971  bl 0x824051d8
	ctx.lr = 0x8240986C;
	sub_824051D8(ctx, base);
	// 8240986C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82409870: 40820020  bne 0x82409890
	if !ctx.cr[0].eq {
	pc = 0x82409890; continue 'dispatch;
	}
	// 82409874: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82409878: 4BFFB921  bl 0x82405198
	ctx.lr = 0x8240987C;
	sub_82405198(ctx, base);
	// 8240987C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82409880: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82409884: C0210050  lfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82409888: 4BFFEE09  bl 0x82408690
	ctx.lr = 0x8240988C;
	sub_82408690(ctx, base);
	// 8240988C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	pc = 0x82409890; continue 'dispatch;
            }
            0x82409890 => {
    //   block [0x82409890..0x8240989C)
	// 82409890: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82409894: 7F1EE000  cmpw cr6, r30, r28
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[28].s32, &mut ctx.xer);
	// 82409898: 4198FFC8  blt cr6, 0x82409860
	if ctx.cr[6].lt {
	pc = 0x82409860; continue 'dispatch;
	}
	pc = 0x8240989C; continue 'dispatch;
            }
            0x8240989C => {
    //   block [0x8240989C..0x824098CC)
	// 8240989C: 807F1C3C  lwz r3, 0x1c3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7228 as u32) ) } as u64;
	// 824098A0: 48001FC9  bl 0x8240b868
	ctx.lr = 0x824098A4;
	sub_8240B868(ctx, base);
	// 824098A4: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 824098A8: 409A0024  bne cr6, 0x824098cc
	if !ctx.cr[6].eq {
	pc = 0x824098CC; continue 'dispatch;
	}
	// 824098AC: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 824098B0: 409A001C  bne cr6, 0x824098cc
	if !ctx.cr[6].eq {
	pc = 0x824098CC; continue 'dispatch;
	}
	// 824098B4: 817F1C4C  lwz r11, 0x1c4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7244 as u32) ) } as u64;
	// 824098B8: 807F1C44  lwz r3, 0x1c44(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7236 as u32) ) } as u64;
	// 824098BC: 388B0BBC  addi r4, r11, 0xbbc
	ctx.r[4].s64 = ctx.r[11].s64 + 3004;
	// 824098C0: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 824098C4: 48005ADD  bl 0x8240f3a0
	ctx.lr = 0x824098C8;
	sub_8240F3A0(ctx, base);
	// 824098C8: 480000A0  b 0x82409968
	pc = 0x82409968; continue 'dispatch;
            }
            0x824098CC => {
    //   block [0x824098CC..0x824098E0)
	// 824098CC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 824098D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824098D4: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 824098D8: C3CA1FF8  lfs f30, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 824098DC: C3EB1850  lfs f31, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x824098E0; continue 'dispatch;
            }
            0x824098E0 => {
    //   block [0x824098E0..0x82409940)
	// 824098E0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 824098E4: 807F1C3C  lwz r3, 0x1c3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7228 as u32) ) } as u64;
	// 824098E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 824098EC: D3E101AC  stfs f31, 0x1ac(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(428 as u32), tmp.u32 ) };
	// 824098F0: D3C101B0  stfs f30, 0x1b0(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(432 as u32), tmp.u32 ) };
	// 824098F4: 936101B4  stw r27, 0x1b4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(436 as u32), ctx.r[27].u32 ) };
	// 824098F8: D3C101B8  stfs f30, 0x1b8(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(440 as u32), tmp.u32 ) };
	// 824098FC: D3E101BC  stfs f31, 0x1bc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(444 as u32), tmp.u32 ) };
	// 82409900: D3E101C0  stfs f31, 0x1c0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(448 as u32), tmp.u32 ) };
	// 82409904: 48001A5D  bl 0x8240b360
	ctx.lr = 0x82409908;
	sub_8240B360(ctx, base);
	// 82409908: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8240990C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82409910: 419A0030  beq cr6, 0x82409940
	if ctx.cr[6].eq {
	pc = 0x82409940; continue 'dispatch;
	}
	// 82409914: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82409918: 80810064  lwz r4, 0x64(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8240991C: 807F1C38  lwz r3, 0x1c38(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7224 as u32) ) } as u64;
	// 82409920: 48002DD9  bl 0x8240c6f8
	ctx.lr = 0x82409924;
	sub_8240C6F8(ctx, base);
	// 82409924: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82409928: 40820018  bne 0x82409940
	if !ctx.cr[0].eq {
	pc = 0x82409940; continue 'dispatch;
	}
	// 8240992C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82409930: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82409934: C02100A0  lfs f1, 0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82409938: 80AB0030  lwz r5, 0x30(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8240993C: 4BFFED55  bl 0x82408690
	ctx.lr = 0x82409940;
	sub_82408690(ctx, base);
	pc = 0x82409940; continue 'dispatch;
            }
            0x82409940 => {
    //   block [0x82409940..0x82409968)
	// 82409940: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82409944: 2F1E00C0  cmpwi cr6, r30, 0xc0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 192, &mut ctx.xer);
	// 82409948: 4198FF98  blt cr6, 0x824098e0
	if ctx.cr[6].lt {
	pc = 0x824098E0; continue 'dispatch;
	}
	// 8240994C: 817F1C4C  lwz r11, 0x1c4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7244 as u32) ) } as u64;
	// 82409950: 38BF0018  addi r5, r31, 0x18
	ctx.r[5].s64 = ctx.r[31].s64 + 24;
	// 82409954: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82409958: 807F1C44  lwz r3, 0x1c44(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7236 as u32) ) } as u64;
	// 8240995C: 38CB0BBC  addi r6, r11, 0xbbc
	ctx.r[6].s64 = ctx.r[11].s64 + 3004;
	// 82409960: 80EB0014  lwz r7, 0x14(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82409964: 48005625  bl 0x8240ef88
	ctx.lr = 0x82409968;
	sub_8240EF88(ctx, base);
	pc = 0x82409968; continue 'dispatch;
            }
            0x82409968 => {
    //   block [0x82409968..0x8240997C)
	// 82409968: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8240996C: 38210210  addi r1, r1, 0x210
	ctx.r[1].s64 = ctx.r[1].s64 + 528;
	// 82409970: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82409974: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82409978: 4812B788  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82409980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82409980 size=220
    let mut pc: u32 = 0x82409980;
    'dispatch: loop {
        match pc {
            0x82409980 => {
    //   block [0x82409980..0x824099D4)
	// 82409980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82409984: 4812B739  bl 0x825350bc
	ctx.lr = 0x82409988;
	sub_82535080(ctx, base);
	// 82409988: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8240998C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82409990: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82409994: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82409998: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 8240999C: C00B1850  lfs f0, 0x1850(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824099A0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824099A4: 807F1C50  lwz r3, 0x1c50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7248 as u32) ) } as u64;
	// 824099A8: D00100F0  stfs f0, 0xf0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 824099AC: D0010100  stfs f0, 0x100(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 824099B0: 93C100F8  stw r30, 0xf8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[30].u32 ) };
	// 824099B4: D0010104  stfs f0, 0x104(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 824099B8: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824099BC: D1A100F4  stfs f13, 0xf4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 824099C0: D1A100FC  stfs f13, 0xfc(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 824099C4: 4800509D  bl 0x8240ea60
	ctx.lr = 0x824099C8;
	sub_8240EA60(ctx, base);
	// 824099C8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 824099CC: 4082007C  bne 0x82409a48
	if !ctx.cr[0].eq {
	pc = 0x82409A48; continue 'dispatch;
	}
	// 824099D0: 3BBF0218  addi r29, r31, 0x218
	ctx.r[29].s64 = ctx.r[31].s64 + 536;
	pc = 0x824099D4; continue 'dispatch;
            }
            0x824099D4 => {
    //   block [0x824099D4..0x82409A34)
	// 824099D4: 8141009C  lwz r10, 0x9c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 824099D8: 396100D4  addi r11, r1, 0xd4
	ctx.r[11].s64 = ctx.r[1].s64 + 212;
	// 824099DC: 81010080  lwz r8, 0x80(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 824099E0: 392100A0  addi r9, r1, 0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + 160;
	// 824099E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824099E8: 80E10098  lwz r7, 0x98(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 824099EC: C04100F4  lfs f2, 0xf4(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 824099F0: 80C1008C  lwz r6, 0x8c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 824099F4: C02100F0  lfs f1, 0xf0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(240 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 824099F8: 80A10084  lwz r5, 0x84(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 824099FC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82409A00: 814100F8  lwz r10, 0xf8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(248 as u32) ) } as u64;
	// 82409A04: 80810090  lwz r4, 0x90(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 82409A08: 93A10074  stw r29, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[29].u32 ) };
	// 82409A0C: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 82409A10: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82409A14: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 82409A18: 4BFFF1C9  bl 0x82408be0
	ctx.lr = 0x82409A1C;
	sub_82408BE0(ctx, base);
	// 82409A1C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82409A20: 40820014  bne 0x82409a34
	if !ctx.cr[0].eq {
	pc = 0x82409A34; continue 'dispatch;
	}
	// 82409A24: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82409A28: 3BBD00D0  addi r29, r29, 0xd0
	ctx.r[29].s64 = ctx.r[29].s64 + 208;
	// 82409A2C: 2F1E0020  cmpwi cr6, r30, 0x20
	ctx.cr[6].compare_i32(ctx.r[30].s32, 32, &mut ctx.xer);
	// 82409A30: 40980024  bge cr6, 0x82409a54
	if !ctx.cr[6].lt {
	pc = 0x82409A54; continue 'dispatch;
	}
	pc = 0x82409A34; continue 'dispatch;
            }
            0x82409A34 => {
    //   block [0x82409A34..0x82409A48)
	// 82409A34: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82409A38: 807F1C50  lwz r3, 0x1c50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7248 as u32) ) } as u64;
	// 82409A3C: 48005025  bl 0x8240ea60
	ctx.lr = 0x82409A40;
	sub_8240EA60(ctx, base);
	// 82409A40: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82409A44: 4182FF90  beq 0x824099d4
	if ctx.cr[0].eq {
	pc = 0x824099D4; continue 'dispatch;
	}
	pc = 0x82409A48; continue 'dispatch;
            }
            0x82409A48 => {
    //   block [0x82409A48..0x82409A4C)
	// 82409A48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x82409A4C; continue 'dispatch;
            }
            0x82409A4C => {
    //   block [0x82409A4C..0x82409A54)
	// 82409A4C: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82409A50: 4812B6BC  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x82409A54 => {
    //   block [0x82409A54..0x82409A5C)
	// 82409A54: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 82409A58: 4BFFFFF4  b 0x82409a4c
	pc = 0x82409A4C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


