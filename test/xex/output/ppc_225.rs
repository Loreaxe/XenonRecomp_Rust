pub fn sub_8328C448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328C448 size=12
    let mut pc: u32 = 0x8328C448;
    'dispatch: loop {
        match pc {
            0x8328C448 => {
    //   block [0x8328C448..0x8328C454)
	// 8328C448: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328C44C: 386B30E8  addi r3, r11, 0x30e8
	ctx.r[3].s64 = ctx.r[11].s64 + 12520;
	// 8328C450: 4BA1DAD0  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328C458 size=12
    let mut pc: u32 = 0x8328C458;
    'dispatch: loop {
        match pc {
            0x8328C458 => {
    //   block [0x8328C458..0x8328C464)
	// 8328C458: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328C45C: 386B30F8  addi r3, r11, 0x30f8
	ctx.r[3].s64 = ctx.r[11].s64 + 12536;
	// 8328C460: 4BA1DAC0  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328C468 size=12
    let mut pc: u32 = 0x8328C468;
    'dispatch: loop {
        match pc {
            0x8328C468 => {
    //   block [0x8328C468..0x8328C474)
	// 8328C468: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328C46C: 386B3108  addi r3, r11, 0x3108
	ctx.r[3].s64 = ctx.r[11].s64 + 12552;
	// 8328C470: 4BA1DAB0  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328C478 size=12
    let mut pc: u32 = 0x8328C478;
    'dispatch: loop {
        match pc {
            0x8328C478 => {
    //   block [0x8328C478..0x8328C484)
	// 8328C478: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328C47C: 386B3160  addi r3, r11, 0x3160
	ctx.r[3].s64 = ctx.r[11].s64 + 12640;
	// 8328C480: 4BA1DAA0  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328C488 size=12
    let mut pc: u32 = 0x8328C488;
    'dispatch: loop {
        match pc {
            0x8328C488 => {
    //   block [0x8328C488..0x8328C494)
	// 8328C488: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328C48C: 386B31C0  addi r3, r11, 0x31c0
	ctx.r[3].s64 = ctx.r[11].s64 + 12736;
	// 8328C490: 4BA1DA90  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328C498 size=12
    let mut pc: u32 = 0x8328C498;
    'dispatch: loop {
        match pc {
            0x8328C498 => {
    //   block [0x8328C498..0x8328C4A4)
	// 8328C498: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328C49C: 386B3220  addi r3, r11, 0x3220
	ctx.r[3].s64 = ctx.r[11].s64 + 12832;
	// 8328C4A0: 4BA1DA80  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C4A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328C4A8 size=12
    let mut pc: u32 = 0x8328C4A8;
    'dispatch: loop {
        match pc {
            0x8328C4A8 => {
    //   block [0x8328C4A8..0x8328C4B4)
	// 8328C4A8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328C4AC: 386B3280  addi r3, r11, 0x3280
	ctx.r[3].s64 = ctx.r[11].s64 + 12928;
	// 8328C4B0: 4BA1DA70  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C4B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328C4B8 size=12
    let mut pc: u32 = 0x8328C4B8;
    'dispatch: loop {
        match pc {
            0x8328C4B8 => {
    //   block [0x8328C4B8..0x8328C4C4)
	// 8328C4B8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328C4BC: 386B32D8  addi r3, r11, 0x32d8
	ctx.r[3].s64 = ctx.r[11].s64 + 13016;
	// 8328C4C0: 4BA1DA60  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C4C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328C4C8 size=12
    let mut pc: u32 = 0x8328C4C8;
    'dispatch: loop {
        match pc {
            0x8328C4C8 => {
    //   block [0x8328C4C8..0x8328C4D4)
	// 8328C4C8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328C4CC: 386B3330  addi r3, r11, 0x3330
	ctx.r[3].s64 = ctx.r[11].s64 + 13104;
	// 8328C4D0: 4BA1DA50  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C4D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328C4D8 size=12
    let mut pc: u32 = 0x8328C4D8;
    'dispatch: loop {
        match pc {
            0x8328C4D8 => {
    //   block [0x8328C4D8..0x8328C4E4)
	// 8328C4D8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328C4DC: 386B3340  addi r3, r11, 0x3340
	ctx.r[3].s64 = ctx.r[11].s64 + 13120;
	// 8328C4E0: 4BA1DA40  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C4E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328C4E8 size=12
    let mut pc: u32 = 0x8328C4E8;
    'dispatch: loop {
        match pc {
            0x8328C4E8 => {
    //   block [0x8328C4E8..0x8328C4F4)
	// 8328C4E8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328C4EC: 386B3350  addi r3, r11, 0x3350
	ctx.r[3].s64 = ctx.r[11].s64 + 13136;
	// 8328C4F0: 4BA1DA30  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C4F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328C4F8 size=12
    let mut pc: u32 = 0x8328C4F8;
    'dispatch: loop {
        match pc {
            0x8328C4F8 => {
    //   block [0x8328C4F8..0x8328C504)
	// 8328C4F8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328C4FC: 386B3360  addi r3, r11, 0x3360
	ctx.r[3].s64 = ctx.r[11].s64 + 13152;
	// 8328C500: 4BA1DA20  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328C508 size=12
    let mut pc: u32 = 0x8328C508;
    'dispatch: loop {
        match pc {
            0x8328C508 => {
    //   block [0x8328C508..0x8328C514)
	// 8328C508: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328C50C: 386B3370  addi r3, r11, 0x3370
	ctx.r[3].s64 = ctx.r[11].s64 + 13168;
	// 8328C510: 4BA1DA10  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328C518 size=12
    let mut pc: u32 = 0x8328C518;
    'dispatch: loop {
        match pc {
            0x8328C518 => {
    //   block [0x8328C518..0x8328C524)
	// 8328C518: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328C51C: 386B3380  addi r3, r11, 0x3380
	ctx.r[3].s64 = ctx.r[11].s64 + 13184;
	// 8328C520: 4BA1DA00  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328C528 size=52
    let mut pc: u32 = 0x8328C528;
    'dispatch: loop {
        match pc {
            0x8328C528 => {
    //   block [0x8328C528..0x8328C55C)
	// 8328C528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328C52C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328C530: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328C534: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8328C538: 386BF850  addi r3, r11, -0x7b0
	ctx.r[3].s64 = ctx.r[11].s64 + -1968;
	// 8328C53C: 4B80302D  bl 0x82a8f568
	ctx.lr = 0x8328C540;
	sub_82A8F568(ctx, base);
	// 8328C540: 3D40832B  lis r10, -0x7cd5
	ctx.r[10].s64 = -2094333952;
	// 8328C544: 386A3390  addi r3, r10, 0x3390
	ctx.r[3].s64 = ctx.r[10].s64 + 13200;
	// 8328C548: 4BA1D9D9  bl 0x82ca9f20
	ctx.lr = 0x8328C54C;
	sub_82CA9F20(ctx, base);
	// 8328C54C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328C550: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328C554: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328C558: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328C560 size=52
    let mut pc: u32 = 0x8328C560;
    'dispatch: loop {
        match pc {
            0x8328C560 => {
    //   block [0x8328C560..0x8328C594)
	// 8328C560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328C564: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328C568: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328C56C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8328C570: 386BF8E0  addi r3, r11, -0x720
	ctx.r[3].s64 = ctx.r[11].s64 + -1824;
	// 8328C574: 4B802FF5  bl 0x82a8f568
	ctx.lr = 0x8328C578;
	sub_82A8F568(ctx, base);
	// 8328C578: 3D40832B  lis r10, -0x7cd5
	ctx.r[10].s64 = -2094333952;
	// 8328C57C: 386A33A0  addi r3, r10, 0x33a0
	ctx.r[3].s64 = ctx.r[10].s64 + 13216;
	// 8328C580: 4BA1D9A1  bl 0x82ca9f20
	ctx.lr = 0x8328C584;
	sub_82CA9F20(ctx, base);
	// 8328C584: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328C588: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328C58C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328C590: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328C598 size=92
    let mut pc: u32 = 0x8328C598;
    'dispatch: loop {
        match pc {
            0x8328C598 => {
    //   block [0x8328C598..0x8328C5F4)
	// 8328C598: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328C59C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8328C5A0: 38AAF970  addi r5, r10, -0x690
	ctx.r[5].s64 = ctx.r[10].s64 + -1680;
	// 8328C5A4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328C5A8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8328C5AC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8328C5B0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8328C5B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8328C5B8: 91650004  stw r11, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8328C5BC: 3C80832B  lis r4, -0x7cd5
	ctx.r[4].s64 = -2094333952;
	// 8328C5C0: 91450008  stw r10, 8(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328C5C4: 9125000C  stw r9, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 8328C5C8: 91050014  stw r8, 0x14(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 8328C5CC: 386433B0  addi r3, r4, 0x33b0
	ctx.r[3].s64 = ctx.r[4].s64 + 13232;
	// 8328C5D0: 90E50018  stw r7, 0x18(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(24 as u32), ctx.r[7].u32 ) };
	// 8328C5D4: 90C5001C  stw r6, 0x1c(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(28 as u32), ctx.r[6].u32 ) };
	// 8328C5D8: 91650024  stw r11, 0x24(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 8328C5DC: 91450028  stw r10, 0x28(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 8328C5E0: 9125002C  stw r9, 0x2c(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 8328C5E4: 91050034  stw r8, 0x34(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(52 as u32), ctx.r[8].u32 ) };
	// 8328C5E8: 90E50038  stw r7, 0x38(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(56 as u32), ctx.r[7].u32 ) };
	// 8328C5EC: 90C5003C  stw r6, 0x3c(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(60 as u32), ctx.r[6].u32 ) };
	// 8328C5F0: 4BA1D930  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C5F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328C5F8 size=12
    let mut pc: u32 = 0x8328C5F8;
    'dispatch: loop {
        match pc {
            0x8328C5F8 => {
    //   block [0x8328C5F8..0x8328C604)
	// 8328C5F8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328C5FC: 386B3400  addi r3, r11, 0x3400
	ctx.r[3].s64 = ctx.r[11].s64 + 13312;
	// 8328C600: 4BA1D920  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328C608 size=52
    let mut pc: u32 = 0x8328C608;
    'dispatch: loop {
        match pc {
            0x8328C608 => {
    //   block [0x8328C608..0x8328C63C)
	// 8328C608: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 8328C60C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8328C610: 38C7F9B0  addi r6, r7, -0x650
	ctx.r[6].s64 = ctx.r[7].s64 + -1616;
	// 8328C614: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328C618: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8328C61C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8328C620: 9167F9B0  stw r11, -0x650(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(-1616 as u32), ctx.r[11].u32 ) };
	// 8328C624: 3CA0832B  lis r5, -0x7cd5
	ctx.r[5].s64 = -2094333952;
	// 8328C628: 91460004  stw r10, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328C62C: 91260008  stw r9, 8(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 8328C630: 38653450  addi r3, r5, 0x3450
	ctx.r[3].s64 = ctx.r[5].s64 + 13392;
	// 8328C634: 9106000C  stw r8, 0xc(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 8328C638: 4BA1D8E8  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328C640 size=12
    let mut pc: u32 = 0x8328C640;
    'dispatch: loop {
        match pc {
            0x8328C640 => {
    //   block [0x8328C640..0x8328C64C)
	// 8328C640: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328C644: 386B34A8  addi r3, r11, 0x34a8
	ctx.r[3].s64 = ctx.r[11].s64 + 13480;
	// 8328C648: 4BA1D8D8  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328C650 size=12
    let mut pc: u32 = 0x8328C650;
    'dispatch: loop {
        match pc {
            0x8328C650 => {
    //   block [0x8328C650..0x8328C65C)
	// 8328C650: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328C654: 386B3528  addi r3, r11, 0x3528
	ctx.r[3].s64 = ctx.r[11].s64 + 13608;
	// 8328C658: 4BA1D8C8  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328C660 size=12
    let mut pc: u32 = 0x8328C660;
    'dispatch: loop {
        match pc {
            0x8328C660 => {
    //   block [0x8328C660..0x8328C66C)
	// 8328C660: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328C664: 386B35B0  addi r3, r11, 0x35b0
	ctx.r[3].s64 = ctx.r[11].s64 + 13744;
	// 8328C668: 4BA1D8B8  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328C670 size=52
    let mut pc: u32 = 0x8328C670;
    'dispatch: loop {
        match pc {
            0x8328C670 => {
    //   block [0x8328C670..0x8328C6A4)
	// 8328C670: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 8328C674: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 8328C678: 38CBB158  addi r6, r11, -0x4ea8
	ctx.r[6].s64 = ctx.r[11].s64 + -20136;
	// 8328C67C: 38A7F9CC  addi r5, r7, -0x634
	ctx.r[5].s64 = ctx.r[7].s64 + -1588;
	// 8328C680: 892BB158  lbz r9, -0x4ea8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-20136 as u32) ) } as u64;
	// 8328C684: 89660002  lbz r11, 2(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(2 as u32) ) } as u64;
	// 8328C688: 89460001  lbz r10, 1(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(1 as u32) ) } as u64;
	// 8328C68C: 89060003  lbz r8, 3(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(3 as u32) ) } as u64;
	// 8328C690: 9927F9CC  stb r9, -0x634(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(-1588 as u32), ctx.r[9].u8 ) };
	// 8328C694: 99650002  stb r11, 2(r5)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[5].u32.wrapping_add(2 as u32), ctx.r[11].u8 ) };
	// 8328C698: 99450001  stb r10, 1(r5)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[5].u32.wrapping_add(1 as u32), ctx.r[10].u8 ) };
	// 8328C69C: 99050003  stb r8, 3(r5)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[5].u32.wrapping_add(3 as u32), ctx.r[8].u8 ) };
	// 8328C6A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C6A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328C6A8 size=64
    let mut pc: u32 = 0x8328C6A8;
    'dispatch: loop {
        match pc {
            0x8328C6A8 => {
    //   block [0x8328C6A8..0x8328C6E8)
	// 8328C6A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328C6AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328C6B0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328C6B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328C6B8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328C6BC: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328C6C0: 386AF9D0  addi r3, r10, -0x630
	ctx.r[3].s64 = ctx.r[10].s64 + -1584;
	// 8328C6C4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328C6C8: 4AFA0809  bl 0x8222ced0
	ctx.lr = 0x8328C6CC;
	sub_8222CED0(ctx, base);
	// 8328C6CC: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328C6D0: 38693630  addi r3, r9, 0x3630
	ctx.r[3].s64 = ctx.r[9].s64 + 13872;
	// 8328C6D4: 4BA1D84D  bl 0x82ca9f20
	ctx.lr = 0x8328C6D8;
	sub_82CA9F20(ctx, base);
	// 8328C6D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328C6DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328C6E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328C6E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C6E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328C6E8 size=64
    let mut pc: u32 = 0x8328C6E8;
    'dispatch: loop {
        match pc {
            0x8328C6E8 => {
    //   block [0x8328C6E8..0x8328C728)
	// 8328C6E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328C6EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328C6F0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328C6F4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328C6F8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328C6FC: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328C700: 386AF9D4  addi r3, r10, -0x62c
	ctx.r[3].s64 = ctx.r[10].s64 + -1580;
	// 8328C704: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328C708: 4AFA07C9  bl 0x8222ced0
	ctx.lr = 0x8328C70C;
	sub_8222CED0(ctx, base);
	// 8328C70C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328C710: 38693640  addi r3, r9, 0x3640
	ctx.r[3].s64 = ctx.r[9].s64 + 13888;
	// 8328C714: 4BA1D80D  bl 0x82ca9f20
	ctx.lr = 0x8328C718;
	sub_82CA9F20(ctx, base);
	// 8328C718: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328C71C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328C720: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328C724: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328C728 size=96
    let mut pc: u32 = 0x8328C728;
    'dispatch: loop {
        match pc {
            0x8328C728 => {
    //   block [0x8328C728..0x8328C74C)
	// 8328C728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328C72C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328C730: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328C734: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 8328C738: 4AF92B21  bl 0x8221f258
	ctx.lr = 0x8328C73C;
	sub_8221F258(ctx, base);
	// 8328C73C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8328C740: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8328C744: 419A0008  beq cr6, 0x8328c74c
	if ctx.cr[6].eq {
	pc = 0x8328C74C; continue 'dispatch;
	}
	// 8328C748: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x8328C74C; continue 'dispatch;
            }
            0x8328C74C => {
    //   block [0x8328C74C..0x8328C758)
	// 8328C74C: 354B0004  addic. r10, r11, 4
	ctx.xer.ca = (ctx.r[11].u32 > (!(4 as u32)));
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8328C750: 41820008  beq 0x8328c758
	if ctx.cr[0].eq {
	pc = 0x8328C758; continue 'dispatch;
	}
	// 8328C754: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x8328C758; continue 'dispatch;
            }
            0x8328C758 => {
    //   block [0x8328C758..0x8328C788)
	// 8328C758: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 8328C75C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328C760: 3909F9D8  addi r8, r9, -0x628
	ctx.r[8].s64 = ctx.r[9].s64 + -1576;
	// 8328C764: 3CE0832B  lis r7, -0x7cd5
	ctx.r[7].s64 = -2094333952;
	// 8328C768: 38673650  addi r3, r7, 0x3650
	ctx.r[3].s64 = ctx.r[7].s64 + 13904;
	// 8328C76C: 91680004  stw r11, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8328C770: 91480008  stw r10, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328C774: 4BA1D7AD  bl 0x82ca9f20
	ctx.lr = 0x8328C778;
	sub_82CA9F20(ctx, base);
	// 8328C778: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328C77C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328C780: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328C784: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328C788 size=144
    let mut pc: u32 = 0x8328C788;
    'dispatch: loop {
        match pc {
            0x8328C788 => {
    //   block [0x8328C788..0x8328C7AC)
	// 8328C788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328C78C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328C790: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328C794: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 8328C798: 4AF92AC1  bl 0x8221f258
	ctx.lr = 0x8328C79C;
	sub_8221F258(ctx, base);
	// 8328C79C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328C7A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8328C7A4: 419A0008  beq cr6, 0x8328c7ac
	if ctx.cr[6].eq {
	pc = 0x8328C7AC; continue 'dispatch;
	}
	// 8328C7A8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x8328C7AC; continue 'dispatch;
            }
            0x8328C7AC => {
    //   block [0x8328C7AC..0x8328C7B8)
	// 8328C7AC: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8328C7B0: 41820008  beq 0x8328c7b8
	if ctx.cr[0].eq {
	pc = 0x8328C7B8; continue 'dispatch;
	}
	// 8328C7B4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x8328C7B8; continue 'dispatch;
            }
            0x8328C7B8 => {
    //   block [0x8328C7B8..0x8328C7C4)
	// 8328C7B8: 35630008  addic. r11, r3, 8
	ctx.xer.ca = (ctx.r[3].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8328C7BC: 41820008  beq 0x8328c7c4
	if ctx.cr[0].eq {
	pc = 0x8328C7C4; continue 'dispatch;
	}
	// 8328C7C0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x8328C7C4; continue 'dispatch;
            }
            0x8328C7C4 => {
    //   block [0x8328C7C4..0x8328C818)
	// 8328C7C4: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 8328C7C8: 99430015  stb r10, 0x15(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(21 as u32), ctx.r[10].u8 ) };
	// 8328C7CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8328C7D0: 3909F9E4  addi r8, r9, -0x61c
	ctx.r[8].s64 = ctx.r[9].s64 + -1564;
	// 8328C7D4: 99630014  stb r11, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 8328C7D8: 3CE0832B  lis r7, -0x7cd5
	ctx.r[7].s64 = -2094333952;
	// 8328C7DC: 90680004  stw r3, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 8328C7E0: 99630015  stb r11, 0x15(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(21 as u32), ctx.r[11].u8 ) };
	// 8328C7E4: 386736D8  addi r3, r7, 0x36d8
	ctx.r[3].s64 = ctx.r[7].s64 + 14040;
	// 8328C7E8: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8328C7EC: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8328C7F0: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8328C7F4: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8328C7F8: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8328C7FC: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8328C800: 91480008  stw r10, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328C804: 4BA1D71D  bl 0x82ca9f20
	ctx.lr = 0x8328C808;
	sub_82CA9F20(ctx, base);
	// 8328C808: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328C80C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328C810: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328C814: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328C818 size=96
    let mut pc: u32 = 0x8328C818;
    'dispatch: loop {
        match pc {
            0x8328C818 => {
    //   block [0x8328C818..0x8328C83C)
	// 8328C818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328C81C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328C820: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328C824: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8328C828: 4AF92A31  bl 0x8221f258
	ctx.lr = 0x8328C82C;
	sub_8221F258(ctx, base);
	// 8328C82C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8328C830: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8328C834: 419A0008  beq cr6, 0x8328c83c
	if ctx.cr[6].eq {
	pc = 0x8328C83C; continue 'dispatch;
	}
	// 8328C838: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x8328C83C; continue 'dispatch;
            }
            0x8328C83C => {
    //   block [0x8328C83C..0x8328C848)
	// 8328C83C: 354B0004  addic. r10, r11, 4
	ctx.xer.ca = (ctx.r[11].u32 > (!(4 as u32)));
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8328C840: 41820008  beq 0x8328c848
	if ctx.cr[0].eq {
	pc = 0x8328C848; continue 'dispatch;
	}
	// 8328C844: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x8328C848; continue 'dispatch;
            }
            0x8328C848 => {
    //   block [0x8328C848..0x8328C878)
	// 8328C848: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 8328C84C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328C850: 3909F9F0  addi r8, r9, -0x610
	ctx.r[8].s64 = ctx.r[9].s64 + -1552;
	// 8328C854: 3CE0832B  lis r7, -0x7cd5
	ctx.r[7].s64 = -2094333952;
	// 8328C858: 386736E8  addi r3, r7, 0x36e8
	ctx.r[3].s64 = ctx.r[7].s64 + 14056;
	// 8328C85C: 91680004  stw r11, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8328C860: 91480008  stw r10, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328C864: 4BA1D6BD  bl 0x82ca9f20
	ctx.lr = 0x8328C868;
	sub_82CA9F20(ctx, base);
	// 8328C868: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328C86C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328C870: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328C874: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328C878 size=28
    let mut pc: u32 = 0x8328C878;
    'dispatch: loop {
        match pc {
            0x8328C878 => {
    //   block [0x8328C878..0x8328C894)
	// 8328C878: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 8328C87C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8328C880: 392BAA88  addi r9, r11, -0x5578
	ctx.r[9].s64 = ctx.r[11].s64 + -21880;
	// 8328C884: 3D00832B  lis r8, -0x7cd5
	ctx.r[8].s64 = -2094333952;
	// 8328C888: 38683770  addi r3, r8, 0x3770
	ctx.r[3].s64 = ctx.r[8].s64 + 14192;
	// 8328C88C: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328C890: 4BA1D690  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328C898 size=12
    let mut pc: u32 = 0x8328C898;
    'dispatch: loop {
        match pc {
            0x8328C898 => {
    //   block [0x8328C898..0x8328C8A4)
	// 8328C898: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328C89C: 386B3780  addi r3, r11, 0x3780
	ctx.r[3].s64 = ctx.r[11].s64 + 14208;
	// 8328C8A0: 4BA1D680  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C8A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328C8A8 size=12
    let mut pc: u32 = 0x8328C8A8;
    'dispatch: loop {
        match pc {
            0x8328C8A8 => {
    //   block [0x8328C8A8..0x8328C8B4)
	// 8328C8A8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328C8AC: 386B37D8  addi r3, r11, 0x37d8
	ctx.r[3].s64 = ctx.r[11].s64 + 14296;
	// 8328C8B0: 4BA1D670  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C8B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328C8B8 size=12
    let mut pc: u32 = 0x8328C8B8;
    'dispatch: loop {
        match pc {
            0x8328C8B8 => {
    //   block [0x8328C8B8..0x8328C8C4)
	// 8328C8B8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328C8BC: 386B3828  addi r3, r11, 0x3828
	ctx.r[3].s64 = ctx.r[11].s64 + 14376;
	// 8328C8C0: 4BA1D660  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328C8C8 size=12
    let mut pc: u32 = 0x8328C8C8;
    'dispatch: loop {
        match pc {
            0x8328C8C8 => {
    //   block [0x8328C8C8..0x8328C8D4)
	// 8328C8C8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328C8CC: 386B3878  addi r3, r11, 0x3878
	ctx.r[3].s64 = ctx.r[11].s64 + 14456;
	// 8328C8D0: 4BA1D650  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C8D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328C8D8 size=12
    let mut pc: u32 = 0x8328C8D8;
    'dispatch: loop {
        match pc {
            0x8328C8D8 => {
    //   block [0x8328C8D8..0x8328C8E4)
	// 8328C8D8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328C8DC: 386B38A0  addi r3, r11, 0x38a0
	ctx.r[3].s64 = ctx.r[11].s64 + 14496;
	// 8328C8E0: 4BA1D640  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C8E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328C8E8 size=12
    let mut pc: u32 = 0x8328C8E8;
    'dispatch: loop {
        match pc {
            0x8328C8E8 => {
    //   block [0x8328C8E8..0x8328C8F4)
	// 8328C8E8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328C8EC: 386B3948  addi r3, r11, 0x3948
	ctx.r[3].s64 = ctx.r[11].s64 + 14664;
	// 8328C8F0: 4BA1D630  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C8F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328C8F8 size=64
    let mut pc: u32 = 0x8328C8F8;
    'dispatch: loop {
        match pc {
            0x8328C8F8 => {
    //   block [0x8328C8F8..0x8328C938)
	// 8328C8F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328C8FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328C900: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328C904: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 8328C908: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328C90C: 388B6C1C  addi r4, r11, 0x6c1c
	ctx.r[4].s64 = ctx.r[11].s64 + 27676;
	// 8328C910: 386AFA4C  addi r3, r10, -0x5b4
	ctx.r[3].s64 = ctx.r[10].s64 + -1460;
	// 8328C914: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328C918: 4AFA05B9  bl 0x8222ced0
	ctx.lr = 0x8328C91C;
	sub_8222CED0(ctx, base);
	// 8328C91C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328C920: 38693950  addi r3, r9, 0x3950
	ctx.r[3].s64 = ctx.r[9].s64 + 14672;
	// 8328C924: 4BA1D5FD  bl 0x82ca9f20
	ctx.lr = 0x8328C928;
	sub_82CA9F20(ctx, base);
	// 8328C928: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328C92C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328C930: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328C934: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328C938 size=64
    let mut pc: u32 = 0x8328C938;
    'dispatch: loop {
        match pc {
            0x8328C938 => {
    //   block [0x8328C938..0x8328C978)
	// 8328C938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328C93C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328C940: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328C944: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328C948: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328C94C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328C950: 386AFA50  addi r3, r10, -0x5b0
	ctx.r[3].s64 = ctx.r[10].s64 + -1456;
	// 8328C954: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328C958: 4AFA0579  bl 0x8222ced0
	ctx.lr = 0x8328C95C;
	sub_8222CED0(ctx, base);
	// 8328C95C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328C960: 38693960  addi r3, r9, 0x3960
	ctx.r[3].s64 = ctx.r[9].s64 + 14688;
	// 8328C964: 4BA1D5BD  bl 0x82ca9f20
	ctx.lr = 0x8328C968;
	sub_82CA9F20(ctx, base);
	// 8328C968: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328C96C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328C970: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328C974: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328C978 size=64
    let mut pc: u32 = 0x8328C978;
    'dispatch: loop {
        match pc {
            0x8328C978 => {
    //   block [0x8328C978..0x8328C9B8)
	// 8328C978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328C97C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328C980: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328C984: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328C988: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328C98C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328C990: 386AFA54  addi r3, r10, -0x5ac
	ctx.r[3].s64 = ctx.r[10].s64 + -1452;
	// 8328C994: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328C998: 4AFA0539  bl 0x8222ced0
	ctx.lr = 0x8328C99C;
	sub_8222CED0(ctx, base);
	// 8328C99C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328C9A0: 38693970  addi r3, r9, 0x3970
	ctx.r[3].s64 = ctx.r[9].s64 + 14704;
	// 8328C9A4: 4BA1D57D  bl 0x82ca9f20
	ctx.lr = 0x8328C9A8;
	sub_82CA9F20(ctx, base);
	// 8328C9A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328C9AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328C9B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328C9B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C9B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328C9B8 size=64
    let mut pc: u32 = 0x8328C9B8;
    'dispatch: loop {
        match pc {
            0x8328C9B8 => {
    //   block [0x8328C9B8..0x8328C9F8)
	// 8328C9B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328C9BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328C9C0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328C9C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328C9C8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328C9CC: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328C9D0: 386AFA58  addi r3, r10, -0x5a8
	ctx.r[3].s64 = ctx.r[10].s64 + -1448;
	// 8328C9D4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328C9D8: 4AFA04F9  bl 0x8222ced0
	ctx.lr = 0x8328C9DC;
	sub_8222CED0(ctx, base);
	// 8328C9DC: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328C9E0: 38693980  addi r3, r9, 0x3980
	ctx.r[3].s64 = ctx.r[9].s64 + 14720;
	// 8328C9E4: 4BA1D53D  bl 0x82ca9f20
	ctx.lr = 0x8328C9E8;
	sub_82CA9F20(ctx, base);
	// 8328C9E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328C9EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328C9F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328C9F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328C9F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328C9F8 size=64
    let mut pc: u32 = 0x8328C9F8;
    'dispatch: loop {
        match pc {
            0x8328C9F8 => {
    //   block [0x8328C9F8..0x8328CA38)
	// 8328C9F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328C9FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328CA00: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328CA04: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328CA08: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328CA0C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328CA10: 386AFA5C  addi r3, r10, -0x5a4
	ctx.r[3].s64 = ctx.r[10].s64 + -1444;
	// 8328CA14: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328CA18: 4AFA04B9  bl 0x8222ced0
	ctx.lr = 0x8328CA1C;
	sub_8222CED0(ctx, base);
	// 8328CA1C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328CA20: 38693990  addi r3, r9, 0x3990
	ctx.r[3].s64 = ctx.r[9].s64 + 14736;
	// 8328CA24: 4BA1D4FD  bl 0x82ca9f20
	ctx.lr = 0x8328CA28;
	sub_82CA9F20(ctx, base);
	// 8328CA28: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328CA2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328CA30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328CA34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328CA38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328CA38 size=32
    let mut pc: u32 = 0x8328CA38;
    'dispatch: loop {
        match pc {
            0x8328CA38 => {
    //   block [0x8328CA38..0x8328CA58)
	// 8328CA38: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8328CA3C: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328CA40: 392B9538  addi r9, r11, -0x6ac8
	ctx.r[9].s64 = ctx.r[11].s64 + -27336;
	// 8328CA44: 390AFA60  addi r8, r10, -0x5a0
	ctx.r[8].s64 = ctx.r[10].s64 + -1440;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328CA58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328CA58 size=64
    let mut pc: u32 = 0x8328CA58;
    'dispatch: loop {
        match pc {
            0x8328CA58 => {
    //   block [0x8328CA58..0x8328CA98)
	// 8328CA58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328CA5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328CA60: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328CA64: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 8328CA68: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328CA6C: 388B6C48  addi r4, r11, 0x6c48
	ctx.r[4].s64 = ctx.r[11].s64 + 27720;
	// 8328CA70: 386AFA70  addi r3, r10, -0x590
	ctx.r[3].s64 = ctx.r[10].s64 + -1424;
	// 8328CA74: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328CA78: 4AFA0459  bl 0x8222ced0
	ctx.lr = 0x8328CA7C;
	sub_8222CED0(ctx, base);
	// 8328CA7C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328CA80: 386939A0  addi r3, r9, 0x39a0
	ctx.r[3].s64 = ctx.r[9].s64 + 14752;
	// 8328CA84: 4BA1D49D  bl 0x82ca9f20
	ctx.lr = 0x8328CA88;
	sub_82CA9F20(ctx, base);
	// 8328CA88: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328CA8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328CA90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328CA94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328CA98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328CA98 size=64
    let mut pc: u32 = 0x8328CA98;
    'dispatch: loop {
        match pc {
            0x8328CA98 => {
    //   block [0x8328CA98..0x8328CAD8)
	// 8328CA98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328CA9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328CAA0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328CAA4: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 8328CAA8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328CAAC: 388B6C58  addi r4, r11, 0x6c58
	ctx.r[4].s64 = ctx.r[11].s64 + 27736;
	// 8328CAB0: 386AFA74  addi r3, r10, -0x58c
	ctx.r[3].s64 = ctx.r[10].s64 + -1420;
	// 8328CAB4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328CAB8: 4AFA0419  bl 0x8222ced0
	ctx.lr = 0x8328CABC;
	sub_8222CED0(ctx, base);
	// 8328CABC: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328CAC0: 386939B0  addi r3, r9, 0x39b0
	ctx.r[3].s64 = ctx.r[9].s64 + 14768;
	// 8328CAC4: 4BA1D45D  bl 0x82ca9f20
	ctx.lr = 0x8328CAC8;
	sub_82CA9F20(ctx, base);
	// 8328CAC8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328CACC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328CAD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328CAD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328CAD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328CAD8 size=64
    let mut pc: u32 = 0x8328CAD8;
    'dispatch: loop {
        match pc {
            0x8328CAD8 => {
    //   block [0x8328CAD8..0x8328CB18)
	// 8328CAD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328CADC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328CAE0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328CAE4: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 8328CAE8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328CAEC: 388B6C6C  addi r4, r11, 0x6c6c
	ctx.r[4].s64 = ctx.r[11].s64 + 27756;
	// 8328CAF0: 386AFA78  addi r3, r10, -0x588
	ctx.r[3].s64 = ctx.r[10].s64 + -1416;
	// 8328CAF4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328CAF8: 4AFA03D9  bl 0x8222ced0
	ctx.lr = 0x8328CAFC;
	sub_8222CED0(ctx, base);
	// 8328CAFC: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328CB00: 386939C0  addi r3, r9, 0x39c0
	ctx.r[3].s64 = ctx.r[9].s64 + 14784;
	// 8328CB04: 4BA1D41D  bl 0x82ca9f20
	ctx.lr = 0x8328CB08;
	sub_82CA9F20(ctx, base);
	// 8328CB08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328CB0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328CB10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328CB14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328CB18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328CB18 size=64
    let mut pc: u32 = 0x8328CB18;
    'dispatch: loop {
        match pc {
            0x8328CB18 => {
    //   block [0x8328CB18..0x8328CB58)
	// 8328CB18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328CB1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328CB20: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328CB24: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 8328CB28: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328CB2C: 388B6C78  addi r4, r11, 0x6c78
	ctx.r[4].s64 = ctx.r[11].s64 + 27768;
	// 8328CB30: 386AFA7C  addi r3, r10, -0x584
	ctx.r[3].s64 = ctx.r[10].s64 + -1412;
	// 8328CB34: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328CB38: 4AFA0399  bl 0x8222ced0
	ctx.lr = 0x8328CB3C;
	sub_8222CED0(ctx, base);
	// 8328CB3C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328CB40: 386939D0  addi r3, r9, 0x39d0
	ctx.r[3].s64 = ctx.r[9].s64 + 14800;
	// 8328CB44: 4BA1D3DD  bl 0x82ca9f20
	ctx.lr = 0x8328CB48;
	sub_82CA9F20(ctx, base);
	// 8328CB48: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328CB4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328CB50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328CB54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328CB58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8328CB58 size=88
    let mut pc: u32 = 0x8328CB58;
    'dispatch: loop {
        match pc {
            0x8328CB58 => {
    //   block [0x8328CB58..0x8328CBB0)
	// 8328CB58: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8328CB5C: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 8328CB60: 3921FFF4  addi r9, r1, -0xc
	ctx.r[9].s64 = ctx.r[1].s64 + -12;
	// 8328CB64: 3901FFF4  addi r8, r1, -0xc
	ctx.r[8].s64 = ctx.r[1].s64 + -12;
	// 8328CB68: 38E1FFF0  addi r7, r1, -0x10
	ctx.r[7].s64 = ctx.r[1].s64 + -16;
	// 8328CB6C: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8328CB70: 3CC0834A  lis r6, -0x7cb6
	ctx.r[6].s64 = -2092302336;
	// 8328CB74: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328CBB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8328CBB0 size=88
    let mut pc: u32 = 0x8328CBB0;
    'dispatch: loop {
        match pc {
            0x8328CBB0 => {
    //   block [0x8328CBB0..0x8328CC08)
	// 8328CBB0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8328CBB4: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 8328CBB8: 3921FFF4  addi r9, r1, -0xc
	ctx.r[9].s64 = ctx.r[1].s64 + -12;
	// 8328CBBC: 3901FFF4  addi r8, r1, -0xc
	ctx.r[8].s64 = ctx.r[1].s64 + -12;
	// 8328CBC0: 38E1FFF0  addi r7, r1, -0x10
	ctx.r[7].s64 = ctx.r[1].s64 + -16;
	// 8328CBC4: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8328CBC8: 3CC0834A  lis r6, -0x7cb6
	ctx.r[6].s64 = -2092302336;
	// 8328CBCC: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328CC08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8328CC08 size=88
    let mut pc: u32 = 0x8328CC08;
    'dispatch: loop {
        match pc {
            0x8328CC08 => {
    //   block [0x8328CC08..0x8328CC60)
	// 8328CC08: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8328CC0C: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 8328CC10: 3921FFF4  addi r9, r1, -0xc
	ctx.r[9].s64 = ctx.r[1].s64 + -12;
	// 8328CC14: 3901FFF4  addi r8, r1, -0xc
	ctx.r[8].s64 = ctx.r[1].s64 + -12;
	// 8328CC18: 38E1FFF0  addi r7, r1, -0x10
	ctx.r[7].s64 = ctx.r[1].s64 + -16;
	// 8328CC1C: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8328CC20: 3CC0834A  lis r6, -0x7cb6
	ctx.r[6].s64 = -2092302336;
	// 8328CC24: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328CC60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328CC60 size=12
    let mut pc: u32 = 0x8328CC60;
    'dispatch: loop {
        match pc {
            0x8328CC60 => {
    //   block [0x8328CC60..0x8328CC6C)
	// 8328CC60: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328CC64: 386B39E0  addi r3, r11, 0x39e0
	ctx.r[3].s64 = ctx.r[11].s64 + 14816;
	// 8328CC68: 4BA1D2B8  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328CC70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328CC70 size=12
    let mut pc: u32 = 0x8328CC70;
    'dispatch: loop {
        match pc {
            0x8328CC70 => {
    //   block [0x8328CC70..0x8328CC7C)
	// 8328CC70: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328CC74: 386B3A38  addi r3, r11, 0x3a38
	ctx.r[3].s64 = ctx.r[11].s64 + 14904;
	// 8328CC78: 4BA1D2A8  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328CC80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328CC80 size=12
    let mut pc: u32 = 0x8328CC80;
    'dispatch: loop {
        match pc {
            0x8328CC80 => {
    //   block [0x8328CC80..0x8328CC8C)
	// 8328CC80: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328CC84: 386B3A90  addi r3, r11, 0x3a90
	ctx.r[3].s64 = ctx.r[11].s64 + 14992;
	// 8328CC88: 4BA1D298  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328CC90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328CC90 size=12
    let mut pc: u32 = 0x8328CC90;
    'dispatch: loop {
        match pc {
            0x8328CC90 => {
    //   block [0x8328CC90..0x8328CC9C)
	// 8328CC90: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328CC94: 386B3AE8  addi r3, r11, 0x3ae8
	ctx.r[3].s64 = ctx.r[11].s64 + 15080;
	// 8328CC98: 4BA1D288  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328CCA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328CCA0 size=12
    let mut pc: u32 = 0x8328CCA0;
    'dispatch: loop {
        match pc {
            0x8328CCA0 => {
    //   block [0x8328CCA0..0x8328CCAC)
	// 8328CCA0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328CCA4: 386B3B40  addi r3, r11, 0x3b40
	ctx.r[3].s64 = ctx.r[11].s64 + 15168;
	// 8328CCA8: 4BA1D278  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328CCB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328CCB0 size=12
    let mut pc: u32 = 0x8328CCB0;
    'dispatch: loop {
        match pc {
            0x8328CCB0 => {
    //   block [0x8328CCB0..0x8328CCBC)
	// 8328CCB0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328CCB4: 386B3B98  addi r3, r11, 0x3b98
	ctx.r[3].s64 = ctx.r[11].s64 + 15256;
	// 8328CCB8: 4BA1D268  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328CCC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328CCC0 size=12
    let mut pc: u32 = 0x8328CCC0;
    'dispatch: loop {
        match pc {
            0x8328CCC0 => {
    //   block [0x8328CCC0..0x8328CCCC)
	// 8328CCC0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328CCC4: 386B3BF0  addi r3, r11, 0x3bf0
	ctx.r[3].s64 = ctx.r[11].s64 + 15344;
	// 8328CCC8: 4BA1D258  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328CCD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328CCD0 size=48
    let mut pc: u32 = 0x8328CCD0;
    'dispatch: loop {
        match pc {
            0x8328CCD0 => {
    //   block [0x8328CCD0..0x8328CCD8)
	// 8328CCD0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8328CCD4: 390B7088  addi r8, r11, 0x7088
	ctx.r[8].s64 = ctx.r[11].s64 + 28808;
	pc = 0x8328CCD8; continue 'dispatch;
            }
            0x8328CCD8 => {
    //   block [0x8328CCD8..0x8328CD00)
	// 8328CCD8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8328CCDC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8328CCE0: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8328CCE4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8328CCE8: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8328CCEC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8328CCF0: 4082FFE8  bne 0x8328ccd8
	if !ctx.cr[0].eq {
	pc = 0x8328CCD8; continue 'dispatch;
	}
	// 8328CCF4: 3CE0832B  lis r7, -0x7cd5
	ctx.r[7].s64 = -2094333952;
	// 8328CCF8: 38673C48  addi r3, r7, 0x3c48
	ctx.r[3].s64 = ctx.r[7].s64 + 15432;
	// 8328CCFC: 4BA1D224  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328CD00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328CD00 size=36
    let mut pc: u32 = 0x8328CD00;
    'dispatch: loop {
        match pc {
            0x8328CD00 => {
    //   block [0x8328CD00..0x8328CD14)
	// 8328CD00: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 8328CD04: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328CD08: 396BAAC0  addi r11, r11, -0x5540
	ctx.r[11].s64 = ctx.r[11].s64 + -21824;
	// 8328CD0C: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 8328CD10: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x8328CD14; continue 'dispatch;
            }
            0x8328CD14 => {
    //   block [0x8328CD14..0x8328CD24)
	// 8328CD14: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 8328CD18: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8328CD1C: 4200FFF8  bdnz 0x8328cd14
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8328CD14; continue 'dispatch;
	}
	// 8328CD20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328CD28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328CD28 size=64
    let mut pc: u32 = 0x8328CD28;
    'dispatch: loop {
        match pc {
            0x8328CD28 => {
    //   block [0x8328CD28..0x8328CD68)
	// 8328CD28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328CD2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328CD30: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328CD34: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328CD38: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328CD3C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328CD40: 386AFB28  addi r3, r10, -0x4d8
	ctx.r[3].s64 = ctx.r[10].s64 + -1240;
	// 8328CD44: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328CD48: 4AFA0189  bl 0x8222ced0
	ctx.lr = 0x8328CD4C;
	sub_8222CED0(ctx, base);
	// 8328CD4C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328CD50: 38693C58  addi r3, r9, 0x3c58
	ctx.r[3].s64 = ctx.r[9].s64 + 15448;
	// 8328CD54: 4BA1D1CD  bl 0x82ca9f20
	ctx.lr = 0x8328CD58;
	sub_82CA9F20(ctx, base);
	// 8328CD58: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328CD5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328CD60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328CD64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328CD68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328CD68 size=64
    let mut pc: u32 = 0x8328CD68;
    'dispatch: loop {
        match pc {
            0x8328CD68 => {
    //   block [0x8328CD68..0x8328CDA8)
	// 8328CD68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328CD6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328CD70: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328CD74: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328CD78: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328CD7C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328CD80: 386AFB2C  addi r3, r10, -0x4d4
	ctx.r[3].s64 = ctx.r[10].s64 + -1236;
	// 8328CD84: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328CD88: 4AFA0149  bl 0x8222ced0
	ctx.lr = 0x8328CD8C;
	sub_8222CED0(ctx, base);
	// 8328CD8C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328CD90: 38693C68  addi r3, r9, 0x3c68
	ctx.r[3].s64 = ctx.r[9].s64 + 15464;
	// 8328CD94: 4BA1D18D  bl 0x82ca9f20
	ctx.lr = 0x8328CD98;
	sub_82CA9F20(ctx, base);
	// 8328CD98: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328CD9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328CDA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328CDA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328CDA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328CDA8 size=12
    let mut pc: u32 = 0x8328CDA8;
    'dispatch: loop {
        match pc {
            0x8328CDA8 => {
    //   block [0x8328CDA8..0x8328CDB4)
	// 8328CDA8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328CDAC: 386B3C78  addi r3, r11, 0x3c78
	ctx.r[3].s64 = ctx.r[11].s64 + 15480;
	// 8328CDB0: 4BA1D170  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328CDB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328CDB8 size=64
    let mut pc: u32 = 0x8328CDB8;
    'dispatch: loop {
        match pc {
            0x8328CDB8 => {
    //   block [0x8328CDB8..0x8328CDF8)
	// 8328CDB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328CDBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328CDC0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328CDC4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328CDC8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328CDCC: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328CDD0: 386AFB40  addi r3, r10, -0x4c0
	ctx.r[3].s64 = ctx.r[10].s64 + -1216;
	// 8328CDD4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328CDD8: 4AFA00F9  bl 0x8222ced0
	ctx.lr = 0x8328CDDC;
	sub_8222CED0(ctx, base);
	// 8328CDDC: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328CDE0: 38693CD0  addi r3, r9, 0x3cd0
	ctx.r[3].s64 = ctx.r[9].s64 + 15568;
	// 8328CDE4: 4BA1D13D  bl 0x82ca9f20
	ctx.lr = 0x8328CDE8;
	sub_82CA9F20(ctx, base);
	// 8328CDE8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328CDEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328CDF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328CDF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328CDF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328CDF8 size=64
    let mut pc: u32 = 0x8328CDF8;
    'dispatch: loop {
        match pc {
            0x8328CDF8 => {
    //   block [0x8328CDF8..0x8328CE38)
	// 8328CDF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328CDFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328CE00: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328CE04: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328CE08: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328CE0C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328CE10: 386AFB44  addi r3, r10, -0x4bc
	ctx.r[3].s64 = ctx.r[10].s64 + -1212;
	// 8328CE14: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328CE18: 4AFA00B9  bl 0x8222ced0
	ctx.lr = 0x8328CE1C;
	sub_8222CED0(ctx, base);
	// 8328CE1C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328CE20: 38693CE0  addi r3, r9, 0x3ce0
	ctx.r[3].s64 = ctx.r[9].s64 + 15584;
	// 8328CE24: 4BA1D0FD  bl 0x82ca9f20
	ctx.lr = 0x8328CE28;
	sub_82CA9F20(ctx, base);
	// 8328CE28: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328CE2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328CE30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328CE34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328CE38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328CE38 size=144
    let mut pc: u32 = 0x8328CE38;
    'dispatch: loop {
        match pc {
            0x8328CE38 => {
    //   block [0x8328CE38..0x8328CE5C)
	// 8328CE38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328CE3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328CE40: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328CE44: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 8328CE48: 4AF92411  bl 0x8221f258
	ctx.lr = 0x8328CE4C;
	sub_8221F258(ctx, base);
	// 8328CE4C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328CE50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8328CE54: 419A0008  beq cr6, 0x8328ce5c
	if ctx.cr[6].eq {
	pc = 0x8328CE5C; continue 'dispatch;
	}
	// 8328CE58: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x8328CE5C; continue 'dispatch;
            }
            0x8328CE5C => {
    //   block [0x8328CE5C..0x8328CE68)
	// 8328CE5C: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8328CE60: 41820008  beq 0x8328ce68
	if ctx.cr[0].eq {
	pc = 0x8328CE68; continue 'dispatch;
	}
	// 8328CE64: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x8328CE68; continue 'dispatch;
            }
            0x8328CE68 => {
    //   block [0x8328CE68..0x8328CE74)
	// 8328CE68: 35630008  addic. r11, r3, 8
	ctx.xer.ca = (ctx.r[3].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8328CE6C: 41820008  beq 0x8328ce74
	if ctx.cr[0].eq {
	pc = 0x8328CE74; continue 'dispatch;
	}
	// 8328CE70: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x8328CE74; continue 'dispatch;
            }
            0x8328CE74 => {
    //   block [0x8328CE74..0x8328CEC8)
	// 8328CE74: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 8328CE78: 99430015  stb r10, 0x15(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(21 as u32), ctx.r[10].u8 ) };
	// 8328CE7C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8328CE80: 3909FB48  addi r8, r9, -0x4b8
	ctx.r[8].s64 = ctx.r[9].s64 + -1208;
	// 8328CE84: 99630014  stb r11, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 8328CE88: 3CE0832B  lis r7, -0x7cd5
	ctx.r[7].s64 = -2094333952;
	// 8328CE8C: 90680004  stw r3, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 8328CE90: 99630015  stb r11, 0x15(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(21 as u32), ctx.r[11].u8 ) };
	// 8328CE94: 38673CF0  addi r3, r7, 0x3cf0
	ctx.r[3].s64 = ctx.r[7].s64 + 15600;
	// 8328CE98: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8328CE9C: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8328CEA0: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8328CEA4: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8328CEA8: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8328CEAC: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8328CEB0: 91480008  stw r10, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328CEB4: 4BA1D06D  bl 0x82ca9f20
	ctx.lr = 0x8328CEB8;
	sub_82CA9F20(ctx, base);
	// 8328CEB8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328CEBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328CEC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328CEC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328CEC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328CEC8 size=96
    let mut pc: u32 = 0x8328CEC8;
    'dispatch: loop {
        match pc {
            0x8328CEC8 => {
    //   block [0x8328CEC8..0x8328CEEC)
	// 8328CEC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328CECC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328CED0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328CED4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8328CED8: 4AF92381  bl 0x8221f258
	ctx.lr = 0x8328CEDC;
	sub_8221F258(ctx, base);
	// 8328CEDC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8328CEE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8328CEE4: 419A0008  beq cr6, 0x8328ceec
	if ctx.cr[6].eq {
	pc = 0x8328CEEC; continue 'dispatch;
	}
	// 8328CEE8: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x8328CEEC; continue 'dispatch;
            }
            0x8328CEEC => {
    //   block [0x8328CEEC..0x8328CEF8)
	// 8328CEEC: 354B0004  addic. r10, r11, 4
	ctx.xer.ca = (ctx.r[11].u32 > (!(4 as u32)));
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8328CEF0: 41820008  beq 0x8328cef8
	if ctx.cr[0].eq {
	pc = 0x8328CEF8; continue 'dispatch;
	}
	// 8328CEF4: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x8328CEF8; continue 'dispatch;
            }
            0x8328CEF8 => {
    //   block [0x8328CEF8..0x8328CF28)
	// 8328CEF8: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 8328CEFC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328CF00: 3909FB54  addi r8, r9, -0x4ac
	ctx.r[8].s64 = ctx.r[9].s64 + -1196;
	// 8328CF04: 3CE0832B  lis r7, -0x7cd5
	ctx.r[7].s64 = -2094333952;
	// 8328CF08: 38673D00  addi r3, r7, 0x3d00
	ctx.r[3].s64 = ctx.r[7].s64 + 15616;
	// 8328CF0C: 91680004  stw r11, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8328CF10: 91480008  stw r10, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328CF14: 4BA1D00D  bl 0x82ca9f20
	ctx.lr = 0x8328CF18;
	sub_82CA9F20(ctx, base);
	// 8328CF18: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328CF1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328CF20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328CF24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328CF28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328CF28 size=12
    let mut pc: u32 = 0x8328CF28;
    'dispatch: loop {
        match pc {
            0x8328CF28 => {
    //   block [0x8328CF28..0x8328CF34)
	// 8328CF28: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328CF2C: 386B3D78  addi r3, r11, 0x3d78
	ctx.r[3].s64 = ctx.r[11].s64 + 15736;
	// 8328CF30: 4BA1CFF0  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328CF38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328CF38 size=64
    let mut pc: u32 = 0x8328CF38;
    'dispatch: loop {
        match pc {
            0x8328CF38 => {
    //   block [0x8328CF38..0x8328CF78)
	// 8328CF38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328CF3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328CF40: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328CF44: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 8328CF48: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328CF4C: 388B6CD4  addi r4, r11, 0x6cd4
	ctx.r[4].s64 = ctx.r[11].s64 + 27860;
	// 8328CF50: 386AFB70  addi r3, r10, -0x490
	ctx.r[3].s64 = ctx.r[10].s64 + -1168;
	// 8328CF54: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328CF58: 4AF9FF79  bl 0x8222ced0
	ctx.lr = 0x8328CF5C;
	sub_8222CED0(ctx, base);
	// 8328CF5C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328CF60: 38693D88  addi r3, r9, 0x3d88
	ctx.r[3].s64 = ctx.r[9].s64 + 15752;
	// 8328CF64: 4BA1CFBD  bl 0x82ca9f20
	ctx.lr = 0x8328CF68;
	sub_82CA9F20(ctx, base);
	// 8328CF68: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328CF6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328CF70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328CF74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328CF78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328CF78 size=64
    let mut pc: u32 = 0x8328CF78;
    'dispatch: loop {
        match pc {
            0x8328CF78 => {
    //   block [0x8328CF78..0x8328CFB8)
	// 8328CF78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328CF7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328CF80: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328CF84: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 8328CF88: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328CF8C: 388B6CE4  addi r4, r11, 0x6ce4
	ctx.r[4].s64 = ctx.r[11].s64 + 27876;
	// 8328CF90: 386AFB74  addi r3, r10, -0x48c
	ctx.r[3].s64 = ctx.r[10].s64 + -1164;
	// 8328CF94: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328CF98: 4AF9FF39  bl 0x8222ced0
	ctx.lr = 0x8328CF9C;
	sub_8222CED0(ctx, base);
	// 8328CF9C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328CFA0: 38693D98  addi r3, r9, 0x3d98
	ctx.r[3].s64 = ctx.r[9].s64 + 15768;
	// 8328CFA4: 4BA1CF7D  bl 0x82ca9f20
	ctx.lr = 0x8328CFA8;
	sub_82CA9F20(ctx, base);
	// 8328CFA8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328CFAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328CFB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328CFB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328CFB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328CFB8 size=64
    let mut pc: u32 = 0x8328CFB8;
    'dispatch: loop {
        match pc {
            0x8328CFB8 => {
    //   block [0x8328CFB8..0x8328CFF8)
	// 8328CFB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328CFBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328CFC0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328CFC4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328CFC8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328CFCC: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328CFD0: 386AFB78  addi r3, r10, -0x488
	ctx.r[3].s64 = ctx.r[10].s64 + -1160;
	// 8328CFD4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328CFD8: 4AF9FEF9  bl 0x8222ced0
	ctx.lr = 0x8328CFDC;
	sub_8222CED0(ctx, base);
	// 8328CFDC: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328CFE0: 38693DA8  addi r3, r9, 0x3da8
	ctx.r[3].s64 = ctx.r[9].s64 + 15784;
	// 8328CFE4: 4BA1CF3D  bl 0x82ca9f20
	ctx.lr = 0x8328CFE8;
	sub_82CA9F20(ctx, base);
	// 8328CFE8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328CFEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328CFF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328CFF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328CFF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328CFF8 size=64
    let mut pc: u32 = 0x8328CFF8;
    'dispatch: loop {
        match pc {
            0x8328CFF8 => {
    //   block [0x8328CFF8..0x8328D038)
	// 8328CFF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328CFFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328D000: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328D004: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328D008: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328D00C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328D010: 386AFB7C  addi r3, r10, -0x484
	ctx.r[3].s64 = ctx.r[10].s64 + -1156;
	// 8328D014: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328D018: 4AF9FEB9  bl 0x8222ced0
	ctx.lr = 0x8328D01C;
	sub_8222CED0(ctx, base);
	// 8328D01C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328D020: 38693DB8  addi r3, r9, 0x3db8
	ctx.r[3].s64 = ctx.r[9].s64 + 15800;
	// 8328D024: 4BA1CEFD  bl 0x82ca9f20
	ctx.lr = 0x8328D028;
	sub_82CA9F20(ctx, base);
	// 8328D028: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328D02C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328D030: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328D034: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328D038 size=40
    let mut pc: u32 = 0x8328D038;
    'dispatch: loop {
        match pc {
            0x8328D038 => {
    //   block [0x8328D038..0x8328D060)
	// 8328D038: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8328D03C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328D040: 396BFB80  addi r11, r11, -0x480
	ctx.r[11].s64 = ctx.r[11].s64 + -1152;
	// 8328D044: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328D048: 38693DC8  addi r3, r9, 0x3dc8
	ctx.r[3].s64 = ctx.r[9].s64 + 15816;
	// 8328D04C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328D050: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328D054: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 8328D058: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8328D05C: 4BA1CEC4  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328D060 size=64
    let mut pc: u32 = 0x8328D060;
    'dispatch: loop {
        match pc {
            0x8328D060 => {
    //   block [0x8328D060..0x8328D0A0)
	// 8328D060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328D064: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328D068: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328D06C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328D070: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328D074: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328D078: 386AFB94  addi r3, r10, -0x46c
	ctx.r[3].s64 = ctx.r[10].s64 + -1132;
	// 8328D07C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328D080: 4AF9FE51  bl 0x8222ced0
	ctx.lr = 0x8328D084;
	sub_8222CED0(ctx, base);
	// 8328D084: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328D088: 38693DE0  addi r3, r9, 0x3de0
	ctx.r[3].s64 = ctx.r[9].s64 + 15840;
	// 8328D08C: 4BA1CE95  bl 0x82ca9f20
	ctx.lr = 0x8328D090;
	sub_82CA9F20(ctx, base);
	// 8328D090: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328D094: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328D098: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328D09C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D0A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328D0A0 size=64
    let mut pc: u32 = 0x8328D0A0;
    'dispatch: loop {
        match pc {
            0x8328D0A0 => {
    //   block [0x8328D0A0..0x8328D0E0)
	// 8328D0A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328D0A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328D0A8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328D0AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328D0B0: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328D0B4: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328D0B8: 386AFB98  addi r3, r10, -0x468
	ctx.r[3].s64 = ctx.r[10].s64 + -1128;
	// 8328D0BC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328D0C0: 4AF9FE11  bl 0x8222ced0
	ctx.lr = 0x8328D0C4;
	sub_8222CED0(ctx, base);
	// 8328D0C4: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328D0C8: 38693DF0  addi r3, r9, 0x3df0
	ctx.r[3].s64 = ctx.r[9].s64 + 15856;
	// 8328D0CC: 4BA1CE55  bl 0x82ca9f20
	ctx.lr = 0x8328D0D0;
	sub_82CA9F20(ctx, base);
	// 8328D0D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328D0D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328D0D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328D0DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D0E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328D0E0 size=96
    let mut pc: u32 = 0x8328D0E0;
    'dispatch: loop {
        match pc {
            0x8328D0E0 => {
    //   block [0x8328D0E0..0x8328D104)
	// 8328D0E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328D0E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328D0E8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328D0EC: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 8328D0F0: 4AF92169  bl 0x8221f258
	ctx.lr = 0x8328D0F4;
	sub_8221F258(ctx, base);
	// 8328D0F4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8328D0F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8328D0FC: 419A0008  beq cr6, 0x8328d104
	if ctx.cr[6].eq {
	pc = 0x8328D104; continue 'dispatch;
	}
	// 8328D100: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x8328D104; continue 'dispatch;
            }
            0x8328D104 => {
    //   block [0x8328D104..0x8328D110)
	// 8328D104: 354B0004  addic. r10, r11, 4
	ctx.xer.ca = (ctx.r[11].u32 > (!(4 as u32)));
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8328D108: 41820008  beq 0x8328d110
	if ctx.cr[0].eq {
	pc = 0x8328D110; continue 'dispatch;
	}
	// 8328D10C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x8328D110; continue 'dispatch;
            }
            0x8328D110 => {
    //   block [0x8328D110..0x8328D140)
	// 8328D110: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 8328D114: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328D118: 3909FB9C  addi r8, r9, -0x464
	ctx.r[8].s64 = ctx.r[9].s64 + -1124;
	// 8328D11C: 3CE0832B  lis r7, -0x7cd5
	ctx.r[7].s64 = -2094333952;
	// 8328D120: 38673E00  addi r3, r7, 0x3e00
	ctx.r[3].s64 = ctx.r[7].s64 + 15872;
	// 8328D124: 91680004  stw r11, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8328D128: 91480008  stw r10, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328D12C: 4BA1CDF5  bl 0x82ca9f20
	ctx.lr = 0x8328D130;
	sub_82CA9F20(ctx, base);
	// 8328D130: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328D134: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328D138: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328D13C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8328D140 size=104
    let mut pc: u32 = 0x8328D140;
    'dispatch: loop {
        match pc {
            0x8328D140 => {
    //   block [0x8328D140..0x8328D160)
	// 8328D140: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8328D144: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 8328D148: 396BFBD0  addi r11, r11, -0x430
	ctx.r[11].s64 = ctx.r[11].s64 + -1072;
	// 8328D14C: 39200031  li r9, 0x31
	ctx.r[9].s64 = 49;
	// 8328D150: 396B0048  addi r11, r11, 0x48
	ctx.r[11].s64 = ctx.r[11].s64 + 72;
	// 8328D154: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328D158: C0079484  lfs f0, -0x6b7c(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8328D15C: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	pc = 0x8328D160; continue 'dispatch;
            }
            0x8328D160 => {
    //   block [0x8328D160..0x8328D1A8)
	// 8328D160: 914BFFBC  stw r10, -0x44(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-68 as u32), ctx.r[10].u32 ) };
	// 8328D164: D00BFFF0  stfs f0, -0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 8328D168: 914BFFB8  stw r10, -0x48(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-72 as u32), ctx.r[10].u32 ) };
	// 8328D16C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8328D170: 994BFFF4  stb r10, -0xc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), ctx.r[10].u8 ) };
	// 8328D174: 914BFFF8  stw r10, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[10].u32 ) };
	// 8328D178: 914BFFFC  stw r10, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[10].u32 ) };
	// 8328D17C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 8328D180: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328D184: 994B0014  stb r10, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 8328D188: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328D18C: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 8328D190: 910B0010  stw r8, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 8328D194: 396B0060  addi r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 + 96;
	// 8328D198: 4080FFC8  bge 0x8328d160
	if !ctx.cr[0].lt {
	pc = 0x8328D160; continue 'dispatch;
	}
	// 8328D19C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328D1A0: 386B3E48  addi r3, r11, 0x3e48
	ctx.r[3].s64 = ctx.r[11].s64 + 15944;
	// 8328D1A4: 4BA1CD7C  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D1A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328D1A8 size=12
    let mut pc: u32 = 0x8328D1A8;
    'dispatch: loop {
        match pc {
            0x8328D1A8 => {
    //   block [0x8328D1A8..0x8328D1B4)
	// 8328D1A8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328D1AC: 386B3E98  addi r3, r11, 0x3e98
	ctx.r[3].s64 = ctx.r[11].s64 + 16024;
	// 8328D1B0: 4BA1CD70  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D1B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328D1B8 size=12
    let mut pc: u32 = 0x8328D1B8;
    'dispatch: loop {
        match pc {
            0x8328D1B8 => {
    //   block [0x8328D1B8..0x8328D1C4)
	// 8328D1B8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328D1BC: 386B3ED8  addi r3, r11, 0x3ed8
	ctx.r[3].s64 = ctx.r[11].s64 + 16088;
	// 8328D1C0: 4BA1CD60  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D1C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328D1C8 size=40
    let mut pc: u32 = 0x8328D1C8;
    'dispatch: loop {
        match pc {
            0x8328D1C8 => {
    //   block [0x8328D1C8..0x8328D1F0)
	// 8328D1C8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8328D1CC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328D1D0: 396BFBA8  addi r11, r11, -0x458
	ctx.r[11].s64 = ctx.r[11].s64 + -1112;
	// 8328D1D4: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328D1D8: 38693F18  addi r3, r9, 0x3f18
	ctx.r[3].s64 = ctx.r[9].s64 + 16152;
	// 8328D1DC: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328D1E0: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328D1E4: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 8328D1E8: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8328D1EC: 4BA1CD34  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D1F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328D1F0 size=40
    let mut pc: u32 = 0x8328D1F0;
    'dispatch: loop {
        match pc {
            0x8328D1F0 => {
    //   block [0x8328D1F0..0x8328D218)
	// 8328D1F0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8328D1F4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328D1F8: 396BFBBC  addi r11, r11, -0x444
	ctx.r[11].s64 = ctx.r[11].s64 + -1092;
	// 8328D1FC: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328D200: 38693F30  addi r3, r9, 0x3f30
	ctx.r[3].s64 = ctx.r[9].s64 + 16176;
	// 8328D204: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328D208: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328D20C: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 8328D210: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8328D214: 4BA1CD0C  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328D218 size=64
    let mut pc: u32 = 0x8328D218;
    'dispatch: loop {
        match pc {
            0x8328D218 => {
    //   block [0x8328D218..0x8328D258)
	// 8328D218: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328D21C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328D220: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328D224: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328D228: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328D22C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328D230: 386A0E9C  addi r3, r10, 0xe9c
	ctx.r[3].s64 = ctx.r[10].s64 + 3740;
	// 8328D234: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328D238: 4AF9FC99  bl 0x8222ced0
	ctx.lr = 0x8328D23C;
	sub_8222CED0(ctx, base);
	// 8328D23C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328D240: 38693F48  addi r3, r9, 0x3f48
	ctx.r[3].s64 = ctx.r[9].s64 + 16200;
	// 8328D244: 4BA1CCDD  bl 0x82ca9f20
	ctx.lr = 0x8328D248;
	sub_82CA9F20(ctx, base);
	// 8328D248: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328D24C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328D250: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328D254: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328D258 size=64
    let mut pc: u32 = 0x8328D258;
    'dispatch: loop {
        match pc {
            0x8328D258 => {
    //   block [0x8328D258..0x8328D298)
	// 8328D258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328D25C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328D260: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328D264: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328D268: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328D26C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328D270: 386A0EA0  addi r3, r10, 0xea0
	ctx.r[3].s64 = ctx.r[10].s64 + 3744;
	// 8328D274: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328D278: 4AF9FC59  bl 0x8222ced0
	ctx.lr = 0x8328D27C;
	sub_8222CED0(ctx, base);
	// 8328D27C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328D280: 38693F58  addi r3, r9, 0x3f58
	ctx.r[3].s64 = ctx.r[9].s64 + 16216;
	// 8328D284: 4BA1CC9D  bl 0x82ca9f20
	ctx.lr = 0x8328D288;
	sub_82CA9F20(ctx, base);
	// 8328D288: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328D28C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328D290: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328D294: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328D298 size=68
    let mut pc: u32 = 0x8328D298;
    'dispatch: loop {
        match pc {
            0x8328D298 => {
    //   block [0x8328D298..0x8328D2DC)
	// 8328D298: 3CC0820F  lis r6, -0x7df1
	ctx.r[6].s64 = -2112946176;
	// 8328D29C: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 8328D2A0: 39062A30  addi r8, r6, 0x2a30
	ctx.r[8].s64 = ctx.r[6].s64 + 10800;
	// 8328D2A4: 38A70EA4  addi r5, r7, 0xea4
	ctx.r[5].s64 = ctx.r[7].s64 + 3748;
	// 8328D2A8: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 8328D2AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8328D2B0: 91470EA4  stw r10, 0xea4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(3748 as u32), ctx.r[10].u32 ) };
	// 8328D2B4: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 8328D2B8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328D2BC: 3C80832B  lis r4, -0x7cd5
	ctx.r[4].s64 = -2094333952;
	// 8328D2C0: 91650004  stw r11, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8328D2C4: 91250008  stw r9, 8(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 8328D2C8: 9165000C  stw r11, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 8328D2CC: 38643F68  addi r3, r4, 0x3f68
	ctx.r[3].s64 = ctx.r[4].s64 + 16232;
	// 8328D2D0: 91450014  stw r10, 0x14(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 8328D2D4: 91050010  stw r8, 0x10(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 8328D2D8: 4BA1CC48  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D2E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328D2E0 size=68
    let mut pc: u32 = 0x8328D2E0;
    'dispatch: loop {
        match pc {
            0x8328D2E0 => {
    //   block [0x8328D2E0..0x8328D324)
	// 8328D2E0: 3CC0820F  lis r6, -0x7df1
	ctx.r[6].s64 = -2112946176;
	// 8328D2E4: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 8328D2E8: 39062A30  addi r8, r6, 0x2a30
	ctx.r[8].s64 = ctx.r[6].s64 + 10800;
	// 8328D2EC: 38A70F60  addi r5, r7, 0xf60
	ctx.r[5].s64 = ctx.r[7].s64 + 3936;
	// 8328D2F0: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 8328D2F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8328D2F8: 91470F60  stw r10, 0xf60(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(3936 as u32), ctx.r[10].u32 ) };
	// 8328D2FC: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 8328D300: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328D304: 3C80832B  lis r4, -0x7cd5
	ctx.r[4].s64 = -2094333952;
	// 8328D308: 91650004  stw r11, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8328D30C: 91250008  stw r9, 8(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 8328D310: 9165000C  stw r11, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 8328D314: 38643FC0  addi r3, r4, 0x3fc0
	ctx.r[3].s64 = ctx.r[4].s64 + 16320;
	// 8328D318: 91450014  stw r10, 0x14(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 8328D31C: 91050010  stw r8, 0x10(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 8328D320: 4BA1CC00  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328D328 size=64
    let mut pc: u32 = 0x8328D328;
    'dispatch: loop {
        match pc {
            0x8328D328 => {
    //   block [0x8328D328..0x8328D368)
	// 8328D328: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328D32C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328D330: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328D334: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328D338: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328D33C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328D340: 386A0F78  addi r3, r10, 0xf78
	ctx.r[3].s64 = ctx.r[10].s64 + 3960;
	// 8328D344: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328D348: 4AF9FB89  bl 0x8222ced0
	ctx.lr = 0x8328D34C;
	sub_8222CED0(ctx, base);
	// 8328D34C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328D350: 38694018  addi r3, r9, 0x4018
	ctx.r[3].s64 = ctx.r[9].s64 + 16408;
	// 8328D354: 4BA1CBCD  bl 0x82ca9f20
	ctx.lr = 0x8328D358;
	sub_82CA9F20(ctx, base);
	// 8328D358: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328D35C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328D360: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328D364: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328D368 size=64
    let mut pc: u32 = 0x8328D368;
    'dispatch: loop {
        match pc {
            0x8328D368 => {
    //   block [0x8328D368..0x8328D3A8)
	// 8328D368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328D36C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328D370: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328D374: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328D378: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328D37C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328D380: 386A0F7C  addi r3, r10, 0xf7c
	ctx.r[3].s64 = ctx.r[10].s64 + 3964;
	// 8328D384: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328D388: 4AF9FB49  bl 0x8222ced0
	ctx.lr = 0x8328D38C;
	sub_8222CED0(ctx, base);
	// 8328D38C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328D390: 38694028  addi r3, r9, 0x4028
	ctx.r[3].s64 = ctx.r[9].s64 + 16424;
	// 8328D394: 4BA1CB8D  bl 0x82ca9f20
	ctx.lr = 0x8328D398;
	sub_82CA9F20(ctx, base);
	// 8328D398: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328D39C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328D3A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328D3A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D3A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328D3A8 size=64
    let mut pc: u32 = 0x8328D3A8;
    'dispatch: loop {
        match pc {
            0x8328D3A8 => {
    //   block [0x8328D3A8..0x8328D3E8)
	// 8328D3A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328D3AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328D3B0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328D3B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328D3B8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328D3BC: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328D3C0: 386A0F80  addi r3, r10, 0xf80
	ctx.r[3].s64 = ctx.r[10].s64 + 3968;
	// 8328D3C4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328D3C8: 4AF9FB09  bl 0x8222ced0
	ctx.lr = 0x8328D3CC;
	sub_8222CED0(ctx, base);
	// 8328D3CC: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328D3D0: 38694038  addi r3, r9, 0x4038
	ctx.r[3].s64 = ctx.r[9].s64 + 16440;
	// 8328D3D4: 4BA1CB4D  bl 0x82ca9f20
	ctx.lr = 0x8328D3D8;
	sub_82CA9F20(ctx, base);
	// 8328D3D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328D3DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328D3E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328D3E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D3E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328D3E8 size=64
    let mut pc: u32 = 0x8328D3E8;
    'dispatch: loop {
        match pc {
            0x8328D3E8 => {
    //   block [0x8328D3E8..0x8328D428)
	// 8328D3E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328D3EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328D3F0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328D3F4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328D3F8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328D3FC: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328D400: 386A0F84  addi r3, r10, 0xf84
	ctx.r[3].s64 = ctx.r[10].s64 + 3972;
	// 8328D404: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328D408: 4AF9FAC9  bl 0x8222ced0
	ctx.lr = 0x8328D40C;
	sub_8222CED0(ctx, base);
	// 8328D40C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328D410: 38694048  addi r3, r9, 0x4048
	ctx.r[3].s64 = ctx.r[9].s64 + 16456;
	// 8328D414: 4BA1CB0D  bl 0x82ca9f20
	ctx.lr = 0x8328D418;
	sub_82CA9F20(ctx, base);
	// 8328D418: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328D41C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328D420: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328D424: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328D428 size=64
    let mut pc: u32 = 0x8328D428;
    'dispatch: loop {
        match pc {
            0x8328D428 => {
    //   block [0x8328D428..0x8328D468)
	// 8328D428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328D42C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328D430: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328D434: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328D438: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328D43C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328D440: 386A0F88  addi r3, r10, 0xf88
	ctx.r[3].s64 = ctx.r[10].s64 + 3976;
	// 8328D444: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328D448: 4AF9FA89  bl 0x8222ced0
	ctx.lr = 0x8328D44C;
	sub_8222CED0(ctx, base);
	// 8328D44C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328D450: 38694058  addi r3, r9, 0x4058
	ctx.r[3].s64 = ctx.r[9].s64 + 16472;
	// 8328D454: 4BA1CACD  bl 0x82ca9f20
	ctx.lr = 0x8328D458;
	sub_82CA9F20(ctx, base);
	// 8328D458: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328D45C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328D460: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328D464: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328D468 size=64
    let mut pc: u32 = 0x8328D468;
    'dispatch: loop {
        match pc {
            0x8328D468 => {
    //   block [0x8328D468..0x8328D4A8)
	// 8328D468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328D46C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328D470: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328D474: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328D478: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328D47C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328D480: 386A0F8C  addi r3, r10, 0xf8c
	ctx.r[3].s64 = ctx.r[10].s64 + 3980;
	// 8328D484: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328D488: 4AF9FA49  bl 0x8222ced0
	ctx.lr = 0x8328D48C;
	sub_8222CED0(ctx, base);
	// 8328D48C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328D490: 38694068  addi r3, r9, 0x4068
	ctx.r[3].s64 = ctx.r[9].s64 + 16488;
	// 8328D494: 4BA1CA8D  bl 0x82ca9f20
	ctx.lr = 0x8328D498;
	sub_82CA9F20(ctx, base);
	// 8328D498: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328D49C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328D4A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328D4A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D4A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328D4A8 size=64
    let mut pc: u32 = 0x8328D4A8;
    'dispatch: loop {
        match pc {
            0x8328D4A8 => {
    //   block [0x8328D4A8..0x8328D4E8)
	// 8328D4A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328D4AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328D4B0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328D4B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328D4B8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328D4BC: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328D4C0: 386A0F90  addi r3, r10, 0xf90
	ctx.r[3].s64 = ctx.r[10].s64 + 3984;
	// 8328D4C4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328D4C8: 4AF9FA09  bl 0x8222ced0
	ctx.lr = 0x8328D4CC;
	sub_8222CED0(ctx, base);
	// 8328D4CC: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328D4D0: 38694078  addi r3, r9, 0x4078
	ctx.r[3].s64 = ctx.r[9].s64 + 16504;
	// 8328D4D4: 4BA1CA4D  bl 0x82ca9f20
	ctx.lr = 0x8328D4D8;
	sub_82CA9F20(ctx, base);
	// 8328D4D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328D4DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328D4E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328D4E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D4E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328D4E8 size=64
    let mut pc: u32 = 0x8328D4E8;
    'dispatch: loop {
        match pc {
            0x8328D4E8 => {
    //   block [0x8328D4E8..0x8328D528)
	// 8328D4E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328D4EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328D4F0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328D4F4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328D4F8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328D4FC: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328D500: 386A0F94  addi r3, r10, 0xf94
	ctx.r[3].s64 = ctx.r[10].s64 + 3988;
	// 8328D504: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328D508: 4AF9F9C9  bl 0x8222ced0
	ctx.lr = 0x8328D50C;
	sub_8222CED0(ctx, base);
	// 8328D50C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328D510: 38694088  addi r3, r9, 0x4088
	ctx.r[3].s64 = ctx.r[9].s64 + 16520;
	// 8328D514: 4BA1CA0D  bl 0x82ca9f20
	ctx.lr = 0x8328D518;
	sub_82CA9F20(ctx, base);
	// 8328D518: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328D51C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328D520: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328D524: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328D528 size=64
    let mut pc: u32 = 0x8328D528;
    'dispatch: loop {
        match pc {
            0x8328D528 => {
    //   block [0x8328D528..0x8328D568)
	// 8328D528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328D52C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328D530: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328D534: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328D538: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328D53C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328D540: 386A0F98  addi r3, r10, 0xf98
	ctx.r[3].s64 = ctx.r[10].s64 + 3992;
	// 8328D544: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328D548: 4AF9F989  bl 0x8222ced0
	ctx.lr = 0x8328D54C;
	sub_8222CED0(ctx, base);
	// 8328D54C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328D550: 38694098  addi r3, r9, 0x4098
	ctx.r[3].s64 = ctx.r[9].s64 + 16536;
	// 8328D554: 4BA1C9CD  bl 0x82ca9f20
	ctx.lr = 0x8328D558;
	sub_82CA9F20(ctx, base);
	// 8328D558: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328D55C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328D560: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328D564: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328D568 size=64
    let mut pc: u32 = 0x8328D568;
    'dispatch: loop {
        match pc {
            0x8328D568 => {
    //   block [0x8328D568..0x8328D5A8)
	// 8328D568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328D56C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328D570: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328D574: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328D578: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328D57C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328D580: 386A0F9C  addi r3, r10, 0xf9c
	ctx.r[3].s64 = ctx.r[10].s64 + 3996;
	// 8328D584: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328D588: 4AF9F949  bl 0x8222ced0
	ctx.lr = 0x8328D58C;
	sub_8222CED0(ctx, base);
	// 8328D58C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328D590: 386940A8  addi r3, r9, 0x40a8
	ctx.r[3].s64 = ctx.r[9].s64 + 16552;
	// 8328D594: 4BA1C98D  bl 0x82ca9f20
	ctx.lr = 0x8328D598;
	sub_82CA9F20(ctx, base);
	// 8328D598: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328D59C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328D5A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328D5A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D5A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328D5A8 size=64
    let mut pc: u32 = 0x8328D5A8;
    'dispatch: loop {
        match pc {
            0x8328D5A8 => {
    //   block [0x8328D5A8..0x8328D5E8)
	// 8328D5A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328D5AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328D5B0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328D5B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328D5B8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328D5BC: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328D5C0: 386A0FA0  addi r3, r10, 0xfa0
	ctx.r[3].s64 = ctx.r[10].s64 + 4000;
	// 8328D5C4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328D5C8: 4AF9F909  bl 0x8222ced0
	ctx.lr = 0x8328D5CC;
	sub_8222CED0(ctx, base);
	// 8328D5CC: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328D5D0: 386940B8  addi r3, r9, 0x40b8
	ctx.r[3].s64 = ctx.r[9].s64 + 16568;
	// 8328D5D4: 4BA1C94D  bl 0x82ca9f20
	ctx.lr = 0x8328D5D8;
	sub_82CA9F20(ctx, base);
	// 8328D5D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328D5DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328D5E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328D5E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D5E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328D5E8 size=64
    let mut pc: u32 = 0x8328D5E8;
    'dispatch: loop {
        match pc {
            0x8328D5E8 => {
    //   block [0x8328D5E8..0x8328D628)
	// 8328D5E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328D5EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328D5F0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328D5F4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328D5F8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328D5FC: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328D600: 386A0FA4  addi r3, r10, 0xfa4
	ctx.r[3].s64 = ctx.r[10].s64 + 4004;
	// 8328D604: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328D608: 4AF9F8C9  bl 0x8222ced0
	ctx.lr = 0x8328D60C;
	sub_8222CED0(ctx, base);
	// 8328D60C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328D610: 386940C8  addi r3, r9, 0x40c8
	ctx.r[3].s64 = ctx.r[9].s64 + 16584;
	// 8328D614: 4BA1C90D  bl 0x82ca9f20
	ctx.lr = 0x8328D618;
	sub_82CA9F20(ctx, base);
	// 8328D618: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328D61C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328D620: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328D624: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328D628 size=12
    let mut pc: u32 = 0x8328D628;
    'dispatch: loop {
        match pc {
            0x8328D628 => {
    //   block [0x8328D628..0x8328D634)
	// 8328D628: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328D62C: 386B40D8  addi r3, r11, 0x40d8
	ctx.r[3].s64 = ctx.r[11].s64 + 16600;
	// 8328D630: 4BA1C8F0  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328D638 size=12
    let mut pc: u32 = 0x8328D638;
    'dispatch: loop {
        match pc {
            0x8328D638 => {
    //   block [0x8328D638..0x8328D644)
	// 8328D638: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328D63C: 386B40E8  addi r3, r11, 0x40e8
	ctx.r[3].s64 = ctx.r[11].s64 + 16616;
	// 8328D640: 4BA1C8E0  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328D648 size=96
    let mut pc: u32 = 0x8328D648;
    'dispatch: loop {
        match pc {
            0x8328D648 => {
    //   block [0x8328D648..0x8328D66C)
	// 8328D648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328D64C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328D650: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328D654: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 8328D658: 4AF91C01  bl 0x8221f258
	ctx.lr = 0x8328D65C;
	sub_8221F258(ctx, base);
	// 8328D65C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8328D660: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8328D664: 419A0008  beq cr6, 0x8328d66c
	if ctx.cr[6].eq {
	pc = 0x8328D66C; continue 'dispatch;
	}
	// 8328D668: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x8328D66C; continue 'dispatch;
            }
            0x8328D66C => {
    //   block [0x8328D66C..0x8328D678)
	// 8328D66C: 354B0004  addic. r10, r11, 4
	ctx.xer.ca = (ctx.r[11].u32 > (!(4 as u32)));
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8328D670: 41820008  beq 0x8328d678
	if ctx.cr[0].eq {
	pc = 0x8328D678; continue 'dispatch;
	}
	// 8328D674: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x8328D678; continue 'dispatch;
            }
            0x8328D678 => {
    //   block [0x8328D678..0x8328D6A8)
	// 8328D678: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 8328D67C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328D680: 39090FF0  addi r8, r9, 0xff0
	ctx.r[8].s64 = ctx.r[9].s64 + 4080;
	// 8328D684: 3CE0832B  lis r7, -0x7cd5
	ctx.r[7].s64 = -2094333952;
	// 8328D688: 38674140  addi r3, r7, 0x4140
	ctx.r[3].s64 = ctx.r[7].s64 + 16704;
	// 8328D68C: 91680004  stw r11, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8328D690: 91480008  stw r10, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328D694: 4BA1C88D  bl 0x82ca9f20
	ctx.lr = 0x8328D698;
	sub_82CA9F20(ctx, base);
	// 8328D698: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328D69C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328D6A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328D6A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D6A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328D6A8 size=76
    let mut pc: u32 = 0x8328D6A8;
    'dispatch: loop {
        match pc {
            0x8328D6A8 => {
    //   block [0x8328D6A8..0x8328D6F4)
	// 8328D6A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328D6AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328D6B0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328D6B4: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 8328D6B8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328D6BC: 388B6EEC  addi r4, r11, 0x6eec
	ctx.r[4].s64 = ctx.r[11].s64 + 28396;
	// 8328D6C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8328D6C4: 4AF9F80D  bl 0x8222ced0
	ctx.lr = 0x8328D6C8;
	sub_8222CED0(ctx, base);
	// 8328D6C8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328D6CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8328D6D0: 386A0FFC  addi r3, r10, 0xffc
	ctx.r[3].s64 = ctx.r[10].s64 + 4092;
	// 8328D6D4: 4B01DE35  bl 0x822ab508
	ctx.lr = 0x8328D6D8;
	sub_822AB508(ctx, base);
	// 8328D6D8: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328D6DC: 38694188  addi r3, r9, 0x4188
	ctx.r[3].s64 = ctx.r[9].s64 + 16776;
	// 8328D6E0: 4BA1C841  bl 0x82ca9f20
	ctx.lr = 0x8328D6E4;
	sub_82CA9F20(ctx, base);
	// 8328D6E4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328D6E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328D6EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328D6F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D6F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328D6F8 size=76
    let mut pc: u32 = 0x8328D6F8;
    'dispatch: loop {
        match pc {
            0x8328D6F8 => {
    //   block [0x8328D6F8..0x8328D744)
	// 8328D6F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328D6FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328D700: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328D704: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 8328D708: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328D70C: 388B6F08  addi r4, r11, 0x6f08
	ctx.r[4].s64 = ctx.r[11].s64 + 28424;
	// 8328D710: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8328D714: 4AF9F7BD  bl 0x8222ced0
	ctx.lr = 0x8328D718;
	sub_8222CED0(ctx, base);
	// 8328D718: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328D71C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8328D720: 386A1048  addi r3, r10, 0x1048
	ctx.r[3].s64 = ctx.r[10].s64 + 4168;
	// 8328D724: 4B01DDE5  bl 0x822ab508
	ctx.lr = 0x8328D728;
	sub_822AB508(ctx, base);
	// 8328D728: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328D72C: 38694198  addi r3, r9, 0x4198
	ctx.r[3].s64 = ctx.r[9].s64 + 16792;
	// 8328D730: 4BA1C7F1  bl 0x82ca9f20
	ctx.lr = 0x8328D734;
	sub_82CA9F20(ctx, base);
	// 8328D734: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328D738: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328D73C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328D740: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328D748 size=64
    let mut pc: u32 = 0x8328D748;
    'dispatch: loop {
        match pc {
            0x8328D748 => {
    //   block [0x8328D748..0x8328D788)
	// 8328D748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328D74C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328D750: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328D754: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328D758: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328D75C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328D760: 386A1094  addi r3, r10, 0x1094
	ctx.r[3].s64 = ctx.r[10].s64 + 4244;
	// 8328D764: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328D768: 4AF9F769  bl 0x8222ced0
	ctx.lr = 0x8328D76C;
	sub_8222CED0(ctx, base);
	// 8328D76C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328D770: 386941A8  addi r3, r9, 0x41a8
	ctx.r[3].s64 = ctx.r[9].s64 + 16808;
	// 8328D774: 4BA1C7AD  bl 0x82ca9f20
	ctx.lr = 0x8328D778;
	sub_82CA9F20(ctx, base);
	// 8328D778: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328D77C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328D780: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328D784: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328D788 size=64
    let mut pc: u32 = 0x8328D788;
    'dispatch: loop {
        match pc {
            0x8328D788 => {
    //   block [0x8328D788..0x8328D7C8)
	// 8328D788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328D78C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328D790: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328D794: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328D798: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328D79C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328D7A0: 386A1098  addi r3, r10, 0x1098
	ctx.r[3].s64 = ctx.r[10].s64 + 4248;
	// 8328D7A4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328D7A8: 4AF9F729  bl 0x8222ced0
	ctx.lr = 0x8328D7AC;
	sub_8222CED0(ctx, base);
	// 8328D7AC: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328D7B0: 386941B8  addi r3, r9, 0x41b8
	ctx.r[3].s64 = ctx.r[9].s64 + 16824;
	// 8328D7B4: 4BA1C76D  bl 0x82ca9f20
	ctx.lr = 0x8328D7B8;
	sub_82CA9F20(ctx, base);
	// 8328D7B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328D7BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328D7C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328D7C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D7C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328D7C8 size=64
    let mut pc: u32 = 0x8328D7C8;
    'dispatch: loop {
        match pc {
            0x8328D7C8 => {
    //   block [0x8328D7C8..0x8328D808)
	// 8328D7C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328D7CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328D7D0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328D7D4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328D7D8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328D7DC: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328D7E0: 386A109C  addi r3, r10, 0x109c
	ctx.r[3].s64 = ctx.r[10].s64 + 4252;
	// 8328D7E4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328D7E8: 4AF9F6E9  bl 0x8222ced0
	ctx.lr = 0x8328D7EC;
	sub_8222CED0(ctx, base);
	// 8328D7EC: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328D7F0: 386941C8  addi r3, r9, 0x41c8
	ctx.r[3].s64 = ctx.r[9].s64 + 16840;
	// 8328D7F4: 4BA1C72D  bl 0x82ca9f20
	ctx.lr = 0x8328D7F8;
	sub_82CA9F20(ctx, base);
	// 8328D7F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328D7FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328D800: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328D804: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328D808 size=64
    let mut pc: u32 = 0x8328D808;
    'dispatch: loop {
        match pc {
            0x8328D808 => {
    //   block [0x8328D808..0x8328D848)
	// 8328D808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328D80C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328D810: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328D814: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328D818: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328D81C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328D820: 386A10A0  addi r3, r10, 0x10a0
	ctx.r[3].s64 = ctx.r[10].s64 + 4256;
	// 8328D824: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328D828: 4AF9F6A9  bl 0x8222ced0
	ctx.lr = 0x8328D82C;
	sub_8222CED0(ctx, base);
	// 8328D82C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328D830: 386941D8  addi r3, r9, 0x41d8
	ctx.r[3].s64 = ctx.r[9].s64 + 16856;
	// 8328D834: 4BA1C6ED  bl 0x82ca9f20
	ctx.lr = 0x8328D838;
	sub_82CA9F20(ctx, base);
	// 8328D838: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328D83C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328D840: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328D844: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328D848 size=64
    let mut pc: u32 = 0x8328D848;
    'dispatch: loop {
        match pc {
            0x8328D848 => {
    //   block [0x8328D848..0x8328D888)
	// 8328D848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328D84C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328D850: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328D854: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328D858: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328D85C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328D860: 386A10A4  addi r3, r10, 0x10a4
	ctx.r[3].s64 = ctx.r[10].s64 + 4260;
	// 8328D864: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328D868: 4AF9F669  bl 0x8222ced0
	ctx.lr = 0x8328D86C;
	sub_8222CED0(ctx, base);
	// 8328D86C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328D870: 386941E8  addi r3, r9, 0x41e8
	ctx.r[3].s64 = ctx.r[9].s64 + 16872;
	// 8328D874: 4BA1C6AD  bl 0x82ca9f20
	ctx.lr = 0x8328D878;
	sub_82CA9F20(ctx, base);
	// 8328D878: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328D87C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328D880: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328D884: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328D888 size=64
    let mut pc: u32 = 0x8328D888;
    'dispatch: loop {
        match pc {
            0x8328D888 => {
    //   block [0x8328D888..0x8328D8C8)
	// 8328D888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328D88C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328D890: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328D894: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328D898: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328D89C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328D8A0: 386A10A8  addi r3, r10, 0x10a8
	ctx.r[3].s64 = ctx.r[10].s64 + 4264;
	// 8328D8A4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328D8A8: 4AF9F629  bl 0x8222ced0
	ctx.lr = 0x8328D8AC;
	sub_8222CED0(ctx, base);
	// 8328D8AC: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328D8B0: 386941F8  addi r3, r9, 0x41f8
	ctx.r[3].s64 = ctx.r[9].s64 + 16888;
	// 8328D8B4: 4BA1C66D  bl 0x82ca9f20
	ctx.lr = 0x8328D8B8;
	sub_82CA9F20(ctx, base);
	// 8328D8B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328D8BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328D8C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328D8C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328D8C8 size=40
    let mut pc: u32 = 0x8328D8C8;
    'dispatch: loop {
        match pc {
            0x8328D8C8 => {
    //   block [0x8328D8C8..0x8328D8F0)
	// 8328D8C8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8328D8CC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328D8D0: 396B10AC  addi r11, r11, 0x10ac
	ctx.r[11].s64 = ctx.r[11].s64 + 4268;
	// 8328D8D4: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328D8D8: 38694208  addi r3, r9, 0x4208
	ctx.r[3].s64 = ctx.r[9].s64 + 16904;
	// 8328D8DC: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328D8E0: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328D8E4: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 8328D8E8: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8328D8EC: 4BA1C634  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D8F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328D8F0 size=40
    let mut pc: u32 = 0x8328D8F0;
    'dispatch: loop {
        match pc {
            0x8328D8F0 => {
    //   block [0x8328D8F0..0x8328D918)
	// 8328D8F0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8328D8F4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328D8F8: 396B10C0  addi r11, r11, 0x10c0
	ctx.r[11].s64 = ctx.r[11].s64 + 4288;
	// 8328D8FC: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328D900: 38694220  addi r3, r9, 0x4220
	ctx.r[3].s64 = ctx.r[9].s64 + 16928;
	// 8328D904: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328D908: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328D90C: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 8328D910: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8328D914: 4BA1C60C  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328D918 size=40
    let mut pc: u32 = 0x8328D918;
    'dispatch: loop {
        match pc {
            0x8328D918 => {
    //   block [0x8328D918..0x8328D940)
	// 8328D918: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8328D91C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328D920: 396B10D4  addi r11, r11, 0x10d4
	ctx.r[11].s64 = ctx.r[11].s64 + 4308;
	// 8328D924: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328D928: 38694238  addi r3, r9, 0x4238
	ctx.r[3].s64 = ctx.r[9].s64 + 16952;
	// 8328D92C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328D930: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328D934: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 8328D938: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8328D93C: 4BA1C5E4  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328D940 size=64
    let mut pc: u32 = 0x8328D940;
    'dispatch: loop {
        match pc {
            0x8328D940 => {
    //   block [0x8328D940..0x8328D980)
	// 8328D940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328D944: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328D948: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328D94C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328D950: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328D954: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328D958: 386A10E8  addi r3, r10, 0x10e8
	ctx.r[3].s64 = ctx.r[10].s64 + 4328;
	// 8328D95C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328D960: 4AF9F571  bl 0x8222ced0
	ctx.lr = 0x8328D964;
	sub_8222CED0(ctx, base);
	// 8328D964: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328D968: 38694250  addi r3, r9, 0x4250
	ctx.r[3].s64 = ctx.r[9].s64 + 16976;
	// 8328D96C: 4BA1C5B5  bl 0x82ca9f20
	ctx.lr = 0x8328D970;
	sub_82CA9F20(ctx, base);
	// 8328D970: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328D974: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328D978: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328D97C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328D980 size=64
    let mut pc: u32 = 0x8328D980;
    'dispatch: loop {
        match pc {
            0x8328D980 => {
    //   block [0x8328D980..0x8328D9C0)
	// 8328D980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328D984: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328D988: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328D98C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328D990: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328D994: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328D998: 386A10EC  addi r3, r10, 0x10ec
	ctx.r[3].s64 = ctx.r[10].s64 + 4332;
	// 8328D99C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328D9A0: 4AF9F531  bl 0x8222ced0
	ctx.lr = 0x8328D9A4;
	sub_8222CED0(ctx, base);
	// 8328D9A4: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328D9A8: 38694260  addi r3, r9, 0x4260
	ctx.r[3].s64 = ctx.r[9].s64 + 16992;
	// 8328D9AC: 4BA1C575  bl 0x82ca9f20
	ctx.lr = 0x8328D9B0;
	sub_82CA9F20(ctx, base);
	// 8328D9B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328D9B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328D9B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328D9BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328D9C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328D9C0 size=60
    let mut pc: u32 = 0x8328D9C0;
    'dispatch: loop {
        match pc {
            0x8328D9C0 => {
    //   block [0x8328D9C0..0x8328D9D0)
	// 8328D9C0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8328D9C4: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 8328D9C8: 396B10F0  addi r11, r11, 0x10f0
	ctx.r[11].s64 = ctx.r[11].s64 + 4336;
	// 8328D9CC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x8328D9D0; continue 'dispatch;
            }
            0x8328D9D0 => {
    //   block [0x8328D9D0..0x8328D9FC)
	// 8328D9D0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8328D9D4: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8328D9D8: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328D9DC: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328D9E0: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 8328D9E4: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8328D9E8: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 8328D9EC: 4080FFE4  bge 0x8328d9d0
	if !ctx.cr[0].lt {
	pc = 0x8328D9D0; continue 'dispatch;
	}
	// 8328D9F0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328D9F4: 386B4270  addi r3, r11, 0x4270
	ctx.r[3].s64 = ctx.r[11].s64 + 17008;
	// 8328D9F8: 4BA1C528  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328DA00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328DA00 size=40
    let mut pc: u32 = 0x8328DA00;
    'dispatch: loop {
        match pc {
            0x8328DA00 => {
    //   block [0x8328DA00..0x8328DA28)
	// 8328DA00: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8328DA04: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328DA08: 396B1140  addi r11, r11, 0x1140
	ctx.r[11].s64 = ctx.r[11].s64 + 4416;
	// 8328DA0C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328DA10: 386942C8  addi r3, r9, 0x42c8
	ctx.r[3].s64 = ctx.r[9].s64 + 17096;
	// 8328DA14: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328DA18: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328DA1C: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 8328DA20: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8328DA24: 4BA1C4FC  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328DA28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328DA28 size=40
    let mut pc: u32 = 0x8328DA28;
    'dispatch: loop {
        match pc {
            0x8328DA28 => {
    //   block [0x8328DA28..0x8328DA50)
	// 8328DA28: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8328DA2C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328DA30: 396B1154  addi r11, r11, 0x1154
	ctx.r[11].s64 = ctx.r[11].s64 + 4436;
	// 8328DA34: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328DA38: 386942E0  addi r3, r9, 0x42e0
	ctx.r[3].s64 = ctx.r[9].s64 + 17120;
	// 8328DA3C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328DA40: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328DA44: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 8328DA48: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8328DA4C: 4BA1C4D4  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328DA50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328DA50 size=72
    let mut pc: u32 = 0x8328DA50;
    'dispatch: loop {
        match pc {
            0x8328DA50 => {
    //   block [0x8328DA50..0x8328DA98)
	// 8328DA50: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 8328DA54: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 8328DA58: 38C81168  addi r6, r8, 0x1168
	ctx.r[6].s64 = ctx.r[8].s64 + 4456;
	// 8328DA5C: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 8328DA60: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 8328DA64: 91681168  stw r11, 0x1168(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4456 as u32), ctx.r[11].u32 ) };
	// 8328DA68: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 8328DA6C: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 8328DA70: 91460004  stw r10, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328DA74: 91260008  stw r9, 8(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 8328DA78: 9106000C  stw r8, 0xc(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 8328DA7C: 91660010  stw r11, 0x10(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 8328DA80: 90E60014  stw r7, 0x14(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	// 8328DA84: 91460018  stw r10, 0x18(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 8328DA88: 9126001C  stw r9, 0x1c(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 8328DA8C: 91060020  stw r8, 0x20(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(32 as u32), ctx.r[8].u32 ) };
	// 8328DA90: 91660024  stw r11, 0x24(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 8328DA94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328DA98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328DA98 size=64
    let mut pc: u32 = 0x8328DA98;
    'dispatch: loop {
        match pc {
            0x8328DA98 => {
    //   block [0x8328DA98..0x8328DAD8)
	// 8328DA98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328DA9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328DAA0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328DAA4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328DAA8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328DAAC: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328DAB0: 386A1190  addi r3, r10, 0x1190
	ctx.r[3].s64 = ctx.r[10].s64 + 4496;
	// 8328DAB4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328DAB8: 4AF9F419  bl 0x8222ced0
	ctx.lr = 0x8328DABC;
	sub_8222CED0(ctx, base);
	// 8328DABC: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328DAC0: 386942F8  addi r3, r9, 0x42f8
	ctx.r[3].s64 = ctx.r[9].s64 + 17144;
	// 8328DAC4: 4BA1C45D  bl 0x82ca9f20
	ctx.lr = 0x8328DAC8;
	sub_82CA9F20(ctx, base);
	// 8328DAC8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328DACC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328DAD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328DAD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328DAD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328DAD8 size=64
    let mut pc: u32 = 0x8328DAD8;
    'dispatch: loop {
        match pc {
            0x8328DAD8 => {
    //   block [0x8328DAD8..0x8328DB18)
	// 8328DAD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328DADC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328DAE0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328DAE4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328DAE8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328DAEC: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328DAF0: 386A1194  addi r3, r10, 0x1194
	ctx.r[3].s64 = ctx.r[10].s64 + 4500;
	// 8328DAF4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328DAF8: 4AF9F3D9  bl 0x8222ced0
	ctx.lr = 0x8328DAFC;
	sub_8222CED0(ctx, base);
	// 8328DAFC: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328DB00: 38694308  addi r3, r9, 0x4308
	ctx.r[3].s64 = ctx.r[9].s64 + 17160;
	// 8328DB04: 4BA1C41D  bl 0x82ca9f20
	ctx.lr = 0x8328DB08;
	sub_82CA9F20(ctx, base);
	// 8328DB08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328DB0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328DB10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328DB14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328DB18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328DB18 size=60
    let mut pc: u32 = 0x8328DB18;
    'dispatch: loop {
        match pc {
            0x8328DB18 => {
    //   block [0x8328DB18..0x8328DB28)
	// 8328DB18: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8328DB1C: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 8328DB20: 396B1198  addi r11, r11, 0x1198
	ctx.r[11].s64 = ctx.r[11].s64 + 4504;
	// 8328DB24: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x8328DB28; continue 'dispatch;
            }
            0x8328DB28 => {
    //   block [0x8328DB28..0x8328DB54)
	// 8328DB28: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8328DB2C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8328DB30: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328DB34: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328DB38: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 8328DB3C: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8328DB40: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 8328DB44: 4080FFE4  bge 0x8328db28
	if !ctx.cr[0].lt {
	pc = 0x8328DB28; continue 'dispatch;
	}
	// 8328DB48: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328DB4C: 386B4318  addi r3, r11, 0x4318
	ctx.r[3].s64 = ctx.r[11].s64 + 17176;
	// 8328DB50: 4BA1C3D0  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328DB58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328DB58 size=40
    let mut pc: u32 = 0x8328DB58;
    'dispatch: loop {
        match pc {
            0x8328DB58 => {
    //   block [0x8328DB58..0x8328DB80)
	// 8328DB58: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8328DB5C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328DB60: 396B11E8  addi r11, r11, 0x11e8
	ctx.r[11].s64 = ctx.r[11].s64 + 4584;
	// 8328DB64: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328DB68: 38694370  addi r3, r9, 0x4370
	ctx.r[3].s64 = ctx.r[9].s64 + 17264;
	// 8328DB6C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328DB70: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328DB74: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 8328DB78: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8328DB7C: 4BA1C3A4  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328DB80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328DB80 size=64
    let mut pc: u32 = 0x8328DB80;
    'dispatch: loop {
        match pc {
            0x8328DB80 => {
    //   block [0x8328DB80..0x8328DBC0)
	// 8328DB80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328DB84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328DB88: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328DB8C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328DB90: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328DB94: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328DB98: 386A11FC  addi r3, r10, 0x11fc
	ctx.r[3].s64 = ctx.r[10].s64 + 4604;
	// 8328DB9C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328DBA0: 4AF9F331  bl 0x8222ced0
	ctx.lr = 0x8328DBA4;
	sub_8222CED0(ctx, base);
	// 8328DBA4: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328DBA8: 38694388  addi r3, r9, 0x4388
	ctx.r[3].s64 = ctx.r[9].s64 + 17288;
	// 8328DBAC: 4BA1C375  bl 0x82ca9f20
	ctx.lr = 0x8328DBB0;
	sub_82CA9F20(ctx, base);
	// 8328DBB0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328DBB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328DBB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328DBBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328DBC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328DBC0 size=64
    let mut pc: u32 = 0x8328DBC0;
    'dispatch: loop {
        match pc {
            0x8328DBC0 => {
    //   block [0x8328DBC0..0x8328DC00)
	// 8328DBC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328DBC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328DBC8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328DBCC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328DBD0: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328DBD4: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328DBD8: 386A1200  addi r3, r10, 0x1200
	ctx.r[3].s64 = ctx.r[10].s64 + 4608;
	// 8328DBDC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328DBE0: 4AF9F2F1  bl 0x8222ced0
	ctx.lr = 0x8328DBE4;
	sub_8222CED0(ctx, base);
	// 8328DBE4: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328DBE8: 38694398  addi r3, r9, 0x4398
	ctx.r[3].s64 = ctx.r[9].s64 + 17304;
	// 8328DBEC: 4BA1C335  bl 0x82ca9f20
	ctx.lr = 0x8328DBF0;
	sub_82CA9F20(ctx, base);
	// 8328DBF0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328DBF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328DBF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328DBFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328DC00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328DC00 size=40
    let mut pc: u32 = 0x8328DC00;
    'dispatch: loop {
        match pc {
            0x8328DC00 => {
    //   block [0x8328DC00..0x8328DC28)
	// 8328DC00: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8328DC04: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328DC08: 396B1204  addi r11, r11, 0x1204
	ctx.r[11].s64 = ctx.r[11].s64 + 4612;
	// 8328DC0C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328DC10: 386943A8  addi r3, r9, 0x43a8
	ctx.r[3].s64 = ctx.r[9].s64 + 17320;
	// 8328DC14: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328DC18: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328DC1C: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 8328DC20: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8328DC24: 4BA1C2FC  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328DC28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8328DC28 size=352
    let mut pc: u32 = 0x8328DC28;
    'dispatch: loop {
        match pc {
            0x8328DC28 => {
    //   block [0x8328DC28..0x8328DD88)
	// 8328DC28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328DC2C: 4BA1B7C9  bl 0x82ca93f4
	ctx.lr = 0x8328DC30;
	sub_82CA93D0(ctx, base);
	// 8328DC30: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8328DC34: 3D008210  lis r8, -0x7df0
	ctx.r[8].s64 = -2112880640;
	// 8328DC38: 392BE434  addi r9, r11, -0x1bcc
	ctx.r[9].s64 = ctx.r[11].s64 + -7116;
	// 8328DC3C: 3CC08210  lis r6, -0x7df0
	ctx.r[6].s64 = -2112880640;
	// 8328DC40: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 8328DC44: 3861FFA4  addi r3, r1, -0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + -92;
	// 8328DC48: C16BE434  lfs f11, -0x1bcc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7116 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8328DC4C: 3CE08210  lis r7, -0x7df0
	ctx.r[7].s64 = -2112880640;
	// 8328DC50: D161FFA0  stfs f11, -0x60(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), tmp.u32 ) };
	// 8328DC54: C009B050  lfs f0, -0x4fb0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-20400 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8328DC58: 3BC1FF8C  addi r30, r1, -0x74
	ctx.r[30].s64 = ctx.r[1].s64 + -116;
	// 8328DC5C: D001FF78  stfs f0, -0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), tmp.u32 ) };
	// 8328DC60: 3B61FF78  addi r27, r1, -0x88
	ctx.r[27].s64 = ctx.r[1].s64 + -136;
	// 8328DC64: D001FF7C  stfs f0, -0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-132 as u32), tmp.u32 ) };
	// 8328DC68: 3B41FF7C  addi r26, r1, -0x84
	ctx.r[26].s64 = ctx.r[1].s64 + -132;
	// 8328DC6C: D001FF74  stfs f0, -0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-140 as u32), tmp.u32 ) };
	// 8328DC70: 3881FFA0  addi r4, r1, -0x60
	ctx.r[4].s64 = ctx.r[1].s64 + -96;
	// 8328DC74: D001FF80  stfs f0, -0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), tmp.u32 ) };
	// 8328DC78: 3BE1FF74  addi r31, r1, -0x8c
	ctx.r[31].s64 = ctx.r[1].s64 + -140;
	// 8328DC7C: D001FF84  stfs f0, -0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-124 as u32), tmp.u32 ) };
	// 8328DC80: 3B21FF80  addi r25, r1, -0x80
	ctx.r[25].s64 = ctx.r[1].s64 + -128;
	// 8328DC84: D001FF88  stfs f0, -0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), tmp.u32 ) };
	// 8328DC88: 3B01FF90  addi r24, r1, -0x70
	ctx.r[24].s64 = ctx.r[1].s64 + -112;
	// 8328DC8C: D001FF90  stfs f0, -0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), tmp.u32 ) };
	// 8328DC90: 3AE1FF98  addi r23, r1, -0x68
	ctx.r[23].s64 = ctx.r[1].s64 + -104;
	// 8328DC94: D001FF98  stfs f0, -0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), tmp.u32 ) };
	// 8328DC98: 3CA08210  lis r5, -0x7df0
	ctx.r[5].s64 = -2112880640;
	// 8328DC9C: D001FF9C  stfs f0, -0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-100 as u32), tmp.u32 ) };
	// 8328DCA0: 3961FFA8  addi r11, r1, -0x58
	ctx.r[11].s64 = ctx.r[1].s64 + -88;
	// 8328DCA4: C0081A50  lfs f0, 0x1a50(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(6736 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8328DCA8: 3901FF84  addi r8, r1, -0x7c
	ctx.r[8].s64 = ctx.r[1].s64 + -124;
	// 8328DCAC: D001FF8C  stfs f0, -0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-116 as u32), tmp.u32 ) };
	// 8328DCB0: 3BA1FF94  addi r29, r1, -0x6c
	ctx.r[29].s64 = ctx.r[1].s64 + -108;
	// 8328DCB4: C0061A4C  lfs f0, 0x1a4c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(6732 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8328DCB8: 38C1FF9C  addi r6, r1, -0x64
	ctx.r[6].s64 = ctx.r[1].s64 + -100;
	// 8328DCBC: C1AA15FC  lfs f13, 0x15fc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(5628 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8328DCC0: 3941FF70  addi r10, r1, -0x90
	ctx.r[10].s64 = ctx.r[1].s64 + -144;
	// 8328DCC4: D001FFA4  stfs f0, -0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-92 as u32), tmp.u32 ) };
	// 8328DCC8: 3B81FFA8  addi r28, r1, -0x58
	ctx.r[28].s64 = ctx.r[1].s64 + -88;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328DD88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328DD88 size=72
    let mut pc: u32 = 0x8328DD88;
    'dispatch: loop {
        match pc {
            0x8328DD88 => {
    //   block [0x8328DD88..0x8328DDD0)
	// 8328DD88: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 8328DD8C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 8328DD90: 38C81218  addi r6, r8, 0x1218
	ctx.r[6].s64 = ctx.r[8].s64 + 4632;
	// 8328DD94: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 8328DD98: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 8328DD9C: 91681218  stw r11, 0x1218(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4632 as u32), ctx.r[11].u32 ) };
	// 8328DDA0: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 8328DDA4: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 8328DDA8: 91460004  stw r10, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328DDAC: 91260008  stw r9, 8(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 8328DDB0: 9106000C  stw r8, 0xc(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 8328DDB4: 91660010  stw r11, 0x10(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 8328DDB8: 90E60014  stw r7, 0x14(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	// 8328DDBC: 91460018  stw r10, 0x18(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 8328DDC0: 9126001C  stw r9, 0x1c(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 8328DDC4: 91060020  stw r8, 0x20(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(32 as u32), ctx.r[8].u32 ) };
	// 8328DDC8: 91660024  stw r11, 0x24(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 8328DDCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328DDD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328DDD0 size=64
    let mut pc: u32 = 0x8328DDD0;
    'dispatch: loop {
        match pc {
            0x8328DDD0 => {
    //   block [0x8328DDD0..0x8328DE10)
	// 8328DDD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328DDD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328DDD8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328DDDC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328DDE0: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328DDE4: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328DDE8: 386A1280  addi r3, r10, 0x1280
	ctx.r[3].s64 = ctx.r[10].s64 + 4736;
	// 8328DDEC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328DDF0: 4AF9F0E1  bl 0x8222ced0
	ctx.lr = 0x8328DDF4;
	sub_8222CED0(ctx, base);
	// 8328DDF4: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328DDF8: 386943C0  addi r3, r9, 0x43c0
	ctx.r[3].s64 = ctx.r[9].s64 + 17344;
	// 8328DDFC: 4BA1C125  bl 0x82ca9f20
	ctx.lr = 0x8328DE00;
	sub_82CA9F20(ctx, base);
	// 8328DE00: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328DE04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328DE08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328DE0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328DE10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328DE10 size=64
    let mut pc: u32 = 0x8328DE10;
    'dispatch: loop {
        match pc {
            0x8328DE10 => {
    //   block [0x8328DE10..0x8328DE50)
	// 8328DE10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328DE14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328DE18: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328DE1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328DE20: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328DE24: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328DE28: 386A1284  addi r3, r10, 0x1284
	ctx.r[3].s64 = ctx.r[10].s64 + 4740;
	// 8328DE2C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328DE30: 4AF9F0A1  bl 0x8222ced0
	ctx.lr = 0x8328DE34;
	sub_8222CED0(ctx, base);
	// 8328DE34: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328DE38: 386943D0  addi r3, r9, 0x43d0
	ctx.r[3].s64 = ctx.r[9].s64 + 17360;
	// 8328DE3C: 4BA1C0E5  bl 0x82ca9f20
	ctx.lr = 0x8328DE40;
	sub_82CA9F20(ctx, base);
	// 8328DE40: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328DE44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328DE48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328DE4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328DE50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8328DE50 size=40
    let mut pc: u32 = 0x8328DE50;
    'dispatch: loop {
        match pc {
            0x8328DE50 => {
    //   block [0x8328DE50..0x8328DE78)
	// 8328DE50: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8328DE54: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 8328DE58: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 8328DE5C: 39091290  addi r8, r9, 0x1290
	ctx.r[8].s64 = ctx.r[9].s64 + 4752;
	// 8328DE60: C00B92CC  lfs f0, -0x6d34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27956 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8328DE64: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328DE78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328DE78 size=64
    let mut pc: u32 = 0x8328DE78;
    'dispatch: loop {
        match pc {
            0x8328DE78 => {
    //   block [0x8328DE78..0x8328DEB8)
	// 8328DE78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328DE7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328DE80: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328DE84: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328DE88: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328DE8C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328DE90: 386A12A0  addi r3, r10, 0x12a0
	ctx.r[3].s64 = ctx.r[10].s64 + 4768;
	// 8328DE94: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328DE98: 4AF9F039  bl 0x8222ced0
	ctx.lr = 0x8328DE9C;
	sub_8222CED0(ctx, base);
	// 8328DE9C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328DEA0: 386943E0  addi r3, r9, 0x43e0
	ctx.r[3].s64 = ctx.r[9].s64 + 17376;
	// 8328DEA4: 4BA1C07D  bl 0x82ca9f20
	ctx.lr = 0x8328DEA8;
	sub_82CA9F20(ctx, base);
	// 8328DEA8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328DEAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328DEB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328DEB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328DEB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328DEB8 size=64
    let mut pc: u32 = 0x8328DEB8;
    'dispatch: loop {
        match pc {
            0x8328DEB8 => {
    //   block [0x8328DEB8..0x8328DEF8)
	// 8328DEB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328DEBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328DEC0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328DEC4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328DEC8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328DECC: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328DED0: 386A12A4  addi r3, r10, 0x12a4
	ctx.r[3].s64 = ctx.r[10].s64 + 4772;
	// 8328DED4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328DED8: 4AF9EFF9  bl 0x8222ced0
	ctx.lr = 0x8328DEDC;
	sub_8222CED0(ctx, base);
	// 8328DEDC: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328DEE0: 386943F0  addi r3, r9, 0x43f0
	ctx.r[3].s64 = ctx.r[9].s64 + 17392;
	// 8328DEE4: 4BA1C03D  bl 0x82ca9f20
	ctx.lr = 0x8328DEE8;
	sub_82CA9F20(ctx, base);
	// 8328DEE8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328DEEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328DEF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328DEF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328DEF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328DEF8 size=64
    let mut pc: u32 = 0x8328DEF8;
    'dispatch: loop {
        match pc {
            0x8328DEF8 => {
    //   block [0x8328DEF8..0x8328DF38)
	// 8328DEF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328DEFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328DF00: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328DF04: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328DF08: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328DF0C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328DF10: 386A12A8  addi r3, r10, 0x12a8
	ctx.r[3].s64 = ctx.r[10].s64 + 4776;
	// 8328DF14: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328DF18: 4AF9EFB9  bl 0x8222ced0
	ctx.lr = 0x8328DF1C;
	sub_8222CED0(ctx, base);
	// 8328DF1C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328DF20: 38694480  addi r3, r9, 0x4480
	ctx.r[3].s64 = ctx.r[9].s64 + 17536;
	// 8328DF24: 4BA1BFFD  bl 0x82ca9f20
	ctx.lr = 0x8328DF28;
	sub_82CA9F20(ctx, base);
	// 8328DF28: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328DF2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328DF30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328DF34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328DF38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328DF38 size=64
    let mut pc: u32 = 0x8328DF38;
    'dispatch: loop {
        match pc {
            0x8328DF38 => {
    //   block [0x8328DF38..0x8328DF78)
	// 8328DF38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328DF3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328DF40: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328DF44: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328DF48: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328DF4C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328DF50: 386A12AC  addi r3, r10, 0x12ac
	ctx.r[3].s64 = ctx.r[10].s64 + 4780;
	// 8328DF54: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328DF58: 4AF9EF79  bl 0x8222ced0
	ctx.lr = 0x8328DF5C;
	sub_8222CED0(ctx, base);
	// 8328DF5C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328DF60: 38694490  addi r3, r9, 0x4490
	ctx.r[3].s64 = ctx.r[9].s64 + 17552;
	// 8328DF64: 4BA1BFBD  bl 0x82ca9f20
	ctx.lr = 0x8328DF68;
	sub_82CA9F20(ctx, base);
	// 8328DF68: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328DF6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328DF70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328DF74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328DF78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328DF78 size=60
    let mut pc: u32 = 0x8328DF78;
    'dispatch: loop {
        match pc {
            0x8328DF78 => {
    //   block [0x8328DF78..0x8328DF88)
	// 8328DF78: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8328DF7C: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 8328DF80: 396B12B0  addi r11, r11, 0x12b0
	ctx.r[11].s64 = ctx.r[11].s64 + 4784;
	// 8328DF84: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x8328DF88; continue 'dispatch;
            }
            0x8328DF88 => {
    //   block [0x8328DF88..0x8328DFB4)
	// 8328DF88: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8328DF8C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8328DF90: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328DF94: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328DF98: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 8328DF9C: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8328DFA0: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 8328DFA4: 4080FFE4  bge 0x8328df88
	if !ctx.cr[0].lt {
	pc = 0x8328DF88; continue 'dispatch;
	}
	// 8328DFA8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328DFAC: 386B44A0  addi r3, r11, 0x44a0
	ctx.r[3].s64 = ctx.r[11].s64 + 17568;
	// 8328DFB0: 4BA1BF70  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328DFB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328DFB8 size=72
    let mut pc: u32 = 0x8328DFB8;
    'dispatch: loop {
        match pc {
            0x8328DFB8 => {
    //   block [0x8328DFB8..0x8328E000)
	// 8328DFB8: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 8328DFBC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 8328DFC0: 38C81300  addi r6, r8, 0x1300
	ctx.r[6].s64 = ctx.r[8].s64 + 4864;
	// 8328DFC4: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 8328DFC8: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 8328DFCC: 91681300  stw r11, 0x1300(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4864 as u32), ctx.r[11].u32 ) };
	// 8328DFD0: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 8328DFD4: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 8328DFD8: 91460004  stw r10, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328DFDC: 91260008  stw r9, 8(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 8328DFE0: 9106000C  stw r8, 0xc(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 8328DFE4: 91660010  stw r11, 0x10(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 8328DFE8: 90E60014  stw r7, 0x14(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	// 8328DFEC: 91460018  stw r10, 0x18(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 8328DFF0: 9126001C  stw r9, 0x1c(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 8328DFF4: 91060020  stw r8, 0x20(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(32 as u32), ctx.r[8].u32 ) };
	// 8328DFF8: 91660024  stw r11, 0x24(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 8328DFFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328E000 size=64
    let mut pc: u32 = 0x8328E000;
    'dispatch: loop {
        match pc {
            0x8328E000 => {
    //   block [0x8328E000..0x8328E040)
	// 8328E000: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328E004: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328E008: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328E00C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328E010: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328E014: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328E018: 386A1328  addi r3, r10, 0x1328
	ctx.r[3].s64 = ctx.r[10].s64 + 4904;
	// 8328E01C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328E020: 4AF9EEB1  bl 0x8222ced0
	ctx.lr = 0x8328E024;
	sub_8222CED0(ctx, base);
	// 8328E024: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328E028: 386944F8  addi r3, r9, 0x44f8
	ctx.r[3].s64 = ctx.r[9].s64 + 17656;
	// 8328E02C: 4BA1BEF5  bl 0x82ca9f20
	ctx.lr = 0x8328E030;
	sub_82CA9F20(ctx, base);
	// 8328E030: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328E034: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328E038: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328E03C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328E040 size=64
    let mut pc: u32 = 0x8328E040;
    'dispatch: loop {
        match pc {
            0x8328E040 => {
    //   block [0x8328E040..0x8328E080)
	// 8328E040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328E044: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328E048: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328E04C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328E050: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328E054: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328E058: 386A132C  addi r3, r10, 0x132c
	ctx.r[3].s64 = ctx.r[10].s64 + 4908;
	// 8328E05C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328E060: 4AF9EE71  bl 0x8222ced0
	ctx.lr = 0x8328E064;
	sub_8222CED0(ctx, base);
	// 8328E064: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328E068: 38694508  addi r3, r9, 0x4508
	ctx.r[3].s64 = ctx.r[9].s64 + 17672;
	// 8328E06C: 4BA1BEB5  bl 0x82ca9f20
	ctx.lr = 0x8328E070;
	sub_82CA9F20(ctx, base);
	// 8328E070: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328E074: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328E078: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328E07C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328E080 size=64
    let mut pc: u32 = 0x8328E080;
    'dispatch: loop {
        match pc {
            0x8328E080 => {
    //   block [0x8328E080..0x8328E0C0)
	// 8328E080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328E084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328E088: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328E08C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328E090: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328E094: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328E098: 386A4330  addi r3, r10, 0x4330
	ctx.r[3].s64 = ctx.r[10].s64 + 17200;
	// 8328E09C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328E0A0: 4AF9EE31  bl 0x8222ced0
	ctx.lr = 0x8328E0A4;
	sub_8222CED0(ctx, base);
	// 8328E0A4: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328E0A8: 38694518  addi r3, r9, 0x4518
	ctx.r[3].s64 = ctx.r[9].s64 + 17688;
	// 8328E0AC: 4BA1BE75  bl 0x82ca9f20
	ctx.lr = 0x8328E0B0;
	sub_82CA9F20(ctx, base);
	// 8328E0B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328E0B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328E0B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328E0BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E0C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328E0C0 size=64
    let mut pc: u32 = 0x8328E0C0;
    'dispatch: loop {
        match pc {
            0x8328E0C0 => {
    //   block [0x8328E0C0..0x8328E100)
	// 8328E0C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328E0C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328E0C8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328E0CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328E0D0: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328E0D4: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328E0D8: 386A4334  addi r3, r10, 0x4334
	ctx.r[3].s64 = ctx.r[10].s64 + 17204;
	// 8328E0DC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328E0E0: 4AF9EDF1  bl 0x8222ced0
	ctx.lr = 0x8328E0E4;
	sub_8222CED0(ctx, base);
	// 8328E0E4: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328E0E8: 38694528  addi r3, r9, 0x4528
	ctx.r[3].s64 = ctx.r[9].s64 + 17704;
	// 8328E0EC: 4BA1BE35  bl 0x82ca9f20
	ctx.lr = 0x8328E0F0;
	sub_82CA9F20(ctx, base);
	// 8328E0F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328E0F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328E0F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328E0FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328E100 size=64
    let mut pc: u32 = 0x8328E100;
    'dispatch: loop {
        match pc {
            0x8328E100 => {
    //   block [0x8328E100..0x8328E140)
	// 8328E100: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328E104: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328E108: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328E10C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328E110: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328E114: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328E118: 386A4338  addi r3, r10, 0x4338
	ctx.r[3].s64 = ctx.r[10].s64 + 17208;
	// 8328E11C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328E120: 4AF9EDB1  bl 0x8222ced0
	ctx.lr = 0x8328E124;
	sub_8222CED0(ctx, base);
	// 8328E124: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328E128: 38694538  addi r3, r9, 0x4538
	ctx.r[3].s64 = ctx.r[9].s64 + 17720;
	// 8328E12C: 4BA1BDF5  bl 0x82ca9f20
	ctx.lr = 0x8328E130;
	sub_82CA9F20(ctx, base);
	// 8328E130: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328E134: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328E138: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328E13C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328E140 size=64
    let mut pc: u32 = 0x8328E140;
    'dispatch: loop {
        match pc {
            0x8328E140 => {
    //   block [0x8328E140..0x8328E180)
	// 8328E140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328E144: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328E148: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328E14C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328E150: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328E154: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328E158: 386A433C  addi r3, r10, 0x433c
	ctx.r[3].s64 = ctx.r[10].s64 + 17212;
	// 8328E15C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328E160: 4AF9ED71  bl 0x8222ced0
	ctx.lr = 0x8328E164;
	sub_8222CED0(ctx, base);
	// 8328E164: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328E168: 38694548  addi r3, r9, 0x4548
	ctx.r[3].s64 = ctx.r[9].s64 + 17736;
	// 8328E16C: 4BA1BDB5  bl 0x82ca9f20
	ctx.lr = 0x8328E170;
	sub_82CA9F20(ctx, base);
	// 8328E170: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328E174: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328E178: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328E17C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328E180 size=12
    let mut pc: u32 = 0x8328E180;
    'dispatch: loop {
        match pc {
            0x8328E180 => {
    //   block [0x8328E180..0x8328E18C)
	// 8328E180: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328E184: 386B4558  addi r3, r11, 0x4558
	ctx.r[3].s64 = ctx.r[11].s64 + 17752;
	// 8328E188: 4BA1BD98  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328E190 size=12
    let mut pc: u32 = 0x8328E190;
    'dispatch: loop {
        match pc {
            0x8328E190 => {
    //   block [0x8328E190..0x8328E19C)
	// 8328E190: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328E194: 386B45D0  addi r3, r11, 0x45d0
	ctx.r[3].s64 = ctx.r[11].s64 + 17872;
	// 8328E198: 4BA1BD88  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E1A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328E1A0 size=12
    let mut pc: u32 = 0x8328E1A0;
    'dispatch: loop {
        match pc {
            0x8328E1A0 => {
    //   block [0x8328E1A0..0x8328E1AC)
	// 8328E1A0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328E1A4: 386B4648  addi r3, r11, 0x4648
	ctx.r[3].s64 = ctx.r[11].s64 + 17992;
	// 8328E1A8: 4BA1BD78  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E1B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328E1B0 size=12
    let mut pc: u32 = 0x8328E1B0;
    'dispatch: loop {
        match pc {
            0x8328E1B0 => {
    //   block [0x8328E1B0..0x8328E1BC)
	// 8328E1B0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328E1B4: 386B46C0  addi r3, r11, 0x46c0
	ctx.r[3].s64 = ctx.r[11].s64 + 18112;
	// 8328E1B8: 4BA1BD68  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E1C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328E1C0 size=12
    let mut pc: u32 = 0x8328E1C0;
    'dispatch: loop {
        match pc {
            0x8328E1C0 => {
    //   block [0x8328E1C0..0x8328E1CC)
	// 8328E1C0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328E1C4: 386B4738  addi r3, r11, 0x4738
	ctx.r[3].s64 = ctx.r[11].s64 + 18232;
	// 8328E1C8: 4BA1BD58  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E1D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328E1D0 size=12
    let mut pc: u32 = 0x8328E1D0;
    'dispatch: loop {
        match pc {
            0x8328E1D0 => {
    //   block [0x8328E1D0..0x8328E1DC)
	// 8328E1D0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328E1D4: 386B47B0  addi r3, r11, 0x47b0
	ctx.r[3].s64 = ctx.r[11].s64 + 18352;
	// 8328E1D8: 4BA1BD48  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E1E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328E1E0 size=12
    let mut pc: u32 = 0x8328E1E0;
    'dispatch: loop {
        match pc {
            0x8328E1E0 => {
    //   block [0x8328E1E0..0x8328E1EC)
	// 8328E1E0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328E1E4: 386B4828  addi r3, r11, 0x4828
	ctx.r[3].s64 = ctx.r[11].s64 + 18472;
	// 8328E1E8: 4BA1BD38  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E1F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328E1F0 size=12
    let mut pc: u32 = 0x8328E1F0;
    'dispatch: loop {
        match pc {
            0x8328E1F0 => {
    //   block [0x8328E1F0..0x8328E1FC)
	// 8328E1F0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328E1F4: 386B48A0  addi r3, r11, 0x48a0
	ctx.r[3].s64 = ctx.r[11].s64 + 18592;
	// 8328E1F8: 4BA1BD28  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328E200 size=12
    let mut pc: u32 = 0x8328E200;
    'dispatch: loop {
        match pc {
            0x8328E200 => {
    //   block [0x8328E200..0x8328E20C)
	// 8328E200: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328E204: 386B4918  addi r3, r11, 0x4918
	ctx.r[3].s64 = ctx.r[11].s64 + 18712;
	// 8328E208: 4BA1BD18  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328E210 size=12
    let mut pc: u32 = 0x8328E210;
    'dispatch: loop {
        match pc {
            0x8328E210 => {
    //   block [0x8328E210..0x8328E21C)
	// 8328E210: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328E214: 386B4990  addi r3, r11, 0x4990
	ctx.r[3].s64 = ctx.r[11].s64 + 18832;
	// 8328E218: 4BA1BD08  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328E220 size=12
    let mut pc: u32 = 0x8328E220;
    'dispatch: loop {
        match pc {
            0x8328E220 => {
    //   block [0x8328E220..0x8328E22C)
	// 8328E220: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328E224: 386B49A0  addi r3, r11, 0x49a0
	ctx.r[3].s64 = ctx.r[11].s64 + 18848;
	// 8328E228: 4BA1BCF8  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8328E230 size=96
    let mut pc: u32 = 0x8328E230;
    'dispatch: loop {
        match pc {
            0x8328E230 => {
    //   block [0x8328E230..0x8328E290)
	// 8328E230: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8328E234: 3941FFF4  addi r10, r1, -0xc
	ctx.r[10].s64 = ctx.r[1].s64 + -12;
	// 8328E238: 392B9490  addi r9, r11, -0x6b70
	ctx.r[9].s64 = ctx.r[11].s64 + -27504;
	// 8328E23C: 3901FFF8  addi r8, r1, -8
	ctx.r[8].s64 = ctx.r[1].s64 + -8;
	// 8328E240: 38E1FFF0  addi r7, r1, -0x10
	ctx.r[7].s64 = ctx.r[1].s64 + -16;
	// 8328E244: 38C1FFF8  addi r6, r1, -8
	ctx.r[6].s64 = ctx.r[1].s64 + -8;
	// 8328E248: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8328E24C: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 8328E250: 3CA0834A  lis r5, -0x7cb6
	ctx.r[5].s64 = -2092302336;
	// 8328E254: C1A9FFF4  lfs f13, -0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8328E258: D1A1FFF4  stfs f13, -0xc(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 8328E25C: 38854370  addi r4, r5, 0x4370
	ctx.r[4].s64 = ctx.r[5].s64 + 17264;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328E290 size=64
    let mut pc: u32 = 0x8328E290;
    'dispatch: loop {
        match pc {
            0x8328E290 => {
    //   block [0x8328E290..0x8328E2D0)
	// 8328E290: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328E294: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328E298: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328E29C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328E2A0: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328E2A4: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328E2A8: 386A4380  addi r3, r10, 0x4380
	ctx.r[3].s64 = ctx.r[10].s64 + 17280;
	// 8328E2AC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328E2B0: 4AF9EC21  bl 0x8222ced0
	ctx.lr = 0x8328E2B4;
	sub_8222CED0(ctx, base);
	// 8328E2B4: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328E2B8: 38694A18  addi r3, r9, 0x4a18
	ctx.r[3].s64 = ctx.r[9].s64 + 18968;
	// 8328E2BC: 4BA1BC65  bl 0x82ca9f20
	ctx.lr = 0x8328E2C0;
	sub_82CA9F20(ctx, base);
	// 8328E2C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328E2C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328E2C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328E2CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E2D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328E2D0 size=64
    let mut pc: u32 = 0x8328E2D0;
    'dispatch: loop {
        match pc {
            0x8328E2D0 => {
    //   block [0x8328E2D0..0x8328E310)
	// 8328E2D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328E2D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328E2D8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328E2DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328E2E0: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328E2E4: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328E2E8: 386A4384  addi r3, r10, 0x4384
	ctx.r[3].s64 = ctx.r[10].s64 + 17284;
	// 8328E2EC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328E2F0: 4AF9EBE1  bl 0x8222ced0
	ctx.lr = 0x8328E2F4;
	sub_8222CED0(ctx, base);
	// 8328E2F4: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328E2F8: 38694A28  addi r3, r9, 0x4a28
	ctx.r[3].s64 = ctx.r[9].s64 + 18984;
	// 8328E2FC: 4BA1BC25  bl 0x82ca9f20
	ctx.lr = 0x8328E300;
	sub_82CA9F20(ctx, base);
	// 8328E300: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328E304: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328E308: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328E30C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328E310 size=12
    let mut pc: u32 = 0x8328E310;
    'dispatch: loop {
        match pc {
            0x8328E310 => {
    //   block [0x8328E310..0x8328E31C)
	// 8328E310: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328E314: 386B4A38  addi r3, r11, 0x4a38
	ctx.r[3].s64 = ctx.r[11].s64 + 19000;
	// 8328E318: 4BA1BC08  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328E320 size=12
    let mut pc: u32 = 0x8328E320;
    'dispatch: loop {
        match pc {
            0x8328E320 => {
    //   block [0x8328E320..0x8328E32C)
	// 8328E320: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328E324: 386B4A48  addi r3, r11, 0x4a48
	ctx.r[3].s64 = ctx.r[11].s64 + 19016;
	// 8328E328: 4BA1BBF8  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328E330 size=12
    let mut pc: u32 = 0x8328E330;
    'dispatch: loop {
        match pc {
            0x8328E330 => {
    //   block [0x8328E330..0x8328E33C)
	// 8328E330: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328E334: 386B4AA8  addi r3, r11, 0x4aa8
	ctx.r[3].s64 = ctx.r[11].s64 + 19112;
	// 8328E338: 4BA1BBE8  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328E340 size=64
    let mut pc: u32 = 0x8328E340;
    'dispatch: loop {
        match pc {
            0x8328E340 => {
    //   block [0x8328E340..0x8328E380)
	// 8328E340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328E344: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328E348: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328E34C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328E350: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328E354: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328E358: 386A4390  addi r3, r10, 0x4390
	ctx.r[3].s64 = ctx.r[10].s64 + 17296;
	// 8328E35C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328E360: 4AF9EB71  bl 0x8222ced0
	ctx.lr = 0x8328E364;
	sub_8222CED0(ctx, base);
	// 8328E364: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328E368: 38694B08  addi r3, r9, 0x4b08
	ctx.r[3].s64 = ctx.r[9].s64 + 19208;
	// 8328E36C: 4BA1BBB5  bl 0x82ca9f20
	ctx.lr = 0x8328E370;
	sub_82CA9F20(ctx, base);
	// 8328E370: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328E374: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328E378: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328E37C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328E380 size=64
    let mut pc: u32 = 0x8328E380;
    'dispatch: loop {
        match pc {
            0x8328E380 => {
    //   block [0x8328E380..0x8328E3C0)
	// 8328E380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328E384: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328E388: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328E38C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328E390: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328E394: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328E398: 386A4394  addi r3, r10, 0x4394
	ctx.r[3].s64 = ctx.r[10].s64 + 17300;
	// 8328E39C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328E3A0: 4AF9EB31  bl 0x8222ced0
	ctx.lr = 0x8328E3A4;
	sub_8222CED0(ctx, base);
	// 8328E3A4: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328E3A8: 38694B18  addi r3, r9, 0x4b18
	ctx.r[3].s64 = ctx.r[9].s64 + 19224;
	// 8328E3AC: 4BA1BB75  bl 0x82ca9f20
	ctx.lr = 0x8328E3B0;
	sub_82CA9F20(ctx, base);
	// 8328E3B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328E3B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328E3B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328E3BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E3C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328E3C0 size=64
    let mut pc: u32 = 0x8328E3C0;
    'dispatch: loop {
        match pc {
            0x8328E3C0 => {
    //   block [0x8328E3C0..0x8328E400)
	// 8328E3C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328E3C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328E3C8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328E3CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328E3D0: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328E3D4: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328E3D8: 386A4398  addi r3, r10, 0x4398
	ctx.r[3].s64 = ctx.r[10].s64 + 17304;
	// 8328E3DC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328E3E0: 4AF9EAF1  bl 0x8222ced0
	ctx.lr = 0x8328E3E4;
	sub_8222CED0(ctx, base);
	// 8328E3E4: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328E3E8: 38694B38  addi r3, r9, 0x4b38
	ctx.r[3].s64 = ctx.r[9].s64 + 19256;
	// 8328E3EC: 4BA1BB35  bl 0x82ca9f20
	ctx.lr = 0x8328E3F0;
	sub_82CA9F20(ctx, base);
	// 8328E3F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328E3F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328E3F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328E3FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328E400 size=64
    let mut pc: u32 = 0x8328E400;
    'dispatch: loop {
        match pc {
            0x8328E400 => {
    //   block [0x8328E400..0x8328E440)
	// 8328E400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328E404: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328E408: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328E40C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328E410: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328E414: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328E418: 386A439C  addi r3, r10, 0x439c
	ctx.r[3].s64 = ctx.r[10].s64 + 17308;
	// 8328E41C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328E420: 4AF9EAB1  bl 0x8222ced0
	ctx.lr = 0x8328E424;
	sub_8222CED0(ctx, base);
	// 8328E424: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328E428: 38694B48  addi r3, r9, 0x4b48
	ctx.r[3].s64 = ctx.r[9].s64 + 19272;
	// 8328E42C: 4BA1BAF5  bl 0x82ca9f20
	ctx.lr = 0x8328E430;
	sub_82CA9F20(ctx, base);
	// 8328E430: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328E434: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328E438: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328E43C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328E440 size=64
    let mut pc: u32 = 0x8328E440;
    'dispatch: loop {
        match pc {
            0x8328E440 => {
    //   block [0x8328E440..0x8328E480)
	// 8328E440: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328E444: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328E448: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328E44C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328E450: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328E454: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328E458: 386A43A0  addi r3, r10, 0x43a0
	ctx.r[3].s64 = ctx.r[10].s64 + 17312;
	// 8328E45C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328E460: 4AF9EA71  bl 0x8222ced0
	ctx.lr = 0x8328E464;
	sub_8222CED0(ctx, base);
	// 8328E464: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328E468: 38694B58  addi r3, r9, 0x4b58
	ctx.r[3].s64 = ctx.r[9].s64 + 19288;
	// 8328E46C: 4BA1BAB5  bl 0x82ca9f20
	ctx.lr = 0x8328E470;
	sub_82CA9F20(ctx, base);
	// 8328E470: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328E474: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328E478: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328E47C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328E480 size=64
    let mut pc: u32 = 0x8328E480;
    'dispatch: loop {
        match pc {
            0x8328E480 => {
    //   block [0x8328E480..0x8328E4C0)
	// 8328E480: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328E484: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328E488: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328E48C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328E490: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328E494: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328E498: 386A43A4  addi r3, r10, 0x43a4
	ctx.r[3].s64 = ctx.r[10].s64 + 17316;
	// 8328E49C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328E4A0: 4AF9EA31  bl 0x8222ced0
	ctx.lr = 0x8328E4A4;
	sub_8222CED0(ctx, base);
	// 8328E4A4: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328E4A8: 38694B68  addi r3, r9, 0x4b68
	ctx.r[3].s64 = ctx.r[9].s64 + 19304;
	// 8328E4AC: 4BA1BA75  bl 0x82ca9f20
	ctx.lr = 0x8328E4B0;
	sub_82CA9F20(ctx, base);
	// 8328E4B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328E4B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328E4B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328E4BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E4C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328E4C0 size=64
    let mut pc: u32 = 0x8328E4C0;
    'dispatch: loop {
        match pc {
            0x8328E4C0 => {
    //   block [0x8328E4C0..0x8328E500)
	// 8328E4C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328E4C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328E4C8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328E4CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328E4D0: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328E4D4: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328E4D8: 386A43A8  addi r3, r10, 0x43a8
	ctx.r[3].s64 = ctx.r[10].s64 + 17320;
	// 8328E4DC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328E4E0: 4AF9E9F1  bl 0x8222ced0
	ctx.lr = 0x8328E4E4;
	sub_8222CED0(ctx, base);
	// 8328E4E4: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328E4E8: 38694B78  addi r3, r9, 0x4b78
	ctx.r[3].s64 = ctx.r[9].s64 + 19320;
	// 8328E4EC: 4BA1BA35  bl 0x82ca9f20
	ctx.lr = 0x8328E4F0;
	sub_82CA9F20(ctx, base);
	// 8328E4F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328E4F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328E4F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328E4FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328E500 size=64
    let mut pc: u32 = 0x8328E500;
    'dispatch: loop {
        match pc {
            0x8328E500 => {
    //   block [0x8328E500..0x8328E540)
	// 8328E500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328E504: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328E508: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328E50C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328E510: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328E514: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328E518: 386A43AC  addi r3, r10, 0x43ac
	ctx.r[3].s64 = ctx.r[10].s64 + 17324;
	// 8328E51C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328E520: 4AF9E9B1  bl 0x8222ced0
	ctx.lr = 0x8328E524;
	sub_8222CED0(ctx, base);
	// 8328E524: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328E528: 38694B88  addi r3, r9, 0x4b88
	ctx.r[3].s64 = ctx.r[9].s64 + 19336;
	// 8328E52C: 4BA1B9F5  bl 0x82ca9f20
	ctx.lr = 0x8328E530;
	sub_82CA9F20(ctx, base);
	// 8328E530: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328E534: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328E538: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328E53C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328E540 size=64
    let mut pc: u32 = 0x8328E540;
    'dispatch: loop {
        match pc {
            0x8328E540 => {
    //   block [0x8328E540..0x8328E580)
	// 8328E540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328E544: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328E548: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328E54C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328E550: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328E554: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328E558: 386A43B0  addi r3, r10, 0x43b0
	ctx.r[3].s64 = ctx.r[10].s64 + 17328;
	// 8328E55C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328E560: 4AF9E971  bl 0x8222ced0
	ctx.lr = 0x8328E564;
	sub_8222CED0(ctx, base);
	// 8328E564: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328E568: 38694B98  addi r3, r9, 0x4b98
	ctx.r[3].s64 = ctx.r[9].s64 + 19352;
	// 8328E56C: 4BA1B9B5  bl 0x82ca9f20
	ctx.lr = 0x8328E570;
	sub_82CA9F20(ctx, base);
	// 8328E570: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328E574: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328E578: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328E57C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328E580 size=64
    let mut pc: u32 = 0x8328E580;
    'dispatch: loop {
        match pc {
            0x8328E580 => {
    //   block [0x8328E580..0x8328E5C0)
	// 8328E580: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328E584: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328E588: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328E58C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328E590: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328E594: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328E598: 386A43B4  addi r3, r10, 0x43b4
	ctx.r[3].s64 = ctx.r[10].s64 + 17332;
	// 8328E59C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328E5A0: 4AF9E931  bl 0x8222ced0
	ctx.lr = 0x8328E5A4;
	sub_8222CED0(ctx, base);
	// 8328E5A4: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328E5A8: 38694BA8  addi r3, r9, 0x4ba8
	ctx.r[3].s64 = ctx.r[9].s64 + 19368;
	// 8328E5AC: 4BA1B975  bl 0x82ca9f20
	ctx.lr = 0x8328E5B0;
	sub_82CA9F20(ctx, base);
	// 8328E5B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328E5B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328E5B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328E5BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E5C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328E5C0 size=64
    let mut pc: u32 = 0x8328E5C0;
    'dispatch: loop {
        match pc {
            0x8328E5C0 => {
    //   block [0x8328E5C0..0x8328E600)
	// 8328E5C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328E5C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328E5C8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328E5CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328E5D0: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328E5D4: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328E5D8: 386A43B8  addi r3, r10, 0x43b8
	ctx.r[3].s64 = ctx.r[10].s64 + 17336;
	// 8328E5DC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328E5E0: 4AF9E8F1  bl 0x8222ced0
	ctx.lr = 0x8328E5E4;
	sub_8222CED0(ctx, base);
	// 8328E5E4: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328E5E8: 38694BB8  addi r3, r9, 0x4bb8
	ctx.r[3].s64 = ctx.r[9].s64 + 19384;
	// 8328E5EC: 4BA1B935  bl 0x82ca9f20
	ctx.lr = 0x8328E5F0;
	sub_82CA9F20(ctx, base);
	// 8328E5F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328E5F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328E5F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328E5FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328E600 size=64
    let mut pc: u32 = 0x8328E600;
    'dispatch: loop {
        match pc {
            0x8328E600 => {
    //   block [0x8328E600..0x8328E640)
	// 8328E600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328E604: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328E608: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328E60C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328E610: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328E614: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328E618: 386A43BC  addi r3, r10, 0x43bc
	ctx.r[3].s64 = ctx.r[10].s64 + 17340;
	// 8328E61C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328E620: 4AF9E8B1  bl 0x8222ced0
	ctx.lr = 0x8328E624;
	sub_8222CED0(ctx, base);
	// 8328E624: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328E628: 38694BC8  addi r3, r9, 0x4bc8
	ctx.r[3].s64 = ctx.r[9].s64 + 19400;
	// 8328E62C: 4BA1B8F5  bl 0x82ca9f20
	ctx.lr = 0x8328E630;
	sub_82CA9F20(ctx, base);
	// 8328E630: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328E634: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328E638: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328E63C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328E640 size=64
    let mut pc: u32 = 0x8328E640;
    'dispatch: loop {
        match pc {
            0x8328E640 => {
    //   block [0x8328E640..0x8328E680)
	// 8328E640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328E644: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328E648: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328E64C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328E650: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328E654: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328E658: 386A43C0  addi r3, r10, 0x43c0
	ctx.r[3].s64 = ctx.r[10].s64 + 17344;
	// 8328E65C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328E660: 4AF9E871  bl 0x8222ced0
	ctx.lr = 0x8328E664;
	sub_8222CED0(ctx, base);
	// 8328E664: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328E668: 38694BD8  addi r3, r9, 0x4bd8
	ctx.r[3].s64 = ctx.r[9].s64 + 19416;
	// 8328E66C: 4BA1B8B5  bl 0x82ca9f20
	ctx.lr = 0x8328E670;
	sub_82CA9F20(ctx, base);
	// 8328E670: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328E674: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328E678: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328E67C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328E680 size=64
    let mut pc: u32 = 0x8328E680;
    'dispatch: loop {
        match pc {
            0x8328E680 => {
    //   block [0x8328E680..0x8328E6C0)
	// 8328E680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328E684: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328E688: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328E68C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328E690: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328E694: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328E698: 386A43C4  addi r3, r10, 0x43c4
	ctx.r[3].s64 = ctx.r[10].s64 + 17348;
	// 8328E69C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328E6A0: 4AF9E831  bl 0x8222ced0
	ctx.lr = 0x8328E6A4;
	sub_8222CED0(ctx, base);
	// 8328E6A4: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328E6A8: 38694BE8  addi r3, r9, 0x4be8
	ctx.r[3].s64 = ctx.r[9].s64 + 19432;
	// 8328E6AC: 4BA1B875  bl 0x82ca9f20
	ctx.lr = 0x8328E6B0;
	sub_82CA9F20(ctx, base);
	// 8328E6B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328E6B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328E6B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328E6BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E6C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328E6C0 size=64
    let mut pc: u32 = 0x8328E6C0;
    'dispatch: loop {
        match pc {
            0x8328E6C0 => {
    //   block [0x8328E6C0..0x8328E700)
	// 8328E6C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328E6C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328E6C8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328E6CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328E6D0: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328E6D4: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328E6D8: 386A43C8  addi r3, r10, 0x43c8
	ctx.r[3].s64 = ctx.r[10].s64 + 17352;
	// 8328E6DC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328E6E0: 4AF9E7F1  bl 0x8222ced0
	ctx.lr = 0x8328E6E4;
	sub_8222CED0(ctx, base);
	// 8328E6E4: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328E6E8: 38694BF8  addi r3, r9, 0x4bf8
	ctx.r[3].s64 = ctx.r[9].s64 + 19448;
	// 8328E6EC: 4BA1B835  bl 0x82ca9f20
	ctx.lr = 0x8328E6F0;
	sub_82CA9F20(ctx, base);
	// 8328E6F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328E6F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328E6F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328E6FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328E700 size=64
    let mut pc: u32 = 0x8328E700;
    'dispatch: loop {
        match pc {
            0x8328E700 => {
    //   block [0x8328E700..0x8328E740)
	// 8328E700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328E704: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328E708: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328E70C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328E710: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328E714: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328E718: 386A43CC  addi r3, r10, 0x43cc
	ctx.r[3].s64 = ctx.r[10].s64 + 17356;
	// 8328E71C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328E720: 4AF9E7B1  bl 0x8222ced0
	ctx.lr = 0x8328E724;
	sub_8222CED0(ctx, base);
	// 8328E724: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328E728: 38694C08  addi r3, r9, 0x4c08
	ctx.r[3].s64 = ctx.r[9].s64 + 19464;
	// 8328E72C: 4BA1B7F5  bl 0x82ca9f20
	ctx.lr = 0x8328E730;
	sub_82CA9F20(ctx, base);
	// 8328E730: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328E734: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328E738: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328E73C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E740(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328E740 size=64
    let mut pc: u32 = 0x8328E740;
    'dispatch: loop {
        match pc {
            0x8328E740 => {
    //   block [0x8328E740..0x8328E780)
	// 8328E740: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328E744: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328E748: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328E74C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328E750: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328E754: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328E758: 386A43D0  addi r3, r10, 0x43d0
	ctx.r[3].s64 = ctx.r[10].s64 + 17360;
	// 8328E75C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328E760: 4AF9E771  bl 0x8222ced0
	ctx.lr = 0x8328E764;
	sub_8222CED0(ctx, base);
	// 8328E764: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328E768: 38694C18  addi r3, r9, 0x4c18
	ctx.r[3].s64 = ctx.r[9].s64 + 19480;
	// 8328E76C: 4BA1B7B5  bl 0x82ca9f20
	ctx.lr = 0x8328E770;
	sub_82CA9F20(ctx, base);
	// 8328E770: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328E774: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328E778: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328E77C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328E780 size=64
    let mut pc: u32 = 0x8328E780;
    'dispatch: loop {
        match pc {
            0x8328E780 => {
    //   block [0x8328E780..0x8328E7C0)
	// 8328E780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328E784: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328E788: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328E78C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328E790: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328E794: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328E798: 386A43D4  addi r3, r10, 0x43d4
	ctx.r[3].s64 = ctx.r[10].s64 + 17364;
	// 8328E79C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328E7A0: 4AF9E731  bl 0x8222ced0
	ctx.lr = 0x8328E7A4;
	sub_8222CED0(ctx, base);
	// 8328E7A4: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328E7A8: 38694C28  addi r3, r9, 0x4c28
	ctx.r[3].s64 = ctx.r[9].s64 + 19496;
	// 8328E7AC: 4BA1B775  bl 0x82ca9f20
	ctx.lr = 0x8328E7B0;
	sub_82CA9F20(ctx, base);
	// 8328E7B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328E7B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328E7B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328E7BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E7C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328E7C0 size=40
    let mut pc: u32 = 0x8328E7C0;
    'dispatch: loop {
        match pc {
            0x8328E7C0 => {
    //   block [0x8328E7C0..0x8328E7E8)
	// 8328E7C0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8328E7C4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328E7C8: 396B43D8  addi r11, r11, 0x43d8
	ctx.r[11].s64 = ctx.r[11].s64 + 17368;
	// 8328E7CC: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328E7D0: 38694C38  addi r3, r9, 0x4c38
	ctx.r[3].s64 = ctx.r[9].s64 + 19512;
	// 8328E7D4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328E7D8: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328E7DC: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 8328E7E0: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8328E7E4: 4BA1B73C  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E7E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328E7E8 size=64
    let mut pc: u32 = 0x8328E7E8;
    'dispatch: loop {
        match pc {
            0x8328E7E8 => {
    //   block [0x8328E7E8..0x8328E828)
	// 8328E7E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328E7EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328E7F0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328E7F4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328E7F8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328E7FC: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328E800: 386A43EC  addi r3, r10, 0x43ec
	ctx.r[3].s64 = ctx.r[10].s64 + 17388;
	// 8328E804: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328E808: 4AF9E6C9  bl 0x8222ced0
	ctx.lr = 0x8328E80C;
	sub_8222CED0(ctx, base);
	// 8328E80C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328E810: 38694C50  addi r3, r9, 0x4c50
	ctx.r[3].s64 = ctx.r[9].s64 + 19536;
	// 8328E814: 4BA1B70D  bl 0x82ca9f20
	ctx.lr = 0x8328E818;
	sub_82CA9F20(ctx, base);
	// 8328E818: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328E81C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328E820: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328E824: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328E828 size=64
    let mut pc: u32 = 0x8328E828;
    'dispatch: loop {
        match pc {
            0x8328E828 => {
    //   block [0x8328E828..0x8328E868)
	// 8328E828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328E82C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328E830: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328E834: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328E838: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328E83C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328E840: 386A43F0  addi r3, r10, 0x43f0
	ctx.r[3].s64 = ctx.r[10].s64 + 17392;
	// 8328E844: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328E848: 4AF9E689  bl 0x8222ced0
	ctx.lr = 0x8328E84C;
	sub_8222CED0(ctx, base);
	// 8328E84C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328E850: 38694C60  addi r3, r9, 0x4c60
	ctx.r[3].s64 = ctx.r[9].s64 + 19552;
	// 8328E854: 4BA1B6CD  bl 0x82ca9f20
	ctx.lr = 0x8328E858;
	sub_82CA9F20(ctx, base);
	// 8328E858: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328E85C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328E860: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328E864: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328E868 size=120
    let mut pc: u32 = 0x8328E868;
    'dispatch: loop {
        match pc {
            0x8328E868 => {
    //   block [0x8328E868..0x8328E8A4)
	// 8328E868: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8328E86C: 3CE0820F  lis r7, -0x7df1
	ctx.r[7].s64 = -2112946176;
	// 8328E870: 396B4440  addi r11, r11, 0x4440
	ctx.r[11].s64 = ctx.r[11].s64 + 17472;
	// 8328E874: 3CC0820F  lis r6, -0x7df1
	ctx.r[6].s64 = -2112946176;
	// 8328E878: 3D208210  lis r9, -0x7df0
	ctx.r[9].s64 = -2112880640;
	// 8328E87C: 3CA0820F  lis r5, -0x7df1
	ctx.r[5].s64 = -2112946176;
	// 8328E880: 3C80820F  lis r4, -0x7df1
	ctx.r[4].s64 = -2112946176;
	// 8328E884: 39000016  li r8, 0x16
	ctx.r[8].s64 = 22;
	// 8328E888: 396B001C  addi r11, r11, 0x1c
	ctx.r[11].s64 = ctx.r[11].s64 + 28;
	// 8328E88C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328E890: 38E76B78  addi r7, r7, 0x6b78
	ctx.r[7].s64 = ctx.r[7].s64 + 27512;
	// 8328E894: 38C66B74  addi r6, r6, 0x6b74
	ctx.r[6].s64 = ctx.r[6].s64 + 27508;
	// 8328E898: 3929B00C  addi r9, r9, -0x4ff4
	ctx.r[9].s64 = ctx.r[9].s64 + -20468;
	// 8328E89C: 38A56B68  addi r5, r5, 0x6b68
	ctx.r[5].s64 = ctx.r[5].s64 + 27496;
	// 8328E8A0: 38846B58  addi r4, r4, 0x6b58
	ctx.r[4].s64 = ctx.r[4].s64 + 27480;
	pc = 0x8328E8A4; continue 'dispatch;
            }
            0x8328E8A4 => {
    //   block [0x8328E8A4..0x8328E8E0)
	// 8328E8A4: 914BFFE8  stw r10, -0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-24 as u32), ctx.r[10].u32 ) };
	// 8328E8A8: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 8328E8AC: 912BFFEC  stw r9, -0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-20 as u32), ctx.r[9].u32 ) };
	// 8328E8B0: 908BFFE4  stw r4, -0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-28 as u32), ctx.r[4].u32 ) };
	// 8328E8B4: 90ABFFEC  stw r5, -0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-20 as u32), ctx.r[5].u32 ) };
	// 8328E8B8: 914BFFF8  stw r10, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[10].u32 ) };
	// 8328E8BC: 914BFFFC  stw r10, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[10].u32 ) };
	// 8328E8C0: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8328E8C4: 90CBFFF4  stw r6, -0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), ctx.r[6].u32 ) };
	// 8328E8C8: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 8328E8CC: 396B0060  addi r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 + 96;
	// 8328E8D0: 4080FFD4  bge 0x8328e8a4
	if !ctx.cr[0].lt {
	pc = 0x8328E8A4; continue 'dispatch;
	}
	// 8328E8D4: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328E8D8: 386B4C70  addi r3, r11, 0x4c70
	ctx.r[3].s64 = ctx.r[11].s64 + 19568;
	// 8328E8DC: 4BA1B644  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E8E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328E8E0 size=76
    let mut pc: u32 = 0x8328E8E0;
    'dispatch: loop {
        match pc {
            0x8328E8E0 => {
    //   block [0x8328E8E0..0x8328E92C)
	// 8328E8E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328E8E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328E8E8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328E8EC: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 8328E8F0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328E8F4: 388B73E8  addi r4, r11, 0x73e8
	ctx.r[4].s64 = ctx.r[11].s64 + 29672;
	// 8328E8F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8328E8FC: 4AF9E5D5  bl 0x8222ced0
	ctx.lr = 0x8328E900;
	sub_8222CED0(ctx, base);
	// 8328E900: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328E904: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8328E908: 386A43F4  addi r3, r10, 0x43f4
	ctx.r[3].s64 = ctx.r[10].s64 + 17396;
	// 8328E90C: 4B01CBFD  bl 0x822ab508
	ctx.lr = 0x8328E910;
	sub_822AB508(ctx, base);
	// 8328E910: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328E914: 38694D20  addi r3, r9, 0x4d20
	ctx.r[3].s64 = ctx.r[9].s64 + 19744;
	// 8328E918: 4BA1B609  bl 0x82ca9f20
	ctx.lr = 0x8328E91C;
	sub_82CA9F20(ctx, base);
	// 8328E91C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328E920: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328E924: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328E928: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328E930 size=12
    let mut pc: u32 = 0x8328E930;
    'dispatch: loop {
        match pc {
            0x8328E930 => {
    //   block [0x8328E930..0x8328E93C)
	// 8328E930: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328E934: 386B4D30  addi r3, r11, 0x4d30
	ctx.r[3].s64 = ctx.r[11].s64 + 19760;
	// 8328E938: 4BA1B5E8  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328E940 size=12
    let mut pc: u32 = 0x8328E940;
    'dispatch: loop {
        match pc {
            0x8328E940 => {
    //   block [0x8328E940..0x8328E94C)
	// 8328E940: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328E944: 386B4DA8  addi r3, r11, 0x4da8
	ctx.r[3].s64 = ctx.r[11].s64 + 19880;
	// 8328E948: 4BA1B5D8  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328E950 size=64
    let mut pc: u32 = 0x8328E950;
    'dispatch: loop {
        match pc {
            0x8328E950 => {
    //   block [0x8328E950..0x8328E990)
	// 8328E950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328E954: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328E958: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328E95C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328E960: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328E964: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328E968: 386A4D30  addi r3, r10, 0x4d30
	ctx.r[3].s64 = ctx.r[10].s64 + 19760;
	// 8328E96C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328E970: 4AF9E561  bl 0x8222ced0
	ctx.lr = 0x8328E974;
	sub_8222CED0(ctx, base);
	// 8328E974: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328E978: 38694DB8  addi r3, r9, 0x4db8
	ctx.r[3].s64 = ctx.r[9].s64 + 19896;
	// 8328E97C: 4BA1B5A5  bl 0x82ca9f20
	ctx.lr = 0x8328E980;
	sub_82CA9F20(ctx, base);
	// 8328E980: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328E984: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328E988: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328E98C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328E990 size=64
    let mut pc: u32 = 0x8328E990;
    'dispatch: loop {
        match pc {
            0x8328E990 => {
    //   block [0x8328E990..0x8328E9D0)
	// 8328E990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328E994: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328E998: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328E99C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328E9A0: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328E9A4: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328E9A8: 386A4D34  addi r3, r10, 0x4d34
	ctx.r[3].s64 = ctx.r[10].s64 + 19764;
	// 8328E9AC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328E9B0: 4AF9E521  bl 0x8222ced0
	ctx.lr = 0x8328E9B4;
	sub_8222CED0(ctx, base);
	// 8328E9B4: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328E9B8: 38694DC8  addi r3, r9, 0x4dc8
	ctx.r[3].s64 = ctx.r[9].s64 + 19912;
	// 8328E9BC: 4BA1B565  bl 0x82ca9f20
	ctx.lr = 0x8328E9C0;
	sub_82CA9F20(ctx, base);
	// 8328E9C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328E9C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328E9C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328E9CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328E9D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8328E9D0 size=88
    let mut pc: u32 = 0x8328E9D0;
    'dispatch: loop {
        match pc {
            0x8328E9D0 => {
    //   block [0x8328E9D0..0x8328EA28)
	// 8328E9D0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8328E9D4: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 8328E9D8: 3921FFF4  addi r9, r1, -0xc
	ctx.r[9].s64 = ctx.r[1].s64 + -12;
	// 8328E9DC: 3901FFF4  addi r8, r1, -0xc
	ctx.r[8].s64 = ctx.r[1].s64 + -12;
	// 8328E9E0: 38E1FFF0  addi r7, r1, -0x10
	ctx.r[7].s64 = ctx.r[1].s64 + -16;
	// 8328E9E4: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8328E9E8: 3CC0834A  lis r6, -0x7cb6
	ctx.r[6].s64 = -2092302336;
	// 8328E9EC: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328EA28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8328EA28 size=96
    let mut pc: u32 = 0x8328EA28;
    'dispatch: loop {
        match pc {
            0x8328EA28 => {
    //   block [0x8328EA28..0x8328EA88)
	// 8328EA28: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8328EA2C: 3901FFF0  addi r8, r1, -0x10
	ctx.r[8].s64 = ctx.r[1].s64 + -16;
	// 8328EA30: 392B9484  addi r9, r11, -0x6b7c
	ctx.r[9].s64 = ctx.r[11].s64 + -27516;
	// 8328EA34: 3941FFF4  addi r10, r1, -0xc
	ctx.r[10].s64 = ctx.r[1].s64 + -12;
	// 8328EA38: 38E1FFF4  addi r7, r1, -0xc
	ctx.r[7].s64 = ctx.r[1].s64 + -12;
	// 8328EA3C: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8328EA40: 38C1FFF0  addi r6, r1, -0x10
	ctx.r[6].s64 = ctx.r[1].s64 + -16;
	// 8328EA44: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 8328EA48: 3CA0834A  lis r5, -0x7cb6
	ctx.r[5].s64 = -2092302336;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328EA88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328EA88 size=12
    let mut pc: u32 = 0x8328EA88;
    'dispatch: loop {
        match pc {
            0x8328EA88 => {
    //   block [0x8328EA88..0x8328EA94)
	// 8328EA88: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328EA8C: 386B4DD8  addi r3, r11, 0x4dd8
	ctx.r[3].s64 = ctx.r[11].s64 + 19928;
	// 8328EA90: 4BA1B490  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328EA98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328EA98 size=12
    let mut pc: u32 = 0x8328EA98;
    'dispatch: loop {
        match pc {
            0x8328EA98 => {
    //   block [0x8328EA98..0x8328EAA4)
	// 8328EA98: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328EA9C: 386B4E38  addi r3, r11, 0x4e38
	ctx.r[3].s64 = ctx.r[11].s64 + 20024;
	// 8328EAA0: 4BA1B480  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328EAA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328EAA8 size=12
    let mut pc: u32 = 0x8328EAA8;
    'dispatch: loop {
        match pc {
            0x8328EAA8 => {
    //   block [0x8328EAA8..0x8328EAB4)
	// 8328EAA8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328EAAC: 386B4E98  addi r3, r11, 0x4e98
	ctx.r[3].s64 = ctx.r[11].s64 + 20120;
	// 8328EAB0: 4BA1B470  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328EAB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328EAB8 size=64
    let mut pc: u32 = 0x8328EAB8;
    'dispatch: loop {
        match pc {
            0x8328EAB8 => {
    //   block [0x8328EAB8..0x8328EAF8)
	// 8328EAB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328EABC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328EAC0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328EAC4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328EAC8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328EACC: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328EAD0: 386A4DAC  addi r3, r10, 0x4dac
	ctx.r[3].s64 = ctx.r[10].s64 + 19884;
	// 8328EAD4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328EAD8: 4AF9E3F9  bl 0x8222ced0
	ctx.lr = 0x8328EADC;
	sub_8222CED0(ctx, base);
	// 8328EADC: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328EAE0: 38694EA8  addi r3, r9, 0x4ea8
	ctx.r[3].s64 = ctx.r[9].s64 + 20136;
	// 8328EAE4: 4BA1B43D  bl 0x82ca9f20
	ctx.lr = 0x8328EAE8;
	sub_82CA9F20(ctx, base);
	// 8328EAE8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328EAEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328EAF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328EAF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328EAF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328EAF8 size=64
    let mut pc: u32 = 0x8328EAF8;
    'dispatch: loop {
        match pc {
            0x8328EAF8 => {
    //   block [0x8328EAF8..0x8328EB38)
	// 8328EAF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328EAFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328EB00: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328EB04: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328EB08: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328EB0C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328EB10: 386A4DB0  addi r3, r10, 0x4db0
	ctx.r[3].s64 = ctx.r[10].s64 + 19888;
	// 8328EB14: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328EB18: 4AF9E3B9  bl 0x8222ced0
	ctx.lr = 0x8328EB1C;
	sub_8222CED0(ctx, base);
	// 8328EB1C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328EB20: 38694EB8  addi r3, r9, 0x4eb8
	ctx.r[3].s64 = ctx.r[9].s64 + 20152;
	// 8328EB24: 4BA1B3FD  bl 0x82ca9f20
	ctx.lr = 0x8328EB28;
	sub_82CA9F20(ctx, base);
	// 8328EB28: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328EB2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328EB30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328EB34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328EB38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328EB38 size=64
    let mut pc: u32 = 0x8328EB38;
    'dispatch: loop {
        match pc {
            0x8328EB38 => {
    //   block [0x8328EB38..0x8328EB78)
	// 8328EB38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328EB3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328EB40: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328EB44: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328EB48: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328EB4C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328EB50: 386A4DB4  addi r3, r10, 0x4db4
	ctx.r[3].s64 = ctx.r[10].s64 + 19892;
	// 8328EB54: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328EB58: 4AF9E379  bl 0x8222ced0
	ctx.lr = 0x8328EB5C;
	sub_8222CED0(ctx, base);
	// 8328EB5C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328EB60: 38694EC8  addi r3, r9, 0x4ec8
	ctx.r[3].s64 = ctx.r[9].s64 + 20168;
	// 8328EB64: 4BA1B3BD  bl 0x82ca9f20
	ctx.lr = 0x8328EB68;
	sub_82CA9F20(ctx, base);
	// 8328EB68: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328EB6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328EB70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328EB74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328EB78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328EB78 size=64
    let mut pc: u32 = 0x8328EB78;
    'dispatch: loop {
        match pc {
            0x8328EB78 => {
    //   block [0x8328EB78..0x8328EBB8)
	// 8328EB78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328EB7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328EB80: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328EB84: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328EB88: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328EB8C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328EB90: 386A4DB8  addi r3, r10, 0x4db8
	ctx.r[3].s64 = ctx.r[10].s64 + 19896;
	// 8328EB94: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328EB98: 4AF9E339  bl 0x8222ced0
	ctx.lr = 0x8328EB9C;
	sub_8222CED0(ctx, base);
	// 8328EB9C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328EBA0: 38694ED8  addi r3, r9, 0x4ed8
	ctx.r[3].s64 = ctx.r[9].s64 + 20184;
	// 8328EBA4: 4BA1B37D  bl 0x82ca9f20
	ctx.lr = 0x8328EBA8;
	sub_82CA9F20(ctx, base);
	// 8328EBA8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328EBAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328EBB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328EBB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328EBB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328EBB8 size=40
    let mut pc: u32 = 0x8328EBB8;
    'dispatch: loop {
        match pc {
            0x8328EBB8 => {
    //   block [0x8328EBB8..0x8328EBE0)
	// 8328EBB8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8328EBBC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328EBC0: 396B4DBC  addi r11, r11, 0x4dbc
	ctx.r[11].s64 = ctx.r[11].s64 + 19900;
	// 8328EBC4: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328EBC8: 38694EE8  addi r3, r9, 0x4ee8
	ctx.r[3].s64 = ctx.r[9].s64 + 20200;
	// 8328EBCC: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328EBD0: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328EBD4: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 8328EBD8: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8328EBDC: 4BA1B344  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328EBE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328EBE0 size=40
    let mut pc: u32 = 0x8328EBE0;
    'dispatch: loop {
        match pc {
            0x8328EBE0 => {
    //   block [0x8328EBE0..0x8328EC08)
	// 8328EBE0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8328EBE4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328EBE8: 396B4DD0  addi r11, r11, 0x4dd0
	ctx.r[11].s64 = ctx.r[11].s64 + 19920;
	// 8328EBEC: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328EBF0: 38694F00  addi r3, r9, 0x4f00
	ctx.r[3].s64 = ctx.r[9].s64 + 20224;
	// 8328EBF4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328EBF8: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328EBFC: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 8328EC00: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8328EC04: 4BA1B31C  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328EC08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328EC08 size=12
    let mut pc: u32 = 0x8328EC08;
    'dispatch: loop {
        match pc {
            0x8328EC08 => {
    //   block [0x8328EC08..0x8328EC14)
	// 8328EC08: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328EC0C: 386B4F18  addi r3, r11, 0x4f18
	ctx.r[3].s64 = ctx.r[11].s64 + 20248;
	// 8328EC10: 4BA1B310  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328EC18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328EC18 size=64
    let mut pc: u32 = 0x8328EC18;
    'dispatch: loop {
        match pc {
            0x8328EC18 => {
    //   block [0x8328EC18..0x8328EC58)
	// 8328EC18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328EC1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328EC20: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328EC24: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328EC28: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328EC2C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328EC30: 386A4DF4  addi r3, r10, 0x4df4
	ctx.r[3].s64 = ctx.r[10].s64 + 19956;
	// 8328EC34: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328EC38: 4AF9E299  bl 0x8222ced0
	ctx.lr = 0x8328EC3C;
	sub_8222CED0(ctx, base);
	// 8328EC3C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328EC40: 38694F70  addi r3, r9, 0x4f70
	ctx.r[3].s64 = ctx.r[9].s64 + 20336;
	// 8328EC44: 4BA1B2DD  bl 0x82ca9f20
	ctx.lr = 0x8328EC48;
	sub_82CA9F20(ctx, base);
	// 8328EC48: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328EC4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328EC50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328EC54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328EC58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328EC58 size=64
    let mut pc: u32 = 0x8328EC58;
    'dispatch: loop {
        match pc {
            0x8328EC58 => {
    //   block [0x8328EC58..0x8328EC98)
	// 8328EC58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328EC5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328EC60: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328EC64: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328EC68: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328EC6C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328EC70: 386A4DF8  addi r3, r10, 0x4df8
	ctx.r[3].s64 = ctx.r[10].s64 + 19960;
	// 8328EC74: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328EC78: 4AF9E259  bl 0x8222ced0
	ctx.lr = 0x8328EC7C;
	sub_8222CED0(ctx, base);
	// 8328EC7C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328EC80: 38694F80  addi r3, r9, 0x4f80
	ctx.r[3].s64 = ctx.r[9].s64 + 20352;
	// 8328EC84: 4BA1B29D  bl 0x82ca9f20
	ctx.lr = 0x8328EC88;
	sub_82CA9F20(ctx, base);
	// 8328EC88: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328EC8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328EC90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328EC94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328EC98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328EC98 size=64
    let mut pc: u32 = 0x8328EC98;
    'dispatch: loop {
        match pc {
            0x8328EC98 => {
    //   block [0x8328EC98..0x8328ECD8)
	// 8328EC98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328EC9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328ECA0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328ECA4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328ECA8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328ECAC: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328ECB0: 386A4DFC  addi r3, r10, 0x4dfc
	ctx.r[3].s64 = ctx.r[10].s64 + 19964;
	// 8328ECB4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328ECB8: 4AF9E219  bl 0x8222ced0
	ctx.lr = 0x8328ECBC;
	sub_8222CED0(ctx, base);
	// 8328ECBC: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328ECC0: 38694F90  addi r3, r9, 0x4f90
	ctx.r[3].s64 = ctx.r[9].s64 + 20368;
	// 8328ECC4: 4BA1B25D  bl 0x82ca9f20
	ctx.lr = 0x8328ECC8;
	sub_82CA9F20(ctx, base);
	// 8328ECC8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328ECCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328ECD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328ECD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328ECD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328ECD8 size=64
    let mut pc: u32 = 0x8328ECD8;
    'dispatch: loop {
        match pc {
            0x8328ECD8 => {
    //   block [0x8328ECD8..0x8328ED18)
	// 8328ECD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328ECDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328ECE0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328ECE4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328ECE8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328ECEC: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328ECF0: 386A4E00  addi r3, r10, 0x4e00
	ctx.r[3].s64 = ctx.r[10].s64 + 19968;
	// 8328ECF4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328ECF8: 4AF9E1D9  bl 0x8222ced0
	ctx.lr = 0x8328ECFC;
	sub_8222CED0(ctx, base);
	// 8328ECFC: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328ED00: 38694FA0  addi r3, r9, 0x4fa0
	ctx.r[3].s64 = ctx.r[9].s64 + 20384;
	// 8328ED04: 4BA1B21D  bl 0x82ca9f20
	ctx.lr = 0x8328ED08;
	sub_82CA9F20(ctx, base);
	// 8328ED08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328ED0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328ED10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328ED14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328ED18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328ED18 size=64
    let mut pc: u32 = 0x8328ED18;
    'dispatch: loop {
        match pc {
            0x8328ED18 => {
    //   block [0x8328ED18..0x8328ED58)
	// 8328ED18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328ED1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328ED20: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328ED24: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328ED28: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328ED2C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328ED30: 386A4E04  addi r3, r10, 0x4e04
	ctx.r[3].s64 = ctx.r[10].s64 + 19972;
	// 8328ED34: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328ED38: 4AF9E199  bl 0x8222ced0
	ctx.lr = 0x8328ED3C;
	sub_8222CED0(ctx, base);
	// 8328ED3C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328ED40: 38694FB0  addi r3, r9, 0x4fb0
	ctx.r[3].s64 = ctx.r[9].s64 + 20400;
	// 8328ED44: 4BA1B1DD  bl 0x82ca9f20
	ctx.lr = 0x8328ED48;
	sub_82CA9F20(ctx, base);
	// 8328ED48: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328ED4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328ED50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328ED54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328ED58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328ED58 size=64
    let mut pc: u32 = 0x8328ED58;
    'dispatch: loop {
        match pc {
            0x8328ED58 => {
    //   block [0x8328ED58..0x8328ED98)
	// 8328ED58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328ED5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328ED60: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328ED64: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328ED68: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328ED6C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328ED70: 386A4E08  addi r3, r10, 0x4e08
	ctx.r[3].s64 = ctx.r[10].s64 + 19976;
	// 8328ED74: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328ED78: 4AF9E159  bl 0x8222ced0
	ctx.lr = 0x8328ED7C;
	sub_8222CED0(ctx, base);
	// 8328ED7C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328ED80: 38694FC0  addi r3, r9, 0x4fc0
	ctx.r[3].s64 = ctx.r[9].s64 + 20416;
	// 8328ED84: 4BA1B19D  bl 0x82ca9f20
	ctx.lr = 0x8328ED88;
	sub_82CA9F20(ctx, base);
	// 8328ED88: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328ED8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328ED90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328ED94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328ED98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328ED98 size=52
    let mut pc: u32 = 0x8328ED98;
    'dispatch: loop {
        match pc {
            0x8328ED98 => {
    //   block [0x8328ED98..0x8328EDCC)
	// 8328ED98: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 8328ED9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8328EDA0: 38C74E0C  addi r6, r7, 0x4e0c
	ctx.r[6].s64 = ctx.r[7].s64 + 19980;
	// 8328EDA4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328EDA8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8328EDAC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8328EDB0: 91674E0C  stw r11, 0x4e0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(19980 as u32), ctx.r[11].u32 ) };
	// 8328EDB4: 3CA0832B  lis r5, -0x7cd5
	ctx.r[5].s64 = -2094333952;
	// 8328EDB8: 91460004  stw r10, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328EDBC: 91260008  stw r9, 8(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 8328EDC0: 38654FD0  addi r3, r5, 0x4fd0
	ctx.r[3].s64 = ctx.r[5].s64 + 20432;
	// 8328EDC4: 9106000C  stw r8, 0xc(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 8328EDC8: 4BA1B158  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328EDD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328EDD0 size=52
    let mut pc: u32 = 0x8328EDD0;
    'dispatch: loop {
        match pc {
            0x8328EDD0 => {
    //   block [0x8328EDD0..0x8328EE04)
	// 8328EDD0: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 8328EDD4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8328EDD8: 38C74E1C  addi r6, r7, 0x4e1c
	ctx.r[6].s64 = ctx.r[7].s64 + 19996;
	// 8328EDDC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328EDE0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8328EDE4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8328EDE8: 91674E1C  stw r11, 0x4e1c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(19996 as u32), ctx.r[11].u32 ) };
	// 8328EDEC: 3CA0832B  lis r5, -0x7cd5
	ctx.r[5].s64 = -2094333952;
	// 8328EDF0: 91460004  stw r10, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328EDF4: 91260008  stw r9, 8(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 8328EDF8: 38655020  addi r3, r5, 0x5020
	ctx.r[3].s64 = ctx.r[5].s64 + 20512;
	// 8328EDFC: 9106000C  stw r8, 0xc(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 8328EE00: 4BA1B120  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328EE08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328EE08 size=52
    let mut pc: u32 = 0x8328EE08;
    'dispatch: loop {
        match pc {
            0x8328EE08 => {
    //   block [0x8328EE08..0x8328EE3C)
	// 8328EE08: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 8328EE0C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8328EE10: 38C74E2C  addi r6, r7, 0x4e2c
	ctx.r[6].s64 = ctx.r[7].s64 + 20012;
	// 8328EE14: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328EE18: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8328EE1C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8328EE20: 91674E2C  stw r11, 0x4e2c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(20012 as u32), ctx.r[11].u32 ) };
	// 8328EE24: 3CA0832B  lis r5, -0x7cd5
	ctx.r[5].s64 = -2094333952;
	// 8328EE28: 91460004  stw r10, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328EE2C: 91260008  stw r9, 8(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 8328EE30: 38655070  addi r3, r5, 0x5070
	ctx.r[3].s64 = ctx.r[5].s64 + 20592;
	// 8328EE34: 9106000C  stw r8, 0xc(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 8328EE38: 4BA1B0E8  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328EE40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328EE40 size=52
    let mut pc: u32 = 0x8328EE40;
    'dispatch: loop {
        match pc {
            0x8328EE40 => {
    //   block [0x8328EE40..0x8328EE74)
	// 8328EE40: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 8328EE44: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8328EE48: 38C74E3C  addi r6, r7, 0x4e3c
	ctx.r[6].s64 = ctx.r[7].s64 + 20028;
	// 8328EE4C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328EE50: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8328EE54: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8328EE58: 91674E3C  stw r11, 0x4e3c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(20028 as u32), ctx.r[11].u32 ) };
	// 8328EE5C: 3CA0832B  lis r5, -0x7cd5
	ctx.r[5].s64 = -2094333952;
	// 8328EE60: 91460004  stw r10, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328EE64: 91260008  stw r9, 8(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 8328EE68: 386550C0  addi r3, r5, 0x50c0
	ctx.r[3].s64 = ctx.r[5].s64 + 20672;
	// 8328EE6C: 9106000C  stw r8, 0xc(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 8328EE70: 4BA1B0B0  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328EE78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328EE78 size=52
    let mut pc: u32 = 0x8328EE78;
    'dispatch: loop {
        match pc {
            0x8328EE78 => {
    //   block [0x8328EE78..0x8328EEAC)
	// 8328EE78: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 8328EE7C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8328EE80: 38C74E4C  addi r6, r7, 0x4e4c
	ctx.r[6].s64 = ctx.r[7].s64 + 20044;
	// 8328EE84: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328EE88: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8328EE8C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8328EE90: 91674E4C  stw r11, 0x4e4c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(20044 as u32), ctx.r[11].u32 ) };
	// 8328EE94: 3CA0832B  lis r5, -0x7cd5
	ctx.r[5].s64 = -2094333952;
	// 8328EE98: 91460004  stw r10, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328EE9C: 91260008  stw r9, 8(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 8328EEA0: 38655110  addi r3, r5, 0x5110
	ctx.r[3].s64 = ctx.r[5].s64 + 20752;
	// 8328EEA4: 9106000C  stw r8, 0xc(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 8328EEA8: 4BA1B078  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328EEB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328EEB0 size=52
    let mut pc: u32 = 0x8328EEB0;
    'dispatch: loop {
        match pc {
            0x8328EEB0 => {
    //   block [0x8328EEB0..0x8328EEE4)
	// 8328EEB0: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 8328EEB4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8328EEB8: 38C74E5C  addi r6, r7, 0x4e5c
	ctx.r[6].s64 = ctx.r[7].s64 + 20060;
	// 8328EEBC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328EEC0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8328EEC4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8328EEC8: 91674E5C  stw r11, 0x4e5c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(20060 as u32), ctx.r[11].u32 ) };
	// 8328EECC: 3CA0832B  lis r5, -0x7cd5
	ctx.r[5].s64 = -2094333952;
	// 8328EED0: 91460004  stw r10, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328EED4: 91260008  stw r9, 8(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 8328EED8: 38655160  addi r3, r5, 0x5160
	ctx.r[3].s64 = ctx.r[5].s64 + 20832;
	// 8328EEDC: 9106000C  stw r8, 0xc(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 8328EEE0: 4BA1B040  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328EEE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328EEE8 size=12
    let mut pc: u32 = 0x8328EEE8;
    'dispatch: loop {
        match pc {
            0x8328EEE8 => {
    //   block [0x8328EEE8..0x8328EEF4)
	// 8328EEE8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328EEEC: 386B51B0  addi r3, r11, 0x51b0
	ctx.r[3].s64 = ctx.r[11].s64 + 20912;
	// 8328EEF0: 4BA1B030  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328EEF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328EEF8 size=144
    let mut pc: u32 = 0x8328EEF8;
    'dispatch: loop {
        match pc {
            0x8328EEF8 => {
    //   block [0x8328EEF8..0x8328EF1C)
	// 8328EEF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328EEFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328EF00: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328EF04: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 8328EF08: 4AF90351  bl 0x8221f258
	ctx.lr = 0x8328EF0C;
	sub_8221F258(ctx, base);
	// 8328EF0C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328EF10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8328EF14: 419A0008  beq cr6, 0x8328ef1c
	if ctx.cr[6].eq {
	pc = 0x8328EF1C; continue 'dispatch;
	}
	// 8328EF18: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x8328EF1C; continue 'dispatch;
            }
            0x8328EF1C => {
    //   block [0x8328EF1C..0x8328EF28)
	// 8328EF1C: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8328EF20: 41820008  beq 0x8328ef28
	if ctx.cr[0].eq {
	pc = 0x8328EF28; continue 'dispatch;
	}
	// 8328EF24: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x8328EF28; continue 'dispatch;
            }
            0x8328EF28 => {
    //   block [0x8328EF28..0x8328EF34)
	// 8328EF28: 35630008  addic. r11, r3, 8
	ctx.xer.ca = (ctx.r[3].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8328EF2C: 41820008  beq 0x8328ef34
	if ctx.cr[0].eq {
	pc = 0x8328EF34; continue 'dispatch;
	}
	// 8328EF30: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x8328EF34; continue 'dispatch;
            }
            0x8328EF34 => {
    //   block [0x8328EF34..0x8328EF88)
	// 8328EF34: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 8328EF38: 99430015  stb r10, 0x15(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(21 as u32), ctx.r[10].u8 ) };
	// 8328EF3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8328EF40: 39094E6C  addi r8, r9, 0x4e6c
	ctx.r[8].s64 = ctx.r[9].s64 + 20076;
	// 8328EF44: 99630014  stb r11, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 8328EF48: 3CE0832B  lis r7, -0x7cd5
	ctx.r[7].s64 = -2094333952;
	// 8328EF4C: 90680004  stw r3, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 8328EF50: 99630015  stb r11, 0x15(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(21 as u32), ctx.r[11].u8 ) };
	// 8328EF54: 38675210  addi r3, r7, 0x5210
	ctx.r[3].s64 = ctx.r[7].s64 + 21008;
	// 8328EF58: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8328EF5C: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8328EF60: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8328EF64: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8328EF68: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8328EF6C: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8328EF70: 91480008  stw r10, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328EF74: 4BA1AFAD  bl 0x82ca9f20
	ctx.lr = 0x8328EF78;
	sub_82CA9F20(ctx, base);
	// 8328EF78: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328EF7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328EF80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328EF84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328EF88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328EF88 size=64
    let mut pc: u32 = 0x8328EF88;
    'dispatch: loop {
        match pc {
            0x8328EF88 => {
    //   block [0x8328EF88..0x8328EFC8)
	// 8328EF88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328EF8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328EF90: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328EF94: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328EF98: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328EF9C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328EFA0: 386A4E78  addi r3, r10, 0x4e78
	ctx.r[3].s64 = ctx.r[10].s64 + 20088;
	// 8328EFA4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328EFA8: 4AF9DF29  bl 0x8222ced0
	ctx.lr = 0x8328EFAC;
	sub_8222CED0(ctx, base);
	// 8328EFAC: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328EFB0: 38695230  addi r3, r9, 0x5230
	ctx.r[3].s64 = ctx.r[9].s64 + 21040;
	// 8328EFB4: 4BA1AF6D  bl 0x82ca9f20
	ctx.lr = 0x8328EFB8;
	sub_82CA9F20(ctx, base);
	// 8328EFB8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328EFBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328EFC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328EFC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328EFC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328EFC8 size=64
    let mut pc: u32 = 0x8328EFC8;
    'dispatch: loop {
        match pc {
            0x8328EFC8 => {
    //   block [0x8328EFC8..0x8328F008)
	// 8328EFC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328EFCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328EFD0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328EFD4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328EFD8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328EFDC: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328EFE0: 386A4E7C  addi r3, r10, 0x4e7c
	ctx.r[3].s64 = ctx.r[10].s64 + 20092;
	// 8328EFE4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328EFE8: 4AF9DEE9  bl 0x8222ced0
	ctx.lr = 0x8328EFEC;
	sub_8222CED0(ctx, base);
	// 8328EFEC: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328EFF0: 38695240  addi r3, r9, 0x5240
	ctx.r[3].s64 = ctx.r[9].s64 + 21056;
	// 8328EFF4: 4BA1AF2D  bl 0x82ca9f20
	ctx.lr = 0x8328EFF8;
	sub_82CA9F20(ctx, base);
	// 8328EFF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328EFFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328F000: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328F004: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328F008 size=144
    let mut pc: u32 = 0x8328F008;
    'dispatch: loop {
        match pc {
            0x8328F008 => {
    //   block [0x8328F008..0x8328F02C)
	// 8328F008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328F00C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328F010: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328F014: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 8328F018: 4AF90241  bl 0x8221f258
	ctx.lr = 0x8328F01C;
	sub_8221F258(ctx, base);
	// 8328F01C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328F020: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8328F024: 419A0008  beq cr6, 0x8328f02c
	if ctx.cr[6].eq {
	pc = 0x8328F02C; continue 'dispatch;
	}
	// 8328F028: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x8328F02C; continue 'dispatch;
            }
            0x8328F02C => {
    //   block [0x8328F02C..0x8328F038)
	// 8328F02C: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8328F030: 41820008  beq 0x8328f038
	if ctx.cr[0].eq {
	pc = 0x8328F038; continue 'dispatch;
	}
	// 8328F034: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x8328F038; continue 'dispatch;
            }
            0x8328F038 => {
    //   block [0x8328F038..0x8328F044)
	// 8328F038: 35630008  addic. r11, r3, 8
	ctx.xer.ca = (ctx.r[3].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8328F03C: 41820008  beq 0x8328f044
	if ctx.cr[0].eq {
	pc = 0x8328F044; continue 'dispatch;
	}
	// 8328F040: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x8328F044; continue 'dispatch;
            }
            0x8328F044 => {
    //   block [0x8328F044..0x8328F098)
	// 8328F044: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 8328F048: 99430019  stb r10, 0x19(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 8328F04C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8328F050: 39094E80  addi r8, r9, 0x4e80
	ctx.r[8].s64 = ctx.r[9].s64 + 20096;
	// 8328F054: 99630018  stb r11, 0x18(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 8328F058: 3CE0832B  lis r7, -0x7cd5
	ctx.r[7].s64 = -2094333952;
	// 8328F05C: 90680004  stw r3, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 8328F060: 99630019  stb r11, 0x19(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 8328F064: 38675250  addi r3, r7, 0x5250
	ctx.r[3].s64 = ctx.r[7].s64 + 21072;
	// 8328F068: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8328F06C: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8328F070: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8328F074: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8328F078: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8328F07C: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8328F080: 91480008  stw r10, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328F084: 4BA1AE9D  bl 0x82ca9f20
	ctx.lr = 0x8328F088;
	sub_82CA9F20(ctx, base);
	// 8328F088: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328F08C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328F090: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328F094: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328F098 size=64
    let mut pc: u32 = 0x8328F098;
    'dispatch: loop {
        match pc {
            0x8328F098 => {
    //   block [0x8328F098..0x8328F0D8)
	// 8328F098: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328F09C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328F0A0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328F0A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328F0A8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328F0AC: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328F0B0: 386A4E8C  addi r3, r10, 0x4e8c
	ctx.r[3].s64 = ctx.r[10].s64 + 20108;
	// 8328F0B4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328F0B8: 4AF9DE19  bl 0x8222ced0
	ctx.lr = 0x8328F0BC;
	sub_8222CED0(ctx, base);
	// 8328F0BC: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328F0C0: 38695260  addi r3, r9, 0x5260
	ctx.r[3].s64 = ctx.r[9].s64 + 21088;
	// 8328F0C4: 4BA1AE5D  bl 0x82ca9f20
	ctx.lr = 0x8328F0C8;
	sub_82CA9F20(ctx, base);
	// 8328F0C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328F0CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328F0D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328F0D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F0D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328F0D8 size=64
    let mut pc: u32 = 0x8328F0D8;
    'dispatch: loop {
        match pc {
            0x8328F0D8 => {
    //   block [0x8328F0D8..0x8328F118)
	// 8328F0D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328F0DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328F0E0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328F0E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328F0E8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328F0EC: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328F0F0: 386A4E90  addi r3, r10, 0x4e90
	ctx.r[3].s64 = ctx.r[10].s64 + 20112;
	// 8328F0F4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328F0F8: 4AF9DDD9  bl 0x8222ced0
	ctx.lr = 0x8328F0FC;
	sub_8222CED0(ctx, base);
	// 8328F0FC: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328F100: 38695270  addi r3, r9, 0x5270
	ctx.r[3].s64 = ctx.r[9].s64 + 21104;
	// 8328F104: 4BA1AE1D  bl 0x82ca9f20
	ctx.lr = 0x8328F108;
	sub_82CA9F20(ctx, base);
	// 8328F108: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328F10C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328F110: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328F114: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328F118 size=12
    let mut pc: u32 = 0x8328F118;
    'dispatch: loop {
        match pc {
            0x8328F118 => {
    //   block [0x8328F118..0x8328F124)
	// 8328F118: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328F11C: 386B5280  addi r3, r11, 0x5280
	ctx.r[3].s64 = ctx.r[11].s64 + 21120;
	// 8328F120: 4BA1AE00  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328F128 size=64
    let mut pc: u32 = 0x8328F128;
    'dispatch: loop {
        match pc {
            0x8328F128 => {
    //   block [0x8328F128..0x8328F168)
	// 8328F128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328F12C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328F130: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328F134: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328F138: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328F13C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328F140: 386A4EA4  addi r3, r10, 0x4ea4
	ctx.r[3].s64 = ctx.r[10].s64 + 20132;
	// 8328F144: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328F148: 4AF9DD89  bl 0x8222ced0
	ctx.lr = 0x8328F14C;
	sub_8222CED0(ctx, base);
	// 8328F14C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328F150: 386952D8  addi r3, r9, 0x52d8
	ctx.r[3].s64 = ctx.r[9].s64 + 21208;
	// 8328F154: 4BA1ADCD  bl 0x82ca9f20
	ctx.lr = 0x8328F158;
	sub_82CA9F20(ctx, base);
	// 8328F158: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328F15C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328F160: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328F164: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328F168 size=64
    let mut pc: u32 = 0x8328F168;
    'dispatch: loop {
        match pc {
            0x8328F168 => {
    //   block [0x8328F168..0x8328F1A8)
	// 8328F168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328F16C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328F170: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328F174: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328F178: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328F17C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328F180: 386A4EA8  addi r3, r10, 0x4ea8
	ctx.r[3].s64 = ctx.r[10].s64 + 20136;
	// 8328F184: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328F188: 4AF9DD49  bl 0x8222ced0
	ctx.lr = 0x8328F18C;
	sub_8222CED0(ctx, base);
	// 8328F18C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328F190: 386952E8  addi r3, r9, 0x52e8
	ctx.r[3].s64 = ctx.r[9].s64 + 21224;
	// 8328F194: 4BA1AD8D  bl 0x82ca9f20
	ctx.lr = 0x8328F198;
	sub_82CA9F20(ctx, base);
	// 8328F198: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328F19C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328F1A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328F1A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F1A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328F1A8 size=60
    let mut pc: u32 = 0x8328F1A8;
    'dispatch: loop {
        match pc {
            0x8328F1A8 => {
    //   block [0x8328F1A8..0x8328F1B8)
	// 8328F1A8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8328F1AC: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 8328F1B0: 396B4EC0  addi r11, r11, 0x4ec0
	ctx.r[11].s64 = ctx.r[11].s64 + 20160;
	// 8328F1B4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x8328F1B8; continue 'dispatch;
            }
            0x8328F1B8 => {
    //   block [0x8328F1B8..0x8328F1E4)
	// 8328F1B8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8328F1BC: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8328F1C0: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328F1C4: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328F1C8: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 8328F1CC: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8328F1D0: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 8328F1D4: 4080FFE4  bge 0x8328f1b8
	if !ctx.cr[0].lt {
	pc = 0x8328F1B8; continue 'dispatch;
	}
	// 8328F1D8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328F1DC: 386B52F8  addi r3, r11, 0x52f8
	ctx.r[3].s64 = ctx.r[11].s64 + 21240;
	// 8328F1E0: 4BA1AD40  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F1E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328F1E8 size=40
    let mut pc: u32 = 0x8328F1E8;
    'dispatch: loop {
        match pc {
            0x8328F1E8 => {
    //   block [0x8328F1E8..0x8328F210)
	// 8328F1E8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8328F1EC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328F1F0: 396B4EAC  addi r11, r11, 0x4eac
	ctx.r[11].s64 = ctx.r[11].s64 + 20140;
	// 8328F1F4: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328F1F8: 38695350  addi r3, r9, 0x5350
	ctx.r[3].s64 = ctx.r[9].s64 + 21328;
	// 8328F1FC: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328F200: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328F204: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 8328F208: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8328F20C: 4BA1AD14  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328F210 size=40
    let mut pc: u32 = 0x8328F210;
    'dispatch: loop {
        match pc {
            0x8328F210 => {
    //   block [0x8328F210..0x8328F238)
	// 8328F210: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8328F214: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328F218: 396B4F10  addi r11, r11, 0x4f10
	ctx.r[11].s64 = ctx.r[11].s64 + 20240;
	// 8328F21C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328F220: 38695368  addi r3, r9, 0x5368
	ctx.r[3].s64 = ctx.r[9].s64 + 21352;
	// 8328F224: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328F228: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328F22C: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 8328F230: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8328F234: 4BA1ACEC  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328F238 size=64
    let mut pc: u32 = 0x8328F238;
    'dispatch: loop {
        match pc {
            0x8328F238 => {
    //   block [0x8328F238..0x8328F278)
	// 8328F238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328F23C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328F240: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328F244: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328F248: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328F24C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328F250: 386A4F24  addi r3, r10, 0x4f24
	ctx.r[3].s64 = ctx.r[10].s64 + 20260;
	// 8328F254: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328F258: 4AF9DC79  bl 0x8222ced0
	ctx.lr = 0x8328F25C;
	sub_8222CED0(ctx, base);
	// 8328F25C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328F260: 38695380  addi r3, r9, 0x5380
	ctx.r[3].s64 = ctx.r[9].s64 + 21376;
	// 8328F264: 4BA1ACBD  bl 0x82ca9f20
	ctx.lr = 0x8328F268;
	sub_82CA9F20(ctx, base);
	// 8328F268: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328F26C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328F270: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328F274: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328F278 size=64
    let mut pc: u32 = 0x8328F278;
    'dispatch: loop {
        match pc {
            0x8328F278 => {
    //   block [0x8328F278..0x8328F2B8)
	// 8328F278: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328F27C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328F280: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328F284: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328F288: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328F28C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328F290: 386A4F28  addi r3, r10, 0x4f28
	ctx.r[3].s64 = ctx.r[10].s64 + 20264;
	// 8328F294: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328F298: 4AF9DC39  bl 0x8222ced0
	ctx.lr = 0x8328F29C;
	sub_8222CED0(ctx, base);
	// 8328F29C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328F2A0: 38695390  addi r3, r9, 0x5390
	ctx.r[3].s64 = ctx.r[9].s64 + 21392;
	// 8328F2A4: 4BA1AC7D  bl 0x82ca9f20
	ctx.lr = 0x8328F2A8;
	sub_82CA9F20(ctx, base);
	// 8328F2A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328F2AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328F2B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328F2B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F2B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328F2B8 size=60
    let mut pc: u32 = 0x8328F2B8;
    'dispatch: loop {
        match pc {
            0x8328F2B8 => {
    //   block [0x8328F2B8..0x8328F2C8)
	// 8328F2B8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8328F2BC: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 8328F2C0: 396B4F30  addi r11, r11, 0x4f30
	ctx.r[11].s64 = ctx.r[11].s64 + 20272;
	// 8328F2C4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x8328F2C8; continue 'dispatch;
            }
            0x8328F2C8 => {
    //   block [0x8328F2C8..0x8328F2F4)
	// 8328F2C8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8328F2CC: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8328F2D0: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328F2D4: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328F2D8: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 8328F2DC: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8328F2E0: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 8328F2E4: 4080FFE4  bge 0x8328f2c8
	if !ctx.cr[0].lt {
	pc = 0x8328F2C8; continue 'dispatch;
	}
	// 8328F2E8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328F2EC: 386B53A0  addi r3, r11, 0x53a0
	ctx.r[3].s64 = ctx.r[11].s64 + 21408;
	// 8328F2F0: 4BA1AC30  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F2F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328F2F8 size=12
    let mut pc: u32 = 0x8328F2F8;
    'dispatch: loop {
        match pc {
            0x8328F2F8 => {
    //   block [0x8328F2F8..0x8328F304)
	// 8328F2F8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328F2FC: 386B53F8  addi r3, r11, 0x53f8
	ctx.r[3].s64 = ctx.r[11].s64 + 21496;
	// 8328F300: 4BA1AC20  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328F308 size=64
    let mut pc: u32 = 0x8328F308;
    'dispatch: loop {
        match pc {
            0x8328F308 => {
    //   block [0x8328F308..0x8328F348)
	// 8328F308: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328F30C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328F310: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328F314: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328F318: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328F31C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328F320: 386A4F84  addi r3, r10, 0x4f84
	ctx.r[3].s64 = ctx.r[10].s64 + 20356;
	// 8328F324: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328F328: 4AF9DBA9  bl 0x8222ced0
	ctx.lr = 0x8328F32C;
	sub_8222CED0(ctx, base);
	// 8328F32C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328F330: 38695470  addi r3, r9, 0x5470
	ctx.r[3].s64 = ctx.r[9].s64 + 21616;
	// 8328F334: 4BA1ABED  bl 0x82ca9f20
	ctx.lr = 0x8328F338;
	sub_82CA9F20(ctx, base);
	// 8328F338: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328F33C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328F340: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328F344: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328F348 size=64
    let mut pc: u32 = 0x8328F348;
    'dispatch: loop {
        match pc {
            0x8328F348 => {
    //   block [0x8328F348..0x8328F388)
	// 8328F348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328F34C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328F350: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328F354: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328F358: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328F35C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328F360: 386A4F88  addi r3, r10, 0x4f88
	ctx.r[3].s64 = ctx.r[10].s64 + 20360;
	// 8328F364: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328F368: 4AF9DB69  bl 0x8222ced0
	ctx.lr = 0x8328F36C;
	sub_8222CED0(ctx, base);
	// 8328F36C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328F370: 38695480  addi r3, r9, 0x5480
	ctx.r[3].s64 = ctx.r[9].s64 + 21632;
	// 8328F374: 4BA1ABAD  bl 0x82ca9f20
	ctx.lr = 0x8328F378;
	sub_82CA9F20(ctx, base);
	// 8328F378: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328F37C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328F380: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328F384: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328F388 size=40
    let mut pc: u32 = 0x8328F388;
    'dispatch: loop {
        match pc {
            0x8328F388 => {
    //   block [0x8328F388..0x8328F3B0)
	// 8328F388: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8328F38C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328F390: 396B4F8C  addi r11, r11, 0x4f8c
	ctx.r[11].s64 = ctx.r[11].s64 + 20364;
	// 8328F394: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328F398: 38695490  addi r3, r9, 0x5490
	ctx.r[3].s64 = ctx.r[9].s64 + 21648;
	// 8328F39C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328F3A0: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328F3A4: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 8328F3A8: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8328F3AC: 4BA1AB74  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F3B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328F3B0 size=40
    let mut pc: u32 = 0x8328F3B0;
    'dispatch: loop {
        match pc {
            0x8328F3B0 => {
    //   block [0x8328F3B0..0x8328F3D8)
	// 8328F3B0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8328F3B4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328F3B8: 396B4FA0  addi r11, r11, 0x4fa0
	ctx.r[11].s64 = ctx.r[11].s64 + 20384;
	// 8328F3BC: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328F3C0: 386954A8  addi r3, r9, 0x54a8
	ctx.r[3].s64 = ctx.r[9].s64 + 21672;
	// 8328F3C4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328F3C8: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328F3CC: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 8328F3D0: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8328F3D4: 4BA1AB4C  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F3D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328F3D8 size=40
    let mut pc: u32 = 0x8328F3D8;
    'dispatch: loop {
        match pc {
            0x8328F3D8 => {
    //   block [0x8328F3D8..0x8328F400)
	// 8328F3D8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8328F3DC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328F3E0: 396B4FB4  addi r11, r11, 0x4fb4
	ctx.r[11].s64 = ctx.r[11].s64 + 20404;
	// 8328F3E4: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328F3E8: 386954C0  addi r3, r9, 0x54c0
	ctx.r[3].s64 = ctx.r[9].s64 + 21696;
	// 8328F3EC: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328F3F0: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328F3F4: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 8328F3F8: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8328F3FC: 4BA1AB24  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328F400 size=40
    let mut pc: u32 = 0x8328F400;
    'dispatch: loop {
        match pc {
            0x8328F400 => {
    //   block [0x8328F400..0x8328F428)
	// 8328F400: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8328F404: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328F408: 396B4FC8  addi r11, r11, 0x4fc8
	ctx.r[11].s64 = ctx.r[11].s64 + 20424;
	// 8328F40C: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328F410: 386954D8  addi r3, r9, 0x54d8
	ctx.r[3].s64 = ctx.r[9].s64 + 21720;
	// 8328F414: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328F418: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328F41C: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 8328F420: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8328F424: 4BA1AAFC  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328F428 size=40
    let mut pc: u32 = 0x8328F428;
    'dispatch: loop {
        match pc {
            0x8328F428 => {
    //   block [0x8328F428..0x8328F450)
	// 8328F428: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8328F42C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328F430: 396B4FDC  addi r11, r11, 0x4fdc
	ctx.r[11].s64 = ctx.r[11].s64 + 20444;
	// 8328F434: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328F438: 386954F0  addi r3, r9, 0x54f0
	ctx.r[3].s64 = ctx.r[9].s64 + 21744;
	// 8328F43C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8328F440: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328F444: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 8328F448: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8328F44C: 4BA1AAD4  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328F450 size=64
    let mut pc: u32 = 0x8328F450;
    'dispatch: loop {
        match pc {
            0x8328F450 => {
    //   block [0x8328F450..0x8328F490)
	// 8328F450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328F454: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328F458: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328F45C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328F460: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328F464: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328F468: 386A4FF0  addi r3, r10, 0x4ff0
	ctx.r[3].s64 = ctx.r[10].s64 + 20464;
	// 8328F46C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328F470: 4AF9DA61  bl 0x8222ced0
	ctx.lr = 0x8328F474;
	sub_8222CED0(ctx, base);
	// 8328F474: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328F478: 38695560  addi r3, r9, 0x5560
	ctx.r[3].s64 = ctx.r[9].s64 + 21856;
	// 8328F47C: 4BA1AAA5  bl 0x82ca9f20
	ctx.lr = 0x8328F480;
	sub_82CA9F20(ctx, base);
	// 8328F480: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328F484: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328F488: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328F48C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328F490 size=64
    let mut pc: u32 = 0x8328F490;
    'dispatch: loop {
        match pc {
            0x8328F490 => {
    //   block [0x8328F490..0x8328F4D0)
	// 8328F490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328F494: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328F498: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328F49C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328F4A0: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328F4A4: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328F4A8: 386A4FF4  addi r3, r10, 0x4ff4
	ctx.r[3].s64 = ctx.r[10].s64 + 20468;
	// 8328F4AC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328F4B0: 4AF9DA21  bl 0x8222ced0
	ctx.lr = 0x8328F4B4;
	sub_8222CED0(ctx, base);
	// 8328F4B4: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328F4B8: 38695570  addi r3, r9, 0x5570
	ctx.r[3].s64 = ctx.r[9].s64 + 21872;
	// 8328F4BC: 4BA1AA65  bl 0x82ca9f20
	ctx.lr = 0x8328F4C0;
	sub_82CA9F20(ctx, base);
	// 8328F4C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328F4C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328F4C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328F4CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F4D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328F4D0 size=12
    let mut pc: u32 = 0x8328F4D0;
    'dispatch: loop {
        match pc {
            0x8328F4D0 => {
    //   block [0x8328F4D0..0x8328F4DC)
	// 8328F4D0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328F4D4: 386B5580  addi r3, r11, 0x5580
	ctx.r[3].s64 = ctx.r[11].s64 + 21888;
	// 8328F4D8: 4BA1AA48  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F4E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328F4E0 size=12
    let mut pc: u32 = 0x8328F4E0;
    'dispatch: loop {
        match pc {
            0x8328F4E0 => {
    //   block [0x8328F4E0..0x8328F4EC)
	// 8328F4E0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328F4E4: 386B55D8  addi r3, r11, 0x55d8
	ctx.r[3].s64 = ctx.r[11].s64 + 21976;
	// 8328F4E8: 4BA1AA38  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F4F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328F4F0 size=12
    let mut pc: u32 = 0x8328F4F0;
    'dispatch: loop {
        match pc {
            0x8328F4F0 => {
    //   block [0x8328F4F0..0x8328F4FC)
	// 8328F4F0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328F4F4: 386B5630  addi r3, r11, 0x5630
	ctx.r[3].s64 = ctx.r[11].s64 + 22064;
	// 8328F4F8: 4BA1AA28  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328F500 size=64
    let mut pc: u32 = 0x8328F500;
    'dispatch: loop {
        match pc {
            0x8328F500 => {
    //   block [0x8328F500..0x8328F540)
	// 8328F500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328F504: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328F508: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328F50C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328F510: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328F514: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328F518: 386A5028  addi r3, r10, 0x5028
	ctx.r[3].s64 = ctx.r[10].s64 + 20520;
	// 8328F51C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328F520: 4AF9D9B1  bl 0x8222ced0
	ctx.lr = 0x8328F524;
	sub_8222CED0(ctx, base);
	// 8328F524: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328F528: 38695688  addi r3, r9, 0x5688
	ctx.r[3].s64 = ctx.r[9].s64 + 22152;
	// 8328F52C: 4BA1A9F5  bl 0x82ca9f20
	ctx.lr = 0x8328F530;
	sub_82CA9F20(ctx, base);
	// 8328F530: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328F534: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328F538: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328F53C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328F540 size=64
    let mut pc: u32 = 0x8328F540;
    'dispatch: loop {
        match pc {
            0x8328F540 => {
    //   block [0x8328F540..0x8328F580)
	// 8328F540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328F544: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328F548: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328F54C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328F550: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328F554: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328F558: 386A502C  addi r3, r10, 0x502c
	ctx.r[3].s64 = ctx.r[10].s64 + 20524;
	// 8328F55C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328F560: 4AF9D971  bl 0x8222ced0
	ctx.lr = 0x8328F564;
	sub_8222CED0(ctx, base);
	// 8328F564: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328F568: 38695698  addi r3, r9, 0x5698
	ctx.r[3].s64 = ctx.r[9].s64 + 22168;
	// 8328F56C: 4BA1A9B5  bl 0x82ca9f20
	ctx.lr = 0x8328F570;
	sub_82CA9F20(ctx, base);
	// 8328F570: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328F574: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328F578: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328F57C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8328F580 size=12
    let mut pc: u32 = 0x8328F580;
    'dispatch: loop {
        match pc {
            0x8328F580 => {
    //   block [0x8328F580..0x8328F58C)
	// 8328F580: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8328F584: 386B56A8  addi r3, r11, 0x56a8
	ctx.r[3].s64 = ctx.r[11].s64 + 22184;
	// 8328F588: 4BA1A998  b 0x82ca9f20
	sub_82CA9F20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328F590 size=96
    let mut pc: u32 = 0x8328F590;
    'dispatch: loop {
        match pc {
            0x8328F590 => {
    //   block [0x8328F590..0x8328F5B4)
	// 8328F590: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328F594: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328F598: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328F59C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8328F5A0: 4AF8FCB9  bl 0x8221f258
	ctx.lr = 0x8328F5A4;
	sub_8221F258(ctx, base);
	// 8328F5A4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8328F5A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8328F5AC: 419A0008  beq cr6, 0x8328f5b4
	if ctx.cr[6].eq {
	pc = 0x8328F5B4; continue 'dispatch;
	}
	// 8328F5B0: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x8328F5B4; continue 'dispatch;
            }
            0x8328F5B4 => {
    //   block [0x8328F5B4..0x8328F5C0)
	// 8328F5B4: 354B0004  addic. r10, r11, 4
	ctx.xer.ca = (ctx.r[11].u32 > (!(4 as u32)));
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8328F5B8: 41820008  beq 0x8328f5c0
	if ctx.cr[0].eq {
	pc = 0x8328F5C0; continue 'dispatch;
	}
	// 8328F5BC: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x8328F5C0; continue 'dispatch;
            }
            0x8328F5C0 => {
    //   block [0x8328F5C0..0x8328F5F0)
	// 8328F5C0: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 8328F5C4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328F5C8: 39095034  addi r8, r9, 0x5034
	ctx.r[8].s64 = ctx.r[9].s64 + 20532;
	// 8328F5CC: 3CE0832B  lis r7, -0x7cd5
	ctx.r[7].s64 = -2094333952;
	// 8328F5D0: 386756E8  addi r3, r7, 0x56e8
	ctx.r[3].s64 = ctx.r[7].s64 + 22248;
	// 8328F5D4: 91680004  stw r11, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8328F5D8: 91480008  stw r10, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328F5DC: 4BA1A945  bl 0x82ca9f20
	ctx.lr = 0x8328F5E0;
	sub_82CA9F20(ctx, base);
	// 8328F5E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328F5E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328F5E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328F5EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F5F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328F5F0 size=96
    let mut pc: u32 = 0x8328F5F0;
    'dispatch: loop {
        match pc {
            0x8328F5F0 => {
    //   block [0x8328F5F0..0x8328F614)
	// 8328F5F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328F5F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328F5F8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328F5FC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8328F600: 4AF8FC59  bl 0x8221f258
	ctx.lr = 0x8328F604;
	sub_8221F258(ctx, base);
	// 8328F604: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8328F608: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8328F60C: 419A0008  beq cr6, 0x8328f614
	if ctx.cr[6].eq {
	pc = 0x8328F614; continue 'dispatch;
	}
	// 8328F610: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x8328F614; continue 'dispatch;
            }
            0x8328F614 => {
    //   block [0x8328F614..0x8328F620)
	// 8328F614: 354B0004  addic. r10, r11, 4
	ctx.xer.ca = (ctx.r[11].u32 > (!(4 as u32)));
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8328F618: 41820008  beq 0x8328f620
	if ctx.cr[0].eq {
	pc = 0x8328F620; continue 'dispatch;
	}
	// 8328F61C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x8328F620; continue 'dispatch;
            }
            0x8328F620 => {
    //   block [0x8328F620..0x8328F650)
	// 8328F620: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 8328F624: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328F628: 39095040  addi r8, r9, 0x5040
	ctx.r[8].s64 = ctx.r[9].s64 + 20544;
	// 8328F62C: 3CE0832B  lis r7, -0x7cd5
	ctx.r[7].s64 = -2094333952;
	// 8328F630: 38675730  addi r3, r7, 0x5730
	ctx.r[3].s64 = ctx.r[7].s64 + 22320;
	// 8328F634: 91680004  stw r11, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8328F638: 91480008  stw r10, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328F63C: 4BA1A8E5  bl 0x82ca9f20
	ctx.lr = 0x8328F640;
	sub_82CA9F20(ctx, base);
	// 8328F640: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328F644: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328F648: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328F64C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328F650 size=96
    let mut pc: u32 = 0x8328F650;
    'dispatch: loop {
        match pc {
            0x8328F650 => {
    //   block [0x8328F650..0x8328F674)
	// 8328F650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328F654: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328F658: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328F65C: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 8328F660: 4AF8FBF9  bl 0x8221f258
	ctx.lr = 0x8328F664;
	sub_8221F258(ctx, base);
	// 8328F664: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8328F668: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8328F66C: 419A0008  beq cr6, 0x8328f674
	if ctx.cr[6].eq {
	pc = 0x8328F674; continue 'dispatch;
	}
	// 8328F670: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x8328F674; continue 'dispatch;
            }
            0x8328F674 => {
    //   block [0x8328F674..0x8328F680)
	// 8328F674: 354B0004  addic. r10, r11, 4
	ctx.xer.ca = (ctx.r[11].u32 > (!(4 as u32)));
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8328F678: 41820008  beq 0x8328f680
	if ctx.cr[0].eq {
	pc = 0x8328F680; continue 'dispatch;
	}
	// 8328F67C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x8328F680; continue 'dispatch;
            }
            0x8328F680 => {
    //   block [0x8328F680..0x8328F6B0)
	// 8328F680: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 8328F684: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328F688: 3909504C  addi r8, r9, 0x504c
	ctx.r[8].s64 = ctx.r[9].s64 + 20556;
	// 8328F68C: 3CE0832B  lis r7, -0x7cd5
	ctx.r[7].s64 = -2094333952;
	// 8328F690: 38675778  addi r3, r7, 0x5778
	ctx.r[3].s64 = ctx.r[7].s64 + 22392;
	// 8328F694: 91680004  stw r11, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8328F698: 91480008  stw r10, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328F69C: 4BA1A885  bl 0x82ca9f20
	ctx.lr = 0x8328F6A0;
	sub_82CA9F20(ctx, base);
	// 8328F6A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328F6A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328F6A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328F6AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F6B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328F6B0 size=96
    let mut pc: u32 = 0x8328F6B0;
    'dispatch: loop {
        match pc {
            0x8328F6B0 => {
    //   block [0x8328F6B0..0x8328F6D4)
	// 8328F6B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328F6B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328F6B8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328F6BC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8328F6C0: 4AF8FB99  bl 0x8221f258
	ctx.lr = 0x8328F6C4;
	sub_8221F258(ctx, base);
	// 8328F6C4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8328F6C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8328F6CC: 419A0008  beq cr6, 0x8328f6d4
	if ctx.cr[6].eq {
	pc = 0x8328F6D4; continue 'dispatch;
	}
	// 8328F6D0: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x8328F6D4; continue 'dispatch;
            }
            0x8328F6D4 => {
    //   block [0x8328F6D4..0x8328F6E0)
	// 8328F6D4: 354B0004  addic. r10, r11, 4
	ctx.xer.ca = (ctx.r[11].u32 > (!(4 as u32)));
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8328F6D8: 41820008  beq 0x8328f6e0
	if ctx.cr[0].eq {
	pc = 0x8328F6E0; continue 'dispatch;
	}
	// 8328F6DC: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x8328F6E0; continue 'dispatch;
            }
            0x8328F6E0 => {
    //   block [0x8328F6E0..0x8328F710)
	// 8328F6E0: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 8328F6E4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8328F6E8: 39095058  addi r8, r9, 0x5058
	ctx.r[8].s64 = ctx.r[9].s64 + 20568;
	// 8328F6EC: 3CE0832B  lis r7, -0x7cd5
	ctx.r[7].s64 = -2094333952;
	// 8328F6F0: 38675800  addi r3, r7, 0x5800
	ctx.r[3].s64 = ctx.r[7].s64 + 22528;
	// 8328F6F4: 91680004  stw r11, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8328F6F8: 91480008  stw r10, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8328F6FC: 4BA1A825  bl 0x82ca9f20
	ctx.lr = 0x8328F700;
	sub_82CA9F20(ctx, base);
	// 8328F700: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328F704: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328F708: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328F70C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8328F710 size=100
    let mut pc: u32 = 0x8328F710;
    'dispatch: loop {
        match pc {
            0x8328F710 => {
    //   block [0x8328F710..0x8328F774)
	// 8328F710: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8328F714: 3921FFF0  addi r9, r1, -0x10
	ctx.r[9].s64 = ctx.r[1].s64 + -16;
	// 8328F718: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8328F71C: 3901FFF4  addi r8, r1, -0xc
	ctx.r[8].s64 = ctx.r[1].s64 + -12;
	// 8328F720: 38E1FFF4  addi r7, r1, -0xc
	ctx.r[7].s64 = ctx.r[1].s64 + -12;
	// 8328F724: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8328F728: 38C1FFF0  addi r6, r1, -0x10
	ctx.r[6].s64 = ctx.r[1].s64 + -16;
	// 8328F72C: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 8328F730: 3CA08332  lis r5, -0x7cce
	ctx.r[5].s64 = -2093875200;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8328F778 size=100
    let mut pc: u32 = 0x8328F778;
    'dispatch: loop {
        match pc {
            0x8328F778 => {
    //   block [0x8328F778..0x8328F7DC)
	// 8328F778: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8328F77C: 3941FFF4  addi r10, r1, -0xc
	ctx.r[10].s64 = ctx.r[1].s64 + -12;
	// 8328F780: 392B9490  addi r9, r11, -0x6b70
	ctx.r[9].s64 = ctx.r[11].s64 + -27504;
	// 8328F784: 3901FFF8  addi r8, r1, -8
	ctx.r[8].s64 = ctx.r[1].s64 + -8;
	// 8328F788: 38E1FFF8  addi r7, r1, -8
	ctx.r[7].s64 = ctx.r[1].s64 + -8;
	// 8328F78C: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8328F790: 38C1FFF0  addi r6, r1, -0x10
	ctx.r[6].s64 = ctx.r[1].s64 + -16;
	// 8328F794: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 8328F798: 3CA0834A  lis r5, -0x7cb6
	ctx.r[5].s64 = -2092302336;
	// 8328F79C: C009FFF4  lfs f0, -0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8328F7A0: D001FFF4  stfs f0, -0xc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 8328F7A4: 38855070  addi r4, r5, 0x5070
	ctx.r[4].s64 = ctx.r[5].s64 + 20592;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F7E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328F7E0 size=64
    let mut pc: u32 = 0x8328F7E0;
    'dispatch: loop {
        match pc {
            0x8328F7E0 => {
    //   block [0x8328F7E0..0x8328F820)
	// 8328F7E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328F7E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328F7E8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328F7EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328F7F0: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328F7F4: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328F7F8: 386A5080  addi r3, r10, 0x5080
	ctx.r[3].s64 = ctx.r[10].s64 + 20608;
	// 8328F7FC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328F800: 4AF9D6D1  bl 0x8222ced0
	ctx.lr = 0x8328F804;
	sub_8222CED0(ctx, base);
	// 8328F804: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328F808: 38695848  addi r3, r9, 0x5848
	ctx.r[3].s64 = ctx.r[9].s64 + 22600;
	// 8328F80C: 4BA1A715  bl 0x82ca9f20
	ctx.lr = 0x8328F810;
	sub_82CA9F20(ctx, base);
	// 8328F810: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328F814: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328F818: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328F81C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8328F820 size=64
    let mut pc: u32 = 0x8328F820;
    'dispatch: loop {
        match pc {
            0x8328F820 => {
    //   block [0x8328F820..0x8328F860)
	// 8328F820: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8328F824: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8328F828: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8328F82C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328F830: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8328F834: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 8328F838: 386A5084  addi r3, r10, 0x5084
	ctx.r[3].s64 = ctx.r[10].s64 + 20612;
	// 8328F83C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8328F840: 4AF9D691  bl 0x8222ced0
	ctx.lr = 0x8328F844;
	sub_8222CED0(ctx, base);
	// 8328F844: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8328F848: 38695858  addi r3, r9, 0x5858
	ctx.r[3].s64 = ctx.r[9].s64 + 22616;
	// 8328F84C: 4BA1A6D5  bl 0x82ca9f20
	ctx.lr = 0x8328F850;
	sub_82CA9F20(ctx, base);
	// 8328F850: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8328F854: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8328F858: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8328F85C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8328F860 size=88
    let mut pc: u32 = 0x8328F860;
    'dispatch: loop {
        match pc {
            0x8328F860 => {
    //   block [0x8328F860..0x8328F8B8)
	// 8328F860: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8328F864: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 8328F868: 3921FFF4  addi r9, r1, -0xc
	ctx.r[9].s64 = ctx.r[1].s64 + -12;
	// 8328F86C: 3901FFF4  addi r8, r1, -0xc
	ctx.r[8].s64 = ctx.r[1].s64 + -12;
	// 8328F870: 38E1FFF0  addi r7, r1, -0x10
	ctx.r[7].s64 = ctx.r[1].s64 + -16;
	// 8328F874: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8328F878: 3CC0834A  lis r6, -0x7cb6
	ctx.r[6].s64 = -2092302336;
	// 8328F87C: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F8B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8328F8B8 size=88
    let mut pc: u32 = 0x8328F8B8;
    'dispatch: loop {
        match pc {
            0x8328F8B8 => {
    //   block [0x8328F8B8..0x8328F910)
	// 8328F8B8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8328F8BC: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 8328F8C0: 3921FFF4  addi r9, r1, -0xc
	ctx.r[9].s64 = ctx.r[1].s64 + -12;
	// 8328F8C4: 3901FFF4  addi r8, r1, -0xc
	ctx.r[8].s64 = ctx.r[1].s64 + -12;
	// 8328F8C8: 38E1FFF0  addi r7, r1, -0x10
	ctx.r[7].s64 = ctx.r[1].s64 + -16;
	// 8328F8CC: C00B0C68  lfs f0, 0xc68(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8328F8D0: 3CC0834A  lis r6, -0x7cb6
	ctx.r[6].s64 = -2092302336;
	// 8328F8D4: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8328F910 size=88
    let mut pc: u32 = 0x8328F910;
    'dispatch: loop {
        match pc {
            0x8328F910 => {
    //   block [0x8328F910..0x8328F968)
	// 8328F910: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8328F914: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 8328F918: 3921FFF4  addi r9, r1, -0xc
	ctx.r[9].s64 = ctx.r[1].s64 + -12;
	// 8328F91C: 3901FFF4  addi r8, r1, -0xc
	ctx.r[8].s64 = ctx.r[1].s64 + -12;
	// 8328F920: 38E1FFF0  addi r7, r1, -0x10
	ctx.r[7].s64 = ctx.r[1].s64 + -16;
	// 8328F924: C00BB7A4  lfs f0, -0x485c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-18524 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8328F928: 3CC0834A  lis r6, -0x7cb6
	ctx.r[6].s64 = -2092302336;
	// 8328F92C: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8328F968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8328F968 size=96
    let mut pc: u32 = 0x8328F968;
    'dispatch: loop {
        match pc {
            0x8328F968 => {
    //   block [0x8328F968..0x8328F9C8)
	// 8328F968: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8328F96C: 3901FFF0  addi r8, r1, -0x10
	ctx.r[8].s64 = ctx.r[1].s64 + -16;
	// 8328F970: 392B9484  addi r9, r11, -0x6b7c
	ctx.r[9].s64 = ctx.r[11].s64 + -27516;
	// 8328F974: 3941FFF4  addi r10, r1, -0xc
	ctx.r[10].s64 = ctx.r[1].s64 + -12;
	// 8328F978: 38E1FFF4  addi r7, r1, -0xc
	ctx.r[7].s64 = ctx.r[1].s64 + -12;
	// 8328F97C: C1AB9484  lfs f13, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8328F980: 38C1FFF0  addi r6, r1, -0x10
	ctx.r[6].s64 = ctx.r[1].s64 + -16;
	// 8328F984: D1A1FFF0  stfs f13, -0x10(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 8328F988: 3CA0834A  lis r5, -0x7cb6
	ctx.r[5].s64 = -2092302336;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


