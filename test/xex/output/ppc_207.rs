pub fn sub_83230C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x83230C30 size=276
    let mut pc: u32 = 0x83230C30;
    'dispatch: loop {
        match pc {
            0x83230C30 => {
    //   block [0x83230C30..0x83230C64)
	// 83230C30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83230C34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83230C38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 83230C3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 83230C40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83230C44: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 83230C48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83230C4C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 83230C50: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 83230C54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83230C58: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 83230C5C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 83230C60: 419A0020  beq cr6, 0x83230c80
	if ctx.cr[6].eq {
	pc = 0x83230C80; continue 'dispatch;
	}
	pc = 0x83230C64; continue 'dispatch;
            }
            0x83230C64 => {
    //   block [0x83230C64..0x83230C80)
	// 83230C64: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 83230C68: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 83230C6C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 83230C70: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 83230C74: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 83230C78: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 83230C7C: 4082FFE8  bne 0x83230c64
	if !ctx.cr[0].eq {
	pc = 0x83230C64; continue 'dispatch;
	}
	pc = 0x83230C80; continue 'dispatch;
            }
            0x83230C80 => {
    //   block [0x83230C80..0x83230D44)
	// 83230C80: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 83230C84: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 83230C88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83230C8C: 4BFFE975  bl 0x8322f600
	ctx.lr = 0x83230C90;
	sub_8322F600(ctx, base);
	// 83230C90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 83230C94: 4AF86E85  bl 0x821b7b18
	ctx.lr = 0x83230C98;
	sub_821B7B18(ctx, base);
	// 83230C98: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 83230C9C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 83230CA0: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 83230CA4: 392B2240  addi r9, r11, 0x2240
	ctx.r[9].s64 = ctx.r[11].s64 + 8768;
	// 83230CA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 83230CAC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 83230CB0: 39000200  li r8, 0x200
	ctx.r[8].s64 = 512;
	// 83230CB4: 80DE0000  lwz r6, 0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 83230CB8: 38EA9490  addi r7, r10, -0x6b70
	ctx.r[7].s64 = ctx.r[10].s64 + -27504;
	// 83230CBC: 90DF01C0  stw r6, 0x1c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), ctx.r[6].u32 ) };
	// 83230CC0: C1AA9490  lfs f13, -0x6b70(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 83230CC4: 917F01C8  stw r11, 0x1c8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(456 as u32), ctx.r[11].u32 ) };
	// 83230CC8: C007FFF4  lfs f0, -0xc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 83230CCC: 917F01CC  stw r11, 0x1cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(460 as u32), ctx.r[11].u32 ) };
	// 83230CD0: 917F01D0  stw r11, 0x1d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(464 as u32), ctx.r[11].u32 ) };
	// 83230CD4: 917F01D8  stw r11, 0x1d8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(472 as u32), ctx.r[11].u32 ) };
	// 83230CD8: 917F01DC  stw r11, 0x1dc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(476 as u32), ctx.r[11].u32 ) };
	// 83230CDC: 917F01E0  stw r11, 0x1e0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(480 as u32), ctx.r[11].u32 ) };
	// 83230CE0: 917F01E8  stw r11, 0x1e8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(488 as u32), ctx.r[11].u32 ) };
	// 83230CE4: 917F01EC  stw r11, 0x1ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(492 as u32), ctx.r[11].u32 ) };
	// 83230CE8: 917F01F0  stw r11, 0x1f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(496 as u32), ctx.r[11].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83230D48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83230D48 size=8
    let mut pc: u32 = 0x83230D48;
    'dispatch: loop {
        match pc {
            0x83230D48 => {
    //   block [0x83230D48..0x83230D50)
	// 83230D48: 38630150  addi r3, r3, 0x150
	ctx.r[3].s64 = ctx.r[3].s64 + 336;
	// 83230D4C: 4BFF7A7C  b 0x832287c8
	sub_832287C8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83230D50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x83230D50 size=428
    let mut pc: u32 = 0x83230D50;
    'dispatch: loop {
        match pc {
            0x83230D50 => {
    //   block [0x83230D50..0x83230DAC)
	// 83230D50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83230D54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83230D58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 83230D5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 83230D60: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 83230D64: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83230D68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83230D6C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 83230D70: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 83230D74: C01F0214  lfs f0, 0x214(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(532 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 83230D78: C3EB9484  lfs f31, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 83230D7C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 83230D80: 4099002C  ble cr6, 0x83230dac
	if !ctx.cr[6].gt {
	pc = 0x83230DAC; continue 'dispatch;
	}
	// 83230D84: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 83230D88: 3D208336  lis r9, -0x7cca
	ctx.r[9].s64 = -2093613056;
	// 83230D8C: 3969F1BC  addi r11, r9, -0xe44
	ctx.r[11].s64 = ctx.r[9].s64 + -3652;
	// 83230D90: 814A6DD4  lwz r10, 0x6dd4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28116 as u32) ) } as u64;
	// 83230D94: 390B0008  addi r8, r11, 8
	ctx.r[8].s64 = ctx.r[11].s64 + 8;
	// 83230D98: 5547103A  slwi r7, r10, 2
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 83230D9C: C1AB0028  lfs f13, 0x28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 83230DA0: 7D87442E  lfsx f12, r7, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 83230DA4: ED6C037C  fnmsubs f11, f12, f13, f0
	ctx.f[11].f64 = -(((ctx.f[12].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 83230DA8: D17F0214  stfs f11, 0x214(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(532 as u32), tmp.u32 ) };
	pc = 0x83230DAC; continue 'dispatch;
            }
            0x83230DAC => {
    //   block [0x83230DAC..0x83230DE8)
	// 83230DAC: 817F0170  lwz r11, 0x170(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 83230DB0: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 83230DB4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 83230DB8: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 83230DBC: 41990088  bgt cr6, 0x83230e44
	if ctx.cr[6].gt {
	pc = 0x83230E44; continue 'dispatch;
	}
	// 83230DC0: 3D808323  lis r12, -0x7cdd
	ctx.r[12].s64 = -2094858240;
	// 83230DC4: 398C0DD8  addi r12, r12, 0xdd8
	ctx.r[12].s64 = ctx.r[12].s64 + 3544;
	// 83230DC8: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 83230DCC: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 83230DD0: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 83230DD4: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x83230DE8; continue 'dispatch;
		},
		1 => {
	pc = 0x83230E00; continue 'dispatch;
		},
		2 => {
	pc = 0x83230E18; continue 'dispatch;
		},
		3 => {
	pc = 0x83230E30; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 83230DD8: 83230DE8  lwz r25, 0xde8(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(3560 as u32) ) } as u64;
	// 83230DDC: 83230E00  lwz r25, 0xe00(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(3584 as u32) ) } as u64;
	// 83230DE0: 83230E18  lwz r25, 0xe18(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(3608 as u32) ) } as u64;
	// 83230DE4: 83230E30  lwz r25, 0xe30(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(3632 as u32) ) } as u64;
            }
            0x83230DE8 => {
    //   block [0x83230DE8..0x83230E00)
	// 83230DE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83230DEC: 4B7D4CD5  bl 0x82a05ac0
	ctx.lr = 0x83230DF0;
	sub_82A05AC0(ctx, base);
	// 83230DF0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 83230DF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83230DF8: 4B7D4EC1  bl 0x82a05cb8
	ctx.lr = 0x83230DFC;
	sub_82A05CB8(ctx, base);
	// 83230DFC: 48000048  b 0x83230e44
	pc = 0x83230E44; continue 'dispatch;
            }
            0x83230E00 => {
    //   block [0x83230E00..0x83230E18)
	// 83230E00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83230E04: 4B7D5235  bl 0x82a06038
	ctx.lr = 0x83230E08;
	sub_82A06038(ctx, base);
	// 83230E08: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 83230E0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83230E10: 4B7D5429  bl 0x82a06238
	ctx.lr = 0x83230E14;
	sub_82A06238(ctx, base);
	// 83230E14: 48000030  b 0x83230e44
	pc = 0x83230E44; continue 'dispatch;
            }
            0x83230E18 => {
    //   block [0x83230E18..0x83230E30)
	// 83230E18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83230E1C: 4B7D57BD  bl 0x82a065d8
	ctx.lr = 0x83230E20;
	sub_82A065D8(ctx, base);
	// 83230E20: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 83230E24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83230E28: 4B7D59B1  bl 0x82a067d8
	ctx.lr = 0x83230E2C;
	sub_82A067D8(ctx, base);
	// 83230E2C: 48000018  b 0x83230e44
	pc = 0x83230E44; continue 'dispatch;
            }
            0x83230E30 => {
    //   block [0x83230E30..0x83230E44)
	// 83230E30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83230E34: 4B7D5D45  bl 0x82a06b78
	ctx.lr = 0x83230E38;
	sub_82A06B78(ctx, base);
	// 83230E38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 83230E3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83230E40: 4B7D5F39  bl 0x82a06d78
	ctx.lr = 0x83230E44;
	sub_82A06D78(ctx, base);
	pc = 0x83230E44; continue 'dispatch;
            }
            0x83230E44 => {
    //   block [0x83230E44..0x83230E7C)
	// 83230E44: C01F0214  lfs f0, 0x214(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(532 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 83230E48: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 83230E4C: 41990094  bgt cr6, 0x83230ee0
	if ctx.cr[6].gt {
	pc = 0x83230EE0; continue 'dispatch;
	}
	// 83230E50: 817F01C0  lwz r11, 0x1c0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) } as u64;
	// 83230E54: 894B00F5  lbz r10, 0xf5(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(245 as u32) ) } as u64;
	// 83230E58: C00B00F0  lfs f0, 0xf0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 83230E5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83230E60: 419A007C  beq cr6, 0x83230edc
	if ctx.cr[6].eq {
	pc = 0x83230EDC; continue 'dispatch;
	}
	// 83230E64: 3CE08332  lis r7, -0x7cce
	ctx.r[7].s64 = -2093875200;
	// 83230E68: 8147859C  lwz r10, -0x7a64(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-31332 as u32) ) } as u64;
	// 83230E6C: 2F0A010B  cmpwi cr6, r10, 0x10b
	ctx.cr[6].compare_i32(ctx.r[10].s32, 267, &mut ctx.xer);
	// 83230E70: 390AFEF5  addi r8, r10, -0x10b
	ctx.r[8].s64 = ctx.r[10].s64 + -267;
	// 83230E74: 40980008  bge cr6, 0x83230e7c
	if !ctx.cr[6].lt {
	pc = 0x83230E7C; continue 'dispatch;
	}
	// 83230E78: 390A0067  addi r8, r10, 0x67
	ctx.r[8].s64 = ctx.r[10].s64 + 103;
	pc = 0x83230E7C; continue 'dispatch;
            }
            0x83230E7C => {
    //   block [0x83230E7C..0x83230EB4)
	// 83230E7C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 83230E80: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 83230E84: 396BF1F8  addi r11, r11, -0xe08
	ctx.r[11].s64 = ctx.r[11].s64 + -3592;
	// 83230E88: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 83230E8C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 83230E90: 2F0A0172  cmpwi cr6, r10, 0x172
	ctx.cr[6].compare_i32(ctx.r[10].s32, 370, &mut ctx.xer);
	// 83230E94: 7CC9582E  lwzx r6, r9, r11
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 83230E98: 7CA8582E  lwzx r5, r8, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 83230E9C: 7CA83278  xor r8, r5, r6
	ctx.r[8].u64 = ctx.r[5].u64 ^ ctx.r[6].u64;
	// 83230EA0: 7D09592E  stwx r8, r9, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[8].u32) };
	// 83230EA4: 41980010  blt cr6, 0x83230eb4
	if ctx.cr[6].lt {
	pc = 0x83230EB4; continue 'dispatch;
	}
	// 83230EA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 83230EAC: 9167859C  stw r11, -0x7a64(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(-31332 as u32), ctx.r[11].u32 ) };
	// 83230EB0: 48000008  b 0x83230eb8
	pc = 0x83230EB8; continue 'dispatch;
            }
            0x83230EB4 => {
    //   block [0x83230EB4..0x83230EB8)
	// 83230EB4: 9147859C  stw r10, -0x7a64(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(-31332 as u32), ctx.r[10].u32 ) };
	pc = 0x83230EB8; continue 'dispatch;
            }
            0x83230EB8 => {
    //   block [0x83230EB8..0x83230EDC)
	// 83230EB8: 550B023E  clrlwi r11, r8, 8
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 83230EBC: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 83230EC0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 83230EC4: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 83230EC8: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 83230ECC: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 83230ED0: C1AA5F50  lfs f13, 0x5f50(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24400 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 83230ED4: ED4B0032  fmuls f10, f11, f0
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 83230ED8: EC0A0372  fmuls f0, f10, f13
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	pc = 0x83230EDC; continue 'dispatch;
            }
            0x83230EDC => {
    //   block [0x83230EDC..0x83230EE0)
	// 83230EDC: D01F0214  stfs f0, 0x214(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(532 as u32), tmp.u32 ) };
	pc = 0x83230EE0; continue 'dispatch;
            }
            0x83230EE0 => {
    //   block [0x83230EE0..0x83230EFC)
	// 83230EE0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 83230EE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 83230EE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83230EEC: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 83230EF0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 83230EF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 83230EF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83230F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83230F00 size=224
    let mut pc: u32 = 0x83230F00;
    'dispatch: loop {
        match pc {
            0x83230F00 => {
    //   block [0x83230F00..0x83230F3C)
	// 83230F00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83230F04: 4BA78509  bl 0x82ca940c
	ctx.lr = 0x83230F08;
	sub_82CA93D0(ctx, base);
	// 83230F08: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83230F0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83230F10: 38600220  li r3, 0x220
	ctx.r[3].s64 = 544;
	// 83230F14: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 83230F18: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 83230F1C: 4AFEE33D  bl 0x8221f258
	ctx.lr = 0x83230F20;
	sub_8221F258(ctx, base);
	// 83230F20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 83230F24: 419A0018  beq cr6, 0x83230f3c
	if ctx.cr[6].eq {
	pc = 0x83230F3C; continue 'dispatch;
	}
	// 83230F28: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 83230F2C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 83230F30: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 83230F34: 4BFFFCFD  bl 0x83230c30
	ctx.lr = 0x83230F38;
	sub_83230C30(ctx, base);
	// 83230F38: 48000008  b 0x83230f40
	pc = 0x83230F40; continue 'dispatch;
            }
            0x83230F3C => {
    //   block [0x83230F3C..0x83230F40)
	// 83230F3C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x83230F40; continue 'dispatch;
            }
            0x83230F40 => {
    //   block [0x83230F40..0x83230F80)
	// 83230F40: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 83230F44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 83230F48: 419A0038  beq cr6, 0x83230f80
	if ctx.cr[6].eq {
	pc = 0x83230F80; continue 'dispatch;
	}
	// 83230F4C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 83230F50: 4AFEE309  bl 0x8221f258
	ctx.lr = 0x83230F54;
	sub_8221F258(ctx, base);
	// 83230F54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 83230F58: 419A0028  beq cr6, 0x83230f80
	if ctx.cr[6].eq {
	pc = 0x83230F80; continue 'dispatch;
	}
	// 83230F5C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83230F60: 3D208253  lis r9, -0x7dad
	ctx.r[9].s64 = -2108489728;
	// 83230F64: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 83230F68: 38E99238  addi r7, r9, -0x6dc8
	ctx.r[7].s64 = ctx.r[9].s64 + -28104;
	// 83230F6C: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 83230F70: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 83230F74: 90E30004  stw r7, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 83230F78: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 83230F7C: 48000008  b 0x83230f84
	pc = 0x83230F84; continue 'dispatch;
            }
            0x83230F80 => {
    //   block [0x83230F80..0x83230F84)
	// 83230F80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x83230F84; continue 'dispatch;
            }
            0x83230F84 => {
    //   block [0x83230F84..0x83230FA0)
	// 83230F84: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83230F88: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 83230F8C: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 83230F90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83230F94: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 83230F98: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 83230F9C: 419A0020  beq cr6, 0x83230fbc
	if ctx.cr[6].eq {
	pc = 0x83230FBC; continue 'dispatch;
	}
	pc = 0x83230FA0; continue 'dispatch;
            }
            0x83230FA0 => {
    //   block [0x83230FA0..0x83230FBC)
	// 83230FA0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 83230FA4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 83230FA8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 83230FAC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 83230FB0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 83230FB4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 83230FB8: 4082FFE8  bne 0x83230fa0
	if !ctx.cr[0].eq {
	pc = 0x83230FA0; continue 'dispatch;
	}
	pc = 0x83230FBC; continue 'dispatch;
            }
            0x83230FBC => {
    //   block [0x83230FBC..0x83230FE0)
	// 83230FBC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 83230FC0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 83230FC4: 386BE48C  addi r3, r11, -0x1b74
	ctx.r[3].s64 = ctx.r[11].s64 + -7028;
	// 83230FC8: 4B21FDF1  bl 0x82450db8
	ctx.lr = 0x83230FCC;
	sub_82450DB8(ctx, base);
	// 83230FCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 83230FD0: 4AF86B49  bl 0x821b7b18
	ctx.lr = 0x83230FD4;
	sub_821B7B18(ctx, base);
	// 83230FD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83230FD8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 83230FDC: 4BA78480  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83230FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83230FE0 size=744
    let mut pc: u32 = 0x83230FE0;
    'dispatch: loop {
        match pc {
            0x83230FE0 => {
    //   block [0x83230FE0..0x832312C8)
	// 83230FE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83230FE4: 4BA78429  bl 0x82ca940c
	ctx.lr = 0x83230FE8;
	sub_82CA93D0(ctx, base);
	// 83230FE8: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832312C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832312C8 size=464
    let mut pc: u32 = 0x832312C8;
    'dispatch: loop {
        match pc {
            0x832312C8 => {
    //   block [0x832312C8..0x83231498)
	// 832312C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832312CC: 4BA78141  bl 0x82ca940c
	ctx.lr = 0x832312D0;
	sub_82CA93D0(ctx, base);
	// 832312D0: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83231498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83231498 size=200
    let mut pc: u32 = 0x83231498;
    'dispatch: loop {
        match pc {
            0x83231498 => {
    //   block [0x83231498..0x83231560)
	// 83231498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323149C: 4BA77F6D  bl 0x82ca9408
	ctx.lr = 0x832314A0;
	sub_82CA93D0(ctx, base);
	// 832314A0: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83231560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83231560 size=156
    let mut pc: u32 = 0x83231560;
    'dispatch: loop {
        match pc {
            0x83231560 => {
    //   block [0x83231560..0x832315C8)
	// 83231560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83231564: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83231568: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8323156C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 83231570: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83231574: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83231578: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8323157C: 817F01CC  lwz r11, 0x1cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 83231580: 815F01C8  lwz r10, 0x1c8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(456 as u32) ) } as u64;
	// 83231584: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 83231588: 55280036  rlwinm r8, r9, 0, 0, 0x1b
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 8323158C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 83231590: 419A0038  beq cr6, 0x832315c8
	if ctx.cr[6].eq {
	pc = 0x832315C8; continue 'dispatch;
	}
	// 83231594: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 83231598: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323159C: 813F01EC  lwz r9, 0x1ec(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(492 as u32) ) } as u64;
	// 832315A0: 811F01E8  lwz r8, 0x1e8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(488 as u32) ) } as u64;
	// 832315A4: 7CEA5850  subf r7, r10, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 832315A8: 7CC84850  subf r6, r8, r9
	ctx.r[6].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 832315AC: 7CEB2670  srawi r11, r7, 4
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> 4) as i64;
	// 832315B0: 7CC52670  srawi r5, r6, 4
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[6].s32 >> 4) as i64;
	// 832315B4: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 832315B8: 419A0020  beq cr6, 0x832315d8
	if ctx.cr[6].eq {
	pc = 0x832315D8; continue 'dispatch;
	}
	// 832315BC: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 832315C0: 419A0018  beq cr6, 0x832315d8
	if ctx.cr[6].eq {
	pc = 0x832315D8; continue 'dispatch;
	}
	// 832315C4: 4BFFED6D  bl 0x83230330
	ctx.lr = 0x832315C8;
	sub_83230330(ctx, base);
	pc = 0x832315C8; continue 'dispatch;
            }
            0x832315C8 => {
    //   block [0x832315C8..0x832315D8)
	// 832315C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 832315CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832315D0: 4BFFFEC9  bl 0x83231498
	ctx.lr = 0x832315D4;
	sub_83231498(ctx, base);
	// 832315D4: 48000010  b 0x832315e4
	pc = 0x832315E4; continue 'dispatch;
            }
            0x832315D8 => {
    //   block [0x832315D8..0x832315E4)
	// 832315D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 832315DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832315E0: 4BFFFA01  bl 0x83230fe0
	ctx.lr = 0x832315E4;
	sub_83230FE0(ctx, base);
	pc = 0x832315E4; continue 'dispatch;
            }
            0x832315E4 => {
    //   block [0x832315E4..0x832315FC)
	// 832315E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832315E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832315EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832315F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832315F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832315F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83231600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83231600 size=124
    let mut pc: u32 = 0x83231600;
    'dispatch: loop {
        match pc {
            0x83231600 => {
    //   block [0x83231600..0x8323167C)
	// 83231600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83231604: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83231608: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8323160C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83231610: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 83231614: 39800090  li r12, 0x90
	ctx.r[12].s64 = 144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83231680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83231680 size=124
    let mut pc: u32 = 0x83231680;
    'dispatch: loop {
        match pc {
            0x83231680 => {
    //   block [0x83231680..0x832316FC)
	// 83231680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83231684: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83231688: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8323168C: 3980FFE0  li r12, -0x20
	ctx.r[12].s64 = -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83231700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83231700 size=56
    let mut pc: u32 = 0x83231700;
    'dispatch: loop {
        match pc {
            0x83231700 => {
    //   block [0x83231700..0x83231738)
	// 83231700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83231704: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83231708: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8323170C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83231710: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83231714: 4BFFE32D  bl 0x8322fa40
	ctx.lr = 0x83231718;
	sub_8322FA40(ctx, base);
	// 83231718: 809F00D0  lwz r4, 0xd0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 8323171C: 807F01C0  lwz r3, 0x1c0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) } as u64;
	// 83231720: 48012211  bl 0x83243930
	ctx.lr = 0x83231724;
	sub_83243930(ctx, base);
	// 83231724: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 83231728: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8323172C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83231730: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 83231734: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83231738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83231738 size=168
    let mut pc: u32 = 0x83231738;
    'dispatch: loop {
        match pc {
            0x83231738 => {
    //   block [0x83231738..0x83231778)
	// 83231738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323173C: 4BA77CC5  bl 0x82ca9400
	ctx.lr = 0x83231740;
	sub_82CA93D0(ctx, base);
	// 83231740: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83231744: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 83231748: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8323174C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 83231750: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 83231754: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 83231758: 816BE54C  lwz r11, -0x1ab4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6836 as u32) ) } as u64;
	// 8323175C: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 83231760: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 83231764: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83231768: 409A0010  bne cr6, 0x83231778
	if !ctx.cr[6].eq {
	pc = 0x83231778; continue 'dispatch;
	}
	// 8323176C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 83231770: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 83231774: 48000008  b 0x8323177c
	pc = 0x8323177C; continue 'dispatch;
            }
            0x83231778 => {
    //   block [0x83231778..0x8323177C)
	// 83231778: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8323177C; continue 'dispatch;
            }
            0x8323177C => {
    //   block [0x8323177C..0x832317D8)
	// 8323177C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83231780: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83231784: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 83231788: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323178C: 4E800421  bctrl
	ctx.lr = 0x83231790;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83231790: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 83231794: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83231798: 419A0040  beq cr6, 0x832317d8
	if ctx.cr[6].eq {
	pc = 0x832317D8; continue 'dispatch;
	}
	// 8323179C: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 832317A0: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 832317A4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 832317A8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 832317AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 832317B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832317B4: 4BFFE455  bl 0x8322fc08
	ctx.lr = 0x832317B8;
	sub_8322FC08(ctx, base);
	// 832317B8: 809E00D0  lwz r4, 0xd0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(208 as u32) ) } as u64;
	// 832317BC: 807E01C0  lwz r3, 0x1c0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(448 as u32) ) } as u64;
	// 832317C0: 48012171  bl 0x83243930
	ctx.lr = 0x832317C4;
	sub_83243930(ctx, base);
	// 832317C4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832317C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832317CC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 832317D0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832317D4: 4E800421  bctrl
	ctx.lr = 0x832317D8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x832317D8 => {
    //   block [0x832317D8..0x832317E0)
	// 832317D8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 832317DC: 4BA77C74  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832317F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832317F8 size=104
    let mut pc: u32 = 0x832317F8;
    'dispatch: loop {
        match pc {
            0x832317F8 => {
    //   block [0x832317F8..0x83231860)
	// 832317F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832317FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83231800: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 83231804: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 83231808: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323180C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83231810: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 83231814: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83231860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83231860 size=104
    let mut pc: u32 = 0x83231860;
    'dispatch: loop {
        match pc {
            0x83231860 => {
    //   block [0x83231860..0x832318C8)
	// 83231860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83231864: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83231868: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8323186C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 83231870: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83231874: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83231878: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 8323187C: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832318C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832318C8 size=128
    let mut pc: u32 = 0x832318C8;
    'dispatch: loop {
        match pc {
            0x832318C8 => {
    //   block [0x832318C8..0x83231948)
	// 832318C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832318CC: 4BA77B39  bl 0x82ca9404
	ctx.lr = 0x832318D0;
	sub_82CA93D0(ctx, base);
	// 832318D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832318D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832318D8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 832318DC: 3BDF0030  addi r30, r31, 0x30
	ctx.r[30].s64 = ctx.r[31].s64 + 48;
	// 832318E0: 3BBF0040  addi r29, r31, 0x40
	ctx.r[29].s64 = ctx.r[31].s64 + 64;
	// 832318E4: 394B0320  addi r10, r11, 0x320
	ctx.r[10].s64 = ctx.r[11].s64 + 800;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83231948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83231948 size=136
    let mut pc: u32 = 0x83231948;
    'dispatch: loop {
        match pc {
            0x83231948 => {
    //   block [0x83231948..0x832319D0)
	// 83231948: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323194C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83231950: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 83231954: 3980FFE0  li r12, -0x20
	ctx.r[12].s64 = -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832319D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832319D0 size=144
    let mut pc: u32 = 0x832319D0;
    'dispatch: loop {
        match pc {
            0x832319D0 => {
    //   block [0x832319D0..0x83231A60)
	// 832319D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832319D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832319D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832319DC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 832319E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832319E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832319E8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 832319EC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 832319F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83231A60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83231A60 size=284
    let mut pc: u32 = 0x83231A60;
    'dispatch: loop {
        match pc {
            0x83231A60 => {
    //   block [0x83231A60..0x83231B7C)
	// 83231A60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83231A64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83231A68: DBE1FFF0  stfd f31, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 83231A6C: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83231BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x83231BA8 size=148
    let mut pc: u32 = 0x83231BA8;
    'dispatch: loop {
        match pc {
            0x83231BA8 => {
    //   block [0x83231BA8..0x83231BD4)
	// 83231BA8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 83231BAC: C1A30030  lfs f13, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 83231BB0: C00BD5C8  lfs f0, -0x2a38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10808 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 83231BB4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 83231BB8: 409A007C  bne cr6, 0x83231c34
	if !ctx.cr[6].eq {
	pc = 0x83231C34; continue 'dispatch;
	}
	// 83231BBC: 3CE08332  lis r7, -0x7cce
	ctx.r[7].s64 = -2093875200;
	// 83231BC0: 8147859C  lwz r10, -0x7a64(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-31332 as u32) ) } as u64;
	// 83231BC4: 2F0A010B  cmpwi cr6, r10, 0x10b
	ctx.cr[6].compare_i32(ctx.r[10].s32, 267, &mut ctx.xer);
	// 83231BC8: 390AFEF5  addi r8, r10, -0x10b
	ctx.r[8].s64 = ctx.r[10].s64 + -267;
	// 83231BCC: 40980008  bge cr6, 0x83231bd4
	if !ctx.cr[6].lt {
	pc = 0x83231BD4; continue 'dispatch;
	}
	// 83231BD0: 390A0067  addi r8, r10, 0x67
	ctx.r[8].s64 = ctx.r[10].s64 + 103;
	pc = 0x83231BD4; continue 'dispatch;
            }
            0x83231BD4 => {
    //   block [0x83231BD4..0x83231C0C)
	// 83231BD4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 83231BD8: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 83231BDC: 396BF1F8  addi r11, r11, -0xe08
	ctx.r[11].s64 = ctx.r[11].s64 + -3592;
	// 83231BE0: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 83231BE4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 83231BE8: 2F0A0172  cmpwi cr6, r10, 0x172
	ctx.cr[6].compare_i32(ctx.r[10].s32, 370, &mut ctx.xer);
	// 83231BEC: 7CC9582E  lwzx r6, r9, r11
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 83231BF0: 7CA8582E  lwzx r5, r8, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 83231BF4: 7CA83278  xor r8, r5, r6
	ctx.r[8].u64 = ctx.r[5].u64 ^ ctx.r[6].u64;
	// 83231BF8: 7D09592E  stwx r8, r9, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[8].u32) };
	// 83231BFC: 41980010  blt cr6, 0x83231c0c
	if ctx.cr[6].lt {
	pc = 0x83231C0C; continue 'dispatch;
	}
	// 83231C00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 83231C04: 9167859C  stw r11, -0x7a64(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(-31332 as u32), ctx.r[11].u32 ) };
	// 83231C08: 48000008  b 0x83231c10
	pc = 0x83231C10; continue 'dispatch;
            }
            0x83231C0C => {
    //   block [0x83231C0C..0x83231C10)
	// 83231C0C: 9147859C  stw r10, -0x7a64(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(-31332 as u32), ctx.r[10].u32 ) };
	pc = 0x83231C10; continue 'dispatch;
            }
            0x83231C10 => {
    //   block [0x83231C10..0x83231C34)
	// 83231C10: 550B023E  clrlwi r11, r8, 8
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 83231C14: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 83231C18: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 83231C1C: C801FFF0  lfd f0, -0x10(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 83231C20: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 83231C24: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 83231C28: C00A5F50  lfs f0, 0x5f50(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24400 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 83231C2C: ED6C0032  fmuls f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 83231C30: D1630030  stfs f11, 0x30(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	pc = 0x83231C34; continue 'dispatch;
            }
            0x83231C34 => {
    //   block [0x83231C34..0x83231C3C)
	// 83231C34: C0230030  lfs f1, 0x30(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 83231C38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83231C40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83231C40 size=88
    let mut pc: u32 = 0x83231C40;
    'dispatch: loop {
        match pc {
            0x83231C40 => {
    //   block [0x83231C40..0x83231C70)
	// 83231C40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83231C44: 4BA777C1  bl 0x82ca9404
	ctx.lr = 0x83231C48;
	sub_82CA93D0(ctx, base);
	// 83231C48: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83231C4C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 83231C50: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 83231C54: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 83231C58: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 83231C5C: 815D000C  lwz r10, 0xc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 83231C60: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 83231C64: 7D3F1E71  srawi. r31, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 83231C68: 40810028  ble 0x83231c90
	if !ctx.cr[0].gt {
	pc = 0x83231C90; continue 'dispatch;
	}
	// 83231C6C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x83231C70; continue 'dispatch;
            }
            0x83231C70 => {
    //   block [0x83231C70..0x83231C90)
	// 83231C70: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 83231C74: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 83231C78: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 83231C7C: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 83231C80: 4BFF70F9  bl 0x83228d78
	ctx.lr = 0x83231C84;
	sub_83228D78(ctx, base);
	// 83231C84: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 83231C88: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 83231C8C: 4082FFE4  bne 0x83231c70
	if !ctx.cr[0].eq {
	pc = 0x83231C70; continue 'dispatch;
	}
	pc = 0x83231C90; continue 'dispatch;
            }
            0x83231C90 => {
    //   block [0x83231C90..0x83231C98)
	// 83231C90: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 83231C94: 4BA777C0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83231C98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x83231C98 size=100
    let mut pc: u32 = 0x83231C98;
    'dispatch: loop {
        match pc {
            0x83231C98 => {
    //   block [0x83231C98..0x83231CFC)
	// 83231C98: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 83231C9C: 81440010  lwz r10, 0x10(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 83231CA0: 3921FFF0  addi r9, r1, -0x10
	ctx.r[9].s64 = ctx.r[1].s64 + -16;
	// 83231CA4: 8104000C  lwz r8, 0xc(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 83231CA8: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 83231CAC: 7CC85050  subf r6, r8, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 83231CB0: 38A79160  addi r5, r7, -0x6ea0
	ctx.r[5].s64 = ctx.r[7].s64 + -28320;
	// 83231CB4: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 83231CB8: 54CB0038  rlwinm r11, r6, 0, 0, 0x1c
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 83231CBC: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83231D00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83231D00 size=200
    let mut pc: u32 = 0x83231D00;
    'dispatch: loop {
        match pc {
            0x83231D00 => {
    //   block [0x83231D00..0x83231D24)
	// 83231D00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83231D04: 4BA77701  bl 0x82ca9404
	ctx.lr = 0x83231D08;
	sub_82CA93D0(ctx, base);
	// 83231D08: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83231D0C: 83A3000C  lwz r29, 0xc(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 83231D10: 83630010  lwz r27, 0x10(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 83231D14: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 83231D18: 419A00A8  beq cr6, 0x83231dc0
	if ctx.cr[6].eq {
	pc = 0x83231DC0; continue 'dispatch;
	}
	// 83231D1C: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 83231D20: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x83231D24; continue 'dispatch;
            }
            0x83231D24 => {
    //   block [0x83231D24..0x83231D30)
	// 83231D24: 83FD0000  lwz r31, 0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 83231D28: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 83231D2C: 419A0088  beq cr6, 0x83231db4
	if ctx.cr[6].eq {
	pc = 0x83231DB4; continue 'dispatch;
	}
	pc = 0x83231D30; continue 'dispatch;
            }
            0x83231D30 => {
    //   block [0x83231D30..0x83231D50)
	// 83231D30: 807F00D0  lwz r3, 0xd0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 83231D34: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83231D38: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 83231D3C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83231D40: 4E800421  bctrl
	ctx.lr = 0x83231D44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83231D44: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 83231D48: 409A0008  bne cr6, 0x83231d50
	if !ctx.cr[6].eq {
	pc = 0x83231D50; continue 'dispatch;
	}
	// 83231D4C: 9B9F01DD  stb r28, 0x1dd(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(477 as u32), ctx.r[28].u8 ) };
            }
            0x83231D50 => {
    //   block [0x83231D50..0x83231D74)
	// 83231D50: 3BFF00F4  addi r31, r31, 0xf4
	ctx.r[31].s64 = ctx.r[31].s64 + 244;
	// 83231D54: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83231D58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83231D5C: 419A0048  beq cr6, 0x83231da4
	if ctx.cr[6].eq {
	pc = 0x83231DA4; continue 'dispatch;
	}
	// 83231D60: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83231D64: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83231D68: 419A000C  beq cr6, 0x83231d74
	if ctx.cr[6].eq {
	pc = 0x83231D74; continue 'dispatch;
	}
	// 83231D6C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 83231D70: 48000038  b 0x83231da8
	pc = 0x83231DA8; continue 'dispatch;
            }
            0x83231D74 => {
    //   block [0x83231D74..0x83231DA0)
	// 83231D74: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 83231D78: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 83231D7C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 83231D80: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83231D84: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 83231D88: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83231D8C: 409A0014  bne cr6, 0x83231da0
	if !ctx.cr[6].eq {
	pc = 0x83231DA0; continue 'dispatch;
	}
	// 83231D90: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83231D94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83231D98: 409A0008  bne cr6, 0x83231da0
	if !ctx.cr[6].eq {
	pc = 0x83231DA0; continue 'dispatch;
	}
	// 83231D9C: 4AFE9F9D  bl 0x8221bd38
	ctx.lr = 0x83231DA0;
	sub_8221BD38(ctx, base);
	pc = 0x83231DA0; continue 'dispatch;
            }
            0x83231DA0 => {
    //   block [0x83231DA0..0x83231DA4)
	// 83231DA0: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	pc = 0x83231DA4; continue 'dispatch;
            }
            0x83231DA4 => {
    //   block [0x83231DA4..0x83231DA8)
	// 83231DA4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x83231DA8; continue 'dispatch;
            }
            0x83231DA8 => {
    //   block [0x83231DA8..0x83231DB4)
	// 83231DA8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 83231DAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83231DB0: 409AFF80  bne cr6, 0x83231d30
	if !ctx.cr[6].eq {
	pc = 0x83231D30; continue 'dispatch;
	}
	pc = 0x83231DB4; continue 'dispatch;
            }
            0x83231DB4 => {
    //   block [0x83231DB4..0x83231DC0)
	// 83231DB4: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 83231DB8: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 83231DBC: 409AFF68  bne cr6, 0x83231d24
	if !ctx.cr[6].eq {
	pc = 0x83231D24; continue 'dispatch;
	}
	pc = 0x83231DC0; continue 'dispatch;
            }
            0x83231DC0 => {
    //   block [0x83231DC0..0x83231DC8)
	// 83231DC0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 83231DC4: 4BA77690  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83231DC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83231DC8 size=292
    let mut pc: u32 = 0x83231DC8;
    'dispatch: loop {
        match pc {
            0x83231DC8 => {
    //   block [0x83231DC8..0x83231DFC)
	// 83231DC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83231DCC: 4BA77635  bl 0x82ca9400
	ctx.lr = 0x83231DD0;
	sub_82CA93D0(ctx, base);
	// 83231DD0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83231DD4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 83231DD8: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 83231DDC: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 83231DE0: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 83231DE4: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 83231DE8: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 83231DEC: 408100F8  ble 0x83231ee4
	if !ctx.cr[0].gt {
	pc = 0x83231EE4; continue 'dispatch;
	}
	// 83231DF0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 83231DF4: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 83231DF8: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	pc = 0x83231DFC; continue 'dispatch;
            }
            0x83231DFC => {
    //   block [0x83231DFC..0x83231E28)
	// 83231DFC: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 83231E00: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 83231E04: 386B00F4  addi r3, r11, 0xf4
	ctx.r[3].s64 = ctx.r[11].s64 + 244;
	// 83231E08: 816B00F8  lwz r11, 0xf8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) } as u64;
	// 83231E0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83231E10: 419A001C  beq cr6, 0x83231e2c
	if ctx.cr[6].eq {
	pc = 0x83231E2C; continue 'dispatch;
	}
	// 83231E14: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83231E18: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83231E1C: 419A000C  beq cr6, 0x83231e28
	if ctx.cr[6].eq {
	pc = 0x83231E28; continue 'dispatch;
	}
	// 83231E20: 555F003E  slwi r31, r10, 0
	ctx.r[31].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 83231E24: 4800000C  b 0x83231e30
	pc = 0x83231E30; continue 'dispatch;
            }
            0x83231E28 => {
    //   block [0x83231E28..0x83231E2C)
	// 83231E28: 4AF62011  bl 0x82193e38
	ctx.lr = 0x83231E2C;
	sub_82193E38(ctx, base);
	pc = 0x83231E2C; continue 'dispatch;
            }
            0x83231E2C => {
    //   block [0x83231E2C..0x83231E30)
	// 83231E2C: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	pc = 0x83231E30; continue 'dispatch;
            }
            0x83231E30 => {
    //   block [0x83231E30..0x83231E38)
	// 83231E30: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 83231E34: 419A00A4  beq cr6, 0x83231ed8
	if ctx.cr[6].eq {
	pc = 0x83231ED8; continue 'dispatch;
	}
	pc = 0x83231E38; continue 'dispatch;
            }
            0x83231E38 => {
    //   block [0x83231E38..0x83231E74)
	// 83231E38: 807F00D0  lwz r3, 0xd0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 83231E3C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83231E40: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 83231E44: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83231E48: 4E800421  bctrl
	ctx.lr = 0x83231E4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83231E4C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 83231E50: 409A0024  bne cr6, 0x83231e74
	if !ctx.cr[6].eq {
	pc = 0x83231E74; continue 'dispatch;
	}
	// 83231E54: 807F01D8  lwz r3, 0x1d8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(472 as u32) ) } as u64;
	// 83231E58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83231E5C: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 83231E60: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83231E64: 4E800421  bctrl
	ctx.lr = 0x83231E68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83231E68: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 83231E6C: 409A0008  bne cr6, 0x83231e74
	if !ctx.cr[6].eq {
	pc = 0x83231E74; continue 'dispatch;
	}
	// 83231E70: 935F01E4  stw r26, 0x1e4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(484 as u32), ctx.r[26].u32 ) };
            }
            0x83231E74 => {
    //   block [0x83231E74..0x83231E98)
	// 83231E74: 3BFF00F4  addi r31, r31, 0xf4
	ctx.r[31].s64 = ctx.r[31].s64 + 244;
	// 83231E78: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83231E7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83231E80: 419A0048  beq cr6, 0x83231ec8
	if ctx.cr[6].eq {
	pc = 0x83231EC8; continue 'dispatch;
	}
	// 83231E84: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83231E88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83231E8C: 419A000C  beq cr6, 0x83231e98
	if ctx.cr[6].eq {
	pc = 0x83231E98; continue 'dispatch;
	}
	// 83231E90: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 83231E94: 48000038  b 0x83231ecc
	pc = 0x83231ECC; continue 'dispatch;
            }
            0x83231E98 => {
    //   block [0x83231E98..0x83231EC4)
	// 83231E98: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 83231E9C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 83231EA0: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 83231EA4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83231EA8: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 83231EAC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83231EB0: 409A0014  bne cr6, 0x83231ec4
	if !ctx.cr[6].eq {
	pc = 0x83231EC4; continue 'dispatch;
	}
	// 83231EB4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83231EB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83231EBC: 409A0008  bne cr6, 0x83231ec4
	if !ctx.cr[6].eq {
	pc = 0x83231EC4; continue 'dispatch;
	}
	// 83231EC0: 4AFE9E79  bl 0x8221bd38
	ctx.lr = 0x83231EC4;
	sub_8221BD38(ctx, base);
	pc = 0x83231EC4; continue 'dispatch;
            }
            0x83231EC4 => {
    //   block [0x83231EC4..0x83231EC8)
	// 83231EC4: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	pc = 0x83231EC8; continue 'dispatch;
            }
            0x83231EC8 => {
    //   block [0x83231EC8..0x83231ECC)
	// 83231EC8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x83231ECC; continue 'dispatch;
            }
            0x83231ECC => {
    //   block [0x83231ECC..0x83231ED8)
	// 83231ECC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 83231ED0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83231ED4: 409AFF64  bne cr6, 0x83231e38
	if !ctx.cr[6].eq {
	pc = 0x83231E38; continue 'dispatch;
	}
	pc = 0x83231ED8; continue 'dispatch;
            }
            0x83231ED8 => {
    //   block [0x83231ED8..0x83231EE4)
	// 83231ED8: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 83231EDC: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 83231EE0: 4082FF1C  bne 0x83231dfc
	if !ctx.cr[0].eq {
	pc = 0x83231DFC; continue 'dispatch;
	}
	pc = 0x83231EE4; continue 'dispatch;
            }
            0x83231EE4 => {
    //   block [0x83231EE4..0x83231EEC)
	// 83231EE4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 83231EE8: 4BA77568  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83231EF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83231EF0 size=152
    let mut pc: u32 = 0x83231EF0;
    'dispatch: loop {
        match pc {
            0x83231EF0 => {
    //   block [0x83231EF0..0x83231F14)
	// 83231EF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83231EF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83231EF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 83231EFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 83231F00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83231F04: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 83231F08: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 83231F0C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 83231F10: 419A0060  beq cr6, 0x83231f70
	if ctx.cr[6].eq {
	pc = 0x83231F70; continue 'dispatch;
	}
	pc = 0x83231F14; continue 'dispatch;
            }
            0x83231F14 => {
    //   block [0x83231F14..0x83231F38)
	// 83231F14: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 83231F18: 419A0020  beq cr6, 0x83231f38
	if ctx.cr[6].eq {
	pc = 0x83231F38; continue 'dispatch;
	}
	// 83231F1C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83231F20: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 83231F24: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 83231F28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83231F2C: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 83231F30: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83231F34: 4E800421  bctrl
	ctx.lr = 0x83231F38;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x83231F38 => {
    //   block [0x83231F38..0x83231F5C)
	// 83231F38: 817F00F8  lwz r11, 0xf8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 83231F3C: 387F00F4  addi r3, r31, 0xf4
	ctx.r[3].s64 = ctx.r[31].s64 + 244;
	// 83231F40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83231F44: 419A001C  beq cr6, 0x83231f60
	if ctx.cr[6].eq {
	pc = 0x83231F60; continue 'dispatch;
	}
	// 83231F48: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83231F4C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83231F50: 419A000C  beq cr6, 0x83231f5c
	if ctx.cr[6].eq {
	pc = 0x83231F5C; continue 'dispatch;
	}
	// 83231F54: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 83231F58: 4800000C  b 0x83231f64
	pc = 0x83231F64; continue 'dispatch;
            }
            0x83231F5C => {
    //   block [0x83231F5C..0x83231F60)
	// 83231F5C: 4AF61EDD  bl 0x82193e38
	ctx.lr = 0x83231F60;
	sub_82193E38(ctx, base);
	pc = 0x83231F60; continue 'dispatch;
            }
            0x83231F60 => {
    //   block [0x83231F60..0x83231F64)
	// 83231F60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x83231F64; continue 'dispatch;
            }
            0x83231F64 => {
    //   block [0x83231F64..0x83231F70)
	// 83231F64: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 83231F68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83231F6C: 409AFFA8  bne cr6, 0x83231f14
	if !ctx.cr[6].eq {
	pc = 0x83231F14; continue 'dispatch;
	}
	pc = 0x83231F70; continue 'dispatch;
            }
            0x83231F70 => {
    //   block [0x83231F70..0x83231F88)
	// 83231F70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 83231F74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 83231F78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83231F7C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 83231F80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 83231F84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83231F88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83231F88 size=116
    let mut pc: u32 = 0x83231F88;
    'dispatch: loop {
        match pc {
            0x83231F88 => {
    //   block [0x83231F88..0x83231FBC)
	// 83231F88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83231F8C: 4BA7747D  bl 0x82ca9408
	ctx.lr = 0x83231F90;
	sub_82CA93D0(ctx, base);
	// 83231F90: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83231F94: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 83231F98: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 83231F9C: 3BFC0008  addi r31, r28, 8
	ctx.r[31].s64 = ctx.r[28].s64 + 8;
	// 83231FA0: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 83231FA4: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 83231FA8: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 83231FAC: 55280038  rlwinm r8, r9, 0, 0, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 83231FB0: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 83231FB4: 40990040  ble cr6, 0x83231ff4
	if !ctx.cr[6].gt {
	pc = 0x83231FF4; continue 'dispatch;
	}
	// 83231FB8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x83231FBC; continue 'dispatch;
            }
            0x83231FBC => {
    //   block [0x83231FBC..0x83231FF4)
	// 83231FBC: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 83231FC0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 83231FC4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 83231FC8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 83231FCC: 7C8BF02E  lwzx r4, r11, r30
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 83231FD0: 4BFFFF21  bl 0x83231ef0
	ctx.lr = 0x83231FD4;
	sub_83231EF0(ctx, base);
	// 83231FD4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83231FD8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 83231FDC: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83231FE0: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 83231FE4: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 83231FE8: 7D071E70  srawi r7, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 83231FEC: 7F1D3800  cmpw cr6, r29, r7
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[7].s32, &mut ctx.xer);
	// 83231FF0: 4198FFCC  blt cr6, 0x83231fbc
	if ctx.cr[6].lt {
	pc = 0x83231FBC; continue 'dispatch;
	}
	pc = 0x83231FF4; continue 'dispatch;
            }
            0x83231FF4 => {
    //   block [0x83231FF4..0x83231FFC)
	// 83231FF4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 83231FF8: 4BA77460  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83232000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83232000 size=72
    let mut pc: u32 = 0x83232000;
    'dispatch: loop {
        match pc {
            0x83232000 => {
    //   block [0x83232000..0x83232028)
	// 83232000: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83232004: 4BA77409  bl 0x82ca940c
	ctx.lr = 0x83232008;
	sub_82CA93D0(ctx, base);
	// 83232008: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323200C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 83232010: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 83232014: 815D000C  lwz r10, 0xc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 83232018: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8323201C: 7D3F1E71  srawi. r31, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 83232020: 40810020  ble 0x83232040
	if !ctx.cr[0].gt {
	pc = 0x83232040; continue 'dispatch;
	}
	// 83232024: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x83232028; continue 'dispatch;
            }
            0x83232028 => {
    //   block [0x83232028..0x83232040)
	// 83232028: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323202C: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 83232030: 4BFF6E59  bl 0x83228e88
	ctx.lr = 0x83232034;
	sub_83228E88(ctx, base);
	// 83232034: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 83232038: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 8323203C: 4082FFEC  bne 0x83232028
	if !ctx.cr[0].eq {
	pc = 0x83232028; continue 'dispatch;
	}
	pc = 0x83232040; continue 'dispatch;
            }
            0x83232040 => {
    //   block [0x83232040..0x83232048)
	// 83232040: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 83232044: 4BA77418  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83232048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83232048 size=80
    let mut pc: u32 = 0x83232048;
    'dispatch: loop {
        match pc {
            0x83232048 => {
    //   block [0x83232048..0x83232074)
	// 83232048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323204C: 4BA773BD  bl 0x82ca9408
	ctx.lr = 0x83232050;
	sub_82CA93D0(ctx, base);
	// 83232050: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83232054: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 83232058: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 8323205C: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 83232060: 815D000C  lwz r10, 0xc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 83232064: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 83232068: 7D3F1E71  srawi. r31, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8323206C: 40810024  ble 0x83232090
	if !ctx.cr[0].gt {
	pc = 0x83232090; continue 'dispatch;
	}
	// 83232070: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x83232074; continue 'dispatch;
            }
            0x83232074 => {
    //   block [0x83232074..0x83232090)
	// 83232074: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 83232078: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8323207C: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 83232080: 4BFF6E81  bl 0x83228f00
	ctx.lr = 0x83232084;
	sub_83228F00(ctx, base);
	// 83232084: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 83232088: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 8323208C: 4082FFE8  bne 0x83232074
	if !ctx.cr[0].eq {
	pc = 0x83232074; continue 'dispatch;
	}
	pc = 0x83232090; continue 'dispatch;
            }
            0x83232090 => {
    //   block [0x83232090..0x83232098)
	// 83232090: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 83232094: 4BA773C4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83232098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x83232098 size=104
    let mut pc: u32 = 0x83232098;
    'dispatch: loop {
        match pc {
            0x83232098 => {
    //   block [0x83232098..0x83232100)
	// 83232098: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323209C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832320A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832320A4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832320A8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 832320AC: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 832320B0: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 832320B4: 390AF1BC  addi r8, r10, -0xe44
	ctx.r[8].s64 = ctx.r[10].s64 + -3652;
	// 832320B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832320BC: 816B6DD4  lwz r11, 0x6dd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28116 as u32) ) } as u64;
	// 832320C0: 5567103A  slwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 832320C4: C00992D4  lfs f0, -0x6d2c(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27948 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 832320C8: 7DA7442E  lfsx f13, r7, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 832320CC: EC2D007A  fmadds f1, f13, f1, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64);
	// 832320D0: 4AFFA2C1  bl 0x8222c390
	ctx.lr = 0x832320D4;
	sub_8222C390(ctx, base);
	// 832320D4: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 832320D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832320DC: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 832320E0: D9610050  stfd f11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[11].u64 ) };
	// 832320E4: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 832320E8: 4BFFFF61  bl 0x83232048
	ctx.lr = 0x832320EC;
	sub_83232048(ctx, base);
	// 832320EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832320F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832320F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832320F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832320FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83232108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x83232108 size=392
    let mut pc: u32 = 0x83232108;
    'dispatch: loop {
        match pc {
            0x83232108 => {
    //   block [0x83232108..0x83232158)
	// 83232108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323210C: 4BA772F9  bl 0x82ca9404
	ctx.lr = 0x83232110;
	sub_82CA93D0(ctx, base);
	// 83232110: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 83232114: 4BA7BBC5  bl 0x82cadcd8
	ctx.lr = 0x83232118;
	sub_82CADCA0(ctx, base);
	// 83232118: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323211C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 83232120: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 83232124: 394B9490  addi r10, r11, -0x6b70
	ctx.r[10].s64 = ctx.r[11].s64 + -27504;
	// 83232128: 813C0010  lwz r9, 0x10(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323212C: 811C000C  lwz r8, 0xc(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 83232130: 7CE84850  subf r7, r8, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 83232134: C38AFFF4  lfs f28, -0xc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 83232138: FFE0E090  fmr f31, f28
	ctx.f[31].f64 = ctx.f[28].f64;
	// 8323213C: 7CEB1E71  srawi. r11, r7, 3
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 83232140: FFC0E090  fmr f30, f28
	ctx.f[30].f64 = ctx.f[28].f64;
	// 83232144: 40810138  ble 0x8323227c
	if !ctx.cr[0].gt {
	pc = 0x8323227C; continue 'dispatch;
	}
	// 83232148: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8323214C: C3AA0000  lfs f29, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 83232150: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 83232154: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	pc = 0x83232158; continue 'dispatch;
            }
            0x83232158 => {
    //   block [0x83232158..0x83232184)
	// 83232158: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323215C: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 83232160: 386B00F4  addi r3, r11, 0xf4
	ctx.r[3].s64 = ctx.r[11].s64 + 244;
	// 83232164: 816B00F8  lwz r11, 0xf8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) } as u64;
	// 83232168: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323216C: 419A001C  beq cr6, 0x83232188
	if ctx.cr[6].eq {
	pc = 0x83232188; continue 'dispatch;
	}
	// 83232170: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83232174: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83232178: 419A000C  beq cr6, 0x83232184
	if ctx.cr[6].eq {
	pc = 0x83232184; continue 'dispatch;
	}
	// 8323217C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 83232180: 4800000C  b 0x8323218c
	pc = 0x8323218C; continue 'dispatch;
            }
            0x83232184 => {
    //   block [0x83232184..0x83232188)
	// 83232184: 4AF61CB5  bl 0x82193e38
	ctx.lr = 0x83232188;
	sub_82193E38(ctx, base);
	pc = 0x83232188; continue 'dispatch;
            }
            0x83232188 => {
    //   block [0x83232188..0x8323218C)
	// 83232188: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x8323218C; continue 'dispatch;
            }
            0x8323218C => {
    //   block [0x8323218C..0x83232198)
	// 8323218C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 83232190: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83232194: 419A00C0  beq cr6, 0x83232254
	if ctx.cr[6].eq {
	pc = 0x83232254; continue 'dispatch;
	}
	pc = 0x83232198; continue 'dispatch;
            }
            0x83232198 => {
    //   block [0x83232198..0x832321D4)
	// 83232198: 807F00D0  lwz r3, 0xd0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 8323219C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 832321A0: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 832321A4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832321A8: 4E800421  bctrl
	ctx.lr = 0x832321AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832321AC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 832321B0: 419A0024  beq cr6, 0x832321d4
	if ctx.cr[6].eq {
	pc = 0x832321D4; continue 'dispatch;
	}
	// 832321B4: 807F00D0  lwz r3, 0xd0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 832321B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 832321BC: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 832321C0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832321C4: 4E800421  bctrl
	ctx.lr = 0x832321C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832321C8: 2F030009  cmpwi cr6, r3, 9
	ctx.cr[6].compare_i32(ctx.r[3].s32, 9, &mut ctx.xer);
	// 832321CC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 832321D0: 409A0008  bne cr6, 0x832321d8
	if !ctx.cr[6].eq {
	pc = 0x832321D8; continue 'dispatch;
	}
            }
            0x832321D4 => {
    //   block [0x832321D4..0x832321D8)
	// 832321D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x832321D8; continue 'dispatch;
            }
            0x832321D8 => {
    //   block [0x832321D8..0x832321F0)
	// 832321D8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 832321DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832321E0: 419A0010  beq cr6, 0x832321f0
	if ctx.cr[6].eq {
	pc = 0x832321F0; continue 'dispatch;
	}
	// 832321E4: C01F019C  lfs f0, 0x19c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 832321E8: EFFFE82A  fadds f31, f31, f29
	ctx.f[31].f64 = ((ctx.f[31].f64 + ctx.f[29].f64) as f32) as f64;
	// 832321EC: EFC0F02A  fadds f30, f0, f30
	ctx.f[30].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	pc = 0x832321F0; continue 'dispatch;
            }
            0x832321F0 => {
    //   block [0x832321F0..0x83232214)
	// 832321F0: 3BFF00F4  addi r31, r31, 0xf4
	ctx.r[31].s64 = ctx.r[31].s64 + 244;
	// 832321F4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832321F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832321FC: 419A0048  beq cr6, 0x83232244
	if ctx.cr[6].eq {
	pc = 0x83232244; continue 'dispatch;
	}
	// 83232200: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83232204: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83232208: 419A000C  beq cr6, 0x83232214
	if ctx.cr[6].eq {
	pc = 0x83232214; continue 'dispatch;
	}
	// 8323220C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 83232210: 48000038  b 0x83232248
	pc = 0x83232248; continue 'dispatch;
            }
            0x83232214 => {
    //   block [0x83232214..0x83232240)
	// 83232214: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 83232218: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 8323221C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 83232220: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83232224: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 83232228: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8323222C: 409A0014  bne cr6, 0x83232240
	if !ctx.cr[6].eq {
	pc = 0x83232240; continue 'dispatch;
	}
	// 83232230: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83232234: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83232238: 409A0008  bne cr6, 0x83232240
	if !ctx.cr[6].eq {
	pc = 0x83232240; continue 'dispatch;
	}
	// 8323223C: 4AFE9AFD  bl 0x8221bd38
	ctx.lr = 0x83232240;
	sub_8221BD38(ctx, base);
	pc = 0x83232240; continue 'dispatch;
            }
            0x83232240 => {
    //   block [0x83232240..0x83232244)
	// 83232240: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	pc = 0x83232244; continue 'dispatch;
            }
            0x83232244 => {
    //   block [0x83232244..0x83232248)
	// 83232244: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x83232248; continue 'dispatch;
            }
            0x83232248 => {
    //   block [0x83232248..0x83232254)
	// 83232248: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 8323224C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83232250: 409AFF48  bne cr6, 0x83232198
	if !ctx.cr[6].eq {
	pc = 0x83232198; continue 'dispatch;
	}
	pc = 0x83232254; continue 'dispatch;
            }
            0x83232254 => {
    //   block [0x83232254..0x8323227C)
	// 83232254: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 83232258: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 8323225C: 4082FEFC  bne 0x83232158
	if !ctx.cr[0].eq {
	pc = 0x83232158; continue 'dispatch;
	}
	// 83232260: FF1FE000  fcmpu cr6, f31, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[28].f64);
	// 83232264: 40990018  ble cr6, 0x8323227c
	if !ctx.cr[6].gt {
	pc = 0x8323227C; continue 'dispatch;
	}
	// 83232268: EC3EF824  fdivs f1, f30, f31
	ctx.f[1].f64 = ((ctx.f[30].f64 / ctx.f[31].f64) as f32) as f64;
	// 8323226C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 83232270: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 83232274: 4BA7BAB1  bl 0x82cadd24
	ctx.lr = 0x83232278;
	sub_82CADCEC(ctx, base);
	// 83232278: 4BA771DC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x8323227C => {
    //   block [0x8323227C..0x83232290)
	// 8323227C: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 83232280: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 83232284: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 83232288: 4BA7BA9D  bl 0x82cadd24
	ctx.lr = 0x8323228C;
	sub_82CADCEC(ctx, base);
	// 8323228C: 4BA771C8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83232290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83232290 size=336
    let mut pc: u32 = 0x83232290;
    'dispatch: loop {
        match pc {
            0x83232290 => {
    //   block [0x83232290..0x832322C8)
	// 83232290: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83232294: 4BA77171  bl 0x82ca9404
	ctx.lr = 0x83232298;
	sub_82CA93D0(ctx, base);
	// 83232298: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 8323229C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832322A0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 832322A4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 832322A8: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 832322AC: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 832322B0: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 832322B4: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832322B8: 4081011C  ble 0x832323d4
	if !ctx.cr[0].gt {
	pc = 0x832323D4; continue 'dispatch;
	}
	// 832322BC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 832322C0: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 832322C4: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	pc = 0x832322C8; continue 'dispatch;
            }
            0x832322C8 => {
    //   block [0x832322C8..0x832322F4)
	// 832322C8: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 832322CC: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 832322D0: 386B00F4  addi r3, r11, 0xf4
	ctx.r[3].s64 = ctx.r[11].s64 + 244;
	// 832322D4: 816B00F8  lwz r11, 0xf8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) } as u64;
	// 832322D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832322DC: 419A001C  beq cr6, 0x832322f8
	if ctx.cr[6].eq {
	pc = 0x832322F8; continue 'dispatch;
	}
	// 832322E0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 832322E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832322E8: 419A000C  beq cr6, 0x832322f4
	if ctx.cr[6].eq {
	pc = 0x832322F4; continue 'dispatch;
	}
	// 832322EC: 555F003E  slwi r31, r10, 0
	ctx.r[31].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 832322F0: 4800000C  b 0x832322fc
	pc = 0x832322FC; continue 'dispatch;
            }
            0x832322F4 => {
    //   block [0x832322F4..0x832322F8)
	// 832322F4: 4AF61B45  bl 0x82193e38
	ctx.lr = 0x832322F8;
	sub_82193E38(ctx, base);
	pc = 0x832322F8; continue 'dispatch;
            }
            0x832322F8 => {
    //   block [0x832322F8..0x832322FC)
	// 832322F8: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	pc = 0x832322FC; continue 'dispatch;
            }
            0x832322FC => {
    //   block [0x832322FC..0x83232304)
	// 832322FC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 83232300: 419A00C8  beq cr6, 0x832323c8
	if ctx.cr[6].eq {
	pc = 0x832323C8; continue 'dispatch;
	}
	pc = 0x83232304; continue 'dispatch;
            }
            0x83232304 => {
    //   block [0x83232304..0x83232340)
	// 83232304: 807F00D0  lwz r3, 0xd0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 83232308: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323230C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 83232310: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83232314: 4E800421  bctrl
	ctx.lr = 0x83232318;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83232318: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 8323231C: 419A0024  beq cr6, 0x83232340
	if ctx.cr[6].eq {
	pc = 0x83232340; continue 'dispatch;
	}
	// 83232320: 807F00D0  lwz r3, 0xd0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 83232324: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83232328: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323232C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83232330: 4E800421  bctrl
	ctx.lr = 0x83232334;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83232334: 2F030009  cmpwi cr6, r3, 9
	ctx.cr[6].compare_i32(ctx.r[3].s32, 9, &mut ctx.xer);
	// 83232338: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 8323233C: 409A0008  bne cr6, 0x83232344
	if !ctx.cr[6].eq {
	pc = 0x83232344; continue 'dispatch;
	}
            }
            0x83232340 => {
    //   block [0x83232340..0x83232344)
	// 83232340: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x83232344; continue 'dispatch;
            }
            0x83232344 => {
    //   block [0x83232344..0x83232388)
	// 83232344: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 83232348: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8323234C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83232350: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83232354: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83232358: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 8323235C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83232360: 4E800421  bctrl
	ctx.lr = 0x83232364;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83232364: 3BFF00F4  addi r31, r31, 0xf4
	ctx.r[31].s64 = ctx.r[31].s64 + 244;
	// 83232368: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323236C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83232370: 419A0048  beq cr6, 0x832323b8
	if ctx.cr[6].eq {
	pc = 0x832323B8; continue 'dispatch;
	}
	// 83232374: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83232378: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323237C: 419A000C  beq cr6, 0x83232388
	if ctx.cr[6].eq {
	pc = 0x83232388; continue 'dispatch;
	}
	// 83232380: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 83232384: 48000038  b 0x832323bc
	pc = 0x832323BC; continue 'dispatch;
            }
            0x83232388 => {
    //   block [0x83232388..0x832323B4)
	// 83232388: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323238C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 83232390: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 83232394: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83232398: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323239C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 832323A0: 409A0014  bne cr6, 0x832323b4
	if !ctx.cr[6].eq {
	pc = 0x832323B4; continue 'dispatch;
	}
	// 832323A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 832323A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832323AC: 409A0008  bne cr6, 0x832323b4
	if !ctx.cr[6].eq {
	pc = 0x832323B4; continue 'dispatch;
	}
	// 832323B0: 4AFE9989  bl 0x8221bd38
	ctx.lr = 0x832323B4;
	sub_8221BD38(ctx, base);
	pc = 0x832323B4; continue 'dispatch;
            }
            0x832323B4 => {
    //   block [0x832323B4..0x832323B8)
	// 832323B4: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	pc = 0x832323B8; continue 'dispatch;
            }
            0x832323B8 => {
    //   block [0x832323B8..0x832323BC)
	// 832323B8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x832323BC; continue 'dispatch;
            }
            0x832323BC => {
    //   block [0x832323BC..0x832323C8)
	// 832323BC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 832323C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832323C4: 409AFF40  bne cr6, 0x83232304
	if !ctx.cr[6].eq {
	pc = 0x83232304; continue 'dispatch;
	}
	pc = 0x832323C8; continue 'dispatch;
            }
            0x832323C8 => {
    //   block [0x832323C8..0x832323D4)
	// 832323C8: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 832323CC: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 832323D0: 4082FEF8  bne 0x832322c8
	if !ctx.cr[0].eq {
	pc = 0x832322C8; continue 'dispatch;
	}
	pc = 0x832323D4; continue 'dispatch;
            }
            0x832323D4 => {
    //   block [0x832323D4..0x832323E0)
	// 832323D4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 832323D8: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 832323DC: 4BA77078  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832323E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x832323E0 size=328
    let mut pc: u32 = 0x832323E0;
    'dispatch: loop {
        match pc {
            0x832323E0 => {
    //   block [0x832323E0..0x8323241C)
	// 832323E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832323E4: 4BA77021  bl 0x82ca9404
	ctx.lr = 0x832323E8;
	sub_82CA93D0(ctx, base);
	// 832323E8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 832323EC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832323F0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 832323F4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 832323F8: D3FC0034  stfs f31, 0x34(r28)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 832323FC: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 83232400: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 83232404: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 83232408: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8323240C: 40810110  ble 0x8323251c
	if !ctx.cr[0].gt {
	pc = 0x8323251C; continue 'dispatch;
	}
	// 83232410: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 83232414: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 83232418: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	pc = 0x8323241C; continue 'dispatch;
            }
            0x8323241C => {
    //   block [0x8323241C..0x83232448)
	// 8323241C: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 83232420: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 83232424: 386B00F4  addi r3, r11, 0xf4
	ctx.r[3].s64 = ctx.r[11].s64 + 244;
	// 83232428: 816B00F8  lwz r11, 0xf8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) } as u64;
	// 8323242C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83232430: 419A001C  beq cr6, 0x8323244c
	if ctx.cr[6].eq {
	pc = 0x8323244C; continue 'dispatch;
	}
	// 83232434: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83232438: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323243C: 419A000C  beq cr6, 0x83232448
	if ctx.cr[6].eq {
	pc = 0x83232448; continue 'dispatch;
	}
	// 83232440: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 83232444: 4800000C  b 0x83232450
	pc = 0x83232450; continue 'dispatch;
            }
            0x83232448 => {
    //   block [0x83232448..0x8323244C)
	// 83232448: 4AF619F1  bl 0x82193e38
	ctx.lr = 0x8323244C;
	sub_82193E38(ctx, base);
	pc = 0x8323244C; continue 'dispatch;
            }
            0x8323244C => {
    //   block [0x8323244C..0x83232450)
	// 8323244C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x83232450; continue 'dispatch;
            }
            0x83232450 => {
    //   block [0x83232450..0x8323245C)
	// 83232450: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 83232454: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83232458: 419A00B8  beq cr6, 0x83232510
	if ctx.cr[6].eq {
	pc = 0x83232510; continue 'dispatch;
	}
	pc = 0x8323245C; continue 'dispatch;
            }
            0x8323245C => {
    //   block [0x8323245C..0x83232498)
	// 8323245C: 807F00D0  lwz r3, 0xd0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 83232460: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83232464: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 83232468: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323246C: 4E800421  bctrl
	ctx.lr = 0x83232470;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83232470: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 83232474: 419A0024  beq cr6, 0x83232498
	if ctx.cr[6].eq {
	pc = 0x83232498; continue 'dispatch;
	}
	// 83232478: 807F00D0  lwz r3, 0xd0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 8323247C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83232480: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 83232484: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83232488: 4E800421  bctrl
	ctx.lr = 0x8323248C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323248C: 2F030009  cmpwi cr6, r3, 9
	ctx.cr[6].compare_i32(ctx.r[3].s32, 9, &mut ctx.xer);
	// 83232490: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 83232494: 409A0008  bne cr6, 0x8323249c
	if !ctx.cr[6].eq {
	pc = 0x8323249C; continue 'dispatch;
	}
            }
            0x83232498 => {
    //   block [0x83232498..0x8323249C)
	// 83232498: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x8323249C; continue 'dispatch;
            }
            0x8323249C => {
    //   block [0x8323249C..0x832324AC)
	// 8323249C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 832324A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832324A4: 419A0008  beq cr6, 0x832324ac
	if ctx.cr[6].eq {
	pc = 0x832324AC; continue 'dispatch;
	}
	// 832324A8: D3FF0198  stfs f31, 0x198(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), tmp.u32 ) };
	pc = 0x832324AC; continue 'dispatch;
            }
            0x832324AC => {
    //   block [0x832324AC..0x832324D0)
	// 832324AC: 3BFF00F4  addi r31, r31, 0xf4
	ctx.r[31].s64 = ctx.r[31].s64 + 244;
	// 832324B0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832324B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832324B8: 419A0048  beq cr6, 0x83232500
	if ctx.cr[6].eq {
	pc = 0x83232500; continue 'dispatch;
	}
	// 832324BC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 832324C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832324C4: 419A000C  beq cr6, 0x832324d0
	if ctx.cr[6].eq {
	pc = 0x832324D0; continue 'dispatch;
	}
	// 832324C8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832324CC: 48000038  b 0x83232504
	pc = 0x83232504; continue 'dispatch;
            }
            0x832324D0 => {
    //   block [0x832324D0..0x832324FC)
	// 832324D0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 832324D4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 832324D8: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 832324DC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832324E0: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 832324E4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 832324E8: 409A0014  bne cr6, 0x832324fc
	if !ctx.cr[6].eq {
	pc = 0x832324FC; continue 'dispatch;
	}
	// 832324EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 832324F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832324F4: 409A0008  bne cr6, 0x832324fc
	if !ctx.cr[6].eq {
	pc = 0x832324FC; continue 'dispatch;
	}
	// 832324F8: 4AFE9841  bl 0x8221bd38
	ctx.lr = 0x832324FC;
	sub_8221BD38(ctx, base);
	pc = 0x832324FC; continue 'dispatch;
            }
            0x832324FC => {
    //   block [0x832324FC..0x83232500)
	// 832324FC: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	pc = 0x83232500; continue 'dispatch;
            }
            0x83232500 => {
    //   block [0x83232500..0x83232504)
	// 83232500: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x83232504; continue 'dispatch;
            }
            0x83232504 => {
    //   block [0x83232504..0x83232510)
	// 83232504: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 83232508: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323250C: 409AFF50  bne cr6, 0x8323245c
	if !ctx.cr[6].eq {
	pc = 0x8323245C; continue 'dispatch;
	}
	pc = 0x83232510; continue 'dispatch;
            }
            0x83232510 => {
    //   block [0x83232510..0x8323251C)
	// 83232510: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 83232514: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 83232518: 4082FF04  bne 0x8323241c
	if !ctx.cr[0].eq {
	pc = 0x8323241C; continue 'dispatch;
	}
	pc = 0x8323251C; continue 'dispatch;
            }
            0x8323251C => {
    //   block [0x8323251C..0x83232528)
	// 8323251C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 83232520: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 83232524: 4BA76F30  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83232530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83232530 size=104
    let mut pc: u32 = 0x83232530;
    'dispatch: loop {
        match pc {
            0x83232530 => {
    //   block [0x83232530..0x83232568)
	// 83232530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83232534: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83232538: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8323253C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 83232540: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83232544: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 83232548: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 8323254C: 3BFE0018  addi r31, r30, 0x18
	ctx.r[31].s64 = ctx.r[30].s64 + 24;
	// 83232550: 394B21BC  addi r10, r11, 0x21bc
	ctx.r[10].s64 = ctx.r[11].s64 + 8636;
	// 83232554: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 83232558: 807E001C  lwz r3, 0x1c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 8323255C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 83232560: 419A0008  beq cr6, 0x83232568
	if ctx.cr[6].eq {
	pc = 0x83232568; continue 'dispatch;
	}
	// 83232564: 4AFE97D5  bl 0x8221bd38
	ctx.lr = 0x83232568;
	sub_8221BD38(ctx, base);
	pc = 0x83232568; continue 'dispatch;
            }
            0x83232568 => {
    //   block [0x83232568..0x83232598)
	// 83232568: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8323256C: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 83232570: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 83232574: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 83232578: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 8323257C: 4B1AA2AD  bl 0x823dc828
	ctx.lr = 0x83232580;
	sub_823DC828(ctx, base);
	// 83232580: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 83232584: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 83232588: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8323258C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 83232590: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 83232594: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832325A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832325A8 size=396
    let mut pc: u32 = 0x832325A8;
    'dispatch: loop {
        match pc {
            0x832325A8 => {
    //   block [0x832325A8..0x83232734)
	// 832325A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832325AC: 4BA76E49  bl 0x82ca93f4
	ctx.lr = 0x832325B0;
	sub_82CA93D0(ctx, base);
	// 832325B0: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 832325B4: 3980FF80  li r12, -0x80
	ctx.r[12].s64 = -128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83232748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83232748 size=352
    let mut pc: u32 = 0x83232748;
    'dispatch: loop {
        match pc {
            0x83232748 => {
    //   block [0x83232748..0x832327DC)
	// 83232748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323274C: 4BA76CB5  bl 0x82ca9400
	ctx.lr = 0x83232750;
	sub_82CA93D0(ctx, base);
	// 83232750: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83232754: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 83232758: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8323275C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83232760: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 83232764: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 83232768: 4B7EFE91  bl 0x82a225f8
	ctx.lr = 0x8323276C;
	sub_82A225F8(ctx, base);
	// 8323276C: 897B0038  lbz r11, 0x38(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(56 as u32) ) } as u64;
	// 83232770: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83232774: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83232778: 7D690034  cntlzw r9, r11
	ctx.r[9].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8323277C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 83232780: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 83232784: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 83232788: 69070001  xori r7, r8, 1
	ctx.r[7].u64 = ctx.r[8].u64 ^ 1;
	// 8323278C: 80CA0010  lwz r6, 0x10(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 83232790: 98E10050  stb r7, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u8 ) };
	// 83232794: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 83232798: 4E800421  bctrl
	ctx.lr = 0x8323279C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323279C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832327A0: 809B003C  lwz r4, 0x3c(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(60 as u32) ) } as u64;
	// 832327A4: 4B7EFE55  bl 0x82a225f8
	ctx.lr = 0x832327A8;
	sub_82A225F8(ctx, base);
	// 832327A8: 809B000C  lwz r4, 0xc(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 832327AC: 80BB0010  lwz r5, 0x10(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 832327B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832327B4: 7D642850  subf r11, r4, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 832327B8: 7D7E1E70  srawi r30, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 832327BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 832327C0: 4B7EFE39  bl 0x82a225f8
	ctx.lr = 0x832327C4;
	sub_82A225F8(ctx, base);
	// 832327C4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 832327C8: 4B7E6179  bl 0x82a18940
	ctx.lr = 0x832327CC;
	sub_82A18940(ctx, base);
	// 832327CC: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 832327D0: 40990094  ble cr6, 0x83232864
	if !ctx.cr[6].gt {
	pc = 0x83232864; continue 'dispatch;
	}
	// 832327D4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 832327D8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
            }
            0x832327DC => {
    //   block [0x832327DC..0x83232814)
	// 832327DC: 817B001C  lwz r11, 0x1c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 832327E0: 895F0008  lbz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 832327E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832327E8: 7D3D582E  lwzx r9, r29, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 832327EC: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 832327F0: 419A0024  beq cr6, 0x83232814
	if ctx.cr[6].eq {
	pc = 0x83232814; continue 'dispatch;
	}
	// 832327F4: 89610058  lbz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 832327F8: 89410059  lbz r10, 0x59(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 832327FC: 8921005B  lbz r9, 0x5b(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(91 as u32) ) } as u64;
	// 83232800: 8901005A  lbz r8, 0x5a(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(90 as u32) ) } as u64;
	// 83232804: 9961005B  stb r11, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[11].u8 ) };
	// 83232808: 9941005A  stb r10, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[10].u8 ) };
	// 8323280C: 99210058  stb r9, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 83232810: 99010059  stb r8, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[8].u8 ) };
	pc = 0x83232814; continue 'dispatch;
            }
            0x83232814 => {
    //   block [0x83232814..0x83232864)
	// 83232814: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83232818: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 8323281C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 83232820: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83232824: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 83232828: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323282C: 4E800421  bctrl
	ctx.lr = 0x83232830;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83232830: 813B000C  lwz r9, 0xc(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 83232834: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 83232838: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 8323283C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 83232840: 7C69E02E  lwzx r3, r9, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 83232844: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83232848: 80E80008  lwz r7, 8(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323284C: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 83232850: 4E800421  bctrl
	ctx.lr = 0x83232854;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83232854: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 83232858: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 8323285C: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 83232860: 4082FF7C  bne 0x832327dc
	if !ctx.cr[0].eq {
	pc = 0x832327DC; continue 'dispatch;
	}
            }
            0x83232864 => {
    //   block [0x83232864..0x832328A8)
	// 83232864: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 83232868: 39210068  addi r9, r1, 0x68
	ctx.r[9].s64 = ctx.r[1].s64 + 104;
	// 8323286C: 39410068  addi r10, r1, 0x68
	ctx.r[10].s64 = ctx.r[1].s64 + 104;
	// 83232870: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 83232874: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 83232878: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323287C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 83232880: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83232884: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 83232888: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8323288C: 91010064  stw r8, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[8].u32 ) };
	// 83232890: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 83232894: 4B7E53E5  bl 0x82a17c78
	ctx.lr = 0x83232898;
	sub_82A17C78(ctx, base);
	// 83232898: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8323289C: 4AFE949D  bl 0x8221bd38
	ctx.lr = 0x832328A0;
	sub_8221BD38(ctx, base);
	// 832328A0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 832328A4: 4BA76BAC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832328A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832328A8 size=492
    let mut pc: u32 = 0x832328A8;
    'dispatch: loop {
        match pc {
            0x832328A8 => {
    //   block [0x832328A8..0x832328E0)
	// 832328A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832328AC: 4BA76B4D  bl 0x82ca93f8
	ctx.lr = 0x832328B0;
	sub_82CA93D0(ctx, base);
	// 832328B0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832328B4: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 832328B8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 832328BC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 832328C0: 3B0BFFDF  addi r24, r11, -0x21
	ctx.r[24].s64 = ctx.r[11].s64 + -33;
	// 832328C4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 832328C8: 816AE510  lwz r11, -0x1af0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-6896 as u32) ) } as u64;
	// 832328CC: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 832328D0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 832328D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832328D8: 419A0008  beq cr6, 0x832328e0
	if ctx.cr[6].eq {
	pc = 0x832328E0; continue 'dispatch;
	}
	// 832328DC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x832328E0; continue 'dispatch;
            }
            0x832328E0 => {
    //   block [0x832328E0..0x83232918)
	// 832328E0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 832328E4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 832328E8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 832328EC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832328F0: 4E800421  bctrl
	ctx.lr = 0x832328F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832328F4: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 832328F8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 832328FC: 419A0190  beq cr6, 0x83232a8c
	if ctx.cr[6].eq {
	pc = 0x83232A8C; continue 'dispatch;
	}
	// 83232900: 3FE0834A  lis r31, -0x7cb6
	ctx.r[31].s64 = -2092302336;
	// 83232904: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 83232908: 817FE518  lwz r11, -0x1ae8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-6888 as u32) ) } as u64;
	// 8323290C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83232910: 419A0008  beq cr6, 0x83232918
	if ctx.cr[6].eq {
	pc = 0x83232918; continue 'dispatch;
	}
	// 83232914: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x83232918 => {
    //   block [0x83232918..0x83232954)
	// 83232918: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323291C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 83232920: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 83232924: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83232928: 4E800421  bctrl
	ctx.lr = 0x8323292C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323292C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 83232930: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83232934: 419A0040  beq cr6, 0x83232974
	if ctx.cr[6].eq {
	pc = 0x83232974; continue 'dispatch;
	}
	// 83232938: 817FE518  lwz r11, -0x1ae8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-6888 as u32) ) } as u64;
	// 8323293C: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 83232940: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 83232944: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 83232948: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323294C: 419A0008  beq cr6, 0x83232954
	if ctx.cr[6].eq {
	pc = 0x83232954; continue 'dispatch;
	}
	// 83232950: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x83232954 => {
    //   block [0x83232954..0x83232974)
	// 83232954: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 83232958: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8323295C: 4B24DE6D  bl 0x824807c8
	ctx.lr = 0x83232960;
	sub_824807C8(ctx, base);
	// 83232960: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 83232964: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 83232968: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323296C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83232970: 4E800421  bctrl
	ctx.lr = 0x83232974;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x83232974 => {
    //   block [0x83232974..0x832329A8)
	// 83232974: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 83232978: 38BB0038  addi r5, r27, 0x38
	ctx.r[5].s64 = ctx.r[27].s64 + 56;
	// 8323297C: 386BE51C  addi r3, r11, -0x1ae4
	ctx.r[3].s64 = ctx.r[11].s64 + -6884;
	// 83232980: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 83232984: 48002C7D  bl 0x83235600
	ctx.lr = 0x83232988;
	sub_83235600(ctx, base);
	// 83232988: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8323298C: 813B003C  lwz r9, 0x3c(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(60 as u32) ) } as u64;
	// 83232990: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 83232994: 816AE520  lwz r11, -0x1ae0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-6880 as u32) ) } as u64;
	// 83232998: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 8323299C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832329A0: 419A0008  beq cr6, 0x832329a8
	if ctx.cr[6].eq {
	pc = 0x832329A8; continue 'dispatch;
	}
	// 832329A4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x832329A8; continue 'dispatch;
            }
            0x832329A8 => {
    //   block [0x832329A8..0x832329E0)
	// 832329A8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 832329AC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 832329B0: 4B15D6D9  bl 0x82390088
	ctx.lr = 0x832329B4;
	sub_82390088(ctx, base);
	// 832329B4: 815B0010  lwz r10, 0x10(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 832329B8: 813B000C  lwz r9, 0xc(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 832329BC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832329C0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 832329C4: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 832329C8: 7D071E70  srawi r7, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 832329CC: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 832329D0: 816BE514  lwz r11, -0x1aec(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6892 as u32) ) } as u64;
	// 832329D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832329D8: 419A0008  beq cr6, 0x832329e0
	if ctx.cr[6].eq {
	pc = 0x832329E0; continue 'dispatch;
	}
	// 832329DC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x832329E0; continue 'dispatch;
            }
            0x832329E0 => {
    //   block [0x832329E0..0x83232A10)
	// 832329E0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 832329E4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 832329E8: 4B24DDE1  bl 0x824807c8
	ctx.lr = 0x832329EC;
	sub_824807C8(ctx, base);
	// 832329EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 832329F0: 4B7E5F51  bl 0x82a18940
	ctx.lr = 0x832329F4;
	sub_82A18940(ctx, base);
	// 832329F4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 832329F8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 832329FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 83232A00: 40990070  ble cr6, 0x83232a70
	if !ctx.cr[6].gt {
	pc = 0x83232A70; continue 'dispatch;
	}
	// 83232A04: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 83232A08: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 83232A0C: 3F40834A  lis r26, -0x7cb6
	ctx.r[26].s64 = -2092302336;
	pc = 0x83232A10; continue 'dispatch;
            }
            0x83232A10 => {
    //   block [0x83232A10..0x83232A2C)
	// 83232A10: 815B001C  lwz r10, 0x1c(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 83232A14: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 83232A18: 817AE524  lwz r11, -0x1adc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6876 as u32) ) } as u64;
	// 83232A1C: 7CAAFA14  add r5, r10, r31
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 83232A20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83232A24: 419A0008  beq cr6, 0x83232a2c
	if ctx.cr[6].eq {
	pc = 0x83232A2C; continue 'dispatch;
	}
	// 83232A28: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x83232A2C; continue 'dispatch;
            }
            0x83232A2C => {
    //   block [0x83232A2C..0x83232A70)
	// 83232A2C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 83232A30: 4B24DD99  bl 0x824807c8
	ctx.lr = 0x83232A34;
	sub_824807C8(ctx, base);
	// 83232A34: 817B000C  lwz r11, 0xc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 83232A38: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 83232A3C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 83232A40: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 83232A44: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 83232A48: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83232A4C: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 83232A50: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 83232A54: 4E800421  bctrl
	ctx.lr = 0x83232A58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83232A58: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 83232A5C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 83232A60: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 83232A64: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 83232A68: 7F1D4000  cmpw cr6, r29, r8
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[8].s32, &mut ctx.xer);
	// 83232A6C: 4198FFA4  blt cr6, 0x83232a10
	if ctx.cr[6].lt {
	pc = 0x83232A10; continue 'dispatch;
	}
            }
            0x83232A70 => {
    //   block [0x83232A70..0x83232A8C)
	// 83232A70: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 83232A74: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 83232A78: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 83232A7C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83232A80: 4E800421  bctrl
	ctx.lr = 0x83232A84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83232A84: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 83232A88: 4B7E52D9  bl 0x82a17d60
	ctx.lr = 0x83232A8C;
	sub_82A17D60(ctx, base);
            }
            0x83232A8C => {
    //   block [0x83232A8C..0x83232A94)
	// 83232A8C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 83232A90: 4BA769B8  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83232A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83232A98 size=200
    let mut pc: u32 = 0x83232A98;
    'dispatch: loop {
        match pc {
            0x83232A98 => {
    //   block [0x83232A98..0x83232AD4)
	// 83232A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83232A9C: 4BA76969  bl 0x82ca9404
	ctx.lr = 0x83232AA0;
	sub_82CA93D0(ctx, base);
	// 83232AA0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83232AA4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 83232AA8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 83232AAC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 83232AB0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 83232AB4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 83232AB8: 4B339439  bl 0x8256bef0
	ctx.lr = 0x83232ABC;
	sub_8256BEF0(ctx, base);
	// 83232ABC: 83610054  lwz r27, 0x54(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 83232AC0: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 83232AC4: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 83232AC8: 7F1BE040  cmplw cr6, r27, r28
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[28].u32, &mut ctx.xer);
	// 83232ACC: 419A007C  beq cr6, 0x83232b48
	if ctx.cr[6].eq {
	pc = 0x83232B48; continue 'dispatch;
	}
	// 83232AD0: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	pc = 0x83232AD4; continue 'dispatch;
            }
            0x83232AD4 => {
    //   block [0x83232AD4..0x83232B34)
	// 83232AD4: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 83232AD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83232ADC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83232AE0: 814B0060  lwz r10, 0x60(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 83232AE4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83232AE8: 4E800421  bctrl
	ctx.lr = 0x83232AEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83232AEC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83232AF0: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 83232AF4: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 83232AF8: 7CE84850  subf r7, r8, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 83232AFC: 54E6003A  rlwinm r6, r7, 0, 0, 0x1d
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 83232B00: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 83232B04: 40990038  ble cr6, 0x83232b3c
	if !ctx.cr[6].gt {
	pc = 0x83232B3C; continue 'dispatch;
	}
	// 83232B08: 817F0170  lwz r11, 0x170(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 83232B0C: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 83232B10: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 83232B14: 419A0020  beq cr6, 0x83232b34
	if ctx.cr[6].eq {
	pc = 0x83232B34; continue 'dispatch;
	}
	// 83232B18: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 83232B1C: 419A0018  beq cr6, 0x83232b34
	if ctx.cr[6].eq {
	pc = 0x83232B34; continue 'dispatch;
	}
	// 83232B20: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 83232B24: 409A0018  bne cr6, 0x83232b3c
	if !ctx.cr[6].eq {
	pc = 0x83232B3C; continue 'dispatch;
	}
	// 83232B28: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 83232B2C: 9BAB0029  stb r29, 0x29(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(41 as u32), ctx.r[29].u8 ) };
	// 83232B30: 4800000C  b 0x83232b3c
	pc = 0x83232B3C; continue 'dispatch;
            }
            0x83232B34 => {
    //   block [0x83232B34..0x83232B3C)
	// 83232B34: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 83232B38: 9BAB0035  stb r29, 0x35(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(53 as u32), ctx.r[29].u8 ) };
	pc = 0x83232B3C; continue 'dispatch;
            }
            0x83232B3C => {
    //   block [0x83232B3C..0x83232B48)
	// 83232B3C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 83232B40: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 83232B44: 409AFF90  bne cr6, 0x83232ad4
	if !ctx.cr[6].eq {
	pc = 0x83232AD4; continue 'dispatch;
	}
	pc = 0x83232B48; continue 'dispatch;
            }
            0x83232B48 => {
    //   block [0x83232B48..0x83232B58)
	// 83232B48: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 83232B4C: 419A000C  beq cr6, 0x83232b58
	if ctx.cr[6].eq {
	pc = 0x83232B58; continue 'dispatch;
	}
	// 83232B50: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 83232B54: 4AFE91E5  bl 0x8221bd38
	ctx.lr = 0x83232B58;
	sub_8221BD38(ctx, base);
	pc = 0x83232B58; continue 'dispatch;
            }
            0x83232B58 => {
    //   block [0x83232B58..0x83232B60)
	// 83232B58: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 83232B5C: 4BA768F8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83232B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83232B60 size=356
    let mut pc: u32 = 0x83232B60;
    'dispatch: loop {
        match pc {
            0x83232B60 => {
    //   block [0x83232B60..0x83232BA8)
	// 83232B60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83232B64: 4BA76895  bl 0x82ca93f8
	ctx.lr = 0x83232B68;
	sub_82CA93D0(ctx, base);
	// 83232B68: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83232B6C: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 83232B70: 90A100D4  stw r5, 0xd4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), ctx.r[5].u32 ) };
	// 83232B74: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 83232B78: 80780000  lwz r3, 0(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 83232B7C: 4BFF687D  bl 0x832293f8
	ctx.lr = 0x83232B80;
	sub_832293F8(ctx, base);
	// 83232B80: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 83232B84: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 83232B88: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 83232B8C: 3B5B0008  addi r26, r27, 8
	ctx.r[26].s64 = ctx.r[27].s64 + 8;
	// 83232B90: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 83232B94: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 83232B98: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 83232B9C: 7D3C1E71  srawi. r28, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 83232BA0: 40810054  ble 0x83232bf4
	if !ctx.cr[0].gt {
	pc = 0x83232BF4; continue 'dispatch;
	}
	// 83232BA4: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	pc = 0x83232BA8; continue 'dispatch;
            }
            0x83232BA8 => {
    //   block [0x83232BA8..0x83232BD4)
	// 83232BA8: 817B000C  lwz r11, 0xc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 83232BAC: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 83232BB0: 386B00F4  addi r3, r11, 0xf4
	ctx.r[3].s64 = ctx.r[11].s64 + 244;
	// 83232BB4: 816B00F8  lwz r11, 0xf8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) } as u64;
	// 83232BB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83232BBC: 419A001C  beq cr6, 0x83232bd8
	if ctx.cr[6].eq {
	pc = 0x83232BD8; continue 'dispatch;
	}
	// 83232BC0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83232BC4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83232BC8: 419A000C  beq cr6, 0x83232bd4
	if ctx.cr[6].eq {
	pc = 0x83232BD4; continue 'dispatch;
	}
	// 83232BCC: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 83232BD0: 4800000C  b 0x83232bdc
	pc = 0x83232BDC; continue 'dispatch;
            }
            0x83232BD4 => {
    //   block [0x83232BD4..0x83232BD8)
	// 83232BD4: 4AF61265  bl 0x82193e38
	ctx.lr = 0x83232BD8;
	sub_82193E38(ctx, base);
	pc = 0x83232BD8; continue 'dispatch;
            }
            0x83232BD8 => {
    //   block [0x83232BD8..0x83232BDC)
	// 83232BD8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x83232BDC; continue 'dispatch;
            }
            0x83232BDC => {
    //   block [0x83232BDC..0x83232BF4)
	// 83232BDC: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 83232BE0: 419A00DC  beq cr6, 0x83232cbc
	if ctx.cr[6].eq {
	pc = 0x83232CBC; continue 'dispatch;
	}
	// 83232BE4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 83232BE8: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 83232BEC: 7F1EE000  cmpw cr6, r30, r28
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[28].s32, &mut ctx.xer);
	// 83232BF0: 4198FFB8  blt cr6, 0x83232ba8
	if ctx.cr[6].lt {
	pc = 0x83232BA8; continue 'dispatch;
	}
	pc = 0x83232BF4; continue 'dispatch;
            }
            0x83232BF4 => {
    //   block [0x83232BF4..0x83232BFC)
	// 83232BF4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 83232BF8: 419A0068  beq cr6, 0x83232c60
	if ctx.cr[6].eq {
	pc = 0x83232C60; continue 'dispatch;
	}
	pc = 0x83232BFC; continue 'dispatch;
            }
            0x83232BFC => {
    //   block [0x83232BFC..0x83232C20)
	// 83232BFC: 817D00F8  lwz r11, 0xf8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(248 as u32) ) } as u64;
	// 83232C00: 3BFD00F4  addi r31, r29, 0xf4
	ctx.r[31].s64 = ctx.r[29].s64 + 244;
	// 83232C04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83232C08: 419A0048  beq cr6, 0x83232c50
	if ctx.cr[6].eq {
	pc = 0x83232C50; continue 'dispatch;
	}
	// 83232C0C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83232C10: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83232C14: 419A000C  beq cr6, 0x83232c20
	if ctx.cr[6].eq {
	pc = 0x83232C20; continue 'dispatch;
	}
	// 83232C18: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 83232C1C: 48000038  b 0x83232c54
	pc = 0x83232C54; continue 'dispatch;
            }
            0x83232C20 => {
    //   block [0x83232C20..0x83232C4C)
	// 83232C20: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 83232C24: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 83232C28: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 83232C2C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83232C30: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 83232C34: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83232C38: 409A0014  bne cr6, 0x83232c4c
	if !ctx.cr[6].eq {
	pc = 0x83232C4C; continue 'dispatch;
	}
	// 83232C3C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83232C40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83232C44: 409A0008  bne cr6, 0x83232c4c
	if !ctx.cr[6].eq {
	pc = 0x83232C4C; continue 'dispatch;
	}
	// 83232C48: 4AFE90F1  bl 0x8221bd38
	ctx.lr = 0x83232C4C;
	sub_8221BD38(ctx, base);
	pc = 0x83232C4C; continue 'dispatch;
            }
            0x83232C4C => {
    //   block [0x83232C4C..0x83232C50)
	// 83232C4C: 933F0004  stw r25, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	pc = 0x83232C50; continue 'dispatch;
            }
            0x83232C50 => {
    //   block [0x83232C50..0x83232C54)
	// 83232C50: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x83232C54; continue 'dispatch;
            }
            0x83232C54 => {
    //   block [0x83232C54..0x83232C60)
	// 83232C54: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 83232C58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83232C5C: 409AFFA0  bne cr6, 0x83232bfc
	if !ctx.cr[6].eq {
	pc = 0x83232BFC; continue 'dispatch;
	}
	pc = 0x83232C60; continue 'dispatch;
            }
            0x83232C60 => {
    //   block [0x83232C60..0x83232CBC)
	// 83232C60: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 83232C64: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 83232C68: 808BE678  lwz r4, -0x1988(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6536 as u32) ) } as u64;
	// 83232C6C: 4BFF90C5  bl 0x8322bd30
	ctx.lr = 0x83232C70;
	sub_8322BD30(ctx, base);
	// 83232C70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 83232C74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 83232C78: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 83232C7C: 4BFF770D  bl 0x8322a388
	ctx.lr = 0x83232C80;
	sub_8322A388(ctx, base);
	// 83232C80: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 83232C84: 4AF84E95  bl 0x821b7b18
	ctx.lr = 0x83232C88;
	sub_821B7B18(ctx, base);
	// 83232C88: 80780000  lwz r3, 0(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 83232C8C: 4BFF676D  bl 0x832293f8
	ctx.lr = 0x83232C90;
	sub_832293F8(ctx, base);
	// 83232C90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 83232C94: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 83232C98: 4BFF67C1  bl 0x83229458
	ctx.lr = 0x83232C9C;
	sub_83229458(ctx, base);
	// 83232C9C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 83232CA0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 83232CA4: 4B21E115  bl 0x82450db8
	ctx.lr = 0x83232CA8;
	sub_82450DB8(ctx, base);
	// 83232CA8: 388100D4  addi r4, r1, 0xd4
	ctx.r[4].s64 = ctx.r[1].s64 + 212;
	// 83232CAC: 387B0018  addi r3, r27, 0x18
	ctx.r[3].s64 = ctx.r[27].s64 + 24;
	// 83232CB0: 4B12EEB9  bl 0x82361b68
	ctx.lr = 0x83232CB4;
	sub_82361B68(ctx, base);
	// 83232CB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 83232CB8: 4AF84E61  bl 0x821b7b18
	ctx.lr = 0x83232CBC;
	sub_821B7B18(ctx, base);
	pc = 0x83232CBC; continue 'dispatch;
            }
            0x83232CBC => {
    //   block [0x83232CBC..0x83232CC4)
	// 83232CBC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 83232CC0: 4BA76788  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83232CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83232CC8 size=1004
    let mut pc: u32 = 0x83232CC8;
    'dispatch: loop {
        match pc {
            0x83232CC8 => {
    //   block [0x83232CC8..0x83232D38)
	// 83232CC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83232CCC: 4BA7672D  bl 0x82ca93f8
	ctx.lr = 0x83232CD0;
	sub_82CA93D0(ctx, base);
	// 83232CD0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83232CD4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 83232CD8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 83232CDC: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 83232CE0: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 83232CE4: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 83232CE8: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 83232CEC: 4198004C  blt cr6, 0x83232d38
	if ctx.cr[6].lt {
	pc = 0x83232D38; continue 'dispatch;
	}
	// 83232CF0: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 83232CF4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 83232CF8: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 83232CFC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83232D00: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 83232D04: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 83232D08: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83232D0C: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 83232D10: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 83232D14: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 83232D18: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 83232D1C: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 83232D20: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 83232D24: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 83232D28: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 83232D2C: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 83232D30: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 83232D34: 48000014  b 0x83232d48
	pc = 0x83232D48; continue 'dispatch;
            }
            0x83232D38 => {
    //   block [0x83232D38..0x83232D48)
	// 83232D38: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 83232D3C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 83232D40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83232D44: 4B7EE1A5  bl 0x82a20ee8
	ctx.lr = 0x83232D48;
	sub_82A20EE8(ctx, base);
	pc = 0x83232D48; continue 'dispatch;
            }
            0x83232D48 => {
    //   block [0x83232D48..0x83232D80)
	// 83232D48: 83C10060  lwz r30, 0x60(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 83232D4C: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 83232D50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83232D54: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 83232D58: 419A0028  beq cr6, 0x83232d80
	if ctx.cr[6].eq {
	pc = 0x83232D80; continue 'dispatch;
	}
	// 83232D5C: 89010063  lbz r8, 0x63(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(99 as u32) ) } as u64;
	// 83232D60: 89410059  lbz r10, 0x59(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 83232D64: 8921005A  lbz r9, 0x5a(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(90 as u32) ) } as u64;
	// 83232D68: 89610060  lbz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 83232D6C: 99010058  stb r8, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u8 ) };
	// 83232D70: 9941005A  stb r10, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[10].u8 ) };
	// 83232D74: 99210059  stb r9, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[9].u8 ) };
	// 83232D78: 9961005B  stb r11, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[11].u8 ) };
	// 83232D7C: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	pc = 0x83232D80; continue 'dispatch;
            }
            0x83232D80 => {
    //   block [0x83232D80..0x83232DC4)
	// 83232D80: 2F1E0004  cmpwi cr6, r30, 4
	ctx.cr[6].compare_i32(ctx.r[30].s32, 4, &mut ctx.xer);
	// 83232D84: 41980064  blt cr6, 0x83232de8
	if ctx.cr[6].lt {
	pc = 0x83232DE8; continue 'dispatch;
	}
	// 83232D88: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 83232D8C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 83232D90: 41980034  blt cr6, 0x83232dc4
	if ctx.cr[6].lt {
	pc = 0x83232DC4; continue 'dispatch;
	}
	// 83232D94: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 83232D98: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 83232D9C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83232DA0: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 83232DA4: 38EB0001  addi r7, r11, 1
	ctx.r[7].s64 = ctx.r[11].s64 + 1;
	// 83232DA8: 38CA0001  addi r6, r10, 1
	ctx.r[6].s64 = ctx.r[10].s64 + 1;
	// 83232DAC: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83232DB0: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 83232DB4: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 83232DB8: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 83232DBC: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 83232DC0: 48000014  b 0x83232dd4
	pc = 0x83232DD4; continue 'dispatch;
            }
            0x83232DC4 => {
    //   block [0x83232DC4..0x83232DD4)
	// 83232DC4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 83232DC8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 83232DCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83232DD0: 4B7EE119  bl 0x82a20ee8
	ctx.lr = 0x83232DD4;
	sub_82A20EE8(ctx, base);
	pc = 0x83232DD4; continue 'dispatch;
            }
            0x83232DD4 => {
    //   block [0x83232DD4..0x83232DE8)
	// 83232DD4: 89410050  lbz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 83232DD8: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 83232DDC: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 83232DE0: 69070001  xori r7, r8, 1
	ctx.r[7].u64 = ctx.r[8].u64 ^ 1;
	// 83232DE4: 98FA0038  stb r7, 0x38(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(56 as u32), ctx.r[7].u8 ) };
	pc = 0x83232DE8; continue 'dispatch;
            }
            0x83232DE8 => {
    //   block [0x83232DE8..0x83232E44)
	// 83232DE8: 2F1E0005  cmpwi cr6, r30, 5
	ctx.cr[6].compare_i32(ctx.r[30].s32, 5, &mut ctx.xer);
	// 83232DEC: 419800A4  blt cr6, 0x83232e90
	if ctx.cr[6].lt {
	pc = 0x83232E90; continue 'dispatch;
	}
	// 83232DF0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 83232DF4: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 83232DF8: 4198004C  blt cr6, 0x83232e44
	if ctx.cr[6].lt {
	pc = 0x83232E44; continue 'dispatch;
	}
	// 83232DFC: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 83232E00: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 83232E04: 39010064  addi r8, r1, 0x64
	ctx.r[8].s64 = ctx.r[1].s64 + 100;
	// 83232E08: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83232E0C: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 83232E10: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 83232E14: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83232E18: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 83232E1C: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 83232E20: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 83232E24: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 83232E28: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 83232E2C: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 83232E30: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 83232E34: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 83232E38: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 83232E3C: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 83232E40: 48000014  b 0x83232e54
	pc = 0x83232E54; continue 'dispatch;
            }
            0x83232E44 => {
    //   block [0x83232E44..0x83232E54)
	// 83232E44: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 83232E48: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 83232E4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83232E50: 4B7EE099  bl 0x82a20ee8
	ctx.lr = 0x83232E54;
	sub_82A20EE8(ctx, base);
	pc = 0x83232E54; continue 'dispatch;
            }
            0x83232E54 => {
    //   block [0x83232E54..0x83232E88)
	// 83232E54: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 83232E58: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 83232E5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83232E60: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 83232E64: 419A0024  beq cr6, 0x83232e88
	if ctx.cr[6].eq {
	pc = 0x83232E88; continue 'dispatch;
	}
	// 83232E68: 89610059  lbz r11, 0x59(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 83232E6C: 8941005A  lbz r10, 0x5a(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(90 as u32) ) } as u64;
	// 83232E70: 89210067  lbz r9, 0x67(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(103 as u32) ) } as u64;
	// 83232E74: 89010064  lbz r8, 0x64(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 83232E78: 9961005A  stb r11, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[11].u8 ) };
	// 83232E7C: 99410059  stb r10, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[10].u8 ) };
	// 83232E80: 99210058  stb r9, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 83232E84: 9901005B  stb r8, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[8].u8 ) };
	pc = 0x83232E88; continue 'dispatch;
            }
            0x83232E88 => {
    //   block [0x83232E88..0x83232E90)
	// 83232E88: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 83232E8C: 917A003C  stw r11, 0x3c(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	pc = 0x83232E90; continue 'dispatch;
            }
            0x83232E90 => {
    //   block [0x83232E90..0x83232EE4)
	// 83232E90: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 83232E94: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 83232E98: 4198004C  blt cr6, 0x83232ee4
	if ctx.cr[6].lt {
	pc = 0x83232EE4; continue 'dispatch;
	}
	// 83232E9C: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 83232EA0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 83232EA4: 39010068  addi r8, r1, 0x68
	ctx.r[8].s64 = ctx.r[1].s64 + 104;
	// 83232EA8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83232EAC: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 83232EB0: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 83232EB4: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83232EB8: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 83232EBC: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 83232EC0: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 83232EC4: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 83232EC8: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 83232ECC: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 83232ED0: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 83232ED4: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 83232ED8: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 83232EDC: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 83232EE0: 48000014  b 0x83232ef4
	pc = 0x83232EF4; continue 'dispatch;
            }
            0x83232EE4 => {
    //   block [0x83232EE4..0x83232EF4)
	// 83232EE4: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 83232EE8: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 83232EEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83232EF0: 4B7EDFF9  bl 0x82a20ee8
	ctx.lr = 0x83232EF4;
	sub_82A20EE8(ctx, base);
	pc = 0x83232EF4; continue 'dispatch;
            }
            0x83232EF4 => {
    //   block [0x83232EF4..0x83232F2C)
	// 83232EF4: 83C10068  lwz r30, 0x68(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 83232EF8: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 83232EFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83232F00: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 83232F04: 419A0028  beq cr6, 0x83232f2c
	if ctx.cr[6].eq {
	pc = 0x83232F2C; continue 'dispatch;
	}
	// 83232F08: 89610059  lbz r11, 0x59(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 83232F0C: 8941005A  lbz r10, 0x5a(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(90 as u32) ) } as u64;
	// 83232F10: 8921006B  lbz r9, 0x6b(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(107 as u32) ) } as u64;
	// 83232F14: 89010068  lbz r8, 0x68(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 83232F18: 9961005A  stb r11, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[11].u8 ) };
	// 83232F1C: 99410059  stb r10, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[10].u8 ) };
	// 83232F20: 99210058  stb r9, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 83232F24: 9901005B  stb r8, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[8].u8 ) };
	// 83232F28: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	pc = 0x83232F2C; continue 'dispatch;
            }
            0x83232F2C => {
    //   block [0x83232F2C..0x83232F48)
	// 83232F2C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 83232F30: 4B7D7681  bl 0x82a0a5b0
	ctx.lr = 0x83232F34;
	sub_82A0A5B0(ctx, base);
	// 83232F34: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 83232F38: 40990128  ble cr6, 0x83233060
	if !ctx.cr[6].gt {
	pc = 0x83233060; continue 'dispatch;
	}
	// 83232F3C: 3BBA0018  addi r29, r26, 0x18
	ctx.r[29].s64 = ctx.r[26].s64 + 24;
	// 83232F40: 3B9A0008  addi r28, r26, 8
	ctx.r[28].s64 = ctx.r[26].s64 + 8;
	// 83232F44: 3F60834A  lis r27, -0x7cb6
	ctx.r[27].s64 = -2092302336;
	pc = 0x83232F48; continue 'dispatch;
            }
            0x83232F48 => {
    //   block [0x83232F48..0x83232F9C)
	// 83232F48: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 83232F4C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 83232F50: 4198004C  blt cr6, 0x83232f9c
	if ctx.cr[6].lt {
	pc = 0x83232F9C; continue 'dispatch;
	}
	// 83232F54: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 83232F58: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 83232F5C: 3901006C  addi r8, r1, 0x6c
	ctx.r[8].s64 = ctx.r[1].s64 + 108;
	// 83232F60: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83232F64: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 83232F68: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 83232F6C: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83232F70: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 83232F74: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 83232F78: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 83232F7C: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 83232F80: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 83232F84: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 83232F88: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 83232F8C: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 83232F90: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 83232F94: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 83232F98: 48000014  b 0x83232fac
	pc = 0x83232FAC; continue 'dispatch;
            }
            0x83232F9C => {
    //   block [0x83232F9C..0x83232FAC)
	// 83232F9C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 83232FA0: 3881006C  addi r4, r1, 0x6c
	ctx.r[4].s64 = ctx.r[1].s64 + 108;
	// 83232FA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83232FA8: 4B7EDF41  bl 0x82a20ee8
	ctx.lr = 0x83232FAC;
	sub_82A20EE8(ctx, base);
	pc = 0x83232FAC; continue 'dispatch;
            }
            0x83232FAC => {
    //   block [0x83232FAC..0x83232FE0)
	// 83232FAC: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 83232FB0: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 83232FB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83232FB8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 83232FBC: 419A0024  beq cr6, 0x83232fe0
	if ctx.cr[6].eq {
	pc = 0x83232FE0; continue 'dispatch;
	}
	// 83232FC0: 89610059  lbz r11, 0x59(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 83232FC4: 8941005A  lbz r10, 0x5a(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(90 as u32) ) } as u64;
	// 83232FC8: 8921006F  lbz r9, 0x6f(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(111 as u32) ) } as u64;
	// 83232FCC: 8901006C  lbz r8, 0x6c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 83232FD0: 9961005A  stb r11, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[11].u8 ) };
	// 83232FD4: 99410059  stb r10, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[10].u8 ) };
	// 83232FD8: 99210058  stb r9, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 83232FDC: 9901005B  stb r8, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[8].u8 ) };
	pc = 0x83232FE0; continue 'dispatch;
            }
            0x83232FE0 => {
    //   block [0x83232FE0..0x83233060)
	// 83232FE0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 83232FE4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 83232FE8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 83232FEC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 83232FF0: 4B12EB79  bl 0x82361b68
	ctx.lr = 0x83232FF4;
	sub_82361B68(ctx, base);
	// 83232FF4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 83232FF8: 809BE678  lwz r4, -0x1988(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-6536 as u32) ) } as u64;
	// 83232FFC: 4BFF8D35  bl 0x8322bd30
	ctx.lr = 0x83233000;
	sub_8322BD30(ctx, base);
	// 83233000: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 83233004: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 83233008: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 8323300C: 4BFF737D  bl 0x8322a388
	ctx.lr = 0x83233010;
	sub_8322A388(ctx, base);
	// 83233010: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 83233014: 4AF84B05  bl 0x821b7b18
	ctx.lr = 0x83233018;
	sub_821B7B18(ctx, base);
	// 83233018: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 8323301C: 7F08C378  mr r8, r24
	ctx.r[8].u64 = ctx.r[24].u64;
	// 83233020: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 83233024: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 83233028: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 8323302C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83233030: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 83233034: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 83233038: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323303C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 83233040: 4E800421  bctrl
	ctx.lr = 0x83233044;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83233044: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 83233048: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8323304C: 4B21DD6D  bl 0x82450db8
	ctx.lr = 0x83233050;
	sub_82450DB8(ctx, base);
	// 83233050: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 83233054: 4AF84AC5  bl 0x821b7b18
	ctx.lr = 0x83233058;
	sub_821B7B18(ctx, base);
	// 83233058: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8323305C: 4082FEEC  bne 0x83232f48
	if !ctx.cr[0].eq {
	pc = 0x83232F48; continue 'dispatch;
	}
            }
            0x83233060 => {
    //   block [0x83233060..0x832330B4)
	// 83233060: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 83233064: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 83233068: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8323306C: 4BFFEF1D  bl 0x83231f88
	ctx.lr = 0x83233070;
	sub_83231F88(ctx, base);
	// 83233070: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 83233074: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 83233078: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 8323307C: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 83233080: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 83233084: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 83233088: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 8323308C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83233090: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 83233094: E8C10070  ld r6, 0x70(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 83233098: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 8323309C: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 832330A0: 4B1C92E9  bl 0x823fc388
	ctx.lr = 0x832330A4;
	sub_823FC388(ctx, base);
	// 832330A4: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 832330A8: 4AFE8C91  bl 0x8221bd38
	ctx.lr = 0x832330AC;
	sub_8221BD38(ctx, base);
	// 832330AC: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 832330B0: 4BA76398  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832330B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x832330B8 size=580
    let mut pc: u32 = 0x832330B8;
    'dispatch: loop {
        match pc {
            0x832330B8 => {
    //   block [0x832330B8..0x832330F4)
	// 832330B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832330BC: 4BA76331  bl 0x82ca93ec
	ctx.lr = 0x832330C0;
	sub_82CA93D0(ctx, base);
	// 832330C0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832330C4: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 832330C8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 832330CC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 832330D0: 3AABFFDF  addi r21, r11, -0x21
	ctx.r[21].s64 = ctx.r[11].s64 + -33;
	// 832330D4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 832330D8: 816AE510  lwz r11, -0x1af0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-6896 as u32) ) } as u64;
	// 832330DC: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 832330E0: 7CD63378  mr r22, r6
	ctx.r[22].u64 = ctx.r[6].u64;
	// 832330E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832330E8: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 832330EC: 419A0008  beq cr6, 0x832330f4
	if ctx.cr[6].eq {
	pc = 0x832330F4; continue 'dispatch;
	}
	// 832330F0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x832330F4; continue 'dispatch;
            }
            0x832330F4 => {
    //   block [0x832330F4..0x8323312C)
	// 832330F4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 832330F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832330FC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 83233100: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83233104: 4E800421  bctrl
	ctx.lr = 0x83233108;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83233108: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8323310C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83233110: 419A01E4  beq cr6, 0x832332f4
	if ctx.cr[6].eq {
	pc = 0x832332F4; continue 'dispatch;
	}
	// 83233114: 3FA0834A  lis r29, -0x7cb6
	ctx.r[29].s64 = -2092302336;
	// 83233118: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 8323311C: 817DE518  lwz r11, -0x1ae8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-6888 as u32) ) } as u64;
	// 83233120: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83233124: 419A0008  beq cr6, 0x8323312c
	if ctx.cr[6].eq {
	pc = 0x8323312C; continue 'dispatch;
	}
	// 83233128: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x8323312C => {
    //   block [0x8323312C..0x83233168)
	// 8323312C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 83233130: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 83233134: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 83233138: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323313C: 4E800421  bctrl
	ctx.lr = 0x83233140;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83233140: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 83233144: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 83233148: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8323314C: 419A003C  beq cr6, 0x83233188
	if ctx.cr[6].eq {
	pc = 0x83233188; continue 'dispatch;
	}
	// 83233150: 817DE518  lwz r11, -0x1ae8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-6888 as u32) ) } as u64;
	// 83233154: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 83233158: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8323315C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83233160: 419A0008  beq cr6, 0x83233168
	if ctx.cr[6].eq {
	pc = 0x83233168; continue 'dispatch;
	}
	// 83233164: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x83233168 => {
    //   block [0x83233168..0x83233188)
	// 83233168: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 8323316C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 83233170: 4B24D659  bl 0x824807c8
	ctx.lr = 0x83233174;
	sub_824807C8(ctx, base);
	// 83233174: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 83233178: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323317C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 83233180: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83233184: 4E800421  bctrl
	ctx.lr = 0x83233188;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x83233188 => {
    //   block [0x83233188..0x832331B8)
	// 83233188: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8323318C: 38BA0038  addi r5, r26, 0x38
	ctx.r[5].s64 = ctx.r[26].s64 + 56;
	// 83233190: 386BE51C  addi r3, r11, -0x1ae4
	ctx.r[3].s64 = ctx.r[11].s64 + -6884;
	// 83233194: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 83233198: 48002469  bl 0x83235600
	ctx.lr = 0x8323319C;
	sub_83235600(ctx, base);
	// 8323319C: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 832331A0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 832331A4: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 832331A8: 816AE520  lwz r11, -0x1ae0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-6880 as u32) ) } as u64;
	// 832331AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832331B0: 419A0008  beq cr6, 0x832331b8
	if ctx.cr[6].eq {
	pc = 0x832331B8; continue 'dispatch;
	}
	// 832331B4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x832331B8; continue 'dispatch;
            }
            0x832331B8 => {
    //   block [0x832331B8..0x832331E4)
	// 832331B8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 832331BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832331C0: 4B15CEC9  bl 0x82390088
	ctx.lr = 0x832331C4;
	sub_82390088(ctx, base);
	// 832331C4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 832331C8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832331CC: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 832331D0: 915A003C  stw r10, 0x3c(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(60 as u32), ctx.r[10].u32 ) };
	// 832331D4: 816BE514  lwz r11, -0x1aec(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6892 as u32) ) } as u64;
	// 832331D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832331DC: 419A0008  beq cr6, 0x832331e4
	if ctx.cr[6].eq {
	pc = 0x832331E4; continue 'dispatch;
	}
	// 832331E0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x832331E4; continue 'dispatch;
            }
            0x832331E4 => {
    //   block [0x832331E4..0x83233218)
	// 832331E4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 832331E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832331EC: 4B24D5DD  bl 0x824807c8
	ctx.lr = 0x832331F0;
	sub_824807C8(ctx, base);
	// 832331F0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 832331F4: 4B7D73BD  bl 0x82a0a5b0
	ctx.lr = 0x832331F8;
	sub_82A0A5B0(ctx, base);
	// 832331F8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 832331FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 83233200: 409900BC  ble cr6, 0x832332bc
	if !ctx.cr[6].gt {
	pc = 0x832332BC; continue 'dispatch;
	}
	// 83233204: 3B9A0018  addi r28, r26, 0x18
	ctx.r[28].s64 = ctx.r[26].s64 + 24;
	// 83233208: 3B7A0008  addi r27, r26, 8
	ctx.r[27].s64 = ctx.r[26].s64 + 8;
	// 8323320C: 3B000003  li r24, 3
	ctx.r[24].s64 = 3;
	// 83233210: 3FA0834A  lis r29, -0x7cb6
	ctx.r[29].s64 = -2092302336;
	// 83233214: 3F20834A  lis r25, -0x7cb6
	ctx.r[25].s64 = -2092302336;
	pc = 0x83233218; continue 'dispatch;
            }
            0x83233218 => {
    //   block [0x83233218..0x83233230)
	// 83233218: 8179E524  lwz r11, -0x1adc(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-6876 as u32) ) } as u64;
	// 8323321C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 83233220: 93010054  stw r24, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[24].u32 ) };
	// 83233224: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83233228: 419A0008  beq cr6, 0x83233230
	if ctx.cr[6].eq {
	pc = 0x83233230; continue 'dispatch;
	}
	// 8323322C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x83233230; continue 'dispatch;
            }
            0x83233230 => {
    //   block [0x83233230..0x832332BC)
	// 83233230: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 83233234: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 83233238: 4B24D591  bl 0x824807c8
	ctx.lr = 0x8323323C;
	sub_824807C8(ctx, base);
	// 8323323C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 83233240: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 83233244: 4B12E925  bl 0x82361b68
	ctx.lr = 0x83233248;
	sub_82361B68(ctx, base);
	// 83233248: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8323324C: 809DE678  lwz r4, -0x1988(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-6536 as u32) ) } as u64;
	// 83233250: 4BFF8AE1  bl 0x8322bd30
	ctx.lr = 0x83233254;
	sub_8322BD30(ctx, base);
	// 83233254: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 83233258: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323325C: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 83233260: 4BFF7129  bl 0x8322a388
	ctx.lr = 0x83233264;
	sub_8322A388(ctx, base);
	// 83233264: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 83233268: 4AF848B1  bl 0x821b7b18
	ctx.lr = 0x8323326C;
	sub_821B7B18(ctx, base);
	// 8323326C: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 83233270: 7EC8B378  mr r8, r22
	ctx.r[8].u64 = ctx.r[22].u64;
	// 83233274: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 83233278: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 8323327C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 83233280: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 83233284: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 83233288: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323328C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 83233290: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83233294: 4E800421  bctrl
	ctx.lr = 0x83233298;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83233298: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8323329C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 832332A0: 4B21DB19  bl 0x82450db8
	ctx.lr = 0x832332A4;
	sub_82450DB8(ctx, base);
	// 832332A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 832332A8: 4AF84871  bl 0x821b7b18
	ctx.lr = 0x832332AC;
	sub_821B7B18(ctx, base);
	// 832332AC: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 832332B0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 832332B4: 7F1F4800  cmpw cr6, r31, r9
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[9].s32, &mut ctx.xer);
	// 832332B8: 4198FF60  blt cr6, 0x83233218
	if ctx.cr[6].lt {
	pc = 0x83233218; continue 'dispatch;
	}
            }
            0x832332BC => {
    //   block [0x832332BC..0x832332F4)
	// 832332BC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 832332C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832332C4: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 832332C8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832332CC: 4E800421  bctrl
	ctx.lr = 0x832332D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832332D0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 832332D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 832332D8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 832332DC: 4BFFECAD  bl 0x83231f88
	ctx.lr = 0x832332E0;
	sub_83231F88(ctx, base);
	// 832332E0: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 832332E4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 832332E8: C009D5C8  lfs f0, -0x2a38(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10808 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 832332EC: D01A0030  stfs f0, 0x30(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 832332F0: 4B0E04B1  bl 0x823137a0
	ctx.lr = 0x832332F4;
	sub_823137A0(ctx, base);
            }
            0x832332F4 => {
    //   block [0x832332F4..0x832332FC)
	// 832332F4: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 832332F8: 4BA76144  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83233300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x83233300 size=780
    let mut pc: u32 = 0x83233300;
    'dispatch: loop {
        match pc {
            0x83233300 => {
    //   block [0x83233300..0x832333BC)
	// 83233300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83233304: 4BA760D5  bl 0x82ca93d8
	ctx.lr = 0x83233308;
	sub_82CA93D0(ctx, base);
	// 83233308: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323330C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 83233310: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 83233314: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 83233318: 390A9490  addi r8, r10, -0x6b70
	ctx.r[8].s64 = ctx.r[10].s64 + -27504;
	// 8323331C: 38E921BC  addi r7, r9, 0x21bc
	ctx.r[7].s64 = ctx.r[9].s64 + 8636;
	// 83233320: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 83233324: 90FB0000  stw r7, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 83233328: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 8323332C: 929B0004  stw r20, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[20].u32 ) };
	// 83233330: C00A9490  lfs f0, -0x6b70(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 83233334: 929B000C  stw r20, 0xc(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(12 as u32), ctx.r[20].u32 ) };
	// 83233338: C1A84138  lfs f13, 0x4138(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(16696 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8323333C: 929B0010  stw r20, 0x10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(16 as u32), ctx.r[20].u32 ) };
	// 83233340: 929B0014  stw r20, 0x14(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(20 as u32), ctx.r[20].u32 ) };
	// 83233344: 929B001C  stw r20, 0x1c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(28 as u32), ctx.r[20].u32 ) };
	// 83233348: 929B0020  stw r20, 0x20(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(32 as u32), ctx.r[20].u32 ) };
	// 8323334C: 929B0024  stw r20, 0x24(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(36 as u32), ctx.r[20].u32 ) };
	// 83233350: D1BB0030  stfs f13, 0x30(r27)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 83233354: D01B0034  stfs f0, 0x34(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 83233358: 929B0028  stw r20, 0x28(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(40 as u32), ctx.r[20].u32 ) };
	// 8323335C: D01B0044  stfs f0, 0x44(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 83233360: 917B002C  stw r11, 0x2c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 83233364: 9A9B0038  stb r20, 0x38(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(56 as u32), ctx.r[20].u8 ) };
	// 83233368: 929B003C  stw r20, 0x3c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(60 as u32), ctx.r[20].u32 ) };
	// 8323336C: 917B0040  stw r11, 0x40(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 83233370: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 83233374: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83233378: 419A020C  beq cr6, 0x83233584
	if ctx.cr[6].eq {
	pc = 0x83233584; continue 'dispatch;
	}
	// 8323337C: 896B001C  lbz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 83233380: 3A000014  li r16, 0x14
	ctx.r[16].s64 = 20;
	// 83233384: 7E91A378  mr r17, r20
	ctx.r[17].u64 = ctx.r[20].u64;
	// 83233388: 997B0038  stb r11, 0x38(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(56 as u32), ctx.r[11].u8 ) };
	// 8323338C: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 83233390: 812A0020  lwz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 83233394: 913B003C  stw r9, 0x3c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(60 as u32), ctx.r[9].u32 ) };
	// 83233398: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323339C: 3A4B000C  addi r18, r11, 0xc
	ctx.r[18].s64 = ctx.r[11].s64 + 12;
	// 832333A0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 832333A4: 81120008  lwz r8, 8(r18)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) } as u64;
	// 832333A8: 7CEB4050  subf r7, r11, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 832333AC: 7CC783D7  divw. r6, r7, r16
	ctx.r[6].s32 = ctx.r[7].s32 / ctx.r[16].s32;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 832333B0: 408101C4  ble 0x83233574
	if !ctx.cr[0].gt {
	pc = 0x83233574; continue 'dispatch;
	}
	// 832333B4: 7E93A378  mr r19, r20
	ctx.r[19].u64 = ctx.r[20].u64;
	// 832333B8: 3AA0000C  li r21, 0xc
	ctx.r[21].s64 = 12;
	pc = 0x832333BC; continue 'dispatch;
            }
            0x832333BC => {
    //   block [0x832333BC..0x832333F0)
	// 832333BC: 7F335A14  add r25, r19, r11
	ctx.r[25].u64 = ctx.r[19].u64 + ctx.r[11].u64;
	// 832333C0: 7E98A378  mr r24, r20
	ctx.r[24].u64 = ctx.r[20].u64;
	// 832333C4: 7E96A378  mr r22, r20
	ctx.r[22].u64 = ctx.r[20].u64;
	// 832333C8: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 832333CC: 7E9FA378  mr r31, r20
	ctx.r[31].u64 = ctx.r[20].u64;
	// 832333D0: 92C10054  stw r22, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[22].u32 ) };
	// 832333D4: 7E97A378  mr r23, r20
	ctx.r[23].u64 = ctx.r[20].u64;
	// 832333D8: 81590008  lwz r10, 8(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 832333DC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 832333E0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 832333E4: 7D09ABD7  divw. r8, r9, r21
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[21].s32;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 832333E8: 40810164  ble 0x8323354c
	if !ctx.cr[0].gt {
	pc = 0x8323354C; continue 'dispatch;
	}
	// 832333EC: 7E9AA378  mr r26, r20
	ctx.r[26].u64 = ctx.r[20].u64;
	pc = 0x832333F0; continue 'dispatch;
            }
            0x832333F0 => {
    //   block [0x832333F0..0x83233470)
	// 832333F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 832333F4: 7C9A582E  lwzx r4, r26, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 832333F8: 7F9A5A14  add r28, r26, r11
	ctx.r[28].u64 = ctx.r[26].u64 + ctx.r[11].u64;
	// 832333FC: 4BFF8935  bl 0x8322bd30
	ctx.lr = 0x83233400;
	sub_8322BD30(ctx, base);
	// 83233400: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 83233404: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83233408: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323340C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83233410: 4E800421  bctrl
	ctx.lr = 0x83233414;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83233414: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 83233418: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 8323341C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 83233420: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 83233424: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 83233428: 409A0058  bne cr6, 0x83233480
	if !ctx.cr[6].eq {
	pc = 0x83233480; continue 'dispatch;
	}
	// 8323342C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 83233430: 4BFF7581  bl 0x8322a9b0
	ctx.lr = 0x83233434;
	sub_8322A9B0(ctx, base);
	// 83233434: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 83233438: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323343C: 7F16F840  cmplw cr6, r22, r31
	ctx.cr[6].compare_u32(ctx.r[22].u32, ctx.r[31].u32, &mut ctx.xer);
	// 83233440: 419A0030  beq cr6, 0x83233470
	if ctx.cr[6].eq {
	pc = 0x83233470; continue 'dispatch;
	}
	// 83233444: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 83233448: 4AF846D1  bl 0x821b7b18
	ctx.lr = 0x8323344C;
	sub_821B7B18(ctx, base);
	// 8323344C: 7FD8F378  mr r24, r30
	ctx.r[24].u64 = ctx.r[30].u64;
	// 83233450: 7FF6FB78  mr r22, r31
	ctx.r[22].u64 = ctx.r[31].u64;
	// 83233454: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 83233458: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8323345C: 92C10054  stw r22, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[22].u32 ) };
	// 83233460: 419A0010  beq cr6, 0x83233470
	if ctx.cr[6].eq {
	pc = 0x83233470; continue 'dispatch;
	}
	// 83233464: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83233468: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8323346C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
            }
            0x83233470 => {
    //   block [0x83233470..0x83233480)
	// 83233470: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 83233474: 4AF846A5  bl 0x821b7b18
	ctx.lr = 0x83233478;
	sub_821B7B18(ctx, base);
	// 83233478: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	// 8323347C: 48000024  b 0x832334a0
	pc = 0x832334A0; continue 'dispatch;
            }
            0x83233480 => {
    //   block [0x83233480..0x832334A0)
	// 83233480: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 83233484: 4BFF752D  bl 0x8322a9b0
	ctx.lr = 0x83233488;
	sub_8322A9B0(ctx, base);
	// 83233488: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323348C: 83E10078  lwz r31, 0x78(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 83233490: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 83233494: 4BFF5FC5  bl 0x83229458
	ctx.lr = 0x83233498;
	sub_83229458(ctx, base);
	// 83233498: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8323349C: 4AF8467D  bl 0x821b7b18
	ctx.lr = 0x832334A0;
	sub_821B7B18(ctx, base);
	pc = 0x832334A0; continue 'dispatch;
            }
            0x832334A0 => {
    //   block [0x832334A0..0x832334F0)
	// 832334A0: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 832334A4: 419A00EC  beq cr6, 0x83233590
	if ctx.cr[6].eq {
	pc = 0x83233590; continue 'dispatch;
	}
	// 832334A8: 2F1D0009  cmpwi cr6, r29, 9
	ctx.cr[6].compare_i32(ctx.r[29].s32, 9, &mut ctx.xer);
	// 832334AC: 419A00E4  beq cr6, 0x83233590
	if ctx.cr[6].eq {
	pc = 0x83233590; continue 'dispatch;
	}
	// 832334B0: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 832334B4: 409A011C  bne cr6, 0x832335d0
	if !ctx.cr[6].eq {
	pc = 0x832335D0; continue 'dispatch;
	}
	// 832334B8: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 832334BC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 832334C0: 419A0038  beq cr6, 0x832334f8
	if ctx.cr[6].eq {
	pc = 0x832334F8; continue 'dispatch;
	}
	// 832334C4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 832334C8: 4BFF8CD1  bl 0x8322c198
	ctx.lr = 0x832334CC;
	sub_8322C198(ctx, base);
	// 832334CC: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 832334D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832334D4: 419A001C  beq cr6, 0x832334f0
	if ctx.cr[6].eq {
	pc = 0x832334F0; continue 'dispatch;
	}
	// 832334D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832334DC: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 832334E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832334E4: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 832334E8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832334EC: 4E800421  bctrl
	ctx.lr = 0x832334F0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x832334F0 => {
    //   block [0x832334F0..0x832334F8)
	// 832334F0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 832334F4: 4AF84625  bl 0x821b7b18
	ctx.lr = 0x832334F8;
	sub_821B7B18(ctx, base);
	pc = 0x832334F8; continue 'dispatch;
            }
            0x832334F8 => {
    //   block [0x832334F8..0x83233524)
	// 832334F8: 809C0008  lwz r4, 8(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 832334FC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 83233500: 419A002C  beq cr6, 0x8323352c
	if ctx.cr[6].eq {
	pc = 0x8323352C; continue 'dispatch;
	}
	// 83233504: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 83233508: 4BFF8C91  bl 0x8322c198
	ctx.lr = 0x8323350C;
	sub_8322C198(ctx, base);
	// 8323350C: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 83233510: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83233514: 419A0010  beq cr6, 0x83233524
	if ctx.cr[6].eq {
	pc = 0x83233524; continue 'dispatch;
	}
	// 83233518: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8323351C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83233520: 4BFFA399  bl 0x8322d8b8
	ctx.lr = 0x83233524;
	sub_8322D8B8(ctx, base);
	pc = 0x83233524; continue 'dispatch;
            }
            0x83233524 => {
    //   block [0x83233524..0x8323352C)
	// 83233524: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 83233528: 4AF845F1  bl 0x821b7b18
	ctx.lr = 0x8323352C;
	sub_821B7B18(ctx, base);
	pc = 0x8323352C; continue 'dispatch;
            }
            0x8323352C => {
    //   block [0x8323352C..0x83233534)
	// 8323352C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 83233530: 4AF845E9  bl 0x821b7b18
	ctx.lr = 0x83233534;
	sub_821B7B18(ctx, base);
	pc = 0x83233534; continue 'dispatch;
            }
            0x83233534 => {
    //   block [0x83233534..0x8323354C)
	// 83233534: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 83233538: 419A0014  beq cr6, 0x8323354c
	if ctx.cr[6].eq {
	pc = 0x8323354C; continue 'dispatch;
	}
	// 8323353C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 83233540: 80B90010  lwz r5, 0x10(r25)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(16 as u32) ) } as u64;
	// 83233544: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 83233548: 4BFFF619  bl 0x83232b60
	ctx.lr = 0x8323354C;
	sub_83232B60(ctx, base);
	pc = 0x8323354C; continue 'dispatch;
            }
            0x8323354C => {
    //   block [0x8323354C..0x83233574)
	// 8323354C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 83233550: 4AF845C9  bl 0x821b7b18
	ctx.lr = 0x83233554;
	sub_821B7B18(ctx, base);
	// 83233554: 81720004  lwz r11, 4(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(4 as u32) ) } as u64;
	// 83233558: 81520008  lwz r10, 8(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323355C: 3A310001  addi r17, r17, 1
	ctx.r[17].s64 = ctx.r[17].s64 + 1;
	// 83233560: 3A730014  addi r19, r19, 0x14
	ctx.r[19].s64 = ctx.r[19].s64 + 20;
	// 83233564: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 83233568: 7D0983D6  divw r8, r9, r16
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[16].s32;
	// 8323356C: 7F114000  cmpw cr6, r17, r8
	ctx.cr[6].compare_i32(ctx.r[17].s32, ctx.r[8].s32, &mut ctx.xer);
	// 83233570: 4198FE4C  blt cr6, 0x832333bc
	if ctx.cr[6].lt {
	pc = 0x832333BC; continue 'dispatch;
	}
	pc = 0x83233574; continue 'dispatch;
            }
            0x83233574 => {
    //   block [0x83233574..0x83233584)
	// 83233574: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 83233578: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8323357C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 83233580: 4BFFEA09  bl 0x83231f88
	ctx.lr = 0x83233584;
	sub_83231F88(ctx, base);
	pc = 0x83233584; continue 'dispatch;
            }
            0x83233584 => {
    //   block [0x83233584..0x83233590)
	// 83233584: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 83233588: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 8323358C: 4BA75E9C  b 0x82ca9428
	sub_82CA9420(ctx, base);
	return;
            }
            0x83233590 => {
    //   block [0x83233590..0x832335C8)
	// 83233590: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 83233594: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 83233598: 419A0038  beq cr6, 0x832335d0
	if ctx.cr[6].eq {
	pc = 0x832335D0; continue 'dispatch;
	}
	// 8323359C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 832335A0: 4BFF8BF9  bl 0x8322c198
	ctx.lr = 0x832335A4;
	sub_8322C198(ctx, base);
	// 832335A4: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 832335A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832335AC: 419A001C  beq cr6, 0x832335c8
	if ctx.cr[6].eq {
	pc = 0x832335C8; continue 'dispatch;
	}
	// 832335B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832335B4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 832335B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832335BC: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 832335C0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832335C4: 4E800421  bctrl
	ctx.lr = 0x832335C8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x832335C8 => {
    //   block [0x832335C8..0x832335D0)
	// 832335C8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 832335CC: 4AF8454D  bl 0x821b7b18
	ctx.lr = 0x832335D0;
	sub_821B7B18(ctx, base);
	pc = 0x832335D0; continue 'dispatch;
            }
            0x832335D0 => {
    //   block [0x832335D0..0x8323360C)
	// 832335D0: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 832335D4: 419AFF58  beq cr6, 0x8323352c
	if ctx.cr[6].eq {
	pc = 0x8323352C; continue 'dispatch;
	}
	// 832335D8: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 832335DC: 419AFF50  beq cr6, 0x8323352c
	if ctx.cr[6].eq {
	pc = 0x8323352C; continue 'dispatch;
	}
	// 832335E0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 832335E4: 4AF84535  bl 0x821b7b18
	ctx.lr = 0x832335E8;
	sub_821B7B18(ctx, base);
	// 832335E8: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 832335EC: 81590008  lwz r10, 8(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 832335F0: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 832335F4: 3B5A000C  addi r26, r26, 0xc
	ctx.r[26].s64 = ctx.r[26].s64 + 12;
	// 832335F8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 832335FC: 7D09ABD6  divw r8, r9, r21
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[21].s32;
	// 83233600: 7F174000  cmpw cr6, r23, r8
	ctx.cr[6].compare_i32(ctx.r[23].s32, ctx.r[8].s32, &mut ctx.xer);
	// 83233604: 4198FDEC  blt cr6, 0x832333f0
	if ctx.cr[6].lt {
	pc = 0x832333F0; continue 'dispatch;
	}
	// 83233608: 4BFFFF2C  b 0x83233534
	pc = 0x83233534; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83233610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x83233610 size=108
    let mut pc: u32 = 0x83233610;
    'dispatch: loop {
        match pc {
            0x83233610 => {
    //   block [0x83233610..0x8323367C)
	// 83233610: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 83233614: 3D208336  lis r9, -0x7cca
	ctx.r[9].s64 = -2093613056;
	// 83233618: 390AB480  addi r8, r10, -0x4b80
	ctx.r[8].s64 = ctx.r[10].s64 + -19328;
	// 8323361C: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 83233620: 38C9F1BC  addi r6, r9, -0xe44
	ctx.r[6].s64 = ctx.r[9].s64 + -3652;
	// 83233624: C12AB480  lfs f9, -0x4b80(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19328 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 83233628: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8323362C: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 83233630: C1A8DE24  lfs f13, -0x21dc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-8668 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 83233634: C0070B8C  lfs f0, 0xb8c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2956 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 83233638: C188E010  lfs f12, -0x1ff0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-8176 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8323363C: 9166002C  stw r11, 0x2c(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 83233640: C1682294  lfs f11, 0x2294(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8852 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 83233644: 91460030  stw r10, 0x30(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 83233648: C148E058  lfs f10, -0x1fa8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-8104 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8323364C: D1A60020  stfs f13, 0x20(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 83233650: D0060024  stfs f0, 0x24(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 83233654: D1860028  stfs f12, 0x28(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 83233658: D149F1BC  stfs f10, -0xe44(r9)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-3652 as u32), tmp.u32 ) };
	// 8323365C: D1660008  stfs f11, 8(r6)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 83233660: D1660010  stfs f11, 0x10(r6)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 83233664: D1260018  stfs f9, 0x18(r6)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 83233668: D1A60004  stfs f13, 4(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8323366C: D006000C  stfs f0, 0xc(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 83233670: D0060014  stfs f0, 0x14(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 83233674: D186001C  stfs f12, 0x1c(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 83233678: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83233680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83233680 size=16
    let mut pc: u32 = 0x83233680;
    'dispatch: loop {
        match pc {
            0x83233680 => {
    //   block [0x83233680..0x83233690)
	// 83233680: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 83233684: 394B2390  addi r10, r11, 0x2390
	ctx.r[10].s64 = ctx.r[11].s64 + 9104;
	// 83233688: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8323368C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83233690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83233690 size=300
    let mut pc: u32 = 0x83233690;
    'dispatch: loop {
        match pc {
            0x83233690 => {
    //   block [0x83233690..0x832336B8)
	// 83233690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83233694: 4BA75D65  bl 0x82ca93f8
	ctx.lr = 0x83233698;
	sub_82CA93D0(ctx, base);
	// 83233698: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323369C: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 832336A0: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 832336A4: 8378000C  lwz r27, 0xc(r24)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) } as u64;
	// 832336A8: 81780010  lwz r11, 0x10(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 832336AC: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 832336B0: 419A0104  beq cr6, 0x832337b4
	if ctx.cr[6].eq {
	pc = 0x832337B4; continue 'dispatch;
	}
	// 832336B4: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	pc = 0x832336B8; continue 'dispatch;
            }
            0x832336B8 => {
    //   block [0x832336B8..0x832336D0)
	// 832336B8: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 832336BC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 832336C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832336C4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 832336C8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 832336CC: 419A0020  beq cr6, 0x832336ec
	if ctx.cr[6].eq {
	pc = 0x832336EC; continue 'dispatch;
	}
	pc = 0x832336D0; continue 'dispatch;
            }
            0x832336D0 => {
    //   block [0x832336D0..0x832336EC)
	// 832336D0: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 832336D4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832336D8: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 832336DC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 832336E0: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 832336E4: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832336E8: 4082FFE8  bne 0x832336d0
	if !ctx.cr[0].eq {
	pc = 0x832336D0; continue 'dispatch;
	}
	pc = 0x832336EC; continue 'dispatch;
            }
            0x832336EC => {
    //   block [0x832336EC..0x832336FC)
	// 832336EC: 83AB0028  lwz r29, 0x28(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 832336F0: 838B002C  lwz r28, 0x2c(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 832336F4: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 832336F8: 419A00A4  beq cr6, 0x8323379c
	if ctx.cr[6].eq {
	pc = 0x8323379C; continue 'dispatch;
	}
	pc = 0x832336FC; continue 'dispatch;
            }
            0x832336FC => {
    //   block [0x832336FC..0x83233734)
	// 832336FC: 83DD0000  lwz r30, 0(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 83233700: 3BFE00D8  addi r31, r30, 0xd8
	ctx.r[31].s64 = ctx.r[30].s64 + 216;
	// 83233704: 817E00E0  lwz r11, 0xe0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(224 as u32) ) } as u64;
	// 83233708: 815E00DC  lwz r10, 0xdc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(220 as u32) ) } as u64;
	// 8323370C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 83233710: 5528003A  rlwinm r8, r9, 0, 0, 0x1d
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 83233714: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 83233718: 419A0078  beq cr6, 0x83233790
	if ctx.cr[6].eq {
	pc = 0x83233790; continue 'dispatch;
	}
	// 8323371C: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 83233720: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 83233724: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 83233728: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 8323372C: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83233730: 419A0060  beq cr6, 0x83233790
	if ctx.cr[6].eq {
	pc = 0x83233790; continue 'dispatch;
	}
	pc = 0x83233734; continue 'dispatch;
            }
            0x83233734 => {
    //   block [0x83233734..0x83233760)
	// 83233734: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83233738: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8323373C: 409A0040  bne cr6, 0x8323377c
	if !ctx.cr[6].eq {
	pc = 0x8323377C; continue 'dispatch;
	}
	// 83233740: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83233744: 38A30004  addi r5, r3, 4
	ctx.r[5].s64 = ctx.r[3].s64 + 4;
	// 83233748: 7D455850  subf r10, r5, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[5].s64;
	// 8323374C: 7D4B1671  srawi. r11, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 83233750: 40810010  ble 0x83233760
	if !ctx.cr[0].gt {
	pc = 0x83233760; continue 'dispatch;
	}
	// 83233754: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 83233758: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 8323375C: 4BA768CD  bl 0x82caa028
	ctx.lr = 0x83233760;
	sub_82CAA028(ctx, base);
	pc = 0x83233760; continue 'dispatch;
            }
            0x83233760 => {
    //   block [0x83233760..0x8323377C)
	// 83233760: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 83233764: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83233768: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 8323376C: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 83233770: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 83233774: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 83233778: 4800000C  b 0x83233784
	pc = 0x83233784; continue 'dispatch;
            }
            0x8323377C => {
    //   block [0x8323377C..0x83233784)
	// 8323377C: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 83233780: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	pc = 0x83233784; continue 'dispatch;
            }
            0x83233784 => {
    //   block [0x83233784..0x83233790)
	// 83233784: 817E00E0  lwz r11, 0xe0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(224 as u32) ) } as u64;
	// 83233788: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8323378C: 409AFFA8  bne cr6, 0x83233734
	if !ctx.cr[6].eq {
	pc = 0x83233734; continue 'dispatch;
	}
	pc = 0x83233790; continue 'dispatch;
            }
            0x83233790 => {
    //   block [0x83233790..0x8323379C)
	// 83233790: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 83233794: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 83233798: 409AFF64  bne cr6, 0x832336fc
	if !ctx.cr[6].eq {
	pc = 0x832336FC; continue 'dispatch;
	}
	pc = 0x8323379C; continue 'dispatch;
            }
            0x8323379C => {
    //   block [0x8323379C..0x832337B4)
	// 8323379C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 832337A0: 4AF84379  bl 0x821b7b18
	ctx.lr = 0x832337A4;
	sub_821B7B18(ctx, base);
	// 832337A4: 81780010  lwz r11, 0x10(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 832337A8: 3B7B0008  addi r27, r27, 8
	ctx.r[27].s64 = ctx.r[27].s64 + 8;
	// 832337AC: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 832337B0: 409AFF08  bne cr6, 0x832336b8
	if !ctx.cr[6].eq {
	pc = 0x832336B8; continue 'dispatch;
	}
	pc = 0x832337B4; continue 'dispatch;
            }
            0x832337B4 => {
    //   block [0x832337B4..0x832337BC)
	// 832337B4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 832337B8: 4BA75C90  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832337C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832337C0 size=208
    let mut pc: u32 = 0x832337C0;
    'dispatch: loop {
        match pc {
            0x832337C0 => {
    //   block [0x832337C0..0x8323382C)
	// 832337C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832337C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832337C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832337CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832337D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832337D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 832337D8: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 832337DC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 832337E0: 419A0090  beq cr6, 0x83233870
	if ctx.cr[6].eq {
	pc = 0x83233870; continue 'dispatch;
	}
	// 832337E4: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 832337E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832337EC: 409A0084  bne cr6, 0x83233870
	if !ctx.cr[6].eq {
	pc = 0x83233870; continue 'dispatch;
	}
	// 832337F0: 83E90028  lwz r31, 0x28(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(40 as u32) ) } as u64;
	// 832337F4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832337F8: 894B00B0  lbz r10, 0xb0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(176 as u32) ) } as u64;
	// 832337FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83233800: 409A002C  bne cr6, 0x8323382c
	if !ctx.cr[6].eq {
	pc = 0x8323382C; continue 'dispatch;
	}
	// 83233804: 814B00D0  lwz r10, 0xd0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 83233808: 810B00B8  lwz r8, 0xb8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) } as u64;
	// 8323380C: 80EA00B0  lwz r7, 0xb0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(176 as u32) ) } as u64;
	// 83233810: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 83233814: 409A0018  bne cr6, 0x8323382c
	if !ctx.cr[6].eq {
	pc = 0x8323382C; continue 'dispatch;
	}
	// 83233818: 816B00B4  lwz r11, 0xb4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(180 as u32) ) } as u64;
	// 8323381C: 814A00AC  lwz r10, 0xac(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(172 as u32) ) } as u64;
	// 83233820: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 83233824: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 83233828: 419A0008  beq cr6, 0x83233830
	if ctx.cr[6].eq {
	pc = 0x83233830; continue 'dispatch;
	}
	pc = 0x8323382C; continue 'dispatch;
            }
            0x8323382C => {
    //   block [0x8323382C..0x83233830)
	// 8323382C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x83233830; continue 'dispatch;
            }
            0x83233830 => {
    //   block [0x83233830..0x83233848)
	// 83233830: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 83233834: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83233838: 419A0038  beq cr6, 0x83233870
	if ctx.cr[6].eq {
	pc = 0x83233870; continue 'dispatch;
	}
	// 8323383C: 8169002C  lwz r11, 0x2c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(44 as u32) ) } as u64;
	// 83233840: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83233844: 419A002C  beq cr6, 0x83233870
	if ctx.cr[6].eq {
	pc = 0x83233870; continue 'dispatch;
	}
	pc = 0x83233848; continue 'dispatch;
            }
            0x83233848 => {
    //   block [0x83233848..0x83233870)
	// 83233848: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323384C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83233850: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 83233854: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83233858: 4E800421  bctrl
	ctx.lr = 0x8323385C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323385C: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 83233860: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 83233864: 8109002C  lwz r8, 0x2c(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(44 as u32) ) } as u64;
	// 83233868: 7F1F4040  cmplw cr6, r31, r8
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[8].u32, &mut ctx.xer);
	// 8323386C: 409AFFDC  bne cr6, 0x83233848
	if !ctx.cr[6].eq {
	pc = 0x83233848; continue 'dispatch;
	}
            }
            0x83233870 => {
    //   block [0x83233870..0x83233890)
	// 83233870: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 83233874: 4AF842A5  bl 0x821b7b18
	ctx.lr = 0x83233878;
	sub_821B7B18(ctx, base);
	// 83233878: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8323387C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 83233880: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83233884: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 83233888: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8323388C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83233890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83233890 size=148
    let mut pc: u32 = 0x83233890;
    'dispatch: loop {
        match pc {
            0x83233890 => {
    //   block [0x83233890..0x832338DC)
	// 83233890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83233894: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83233898: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8323389C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832338A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832338A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 832338A8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 832338AC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 832338B0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 832338B4: 409A0050  bne cr6, 0x83233904
	if !ctx.cr[6].eq {
	pc = 0x83233904; continue 'dispatch;
	}
	// 832338B8: 994B0011  stb r10, 0x11(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(17 as u32), ctx.r[10].u8 ) };
	// 832338BC: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 832338C0: 811E0000  lwz r8, 0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 832338C4: 8168001C  lwz r11, 0x1c(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(28 as u32) ) } as u64;
	// 832338C8: 83E80028  lwz r31, 0x28(r8)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(40 as u32) ) } as u64;
	// 832338CC: 80E8002C  lwz r7, 0x2c(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(44 as u32) ) } as u64;
	// 832338D0: 7F1F3840  cmplw cr6, r31, r7
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[7].u32, &mut ctx.xer);
	// 832338D4: 91696DD0  stw r11, 0x6dd0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28112 as u32), ctx.r[11].u32 ) };
	// 832338D8: 419A002C  beq cr6, 0x83233904
	if ctx.cr[6].eq {
	pc = 0x83233904; continue 'dispatch;
	}
	pc = 0x832338DC; continue 'dispatch;
            }
            0x832338DC => {
    //   block [0x832338DC..0x83233904)
	// 832338DC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832338E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 832338E4: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 832338E8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832338EC: 4E800421  bctrl
	ctx.lr = 0x832338F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832338F0: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 832338F4: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 832338F8: 8109002C  lwz r8, 0x2c(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(44 as u32) ) } as u64;
	// 832338FC: 7F1F4040  cmplw cr6, r31, r8
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[8].u32, &mut ctx.xer);
	// 83233900: 409AFFDC  bne cr6, 0x832338dc
	if !ctx.cr[6].eq {
	pc = 0x832338DC; continue 'dispatch;
	}
            }
            0x83233904 => {
    //   block [0x83233904..0x83233924)
	// 83233904: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 83233908: 4AF84211  bl 0x821b7b18
	ctx.lr = 0x8323390C;
	sub_821B7B18(ctx, base);
	// 8323390C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 83233910: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 83233914: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83233918: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8323391C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 83233920: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83233928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x83233928 size=596
    let mut pc: u32 = 0x83233928;
    'dispatch: loop {
        match pc {
            0x83233928 => {
    //   block [0x83233928..0x832339A8)
	// 83233928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323392C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83233930: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 83233934: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 83233938: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323393C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83233940: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83233944: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 83233948: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323394C: 4E800421  bctrl
	ctx.lr = 0x83233950;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83233950: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 83233954: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 83233958: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 8323395C: 4198004C  blt cr6, 0x832339a8
	if ctx.cr[6].lt {
	pc = 0x832339A8; continue 'dispatch;
	}
	// 83233960: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 83233964: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 83233968: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 8323396C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83233970: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 83233974: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 83233978: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323397C: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 83233980: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 83233984: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 83233988: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 8323398C: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 83233990: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 83233994: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 83233998: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 8323399C: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 832339A0: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 832339A4: 48000014  b 0x832339b8
	pc = 0x832339B8; continue 'dispatch;
            }
            0x832339A8 => {
    //   block [0x832339A8..0x832339B8)
	// 832339A8: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 832339AC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 832339B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832339B4: 4B7ED535  bl 0x82a20ee8
	ctx.lr = 0x832339B8;
	sub_82A20EE8(ctx, base);
	pc = 0x832339B8; continue 'dispatch;
            }
            0x832339B8 => {
    //   block [0x832339B8..0x832339EC)
	// 832339B8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 832339BC: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 832339C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832339C4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 832339C8: 419A0024  beq cr6, 0x832339ec
	if ctx.cr[6].eq {
	pc = 0x832339EC; continue 'dispatch;
	}
	// 832339CC: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 832339D0: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 832339D4: 89210057  lbz r9, 0x57(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(87 as u32) ) } as u64;
	// 832339D8: 89010054  lbz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 832339DC: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 832339E0: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 832339E4: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 832339E8: 99010053  stb r8, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[8].u8 ) };
	pc = 0x832339EC; continue 'dispatch;
            }
            0x832339EC => {
    //   block [0x832339EC..0x83233A54)
	// 832339EC: 3D60BAAD  lis r11, -0x4553
	ctx.r[11].s64 = -1163067392;
	// 832339F0: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 832339F4: 6169F00D  ori r9, r11, 0xf00d
	ctx.r[9].u64 = ctx.r[11].u64 | 61453;
	// 832339F8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 832339FC: 409A00FC  bne cr6, 0x83233af8
	if !ctx.cr[6].eq {
	pc = 0x83233AF8; continue 'dispatch;
	}
	// 83233A00: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 83233A04: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 83233A08: 4198004C  blt cr6, 0x83233a54
	if ctx.cr[6].lt {
	pc = 0x83233A54; continue 'dispatch;
	}
	// 83233A0C: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 83233A10: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 83233A14: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 83233A18: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83233A1C: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 83233A20: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 83233A24: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83233A28: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 83233A2C: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 83233A30: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 83233A34: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 83233A38: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 83233A3C: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 83233A40: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 83233A44: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 83233A48: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 83233A4C: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 83233A50: 48000014  b 0x83233a64
	pc = 0x83233A64; continue 'dispatch;
            }
            0x83233A54 => {
    //   block [0x83233A54..0x83233A64)
	// 83233A54: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 83233A58: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 83233A5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83233A60: 4B7ED489  bl 0x82a20ee8
	ctx.lr = 0x83233A64;
	sub_82A20EE8(ctx, base);
	pc = 0x83233A64; continue 'dispatch;
            }
            0x83233A64 => {
    //   block [0x83233A64..0x83233A98)
	// 83233A64: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 83233A68: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 83233A6C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83233A70: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 83233A74: 419A0024  beq cr6, 0x83233a98
	if ctx.cr[6].eq {
	pc = 0x83233A98; continue 'dispatch;
	}
	// 83233A78: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 83233A7C: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 83233A80: 8921005B  lbz r9, 0x5b(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(91 as u32) ) } as u64;
	// 83233A84: 89010058  lbz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 83233A88: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 83233A8C: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 83233A90: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 83233A94: 99010053  stb r8, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[8].u8 ) };
	pc = 0x83233A98; continue 'dispatch;
            }
            0x83233A98 => {
    //   block [0x83233A98..0x83233AF8)
	// 83233A98: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 83233A9C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 83233AA0: 419800C4  blt cr6, 0x83233b64
	if ctx.cr[6].lt {
	pc = 0x83233B64; continue 'dispatch;
	}
	// 83233AA4: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 83233AA8: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 83233AAC: 41980068  blt cr6, 0x83233b14
	if ctx.cr[6].lt {
	pc = 0x83233B14; continue 'dispatch;
	}
	// 83233AB0: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 83233AB4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 83233AB8: 3901005C  addi r8, r1, 0x5c
	ctx.r[8].s64 = ctx.r[1].s64 + 92;
	// 83233ABC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83233AC0: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 83233AC4: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 83233AC8: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83233ACC: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 83233AD0: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 83233AD4: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 83233AD8: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 83233ADC: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 83233AE0: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 83233AE4: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 83233AE8: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 83233AEC: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 83233AF0: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 83233AF4: 48000030  b 0x83233b24
	pc = 0x83233B24; continue 'dispatch;
            }
            0x83233AF8 => {
    //   block [0x83233AF8..0x83233B14)
	// 83233AF8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83233AFC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 83233B00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83233B04: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 83233B08: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83233B0C: 4E800421  bctrl
	ctx.lr = 0x83233B10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83233B10: 48000054  b 0x83233b64
	pc = 0x83233B64; continue 'dispatch;
            }
            0x83233B14 => {
    //   block [0x83233B14..0x83233B24)
	// 83233B14: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 83233B18: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 83233B1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83233B20: 4B7ED3C9  bl 0x82a20ee8
	ctx.lr = 0x83233B24;
	sub_82A20EE8(ctx, base);
	pc = 0x83233B24; continue 'dispatch;
            }
            0x83233B24 => {
    //   block [0x83233B24..0x83233B58)
	// 83233B24: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 83233B28: C001005C  lfs f0, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 83233B2C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 83233B30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83233B34: 419A0024  beq cr6, 0x83233b58
	if ctx.cr[6].eq {
	pc = 0x83233B58; continue 'dispatch;
	}
	// 83233B38: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 83233B3C: 89410051  lbz r10, 0x51(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 83233B40: 89210053  lbz r9, 0x53(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(83 as u32) ) } as u64;
	// 83233B44: 89010052  lbz r8, 0x52(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 83233B48: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 83233B4C: 99410052  stb r10, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[10].u8 ) };
	// 83233B50: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 83233B54: 99010051  stb r8, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[8].u8 ) };
	pc = 0x83233B58; continue 'dispatch;
            }
            0x83233B58 => {
    //   block [0x83233B58..0x83233B64)
	// 83233B58: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 83233B5C: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 83233B60: D00B8E18  stfs f0, -0x71e8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-29160 as u32), tmp.u32 ) };
	pc = 0x83233B64; continue 'dispatch;
            }
            0x83233B64 => {
    //   block [0x83233B64..0x83233B7C)
	// 83233B64: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 83233B68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 83233B6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83233B70: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 83233B74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 83233B78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83233B80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x83233B80 size=672
    let mut pc: u32 = 0x83233B80;
    'dispatch: loop {
        match pc {
            0x83233B80 => {
    //   block [0x83233B80..0x83233BE4)
	// 83233B80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83233B84: 4BA75875  bl 0x82ca93f8
	ctx.lr = 0x83233B88;
	sub_82CA93D0(ctx, base);
	// 83233B88: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 83233B8C: 4BA7A14D  bl 0x82cadcd8
	ctx.lr = 0x83233B90;
	sub_82CADCA0(ctx, base);
	// 83233B90: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83233B94: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 83233B98: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 83233B9C: 8159002C  lwz r10, 0x2c(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(44 as u32) ) } as u64;
	// 83233BA0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 83233BA4: 4198026C  blt cr6, 0x83233e10
	if ctx.cr[6].lt {
	pc = 0x83233E10; continue 'dispatch;
	}
	// 83233BA8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 83233BAC: EF9D0772  fmuls f28, f29, f29
	ctx.f[28].f64 = (((ctx.f[29].f64 * ctx.f[29].f64) as f32) as f64);
	// 83233BB0: 1D4A001C  mulli r10, r10, 0x1c
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 28 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 83233BB4: 3B4BE47C  addi r26, r11, -0x1b84
	ctx.r[26].s64 = ctx.r[11].s64 + -7044;
	// 83233BB8: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 83233BBC: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 83233BC0: 3B6B0E68  addi r27, r11, 0xe68
	ctx.r[27].s64 = ctx.r[11].s64 + 3688;
	// 83233BC4: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 83233BC8: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 83233BCC: C3E99484  lfs f31, -0x6b7c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 83233BD0: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	// 83233BD4: 83EA000C  lwz r31, 0xc(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 83233BD8: 810A0010  lwz r8, 0x10(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 83233BDC: 7F1F4040  cmplw cr6, r31, r8
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[8].u32, &mut ctx.xer);
	// 83233BE0: 419A0084  beq cr6, 0x83233c64
	if ctx.cr[6].eq {
	pc = 0x83233C64; continue 'dispatch;
	}
	pc = 0x83233BE4; continue 'dispatch;
            }
            0x83233BE4 => {
    //   block [0x83233BE4..0x83233BFC)
	// 83233BE4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83233BE8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83233BEC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83233BF0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 83233BF4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 83233BF8: 419A0020  beq cr6, 0x83233c18
	if ctx.cr[6].eq {
	pc = 0x83233C18; continue 'dispatch;
	}
	pc = 0x83233BFC; continue 'dispatch;
            }
            0x83233BFC => {
    //   block [0x83233BFC..0x83233C18)
	// 83233BFC: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 83233C00: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 83233C04: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 83233C08: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 83233C0C: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 83233C10: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 83233C14: 4082FFE8  bne 0x83233bfc
	if !ctx.cr[0].eq {
	pc = 0x83233BFC; continue 'dispatch;
	}
	pc = 0x83233C18; continue 'dispatch;
            }
            0x83233C18 => {
    //   block [0x83233C18..0x83233C64)
	// 83233C18: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 83233C1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 83233C20: EDBE0028  fsubs f13, f30, f0
	ctx.f[13].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 83233C24: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 83233C28: 7D600026  mfcr r11
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[11].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 83233C2C: 556ADF7A  rlwinm r10, r11, 0x1b, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 83233C30: 5569F77A  rlwinm r9, r11, 0x1e, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 83233C34: 7D484B78  or r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 83233C38: 7D9B442E  lfsx f12, r27, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 83233C3C: FFCC07AE  fsel f30, f12, f30, f0
	ctx.f[30].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[30].f64 } else { ctx.f[0].f64 };
	// 83233C40: 4AF83ED9  bl 0x821b7b18
	ctx.lr = 0x83233C44;
	sub_821B7B18(ctx, base);
	// 83233C44: 80F9002C  lwz r7, 0x2c(r25)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(44 as u32) ) } as u64;
	// 83233C48: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 83233C4C: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 83233C50: 1D47001C  mulli r10, r7, 0x1c
	ctx.r[10].s32 = ((ctx.r[7].s32 as i64 * 28 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 83233C54: 7CCA5A14  add r6, r10, r11
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 83233C58: 80A60010  lwz r5, 0x10(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) } as u64;
	// 83233C5C: 7F1F2840  cmplw cr6, r31, r5
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[5].u32, &mut ctx.xer);
	// 83233C60: 409AFF84  bne cr6, 0x83233be4
	if !ctx.cr[6].eq {
	pc = 0x83233BE4; continue 'dispatch;
	}
	pc = 0x83233C64; continue 'dispatch;
            }
            0x83233C64 => {
    //   block [0x83233C64..0x83233C9C)
	// 83233C64: 8159002C  lwz r10, 0x2c(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(44 as u32) ) } as u64;
	// 83233C68: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 83233C6C: 1D4A001C  mulli r10, r10, 0x1c
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 28 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 83233C70: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 83233C74: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 83233C78: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 83233C7C: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 83233C80: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 83233C84: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 83233C88: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 83233C8C: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 83233C90: 419A0180  beq cr6, 0x83233e10
	if ctx.cr[6].eq {
	pc = 0x83233E10; continue 'dispatch;
	}
	// 83233C94: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 83233C98: 3F00820A  lis r24, -0x7df6
	ctx.r[24].s64 = -2113273856;
	pc = 0x83233C9C; continue 'dispatch;
            }
            0x83233C9C => {
    //   block [0x83233C9C..0x83233CB4)
	// 83233C9C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 83233CA0: 83BC0000  lwz r29, 0(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 83233CA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83233CA8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 83233CAC: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 83233CB0: 419A0020  beq cr6, 0x83233cd0
	if ctx.cr[6].eq {
	pc = 0x83233CD0; continue 'dispatch;
	}
	pc = 0x83233CB4; continue 'dispatch;
            }
            0x83233CB4 => {
    //   block [0x83233CB4..0x83233CD0)
	// 83233CB4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 83233CB8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 83233CBC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 83233CC0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 83233CC4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 83233CC8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 83233CCC: 4082FFE8  bne 0x83233cb4
	if !ctx.cr[0].eq {
	pc = 0x83233CB4; continue 'dispatch;
	}
	pc = 0x83233CD0; continue 'dispatch;
            }
            0x83233CD0 => {
    //   block [0x83233CD0..0x83233CF0)
	// 83233CD0: C01D0014  lfs f0, 0x14(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 83233CD4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 83233CD8: ED80F028  fsubs f12, f0, f30
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 83233CDC: C1B89054  lfs f13, -0x6fac(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-28588 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 83233CE0: FD606210  fabs f11, f12
	ctx.f[11].u64 = ctx.f[12].u64 & !0x8000_0000_0000_0000u64;
	// 83233CE4: FF0B6800  fcmpu cr6, f11, f13
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[13].f64);
	// 83233CE8: 41980008  blt cr6, 0x83233cf0
	if ctx.cr[6].lt {
	pc = 0x83233CF0; continue 'dispatch;
	}
	// 83233CEC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x83233CF0; continue 'dispatch;
            }
            0x83233CF0 => {
    //   block [0x83233CF0..0x83233D04)
	// 83233CF0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 83233CF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83233CF8: 409A000C  bne cr6, 0x83233d04
	if !ctx.cr[6].eq {
	pc = 0x83233D04; continue 'dispatch;
	}
	// 83233CFC: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 83233D00: 409900E8  ble cr6, 0x83233de8
	if !ctx.cr[6].gt {
	pc = 0x83233DE8; continue 'dispatch;
	}
	pc = 0x83233D04; continue 'dispatch;
            }
            0x83233D04 => {
    //   block [0x83233D04..0x83233D18)
	// 83233D04: D39D0014  stfs f28, 0x14(r29)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 83233D08: 83FD0028  lwz r31, 0x28(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 83233D0C: 817D002C  lwz r11, 0x2c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 83233D10: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83233D14: 419A00D4  beq cr6, 0x83233de8
	if ctx.cr[6].eq {
	pc = 0x83233DE8; continue 'dispatch;
	}
	pc = 0x83233D18; continue 'dispatch;
            }
            0x83233D18 => {
    //   block [0x83233D18..0x83233D58)
	// 83233D18: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83233D1C: 807E00D0  lwz r3, 0xd0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(208 as u32) ) } as u64;
	// 83233D20: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83233D24: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 83233D28: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83233D2C: 4E800421  bctrl
	ctx.lr = 0x83233D30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83233D30: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 83233D34: 419A0024  beq cr6, 0x83233d58
	if ctx.cr[6].eq {
	pc = 0x83233D58; continue 'dispatch;
	}
	// 83233D38: 807E00D0  lwz r3, 0xd0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(208 as u32) ) } as u64;
	// 83233D3C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83233D40: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 83233D44: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83233D48: 4E800421  bctrl
	ctx.lr = 0x83233D4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83233D4C: 2F030009  cmpwi cr6, r3, 9
	ctx.cr[6].compare_i32(ctx.r[3].s32, 9, &mut ctx.xer);
	// 83233D50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 83233D54: 409A0008  bne cr6, 0x83233d5c
	if !ctx.cr[6].eq {
	pc = 0x83233D5C; continue 'dispatch;
	}
            }
            0x83233D58 => {
    //   block [0x83233D58..0x83233D5C)
	// 83233D58: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x83233D5C; continue 'dispatch;
            }
            0x83233D5C => {
    //   block [0x83233D5C..0x83233DD8)
	// 83233D5C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 83233D60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83233D64: 419A0074  beq cr6, 0x83233dd8
	if ctx.cr[6].eq {
	pc = 0x83233DD8; continue 'dispatch;
	}
	// 83233D68: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83233D6C: 396B0150  addi r11, r11, 0x150
	ctx.r[11].s64 = ctx.r[11].s64 + 336;
	// 83233D70: C00B0040  lfs f0, 0x40(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 83233D74: C1AB0044  lfs f13, 0x44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 83233D78: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 83233D7C: C16B003C  lfs f11, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 83233D80: C14B0038  lfs f10, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 83233D84: D3AB0044  stfs f29, 0x44(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 83233D88: ED206028  fsubs f9, f0, f12
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 83233D8C: D12B0040  stfs f9, 0x40(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 83233D90: ED0B4828  fsubs f8, f11, f9
	ctx.f[8].f64 = (((ctx.f[11].f64 - ctx.f[9].f64) as f32) as f64);
	// 83233D94: FF08F800  fcmpu cr6, f8, f31
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[31].f64);
	// 83233D98: 7D400026  mfcr r10
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[10].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 83233D9C: 5549DF7A  rlwinm r9, r10, 0x1b, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 83233DA0: 5548F77A  rlwinm r8, r10, 0x1e, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 83233DA4: 7D274378  or r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 83233DA8: 7CFB3C2E  lfsx f7, r27, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 83233DAC: FCC75A6E  fsel f6, f7, f9, f11
	ctx.f[6].f64 = if ctx.f[7].f64 >= 0.0 { ctx.f[9].f64 } else { ctx.f[11].f64 };
	// 83233DB0: D0CB003C  stfs f6, 0x3c(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 83233DB4: ECAA3028  fsubs f5, f10, f6
	ctx.f[5].f64 = (((ctx.f[10].f64 - ctx.f[6].f64) as f32) as f64);
	// 83233DB8: FF05F800  fcmpu cr6, f5, f31
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[31].f64);
	// 83233DBC: 7CC00026  mfcr r6
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[6].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[6].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 83233DC0: 54C5DF7A  rlwinm r5, r6, 0x1b, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[6].u32 as u64 & 0x0000001Fu64;
	// 83233DC4: 54C4F77A  rlwinm r4, r6, 0x1e, 0x1d, 0x1d
	ctx.r[4].u64 = ctx.r[6].u32 as u64 & 0x00000003u64;
	// 83233DC8: 7CA32378  or r3, r5, r4
	ctx.r[3].u64 = ctx.r[5].u64 | ctx.r[4].u64;
	// 83233DCC: 7C9B1C2E  lfsx f4, r27, r3
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[3].u32)) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 83233DD0: FC6451AE  fsel f3, f4, f6, f10
	ctx.f[3].f64 = if ctx.f[4].f64 >= 0.0 { ctx.f[6].f64 } else { ctx.f[10].f64 };
	// 83233DD4: D06B0038  stfs f3, 0x38(r11)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), tmp.u32 ) };
	pc = 0x83233DD8; continue 'dispatch;
            }
            0x83233DD8 => {
    //   block [0x83233DD8..0x83233DE8)
	// 83233DD8: 817D002C  lwz r11, 0x2c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 83233DDC: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 83233DE0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83233DE4: 409AFF34  bne cr6, 0x83233d18
	if !ctx.cr[6].eq {
	pc = 0x83233D18; continue 'dispatch;
	}
	pc = 0x83233DE8; continue 'dispatch;
            }
            0x83233DE8 => {
    //   block [0x83233DE8..0x83233E10)
	// 83233DE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 83233DEC: 4AF83D2D  bl 0x821b7b18
	ctx.lr = 0x83233DF0;
	sub_821B7B18(ctx, base);
	// 83233DF0: 8159002C  lwz r10, 0x2c(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(44 as u32) ) } as u64;
	// 83233DF4: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 83233DF8: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 83233DFC: 1D4A001C  mulli r10, r10, 0x1c
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 28 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 83233E00: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 83233E04: 81090010  lwz r8, 0x10(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 83233E08: 7F1C4040  cmplw cr6, r28, r8
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[8].u32, &mut ctx.xer);
	// 83233E0C: 409AFE90  bne cr6, 0x83233c9c
	if !ctx.cr[6].eq {
	pc = 0x83233C9C; continue 'dispatch;
	}
	pc = 0x83233E10; continue 'dispatch;
            }
            0x83233E10 => {
    //   block [0x83233E10..0x83233E20)
	// 83233E10: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 83233E14: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 83233E18: 4BA79F0D  bl 0x82cadd24
	ctx.lr = 0x83233E1C;
	sub_82CADCEC(ctx, base);
	// 83233E1C: 4BA7562C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83233E20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83233E20 size=200
    let mut pc: u32 = 0x83233E20;
    'dispatch: loop {
        match pc {
            0x83233E20 => {
    //   block [0x83233E20..0x83233E58)
	// 83233E20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83233E24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83233E28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 83233E2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 83233E30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83233E34: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 83233E38: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 83233E3C: 3BEBE49C  addi r31, r11, -0x1b64
	ctx.r[31].s64 = ctx.r[11].s64 + -7012;
	// 83233E40: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 83233E44: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83233E48: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83233E4C: 7F1E2040  cmplw cr6, r30, r4
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[4].u32, &mut ctx.xer);
	// 83233E50: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 83233E54: 419A007C  beq cr6, 0x83233ed0
	if ctx.cr[6].eq {
	pc = 0x83233ED0; continue 'dispatch;
	}
	pc = 0x83233E58; continue 'dispatch;
            }
            0x83233E58 => {
    //   block [0x83233E58..0x83233E88)
	// 83233E58: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 83233E5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83233E60: 419A0034  beq cr6, 0x83233e94
	if ctx.cr[6].eq {
	pc = 0x83233E94; continue 'dispatch;
	}
	// 83233E64: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83233E68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83233E6C: 419A001C  beq cr6, 0x83233e88
	if ctx.cr[6].eq {
	pc = 0x83233E88; continue 'dispatch;
	}
	// 83233E70: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 83233E74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83233E78: 419A001C  beq cr6, 0x83233e94
	if ctx.cr[6].eq {
	pc = 0x83233E94; continue 'dispatch;
	}
	// 83233E7C: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 83233E80: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 83233E84: 48000044  b 0x83233ec8
	pc = 0x83233EC8; continue 'dispatch;
            }
            0x83233E88 => {
    //   block [0x83233E88..0x83233E94)
	// 83233E88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 83233E8C: 4AF5FFAD  bl 0x82193e38
	ctx.lr = 0x83233E90;
	sub_82193E38(ctx, base);
	// 83233E90: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x83233E94; continue 'dispatch;
            }
            0x83233E94 => {
    //   block [0x83233E94..0x83233EC8)
	// 83233E94: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 83233E98: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 83233E9C: 4B7CFBFD  bl 0x82a03a98
	ctx.lr = 0x83233EA0;
	sub_82A03A98(ctx, base);
	// 83233EA0: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83233EA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83233EA8: 3885FFF8  addi r4, r5, -8
	ctx.r[4].s64 = ctx.r[5].s64 + -8;
	// 83233EAC: 4B85E055  bl 0x82a91f00
	ctx.lr = 0x83233EB0;
	sub_82A91F00(ctx, base);
	// 83233EB0: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 83233EB4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83233EB8: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 83233EBC: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 83233EC0: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 83233EC4: 909F0008  stw r4, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	pc = 0x83233EC8; continue 'dispatch;
            }
            0x83233EC8 => {
    //   block [0x83233EC8..0x83233ED0)
	// 83233EC8: 7F1E2040  cmplw cr6, r30, r4
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[4].u32, &mut ctx.xer);
	// 83233ECC: 409AFF8C  bne cr6, 0x83233e58
	if !ctx.cr[6].eq {
	pc = 0x83233E58; continue 'dispatch;
	}
	pc = 0x83233ED0; continue 'dispatch;
            }
            0x83233ED0 => {
    //   block [0x83233ED0..0x83233EE8)
	// 83233ED0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 83233ED4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 83233ED8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83233EDC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 83233EE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 83233EE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83233EF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83233EF0 size=552
    let mut pc: u32 = 0x83233EF0;
    'dispatch: loop {
        match pc {
            0x83233EF0 => {
    //   block [0x83233EF0..0x83234118)
	// 83233EF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83233EF4: 4BA754FD  bl 0x82ca93f0
	ctx.lr = 0x83233EF8;
	sub_82CA93D0(ctx, base);
	// 83233EF8: 3980FF80  li r12, -0x80
	ctx.r[12].s64 = -128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83234118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83234118 size=216
    let mut pc: u32 = 0x83234118;
    'dispatch: loop {
        match pc {
            0x83234118 => {
    //   block [0x83234118..0x83234178)
	// 83234118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323411C: 4BA752F1  bl 0x82ca940c
	ctx.lr = 0x83234120;
	sub_82CA93D0(ctx, base);
	// 83234120: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83234124: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 83234128: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8323412C: 3BEBE49C  addi r31, r11, -0x1b64
	ctx.r[31].s64 = ctx.r[11].s64 + -7012;
	// 83234130: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83234134: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83234138: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8323413C: 7D6A1E70  srawi r10, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 83234140: 2B0A0008  cmplwi cr6, r10, 8
	ctx.cr[6].compare_u32(ctx.r[10].u32, 8 as u32, &mut ctx.xer);
	// 83234144: 409800A4  bge cr6, 0x832341e8
	if !ctx.cr[6].lt {
	pc = 0x832341E8; continue 'dispatch;
	}
	// 83234148: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8323414C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 83234150: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 83234154: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 83234158: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8323415C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 83234160: 4AFE0739  bl 0x82214898
	ctx.lr = 0x83234164;
	sub_82214898(ctx, base);
	// 83234164: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83234168: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323416C: 409A000C  bne cr6, 0x83234178
	if !ctx.cr[6].eq {
	pc = 0x83234178; continue 'dispatch;
	}
	// 83234170: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 83234174: 48000010  b 0x83234184
	pc = 0x83234184; continue 'dispatch;
            }
            0x83234178 => {
    //   block [0x83234178..0x83234184)
	// 83234178: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323417C: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 83234180: 7D4A1E70  srawi r10, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 3) as i64;
	pc = 0x83234184; continue 'dispatch;
            }
            0x83234184 => {
    //   block [0x83234184..0x832341AC)
	// 83234184: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83234188: 7D6BF050  subf r11, r11, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 8323418C: 7D691E70  srawi r9, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 83234190: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 83234194: 40980024  bge cr6, 0x832341b8
	if !ctx.cr[6].lt {
	pc = 0x832341B8; continue 'dispatch;
	}
	// 83234198: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8323419C: 419A0010  beq cr6, 0x832341ac
	if ctx.cr[6].eq {
	pc = 0x832341AC; continue 'dispatch;
	}
	// 832341A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 832341A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832341A8: 4AF62BC9  bl 0x82196d70
	ctx.lr = 0x832341AC;
	sub_82196D70(ctx, base);
	pc = 0x832341AC; continue 'dispatch;
            }
            0x832341AC => {
    //   block [0x832341AC..0x832341B8)
	// 832341AC: 397E0008  addi r11, r30, 8
	ctx.r[11].s64 = ctx.r[30].s64 + 8;
	// 832341B0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 832341B4: 48000020  b 0x832341d4
	pc = 0x832341D4; continue 'dispatch;
            }
            0x832341B8 => {
    //   block [0x832341B8..0x832341D4)
	// 832341B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832341BC: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 832341C0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 832341C4: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 832341C8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 832341CC: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 832341D0: 4B7CE8F9  bl 0x82a02ac8
	ctx.lr = 0x832341D4;
	sub_82A02AC8(ctx, base);
	pc = 0x832341D4; continue 'dispatch;
            }
            0x832341D4 => {
    //   block [0x832341D4..0x832341E8)
	// 832341D4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 832341D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 832341DC: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 832341E0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 832341E4: 4AF5FC55  bl 0x82193e38
	ctx.lr = 0x832341E8;
	sub_82193E38(ctx, base);
	pc = 0x832341E8; continue 'dispatch;
            }
            0x832341E8 => {
    //   block [0x832341E8..0x832341F0)
	// 832341E8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 832341EC: 4BA75270  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83234200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83234200 size=172
    let mut pc: u32 = 0x83234200;
    'dispatch: loop {
        match pc {
            0x83234200 => {
    //   block [0x83234200..0x83234248)
	// 83234200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83234204: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83234208: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8323420C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 83234210: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83234214: 906100F4  stw r3, 0xf4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), ctx.r[3].u32 ) };
	// 83234218: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8323421C: 38A100F4  addi r5, r1, 0xf4
	ctx.r[5].s64 = ctx.r[1].s64 + 244;
	// 83234220: 3BEBE4F0  addi r31, r11, -0x1b10
	ctx.r[31].s64 = ctx.r[11].s64 + -6928;
	// 83234224: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 83234228: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8323422C: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83234230: 4B02D479  bl 0x822616a8
	ctx.lr = 0x83234234;
	sub_822616A8(ctx, base);
	// 83234234: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83234238: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323423C: 419A000C  beq cr6, 0x83234248
	if ctx.cr[6].eq {
	pc = 0x83234248; continue 'dispatch;
	}
	// 83234240: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 83234244: 419A0008  beq cr6, 0x8323424c
	if ctx.cr[6].eq {
	pc = 0x8323424C; continue 'dispatch;
	}
	pc = 0x83234248; continue 'dispatch;
            }
            0x83234248 => {
    //   block [0x83234248..0x8323424C)
	// 83234248: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8323424C; continue 'dispatch;
            }
            0x8323424C => {
    //   block [0x8323424C..0x83234280)
	// 8323424C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 83234250: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 83234254: 409A0040  bne cr6, 0x83234294
	if !ctx.cr[6].eq {
	pc = 0x83234294; continue 'dispatch;
	}
	// 83234258: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323425C: 388100F4  addi r4, r1, 0xf4
	ctx.r[4].s64 = ctx.r[1].s64 + 244;
	// 83234260: 4B02D339  bl 0x82261598
	ctx.lr = 0x83234264;
	sub_82261598(ctx, base);
	// 83234264: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83234268: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323426C: 4BFFD6DD  bl 0x83231948
	ctx.lr = 0x83234270;
	sub_83231948(ctx, base);
	// 83234270: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 83234274: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 83234278: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 8323427C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x83234280; continue 'dispatch;
            }
            0x83234280 => {
    //   block [0x83234280..0x83234294)
	// 83234280: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 83234284: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 83234288: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 8323428C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 83234290: 4200FFF0  bdnz 0x83234280
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x83234280; continue 'dispatch;
	}
	pc = 0x83234294; continue 'dispatch;
            }
            0x83234294 => {
    //   block [0x83234294..0x832342AC)
	// 83234294: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 83234298: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8323429C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832342A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832342A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832342A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832342B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832342B0 size=132
    let mut pc: u32 = 0x832342B0;
    'dispatch: loop {
        match pc {
            0x832342B0 => {
    //   block [0x832342B0..0x832342F8)
	// 832342B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832342B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832342B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832342BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832342C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832342C4: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 832342C8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832342CC: 38A10084  addi r5, r1, 0x84
	ctx.r[5].s64 = ctx.r[1].s64 + 132;
	// 832342D0: 3BEBE4F0  addi r31, r11, -0x1b10
	ctx.r[31].s64 = ctx.r[11].s64 + -6928;
	// 832342D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 832342D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 832342DC: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832342E0: 4B02D3C9  bl 0x822616a8
	ctx.lr = 0x832342E4;
	sub_822616A8(ctx, base);
	// 832342E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 832342E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832342EC: 419A000C  beq cr6, 0x832342f8
	if ctx.cr[6].eq {
	pc = 0x832342F8; continue 'dispatch;
	}
	// 832342F0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 832342F4: 419A0008  beq cr6, 0x832342fc
	if ctx.cr[6].eq {
	pc = 0x832342FC; continue 'dispatch;
	}
	pc = 0x832342F8; continue 'dispatch;
            }
            0x832342F8 => {
    //   block [0x832342F8..0x832342FC)
	// 832342F8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x832342FC; continue 'dispatch;
            }
            0x832342FC => {
    //   block [0x832342FC..0x83234310)
	// 832342FC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 83234300: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 83234304: 409A000C  bne cr6, 0x83234310
	if !ctx.cr[6].eq {
	pc = 0x83234310; continue 'dispatch;
	}
	// 83234308: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8323430C: 48000010  b 0x8323431c
	pc = 0x8323431C; continue 'dispatch;
            }
            0x83234310 => {
    //   block [0x83234310..0x8323431C)
	// 83234310: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83234314: 38810084  addi r4, r1, 0x84
	ctx.r[4].s64 = ctx.r[1].s64 + 132;
	// 83234318: 4B02D281  bl 0x82261598
	ctx.lr = 0x8323431C;
	sub_82261598(ctx, base);
	pc = 0x8323431C; continue 'dispatch;
            }
            0x8323431C => {
    //   block [0x8323431C..0x83234334)
	// 8323431C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 83234320: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 83234324: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83234328: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8323432C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 83234330: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83234338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83234338 size=1236
    let mut pc: u32 = 0x83234338;
    'dispatch: loop {
        match pc {
            0x83234338 => {
    //   block [0x83234338..0x8323438C)
	// 83234338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323433C: 4BA7509D  bl 0x82ca93d8
	ctx.lr = 0x83234340;
	sub_82CA93D0(ctx, base);
	// 83234340: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83234344: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 83234348: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 8323434C: 7C711B78  mr r17, r3
	ctx.r[17].u64 = ctx.r[3].u64;
	// 83234350: 3AEB1AA0  addi r23, r11, 0x1aa0
	ctx.r[23].s64 = ctx.r[11].s64 + 6816;
	// 83234354: 7C902378  mr r16, r4
	ctx.r[16].u64 = ctx.r[4].u64;
	// 83234358: 816A3A20  lwz r11, 0x3a20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(14880 as u32) ) } as u64;
	// 8323435C: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 83234360: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 83234364: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 83234368: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8323436C: 409A0074  bne cr6, 0x832343e0
	if !ctx.cr[6].eq {
	pc = 0x832343E0; continue 'dispatch;
	}
	// 83234370: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 83234374: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 83234378: 916A3A20  stw r11, 0x3a20(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(14880 as u32), ctx.r[11].u32 ) };
	// 8323437C: 4AFEAEDD  bl 0x8221f258
	ctx.lr = 0x83234380;
	sub_8221F258(ctx, base);
	// 83234380: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 83234384: 419A0008  beq cr6, 0x8323438c
	if ctx.cr[6].eq {
	pc = 0x8323438C; continue 'dispatch;
	}
	// 83234388: 92C30000  stw r22, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[22].u32 ) };
	pc = 0x8323438C; continue 'dispatch;
            }
            0x8323438C => {
    //   block [0x8323438C..0x83234398)
	// 8323438C: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 83234390: 41820008  beq 0x83234398
	if ctx.cr[0].eq {
	pc = 0x83234398; continue 'dispatch;
	}
	// 83234394: 92CB0000  stw r22, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[22].u32 ) };
	pc = 0x83234398; continue 'dispatch;
            }
            0x83234398 => {
    //   block [0x83234398..0x832343A4)
	// 83234398: 35630008  addic. r11, r3, 8
	ctx.xer.ca = (ctx.r[3].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8323439C: 41820008  beq 0x832343a4
	if ctx.cr[0].eq {
	pc = 0x832343A4; continue 'dispatch;
	}
	// 832343A0: 92CB0000  stw r22, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[22].u32 ) };
	pc = 0x832343A4; continue 'dispatch;
            }
            0x832343A4 => {
    //   block [0x832343A4..0x832343E0)
	// 832343A4: 9B230010  stb r25, 0x10(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[25].u8 ) };
	// 832343A8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 832343AC: 9AC30011  stb r22, 0x11(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(17 as u32), ctx.r[22].u8 ) };
	// 832343B0: 7ECAB378  mr r10, r22
	ctx.r[10].u64 = ctx.r[22].u64;
	// 832343B4: 90770004  stw r3, 4(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 832343B8: 9B230011  stb r25, 0x11(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(17 as u32), ctx.r[25].u8 ) };
	// 832343BC: 386B1528  addi r3, r11, 0x1528
	ctx.r[3].s64 = ctx.r[11].s64 + 5416;
	// 832343C0: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 832343C4: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832343C8: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 832343CC: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 832343D0: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 832343D4: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 832343D8: 91570008  stw r10, 8(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 832343DC: 4BA75B45  bl 0x82ca9f20
	ctx.lr = 0x832343E0;
	sub_82CA9F20(ctx, base);
	pc = 0x832343E0; continue 'dispatch;
            }
            0x832343E0 => {
    //   block [0x832343E0..0x83234418)
	// 832343E0: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 832343E4: 4B7CDE25  bl 0x82a02208
	ctx.lr = 0x832343E8;
	sub_82A02208(ctx, base);
	// 832343E8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832343EC: 3940001C  li r10, 0x1c
	ctx.r[10].s64 = 28;
	// 832343F0: 3AABE47C  addi r21, r11, -0x1b84
	ctx.r[21].s64 = ctx.r[11].s64 + -7044;
	// 832343F4: 3E408349  lis r18, -0x7cb7
	ctx.r[18].s64 = -2092367872;
	// 832343F8: 7ED4B378  mr r20, r22
	ctx.r[20].u64 = ctx.r[22].u64;
	// 832343FC: 7EDAB378  mr r26, r22
	ctx.r[26].u64 = ctx.r[22].u64;
	// 83234400: 81350004  lwz r9, 4(r21)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 83234404: 81150008  lwz r8, 8(r21)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 83234408: 7CE94050  subf r7, r9, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 8323440C: 7E6753D7  divw. r19, r7, r10
	ctx.r[19].s32 = ctx.r[7].s32 / ctx.r[10].s32;
	ctx.cr[0].compare_i32(ctx.r[19].s32, 0, &mut ctx.xer);
	// 83234410: 4081019C  ble 0x832345ac
	if !ctx.cr[0].gt {
	pc = 0x832345AC; continue 'dispatch;
	}
	// 83234414: 7EDBB378  mr r27, r22
	ctx.r[27].u64 = ctx.r[22].u64;
	pc = 0x83234418; continue 'dispatch;
            }
            0x83234418 => {
    //   block [0x83234418..0x8323444C)
	// 83234418: 81750004  lwz r11, 4(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323441C: 7F9B5A14  add r28, r27, r11
	ctx.r[28].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 83234420: 7D7B582E  lwzx r11, r27, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 83234424: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 83234428: 7F0B8800  cmpw cr6, r11, r17
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[17].s32, &mut ctx.xer);
	// 8323442C: 41980170  blt cr6, 0x8323459c
	if ctx.cr[6].lt {
	pc = 0x8323459C; continue 'dispatch;
	}
	// 83234430: 83BC000C  lwz r29, 0xc(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 83234434: 815C0010  lwz r10, 0x10(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 83234438: 91726DD4  stw r11, 0x6dd4(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(28116 as u32), ctx.r[11].u32 ) };
	// 8323443C: 92C10058  stw r22, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[22].u32 ) };
	// 83234440: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 83234444: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 83234448: 419A0150  beq cr6, 0x83234598
	if ctx.cr[6].eq {
	pc = 0x83234598; continue 'dispatch;
	}
	pc = 0x8323444C; continue 'dispatch;
            }
            0x8323444C => {
    //   block [0x8323444C..0x83234484)
	// 8323444C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 83234450: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 83234454: 83EA0000  lwz r31, 0(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 83234458: 893F00C8  lbz r9, 0xc8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 8323445C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83234460: 409A0024  bne cr6, 0x83234484
	if !ctx.cr[6].eq {
	pc = 0x83234484; continue 'dispatch;
	}
	// 83234464: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83234468: 4BFF5561  bl 0x832299c8
	ctx.lr = 0x8323446C;
	sub_832299C8(ctx, base);
	// 8323446C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 83234470: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83234474: 409A0010  bne cr6, 0x83234484
	if !ctx.cr[6].eq {
	pc = 0x83234484; continue 'dispatch;
	}
	// 83234478: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 8323447C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 83234480: 4800010C  b 0x8323458c
	pc = 0x8323458C; continue 'dispatch;
            }
            0x83234484 => {
    //   block [0x83234484..0x83234498)
	// 83234484: 817C0018  lwz r11, 0x18(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 83234488: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8323448C: 917C0018  stw r11, 0x18(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 83234490: 40820008  bne 0x83234498
	if !ctx.cr[0].eq {
	pc = 0x83234498; continue 'dispatch;
	}
	// 83234494: 7F34CB78  mr r20, r25
	ctx.r[20].u64 = ctx.r[25].u64;
	pc = 0x83234498; continue 'dispatch;
            }
            0x83234498 => {
    //   block [0x83234498..0x8323449C)
	// 83234498: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	pc = 0x8323449C; continue 'dispatch;
            }
            0x8323449C => {
    //   block [0x8323449C..0x832344D4)
	// 8323449C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 832344A0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 832344A4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 832344A8: 4AF4BBE1  bl 0x82180088
	ctx.lr = 0x832344AC;
	sub_82180088(ctx, base);
	// 832344AC: 807F00D0  lwz r3, 0xd0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 832344B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 832344B4: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 832344B8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832344BC: 4E800421  bctrl
	ctx.lr = 0x832344C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832344C0: 2F030004  cmpwi cr6, r3, 4
	ctx.cr[6].compare_i32(ctx.r[3].s32, 4, &mut ctx.xer);
	// 832344C4: 409A0010  bne cr6, 0x832344d4
	if !ctx.cr[6].eq {
	pc = 0x832344D4; continue 'dispatch;
	}
	// 832344C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 832344CC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 832344D0: 4BFFF1C1  bl 0x83233690
	ctx.lr = 0x832344D4;
	sub_83233690(ctx, base);
            }
            0x832344D4 => {
    //   block [0x832344D4..0x832344F8)
	// 832344D4: 3BFF00F4  addi r31, r31, 0xf4
	ctx.r[31].s64 = ctx.r[31].s64 + 244;
	// 832344D8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832344DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832344E0: 419A0048  beq cr6, 0x83234528
	if ctx.cr[6].eq {
	pc = 0x83234528; continue 'dispatch;
	}
	// 832344E4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 832344E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832344EC: 419A000C  beq cr6, 0x832344f8
	if ctx.cr[6].eq {
	pc = 0x832344F8; continue 'dispatch;
	}
	// 832344F0: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832344F4: 48000038  b 0x8323452c
	pc = 0x8323452C; continue 'dispatch;
            }
            0x832344F8 => {
    //   block [0x832344F8..0x83234524)
	// 832344F8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 832344FC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 83234500: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 83234504: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83234508: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323450C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83234510: 409A0014  bne cr6, 0x83234524
	if !ctx.cr[6].eq {
	pc = 0x83234524; continue 'dispatch;
	}
	// 83234514: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83234518: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323451C: 409A0008  bne cr6, 0x83234524
	if !ctx.cr[6].eq {
	pc = 0x83234524; continue 'dispatch;
	}
	// 83234520: 4AFE7819  bl 0x8221bd38
	ctx.lr = 0x83234524;
	sub_8221BD38(ctx, base);
	pc = 0x83234524; continue 'dispatch;
            }
            0x83234524 => {
    //   block [0x83234524..0x83234528)
	// 83234524: 92DF0004  stw r22, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[22].u32 ) };
	pc = 0x83234528; continue 'dispatch;
            }
            0x83234528 => {
    //   block [0x83234528..0x8323452C)
	// 83234528: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x8323452C; continue 'dispatch;
            }
            0x8323452C => {
    //   block [0x8323452C..0x83234560)
	// 8323452C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 83234530: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83234534: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 83234538: 409AFF64  bne cr6, 0x8323449c
	if !ctx.cr[6].eq {
	pc = 0x8323449C; continue 'dispatch;
	}
	// 8323453C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 83234540: 809C0010  lwz r4, 0x10(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 83234544: 387D0008  addi r3, r29, 8
	ctx.r[3].s64 = ctx.r[29].s64 + 8;
	// 83234548: 3BDC0008  addi r30, r28, 8
	ctx.r[30].s64 = ctx.r[28].s64 + 8;
	// 8323454C: 4B93652D  bl 0x82b6aa78
	ctx.lr = 0x83234550;
	sub_82B6AA78(ctx, base);
	// 83234550: 83BC0010  lwz r29, 0x10(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 83234554: 3BFDFFF8  addi r31, r29, -8
	ctx.r[31].s64 = ctx.r[29].s64 + -8;
	// 83234558: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8323455C: 419A0018  beq cr6, 0x83234574
	if ctx.cr[6].eq {
	pc = 0x83234574; continue 'dispatch;
	}
	pc = 0x83234560; continue 'dispatch;
            }
            0x83234560 => {
    //   block [0x83234560..0x83234574)
	// 83234560: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83234564: 4AF835B5  bl 0x821b7b18
	ctx.lr = 0x83234568;
	sub_821B7B18(ctx, base);
	// 83234568: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 8323456C: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 83234570: 409AFFF0  bne cr6, 0x83234560
	if !ctx.cr[6].eq {
	pc = 0x83234560; continue 'dispatch;
	}
	pc = 0x83234574; continue 'dispatch;
            }
            0x83234574 => {
    //   block [0x83234574..0x8323458C)
	// 83234574: E9410058  ld r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 83234578: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323457C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 83234580: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 83234584: 913E0008  stw r9, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 83234588: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	pc = 0x8323458C; continue 'dispatch;
            }
            0x8323458C => {
    //   block [0x8323458C..0x83234598)
	// 8323458C: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 83234590: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83234594: 409AFEB8  bne cr6, 0x8323444c
	if !ctx.cr[6].eq {
	pc = 0x8323444C; continue 'dispatch;
	}
	pc = 0x83234598; continue 'dispatch;
            }
            0x83234598 => {
    //   block [0x83234598..0x8323459C)
	// 83234598: 92326DD4  stw r17, 0x6dd4(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(28116 as u32), ctx.r[17].u32 ) };
	pc = 0x8323459C; continue 'dispatch;
            }
            0x8323459C => {
    //   block [0x8323459C..0x832345AC)
	// 8323459C: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 832345A0: 3B7B001C  addi r27, r27, 0x1c
	ctx.r[27].s64 = ctx.r[27].s64 + 28;
	// 832345A4: 7F1A9800  cmpw cr6, r26, r19
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[19].s32, &mut ctx.xer);
	// 832345A8: 4198FE70  blt cr6, 0x83234418
	if ctx.cr[6].lt {
	pc = 0x83234418; continue 'dispatch;
	}
	pc = 0x832345AC; continue 'dispatch;
            }
            0x832345AC => {
    //   block [0x832345AC..0x832345D4)
	// 832345AC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832345B0: 7ED8B378  mr r24, r22
	ctx.r[24].u64 = ctx.r[22].u64;
	// 832345B4: 3B6BE48C  addi r27, r11, -0x1b74
	ctx.r[27].s64 = ctx.r[11].s64 + -7028;
	// 832345B8: 80FB0004  lwz r7, 4(r27)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 832345BC: 80DB0008  lwz r6, 8(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 832345C0: 7D673050  subf r11, r7, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[7].s64;
	// 832345C4: 7D7A1E71  srawi. r26, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[26].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 832345C8: 40810134  ble 0x832346fc
	if !ctx.cr[0].gt {
	pc = 0x832346FC; continue 'dispatch;
	}
	// 832345CC: 81370004  lwz r9, 4(r23)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 832345D0: 7ED9B378  mr r25, r22
	ctx.r[25].u64 = ctx.r[22].u64;
	pc = 0x832345D4; continue 'dispatch;
            }
            0x832345D4 => {
    //   block [0x832345D4..0x832345FC)
	// 832345D4: 81770008  lwz r11, 8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 832345D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832345DC: 419A0120  beq cr6, 0x832346fc
	if ctx.cr[6].eq {
	pc = 0x832346FC; continue 'dispatch;
	}
	// 832345E0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 832345E4: 7F993A14  add r28, r25, r7
	ctx.r[28].u64 = ctx.r[25].u64 + ctx.r[7].u64;
	// 832345E8: 7D19382E  lwzx r8, r25, r7
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 832345EC: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 832345F0: 88AB0011  lbz r5, 0x11(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 832345F4: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 832345F8: 409A002C  bne cr6, 0x83234624
	if !ctx.cr[6].eq {
	pc = 0x83234624; continue 'dispatch;
	}
	pc = 0x832345FC; continue 'dispatch;
            }
            0x832345FC => {
    //   block [0x832345FC..0x83234610)
	// 832345FC: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 83234600: 7F054040  cmplw cr6, r5, r8
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[8].u32, &mut ctx.xer);
	// 83234604: 4098000C  bge cr6, 0x83234610
	if !ctx.cr[6].lt {
	pc = 0x83234610; continue 'dispatch;
	}
	// 83234608: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323460C: 4800000C  b 0x83234618
	pc = 0x83234618; continue 'dispatch;
            }
            0x83234610 => {
    //   block [0x83234610..0x83234618)
	// 83234610: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 83234614: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x83234618; continue 'dispatch;
            }
            0x83234618 => {
    //   block [0x83234618..0x83234624)
	// 83234618: 88AB0011  lbz r5, 0x11(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 8323461C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 83234620: 419AFFDC  beq cr6, 0x832345fc
	if ctx.cr[6].eq {
	pc = 0x832345FC; continue 'dispatch;
	}
	pc = 0x83234624; continue 'dispatch;
            }
            0x83234624 => {
    //   block [0x83234624..0x83234648)
	// 83234624: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 83234628: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8323462C: 92E10058  stw r23, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[23].u32 ) };
	// 83234630: 419A0018  beq cr6, 0x83234648
	if ctx.cr[6].eq {
	pc = 0x83234648; continue 'dispatch;
	}
	// 83234634: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 83234638: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8323463C: 4198000C  blt cr6, 0x83234648
	if ctx.cr[6].lt {
	pc = 0x83234648; continue 'dispatch;
	}
	// 83234640: 3BA10058  addi r29, r1, 0x58
	ctx.r[29].s64 = ctx.r[1].s64 + 88;
	// 83234644: 48000010  b 0x83234654
	pc = 0x83234654; continue 'dispatch;
            }
            0x83234648 => {
    //   block [0x83234648..0x83234654)
	// 83234648: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 8323464C: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 83234650: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	pc = 0x83234654; continue 'dispatch;
            }
            0x83234654 => {
    //   block [0x83234654..0x83234670)
	// 83234654: E97D0000  ld r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 83234658: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 8323465C: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 83234660: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83234664: 419A000C  beq cr6, 0x83234670
	if ctx.cr[6].eq {
	pc = 0x83234670; continue 'dispatch;
	}
	// 83234668: 7F0BB840  cmplw cr6, r11, r23
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[23].u32, &mut ctx.xer);
	// 8323466C: 419A0008  beq cr6, 0x83234674
	if ctx.cr[6].eq {
	pc = 0x83234674; continue 'dispatch;
	}
	pc = 0x83234670; continue 'dispatch;
            }
            0x83234670 => {
    //   block [0x83234670..0x83234674)
	// 83234670: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x83234674; continue 'dispatch;
            }
            0x83234674 => {
    //   block [0x83234674..0x832346C0)
	// 83234674: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 83234678: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8323467C: 419A0070  beq cr6, 0x832346ec
	if ctx.cr[6].eq {
	pc = 0x832346EC; continue 'dispatch;
	}
	// 83234680: 83E6FFFC  lwz r31, -4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-4 as u32) ) } as u64;
	// 83234684: 3966FFF8  addi r11, r6, -8
	ctx.r[11].s64 = ctx.r[6].s64 + -8;
	// 83234688: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323468C: 83C6FFF8  lwz r30, -8(r6)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-8 as u32) ) } as u64;
	// 83234690: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 83234694: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 83234698: 419A0028  beq cr6, 0x832346c0
	if ctx.cr[6].eq {
	pc = 0x832346C0; continue 'dispatch;
	}
	// 8323469C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 832346A0: 4AF83479  bl 0x821b7b18
	ctx.lr = 0x832346A4;
	sub_821B7B18(ctx, base);
	// 832346A4: 93DC0000  stw r30, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 832346A8: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 832346AC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 832346B0: 419A0010  beq cr6, 0x832346c0
	if ctx.cr[6].eq {
	pc = 0x832346C0; continue 'dispatch;
	}
	// 832346B4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832346B8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 832346BC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x832346C0; continue 'dispatch;
            }
            0x832346C0 => {
    //   block [0x832346C0..0x832346EC)
	// 832346C0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 832346C4: 4B7CD8D5  bl 0x82a01f98
	ctx.lr = 0x832346C8;
	sub_82A01F98(ctx, base);
	// 832346C8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 832346CC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 832346D0: E8BD0000  ld r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 832346D4: 4B082CED  bl 0x822b73c0
	ctx.lr = 0x832346D8;
	sub_822B73C0(ctx, base);
	// 832346D8: 81370004  lwz r9, 4(r23)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 832346DC: 80DB0008  lwz r6, 8(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 832346E0: 3B5AFFFF  addi r26, r26, -1
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	// 832346E4: 80FB0004  lwz r7, 4(r27)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 832346E8: 4800000C  b 0x832346f4
	pc = 0x832346F4; continue 'dispatch;
            }
            0x832346EC => {
    //   block [0x832346EC..0x832346F4)
	// 832346EC: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 832346F0: 3B390008  addi r25, r25, 8
	ctx.r[25].s64 = ctx.r[25].s64 + 8;
	pc = 0x832346F4; continue 'dispatch;
            }
            0x832346F4 => {
    //   block [0x832346F4..0x832346FC)
	// 832346F4: 7F18D000  cmpw cr6, r24, r26
	ctx.cr[6].compare_i32(ctx.r[24].s32, ctx.r[26].s32, &mut ctx.xer);
	// 832346F8: 4198FEDC  blt cr6, 0x832345d4
	if ctx.cr[6].lt {
	pc = 0x832345D4; continue 'dispatch;
	}
	pc = 0x832346FC; continue 'dispatch;
            }
            0x832346FC => {
    //   block [0x832346FC..0x8323471C)
	// 832346FC: 568B063E  clrlwi r11, r20, 0x18
	ctx.r[11].u64 = ctx.r[20].u32 as u64 & 0x000000FFu64;
	// 83234700: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83234704: 419A0100  beq cr6, 0x83234804
	if ctx.cr[6].eq {
	pc = 0x83234804; continue 'dispatch;
	}
	// 83234708: 7EDDB378  mr r29, r22
	ctx.r[29].u64 = ctx.r[22].u64;
	// 8323470C: 2F130000  cmpwi cr6, r19, 0
	ctx.cr[6].compare_i32(ctx.r[19].s32, 0, &mut ctx.xer);
	// 83234710: 409900F0  ble cr6, 0x83234800
	if !ctx.cr[6].gt {
	pc = 0x83234800; continue 'dispatch;
	}
	// 83234714: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	// 83234718: 3B80FFFF  li r28, -1
	ctx.r[28].s64 = -1;
	pc = 0x8323471C; continue 'dispatch;
            }
            0x8323471C => {
    //   block [0x8323471C..0x83234758)
	// 8323471C: 81750004  lwz r11, 4(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 83234720: 7FFE5A14  add r31, r30, r11
	ctx.r[31].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 83234724: 7D5E582E  lwzx r10, r30, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 83234728: 816A003C  lwz r11, 0x3c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) } as u64;
	// 8323472C: 7F0B8800  cmpw cr6, r11, r17
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[17].s32, &mut ctx.xer);
	// 83234730: 419800C0  blt cr6, 0x832347f0
	if ctx.cr[6].lt {
	pc = 0x832347F0; continue 'dispatch;
	}
	// 83234734: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 83234738: 91726DD4  stw r11, 0x6dd4(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(28116 as u32), ctx.r[11].u32 ) };
	// 8323473C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 83234740: 409A00B0  bne cr6, 0x832347f0
	if !ctx.cr[6].eq {
	pc = 0x832347F0; continue 'dispatch;
	}
	// 83234744: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83234748: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 8323474C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83234750: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 83234754: 419A0020  beq cr6, 0x83234774
	if ctx.cr[6].eq {
	pc = 0x83234774; continue 'dispatch;
	}
	pc = 0x83234758; continue 'dispatch;
            }
            0x83234758 => {
    //   block [0x83234758..0x83234774)
	// 83234758: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 8323475C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 83234760: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 83234764: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 83234768: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8323476C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 83234770: 4082FFE8  bne 0x83234758
	if !ctx.cr[0].eq {
	pc = 0x83234758; continue 'dispatch;
	}
	pc = 0x83234774; continue 'dispatch;
            }
            0x83234774 => {
    //   block [0x83234774..0x832347A4)
	// 83234774: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83234778: 419A002C  beq cr6, 0x832347a4
	if ctx.cr[6].eq {
	pc = 0x832347A4; continue 'dispatch;
	}
	// 8323477C: 560B063E  clrlwi r11, r16, 0x18
	ctx.r[11].u64 = ctx.r[16].u32 as u64 & 0x000000FFu64;
	// 83234780: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83234784: 419A0020  beq cr6, 0x832347a4
	if ctx.cr[6].eq {
	pc = 0x832347A4; continue 'dispatch;
	}
	// 83234788: 806A0028  lwz r3, 0x28(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 8323478C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 83234790: 419A0014  beq cr6, 0x832347a4
	if ctx.cr[6].eq {
	pc = 0x832347A4; continue 'dispatch;
	}
	// 83234794: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83234798: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323479C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832347A0: 4E800421  bctrl
	ctx.lr = 0x832347A4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x832347A4 => {
    //   block [0x832347A4..0x832347BC)
	// 832347A4: 81750008  lwz r11, 8(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 832347A8: 388BFFE4  addi r4, r11, -0x1c
	ctx.r[4].s64 = ctx.r[11].s64 + -28;
	// 832347AC: 816BFFE4  lwz r11, -0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28 as u32) ) } as u64;
	// 832347B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832347B4: 419A0008  beq cr6, 0x832347bc
	if ctx.cr[6].eq {
	pc = 0x832347BC; continue 'dispatch;
	}
	// 832347B8: 93AB002C  stw r29, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[29].u32 ) };
	pc = 0x832347BC; continue 'dispatch;
            }
            0x832347BC => {
    //   block [0x832347BC..0x832347CC)
	// 832347BC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832347C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832347C4: 419A0008  beq cr6, 0x832347cc
	if ctx.cr[6].eq {
	pc = 0x832347CC; continue 'dispatch;
	}
	// 832347C8: 938B002C  stw r28, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[28].u32 ) };
	pc = 0x832347CC; continue 'dispatch;
            }
            0x832347CC => {
    //   block [0x832347CC..0x832347F0)
	// 832347CC: 81750004  lwz r11, 4(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 832347D0: 7C7E5A14  add r3, r30, r11
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 832347D4: 4B7CD75D  bl 0x82a01f30
	ctx.lr = 0x832347D8;
	sub_82A01F30(ctx, base);
	// 832347D8: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 832347DC: 4B7CD885  bl 0x82a02060
	ctx.lr = 0x832347E0;
	sub_82A02060(ctx, base);
	// 832347E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 832347E4: 3A73FFFF  addi r19, r19, -1
	ctx.r[19].s64 = ctx.r[19].s64 + -1;
	// 832347E8: 4AF83331  bl 0x821b7b18
	ctx.lr = 0x832347EC;
	sub_821B7B18(ctx, base);
	// 832347EC: 4800000C  b 0x832347f8
	pc = 0x832347F8; continue 'dispatch;
            }
            0x832347F0 => {
    //   block [0x832347F0..0x832347F8)
	// 832347F0: 3BDE001C  addi r30, r30, 0x1c
	ctx.r[30].s64 = ctx.r[30].s64 + 28;
	// 832347F4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	pc = 0x832347F8; continue 'dispatch;
            }
            0x832347F8 => {
    //   block [0x832347F8..0x83234800)
	// 832347F8: 7F1D9800  cmpw cr6, r29, r19
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[19].s32, &mut ctx.xer);
	// 832347FC: 4198FF20  blt cr6, 0x8323471c
	if ctx.cr[6].lt {
	pc = 0x8323471C; continue 'dispatch;
	}
	pc = 0x83234800; continue 'dispatch;
            }
            0x83234800 => {
    //   block [0x83234800..0x83234804)
	// 83234800: 92326DD4  stw r17, 0x6dd4(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(28116 as u32), ctx.r[17].u32 ) };
	pc = 0x83234804; continue 'dispatch;
            }
            0x83234804 => {
    //   block [0x83234804..0x8323480C)
	// 83234804: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 83234808: 4BA74C20  b 0x82ca9428
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83234810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83234810 size=108
    let mut pc: u32 = 0x83234810;
    'dispatch: loop {
        match pc {
            0x83234810 => {
    //   block [0x83234810..0x8323483C)
	// 83234810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83234814: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83234818: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8323481C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 83234820: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83234824: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 83234828: 394BE47C  addi r10, r11, -0x1b84
	ctx.r[10].s64 = ctx.r[11].s64 + -7044;
	// 8323482C: 83EA0004  lwz r31, 4(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 83234830: 83CA0008  lwz r30, 8(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 83234834: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 83234838: 419A0020  beq cr6, 0x83234858
	if ctx.cr[6].eq {
	pc = 0x83234858; continue 'dispatch;
	}
	pc = 0x8323483C; continue 'dispatch;
            }
            0x8323483C => {
    //   block [0x8323483C..0x8323484C)
	// 8323483C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83234840: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 83234844: 419A0008  beq cr6, 0x8323484c
	if ctx.cr[6].eq {
	pc = 0x8323484C; continue 'dispatch;
	}
	// 83234848: 4BFFD7B9  bl 0x83232000
	ctx.lr = 0x8323484C;
	sub_83232000(ctx, base);
	pc = 0x8323484C; continue 'dispatch;
            }
            0x8323484C => {
    //   block [0x8323484C..0x83234858)
	// 8323484C: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 83234850: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 83234854: 409AFFE8  bne cr6, 0x8323483c
	if !ctx.cr[6].eq {
	pc = 0x8323483C; continue 'dispatch;
	}
	pc = 0x83234858; continue 'dispatch;
            }
            0x83234858 => {
    //   block [0x83234858..0x8323487C)
	// 83234858: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8323485C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 83234860: 4BFFFAD9  bl 0x83234338
	ctx.lr = 0x83234864;
	sub_83234338(ctx, base);
	// 83234864: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 83234868: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8323486C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83234870: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 83234874: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 83234878: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832348A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832348A0 size=476
    let mut pc: u32 = 0x832348A0;
    'dispatch: loop {
        match pc {
            0x832348A0 => {
    //   block [0x832348A0..0x832348D8)
	// 832348A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832348A4: 4BA74B4D  bl 0x82ca93f0
	ctx.lr = 0x832348A8;
	sub_82CA93D0(ctx, base);
	// 832348A8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832348AC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832348B0: 3940001C  li r10, 0x1c
	ctx.r[10].s64 = 28;
	// 832348B4: 3AEBE47C  addi r23, r11, -0x1b84
	ctx.r[23].s64 = ctx.r[11].s64 + -7044;
	// 832348B8: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 832348BC: 81370004  lwz r9, 4(r23)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 832348C0: 81170008  lwz r8, 8(r23)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 832348C4: 7CE94050  subf r7, r9, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 832348C8: 7D6753D7  divw. r11, r7, r10
	ctx.r[11].s32 = ctx.r[7].s32 / ctx.r[10].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832348CC: 408100BC  ble 0x83234988
	if !ctx.cr[0].gt {
	pc = 0x83234988; continue 'dispatch;
	}
	// 832348D0: 7ED9B378  mr r25, r22
	ctx.r[25].u64 = ctx.r[22].u64;
	// 832348D4: 7D785B78  mr r24, r11
	ctx.r[24].u64 = ctx.r[11].u64;
	pc = 0x832348D8; continue 'dispatch;
            }
            0x832348D8 => {
    //   block [0x832348D8..0x832348FC)
	// 832348D8: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 832348DC: 7F795A14  add r27, r25, r11
	ctx.r[27].u64 = ctx.r[25].u64 + ctx.r[11].u64;
	// 832348E0: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 832348E4: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 832348E8: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 832348EC: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832348F0: 4081008C  ble 0x8323497c
	if !ctx.cr[0].gt {
	pc = 0x8323497C; continue 'dispatch;
	}
	// 832348F4: 7EDCB378  mr r28, r22
	ctx.r[28].u64 = ctx.r[22].u64;
	// 832348F8: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	pc = 0x832348FC; continue 'dispatch;
            }
            0x832348FC => {
    //   block [0x832348FC..0x8323491C)
	// 832348FC: 817B000C  lwz r11, 0xc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 83234900: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 83234904: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 83234908: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323490C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83234910: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 83234914: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 83234918: 419A0020  beq cr6, 0x83234938
	if ctx.cr[6].eq {
	pc = 0x83234938; continue 'dispatch;
	}
	pc = 0x8323491C; continue 'dispatch;
            }
            0x8323491C => {
    //   block [0x8323491C..0x83234938)
	// 8323491C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 83234920: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 83234924: 7D605028  lwarx r11, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 83234928: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8323492C: 7D60512D  stwcx. r11, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 83234930: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 83234934: 4082FFE8  bne 0x8323491c
	if !ctx.cr[0].eq {
	pc = 0x8323491C; continue 'dispatch;
	}
	pc = 0x83234938; continue 'dispatch;
            }
            0x83234938 => {
    //   block [0x83234938..0x83234950)
	// 83234938: 817D002C  lwz r11, 0x2c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 8323493C: 815D0028  lwz r10, 0x28(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 83234940: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 83234944: 7D3F1671  srawi. r31, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 83234948: 40810020  ble 0x83234968
	if !ctx.cr[0].gt {
	pc = 0x83234968; continue 'dispatch;
	}
	// 8323494C: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	pc = 0x83234950; continue 'dispatch;
            }
            0x83234950 => {
    //   block [0x83234950..0x83234968)
	// 83234950: 817D0028  lwz r11, 0x28(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 83234954: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 83234958: 4BFF4531  bl 0x83228e88
	ctx.lr = 0x8323495C;
	sub_83228E88(ctx, base);
	// 8323495C: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 83234960: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 83234964: 4082FFEC  bne 0x83234950
	if !ctx.cr[0].eq {
	pc = 0x83234950; continue 'dispatch;
	}
	pc = 0x83234968; continue 'dispatch;
            }
            0x83234968 => {
    //   block [0x83234968..0x8323497C)
	// 83234968: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8323496C: 4AF831AD  bl 0x821b7b18
	ctx.lr = 0x83234970;
	sub_821B7B18(ctx, base);
	// 83234970: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 83234974: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 83234978: 4082FF84  bne 0x832348fc
	if !ctx.cr[0].eq {
	pc = 0x832348FC; continue 'dispatch;
	}
	pc = 0x8323497C; continue 'dispatch;
            }
            0x8323497C => {
    //   block [0x8323497C..0x83234988)
	// 8323497C: 3718FFFF  addic. r24, r24, -1
	ctx.xer.ca = (ctx.r[24].u32 > (!(-1 as u32)));
	ctx.r[24].s64 = ctx.r[24].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 83234980: 3B39001C  addi r25, r25, 0x1c
	ctx.r[25].s64 = ctx.r[25].s64 + 28;
	// 83234984: 4082FF54  bne 0x832348d8
	if !ctx.cr[0].eq {
	pc = 0x832348D8; continue 'dispatch;
	}
	pc = 0x83234988; continue 'dispatch;
            }
            0x83234988 => {
    //   block [0x83234988..0x832349A8)
	// 83234988: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8323498C: 3BCBE48C  addi r30, r11, -0x1b74
	ctx.r[30].s64 = ctx.r[11].s64 + -7028;
	// 83234990: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 83234994: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 83234998: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8323499C: 7D3F1E71  srawi. r31, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 832349A0: 40810024  ble 0x832349c4
	if !ctx.cr[0].gt {
	pc = 0x832349C4; continue 'dispatch;
	}
	// 832349A4: 7EDDB378  mr r29, r22
	ctx.r[29].u64 = ctx.r[22].u64;
	pc = 0x832349A8; continue 'dispatch;
            }
            0x832349A8 => {
    //   block [0x832349A8..0x832349C4)
	// 832349A8: 7C7D502E  lwzx r3, r29, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 832349AC: 4BFF44DD  bl 0x83228e88
	ctx.lr = 0x832349B0;
	sub_83228E88(ctx, base);
	// 832349B0: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 832349B4: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 832349B8: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 832349BC: 4082FFEC  bne 0x832349a8
	if !ctx.cr[0].eq {
	pc = 0x832349A8; continue 'dispatch;
	}
	// 832349C0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x832349C4; continue 'dispatch;
            }
            0x832349C4 => {
    //   block [0x832349C4..0x83234A04)
	// 832349C4: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 832349C8: 3BE9E49C  addi r31, r9, -0x1b64
	ctx.r[31].s64 = ctx.r[9].s64 + -7012;
	// 832349CC: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832349D0: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 832349D4: 7F052040  cmplw cr6, r5, r4
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[4].u32, &mut ctx.xer);
	// 832349D8: 419A002C  beq cr6, 0x83234a04
	if ctx.cr[6].eq {
	pc = 0x83234A04; continue 'dispatch;
	}
	// 832349DC: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 832349E0: 4B7CF0B9  bl 0x82a03a98
	ctx.lr = 0x832349E4;
	sub_82A03A98(ctx, base);
	// 832349E4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 832349E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832349EC: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 832349F0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 832349F4: 4B85D50D  bl 0x82a91f00
	ctx.lr = 0x832349F8;
	sub_82A91F00(ctx, base);
	// 832349F8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 832349FC: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 83234A00: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	pc = 0x83234A04; continue 'dispatch;
            }
            0x83234A04 => {
    //   block [0x83234A04..0x83234A30)
	// 83234A04: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83234A08: 419A0040  beq cr6, 0x83234a48
	if ctx.cr[6].eq {
	pc = 0x83234A48; continue 'dispatch;
	}
	// 83234A0C: 7D455378  mr r5, r10
	ctx.r[5].u64 = ctx.r[10].u64;
	// 83234A10: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 83234A14: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 83234A18: 4B936061  bl 0x82b6aa78
	ctx.lr = 0x83234A1C;
	sub_82B6AA78(ctx, base);
	// 83234A1C: 839E0008  lwz r28, 8(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 83234A20: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 83234A24: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 83234A28: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 83234A2C: 419A0018  beq cr6, 0x83234a44
	if ctx.cr[6].eq {
	pc = 0x83234A44; continue 'dispatch;
	}
	pc = 0x83234A30; continue 'dispatch;
            }
            0x83234A30 => {
    //   block [0x83234A30..0x83234A44)
	// 83234A30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83234A34: 4AF830E5  bl 0x821b7b18
	ctx.lr = 0x83234A38;
	sub_821B7B18(ctx, base);
	// 83234A38: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 83234A3C: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 83234A40: 409AFFF0  bne cr6, 0x83234a30
	if !ctx.cr[6].eq {
	pc = 0x83234A30; continue 'dispatch;
	}
	pc = 0x83234A44; continue 'dispatch;
            }
            0x83234A44 => {
    //   block [0x83234A44..0x83234A48)
	// 83234A44: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	pc = 0x83234A48; continue 'dispatch;
            }
            0x83234A48 => {
    //   block [0x83234A48..0x83234A7C)
	// 83234A48: 81570004  lwz r10, 4(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 83234A4C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 83234A50: 92C10058  stw r22, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[22].u32 ) };
	// 83234A54: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 83234A58: 81770008  lwz r11, 8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 83234A5C: 92C10050  stw r22, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[22].u32 ) };
	// 83234A60: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 83234A64: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 83234A68: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 83234A6C: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 83234A70: 4B7CD7F9  bl 0x82a02268
	ctx.lr = 0x83234A74;
	sub_82A02268(ctx, base);
	// 83234A74: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 83234A78: 4BA749C8  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83234A80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83234A80 size=436
    let mut pc: u32 = 0x83234A80;
    'dispatch: loop {
        match pc {
            0x83234A80 => {
    //   block [0x83234A80..0x83234AB0)
	// 83234A80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83234A84: 4BA74971  bl 0x82ca93f4
	ctx.lr = 0x83234A88;
	sub_82CA93D0(ctx, base);
	// 83234A88: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83234A8C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 83234A90: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 83234A94: 394BE47C  addi r10, r11, -0x1b84
	ctx.r[10].s64 = ctx.r[11].s64 + -7044;
	// 83234A98: 838A0004  lwz r28, 4(r10)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 83234A9C: 82EA0008  lwz r23, 8(r10)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 83234AA0: 7F1CB840  cmplw cr6, r28, r23
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[23].u32, &mut ctx.xer);
	// 83234AA4: 419A0180  beq cr6, 0x83234c24
	if ctx.cr[6].eq {
	pc = 0x83234C24; continue 'dispatch;
	}
	// 83234AA8: 3F208349  lis r25, -0x7cb7
	ctx.r[25].s64 = -2092367872;
	// 83234AAC: 3B000002  li r24, 2
	ctx.r[24].s64 = 2;
	pc = 0x83234AB0; continue 'dispatch;
            }
            0x83234AB0 => {
    //   block [0x83234AB0..0x83234AF0)
	// 83234AB0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 83234AB4: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 83234AB8: 7F0AD000  cmpw cr6, r10, r26
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[26].s32, &mut ctx.xer);
	// 83234ABC: 41980150  blt cr6, 0x83234c0c
	if ctx.cr[6].lt {
	pc = 0x83234C0C; continue 'dispatch;
	}
	// 83234AC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83234AC4: 91596DD4  stw r10, 0x6dd4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(28116 as u32), ctx.r[10].u32 ) };
	// 83234AC8: 419A0144  beq cr6, 0x83234c0c
	if ctx.cr[6].eq {
	pc = 0x83234C0C; continue 'dispatch;
	}
	// 83234ACC: 806B0040  lwz r3, 0x40(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 83234AD0: 4BFFF7E1  bl 0x832342b0
	ctx.lr = 0x83234AD4;
	sub_832342B0(ctx, base);
	// 83234AD4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 83234AD8: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 83234ADC: 419A0130  beq cr6, 0x83234c0c
	if ctx.cr[6].eq {
	pc = 0x83234C0C; continue 'dispatch;
	}
	// 83234AE0: 83BC000C  lwz r29, 0xc(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 83234AE4: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 83234AE8: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83234AEC: 419A0120  beq cr6, 0x83234c0c
	if ctx.cr[6].eq {
	pc = 0x83234C0C; continue 'dispatch;
	}
	pc = 0x83234AF0; continue 'dispatch;
            }
            0x83234AF0 => {
    //   block [0x83234AF0..0x83234B08)
	// 83234AF0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 83234AF4: 83FD0000  lwz r31, 0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 83234AF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83234AFC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 83234B00: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 83234B04: 419A0020  beq cr6, 0x83234b24
	if ctx.cr[6].eq {
	pc = 0x83234B24; continue 'dispatch;
	}
	pc = 0x83234B08; continue 'dispatch;
            }
            0x83234B08 => {
    //   block [0x83234B08..0x83234B24)
	// 83234B08: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 83234B0C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 83234B10: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 83234B14: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 83234B18: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 83234B1C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 83234B20: 4082FFE8  bne 0x83234b08
	if !ctx.cr[0].eq {
	pc = 0x83234B08; continue 'dispatch;
	}
	pc = 0x83234B24; continue 'dispatch;
            }
            0x83234B24 => {
    //   block [0x83234B24..0x83234B48)
	// 83234B24: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 83234B28: 813F0028  lwz r9, 0x28(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 83234B2C: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83234B30: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 83234B34: 5507003A  rlwinm r7, r8, 0, 0, 0x1d
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 83234B38: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 83234B3C: 409A000C  bne cr6, 0x83234b48
	if !ctx.cr[6].eq {
	pc = 0x83234B48; continue 'dispatch;
	}
	// 83234B40: 931F0008  stw r24, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[24].u32 ) };
	// 83234B44: 480000B0  b 0x83234bf4
	pc = 0x83234BF4; continue 'dispatch;
            }
            0x83234B48 => {
    //   block [0x83234B48..0x83234B58)
	// 83234B48: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 83234B4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83234B50: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 83234B54: 419A0020  beq cr6, 0x83234b74
	if ctx.cr[6].eq {
	pc = 0x83234B74; continue 'dispatch;
	}
	pc = 0x83234B58; continue 'dispatch;
            }
            0x83234B58 => {
    //   block [0x83234B58..0x83234B74)
	// 83234B58: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 83234B5C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 83234B60: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 83234B64: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 83234B68: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 83234B6C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 83234B70: 4082FFE8  bne 0x83234b58
	if !ctx.cr[0].eq {
	pc = 0x83234B58; continue 'dispatch;
	}
	pc = 0x83234B74; continue 'dispatch;
            }
            0x83234B74 => {
    //   block [0x83234B74..0x83234BC4)
	// 83234B74: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 83234B78: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 83234B7C: 4BFFF375  bl 0x83233ef0
	ctx.lr = 0x83234B80;
	sub_83233EF0(ctx, base);
	// 83234B80: 815F0028  lwz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 83234B84: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83234B88: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 83234B8C: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 83234B90: 419A0064  beq cr6, 0x83234bf4
	if ctx.cr[6].eq {
	pc = 0x83234BF4; continue 'dispatch;
	}
	// 83234B94: 814300C0  lwz r10, 0xc0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 83234B98: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 83234B9C: 40980054  bge cr6, 0x83234bf0
	if !ctx.cr[6].lt {
	pc = 0x83234BF0; continue 'dispatch;
	}
	// 83234BA0: 895F0010  lbz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 83234BA4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83234BA8: 409A0048  bne cr6, 0x83234bf0
	if !ctx.cr[6].eq {
	pc = 0x83234BF0; continue 'dispatch;
	}
	// 83234BAC: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 83234BB0: 419A0044  beq cr6, 0x83234bf4
	if ctx.cr[6].eq {
	pc = 0x83234BF4; continue 'dispatch;
	}
	// 83234BB4: 83DF0028  lwz r30, 0x28(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 83234BB8: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 83234BBC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83234BC0: 419A0034  beq cr6, 0x83234bf4
	if ctx.cr[6].eq {
	pc = 0x83234BF4; continue 'dispatch;
	}
	pc = 0x83234BC4; continue 'dispatch;
            }
            0x83234BC4 => {
    //   block [0x83234BC4..0x83234BF0)
	// 83234BC4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 83234BC8: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83234BCC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83234BD0: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 83234BD4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83234BD8: 4E800421  bctrl
	ctx.lr = 0x83234BDC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83234BDC: 813F002C  lwz r9, 0x2c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 83234BE0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 83234BE4: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 83234BE8: 409AFFDC  bne cr6, 0x83234bc4
	if !ctx.cr[6].eq {
	pc = 0x83234BC4; continue 'dispatch;
	}
	// 83234BEC: 48000008  b 0x83234bf4
	pc = 0x83234BF4; continue 'dispatch;
            }
            0x83234BF0 => {
    //   block [0x83234BF0..0x83234BF4)
	// 83234BF0: 4BFF4299  bl 0x83228e88
	ctx.lr = 0x83234BF4;
	sub_83228E88(ctx, base);
	pc = 0x83234BF4; continue 'dispatch;
            }
            0x83234BF4 => {
    //   block [0x83234BF4..0x83234C0C)
	// 83234BF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 83234BF8: 4AF82F21  bl 0x821b7b18
	ctx.lr = 0x83234BFC;
	sub_821B7B18(ctx, base);
	// 83234BFC: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 83234C00: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 83234C04: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83234C08: 409AFEE8  bne cr6, 0x83234af0
	if !ctx.cr[6].eq {
	pc = 0x83234AF0; continue 'dispatch;
	}
	pc = 0x83234C0C; continue 'dispatch;
            }
            0x83234C0C => {
    //   block [0x83234C0C..0x83234C24)
	// 83234C0C: 3B9C001C  addi r28, r28, 0x1c
	ctx.r[28].s64 = ctx.r[28].s64 + 28;
	// 83234C10: 7F1CB840  cmplw cr6, r28, r23
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[23].u32, &mut ctx.xer);
	// 83234C14: 409AFE9C  bne cr6, 0x83234ab0
	if !ctx.cr[6].eq {
	pc = 0x83234AB0; continue 'dispatch;
	}
	// 83234C18: 93596DD4  stw r26, 0x6dd4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(28116 as u32), ctx.r[26].u32 ) };
	// 83234C1C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 83234C20: 4BA74824  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x83234C24 => {
    //   block [0x83234C24..0x83234C34)
	// 83234C24: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 83234C28: 934B6DD4  stw r26, 0x6dd4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28116 as u32), ctx.r[26].u32 ) };
	// 83234C2C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 83234C30: 4BA74814  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83234C38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83234C38 size=316
    let mut pc: u32 = 0x83234C38;
    'dispatch: loop {
        match pc {
            0x83234C38 => {
    //   block [0x83234C38..0x83234C74)
	// 83234C38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83234C3C: 4BA747C9  bl 0x82ca9404
	ctx.lr = 0x83234C40;
	sub_82CA93D0(ctx, base);
	// 83234C40: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83234C44: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 83234C48: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 83234C4C: 93DD6DD4  stw r30, 0x6dd4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28116 as u32), ctx.r[30].u32 ) };
	// 83234C50: 4BFFF1D1  bl 0x83233e20
	ctx.lr = 0x83234C54;
	sub_83233E20(ctx, base);
	// 83234C54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 83234C58: 4BFFFE29  bl 0x83234a80
	ctx.lr = 0x83234C5C;
	sub_83234A80(ctx, base);
	// 83234C5C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 83234C60: 394BE47C  addi r10, r11, -0x1b84
	ctx.r[10].s64 = ctx.r[11].s64 + -7044;
	// 83234C64: 838A0004  lwz r28, 4(r10)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 83234C68: 836A0008  lwz r27, 8(r10)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 83234C6C: 7F1CD840  cmplw cr6, r28, r27
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[27].u32, &mut ctx.xer);
	// 83234C70: 419A00F0  beq cr6, 0x83234d60
	if ctx.cr[6].eq {
	pc = 0x83234D60; continue 'dispatch;
	}
	pc = 0x83234C74; continue 'dispatch;
            }
            0x83234C74 => {
    //   block [0x83234C74..0x83234C84)
	// 83234C74: 83FC000C  lwz r31, 0xc(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 83234C78: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 83234C7C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83234C80: 419A00D4  beq cr6, 0x83234d54
	if ctx.cr[6].eq {
	pc = 0x83234D54; continue 'dispatch;
	}
	pc = 0x83234C84; continue 'dispatch;
            }
            0x83234C84 => {
    //   block [0x83234C84..0x83234C9C)
	// 83234C84: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83234C88: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83234C8C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83234C90: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 83234C94: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 83234C98: 419A0020  beq cr6, 0x83234cb8
	if ctx.cr[6].eq {
	pc = 0x83234CB8; continue 'dispatch;
	}
	pc = 0x83234C9C; continue 'dispatch;
            }
            0x83234C9C => {
    //   block [0x83234C9C..0x83234CB8)
	// 83234C9C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 83234CA0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 83234CA4: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 83234CA8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 83234CAC: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 83234CB0: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 83234CB4: 4082FFE8  bne 0x83234c9c
	if !ctx.cr[0].eq {
	pc = 0x83234C9C; continue 'dispatch;
	}
	pc = 0x83234CB8; continue 'dispatch;
            }
            0x83234CB8 => {
    //   block [0x83234CB8..0x83234CDC)
	// 83234CB8: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 83234CBC: 913D6DD4  stw r9, 0x6dd4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28116 as u32), ctx.r[9].u32 ) };
	// 83234CC0: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 83234CC4: 7F09F000  cmpw cr6, r9, r30
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[30].s32, &mut ctx.xer);
	// 83234CC8: 4198003C  blt cr6, 0x83234d04
	if ctx.cr[6].lt {
	pc = 0x83234D04; continue 'dispatch;
	}
	// 83234CCC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 83234CD0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83234CD4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 83234CD8: 419A0020  beq cr6, 0x83234cf8
	if ctx.cr[6].eq {
	pc = 0x83234CF8; continue 'dispatch;
	}
	pc = 0x83234CDC; continue 'dispatch;
            }
            0x83234CDC => {
    //   block [0x83234CDC..0x83234CF8)
	// 83234CDC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 83234CE0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 83234CE4: 7D605028  lwarx r11, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 83234CE8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 83234CEC: 7D60512D  stwcx. r11, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 83234CF0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 83234CF4: 4082FFE8  bne 0x83234cdc
	if !ctx.cr[0].eq {
	pc = 0x83234CDC; continue 'dispatch;
	}
	pc = 0x83234CF8; continue 'dispatch;
            }
            0x83234CF8 => {
    //   block [0x83234CF8..0x83234D04)
	// 83234CF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 83234CFC: 4BFFEB95  bl 0x83233890
	ctx.lr = 0x83234D00;
	sub_83233890(ctx, base);
	// 83234D00: 48000038  b 0x83234d38
	pc = 0x83234D38; continue 'dispatch;
            }
            0x83234D04 => {
    //   block [0x83234D04..0x83234D14)
	// 83234D04: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 83234D08: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83234D0C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 83234D10: 419A0020  beq cr6, 0x83234d30
	if ctx.cr[6].eq {
	pc = 0x83234D30; continue 'dispatch;
	}
	pc = 0x83234D14; continue 'dispatch;
            }
            0x83234D14 => {
    //   block [0x83234D14..0x83234D30)
	// 83234D14: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 83234D18: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 83234D1C: 7D605028  lwarx r11, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 83234D20: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 83234D24: 7D60512D  stwcx. r11, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 83234D28: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 83234D2C: 4082FFE8  bne 0x83234d14
	if !ctx.cr[0].eq {
	pc = 0x83234D14; continue 'dispatch;
	}
	pc = 0x83234D30; continue 'dispatch;
            }
            0x83234D30 => {
    //   block [0x83234D30..0x83234D38)
	// 83234D30: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 83234D34: 4BFFEA8D  bl 0x832337c0
	ctx.lr = 0x83234D38;
	sub_832337C0(ctx, base);
	pc = 0x83234D38; continue 'dispatch;
            }
            0x83234D38 => {
    //   block [0x83234D38..0x83234D54)
	// 83234D38: 93DD6DD4  stw r30, 0x6dd4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28116 as u32), ctx.r[30].u32 ) };
	// 83234D3C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 83234D40: 4AF82DD9  bl 0x821b7b18
	ctx.lr = 0x83234D44;
	sub_821B7B18(ctx, base);
	// 83234D44: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 83234D48: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 83234D4C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83234D50: 409AFF34  bne cr6, 0x83234c84
	if !ctx.cr[6].eq {
	pc = 0x83234C84; continue 'dispatch;
	}
	pc = 0x83234D54; continue 'dispatch;
            }
            0x83234D54 => {
    //   block [0x83234D54..0x83234D60)
	// 83234D54: 3B9C001C  addi r28, r28, 0x1c
	ctx.r[28].s64 = ctx.r[28].s64 + 28;
	// 83234D58: 7F1CD840  cmplw cr6, r28, r27
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[27].u32, &mut ctx.xer);
	// 83234D5C: 409AFF18  bne cr6, 0x83234c74
	if !ctx.cr[6].eq {
	pc = 0x83234C74; continue 'dispatch;
	}
	pc = 0x83234D60; continue 'dispatch;
            }
            0x83234D60 => {
    //   block [0x83234D60..0x83234D74)
	// 83234D60: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 83234D64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 83234D68: 4BFFF5D1  bl 0x83234338
	ctx.lr = 0x83234D6C;
	sub_83234338(ctx, base);
	// 83234D6C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 83234D70: 4BA746E4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83234D78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x83234D78 size=1620
    let mut pc: u32 = 0x83234D78;
    'dispatch: loop {
        match pc {
            0x83234D78 => {
    //   block [0x83234D78..0x83234DF8)
	// 83234D78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83234D7C: 4BA7465D  bl 0x82ca93d8
	ctx.lr = 0x83234D80;
	sub_82CA93D0(ctx, base);
	// 83234D80: DBA1FF60  stfd f29, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[29].u64 ) };
	// 83234D84: DBC1FF68  stfd f30, -0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.f[30].u64 ) };
	// 83234D88: DBE1FF70  stfd f31, -0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[31].u64 ) };
	// 83234D8C: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83234D90: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 83234D94: 7C711B78  mr r17, r3
	ctx.r[17].u64 = ctx.r[3].u64;
	// 83234D98: 894B8089  lbz r10, -0x7f77(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-32631 as u32) ) } as u64;
	// 83234D9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83234DA0: 419A0610  beq cr6, 0x832353b0
	if ctx.cr[6].eq {
	pc = 0x832353B0; continue 'dispatch;
	}
	// 83234DA4: 3A400000  li r18, 0
	ctx.r[18].s64 = 0;
	// 83234DA8: 83F10004  lwz r31, 4(r17)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(4 as u32) ) } as u64;
	// 83234DAC: 83D10000  lwz r30, 0(r17)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(0 as u32) ) } as u64;
	// 83234DB0: 7E509378  mr r16, r18
	ctx.r[16].u64 = ctx.r[18].u64;
	// 83234DB4: 92410070  stw r18, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[18].u32 ) };
	// 83234DB8: 7E549378  mr r20, r18
	ctx.r[20].u64 = ctx.r[18].u64;
	// 83234DBC: 92410074  stw r18, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[18].u32 ) };
	// 83234DC0: 9201007C  stw r16, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[16].u32 ) };
	// 83234DC4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 83234DC8: 92810080  stw r20, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[20].u32 ) };
	// 83234DCC: 92410084  stw r18, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[18].u32 ) };
	// 83234DD0: 419A0028  beq cr6, 0x83234df8
	if ctx.cr[6].eq {
	pc = 0x83234DF8; continue 'dispatch;
	}
	// 83234DD4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 83234DD8: 4AF82D41  bl 0x821b7b18
	ctx.lr = 0x83234DDC;
	sub_821B7B18(ctx, base);
	// 83234DDC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83234DE0: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 83234DE4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 83234DE8: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 83234DEC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83234DF0: 82810080  lwz r20, 0x80(r1)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 83234DF4: 8201007C  lwz r16, 0x7c(r1)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	pc = 0x83234DF8; continue 'dispatch;
            }
            0x83234DF8 => {
    //   block [0x83234DF8..0x83234E44)
	// 83234DF8: 81710000  lwz r11, 0(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(0 as u32) ) } as u64;
	// 83234DFC: 7E569378  mr r22, r18
	ctx.r[22].u64 = ctx.r[18].u64;
	// 83234E00: 3B2B0008  addi r25, r11, 8
	ctx.r[25].s64 = ctx.r[11].s64 + 8;
	// 83234E04: 3AEB0018  addi r23, r11, 0x18
	ctx.r[23].s64 = ctx.r[11].s64 + 24;
	// 83234E08: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 83234E0C: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 83234E10: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 83234E14: 7D151E71  srawi. r21, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[21].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[21].s32, 0, &mut ctx.xer);
	// 83234E18: 40810318  ble 0x83235130
	if !ctx.cr[0].gt {
	pc = 0x83235130; continue 'dispatch;
	}
	// 83234E1C: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 83234E20: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 83234E24: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 83234E28: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 83234E2C: 7E5A9378  mr r26, r18
	ctx.r[26].u64 = ctx.r[18].u64;
	// 83234E30: C3C99484  lfs f30, -0x6b7c(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 83234E34: 7E5B9378  mr r27, r18
	ctx.r[27].u64 = ctx.r[18].u64;
	// 83234E38: C3A80BEC  lfs f29, 0xbec(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3052 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 83234E3C: 3B0B0E68  addi r24, r11, 0xe68
	ctx.r[24].s64 = ctx.r[11].s64 + 3688;
	// 83234E40: 3A6A141C  addi r19, r10, 0x141c
	ctx.r[19].s64 = ctx.r[10].s64 + 5148;
	pc = 0x83234E44; continue 'dispatch;
            }
            0x83234E44 => {
    //   block [0x83234E44..0x83234E90)
	// 83234E44: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 83234E48: 92410058  stw r18, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[18].u32 ) };
	// 83234E4C: 9241005C  stw r18, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[18].u32 ) };
	// 83234E50: 4AFEA409  bl 0x8221f258
	ctx.lr = 0x83234E54;
	sub_8221F258(ctx, base);
	// 83234E54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 83234E58: 419A0038  beq cr6, 0x83234e90
	if ctx.cr[6].eq {
	pc = 0x83234E90; continue 'dispatch;
	}
	// 83234E5C: D3A30014  stfs f29, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 83234E60: 92430004  stw r18, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[18].u32 ) };
	// 83234E64: D3C30018  stfs f30, 0x18(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 83234E68: 92630000  stw r19, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[19].u32 ) };
	// 83234E6C: 92430008  stw r18, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[18].u32 ) };
	// 83234E70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 83234E74: 9A430010  stb r18, 0x10(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[18].u8 ) };
	// 83234E78: 9A430011  stb r18, 0x11(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(17 as u32), ctx.r[18].u8 ) };
	// 83234E7C: 9243001C  stw r18, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[18].u32 ) };
	// 83234E80: 92430028  stw r18, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[18].u32 ) };
	// 83234E84: 9243002C  stw r18, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[18].u32 ) };
	// 83234E88: 92430030  stw r18, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[18].u32 ) };
	// 83234E8C: 48000008  b 0x83234e94
	pc = 0x83234E94; continue 'dispatch;
            }
            0x83234E90 => {
    //   block [0x83234E90..0x83234E94)
	// 83234E90: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	pc = 0x83234E94; continue 'dispatch;
            }
            0x83234E94 => {
    //   block [0x83234E94..0x83234F08)
	// 83234E94: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 83234E98: 4B03E1C1  bl 0x82273058
	ctx.lr = 0x83234E9C;
	sub_82273058(ctx, base);
	// 83234E9C: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 83234EA0: 7E5C9378  mr r28, r18
	ctx.r[28].u64 = ctx.r[18].u64;
	// 83234EA4: FFE0E890  fmr f31, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[29].f64;
	// 83234EA8: 7D5B582E  lwzx r10, r27, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 83234EAC: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 83234EB0: 915D0020  stw r10, 0x20(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 83234EB4: 81310000  lwz r9, 0(r17)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(0 as u32) ) } as u64;
	// 83234EB8: 8109003C  lwz r8, 0x3c(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(60 as u32) ) } as u64;
	// 83234EBC: 911D000C  stw r8, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 83234EC0: 80F90004  lwz r7, 4(r25)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 83234EC4: 7C67D02E  lwzx r3, r7, r26
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 83234EC8: 4BFF4531  bl 0x832293f8
	ctx.lr = 0x83234ECC;
	sub_832293F8(ctx, base);
	// 83234ECC: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 83234ED0: 3BDD0024  addi r30, r29, 0x24
	ctx.r[30].s64 = ctx.r[29].s64 + 36;
	// 83234ED4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 83234ED8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 83234EDC: 4AFA6E25  bl 0x821dbd00
	ctx.lr = 0x83234EE0;
	sub_821DBD00(ctx, base);
	// 83234EE0: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 83234EE4: 386600F4  addi r3, r6, 0xf4
	ctx.r[3].s64 = ctx.r[6].s64 + 244;
	// 83234EE8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 83234EEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83234EF0: 419A001C  beq cr6, 0x83234f0c
	if ctx.cr[6].eq {
	pc = 0x83234F0C; continue 'dispatch;
	}
	// 83234EF4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83234EF8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83234EFC: 419A000C  beq cr6, 0x83234f08
	if ctx.cr[6].eq {
	pc = 0x83234F08; continue 'dispatch;
	}
	// 83234F00: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 83234F04: 4800000C  b 0x83234f10
	pc = 0x83234F10; continue 'dispatch;
            }
            0x83234F08 => {
    //   block [0x83234F08..0x83234F0C)
	// 83234F08: 4AF5EF31  bl 0x82193e38
	ctx.lr = 0x83234F0C;
	sub_82193E38(ctx, base);
	pc = 0x83234F0C; continue 'dispatch;
            }
            0x83234F0C => {
    //   block [0x83234F0C..0x83234F10)
	// 83234F0C: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x83234F10; continue 'dispatch;
            }
            0x83234F10 => {
    //   block [0x83234F10..0x83234F20)
	// 83234F10: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 83234F14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83234F18: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 83234F1C: 419A0138  beq cr6, 0x83235054
	if ctx.cr[6].eq {
	pc = 0x83235054; continue 'dispatch;
	}
	pc = 0x83234F20; continue 'dispatch;
            }
            0x83234F20 => {
    //   block [0x83234F20..0x83234F34)
	// 83234F20: 817F00D0  lwz r11, 0xd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 83234F24: 894B00A0  lbz r10, 0xa0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(160 as u32) ) } as u64;
	// 83234F28: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83234F2C: 419A0008  beq cr6, 0x83234f34
	if ctx.cr[6].eq {
	pc = 0x83234F34; continue 'dispatch;
	}
	// 83234F30: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	pc = 0x83234F34; continue 'dispatch;
            }
            0x83234F34 => {
    //   block [0x83234F34..0x83234F7C)
	// 83234F34: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 83234F38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83234F3C: 419A0078  beq cr6, 0x83234fb4
	if ctx.cr[6].eq {
	pc = 0x83234FB4; continue 'dispatch;
	}
	// 83234F40: 807F00D0  lwz r3, 0xd0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 83234F44: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83234F48: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 83234F4C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83234F50: 4E800421  bctrl
	ctx.lr = 0x83234F54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83234F54: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 83234F58: 419A0024  beq cr6, 0x83234f7c
	if ctx.cr[6].eq {
	pc = 0x83234F7C; continue 'dispatch;
	}
	// 83234F5C: 807F00D0  lwz r3, 0xd0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 83234F60: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83234F64: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 83234F68: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83234F6C: 4E800421  bctrl
	ctx.lr = 0x83234F70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83234F70: 2F030009  cmpwi cr6, r3, 9
	ctx.cr[6].compare_i32(ctx.r[3].s32, 9, &mut ctx.xer);
	// 83234F74: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 83234F78: 409A0008  bne cr6, 0x83234f80
	if !ctx.cr[6].eq {
	pc = 0x83234F80; continue 'dispatch;
	}
            }
            0x83234F7C => {
    //   block [0x83234F7C..0x83234F80)
	// 83234F7C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x83234F80; continue 'dispatch;
            }
            0x83234F80 => {
    //   block [0x83234F80..0x83234FB4)
	// 83234F80: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 83234F84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83234F88: 419A002C  beq cr6, 0x83234fb4
	if ctx.cr[6].eq {
	pc = 0x83234FB4; continue 'dispatch;
	}
	// 83234F8C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83234F90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83234F94: 814B0060  lwz r10, 0x60(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 83234F98: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83234F9C: 4E800421  bctrl
	ctx.lr = 0x83234FA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83234FA0: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83234FA4: 81090034  lwz r8, 0x34(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(52 as u32) ) } as u64;
	// 83234FA8: 2F08FFFF  cmpwi cr6, r8, -1
	ctx.cr[6].compare_i32(ctx.r[8].s32, -1, &mut ctx.xer);
	// 83234FAC: 409A0008  bne cr6, 0x83234fb4
	if !ctx.cr[6].eq {
	pc = 0x83234FB4; continue 'dispatch;
	}
	// 83234FB0: 7E5C9378  mr r28, r18
	ctx.r[28].u64 = ctx.r[18].u64;
            }
            0x83234FB4 => {
    //   block [0x83234FB4..0x83235010)
	// 83234FB4: 817F00D0  lwz r11, 0xd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 83234FB8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 83234FBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 83234FC0: C00B00A8  lfs f0, 0xa8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(168 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 83234FC4: EDBF0028  fsubs f13, f31, f0
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 83234FC8: FF0DF000  fcmpu cr6, f13, f30
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[30].f64);
	// 83234FCC: 7D400026  mfcr r10
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[10].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 83234FD0: 5549DF7A  rlwinm r9, r10, 0x1b, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 83234FD4: 5548F77A  rlwinm r8, r10, 0x1e, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 83234FD8: 7D274378  or r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 83234FDC: 7D983C2E  lfsx f12, r24, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 83234FE0: FFECF82E  fsel f31, f12, f0, f31
	ctx.f[31].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[31].f64 };
	// 83234FE4: 4AFA6D1D  bl 0x821dbd00
	ctx.lr = 0x83234FE8;
	sub_821DBD00(ctx, base);
	// 83234FE8: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 83234FEC: 3BE600F4  addi r31, r6, 0xf4
	ctx.r[31].s64 = ctx.r[6].s64 + 244;
	// 83234FF0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83234FF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83234FF8: 419A0048  beq cr6, 0x83235040
	if ctx.cr[6].eq {
	pc = 0x83235040; continue 'dispatch;
	}
	// 83234FFC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83235000: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83235004: 419A000C  beq cr6, 0x83235010
	if ctx.cr[6].eq {
	pc = 0x83235010; continue 'dispatch;
	}
	// 83235008: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8323500C: 48000038  b 0x83235044
	pc = 0x83235044; continue 'dispatch;
            }
            0x83235010 => {
    //   block [0x83235010..0x8323503C)
	// 83235010: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 83235014: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 83235018: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8323501C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83235020: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 83235024: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83235028: 409A0014  bne cr6, 0x8323503c
	if !ctx.cr[6].eq {
	pc = 0x8323503C; continue 'dispatch;
	}
	// 8323502C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83235030: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83235034: 409A0008  bne cr6, 0x8323503c
	if !ctx.cr[6].eq {
	pc = 0x8323503C; continue 'dispatch;
	}
	// 83235038: 4AFE6D01  bl 0x8221bd38
	ctx.lr = 0x8323503C;
	sub_8221BD38(ctx, base);
	pc = 0x8323503C; continue 'dispatch;
            }
            0x8323503C => {
    //   block [0x8323503C..0x83235040)
	// 8323503C: 925F0004  stw r18, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[18].u32 ) };
	pc = 0x83235040; continue 'dispatch;
            }
            0x83235040 => {
    //   block [0x83235040..0x83235044)
	// 83235040: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x83235044; continue 'dispatch;
            }
            0x83235044 => {
    //   block [0x83235044..0x83235054)
	// 83235044: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 83235048: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323504C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 83235050: 409AFED0  bne cr6, 0x83234f20
	if !ctx.cr[6].eq {
	pc = 0x83234F20; continue 'dispatch;
	}
	pc = 0x83235054; continue 'dispatch;
            }
            0x83235054 => {
    //   block [0x83235054..0x8323507C)
	// 83235054: 9B9D0010  stb r28, 0x10(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[28].u8 ) };
	// 83235058: EC1F07F2  fmuls f0, f31, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[31].f64) as f32) as f64);
	// 8323505C: D01D0014  stfs f0, 0x14(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 83235060: 81710000  lwz r11, 0(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(0 as u32) ) } as u64;
	// 83235064: 894B0038  lbz r10, 0x38(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 83235068: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323506C: 419A0010  beq cr6, 0x8323507c
	if ctx.cr[6].eq {
	pc = 0x8323507C; continue 'dispatch;
	}
	// 83235070: 39760001  addi r11, r22, 1
	ctx.r[11].s64 = ctx.r[22].s64 + 1;
	// 83235074: 917D001C  stw r11, 0x1c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 83235078: 48000008  b 0x83235080
	pc = 0x83235080; continue 'dispatch;
            }
            0x8323507C => {
    //   block [0x8323507C..0x83235080)
	// 8323507C: 925D001C  stw r18, 0x1c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28 as u32), ctx.r[18].u32 ) };
	pc = 0x83235080; continue 'dispatch;
            }
            0x83235080 => {
    //   block [0x83235080..0x83235090)
	// 83235080: 2B100000  cmplwi cr6, r16, 0
	ctx.cr[6].compare_u32(ctx.r[16].u32, 0 as u32, &mut ctx.xer);
	// 83235084: 409A000C  bne cr6, 0x83235090
	if !ctx.cr[6].eq {
	pc = 0x83235090; continue 'dispatch;
	}
	// 83235088: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 8323508C: 48000010  b 0x8323509c
	pc = 0x8323509C; continue 'dispatch;
            }
            0x83235090 => {
    //   block [0x83235090..0x8323509C)
	// 83235090: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 83235094: 7D505850  subf r10, r16, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[16].s64;
	// 83235098: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	pc = 0x8323509C; continue 'dispatch;
            }
            0x8323509C => {
    //   block [0x8323509C..0x832350C8)
	// 8323509C: 7D50A050  subf r10, r16, r20
	ctx.r[10].s64 = ctx.r[20].s64 - ctx.r[16].s64;
	// 832350A0: 7D491E70  srawi r9, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 832350A4: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 832350A8: 40980048  bge cr6, 0x832350f0
	if !ctx.cr[6].lt {
	pc = 0x832350F0; continue 'dispatch;
	}
	// 832350AC: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 832350B0: 419A0034  beq cr6, 0x832350e4
	if ctx.cr[6].eq {
	pc = 0x832350E4; continue 'dispatch;
	}
	// 832350B4: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 832350B8: 93B40000  stw r29, 0(r20)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[20].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 832350BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832350C0: 91740004  stw r11, 4(r20)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[20].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832350C4: 419A0020  beq cr6, 0x832350e4
	if ctx.cr[6].eq {
	pc = 0x832350E4; continue 'dispatch;
	}
	pc = 0x832350C8; continue 'dispatch;
            }
            0x832350C8 => {
    //   block [0x832350C8..0x832350E4)
	// 832350C8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 832350CC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832350D0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 832350D4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 832350D8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 832350DC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832350E0: 4082FFE8  bne 0x832350c8
	if !ctx.cr[0].eq {
	pc = 0x832350C8; continue 'dispatch;
	}
	pc = 0x832350E4; continue 'dispatch;
            }
            0x832350E4 => {
    //   block [0x832350E4..0x832350F0)
	// 832350E4: 3A940008  addi r20, r20, 8
	ctx.r[20].s64 = ctx.r[20].s64 + 8;
	// 832350E8: 92810080  stw r20, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[20].u32 ) };
	// 832350EC: 48000028  b 0x83235114
	pc = 0x83235114; continue 'dispatch;
            }
            0x832350F0 => {
    //   block [0x832350F0..0x83235114)
	// 832350F0: 92410060  stw r18, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[18].u32 ) };
	// 832350F4: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 832350F8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 832350FC: 92810064  stw r20, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[20].u32 ) };
	// 83235100: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 83235104: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 83235108: 4B2E5E79  bl 0x8251af80
	ctx.lr = 0x8323510C;
	sub_8251AF80(ctx, base);
	// 8323510C: 82810080  lwz r20, 0x80(r1)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 83235110: 8201007C  lwz r16, 0x7c(r1)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	pc = 0x83235114; continue 'dispatch;
            }
            0x83235114 => {
    //   block [0x83235114..0x83235130)
	// 83235114: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 83235118: 4AF82A01  bl 0x821b7b18
	ctx.lr = 0x8323511C;
	sub_821B7B18(ctx, base);
	// 8323511C: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	// 83235120: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 83235124: 3B5A0008  addi r26, r26, 8
	ctx.r[26].s64 = ctx.r[26].s64 + 8;
	// 83235128: 7F16A800  cmpw cr6, r22, r21
	ctx.cr[6].compare_i32(ctx.r[22].s32, ctx.r[21].s32, &mut ctx.xer);
	// 8323512C: 4198FD18  blt cr6, 0x83234e44
	if ctx.cr[6].lt {
	pc = 0x83234E44; continue 'dispatch;
	}
	pc = 0x83235130; continue 'dispatch;
            }
            0x83235130 => {
    //   block [0x83235130..0x8323516C)
	// 83235130: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 83235134: 81010070  lwz r8, 0x70(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 83235138: 3920001C  li r9, 0x1c
	ctx.r[9].s64 = 28;
	// 8323513C: 92A10088  stw r21, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[21].u32 ) };
	// 83235140: 3BEBE47C  addi r31, r11, -0x1b84
	ctx.r[31].s64 = ctx.r[11].s64 + -7044;
	// 83235144: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83235148: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323514C: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 83235150: 7CC74BD6  divw r6, r7, r9
	ctx.r[6].s32 = ctx.r[7].s32 / ctx.r[9].s32;
	// 83235154: 90C8002C  stw r6, 0x2c(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(44 as u32), ctx.r[6].u32 ) };
	// 83235158: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323515C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83235160: 409A000C  bne cr6, 0x8323516c
	if !ctx.cr[6].eq {
	pc = 0x8323516C; continue 'dispatch;
	}
	// 83235164: 7E4A9378  mr r10, r18
	ctx.r[10].u64 = ctx.r[18].u64;
	// 83235168: 48000010  b 0x83235178
	pc = 0x83235178; continue 'dispatch;
            }
            0x8323516C => {
    //   block [0x8323516C..0x83235178)
	// 8323516C: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 83235170: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 83235174: 7D4A4BD6  divw r10, r10, r9
	ctx.r[10].s32 = ctx.r[10].s32 / ctx.r[9].s32;
	pc = 0x83235178; continue 'dispatch;
            }
            0x83235178 => {
    //   block [0x83235178..0x832351A0)
	// 83235178: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323517C: 7D6BF050  subf r11, r11, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 83235180: 7D2B4BD6  divw r9, r11, r9
	ctx.r[9].s32 = ctx.r[11].s32 / ctx.r[9].s32;
	// 83235184: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 83235188: 40980024  bge cr6, 0x832351ac
	if !ctx.cr[6].lt {
	pc = 0x832351AC; continue 'dispatch;
	}
	// 8323518C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 83235190: 419A0010  beq cr6, 0x832351a0
	if ctx.cr[6].eq {
	pc = 0x832351A0; continue 'dispatch;
	}
	// 83235194: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 83235198: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323519C: 4AF3C54D  bl 0x821716e8
	ctx.lr = 0x832351A0;
	sub_821716E8(ctx, base);
	pc = 0x832351A0; continue 'dispatch;
            }
            0x832351A0 => {
    //   block [0x832351A0..0x832351AC)
	// 832351A0: 397E001C  addi r11, r30, 0x1c
	ctx.r[11].s64 = ctx.r[30].s64 + 28;
	// 832351A4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 832351A8: 48000020  b 0x832351c8
	pc = 0x832351C8; continue 'dispatch;
            }
            0x832351AC => {
    //   block [0x832351AC..0x832351C8)
	// 832351AC: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 832351B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832351B4: 92410060  stw r18, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[18].u32 ) };
	// 832351B8: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 832351BC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 832351C0: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 832351C4: 4B7CD5ED  bl 0x82a027b0
	ctx.lr = 0x832351C8;
	sub_82A027B0(ctx, base);
	pc = 0x832351C8; continue 'dispatch;
            }
            0x832351C8 => {
    //   block [0x832351C8..0x832351DC)
	// 832351C8: 7D70A050  subf r11, r16, r20
	ctx.r[11].s64 = ctx.r[20].s64 - ctx.r[16].s64;
	// 832351CC: 7D751E71  srawi. r21, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[21].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[21].s32, 0, &mut ctx.xer);
	// 832351D0: 408101D0  ble 0x832353a0
	if !ctx.cr[0].gt {
	pc = 0x832353A0; continue 'dispatch;
	}
	// 832351D4: 7E148378  mr r20, r16
	ctx.r[20].u64 = ctx.r[16].u64;
	// 832351D8: 7EB3AB78  mr r19, r21
	ctx.r[19].u64 = ctx.r[21].u64;
	pc = 0x832351DC; continue 'dispatch;
            }
            0x832351DC => {
    //   block [0x832351DC..0x832351F4)
	// 832351DC: 81740004  lwz r11, 4(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) } as u64;
	// 832351E0: 82D40000  lwz r22, 0(r20)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 832351E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832351E8: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 832351EC: 92C10068  stw r22, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[22].u32 ) };
	// 832351F0: 419A0020  beq cr6, 0x83235210
	if ctx.cr[6].eq {
	pc = 0x83235210; continue 'dispatch;
	}
	pc = 0x832351F4; continue 'dispatch;
            }
            0x832351F4 => {
    //   block [0x832351F4..0x83235210)
	// 832351F4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 832351F8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832351FC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 83235200: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 83235204: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 83235208: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323520C: 4082FFE8  bne 0x832351f4
	if !ctx.cr[0].eq {
	pc = 0x832351F4; continue 'dispatch;
	}
	pc = 0x83235210; continue 'dispatch;
            }
            0x83235210 => {
    //   block [0x83235210..0x8323522C)
	// 83235210: 8176002C  lwz r11, 0x2c(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(44 as u32) ) } as u64;
	// 83235214: 81560028  lwz r10, 0x28(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(40 as u32) ) } as u64;
	// 83235218: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8323521C: 7D2B1671  srawi. r11, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 83235220: 4081016C  ble 0x8323538c
	if !ctx.cr[0].gt {
	pc = 0x8323538C; continue 'dispatch;
	}
	// 83235224: 7E589378  mr r24, r18
	ctx.r[24].u64 = ctx.r[18].u64;
	// 83235228: 7D775B78  mr r23, r11
	ctx.r[23].u64 = ctx.r[11].u64;
	pc = 0x8323522C; continue 'dispatch;
            }
            0x8323522C => {
    //   block [0x8323522C..0x83235270)
	// 8323522C: 81760028  lwz r11, 0x28(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(40 as u32) ) } as u64;
	// 83235230: 7F78582E  lwzx r27, r24, r11
	ctx.r[27].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 83235234: 807B00D0  lwz r3, 0xd0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(208 as u32) ) } as u64;
	// 83235238: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323523C: 812A0014  lwz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 83235240: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 83235244: 4E800421  bctrl
	ctx.lr = 0x83235248;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83235248: 2F030004  cmpwi cr6, r3, 4
	ctx.cr[6].compare_i32(ctx.r[3].s32, 4, &mut ctx.xer);
	// 8323524C: 409A0134  bne cr6, 0x83235380
	if !ctx.cr[6].eq {
	pc = 0x83235380; continue 'dispatch;
	}
	// 83235250: 817B0130  lwz r11, 0x130(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(304 as u32) ) } as u64;
	// 83235254: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 83235258: 894B00C1  lbz r10, 0xc1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(193 as u32) ) } as u64;
	// 8323525C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83235260: 419A0010  beq cr6, 0x83235270
	if ctx.cr[6].eq {
	pc = 0x83235270; continue 'dispatch;
	}
	// 83235264: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 83235268: 4BFFEEB1  bl 0x83234118
	ctx.lr = 0x8323526C;
	sub_83234118(ctx, base);
	// 8323526C: 48000114  b 0x83235380
	pc = 0x83235380; continue 'dispatch;
            }
            0x83235270 => {
    //   block [0x83235270..0x83235278)
	// 83235270: 7E1A8378  mr r26, r16
	ctx.r[26].u64 = ctx.r[16].u64;
	// 83235274: 7EB9AB78  mr r25, r21
	ctx.r[25].u64 = ctx.r[21].u64;
	pc = 0x83235278; continue 'dispatch;
            }
            0x83235278 => {
    //   block [0x83235278..0x83235290)
	// 83235278: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323527C: 839A0000  lwz r28, 0(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 83235280: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83235284: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 83235288: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 8323528C: 419A0020  beq cr6, 0x832352ac
	if ctx.cr[6].eq {
	pc = 0x832352AC; continue 'dispatch;
	}
	pc = 0x83235290; continue 'dispatch;
            }
            0x83235290 => {
    //   block [0x83235290..0x832352AC)
	// 83235290: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 83235294: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 83235298: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8323529C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 832352A0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 832352A4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832352A8: 4082FFE8  bne 0x83235290
	if !ctx.cr[0].eq {
	pc = 0x83235290; continue 'dispatch;
	}
	pc = 0x832352AC; continue 'dispatch;
            }
            0x832352AC => {
    //   block [0x832352AC..0x832352C8)
	// 832352AC: 817C002C  lwz r11, 0x2c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 832352B0: 815C0028  lwz r10, 0x28(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) } as u64;
	// 832352B4: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 832352B8: 7D2B1671  srawi. r11, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832352BC: 408100B0  ble 0x8323536c
	if !ctx.cr[0].gt {
	pc = 0x8323536C; continue 'dispatch;
	}
	// 832352C0: 7E5E9378  mr r30, r18
	ctx.r[30].u64 = ctx.r[18].u64;
	// 832352C4: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	pc = 0x832352C8; continue 'dispatch;
            }
            0x832352C8 => {
    //   block [0x832352C8..0x83235314)
	// 832352C8: 817C0028  lwz r11, 0x28(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) } as u64;
	// 832352CC: 7FEBF02E  lwzx r31, r11, r30
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 832352D0: 7F1BF840  cmplw cr6, r27, r31
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[31].u32, &mut ctx.xer);
	// 832352D4: 419A008C  beq cr6, 0x83235360
	if ctx.cr[6].eq {
	pc = 0x83235360; continue 'dispatch;
	}
	// 832352D8: 807F00D0  lwz r3, 0xd0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 832352DC: 809B00D0  lwz r4, 0xd0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(208 as u32) ) } as u64;
	// 832352E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 832352E4: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 832352E8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832352EC: 4E800421  bctrl
	ctx.lr = 0x832352F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832352F0: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 832352F4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 832352F8: 419A0068  beq cr6, 0x83235360
	if ctx.cr[6].eq {
	pc = 0x83235360; continue 'dispatch;
	}
	// 832352FC: 815F00DC  lwz r10, 0xdc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 83235300: 387F00D8  addi r3, r31, 0xd8
	ctx.r[3].s64 = ctx.r[31].s64 + 216;
	// 83235304: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83235308: 409A000C  bne cr6, 0x83235314
	if !ctx.cr[6].eq {
	pc = 0x83235314; continue 'dispatch;
	}
	// 8323530C: 7E499378  mr r9, r18
	ctx.r[9].u64 = ctx.r[18].u64;
	// 83235310: 48000010  b 0x83235320
	pc = 0x83235320; continue 'dispatch;
            }
            0x83235314 => {
    //   block [0x83235314..0x83235320)
	// 83235314: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 83235318: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8323531C: 7D291670  srawi r9, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 2) as i64;
	pc = 0x83235320; continue 'dispatch;
            }
            0x83235320 => {
    //   block [0x83235320..0x83235348)
	// 83235320: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 83235324: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 83235328: 7D481670  srawi r8, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 8323532C: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 83235330: 40980018  bge cr6, 0x83235348
	if !ctx.cr[6].lt {
	pc = 0x83235348; continue 'dispatch;
	}
	// 83235334: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 83235338: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 8323533C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 83235340: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 83235344: 4800001C  b 0x83235360
	pc = 0x83235360; continue 'dispatch;
            }
            0x83235348 => {
    //   block [0x83235348..0x83235360)
	// 83235348: 92410060  stw r18, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[18].u32 ) };
	// 8323534C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 83235350: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 83235354: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 83235358: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8323535C: 4B22D155  bl 0x824624b0
	ctx.lr = 0x83235360;
	sub_824624B0(ctx, base);
	pc = 0x83235360; continue 'dispatch;
            }
            0x83235360 => {
    //   block [0x83235360..0x8323536C)
	// 83235360: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 83235364: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 83235368: 4082FF60  bne 0x832352c8
	if !ctx.cr[0].eq {
	pc = 0x832352C8; continue 'dispatch;
	}
	pc = 0x8323536C; continue 'dispatch;
            }
            0x8323536C => {
    //   block [0x8323536C..0x83235380)
	// 8323536C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 83235370: 4AF827A9  bl 0x821b7b18
	ctx.lr = 0x83235374;
	sub_821B7B18(ctx, base);
	// 83235374: 3739FFFF  addic. r25, r25, -1
	ctx.xer.ca = (ctx.r[25].u32 > (!(-1 as u32)));
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 83235378: 3B5A0008  addi r26, r26, 8
	ctx.r[26].s64 = ctx.r[26].s64 + 8;
	// 8323537C: 4082FEFC  bne 0x83235278
	if !ctx.cr[0].eq {
	pc = 0x83235278; continue 'dispatch;
	}
	pc = 0x83235380; continue 'dispatch;
            }
            0x83235380 => {
    //   block [0x83235380..0x8323538C)
	// 83235380: 36F7FFFF  addic. r23, r23, -1
	ctx.xer.ca = (ctx.r[23].u32 > (!(-1 as u32)));
	ctx.r[23].s64 = ctx.r[23].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 83235384: 3B180004  addi r24, r24, 4
	ctx.r[24].s64 = ctx.r[24].s64 + 4;
	// 83235388: 4082FEA4  bne 0x8323522c
	if !ctx.cr[0].eq {
	pc = 0x8323522C; continue 'dispatch;
	}
	pc = 0x8323538C; continue 'dispatch;
            }
            0x8323538C => {
    //   block [0x8323538C..0x832353A0)
	// 8323538C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 83235390: 4AF82789  bl 0x821b7b18
	ctx.lr = 0x83235394;
	sub_821B7B18(ctx, base);
	// 83235394: 3673FFFF  addic. r19, r19, -1
	ctx.xer.ca = (ctx.r[19].u32 > (!(-1 as u32)));
	ctx.r[19].s64 = ctx.r[19].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[19].s32, 0, &mut ctx.xer);
	// 83235398: 3A940008  addi r20, r20, 8
	ctx.r[20].s64 = ctx.r[20].s64 + 8;
	// 8323539C: 4082FE40  bne 0x832351dc
	if !ctx.cr[0].eq {
	pc = 0x832351DC; continue 'dispatch;
	}
	pc = 0x832353A0; continue 'dispatch;
            }
            0x832353A0 => {
    //   block [0x832353A0..0x832353B0)
	// 832353A0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 832353A4: 4B1A7485  bl 0x823dc828
	ctx.lr = 0x832353A8;
	sub_823DC828(ctx, base);
	// 832353A8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 832353AC: 4AF8276D  bl 0x821b7b18
	ctx.lr = 0x832353B0;
	sub_821B7B18(ctx, base);
	pc = 0x832353B0; continue 'dispatch;
            }
            0x832353B0 => {
    //   block [0x832353B0..0x832353CC)
	// 832353B0: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 832353B4: 4AF82765  bl 0x821b7b18
	ctx.lr = 0x832353B8;
	sub_821B7B18(ctx, base);
	// 832353B8: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 832353BC: CBA1FF60  lfd f29, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 832353C0: CBC1FF68  lfd f30, -0x98(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 832353C4: CBE1FF70  lfd f31, -0x90(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 832353C8: 4BA74060  b 0x82ca9428
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832353E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832353E0 size=124
    let mut pc: u32 = 0x832353E0;
    'dispatch: loop {
        match pc {
            0x832353E0 => {
    //   block [0x832353E0..0x83235414)
	// 832353E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832353E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832353E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832353EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832353F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832353F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 832353F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 832353FC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 83235400: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83235404: 409A0010  bne cr6, 0x83235414
	if !ctx.cr[6].eq {
	pc = 0x83235414; continue 'dispatch;
	}
	// 83235408: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8323540C: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 83235410: 48000008  b 0x83235418
	pc = 0x83235418; continue 'dispatch;
            }
            0x83235414 => {
    //   block [0x83235414..0x83235418)
	// 83235414: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x83235418; continue 'dispatch;
            }
            0x83235418 => {
    //   block [0x83235418..0x83235444)
	// 83235418: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323541C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83235420: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 83235424: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83235428: 4E800421  bctrl
	ctx.lr = 0x8323542C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323542C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 83235430: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83235434: 419A0010  beq cr6, 0x83235444
	if ctx.cr[6].eq {
	pc = 0x83235444; continue 'dispatch;
	}
	// 83235438: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8323543C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83235440: 4B7CCA11  bl 0x82a01e50
	ctx.lr = 0x83235444;
	sub_82A01E50(ctx, base);
            }
            0x83235444 => {
    //   block [0x83235444..0x8323545C)
	// 83235444: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 83235448: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8323544C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83235450: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 83235454: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 83235458: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83235460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83235460 size=172
    let mut pc: u32 = 0x83235460;
    'dispatch: loop {
        match pc {
            0x83235460 => {
    //   block [0x83235460..0x83235494)
	// 83235460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83235464: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83235468: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8323546C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 83235470: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83235474: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83235478: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8323547C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 83235480: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83235484: 409A0010  bne cr6, 0x83235494
	if !ctx.cr[6].eq {
	pc = 0x83235494; continue 'dispatch;
	}
	// 83235488: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8323548C: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 83235490: 48000008  b 0x83235498
	pc = 0x83235498; continue 'dispatch;
            }
            0x83235494 => {
    //   block [0x83235494..0x83235498)
	// 83235494: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x83235498; continue 'dispatch;
            }
            0x83235498 => {
    //   block [0x83235498..0x832354F4)
	// 83235498: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323549C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832354A0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 832354A4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832354A8: 4E800421  bctrl
	ctx.lr = 0x832354AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832354AC: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 832354B0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 832354B4: 419A0040  beq cr6, 0x832354f4
	if ctx.cr[6].eq {
	pc = 0x832354F4; continue 'dispatch;
	}
	// 832354B8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 832354BC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 832354C0: 388B06D4  addi r4, r11, 0x6d4
	ctx.r[4].s64 = ctx.r[11].s64 + 1748;
	// 832354C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832354C8: 4B24B389  bl 0x82480850
	ctx.lr = 0x832354CC;
	sub_82480850(ctx, base);
	// 832354CC: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 832354D0: 38BE0004  addi r5, r30, 4
	ctx.r[5].s64 = ctx.r[30].s64 + 4;
	// 832354D4: 388A06D8  addi r4, r10, 0x6d8
	ctx.r[4].s64 = ctx.r[10].s64 + 1752;
	// 832354D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832354DC: 4B24B375  bl 0x82480850
	ctx.lr = 0x832354E0;
	sub_82480850(ctx, base);
	// 832354E0: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832354E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832354E8: 8109000C  lwz r8, 0xc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 832354EC: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 832354F0: 4E800421  bctrl
	ctx.lr = 0x832354F4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x832354F4 => {
    //   block [0x832354F4..0x8323550C)
	// 832354F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832354F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832354FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83235500: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 83235504: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 83235508: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83235510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83235510 size=240
    let mut pc: u32 = 0x83235510;
    'dispatch: loop {
        match pc {
            0x83235510 => {
    //   block [0x83235510..0x83235544)
	// 83235510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83235514: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83235518: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8323551C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 83235520: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83235524: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83235528: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8323552C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 83235530: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83235534: 409A0010  bne cr6, 0x83235544
	if !ctx.cr[6].eq {
	pc = 0x83235544; continue 'dispatch;
	}
	// 83235538: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8323553C: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 83235540: 48000008  b 0x83235548
	pc = 0x83235548; continue 'dispatch;
            }
            0x83235544 => {
    //   block [0x83235544..0x83235548)
	// 83235544: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x83235548; continue 'dispatch;
            }
            0x83235548 => {
    //   block [0x83235548..0x832355E8)
	// 83235548: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323554C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83235550: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 83235554: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83235558: 4E800421  bctrl
	ctx.lr = 0x8323555C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323555C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 83235560: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83235564: 419A0084  beq cr6, 0x832355e8
	if ctx.cr[6].eq {
	pc = 0x832355E8; continue 'dispatch;
	}
	// 83235568: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 8323556C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 83235570: 388B21A8  addi r4, r11, 0x21a8
	ctx.r[4].s64 = ctx.r[11].s64 + 8616;
	// 83235574: 4BA53765  bl 0x82c88cd8
	ctx.lr = 0x83235578;
	sub_82C88CD8(ctx, base);
	// 83235578: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323557C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 83235580: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 83235584: 388A0E7C  addi r4, r10, 0xe7c
	ctx.r[4].s64 = ctx.r[10].s64 + 3708;
	// 83235588: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323558C: 81090028  lwz r8, 0x28(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(40 as u32) ) } as u64;
	// 83235590: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 83235594: 4E800421  bctrl
	ctx.lr = 0x83235598;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83235598: 3CE0820B  lis r7, -0x7df5
	ctx.r[7].s64 = -2113208320;
	// 8323559C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 832355A0: 388706D4  addi r4, r7, 0x6d4
	ctx.r[4].s64 = ctx.r[7].s64 + 1748;
	// 832355A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832355A8: 4B24B2A9  bl 0x82480850
	ctx.lr = 0x832355AC;
	sub_82480850(ctx, base);
	// 832355AC: 3CC0820B  lis r6, -0x7df5
	ctx.r[6].s64 = -2113208320;
	// 832355B0: 38BE0004  addi r5, r30, 4
	ctx.r[5].s64 = ctx.r[30].s64 + 4;
	// 832355B4: 388606D8  addi r4, r6, 0x6d8
	ctx.r[4].s64 = ctx.r[6].s64 + 1752;
	// 832355B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832355BC: 4B24B295  bl 0x82480850
	ctx.lr = 0x832355C0;
	sub_82480850(ctx, base);
	// 832355C0: 3C80820C  lis r4, -0x7df4
	ctx.r[4].s64 = -2113142784;
	// 832355C4: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 832355C8: 3884C2C8  addi r4, r4, -0x3d38
	ctx.r[4].s64 = ctx.r[4].s64 + -15672;
	// 832355CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832355D0: 4B24B281  bl 0x82480850
	ctx.lr = 0x832355D4;
	sub_82480850(ctx, base);
	// 832355D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832355D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832355DC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 832355E0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832355E4: 4E800421  bctrl
	ctx.lr = 0x832355E8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x832355E8 => {
    //   block [0x832355E8..0x83235600)
	// 832355E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832355EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832355F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832355F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832355F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832355FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83235600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83235600 size=156
    let mut pc: u32 = 0x83235600;
    'dispatch: loop {
        match pc {
            0x83235600 => {
    //   block [0x83235600..0x83235634)
	// 83235600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83235604: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83235608: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8323560C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 83235610: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83235614: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83235618: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8323561C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 83235620: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83235624: 409A0010  bne cr6, 0x83235634
	if !ctx.cr[6].eq {
	pc = 0x83235634; continue 'dispatch;
	}
	// 83235628: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8323562C: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 83235630: 48000008  b 0x83235638
	pc = 0x83235638; continue 'dispatch;
            }
            0x83235634 => {
    //   block [0x83235634..0x83235638)
	// 83235634: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x83235638; continue 'dispatch;
            }
            0x83235638 => {
    //   block [0x83235638..0x83235684)
	// 83235638: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323563C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83235640: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 83235644: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83235648: 4E800421  bctrl
	ctx.lr = 0x8323564C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323564C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 83235650: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83235654: 419A0030  beq cr6, 0x83235684
	if ctx.cr[6].eq {
	pc = 0x83235684; continue 'dispatch;
	}
	// 83235658: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323565C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 83235660: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83235664: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 83235668: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323566C: 4E800421  bctrl
	ctx.lr = 0x83235670;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83235670: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83235674: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83235678: 8109000C  lwz r8, 0xc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323567C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 83235680: 4E800421  bctrl
	ctx.lr = 0x83235684;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x83235684 => {
    //   block [0x83235684..0x8323569C)
	// 83235684: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 83235688: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8323568C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83235690: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 83235694: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 83235698: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832356A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832356A0 size=40
    let mut pc: u32 = 0x832356A0;
    'dispatch: loop {
        match pc {
            0x832356A0 => {
    //   block [0x832356A0..0x832356BC)
	// 832356A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 832356A4: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 832356A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832356AC: 409A0010  bne cr6, 0x832356bc
	if !ctx.cr[6].eq {
	pc = 0x832356BC; continue 'dispatch;
	}
	// 832356B0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 832356B4: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 832356B8: 48000008  b 0x832356c0
	pc = 0x832356C0; continue 'dispatch;
            }
            0x832356BC => {
    //   block [0x832356BC..0x832356C0)
	// 832356BC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x832356C0; continue 'dispatch;
            }
            0x832356C0 => {
    //   block [0x832356C0..0x832356C8)
	// 832356C0: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 832356C4: 4B15A9C4  b 0x82390088
	sub_82390088(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832356C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832356C8 size=40
    let mut pc: u32 = 0x832356C8;
    'dispatch: loop {
        match pc {
            0x832356C8 => {
    //   block [0x832356C8..0x832356E4)
	// 832356C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 832356CC: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 832356D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832356D4: 409A0010  bne cr6, 0x832356e4
	if !ctx.cr[6].eq {
	pc = 0x832356E4; continue 'dispatch;
	}
	// 832356D8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 832356DC: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 832356E0: 48000008  b 0x832356e8
	pc = 0x832356E8; continue 'dispatch;
            }
            0x832356E4 => {
    //   block [0x832356E4..0x832356E8)
	// 832356E4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x832356E8; continue 'dispatch;
            }
            0x832356E8 => {
    //   block [0x832356E8..0x832356F0)
	// 832356E8: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 832356EC: 4B24B0DC  b 0x824807c8
	sub_824807C8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832356F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832356F0 size=40
    let mut pc: u32 = 0x832356F0;
    'dispatch: loop {
        match pc {
            0x832356F0 => {
    //   block [0x832356F0..0x8323570C)
	// 832356F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 832356F4: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 832356F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832356FC: 409A0010  bne cr6, 0x8323570c
	if !ctx.cr[6].eq {
	pc = 0x8323570C; continue 'dispatch;
	}
	// 83235700: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 83235704: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 83235708: 48000008  b 0x83235710
	pc = 0x83235710; continue 'dispatch;
            }
            0x8323570C => {
    //   block [0x8323570C..0x83235710)
	// 8323570C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x83235710; continue 'dispatch;
            }
            0x83235710 => {
    //   block [0x83235710..0x83235718)
	// 83235710: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 83235714: 4B24B13C  b 0x82480850
	sub_82480850(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83235718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83235718 size=16
    let mut pc: u32 = 0x83235718;
    'dispatch: loop {
        match pc {
            0x83235718 => {
    //   block [0x83235718..0x83235728)
	// 83235718: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8323571C: 394BF1BC  addi r10, r11, -0xe44
	ctx.r[10].s64 = ctx.r[11].s64 + -3652;
	// 83235720: 806A002C  lwz r3, 0x2c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 83235724: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83235728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83235728 size=16
    let mut pc: u32 = 0x83235728;
    'dispatch: loop {
        match pc {
            0x83235728 => {
    //   block [0x83235728..0x83235738)
	// 83235728: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8323572C: 396BF1BC  addi r11, r11, -0xe44
	ctx.r[11].s64 = ctx.r[11].s64 + -3652;
	// 83235730: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 83235734: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83235738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x83235738 size=16
    let mut pc: u32 = 0x83235738;
    'dispatch: loop {
        match pc {
            0x83235738 => {
    //   block [0x83235738..0x83235748)
	// 83235738: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8323573C: 394BF1BC  addi r10, r11, -0xe44
	ctx.r[10].s64 = ctx.r[11].s64 + -3652;
	// 83235740: D02A0028  stfs f1, 0x28(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 83235744: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83235748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x83235748 size=16
    let mut pc: u32 = 0x83235748;
    'dispatch: loop {
        match pc {
            0x83235748 => {
    //   block [0x83235748..0x83235758)
	// 83235748: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8323574C: 394BF1BC  addi r10, r11, -0xe44
	ctx.r[10].s64 = ctx.r[11].s64 + -3652;
	// 83235750: C02A0028  lfs f1, 0x28(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 83235754: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83235758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x83235758 size=16
    let mut pc: u32 = 0x83235758;
    'dispatch: loop {
        match pc {
            0x83235758 => {
    //   block [0x83235758..0x83235768)
	// 83235758: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8323575C: 394BF1BC  addi r10, r11, -0xe44
	ctx.r[10].s64 = ctx.r[11].s64 + -3652;
	// 83235760: C02A0024  lfs f1, 0x24(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 83235764: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83235768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x83235768 size=32
    let mut pc: u32 = 0x83235768;
    'dispatch: loop {
        match pc {
            0x83235768 => {
    //   block [0x83235768..0x83235788)
	// 83235768: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8323576C: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 83235770: 394AF1BC  addi r10, r10, -0xe44
	ctx.r[10].s64 = ctx.r[10].s64 + -3652;
	// 83235774: 816B6DD4  lwz r11, 0x6dd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28116 as u32) ) } as u64;
	// 83235778: 392A0018  addi r9, r10, 0x18
	ctx.r[9].s64 = ctx.r[10].s64 + 24;
	// 8323577C: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 83235780: 7C284C2E  lfsx f1, r8, r9
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 83235784: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83235788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x83235788 size=32
    let mut pc: u32 = 0x83235788;
    'dispatch: loop {
        match pc {
            0x83235788 => {
    //   block [0x83235788..0x832357A8)
	// 83235788: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8323578C: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 83235790: 394AF1BC  addi r10, r10, -0xe44
	ctx.r[10].s64 = ctx.r[10].s64 + -3652;
	// 83235794: 816B6DD4  lwz r11, 0x6dd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28116 as u32) ) } as u64;
	// 83235798: 392A0010  addi r9, r10, 0x10
	ctx.r[9].s64 = ctx.r[10].s64 + 16;
	// 8323579C: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 832357A0: 7C284C2E  lfsx f1, r8, r9
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 832357A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832357A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x832357A8 size=32
    let mut pc: u32 = 0x832357A8;
    'dispatch: loop {
        match pc {
            0x832357A8 => {
    //   block [0x832357A8..0x832357C8)
	// 832357A8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 832357AC: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 832357B0: 394AF1BC  addi r10, r10, -0xe44
	ctx.r[10].s64 = ctx.r[10].s64 + -3652;
	// 832357B4: 816B6DD4  lwz r11, 0x6dd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28116 as u32) ) } as u64;
	// 832357B8: 392A0008  addi r9, r10, 8
	ctx.r[9].s64 = ctx.r[10].s64 + 8;
	// 832357BC: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 832357C0: 7C284C2E  lfsx f1, r8, r9
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 832357C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832357C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x832357C8 size=28
    let mut pc: u32 = 0x832357C8;
    'dispatch: loop {
        match pc {
            0x832357C8 => {
    //   block [0x832357C8..0x832357E4)
	// 832357C8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 832357CC: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 832357D0: 392AF1BC  addi r9, r10, -0xe44
	ctx.r[9].s64 = ctx.r[10].s64 + -3652;
	// 832357D4: 816B6DD4  lwz r11, 0x6dd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28116 as u32) ) } as u64;
	// 832357D8: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 832357DC: 7C284C2E  lfsx f1, r8, r9
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 832357E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832357E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832357E8 size=60
    let mut pc: u32 = 0x832357E8;
    'dispatch: loop {
        match pc {
            0x832357E8 => {
    //   block [0x832357E8..0x83235824)
	// 832357E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832357EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832357F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832357F4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832357F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 832357FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 83235800: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 83235804: 4B7EC10D  bl 0x82a21910
	ctx.lr = 0x83235808;
	sub_82A21910(ctx, base);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83235828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x83235828 size=212
    let mut pc: u32 = 0x83235828;
    'dispatch: loop {
        match pc {
            0x83235828 => {
    //   block [0x83235828..0x83235898)
	// 83235828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323582C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83235830: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 83235834: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 83235838: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323583C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83235840: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 83235844: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 83235848: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 8323584C: 4198004C  blt cr6, 0x83235898
	if ctx.cr[6].lt {
	pc = 0x83235898; continue 'dispatch;
	}
	// 83235850: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 83235854: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 83235858: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323585C: 38EAFFFC  addi r7, r10, -4
	ctx.r[7].s64 = ctx.r[10].s64 + -4;
	// 83235860: 38CB0004  addi r6, r11, 4
	ctx.r[6].s64 = ctx.r[11].s64 + 4;
	// 83235864: 38A90004  addi r5, r9, 4
	ctx.r[5].s64 = ctx.r[9].s64 + 4;
	// 83235868: 888B0000  lbz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323586C: 98880000  stb r4, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[4].u8 ) };
	// 83235870: 886B0001  lbz r3, 1(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 83235874: 98680001  stb r3, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[3].u8 ) };
	// 83235878: 894B0002  lbz r10, 2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 8323587C: 99480002  stb r10, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[10].u8 ) };
	// 83235880: 892B0003  lbz r9, 3(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 83235884: 99280003  stb r9, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[9].u8 ) };
	// 83235888: 90DF000C  stw r6, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[6].u32 ) };
	// 8323588C: 90FF0014  stw r7, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	// 83235890: 90BF0004  stw r5, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 83235894: 48000014  b 0x832358a8
	pc = 0x832358A8; continue 'dispatch;
            }
            0x83235898 => {
    //   block [0x83235898..0x832358A8)
	// 83235898: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 8323589C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 832358A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832358A4: 4B7EB645  bl 0x82a20ee8
	ctx.lr = 0x832358A8;
	sub_82A20EE8(ctx, base);
	pc = 0x832358A8; continue 'dispatch;
            }
            0x832358A8 => {
    //   block [0x832358A8..0x832358E0)
	// 832358A8: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 832358AC: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 832358B0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 832358B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832358B8: 419A0028  beq cr6, 0x832358e0
	if ctx.cr[6].eq {
	pc = 0x832358E0; continue 'dispatch;
	}
	// 832358BC: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 832358C0: 89410051  lbz r10, 0x51(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 832358C4: 89210053  lbz r9, 0x53(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(83 as u32) ) } as u64;
	// 832358C8: 89010052  lbz r8, 0x52(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 832358CC: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 832358D0: 99410052  stb r10, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[10].u8 ) };
	// 832358D4: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 832358D8: 99010051  stb r8, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[8].u8 ) };
	// 832358DC: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x832358E0; continue 'dispatch;
            }
            0x832358E0 => {
    //   block [0x832358E0..0x832358FC)
	// 832358E0: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 832358E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832358E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832358EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832358F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832358F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832358F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83235928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83235928 size=28
    let mut pc: u32 = 0x83235928;
    'dispatch: loop {
        match pc {
            0x83235928 => {
    //   block [0x83235928..0x83235944)
	// 83235928: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323592C: 81030004  lwz r8, 4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 83235930: 7D685050  subf r11, r8, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 83235934: 7D6B2671  srawi. r11, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 4) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 83235938: 4181000C  bgt 0x83235944
	if ctx.cr[0].gt {
		sub_83235944(ctx, base);
		return;
	}
	// 8323593C: 1020038C  vspltisw v1, 0
	for i in 0..4 {
		ctx.v[1].u32[i] = 0;
	}
	// 83235940: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83235944(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83235944 size=16
    let mut pc: u32 = 0x83235944;
    'dispatch: loop {
        match pc {
            0x83235944 => {
    //   block [0x83235944..0x83235954)
	// 83235944: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 83235948: 409A000C  bne cr6, 0x83235954
	if !ctx.cr[6].eq {
		sub_83235954(ctx, base);
		return;
	}
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83235954(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x83235954 size=44
    let mut pc: u32 = 0x83235954;
    'dispatch: loop {
        match pc {
            0x83235954 => {
    //   block [0x83235954..0x83235980)
	// 83235954: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 83235958: 38E9CBBC  addi r7, r9, -0x3444
	ctx.r[7].s64 = ctx.r[9].s64 + -13380;
	// 8323595C: C007C8C8  lfs f0, -0x3738(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-14136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 83235960: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 83235964: 4099FFE8  ble cr6, 0x8323594c
	if !ctx.cr[6].gt {
		sub_83235944(ctx, base);
		return;
	}
	// 83235968: C007C8D4  lfs f0, -0x372c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-14124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323596C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 83235970: 41980010  blt cr6, 0x83235980
	if ctx.cr[6].lt {
		sub_83235980(ctx, base);
		return;
	}
	// 83235974: 396AFFF0  addi r11, r10, -0x10
	ctx.r[11].s64 = ctx.r[10].s64 + -16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83235980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83235980 size=520
    let mut pc: u32 = 0x83235980;
    'dispatch: loop {
        match pc {
            0x83235980 => {
    //   block [0x83235980..0x832359A4)
	// 83235980: 54AA063E  clrlwi r10, r5, 0x18
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 83235984: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83235988: 419A001C  beq cr6, 0x832359a4
	if ctx.cr[6].eq {
	pc = 0x832359A4; continue 'dispatch;
	}
	// 8323598C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 83235990: 40990014  ble cr6, 0x832359a4
	if !ctx.cr[6].gt {
	pc = 0x832359A4; continue 'dispatch;
	}
	// 83235994: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 83235998: F921FFE8  std r9, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[9].u64 ) };
	// 8323599C: C801FFE8  lfd f0, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832359A0: 48000014  b 0x832359b4
	pc = 0x832359B4; continue 'dispatch;
            }
            0x832359A4 => {
    //   block [0x832359A4..0x832359B4)
	// 832359A4: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 832359A8: 7D2507B4  extsw r5, r9
	ctx.r[5].s64 = ctx.r[9].s32 as i64;
	// 832359AC: F8A1FFE8  std r5, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[5].u64 ) };
	// 832359B0: C801FFE8  lfd f0, -0x18(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	pc = 0x832359B4; continue 'dispatch;
            }
            0x832359B4 => {
    //   block [0x832359B4..0x83235A10)
	// 832359B4: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 832359B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832359BC: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 832359C0: ED6C0072  fmuls f11, f12, f1
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[1].f64) as f32) as f64);
	// 832359C4: FC00581E  fctiwz f0, f11
	ctx.f[0].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 832359C8: D801FFE8  stfd f0, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[0].u64 ) };
	// 832359CC: 8121FFEC  lwz r9, -0x14(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-20 as u32) ) } as u64;
	// 832359D0: 419A00B0  beq cr6, 0x83235a80
	if ctx.cr[6].eq {
	pc = 0x83235A80; continue 'dispatch;
	}
	// 832359D4: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 832359D8: 409900A8  ble cr6, 0x83235a80
	if !ctx.cr[6].gt {
	pc = 0x83235A80; continue 'dispatch;
	}
	// 832359DC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 832359E0: 409A0030  bne cr6, 0x83235a10
	if !ctx.cr[6].eq {
	pc = 0x83235A10; continue 'dispatch;
	}
	// 832359E4: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 832359E8: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832359EC: 3900FFF0  li r8, -0x10
	ctx.r[8].s64 = -16;
	// 832359F0: 7CAB5214  add r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 832359F4: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 832359F8: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	pc = 0x83235A10; continue 'dispatch;
            }
            0x83235A10 => {
    //   block [0x83235A10..0x83235A80)
	// 83235A10: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 83235A14: 390BFFFE  addi r8, r11, -2
	ctx.r[8].s64 = ctx.r[11].s64 + -2;
	// 83235A18: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 83235A1C: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 83235A20: 409A002C  bne cr6, 0x83235a4c
	if !ctx.cr[6].eq {
	pc = 0x83235A4C; continue 'dispatch;
	}
	// 83235A24: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	pc = 0x83235A80; continue 'dispatch;
            }
            0x83235A80 => {
    //   block [0x83235A80..0x83235B88)
	// 83235A80: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 83235A84: 409A0068  bne cr6, 0x83235aec
	if !ctx.cr[6].eq {
	pc = 0x83235AEC; continue 'dispatch;
	}
	// 83235A88: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 83235A8C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83235B88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x83235B88 size=276
    let mut pc: u32 = 0x83235B88;
    'dispatch: loop {
        match pc {
            0x83235B88 => {
    //   block [0x83235B88..0x83235C9C)
	// 83235B88: 3961FFD4  addi r11, r1, -0x2c
	ctx.r[11].s64 = ctx.r[1].s64 + -44;
	// 83235B8C: C1A70000  lfs f13, 0(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 83235B90: 3861FFD4  addi r3, r1, -0x2c
	ctx.r[3].s64 = ctx.r[1].s64 + -44;
	// 83235B94: D1A1FFD0  stfs f13, -0x30(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), tmp.u32 ) };
	// 83235B98: D1A1FFD8  stfs f13, -0x28(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), tmp.u32 ) };
	// 83235B9C: 3941FFDC  addi r10, r1, -0x24
	ctx.r[10].s64 = ctx.r[1].s64 + -36;
	// 83235BA0: C1A71BF0  lfs f13, 0x1bf0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(7152 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 83235BA4: 38C1FFD0  addi r6, r1, -0x30
	ctx.r[6].s64 = ctx.r[1].s64 + -48;
	// 83235BA8: D1A1FFD4  stfs f13, -0x2c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-44 as u32), tmp.u32 ) };
	// 83235BAC: 38A1FFD8  addi r5, r1, -0x28
	ctx.r[5].s64 = ctx.r[1].s64 + -40;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83235CA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x83235CA0 size=412
    let mut pc: u32 = 0x83235CA0;
    'dispatch: loop {
        match pc {
            0x83235CA0 => {
    //   block [0x83235CA0..0x83235CC4)
	// 83235CA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83235CA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83235CA8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83235CAC: 3CA08332  lis r5, -0x7cce
	ctx.r[5].s64 = -2093875200;
	// 83235CB0: 8145859C  lwz r10, -0x7a64(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-31332 as u32) ) } as u64;
	// 83235CB4: 2F0A010B  cmpwi cr6, r10, 0x10b
	ctx.cr[6].compare_i32(ctx.r[10].s32, 267, &mut ctx.xer);
	// 83235CB8: 390AFEF5  addi r8, r10, -0x10b
	ctx.r[8].s64 = ctx.r[10].s64 + -267;
	// 83235CBC: 40980008  bge cr6, 0x83235cc4
	if !ctx.cr[6].lt {
	pc = 0x83235CC4; continue 'dispatch;
	}
	// 83235CC0: 390A0067  addi r8, r10, 0x67
	ctx.r[8].s64 = ctx.r[10].s64 + 103;
	pc = 0x83235CC4; continue 'dispatch;
            }
            0x83235CC4 => {
    //   block [0x83235CC4..0x83235CF4)
	// 83235CC4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 83235CC8: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 83235CCC: 396BF1F8  addi r11, r11, -0xe08
	ctx.r[11].s64 = ctx.r[11].s64 + -3592;
	// 83235CD0: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 83235CD4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 83235CD8: 2F0A0172  cmpwi cr6, r10, 0x172
	ctx.cr[6].compare_i32(ctx.r[10].s32, 370, &mut ctx.xer);
	// 83235CDC: 7CE9582E  lwzx r7, r9, r11
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 83235CE0: 7CC8582E  lwzx r6, r8, r11
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 83235CE4: 7CC63A78  xor r6, r6, r7
	ctx.r[6].u64 = ctx.r[6].u64 ^ ctx.r[7].u64;
	// 83235CE8: 7CC9592E  stwx r6, r9, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u32) };
	// 83235CEC: 41980008  blt cr6, 0x83235cf4
	if ctx.cr[6].lt {
	pc = 0x83235CF4; continue 'dispatch;
	}
	// 83235CF0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x83235CF4; continue 'dispatch;
            }
            0x83235CF4 => {
    //   block [0x83235CF4..0x83235D04)
	// 83235CF4: 2F0A010B  cmpwi cr6, r10, 0x10b
	ctx.cr[6].compare_i32(ctx.r[10].s32, 267, &mut ctx.xer);
	// 83235CF8: 390AFEF5  addi r8, r10, -0x10b
	ctx.r[8].s64 = ctx.r[10].s64 + -267;
	// 83235CFC: 40980008  bge cr6, 0x83235d04
	if !ctx.cr[6].lt {
	pc = 0x83235D04; continue 'dispatch;
	}
	// 83235D00: 390A0067  addi r8, r10, 0x67
	ctx.r[8].s64 = ctx.r[10].s64 + 103;
	pc = 0x83235D04; continue 'dispatch;
            }
            0x83235D04 => {
    //   block [0x83235D04..0x83235D2C)
	// 83235D04: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 83235D08: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 83235D0C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 83235D10: 2F0A0172  cmpwi cr6, r10, 0x172
	ctx.cr[6].compare_i32(ctx.r[10].s32, 370, &mut ctx.xer);
	// 83235D14: 7CE9582E  lwzx r7, r9, r11
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 83235D18: 7C88582E  lwzx r4, r8, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 83235D1C: 7C873A78  xor r7, r4, r7
	ctx.r[7].u64 = ctx.r[4].u64 ^ ctx.r[7].u64;
	// 83235D20: 7CE9592E  stwx r7, r9, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 83235D24: 41980008  blt cr6, 0x83235d2c
	if ctx.cr[6].lt {
	pc = 0x83235D2C; continue 'dispatch;
	}
	// 83235D28: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x83235D2C; continue 'dispatch;
            }
            0x83235D2C => {
    //   block [0x83235D2C..0x83235D3C)
	// 83235D2C: 2F0A010B  cmpwi cr6, r10, 0x10b
	ctx.cr[6].compare_i32(ctx.r[10].s32, 267, &mut ctx.xer);
	// 83235D30: 390AFEF5  addi r8, r10, -0x10b
	ctx.r[8].s64 = ctx.r[10].s64 + -267;
	// 83235D34: 40980008  bge cr6, 0x83235d3c
	if !ctx.cr[6].lt {
	pc = 0x83235D3C; continue 'dispatch;
	}
	// 83235D38: 390A0067  addi r8, r10, 0x67
	ctx.r[8].s64 = ctx.r[10].s64 + 103;
	pc = 0x83235D3C; continue 'dispatch;
            }
            0x83235D3C => {
    //   block [0x83235D3C..0x83235D6C)
	// 83235D3C: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 83235D40: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 83235D44: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 83235D48: 2F0A0172  cmpwi cr6, r10, 0x172
	ctx.cr[6].compare_i32(ctx.r[10].s32, 370, &mut ctx.xer);
	// 83235D4C: 7C89582E  lwzx r4, r9, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 83235D50: 7C68582E  lwzx r3, r8, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 83235D54: 7C682278  xor r8, r3, r4
	ctx.r[8].u64 = ctx.r[3].u64 ^ ctx.r[4].u64;
	// 83235D58: 7D09592E  stwx r8, r9, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[8].u32) };
	// 83235D5C: 41980010  blt cr6, 0x83235d6c
	if ctx.cr[6].lt {
	pc = 0x83235D6C; continue 'dispatch;
	}
	// 83235D60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 83235D64: 9165859C  stw r11, -0x7a64(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(-31332 as u32), ctx.r[11].u32 ) };
	// 83235D68: 48000008  b 0x83235d70
	pc = 0x83235D70; continue 'dispatch;
            }
            0x83235D6C => {
    //   block [0x83235D6C..0x83235D70)
	// 83235D6C: 9145859C  stw r10, -0x7a64(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(-31332 as u32), ctx.r[10].u32 ) };
	pc = 0x83235D70; continue 'dispatch;
            }
            0x83235D70 => {
    //   block [0x83235D70..0x83235E3C)
	// 83235D70: 550B023E  clrlwi r11, r8, 8
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 83235D74: 54EA023E  clrlwi r10, r7, 8
	ctx.r[10].u64 = ctx.r[7].u32 as u64 & 0x00FFFFFFu64;
	// 83235D78: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 83235D7C: C9810060  lfd f12, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 83235D80: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 83235D84: C9610060  lfd f11, 0x60(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 83235D88: 54C9023E  clrlwi r9, r6, 8
	ctx.r[9].u64 = ctx.r[6].u32 as u64 & 0x00FFFFFFu64;
	// 83235D8C: FCC0669C  fcfid f6, f12
	ctx.f[6].f64 = (ctx.f[12].s64 as f64);
	// 83235D90: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 83235D94: C9410060  lfd f10, 0x60(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 83235D98: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 83235D9C: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 83235DA0: FCE05E9C  fcfid f7, f11
	ctx.f[7].f64 = (ctx.f[11].s64 as f64);
	// 83235DA4: 38C89490  addi r6, r8, -0x6b70
	ctx.r[6].s64 = ctx.r[8].s64 + -27504;
	// 83235DA8: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 83235DAC: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 83235DB0: FC603018  frsp f3, f6
	ctx.f[3].f64 = (ctx.f[6].f64 as f32) as f64;
	// 83235DB4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 83235DB8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 83235DBC: C1A89490  lfs f13, -0x6b70(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 83235DC0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 83235DC4: C186FFF4  lfs f12, -0xc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 83235DC8: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 83235DCC: C0070C38  lfs f0, 0xc38(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(3128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 83235DD0: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 83235DD4: D1810050  stfs f12, 0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 83235DD8: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83235E40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x83235E40 size=412
    let mut pc: u32 = 0x83235E40;
    'dispatch: loop {
        match pc {
            0x83235E40 => {
    //   block [0x83235E40..0x83235E64)
	// 83235E40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83235E44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83235E48: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83235E4C: 3CA08332  lis r5, -0x7cce
	ctx.r[5].s64 = -2093875200;
	// 83235E50: 8145859C  lwz r10, -0x7a64(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-31332 as u32) ) } as u64;
	// 83235E54: 2F0A010B  cmpwi cr6, r10, 0x10b
	ctx.cr[6].compare_i32(ctx.r[10].s32, 267, &mut ctx.xer);
	// 83235E58: 390AFEF5  addi r8, r10, -0x10b
	ctx.r[8].s64 = ctx.r[10].s64 + -267;
	// 83235E5C: 40980008  bge cr6, 0x83235e64
	if !ctx.cr[6].lt {
	pc = 0x83235E64; continue 'dispatch;
	}
	// 83235E60: 390A0067  addi r8, r10, 0x67
	ctx.r[8].s64 = ctx.r[10].s64 + 103;
	pc = 0x83235E64; continue 'dispatch;
            }
            0x83235E64 => {
    //   block [0x83235E64..0x83235E94)
	// 83235E64: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 83235E68: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 83235E6C: 396BF1F8  addi r11, r11, -0xe08
	ctx.r[11].s64 = ctx.r[11].s64 + -3592;
	// 83235E70: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 83235E74: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 83235E78: 2F0A0172  cmpwi cr6, r10, 0x172
	ctx.cr[6].compare_i32(ctx.r[10].s32, 370, &mut ctx.xer);
	// 83235E7C: 7CE9582E  lwzx r7, r9, r11
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 83235E80: 7CC8582E  lwzx r6, r8, r11
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 83235E84: 7CC63A78  xor r6, r6, r7
	ctx.r[6].u64 = ctx.r[6].u64 ^ ctx.r[7].u64;
	// 83235E88: 7CC9592E  stwx r6, r9, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u32) };
	// 83235E8C: 41980008  blt cr6, 0x83235e94
	if ctx.cr[6].lt {
	pc = 0x83235E94; continue 'dispatch;
	}
	// 83235E90: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x83235E94; continue 'dispatch;
            }
            0x83235E94 => {
    //   block [0x83235E94..0x83235EA4)
	// 83235E94: 2F0A010B  cmpwi cr6, r10, 0x10b
	ctx.cr[6].compare_i32(ctx.r[10].s32, 267, &mut ctx.xer);
	// 83235E98: 390AFEF5  addi r8, r10, -0x10b
	ctx.r[8].s64 = ctx.r[10].s64 + -267;
	// 83235E9C: 40980008  bge cr6, 0x83235ea4
	if !ctx.cr[6].lt {
	pc = 0x83235EA4; continue 'dispatch;
	}
	// 83235EA0: 390A0067  addi r8, r10, 0x67
	ctx.r[8].s64 = ctx.r[10].s64 + 103;
	pc = 0x83235EA4; continue 'dispatch;
            }
            0x83235EA4 => {
    //   block [0x83235EA4..0x83235ECC)
	// 83235EA4: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 83235EA8: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 83235EAC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 83235EB0: 2F0A0172  cmpwi cr6, r10, 0x172
	ctx.cr[6].compare_i32(ctx.r[10].s32, 370, &mut ctx.xer);
	// 83235EB4: 7CE9582E  lwzx r7, r9, r11
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 83235EB8: 7C88582E  lwzx r4, r8, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 83235EBC: 7C873A78  xor r7, r4, r7
	ctx.r[7].u64 = ctx.r[4].u64 ^ ctx.r[7].u64;
	// 83235EC0: 7CE9592E  stwx r7, r9, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 83235EC4: 41980008  blt cr6, 0x83235ecc
	if ctx.cr[6].lt {
	pc = 0x83235ECC; continue 'dispatch;
	}
	// 83235EC8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x83235ECC; continue 'dispatch;
            }
            0x83235ECC => {
    //   block [0x83235ECC..0x83235EDC)
	// 83235ECC: 2F0A010B  cmpwi cr6, r10, 0x10b
	ctx.cr[6].compare_i32(ctx.r[10].s32, 267, &mut ctx.xer);
	// 83235ED0: 390AFEF5  addi r8, r10, -0x10b
	ctx.r[8].s64 = ctx.r[10].s64 + -267;
	// 83235ED4: 40980008  bge cr6, 0x83235edc
	if !ctx.cr[6].lt {
	pc = 0x83235EDC; continue 'dispatch;
	}
	// 83235ED8: 390A0067  addi r8, r10, 0x67
	ctx.r[8].s64 = ctx.r[10].s64 + 103;
	pc = 0x83235EDC; continue 'dispatch;
            }
            0x83235EDC => {
    //   block [0x83235EDC..0x83235F0C)
	// 83235EDC: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 83235EE0: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 83235EE4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 83235EE8: 2F0A0172  cmpwi cr6, r10, 0x172
	ctx.cr[6].compare_i32(ctx.r[10].s32, 370, &mut ctx.xer);
	// 83235EEC: 7C89582E  lwzx r4, r9, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 83235EF0: 7C68582E  lwzx r3, r8, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 83235EF4: 7C682278  xor r8, r3, r4
	ctx.r[8].u64 = ctx.r[3].u64 ^ ctx.r[4].u64;
	// 83235EF8: 7D09592E  stwx r8, r9, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[8].u32) };
	// 83235EFC: 41980010  blt cr6, 0x83235f0c
	if ctx.cr[6].lt {
	pc = 0x83235F0C; continue 'dispatch;
	}
	// 83235F00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 83235F04: 9165859C  stw r11, -0x7a64(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(-31332 as u32), ctx.r[11].u32 ) };
	// 83235F08: 48000008  b 0x83235f10
	pc = 0x83235F10; continue 'dispatch;
            }
            0x83235F0C => {
    //   block [0x83235F0C..0x83235F10)
	// 83235F0C: 9145859C  stw r10, -0x7a64(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(-31332 as u32), ctx.r[10].u32 ) };
	pc = 0x83235F10; continue 'dispatch;
            }
            0x83235F10 => {
    //   block [0x83235F10..0x83235FDC)
	// 83235F10: 550B023E  clrlwi r11, r8, 8
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 83235F14: 54EA023E  clrlwi r10, r7, 8
	ctx.r[10].u64 = ctx.r[7].u32 as u64 & 0x00FFFFFFu64;
	// 83235F18: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 83235F1C: C9810060  lfd f12, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 83235F20: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 83235F24: C9610060  lfd f11, 0x60(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 83235F28: 54C9023E  clrlwi r9, r6, 8
	ctx.r[9].u64 = ctx.r[6].u32 as u64 & 0x00FFFFFFu64;
	// 83235F2C: FCC0669C  fcfid f6, f12
	ctx.f[6].f64 = (ctx.f[12].s64 as f64);
	// 83235F30: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 83235F34: C9410060  lfd f10, 0x60(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 83235F38: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 83235F3C: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 83235F40: FCE05E9C  fcfid f7, f11
	ctx.f[7].f64 = (ctx.f[11].s64 as f64);
	// 83235F44: 38C89490  addi r6, r8, -0x6b70
	ctx.r[6].s64 = ctx.r[8].s64 + -27504;
	// 83235F48: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 83235F4C: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 83235F50: FC603018  frsp f3, f6
	ctx.f[3].f64 = (ctx.f[6].f64 as f32) as f64;
	// 83235F54: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 83235F58: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 83235F5C: C1A89490  lfs f13, -0x6b70(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 83235F60: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 83235F64: C186FFF4  lfs f12, -0xc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 83235F68: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 83235F6C: C0070C38  lfs f0, 0xc38(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(3128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 83235F70: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 83235F74: D1810050  stfs f12, 0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 83235F78: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83235FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83235FE0 size=156
    let mut pc: u32 = 0x83235FE0;
    'dispatch: loop {
        match pc {
            0x83235FE0 => {
    //   block [0x83235FE0..0x8323607C)
	// 83235FE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83235FE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83235FE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 83235FEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 83235FF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83235FF4: 3FE0834C  lis r31, -0x7cb4
	ctx.r[31].s64 = -2092171264;
	// 83235FF8: 387FE8C0  addi r3, r31, -0x1740
	ctx.r[3].s64 = ctx.r[31].s64 + -5952;
	// 83235FFC: 4B9B4745  bl 0x82bea740
	ctx.lr = 0x83236000;
	sub_82BEA740(ctx, base);
	// 83236000: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 83236004: 3FC0834C  lis r30, -0x7cb4
	ctx.r[30].s64 = -2092171264;
	// 83236008: 917FE8C0  stw r11, -0x1740(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-5952 as u32), ctx.r[11].u32 ) };
	// 8323600C: 387EE8C8  addi r3, r30, -0x1738
	ctx.r[3].s64 = ctx.r[30].s64 + -5944;
	// 83236010: 4B9B4849  bl 0x82bea858
	ctx.lr = 0x83236014;
	sub_82BEA858(ctx, base);
	// 83236014: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 83236018: 3FE0834C  lis r31, -0x7cb4
	ctx.r[31].s64 = -2092171264;
	// 8323601C: 917EE8C8  stw r11, -0x1738(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-5944 as u32), ctx.r[11].u32 ) };
	// 83236020: 387FE8D0  addi r3, r31, -0x1730
	ctx.r[3].s64 = ctx.r[31].s64 + -5936;
	// 83236024: 4B9B494D  bl 0x82bea970
	ctx.lr = 0x83236028;
	sub_82BEA970(ctx, base);
	// 83236028: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8323602C: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 83236030: 917FE8D0  stw r11, -0x1730(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-5936 as u32), ctx.r[11].u32 ) };
	// 83236034: 396AE63C  addi r11, r10, -0x19c4
	ctx.r[11].s64 = ctx.r[10].s64 + -6596;
	// 83236038: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 8323603C: 4B0DD95D  bl 0x82313998
	ctx.lr = 0x83236040;
	sub_82313998(ctx, base);
	// 83236040: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 83236044: 3969E688  addi r11, r9, -0x1978
	ctx.r[11].s64 = ctx.r[9].s64 + -6520;
	// 83236048: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 8323604C: 4B0DD94D  bl 0x82313998
	ctx.lr = 0x83236050;
	sub_82313998(ctx, base);
	// 83236050: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 83236054: 3968E568  addi r11, r8, -0x1a98
	ctx.r[11].s64 = ctx.r[8].s64 + -6808;
	// 83236058: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 8323605C: 4B0DD93D  bl 0x82313998
	ctx.lr = 0x83236060;
	sub_82313998(ctx, base);
	// 83236060: 4BFFE841  bl 0x832348a0
	ctx.lr = 0x83236064;
	sub_832348A0(ctx, base);
	// 83236064: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 83236068: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8323606C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83236070: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 83236074: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 83236078: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83236080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x83236080 size=228
    let mut pc: u32 = 0x83236080;
    'dispatch: loop {
        match pc {
            0x83236080 => {
    //   block [0x83236080..0x83236164)
	// 83236080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83236084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83236088: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8323608C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 83236090: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83236094: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 83236098: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8323609C: 4B9B461D  bl 0x82bea6b8
	ctx.lr = 0x832360A0;
	sub_82BEA6B8(ctx, base);
	// 832360A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832360A4: 4B9B472D  bl 0x82bea7d0
	ctx.lr = 0x832360A8;
	sub_82BEA7D0(ctx, base);
	// 832360A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832360AC: 4B9B483D  bl 0x82bea8e8
	ctx.lr = 0x832360B0;
	sub_82BEA8E8(ctx, base);
	// 832360B0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832360B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 832360B8: 808BE678  lwz r4, -0x1988(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6536 as u32) ) } as u64;
	// 832360BC: 4BFF0C35  bl 0x83226cf0
	ctx.lr = 0x832360C0;
	sub_83226CF0(ctx, base);
	// 832360C0: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 832360C4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 832360C8: 388AE674  addi r4, r10, -0x198c
	ctx.r[4].s64 = ctx.r[10].s64 + -6540;
	// 832360CC: 48005D4D  bl 0x8323be18
	ctx.lr = 0x832360D0;
	sub_8323BE18(ctx, base);
	// 832360D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 832360D4: 4AF81A45  bl 0x821b7b18
	ctx.lr = 0x832360D8;
	sub_821B7B18(ctx, base);
	// 832360D8: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 832360DC: 3D008336  lis r8, -0x7cca
	ctx.r[8].s64 = -2093613056;
	// 832360E0: 38E9B480  addi r7, r9, -0x4b80
	ctx.r[7].s64 = ctx.r[9].s64 + -19328;
	// 832360E4: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 832360E8: 38A8F1BC  addi r5, r8, -0xe44
	ctx.r[5].s64 = ctx.r[8].s64 + -3652;
	// 832360EC: 3C808349  lis r4, -0x7cb7
	ctx.r[4].s64 = -2092367872;
	// 832360F0: C129B480  lfs f9, -0x4b80(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-19328 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 832360F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 832360F8: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 832360FC: C1A7DE24  lfs f13, -0x21dc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-8668 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 83236100: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 83236104: C0060B8C  lfs f0, 0xb8c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(2956 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 83236108: C187E010  lfs f12, -0x1ff0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-8176 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8323610C: 9165002C  stw r11, 0x2c(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 83236110: C1672294  lfs f11, 0x2294(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8852 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 83236114: 91450030  stw r10, 0x30(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 83236118: C147E058  lfs f10, -0x1fa8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-8104 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8323611C: 91246DCC  stw r9, 0x6dcc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(28108 as u32), ctx.r[9].u32 ) };
	// 83236120: D1A50020  stfs f13, 0x20(r5)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 83236124: D0050024  stfs f0, 0x24(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 83236128: D1850028  stfs f12, 0x28(r5)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 8323612C: D148F1BC  stfs f10, -0xe44(r8)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(-3652 as u32), tmp.u32 ) };
	// 83236130: D1650008  stfs f11, 8(r5)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 83236134: D1650010  stfs f11, 0x10(r5)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 83236138: D1250018  stfs f9, 0x18(r5)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8323613C: D1A50004  stfs f13, 4(r5)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 83236140: D005000C  stfs f0, 0xc(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 83236144: D0050014  stfs f0, 0x14(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 83236148: D185001C  stfs f12, 0x1c(r5)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8323614C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 83236150: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 83236154: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83236158: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8323615C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 83236160: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83236168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83236168 size=36
    let mut pc: u32 = 0x83236168;
    'dispatch: loop {
        match pc {
            0x83236168 => {
    //   block [0x83236168..0x8323618C)
	// 83236168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323616C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83236170: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83236174: 4BFFEAC5  bl 0x83234c38
	ctx.lr = 0x83236178;
	sub_83234C38(ctx, base);
	// 83236178: 4B088A01  bl 0x822beb78
	ctx.lr = 0x8323617C;
	sub_822BEB78(ctx, base);
	// 8323617C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 83236180: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 83236184: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83236188: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83236190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83236190 size=40
    let mut pc: u32 = 0x83236190;
    'dispatch: loop {
        match pc {
            0x83236190 => {
    //   block [0x83236190..0x832361B8)
	// 83236190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83236194: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83236198: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323619C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 832361A0: 4BFFEA99  bl 0x83234c38
	ctx.lr = 0x832361A4;
	sub_83234C38(ctx, base);
	// 832361A4: 4B0889D5  bl 0x822beb78
	ctx.lr = 0x832361A8;
	sub_822BEB78(ctx, base);
	// 832361A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832361AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832361B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832361B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832361B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832361B8 size=344
    let mut pc: u32 = 0x832361B8;
    'dispatch: loop {
        match pc {
            0x832361B8 => {
    //   block [0x832361B8..0x832361F4)
	// 832361B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832361BC: 4BA73249  bl 0x82ca9404
	ctx.lr = 0x832361C0;
	sub_82CA93D0(ctx, base);
	// 832361C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832361C4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832361C8: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 832361CC: 3BCBE46C  addi r30, r11, -0x1b94
	ctx.r[30].s64 = ctx.r[11].s64 + -7060;
	// 832361D0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 832361D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832361D8: 816BE46C  lwz r11, -0x1b94(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7060 as u32) ) } as u64;
	// 832361DC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 832361E0: 837D6DD4  lwz r27, 0x6dd4(r29)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28116 as u32) ) } as u64;
	// 832361E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832361E8: 915D6DD4  stw r10, 0x6dd4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28116 as u32), ctx.r[10].u32 ) };
	// 832361EC: 419A0008  beq cr6, 0x832361f4
	if ctx.cr[6].eq {
	pc = 0x832361F4; continue 'dispatch;
	}
	// 832361F0: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x832361F4; continue 'dispatch;
            }
            0x832361F4 => {
    //   block [0x832361F4..0x83236278)
	// 832361F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 832361F8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 832361FC: 4B7EB135  bl 0x82a21330
	ctx.lr = 0x83236200;
	sub_82A21330(ctx, base);
	// 83236200: 3F808332  lis r28, -0x7cce
	ctx.r[28].s64 = -2093875200;
	// 83236204: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 83236208: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8323620C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 83236210: 917CA91C  stw r11, -0x56e4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(-22244 as u32), ctx.r[11].u32 ) };
	// 83236214: 4B907C35  bl 0x82b3de48
	ctx.lr = 0x83236218;
	sub_82B3DE48(ctx, base);
	// 83236218: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8323621C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83236220: 409A00E0  bne cr6, 0x83236300
	if !ctx.cr[6].eq {
	pc = 0x83236300; continue 'dispatch;
	}
	// 83236224: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 83236228: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 8323622C: 4198004C  blt cr6, 0x83236278
	if ctx.cr[6].lt {
	pc = 0x83236278; continue 'dispatch;
	}
	// 83236230: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 83236234: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 83236238: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323623C: 38EAFFFC  addi r7, r10, -4
	ctx.r[7].s64 = ctx.r[10].s64 + -4;
	// 83236240: 38CB0004  addi r6, r11, 4
	ctx.r[6].s64 = ctx.r[11].s64 + 4;
	// 83236244: 38A90004  addi r5, r9, 4
	ctx.r[5].s64 = ctx.r[9].s64 + 4;
	// 83236248: 888B0000  lbz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323624C: 98880000  stb r4, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[4].u8 ) };
	// 83236250: 886B0001  lbz r3, 1(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 83236254: 98680001  stb r3, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[3].u8 ) };
	// 83236258: 894B0002  lbz r10, 2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 8323625C: 99480002  stb r10, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[10].u8 ) };
	// 83236260: 892B0003  lbz r9, 3(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 83236264: 99280003  stb r9, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[9].u8 ) };
	// 83236268: 90DF000C  stw r6, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[6].u32 ) };
	// 8323626C: 90FF0014  stw r7, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	// 83236270: 90BF0004  stw r5, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 83236274: 48000014  b 0x83236288
	pc = 0x83236288; continue 'dispatch;
            }
            0x83236278 => {
    //   block [0x83236278..0x83236288)
	// 83236278: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 8323627C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 83236280: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83236284: 4B7EAC65  bl 0x82a20ee8
	ctx.lr = 0x83236288;
	sub_82A20EE8(ctx, base);
	pc = 0x83236288; continue 'dispatch;
            }
            0x83236288 => {
    //   block [0x83236288..0x832362BC)
	// 83236288: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323628C: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 83236290: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83236294: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 83236298: 419A0024  beq cr6, 0x832362bc
	if ctx.cr[6].eq {
	pc = 0x832362BC; continue 'dispatch;
	}
	// 8323629C: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 832362A0: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 832362A4: 89210057  lbz r9, 0x57(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(87 as u32) ) } as u64;
	// 832362A8: 89010054  lbz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 832362AC: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 832362B0: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 832362B4: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 832362B8: 99010053  stb r8, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[8].u8 ) };
	pc = 0x832362BC; continue 'dispatch;
            }
            0x832362BC => {
    //   block [0x832362BC..0x83236300)
	// 832362BC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 832362C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832362C4: 917CA91C  stw r11, -0x56e4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(-22244 as u32), ctx.r[11].u32 ) };
	// 832362C8: 4BFFD661  bl 0x83233928
	ctx.lr = 0x832362CC;
	sub_83233928(ctx, base);
	// 832362CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832362D0: 4BFF6579  bl 0x8322c848
	ctx.lr = 0x832362D4;
	sub_8322C848(ctx, base);
	// 832362D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832362D8: 4BFF6161  bl 0x8322c438
	ctx.lr = 0x832362DC;
	sub_8322C438(ctx, base);
	// 832362DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832362E0: 4BFF5CF9  bl 0x8322bfd8
	ctx.lr = 0x832362E4;
	sub_8322BFD8(ctx, base);
	// 832362E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832362E8: 4BFF9CA9  bl 0x8322ff90
	ctx.lr = 0x832362EC;
	sub_8322FF90(ctx, base);
	// 832362EC: 937D6DD4  stw r27, 0x6dd4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28116 as u32), ctx.r[27].u32 ) };
	// 832362F0: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 832362F4: 396AE63C  addi r11, r10, -0x19c4
	ctx.r[11].s64 = ctx.r[10].s64 + -6596;
	// 832362F8: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 832362FC: 4B0DD69D  bl 0x82313998
	ctx.lr = 0x83236300;
	sub_82313998(ctx, base);
	pc = 0x83236300; continue 'dispatch;
            }
            0x83236300 => {
    //   block [0x83236300..0x83236310)
	// 83236300: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 83236304: 4AFDEAD5  bl 0x82214dd8
	ctx.lr = 0x83236308;
	sub_82214DD8(ctx, base);
	// 83236308: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8323630C: 4BA73148  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83236318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83236318 size=96
    let mut pc: u32 = 0x83236318;
    'dispatch: loop {
        match pc {
            0x83236318 => {
    //   block [0x83236318..0x8323633C)
	// 83236318: 548B0026  rlwinm r11, r4, 0, 0, 0x13
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	// 8323631C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 83236320: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 83236324: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 83236328: 40820050  bne 0x83236378
	if !ctx.cr[0].eq {
		crate::recompiler::externs::call(ctx, base, 0x83236378);
		return;
	}
	// 8323632C: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 83236330: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 83236334: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83236338: 419A0014  beq cr6, 0x8323634c
	if ctx.cr[6].eq {
	pc = 0x8323634C; continue 'dispatch;
	}
	pc = 0x8323633C; continue 'dispatch;
            }
            0x8323633C => {
    //   block [0x8323633C..0x8323634C)
	// 8323633C: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 83236340: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 83236344: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83236348: 409AFFF4  bne cr6, 0x8323633c
	if !ctx.cr[6].eq {
	pc = 0x8323633C; continue 'dispatch;
	}
	pc = 0x8323634C; continue 'dispatch;
            }
            0x8323634C => {
    //   block [0x8323634C..0x83236360)
	// 8323634C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 83236350: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83236354: 419A000C  beq cr6, 0x83236360
	if ctx.cr[6].eq {
	pc = 0x83236360; continue 'dispatch;
	}
	// 83236358: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8323635C: 48000008  b 0x83236364
	pc = 0x83236364; continue 'dispatch;
            }
            0x83236360 => {
    //   block [0x83236360..0x83236364)
	// 83236360: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x83236364; continue 'dispatch;
            }
            0x83236364 => {
    //   block [0x83236364..0x83236378)
	// 83236364: 3CA00000  lis r5, 0
	ctx.r[5].s64 = 0;
	// 83236368: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8323636C: 60A58000  ori r5, r5, 0x8000
	ctx.r[5].u64 = ctx.r[5].u64 | 32768;
	// 83236370: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 83236374: 4BA911D4  b 0x82cc7548
	sub_82CC7548(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832363A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832363A8 size=260
    let mut pc: u32 = 0x832363A8;
    'dispatch: loop {
        match pc {
            0x832363A8 => {
    //   block [0x832363A8..0x83236400)
	// 832363A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832363AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832363B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832363B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832363B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832363BC: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 832363C0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 832363C4: 409A00A4  bne cr6, 0x83236468
	if !ctx.cr[6].eq {
	pc = 0x83236468; continue 'dispatch;
	}
	// 832363C8: 3CA00080  lis r5, 0x80
	ctx.r[5].s64 = 8388608;
	// 832363CC: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 832363D0: 60A51000  ori r5, r5, 0x1000
	ctx.r[5].u64 = ctx.r[5].u64 | 4096;
	// 832363D4: 38801000  li r4, 0x1000
	ctx.r[4].s64 = 4096;
	// 832363D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 832363DC: 4BA9111D  bl 0x82cc74f8
	ctx.lr = 0x832363E0;
	sub_82CC74F8(ctx, base);
	// 832363E0: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 832363E4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 832363E8: 409A0018  bne cr6, 0x83236400
	if !ctx.cr[6].eq {
	pc = 0x83236400; continue 'dispatch;
	}
	// 832363EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832363F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832363F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832363F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832363FC: 4E800020  blr
	return;
            }
            0x83236400 => {
    //   block [0x83236400..0x83236430)
	// 83236400: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83236404: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 83236408: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323640C: 390B000B  addi r8, r11, 0xb
	ctx.r[8].s64 = ctx.r[11].s64 + 11;
	// 83236410: 34EAFFFF  addic. r7, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 83236414: 7CC85B96  divwu r6, r8, r11
	ctx.r[6].u32 = ctx.r[8].u32 / ctx.r[11].u32;
	// 83236418: 0CCB0000  twi 6, r11, 0
	// 8323641C: 7D4659D6  mullw r10, r6, r11
	ctx.r[10].s32 = ((ctx.r[6].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 83236420: 7CCA4A14  add r6, r10, r9
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 83236424: 7CA82B78  mr r8, r5
	ctx.r[8].u64 = ctx.r[5].u64;
	// 83236428: 7CCA3378  mr r10, r6
	ctx.r[10].u64 = ctx.r[6].u64;
	// 8323642C: 41820028  beq 0x83236454
	if ctx.cr[0].eq {
	pc = 0x83236454; continue 'dispatch;
	}
	pc = 0x83236430; continue 'dispatch;
            }
            0x83236430 => {
    //   block [0x83236430..0x83236454)
	// 83236430: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 83236434: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 83236438: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8323643C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83236440: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83236444: 38E7FFFF  addi r7, r7, -1
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	// 83236448: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8323644C: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 83236450: 4198FFE0  blt cr6, 0x83236430
	if ctx.cr[6].lt {
	pc = 0x83236430; continue 'dispatch;
	}
	pc = 0x83236454; continue 'dispatch;
            }
            0x83236454 => {
    //   block [0x83236454..0x83236468)
	// 83236454: 90AA0000  stw r5, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 83236458: 90C90000  stw r6, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 8323645C: 90A90004  stw r5, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 83236460: 90A90008  stw r5, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 83236464: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x83236468; continue 'dispatch;
            }
            0x83236468 => {
    //   block [0x83236468..0x83236498)
	// 83236468: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323646C: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 83236470: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 83236474: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83236478: 91690008  stw r11, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8323647C: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 83236480: 5549003E  slwi r9, r10, 0
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 83236484: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83236488: 409A0010  bne cr6, 0x83236498
	if !ctx.cr[6].eq {
	pc = 0x83236498; continue 'dispatch;
	}
	// 8323648C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83236490: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 83236494: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x83236498; continue 'dispatch;
            }
            0x83236498 => {
    //   block [0x83236498..0x832364AC)
	// 83236498: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8323649C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832364A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832364A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832364A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832364B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832364B0 size=48
    let mut pc: u32 = 0x832364B0;
    'dispatch: loop {
        match pc {
            0x832364B0 => {
    //   block [0x832364B0..0x832364E0)
	// 832364B0: 3964000B  addi r11, r4, 0xb
	ctx.r[11].s64 = ctx.r[4].s64 + 11;
	// 832364B4: 90830000  stw r4, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 832364B8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 832364BC: 7D4B2396  divwu r10, r11, r4
	ctx.r[10].u32 = ctx.r[11].u32 / ctx.r[4].u32;
	// 832364C0: 0CC40000  twi 6, r4, 0
	// 832364C4: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 832364C8: 7D0A21D6  mullw r8, r10, r4
	ctx.r[8].s32 = ((ctx.r[10].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 832364CC: 20E81000  subfic r7, r8, 0x1000
	ctx.xer.ca = ctx.r[8].u32 <= 4096 as u32;
	ctx.r[7].s64 = (4096 as i64) - ctx.r[8].s64;
	// 832364D0: 0CC40000  twi 6, r4, 0
	// 832364D4: 7CC72396  divwu r6, r7, r4
	ctx.r[6].u32 = ctx.r[7].u32 / ctx.r[4].u32;
	// 832364D8: 90C30004  stw r6, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 832364DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832364E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832364E0 size=60
    let mut pc: u32 = 0x832364E0;
    'dispatch: loop {
        match pc {
            0x832364E0 => {
    //   block [0x832364E0..0x832364F8)
	// 832364E0: 54AA063E  clrlwi r10, r5, 0x18
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 832364E4: 39601000  li r11, 0x1000
	ctx.r[11].s64 = 4096;
	// 832364E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832364EC: 419A000C  beq cr6, 0x832364f8
	if ctx.cr[6].eq {
	pc = 0x832364F8; continue 'dispatch;
	}
	// 832364F0: 3D600010  lis r11, 0x10
	ctx.r[11].s64 = 1048576;
	// 832364F4: 616B1000  ori r11, r11, 0x1000
	ctx.r[11].u64 = ctx.r[11].u64 | 4096;
	pc = 0x832364F8; continue 'dispatch;
            }
            0x832364F8 => {
    //   block [0x832364F8..0x83236508)
	// 832364F8: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 832364FC: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 83236500: 409A0008  bne cr6, 0x83236508
	if !ctx.cr[6].eq {
	pc = 0x83236508; continue 'dispatch;
	}
	// 83236504: 656B2000  oris r11, r11, 0x2000
	ctx.r[11].u64 = ctx.r[11].u64 | 536870912;
	pc = 0x83236508; continue 'dispatch;
            }
            0x83236508 => {
    //   block [0x83236508..0x8323651C)
	// 83236508: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8323650C: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 83236510: 65650080  oris r5, r11, 0x80
	ctx.r[5].u64 = ctx.r[11].u64 | 8388608;
	// 83236514: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 83236518: 4BA90FE0  b 0x82cc74f8
	sub_82CC74F8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83236520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83236520 size=8
    let mut pc: u32 = 0x83236520;
    'dispatch: loop {
        match pc {
            0x83236520 => {
    //   block [0x83236520..0x83236528)
	// 83236520: 38A04000  li r5, 0x4000
	ctx.r[5].s64 = 16384;
	// 83236524: 4BA91024  b 0x82cc7548
	sub_82CC7548(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83236528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83236528 size=76
    let mut pc: u32 = 0x83236528;
    'dispatch: loop {
        match pc {
            0x83236528 => {
    //   block [0x83236528..0x8323654C)
	// 83236528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323652C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83236530: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83236534: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 83236538: 39601000  li r11, 0x1000
	ctx.r[11].s64 = 4096;
	// 8323653C: 7F055040  cmplw cr6, r5, r10
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[10].u32, &mut ctx.xer);
	// 83236540: 409A000C  bne cr6, 0x8323654c
	if !ctx.cr[6].eq {
	pc = 0x8323654C; continue 'dispatch;
	}
	// 83236544: 3D602000  lis r11, 0x2000
	ctx.r[11].s64 = 536870912;
	// 83236548: 616B1000  ori r11, r11, 0x1000
	ctx.r[11].u64 = ctx.r[11].u64 | 4096;
	pc = 0x8323654C; continue 'dispatch;
            }
            0x8323654C => {
    //   block [0x8323654C..0x83236574)
	// 8323654C: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 83236550: 65650080  oris r5, r11, 0x80
	ctx.r[5].u64 = ctx.r[11].u64 | 8388608;
	// 83236554: 4BA90FA5  bl 0x82cc74f8
	ctx.lr = 0x83236558;
	sub_82CC74F8(ctx, base);
	// 83236558: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 8323655C: 556ADFFE  rlwinm r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 83236560: 69430001  xori r3, r10, 1
	ctx.r[3].u64 = ctx.r[10].u64 ^ 1;
	// 83236564: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 83236568: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8323656C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83236570: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83236578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83236578 size=16
    let mut pc: u32 = 0x83236578;
    'dispatch: loop {
        match pc {
            0x83236578 => {
    //   block [0x83236578..0x83236588)
	// 83236578: 3CA00000  lis r5, 0
	ctx.r[5].s64 = 0;
	// 8323657C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 83236580: 60A58000  ori r5, r5, 0x8000
	ctx.r[5].u64 = ctx.r[5].u64 | 32768;
	// 83236584: 4BA90FC4  b 0x82cc7548
	sub_82CC7548(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83236588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83236588 size=44
    let mut pc: u32 = 0x83236588;
    'dispatch: loop {
        match pc {
            0x83236588 => {
    //   block [0x83236588..0x832365A0)
	// 83236588: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8323658C: 39602000  li r11, 0x2000
	ctx.r[11].s64 = 8192;
	// 83236590: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 83236594: 409A000C  bne cr6, 0x832365a0
	if !ctx.cr[6].eq {
	pc = 0x832365A0; continue 'dispatch;
	}
	// 83236598: 3D602000  lis r11, 0x2000
	ctx.r[11].s64 = 536870912;
	// 8323659C: 616B2000  ori r11, r11, 0x2000
	ctx.r[11].u64 = ctx.r[11].u64 | 8192;
	pc = 0x832365A0; continue 'dispatch;
            }
            0x832365A0 => {
    //   block [0x832365A0..0x832365B4)
	// 832365A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 832365A4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 832365A8: 65650080  oris r5, r11, 0x80
	ctx.r[5].u64 = ctx.r[11].u64 | 8388608;
	// 832365AC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 832365B0: 4BA90F48  b 0x82cc74f8
	sub_82CC74F8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832365B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832365B8 size=4
    let mut pc: u32 = 0x832365B8;
    'dispatch: loop {
        match pc {
            0x832365B8 => {
    //   block [0x832365B8..0x832365BC)
	// 832365B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832365C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832365C0 size=32
    let mut pc: u32 = 0x832365C0;
    'dispatch: loop {
        match pc {
            0x832365C0 => {
    //   block [0x832365C0..0x832365E0)
	// 832365C0: 7D652396  divwu r11, r5, r4
	ctx.r[11].u32 = ctx.r[5].u32 / ctx.r[4].u32;
	// 832365C4: 90830000  stw r4, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 832365C8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 832365CC: 90A30004  stw r5, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 832365D0: 0CC40000  twi 6, r4, 0
	// 832365D4: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 832365D8: 9143000C  stw r10, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 832365DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832365E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832365E0 size=72
    let mut pc: u32 = 0x832365E0;
    'dispatch: loop {
        match pc {
            0x832365E0 => {
    //   block [0x832365E0..0x832365EC)
	// 832365E0: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 832365E4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 832365E8: 419A002C  beq cr6, 0x83236614
	if ctx.cr[6].eq {
	pc = 0x83236614; continue 'dispatch;
	}
	pc = 0x832365EC; continue 'dispatch;
            }
            0x832365EC => {
    //   block [0x832365EC..0x83236608)
	// 832365EC: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 832365F0: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 832365F4: 41980014  blt cr6, 0x83236608
	if ctx.cr[6].lt {
	pc = 0x83236608; continue 'dispatch;
	}
	// 832365F8: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 832365FC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 83236600: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83236604: 41980014  blt cr6, 0x83236618
	if ctx.cr[6].lt {
	pc = 0x83236618; continue 'dispatch;
	}
	pc = 0x83236608; continue 'dispatch;
            }
            0x83236608 => {
    //   block [0x83236608..0x83236614)
	// 83236608: 8129000C  lwz r9, 0xc(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323660C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83236610: 409AFFDC  bne cr6, 0x832365ec
	if !ctx.cr[6].eq {
	pc = 0x832365EC; continue 'dispatch;
	}
	pc = 0x83236614; continue 'dispatch;
            }
            0x83236614 => {
    //   block [0x83236614..0x83236618)
	// 83236614: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x83236618; continue 'dispatch;
            }
            0x83236618 => {
    //   block [0x83236618..0x83236628)
	// 83236618: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 8323661C: 556ADFFE  rlwinm r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 83236620: 69430001  xori r3, r10, 1
	ctx.r[3].u64 = ctx.r[10].u64 ^ 1;
	// 83236624: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83236628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83236628 size=200
    let mut pc: u32 = 0x83236628;
    'dispatch: loop {
        match pc {
            0x83236628 => {
    //   block [0x83236628..0x8323664C)
	// 83236628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323662C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83236630: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 83236634: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 83236638: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323663C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 83236640: 83E9000C  lwz r31, 0xc(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 83236644: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 83236648: 419A002C  beq cr6, 0x83236674
	if ctx.cr[6].eq {
	pc = 0x83236674; continue 'dispatch;
	}
	pc = 0x8323664C; continue 'dispatch;
            }
            0x8323664C => {
    //   block [0x8323664C..0x83236668)
	// 8323664C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83236650: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83236654: 41980014  blt cr6, 0x83236668
	if ctx.cr[6].lt {
	pc = 0x83236668; continue 'dispatch;
	}
	// 83236658: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323665C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 83236660: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83236664: 41980014  blt cr6, 0x83236678
	if ctx.cr[6].lt {
	pc = 0x83236678; continue 'dispatch;
	}
	pc = 0x83236668; continue 'dispatch;
            }
            0x83236668 => {
    //   block [0x83236668..0x83236674)
	// 83236668: 83FF000C  lwz r31, 0xc(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323666C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 83236670: 409AFFDC  bne cr6, 0x8323664c
	if !ctx.cr[6].eq {
	pc = 0x8323664C; continue 'dispatch;
	}
	pc = 0x83236674; continue 'dispatch;
            }
            0x83236674 => {
    //   block [0x83236674..0x83236678)
	// 83236674: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x83236678; continue 'dispatch;
            }
            0x83236678 => {
    //   block [0x83236678..0x832366D8)
	// 83236678: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323667C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 83236680: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83236684: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 83236688: 38CA0001  addi r6, r10, 1
	ctx.r[6].s64 = ctx.r[10].s64 + 1;
	// 8323668C: 7CA82050  subf r5, r8, r4
	ctx.r[5].s64 = ctx.r[4].s64 - ctx.r[8].s64;
	// 83236690: 90DF0008  stw r6, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 83236694: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 83236698: 80890000  lwz r4, 0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323669C: 7FC52396  divwu r30, r5, r4
	ctx.r[30].u32 = ctx.r[5].u32 / ctx.r[4].u32;
	// 832366A0: 57CAE8FA  rlwinm r10, r30, 0x1d, 3, 0x1d
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000007u64;
	// 832366A4: 57C806FE  clrlwi r8, r30, 0x1b
	ctx.r[8].u64 = ctx.r[30].u32 as u64 & 0x0000001Fu64;
	// 832366A8: 0CC40000  twi 6, r4, 0
	// 832366AC: 7CE74030  slw r7, r7, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = ((ctx.r[7].u32) << ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 832366B0: 7CCA582E  lwzx r6, r10, r11
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 832366B4: 7CC43878  andc r4, r6, r7
	ctx.r[4].u64 = ctx.r[6].u64 & !ctx.r[7].u64;
	// 832366B8: 7C8A592E  stwx r4, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[4].u32) };
	// 832366BC: 38A04000  li r5, 0x4000
	ctx.r[5].s64 = 16384;
	// 832366C0: 80890000  lwz r4, 0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 832366C4: 4BA90E85  bl 0x82cc7548
	ctx.lr = 0x832366C8;
	sub_82CC7548(ctx, base);
	// 832366C8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832366CC: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 832366D0: 40980008  bge cr6, 0x832366d8
	if !ctx.cr[6].lt {
	pc = 0x832366D8; continue 'dispatch;
	}
	// 832366D4: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	pc = 0x832366D8; continue 'dispatch;
            }
            0x832366D8 => {
    //   block [0x832366D8..0x832366F0)
	// 832366D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832366DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832366E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832366E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832366E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832366EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832366F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832366F0 size=172
    let mut pc: u32 = 0x832366F0;
    'dispatch: loop {
        match pc {
            0x832366F0 => {
    //   block [0x832366F0..0x83236724)
	// 832366F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832366F4: 4BA72D19  bl 0x82ca940c
	ctx.lr = 0x832366F8;
	sub_82CA93D0(ctx, base);
	// 832366F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832366FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 83236700: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 83236704: 556BE8FE  srwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 83236708: 394B0003  addi r10, r11, 3
	ctx.r[10].s64 = ctx.r[11].s64 + 3;
	// 8323670C: 555D003A  rlwinm r29, r10, 0, 0, 0x1d
	ctx.r[29].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 83236710: 387D0010  addi r3, r29, 0x10
	ctx.r[3].s64 = ctx.r[29].s64 + 16;
	// 83236714: 4BA73D75  bl 0x82caa488
	ctx.lr = 0x83236718;
	sub_82CAA488(ctx, base);
	// 83236718: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8323671C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 83236720: 409A0010  bne cr6, 0x83236730
	if !ctx.cr[6].eq {
	pc = 0x83236730; continue 'dispatch;
	}
	pc = 0x83236724; continue 'dispatch;
            }
            0x83236724 => {
    //   block [0x83236724..0x83236730)
	// 83236724: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 83236728: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8323672C: 4BA72D30  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x83236730 => {
    //   block [0x83236730..0x83236760)
	// 83236730: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 83236734: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 83236738: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 8323673C: 4BA73275  bl 0x82ca99b0
	ctx.lr = 0x83236740;
	sub_82CA99B0(ctx, base);
	// 83236740: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 83236744: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 83236748: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323674C: 39602000  li r11, 0x2000
	ctx.r[11].s64 = 8192;
	// 83236750: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 83236754: 409A000C  bne cr6, 0x83236760
	if !ctx.cr[6].eq {
	pc = 0x83236760; continue 'dispatch;
	}
	// 83236758: 3D602000  lis r11, 0x2000
	ctx.r[11].s64 = 536870912;
	// 8323675C: 616B2000  ori r11, r11, 0x2000
	ctx.r[11].u64 = ctx.r[11].u64 | 8192;
	pc = 0x83236760; continue 'dispatch;
            }
            0x83236760 => {
    //   block [0x83236760..0x8323679C)
	// 83236760: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 83236764: 65650080  oris r5, r11, 0x80
	ctx.r[5].u64 = ctx.r[11].u64 | 8388608;
	// 83236768: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8323676C: 4BA90D8D  bl 0x82cc74f8
	ctx.lr = 0x83236770;
	sub_82CC74F8(ctx, base);
	// 83236770: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 83236774: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 83236778: 419AFFAC  beq cr6, 0x83236724
	if ctx.cr[6].eq {
	pc = 0x83236724; continue 'dispatch;
	}
	// 8323677C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 83236780: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83236784: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 83236788: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323678C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 83236790: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 83236794: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 83236798: 4BA72CC4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832367A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832367A0 size=100
    let mut pc: u32 = 0x832367A0;
    'dispatch: loop {
        match pc {
            0x832367A0 => {
    //   block [0x832367A0..0x832367C0)
	// 832367A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832367A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832367A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832367AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832367B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832367B4: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 832367B8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 832367BC: 419A0030  beq cr6, 0x832367ec
	if ctx.cr[6].eq {
	pc = 0x832367EC; continue 'dispatch;
	}
	pc = 0x832367C0; continue 'dispatch;
            }
            0x832367C0 => {
    //   block [0x832367C0..0x832367EC)
	// 832367C0: 3CA00000  lis r5, 0
	ctx.r[5].s64 = 0;
	// 832367C4: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 832367C8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 832367CC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832367D0: 60A58000  ori r5, r5, 0x8000
	ctx.r[5].u64 = ctx.r[5].u64 | 32768;
	// 832367D4: 4BA90D75  bl 0x82cc7548
	ctx.lr = 0x832367D8;
	sub_82CC7548(ctx, base);
	// 832367D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832367DC: 4BA75965  bl 0x82cac140
	ctx.lr = 0x832367E0;
	sub_82CAC140(ctx, base);
	// 832367E0: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 832367E4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 832367E8: 409AFFD8  bne cr6, 0x832367c0
	if !ctx.cr[6].eq {
	pc = 0x832367C0; continue 'dispatch;
	}
	pc = 0x832367EC; continue 'dispatch;
            }
            0x832367EC => {
    //   block [0x832367EC..0x83236804)
	// 832367EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832367F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832367F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832367F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832367FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 83236800: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83236808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83236808 size=468
    let mut pc: u32 = 0x83236808;
    'dispatch: loop {
        match pc {
            0x83236808 => {
    //   block [0x83236808..0x83236828)
	// 83236808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323680C: 4BA72BFD  bl 0x82ca9408
	ctx.lr = 0x83236810;
	sub_82CA93D0(ctx, base);
	// 83236810: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83236814: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 83236818: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8323681C: 83FD000C  lwz r31, 0xc(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 83236820: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 83236824: 419A0020  beq cr6, 0x83236844
	if ctx.cr[6].eq {
	pc = 0x83236844; continue 'dispatch;
	}
	pc = 0x83236828; continue 'dispatch;
            }
            0x83236828 => {
    //   block [0x83236828..0x83236844)
	// 83236828: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323682C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83236830: 409A0048  bne cr6, 0x83236878
	if !ctx.cr[6].eq {
	pc = 0x83236878; continue 'dispatch;
	}
	// 83236834: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 83236838: 83FF000C  lwz r31, 0xc(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323683C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 83236840: 409AFFE8  bne cr6, 0x83236828
	if !ctx.cr[6].eq {
	pc = 0x83236828; continue 'dispatch;
	}
	pc = 0x83236844; continue 'dispatch;
            }
            0x83236844 => {
    //   block [0x83236844..0x83236858)
	// 83236844: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 83236848: 4BFFFEA9  bl 0x832366f0
	ctx.lr = 0x8323684C;
	sub_832366F0(ctx, base);
	// 8323684C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83236850: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 83236854: 409A0010  bne cr6, 0x83236864
	if !ctx.cr[6].eq {
	pc = 0x83236864; continue 'dispatch;
	}
	pc = 0x83236858; continue 'dispatch;
            }
            0x83236858 => {
    //   block [0x83236858..0x83236864)
	// 83236858: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8323685C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 83236860: 4BA72BF8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x83236864 => {
    //   block [0x83236864..0x83236874)
	// 83236864: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 83236868: 419A000C  beq cr6, 0x83236874
	if ctx.cr[6].eq {
	pc = 0x83236874; continue 'dispatch;
	}
	// 8323686C: 93FE000C  stw r31, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 83236870: 48000008  b 0x83236878
	pc = 0x83236878; continue 'dispatch;
            }
            0x83236874 => {
    //   block [0x83236874..0x83236878)
	// 83236874: 93FD000C  stw r31, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	pc = 0x83236878; continue 'dispatch;
            }
            0x83236878 => {
    //   block [0x83236878..0x832368A4)
	// 83236878: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323687C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 83236880: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83236884: 39201000  li r9, 0x1000
	ctx.r[9].s64 = 4096;
	// 83236888: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8323688C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83236890: 7D64F1D6  mullw r11, r4, r30
	ctx.r[11].s32 = ((ctx.r[4].s32 as i64 * ctx.r[30].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 83236894: 7F8B5214  add r28, r11, r10
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 83236898: 409A000C  bne cr6, 0x832368a4
	if !ctx.cr[6].eq {
	pc = 0x832368A4; continue 'dispatch;
	}
	// 8323689C: 3D202000  lis r9, 0x2000
	ctx.r[9].s64 = 536870912;
	// 832368A0: 61291000  ori r9, r9, 0x1000
	ctx.r[9].u64 = ctx.r[9].u64 | 4096;
	pc = 0x832368A4; continue 'dispatch;
            }
            0x832368A4 => {
    //   block [0x832368A4..0x83236928)
	// 832368A4: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 832368A8: 65250080  oris r5, r9, 0x80
	ctx.r[5].u64 = ctx.r[9].u64 | 8388608;
	// 832368AC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 832368B0: 4BA90C49  bl 0x82cc74f8
	ctx.lr = 0x832368B4;
	sub_82CC74F8(ctx, base);
	// 832368B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832368B8: 419AFFA0  beq cr6, 0x83236858
	if ctx.cr[6].eq {
	pc = 0x83236858; continue 'dispatch;
	}
	// 832368BC: 57CBE8FA  rlwinm r11, r30, 0x1d, 3, 0x1d
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000007u64;
	// 832368C0: 395F0010  addi r10, r31, 0x10
	ctx.r[10].s64 = ctx.r[31].s64 + 16;
	// 832368C4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 832368C8: 57C906FE  clrlwi r9, r30, 0x1b
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x0000001Fu64;
	// 832368CC: 7CE84830  slw r8, r7, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = ((ctx.r[7].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 832368D0: 7CCB502E  lwzx r6, r11, r10
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 832368D4: 7D053378  or r5, r8, r6
	ctx.r[5].u64 = ctx.r[8].u64 | ctx.r[6].u64;
	// 832368D8: 7CAB512E  stwx r5, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[5].u32) };
	// 832368DC: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 832368E0: 3564FFFF  addic. r11, r4, -1
	ctx.xer.ca = (ctx.r[4].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832368E4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 832368E8: 418200E0  beq 0x832369c8
	if ctx.cr[0].eq {
	pc = 0x832369C8; continue 'dispatch;
	}
	// 832368EC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832368F0: 80DD0008  lwz r6, 8(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 832368F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 832368F8: 5569E8FA  rlwinm r9, r11, 0x1d, 3, 0x1d
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 832368FC: 556806FE  clrlwi r8, r11, 0x1b
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 83236900: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 83236904: 7CE54030  slw r5, r7, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[5].u64 = 0;
	} else {
		ctx.r[5].u64 = ((ctx.r[7].u32) << ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 83236908: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323690C: 7CA32038  and r3, r5, r4
	ctx.r[3].u64 = ctx.r[5].u64 & ctx.r[4].u64;
	// 83236910: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 83236914: 419A00B8  beq cr6, 0x832369cc
	if ctx.cr[6].eq {
	pc = 0x832369CC; continue 'dispatch;
	}
	// 83236918: 5489003E  slwi r9, r4, 0
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8323691C: 556B0034  rlwinm r11, r11, 0, 0, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 83236920: 2F09FFFF  cmpwi cr6, r9, -1
	ctx.cr[6].compare_i32(ctx.r[9].s32, -1, &mut ctx.xer);
	// 83236924: 409A0020  bne cr6, 0x83236944
	if !ctx.cr[6].eq {
	pc = 0x83236944; continue 'dispatch;
	}
	pc = 0x83236928; continue 'dispatch;
            }
            0x83236928 => {
    //   block [0x83236928..0x83236944)
	// 83236928: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 8323692C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 83236930: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 83236934: 40980080  bge cr6, 0x832369b4
	if !ctx.cr[6].lt {
	pc = 0x832369B4; continue 'dispatch;
	}
	// 83236938: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323693C: 2F09FFFF  cmpwi cr6, r9, -1
	ctx.cr[6].compare_i32(ctx.r[9].s32, -1, &mut ctx.xer);
	// 83236940: 419AFFE8  beq cr6, 0x83236928
	if ctx.cr[6].eq {
	pc = 0x83236928; continue 'dispatch;
	}
	pc = 0x83236944; continue 'dispatch;
            }
            0x83236944 => {
    //   block [0x83236944..0x8323695C)
	// 83236944: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 83236948: 550A043E  clrlwi r10, r8, 0x10
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x0000FFFFu64;
	// 8323694C: 2B0AFFFF  cmplwi cr6, r10, 0xffff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 65535 as u32, &mut ctx.xer);
	// 83236950: 409A000C  bne cr6, 0x8323695c
	if !ctx.cr[6].eq {
	pc = 0x8323695C; continue 'dispatch;
	}
	// 83236954: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 83236958: 5508843E  srwi r8, r8, 0x10
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(16);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	pc = 0x8323695C; continue 'dispatch;
            }
            0x8323695C => {
    //   block [0x8323695C..0x83236970)
	// 8323695C: 550A063E  clrlwi r10, r8, 0x18
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 83236960: 2B0A00FF  cmplwi cr6, r10, 0xff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 255 as u32, &mut ctx.xer);
	// 83236964: 409A000C  bne cr6, 0x83236970
	if !ctx.cr[6].eq {
	pc = 0x83236970; continue 'dispatch;
	}
	// 83236968: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8323696C: 5508C23E  srwi r8, r8, 8
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(8);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	pc = 0x83236970; continue 'dispatch;
            }
            0x83236970 => {
    //   block [0x83236970..0x83236978)
	// 83236970: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 83236974: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	pc = 0x83236978; continue 'dispatch;
            }
            0x83236978 => {
    //   block [0x83236978..0x832369AC)
	// 83236978: 7D474038  and r7, r10, r8
	ctx.r[7].u64 = ctx.r[10].u64 & ctx.r[8].u64;
	// 8323697C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 83236980: 419A002C  beq cr6, 0x832369ac
	if ctx.cr[6].eq {
	pc = 0x832369AC; continue 'dispatch;
	}
	// 83236984: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 83236988: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8323698C: 554A083E  rotlwi r10, r10, 1
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 83236990: 2B090008  cmplwi cr6, r9, 8
	ctx.cr[6].compare_u32(ctx.r[9].u32, 8 as u32, &mut ctx.xer);
	// 83236994: 4198FFE4  blt cr6, 0x83236978
	if ctx.cr[6].lt {
	pc = 0x83236978; continue 'dispatch;
	}
	// 83236998: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 8323699C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 832369A0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832369A4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 832369A8: 4BA72AB0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x832369AC => {
    //   block [0x832369AC..0x832369B4)
	// 832369AC: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 832369B0: 4198001C  blt cr6, 0x832369cc
	if ctx.cr[6].lt {
	pc = 0x832369CC; continue 'dispatch;
	}
	pc = 0x832369B4; continue 'dispatch;
            }
            0x832369B4 => {
    //   block [0x832369B4..0x832369C8)
	// 832369B4: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 832369B8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 832369BC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832369C0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 832369C4: 4BA72A94  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x832369C8 => {
    //   block [0x832369C8..0x832369CC)
	// 832369C8: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x832369CC; continue 'dispatch;
            }
            0x832369CC => {
    //   block [0x832369CC..0x832369DC)
	// 832369CC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832369D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 832369D4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 832369D8: 4BA72A80  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832369E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832369E0 size=4
    let mut pc: u32 = 0x832369E0;
    'dispatch: loop {
        match pc {
            0x832369E0 => {
    //   block [0x832369E0..0x832369E4)
	// 832369E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832369E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832369E8 size=60
    let mut pc: u32 = 0x832369E8;
    'dispatch: loop {
        match pc {
            0x832369E8 => {
    //   block [0x832369E8..0x832369F8)
	// 832369E8: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 832369EC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 832369F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832369F4: 419A001C  beq cr6, 0x83236a10
	if ctx.cr[6].eq {
	pc = 0x83236A10; continue 'dispatch;
	}
	pc = 0x832369F8; continue 'dispatch;
            }
            0x832369F8 => {
    //   block [0x832369F8..0x83236A10)
	// 832369F8: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 832369FC: 419A0014  beq cr6, 0x83236a10
	if ctx.cr[6].eq {
	pc = 0x83236A10; continue 'dispatch;
	}
	// 83236A00: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 83236A04: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 83236A08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83236A0C: 409AFFEC  bne cr6, 0x832369f8
	if !ctx.cr[6].eq {
	pc = 0x832369F8; continue 'dispatch;
	}
	pc = 0x83236A10; continue 'dispatch;
            }
            0x83236A10 => {
    //   block [0x83236A10..0x83236A24)
	// 83236A10: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 83236A14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83236A18: 419A000C  beq cr6, 0x83236a24
	if ctx.cr[6].eq {
		sub_83236A24(ctx, base);
		return;
	}
	// 83236A1C: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 83236A20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83236A24(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83236A24 size=8
    let mut pc: u32 = 0x83236A24;
    'dispatch: loop {
        match pc {
            0x83236A24 => {
    //   block [0x83236A24..0x83236A2C)
	// 83236A24: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 83236A28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83236A30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83236A30 size=60
    let mut pc: u32 = 0x83236A30;
    'dispatch: loop {
        match pc {
            0x83236A30 => {
    //   block [0x83236A30..0x83236A40)
	// 83236A30: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 83236A34: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 83236A38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83236A3C: 419A001C  beq cr6, 0x83236a58
	if ctx.cr[6].eq {
	pc = 0x83236A58; continue 'dispatch;
	}
	pc = 0x83236A40; continue 'dispatch;
            }
            0x83236A40 => {
    //   block [0x83236A40..0x83236A58)
	// 83236A40: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 83236A44: 40980014  bge cr6, 0x83236a58
	if !ctx.cr[6].lt {
	pc = 0x83236A58; continue 'dispatch;
	}
	// 83236A48: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 83236A4C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 83236A50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83236A54: 409AFFEC  bne cr6, 0x83236a40
	if !ctx.cr[6].eq {
	pc = 0x83236A40; continue 'dispatch;
	}
	pc = 0x83236A58; continue 'dispatch;
            }
            0x83236A58 => {
    //   block [0x83236A58..0x83236A6C)
	// 83236A58: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 83236A5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83236A60: 419A000C  beq cr6, 0x83236a6c
	if ctx.cr[6].eq {
		sub_83236A6C(ctx, base);
		return;
	}
	// 83236A64: 908A0008  stw r4, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 83236A68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83236A6C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83236A6C size=8
    let mut pc: u32 = 0x83236A6C;
    'dispatch: loop {
        match pc {
            0x83236A6C => {
    //   block [0x83236A6C..0x83236A74)
	// 83236A6C: 90830010  stw r4, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[4].u32 ) };
	// 83236A70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83236A78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83236A78 size=80
    let mut pc: u32 = 0x83236A78;
    'dispatch: loop {
        match pc {
            0x83236A78 => {
    //   block [0x83236A78..0x83236AC8)
	// 83236A78: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83236A7C: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 83236A80: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 83236A84: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 83236A88: 38EB000F  addi r7, r11, 0xf
	ctx.r[7].s64 = ctx.r[11].s64 + 15;
	// 83236A8C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 83236A90: 38C9FFFF  addi r6, r9, -1
	ctx.r[6].s64 = ctx.r[9].s64 + -1;
	// 83236A94: 7CA75B96  divwu r5, r7, r11
	ctx.r[5].u32 = ctx.r[7].u32 / ctx.r[11].u32;
	// 83236A98: 7C865B96  divwu r4, r6, r11
	ctx.r[4].u32 = ctx.r[6].u32 / ctx.r[11].u32;
	// 83236A9C: 7D4559D6  mullw r10, r5, r11
	ctx.r[10].s32 = ((ctx.r[5].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 83236AA0: 7D2459D6  mullw r9, r4, r11
	ctx.r[9].s32 = ((ctx.r[4].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 83236AA4: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 83236AA8: 81080000  lwz r8, 0(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 83236AAC: 7CEA4050  subf r7, r10, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	// 83236AB0: 7CC74B96  divwu r6, r7, r9
	ctx.r[6].u32 = ctx.r[7].u32 / ctx.r[9].u32;
	// 83236AB4: 0CCB0000  twi 6, r11, 0
	// 83236AB8: 0CCB0000  twi 6, r11, 0
	// 83236ABC: 90C30008  stw r6, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 83236AC0: 0CC90000  twi 6, r9, 0
	// 83236AC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83236AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83236AC8 size=116
    let mut pc: u32 = 0x83236AC8;
    'dispatch: loop {
        match pc {
            0x83236AC8 => {
    //   block [0x83236AC8..0x83236B3C)
	// 83236AC8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 83236ACC: 90830000  stw r4, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 83236AD0: 90C3000C  stw r6, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[6].u32 ) };
	// 83236AD4: 90A30014  stw r5, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[5].u32 ) };
	// 83236AD8: 91430010  stw r10, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 83236ADC: 91430024  stw r10, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 83236AE0: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83236AE4: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 83236AE8: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 83236AEC: 38AB000F  addi r5, r11, 0xf
	ctx.r[5].s64 = ctx.r[11].s64 + 15;
	// 83236AF0: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 83236AF4: 7D095A14  add r8, r9, r11
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 83236AF8: 7D255B96  divwu r9, r5, r11
	ctx.r[9].u32 = ctx.r[5].u32 / ctx.r[11].u32;
	// 83236AFC: 38C8FFFF  addi r6, r8, -1
	ctx.r[6].s64 = ctx.r[8].s64 + -1;
	// 83236B00: 0CCB0000  twi 6, r11, 0
	// 83236B04: 7C865B96  divwu r4, r6, r11
	ctx.r[4].u32 = ctx.r[6].u32 / ctx.r[11].u32;
	// 83236B08: 7CC959D6  mullw r6, r9, r11
	ctx.r[6].s32 = ((ctx.r[9].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[6].s64 = ctx.r[6].s32 as i64;
	// 83236B0C: 7D0459D6  mullw r8, r4, r11
	ctx.r[8].s32 = ((ctx.r[4].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 83236B10: 91030004  stw r8, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 83236B14: 80E70000  lwz r7, 0(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 83236B18: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 83236B1C: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 83236B20: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 83236B24: 7CA63850  subf r5, r6, r7
	ctx.r[5].s64 = ctx.r[7].s64 - ctx.r[6].s64;
	// 83236B28: 7C854396  divwu r4, r5, r8
	ctx.r[4].u32 = ctx.r[5].u32 / ctx.r[8].u32;
	// 83236B2C: 0CCB0000  twi 6, r11, 0
	// 83236B30: 0CC80000  twi 6, r8, 0
	// 83236B34: 90830008  stw r4, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 83236B38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83236B40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83236B40 size=60
    let mut pc: u32 = 0x83236B40;
    'dispatch: loop {
        match pc {
            0x83236B40 => {
    //   block [0x83236B40..0x83236B4C)
	// 83236B40: 8124001C  lwz r9, 0x1c(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 83236B44: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83236B48: 419A002C  beq cr6, 0x83236b74
	if ctx.cr[6].eq {
	pc = 0x83236B74; continue 'dispatch;
	}
	pc = 0x83236B4C; continue 'dispatch;
            }
            0x83236B4C => {
    //   block [0x83236B4C..0x83236B68)
	// 83236B4C: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 83236B50: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83236B54: 41980014  blt cr6, 0x83236b68
	if ctx.cr[6].lt {
	pc = 0x83236B68; continue 'dispatch;
	}
	// 83236B58: 81440014  lwz r10, 0x14(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 83236B5C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 83236B60: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83236B64: 41980018  blt cr6, 0x83236b7c
	if ctx.cr[6].lt {
		sub_83236B7C(ctx, base);
		return;
	}
	pc = 0x83236B68; continue 'dispatch;
            }
            0x83236B68 => {
    //   block [0x83236B68..0x83236B74)
	// 83236B68: 8129000C  lwz r9, 0xc(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 83236B6C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83236B70: 409AFFDC  bne cr6, 0x83236b4c
	if !ctx.cr[6].eq {
	pc = 0x83236B4C; continue 'dispatch;
	}
	pc = 0x83236B74; continue 'dispatch;
            }
            0x83236B74 => {
    //   block [0x83236B74..0x83236B7C)
	// 83236B74: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 83236B78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83236B7C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83236B7C size=24
    let mut pc: u32 = 0x83236B7C;
    'dispatch: loop {
        match pc {
            0x83236B7C => {
    //   block [0x83236B7C..0x83236B94)
	// 83236B7C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 83236B80: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 83236B84: 7C6A5878  andc r10, r3, r11
	ctx.r[10].u64 = ctx.r[3].u64 & !ctx.r[11].u64;
	// 83236B88: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 83236B8C: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 83236B90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83236B98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83236B98 size=368
    let mut pc: u32 = 0x83236B98;
    'dispatch: loop {
        match pc {
            0x83236B98 => {
    //   block [0x83236B98..0x83236C18)
	// 83236B98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83236B9C: 4BA72871  bl 0x82ca940c
	ctx.lr = 0x83236BA0;
	sub_82CA93D0(ctx, base);
	// 83236BA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83236BA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83236BA8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 83236BAC: 3BDF0024  addi r30, r31, 0x24
	ctx.r[30].s64 = ctx.r[31].s64 + 36;
	// 83236BB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 83236BB4: 4B0A00D5  bl 0x822d6c88
	ctx.lr = 0x83236BB8;
	sub_822D6C88(ctx, base);
	// 83236BB8: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 83236BBC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83236BC0: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 83236BC4: 7FA45078  andc r4, r29, r10
	ctx.r[4].u64 = ctx.r[29].u64 & !ctx.r[10].u64;
	// 83236BC8: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 83236BCC: 913D0000  stw r9, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 83236BD0: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 83236BD4: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	// 83236BD8: 91040004  stw r8, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 83236BDC: 93A40000  stw r29, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 83236BE0: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 83236BE4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83236BE8: 80FF0018  lwz r7, 0x18(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 83236BEC: 7CAB3850  subf r5, r11, r7
	ctx.r[5].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 83236BF0: 7CCB5214  add r6, r11, r10
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 83236BF4: 90BF0018  stw r5, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[5].u32 ) };
	// 83236BF8: 90DF001C  stw r6, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[6].u32 ) };
	// 83236BFC: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 83236C00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83236C04: 409A0090  bne cr6, 0x83236c94
	if !ctx.cr[6].eq {
	pc = 0x83236C94; continue 'dispatch;
	}
	// 83236C08: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 83236C0C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 83236C10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83236C14: 419A001C  beq cr6, 0x83236c30
	if ctx.cr[6].eq {
	pc = 0x83236C30; continue 'dispatch;
	}
	pc = 0x83236C18; continue 'dispatch;
            }
            0x83236C18 => {
    //   block [0x83236C18..0x83236C30)
	// 83236C18: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 83236C1C: 419A0014  beq cr6, 0x83236c30
	if ctx.cr[6].eq {
	pc = 0x83236C30; continue 'dispatch;
	}
	// 83236C20: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 83236C24: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 83236C28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83236C2C: 409AFFEC  bne cr6, 0x83236c18
	if !ctx.cr[6].eq {
	pc = 0x83236C18; continue 'dispatch;
	}
	pc = 0x83236C30; continue 'dispatch;
            }
            0x83236C30 => {
    //   block [0x83236C30..0x83236C44)
	// 83236C30: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 83236C34: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83236C38: 419A000C  beq cr6, 0x83236c44
	if ctx.cr[6].eq {
	pc = 0x83236C44; continue 'dispatch;
	}
	// 83236C3C: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 83236C40: 48000008  b 0x83236c48
	pc = 0x83236C48; continue 'dispatch;
            }
            0x83236C44 => {
    //   block [0x83236C44..0x83236C48)
	// 83236C44: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x83236C48; continue 'dispatch;
            }
            0x83236C48 => {
    //   block [0x83236C48..0x83236C94)
	// 83236C48: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 83236C4C: 48005BED  bl 0x8323c838
	ctx.lr = 0x83236C50;
	sub_8323C838(ctx, base);
	// 83236C50: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83236C54: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83236C58: 811F001C  lwz r8, 0x1c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 83236C5C: 7CEB49D6  mullw r7, r11, r9
	ctx.r[7].s32 = ((ctx.r[11].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[7].s64 = ctx.r[7].s32 as i64;
	// 83236C60: 80DF0014  lwz r6, 0x14(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 83236C64: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 83236C68: 7CA74050  subf r5, r7, r8
	ctx.r[5].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 83236C6C: 90BF001C  stw r5, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[5].u32 ) };
	// 83236C70: 80860000  lwz r4, 0(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 83236C74: 7D643850  subf r11, r4, r7
	ctx.r[11].s64 = ctx.r[7].s64 - ctx.r[4].s64;
	// 83236C78: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 83236C7C: 907F0020  stw r3, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 83236C80: 7C2004AC  lwsync
	// 83236C84: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 83236C88: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83236C8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 83236C90: 4BA727CC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x83236C94 => {
    //   block [0x83236C94..0x83236CB4)
	// 83236C94: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83236C98: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 83236C9C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 83236CA0: 409A0054  bne cr6, 0x83236cf4
	if !ctx.cr[6].eq {
	pc = 0x83236CF4; continue 'dispatch;
	}
	// 83236CA4: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 83236CA8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 83236CAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83236CB0: 419A001C  beq cr6, 0x83236ccc
	if ctx.cr[6].eq {
	pc = 0x83236CCC; continue 'dispatch;
	}
	pc = 0x83236CB4; continue 'dispatch;
            }
            0x83236CB4 => {
    //   block [0x83236CB4..0x83236CCC)
	// 83236CB4: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 83236CB8: 40980014  bge cr6, 0x83236ccc
	if !ctx.cr[6].lt {
	pc = 0x83236CCC; continue 'dispatch;
	}
	// 83236CBC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 83236CC0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 83236CC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83236CC8: 409AFFEC  bne cr6, 0x83236cb4
	if !ctx.cr[6].eq {
	pc = 0x83236CB4; continue 'dispatch;
	}
	pc = 0x83236CCC; continue 'dispatch;
            }
            0x83236CCC => {
    //   block [0x83236CCC..0x83236CF0)
	// 83236CCC: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 83236CD0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83236CD4: 419A001C  beq cr6, 0x83236cf0
	if ctx.cr[6].eq {
	pc = 0x83236CF0; continue 'dispatch;
	}
	// 83236CD8: 908A0008  stw r4, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 83236CDC: 7C2004AC  lwsync
	// 83236CE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 83236CE4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83236CE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 83236CEC: 4BA72770  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x83236CF0 => {
    //   block [0x83236CF0..0x83236CF4)
	// 83236CF0: 909F0010  stw r4, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[4].u32 ) };
	pc = 0x83236CF4; continue 'dispatch;
            }
            0x83236CF4 => {
    //   block [0x83236CF4..0x83236D08)
	// 83236CF4: 7C2004AC  lwsync
	// 83236CF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 83236CFC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83236D00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 83236D04: 4BA72758  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83236D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83236D08 size=88
    let mut pc: u32 = 0x83236D08;
    'dispatch: loop {
        match pc {
            0x83236D08 => {
    //   block [0x83236D08..0x83236D60)
	// 83236D08: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 83236D0C: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 83236D10: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 83236D14: 9083000C  stw r4, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	// 83236D18: 3944000F  addi r10, r4, 0xf
	ctx.r[10].s64 = ctx.r[4].s64 + 15;
	// 83236D1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83236D20: 0CC40000  twi 6, r4, 0
	// 83236D24: 7D0A2396  divwu r8, r10, r4
	ctx.r[8].u32 = ctx.r[10].u32 / ctx.r[4].u32;
	// 83236D28: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 83236D2C: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 83236D30: 7CC821D6  mullw r6, r8, r4
	ctx.r[6].s32 = ((ctx.r[8].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[6].s64 = ctx.r[6].s32 as i64;
	// 83236D34: 38EBFFFF  addi r7, r11, -1
	ctx.r[7].s64 = ctx.r[11].s64 + -1;
	// 83236D38: 0CC40000  twi 6, r4, 0
	// 83236D3C: 7CA72396  divwu r5, r7, r4
	ctx.r[5].u32 = ctx.r[7].u32 / ctx.r[4].u32;
	// 83236D40: 7C8521D6  mullw r4, r5, r4
	ctx.r[4].s32 = ((ctx.r[5].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 83236D44: 90830004  stw r4, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 83236D48: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 83236D4C: 7D465850  subf r10, r6, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[6].s64;
	// 83236D50: 7D2A2396  divwu r9, r10, r4
	ctx.r[9].u32 = ctx.r[10].u32 / ctx.r[4].u32;
	// 83236D54: 0CC40000  twi 6, r4, 0
	// 83236D58: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 83236D5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83236D60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83236D60 size=128
    let mut pc: u32 = 0x83236D60;
    'dispatch: loop {
        match pc {
            0x83236D60 => {
    //   block [0x83236D60..0x83236D78)
	// 83236D60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83236D64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83236D68: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83236D6C: 8124001C  lwz r9, 0x1c(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 83236D70: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83236D74: 419A002C  beq cr6, 0x83236da0
	if ctx.cr[6].eq {
	pc = 0x83236DA0; continue 'dispatch;
	}
	pc = 0x83236D78; continue 'dispatch;
            }
            0x83236D78 => {
    //   block [0x83236D78..0x83236D94)
	// 83236D78: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 83236D7C: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83236D80: 41980014  blt cr6, 0x83236d94
	if ctx.cr[6].lt {
	pc = 0x83236D94; continue 'dispatch;
	}
	// 83236D84: 81440014  lwz r10, 0x14(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 83236D88: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 83236D8C: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83236D90: 41980024  blt cr6, 0x83236db4
	if ctx.cr[6].lt {
	pc = 0x83236DB4; continue 'dispatch;
	}
	pc = 0x83236D94; continue 'dispatch;
            }
            0x83236D94 => {
    //   block [0x83236D94..0x83236DA0)
	// 83236D94: 8129000C  lwz r9, 0xc(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 83236D98: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83236D9C: 409AFFDC  bne cr6, 0x83236d78
	if !ctx.cr[6].eq {
	pc = 0x83236D78; continue 'dispatch;
	}
	pc = 0x83236DA0; continue 'dispatch;
            }
            0x83236DA0 => {
    //   block [0x83236DA0..0x83236DB4)
	// 83236DA0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 83236DA4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 83236DA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 83236DAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83236DB0: 4E800020  blr
	return;
            }
            0x83236DB4 => {
    //   block [0x83236DB4..0x83236DE0)
	// 83236DB4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 83236DB8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 83236DBC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 83236DC0: 7C6A5878  andc r10, r3, r11
	ctx.r[10].u64 = ctx.r[3].u64 & !ctx.r[11].u64;
	// 83236DC4: 806A000C  lwz r3, 0xc(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 83236DC8: 4BFFFDD1  bl 0x83236b98
	ctx.lr = 0x83236DCC;
	sub_83236B98(ctx, base);
	// 83236DCC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 83236DD0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 83236DD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 83236DD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83236DDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83236DE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83236DE0 size=284
    let mut pc: u32 = 0x83236DE0;
    'dispatch: loop {
        match pc {
            0x83236DE0 => {
    //   block [0x83236DE0..0x83236E18)
	// 83236DE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83236DE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83236DE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 83236DEC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83236DF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83236DF4: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 83236DF8: 48005CB1  bl 0x8323caa8
	ctx.lr = 0x83236DFC;
	sub_8323CAA8(ctx, base);
	// 83236DFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 83236E00: 409A0018  bne cr6, 0x83236e18
	if !ctx.cr[6].eq {
	pc = 0x83236E18; continue 'dispatch;
	}
	// 83236E04: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 83236E08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 83236E0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83236E10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 83236E14: 4E800020  blr
	return;
            }
            0x83236E18 => {
    //   block [0x83236E18..0x83236E50)
	// 83236E18: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 83236E1C: 394B000F  addi r10, r11, 0xf
	ctx.r[10].s64 = ctx.r[11].s64 + 15;
	// 83236E20: 0CCB0000  twi 6, r11, 0
	// 83236E24: 7D2A5B96  divwu r9, r10, r11
	ctx.r[9].u32 = ctx.r[10].u32 / ctx.r[11].u32;
	// 83236E28: 7D6959D6  mullw r11, r9, r11
	ctx.r[11].s32 = ((ctx.r[9].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 83236E2C: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 83236E30: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83236E34: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83236E38: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83236E3C: 38EAFFFF  addi r7, r10, -1
	ctx.r[7].s64 = ctx.r[10].s64 + -1;
	// 83236E40: 7D4741D6  mullw r10, r7, r8
	ctx.r[10].s32 = ((ctx.r[7].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 83236E44: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 83236E48: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 83236E4C: 419A001C  beq cr6, 0x83236e68
	if ctx.cr[6].eq {
	pc = 0x83236E68; continue 'dispatch;
	}
	pc = 0x83236E50; continue 'dispatch;
            }
            0x83236E50 => {
    //   block [0x83236E50..0x83236E68)
	// 83236E50: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83236E54: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 83236E58: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 83236E5C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 83236E60: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 83236E64: 409AFFEC  bne cr6, 0x83236e50
	if !ctx.cr[6].eq {
	pc = 0x83236E50; continue 'dispatch;
	}
	pc = 0x83236E68; continue 'dispatch;
            }
            0x83236E68 => {
    //   block [0x83236E68..0x83236E88)
	// 83236E68: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 83236E6C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 83236E70: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 83236E74: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 83236E78: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 83236E7C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 83236E80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83236E84: 419A001C  beq cr6, 0x83236ea0
	if ctx.cr[6].eq {
	pc = 0x83236EA0; continue 'dispatch;
	}
	pc = 0x83236E88; continue 'dispatch;
            }
            0x83236E88 => {
    //   block [0x83236E88..0x83236EA0)
	// 83236E88: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 83236E8C: 40980014  bge cr6, 0x83236ea0
	if !ctx.cr[6].lt {
	pc = 0x83236EA0; continue 'dispatch;
	}
	// 83236E90: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 83236E94: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 83236E98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83236E9C: 409AFFEC  bne cr6, 0x83236e88
	if !ctx.cr[6].eq {
	pc = 0x83236E88; continue 'dispatch;
	}
	pc = 0x83236EA0; continue 'dispatch;
            }
            0x83236EA0 => {
    //   block [0x83236EA0..0x83236EB4)
	// 83236EA0: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 83236EA4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83236EA8: 419A000C  beq cr6, 0x83236eb4
	if ctx.cr[6].eq {
	pc = 0x83236EB4; continue 'dispatch;
	}
	// 83236EAC: 906A0008  stw r3, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 83236EB0: 48000008  b 0x83236eb8
	pc = 0x83236EB8; continue 'dispatch;
            }
            0x83236EB4 => {
    //   block [0x83236EB4..0x83236EB8)
	// 83236EB4: 907F0010  stw r3, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	pc = 0x83236EB8; continue 'dispatch;
            }
            0x83236EB8 => {
    //   block [0x83236EB8..0x83236EFC)
	// 83236EB8: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 83236EBC: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83236EC0: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83236EC4: 813F0020  lwz r9, 0x20(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 83236EC8: 7D6839D6  mullw r11, r8, r7
	ctx.r[11].s32 = ((ctx.r[8].s32 as i64 * ctx.r[7].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 83236ECC: 811F001C  lwz r8, 0x1c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 83236ED0: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 83236ED4: 7D4B3050  subf r10, r11, r6
	ctx.r[10].s64 = ctx.r[6].s64 - ctx.r[11].s64;
	// 83236ED8: 7CAB4214  add r5, r11, r8
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 83236EDC: 7C8A4A14  add r4, r10, r9
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 83236EE0: 90BF001C  stw r5, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[5].u32 ) };
	// 83236EE4: 909F0020  stw r4, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 83236EE8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 83236EEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 83236EF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83236EF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 83236EF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83236F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83236F00 size=244
    let mut pc: u32 = 0x83236F00;
    'dispatch: loop {
        match pc {
            0x83236F00 => {
    //   block [0x83236F00..0x83236F54)
	// 83236F00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83236F04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83236F08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 83236F0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 83236F10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83236F14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83236F18: 3BDF0024  addi r30, r31, 0x24
	ctx.r[30].s64 = ctx.r[31].s64 + 36;
	// 83236F1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 83236F20: 4B09FD69  bl 0x822d6c88
	ctx.lr = 0x83236F24;
	sub_822D6C88(ctx, base);
	// 83236F24: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 83236F28: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83236F2C: 409A0028  bne cr6, 0x83236f54
	if !ctx.cr[6].eq {
	pc = 0x83236F54; continue 'dispatch;
	}
	// 83236F30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83236F34: 4BFFFEAD  bl 0x83236de0
	ctx.lr = 0x83236F38;
	sub_83236DE0(ctx, base);
	// 83236F38: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 83236F3C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83236F40: 409A0014  bne cr6, 0x83236f54
	if !ctx.cr[6].eq {
	pc = 0x83236F54; continue 'dispatch;
	}
	// 83236F44: 7C2004AC  lwsync
	// 83236F48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 83236F4C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83236F50: 4800008C  b 0x83236fdc
	pc = 0x83236FDC; continue 'dispatch;
            }
            0x83236F54 => {
    //   block [0x83236F54..0x83236F84)
	// 83236F54: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 83236F58: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 83236F5C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 83236F60: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83236F64: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 83236F68: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83236F6C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 83236F70: 409A0044  bne cr6, 0x83236fb4
	if !ctx.cr[6].eq {
	pc = 0x83236FB4; continue 'dispatch;
	}
	// 83236F74: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 83236F78: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 83236F7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83236F80: 419A001C  beq cr6, 0x83236f9c
	if ctx.cr[6].eq {
	pc = 0x83236F9C; continue 'dispatch;
	}
	pc = 0x83236F84; continue 'dispatch;
            }
            0x83236F84 => {
    //   block [0x83236F84..0x83236F9C)
	// 83236F84: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 83236F88: 419A0014  beq cr6, 0x83236f9c
	if ctx.cr[6].eq {
	pc = 0x83236F9C; continue 'dispatch;
	}
	// 83236F8C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 83236F90: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 83236F94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83236F98: 409AFFEC  bne cr6, 0x83236f84
	if !ctx.cr[6].eq {
	pc = 0x83236F84; continue 'dispatch;
	}
	pc = 0x83236F9C; continue 'dispatch;
            }
            0x83236F9C => {
    //   block [0x83236F9C..0x83236FB0)
	// 83236F9C: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 83236FA0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83236FA4: 419A000C  beq cr6, 0x83236fb0
	if ctx.cr[6].eq {
	pc = 0x83236FB0; continue 'dispatch;
	}
	// 83236FA8: 91690008  stw r11, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 83236FAC: 48000008  b 0x83236fb4
	pc = 0x83236FB4; continue 'dispatch;
            }
            0x83236FB0 => {
    //   block [0x83236FB0..0x83236FB4)
	// 83236FB0: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x83236FB4; continue 'dispatch;
            }
            0x83236FB4 => {
    //   block [0x83236FB4..0x83236FDC)
	// 83236FB4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83236FB8: 813F001C  lwz r9, 0x1c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 83236FBC: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 83236FC0: 7D0B4850  subf r8, r11, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 83236FC4: 7CEA5A14  add r7, r10, r11
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 83236FC8: 911F001C  stw r8, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[8].u32 ) };
	// 83236FCC: 90FF0018  stw r7, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[7].u32 ) };
	// 83236FD0: 7C2004AC  lwsync
	// 83236FD4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 83236FD8: 90DE0000  stw r6, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	pc = 0x83236FDC; continue 'dispatch;
            }
            0x83236FDC => {
    //   block [0x83236FDC..0x83236FF4)
	// 83236FDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 83236FE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 83236FE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83236FE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 83236FEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 83236FF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83236FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83236FF8 size=4
    let mut pc: u32 = 0x83236FF8;
    'dispatch: loop {
        match pc {
            0x83236FF8 => {
    //   block [0x83236FF8..0x83236FFC)
	// 83236FF8: 4BA75148  b 0x82cac140
	sub_82CAC140(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83237000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83237000 size=4
    let mut pc: u32 = 0x83237000;
    'dispatch: loop {
        match pc {
            0x83237000 => {
    //   block [0x83237000..0x83237004)
	// 83237000: 4BA73488  b 0x82caa488
	sub_82CAA488(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83237008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83237008 size=48
    let mut pc: u32 = 0x83237008;
    'dispatch: loop {
        match pc {
            0x83237008 => {
    //   block [0x83237008..0x8323701C)
	// 83237008: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 8323700C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 83237010: 806A6DC8  lwz r3, 0x6dc8(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28104 as u32) ) } as u64;
	// 83237014: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 83237018: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	pc = 0x8323701C; continue 'dispatch;
            }
            0x8323701C => {
    //   block [0x8323701C..0x83237038)
	// 8323701C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83237020: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83237024: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 83237028: 80630008  lwz r3, 8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323702C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 83237030: 409AFFEC  bne cr6, 0x8323701c
	if !ctx.cr[6].eq {
	pc = 0x8323701C; continue 'dispatch;
	}
	// 83237034: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83237038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83237038 size=136
    let mut pc: u32 = 0x83237038;
    'dispatch: loop {
        match pc {
            0x83237038 => {
    //   block [0x83237038..0x83237070)
	// 83237038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323703C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83237040: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 83237044: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 83237048: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323704C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 83237050: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83237054: 3BCBE468  addi r30, r11, -0x1b98
	ctx.r[30].s64 = ctx.r[11].s64 + -7064;
	// 83237058: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323705C: 4B09FC2D  bl 0x822d6c88
	ctx.lr = 0x83237060;
	sub_822D6C88(ctx, base);
	// 83237060: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 83237064: 816B6DC8  lwz r11, 0x6dc8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28104 as u32) ) } as u64;
	// 83237068: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323706C: 419A001C  beq cr6, 0x83237088
	if ctx.cr[6].eq {
	pc = 0x83237088; continue 'dispatch;
	}
	pc = 0x83237070; continue 'dispatch;
            }
            0x83237070 => {
    //   block [0x83237070..0x83237088)
	// 83237070: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83237074: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 83237078: 419A0038  beq cr6, 0x832370b0
	if ctx.cr[6].eq {
	pc = 0x832370B0; continue 'dispatch;
	}
	// 8323707C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 83237080: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83237084: 409AFFEC  bne cr6, 0x83237070
	if !ctx.cr[6].eq {
	pc = 0x83237070; continue 'dispatch;
	}
	pc = 0x83237088; continue 'dispatch;
            }
            0x83237088 => {
    //   block [0x83237088..0x8323708C)
	// 83237088: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x8323708C; continue 'dispatch;
            }
            0x8323708C => {
    //   block [0x8323708C..0x832370B0)
	// 8323708C: 7C2004AC  lwsync
	// 83237090: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 83237094: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83237098: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8323709C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832370A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832370A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832370A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832370AC: 4E800020  blr
	return;
            }
            0x832370B0 => {
    //   block [0x832370B0..0x832370C0)
	// 832370B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832370B4: 419AFFD4  beq cr6, 0x83237088
	if ctx.cr[6].eq {
	pc = 0x83237088; continue 'dispatch;
	}
	// 832370B8: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 832370BC: 4BFFFFD0  b 0x8323708c
	pc = 0x8323708C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832370C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832370C0 size=184
    let mut pc: u32 = 0x832370C0;
    'dispatch: loop {
        match pc {
            0x832370C0 => {
    //   block [0x832370C0..0x832370F8)
	// 832370C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832370C4: 4BA72349  bl 0x82ca940c
	ctx.lr = 0x832370C8;
	sub_82CA93D0(ctx, base);
	// 832370C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832370CC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832370D0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 832370D4: 3BEBE468  addi r31, r11, -0x1b98
	ctx.r[31].s64 = ctx.r[11].s64 + -7064;
	// 832370D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832370DC: 4B09FBAD  bl 0x822d6c88
	ctx.lr = 0x832370E0;
	sub_822D6C88(ctx, base);
	// 832370E0: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 832370E4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 832370E8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 832370EC: 808A6DC8  lwz r4, 0x6dc8(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28104 as u32) ) } as u64;
	// 832370F0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 832370F4: 419A0020  beq cr6, 0x83237114
	if ctx.cr[6].eq {
	pc = 0x83237114; continue 'dispatch;
	}
	pc = 0x832370F8; continue 'dispatch;
            }
            0x832370F8 => {
    //   block [0x832370F8..0x83237114)
	// 832370F8: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 832370FC: 7F09F040  cmplw cr6, r9, r30
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[30].u32, &mut ctx.xer);
	// 83237100: 419A0028  beq cr6, 0x83237128
	if ctx.cr[6].eq {
	pc = 0x83237128; continue 'dispatch;
	}
	// 83237104: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 83237108: 80840008  lwz r4, 8(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323710C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 83237110: 409AFFE8  bne cr6, 0x832370f8
	if !ctx.cr[6].eq {
	pc = 0x832370F8; continue 'dispatch;
	}
	pc = 0x83237114; continue 'dispatch;
            }
            0x83237114 => {
    //   block [0x83237114..0x83237128)
	// 83237114: 7C2004AC  lwsync
	// 83237118: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8323711C: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 83237120: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 83237124: 4BA72338  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x83237128 => {
    //   block [0x83237128..0x8323713C)
	// 83237128: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323712C: 419A0010  beq cr6, 0x8323713c
	if ctx.cr[6].eq {
	pc = 0x8323713C; continue 'dispatch;
	}
	// 83237130: 81440008  lwz r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 83237134: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 83237138: 4800000C  b 0x83237144
	pc = 0x83237144; continue 'dispatch;
            }
            0x8323713C => {
    //   block [0x8323713C..0x83237144)
	// 8323713C: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 83237140: 916A6DC8  stw r11, 0x6dc8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28104 as u32), ctx.r[11].u32 ) };
	pc = 0x83237144; continue 'dispatch;
            }
            0x83237144 => {
    //   block [0x83237144..0x83237178)
	// 83237144: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 83237148: 806B6DC4  lwz r3, 0x6dc4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28100 as u32) ) } as u64;
	// 8323714C: 4BFFF1CD  bl 0x83236318
	ctx.lr = 0x83237150;
	sub_83236318(ctx, base);
	// 83237150: 3CA00000  lis r5, 0
	ctx.r[5].s64 = 0;
	// 83237154: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 83237158: 60A58000  ori r5, r5, 0x8000
	ctx.r[5].u64 = ctx.r[5].u64 | 32768;
	// 8323715C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 83237160: 4BA903E9  bl 0x82cc7548
	ctx.lr = 0x83237164;
	sub_82CC7548(ctx, base);
	// 83237164: 7C2004AC  lwsync
	// 83237168: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8323716C: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 83237170: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 83237174: 4BA722E8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83237178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83237178 size=168
    let mut pc: u32 = 0x83237178;
    'dispatch: loop {
        match pc {
            0x83237178 => {
    //   block [0x83237178..0x832371C4)
	// 83237178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323717C: 4BA72291  bl 0x82ca940c
	ctx.lr = 0x83237180;
	sub_82CA93D0(ctx, base);
	// 83237180: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83237184: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 83237188: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8323718C: 3BCBE468  addi r30, r11, -0x1b98
	ctx.r[30].s64 = ctx.r[11].s64 + -7064;
	// 83237190: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 83237194: 4B09FAF5  bl 0x822d6c88
	ctx.lr = 0x83237198;
	sub_822D6C88(ctx, base);
	// 83237198: 3D7D0001  addis r11, r29, 1
	ctx.r[11].s64 = ctx.r[29].s64 + 65536;
	// 8323719C: 3CA02090  lis r5, 0x2090
	ctx.r[5].s64 = 546308096;
	// 832371A0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 832371A4: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 832371A8: 60A51000  ori r5, r5, 0x1000
	ctx.r[5].u64 = ctx.r[5].u64 | 4096;
	// 832371AC: 5564001E  rlwinm r4, r11, 0, 0, 0xf
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 832371B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 832371B4: 4BA90345  bl 0x82cc74f8
	ctx.lr = 0x832371B8;
	sub_82CC74F8(ctx, base);
	// 832371B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832371BC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 832371C0: 409A001C  bne cr6, 0x832371dc
	if !ctx.cr[6].eq {
	pc = 0x832371DC; continue 'dispatch;
	}
	pc = 0x832371C4; continue 'dispatch;
            }
            0x832371C4 => {
    //   block [0x832371C4..0x832371DC)
	// 832371C4: 7C2004AC  lwsync
	// 832371C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832371CC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 832371D0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 832371D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832371D8: 4BA72284  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x832371DC => {
    //   block [0x832371DC..0x83237220)
	// 832371DC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 832371E0: 806B6DC4  lwz r3, 0x6dc4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28100 as u32) ) } as u64;
	// 832371E4: 4BFFF1C5  bl 0x832363a8
	ctx.lr = 0x832371E8;
	sub_832363A8(ctx, base);
	// 832371E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832371EC: 419AFFD8  beq cr6, 0x832371c4
	if ctx.cr[6].eq {
	pc = 0x832371C4; continue 'dispatch;
	}
	// 832371F0: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 832371F4: 93E30000  stw r31, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 832371F8: 93A30004  stw r29, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 832371FC: 816A6DC8  lwz r11, 0x6dc8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28104 as u32) ) } as u64;
	// 83237200: 906A6DC8  stw r3, 0x6dc8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28104 as u32), ctx.r[3].u32 ) };
	// 83237204: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 83237208: 7C2004AC  lwsync
	// 8323720C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 83237210: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83237214: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 83237218: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8323721C: 4BA72240  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83237228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83237228 size=152
    let mut pc: u32 = 0x83237228;
    'dispatch: loop {
        match pc {
            0x83237228 => {
    //   block [0x83237228..0x83237278)
	// 83237228: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323722C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83237230: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 83237234: 3BE1FF90  addi r31, r1, -0x70
	ctx.r[31].s64 = ctx.r[1].s64 + -112;
	// 83237238: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323723C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 83237240: 4BA73249  bl 0x82caa488
	ctx.lr = 0x83237244;
	sub_82CAA488(ctx, base);
	// 83237244: 907F0050  stw r3, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 83237248: 907F0054  stw r3, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 8323724C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 83237250: 419A0028  beq cr6, 0x83237278
	if ctx.cr[6].eq {
	pc = 0x83237278; continue 'dispatch;
	}
	// 83237254: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 83237258: 39400154  li r10, 0x154
	ctx.r[10].s64 = 340;
	// 8323725C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 83237260: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83237264: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 83237268: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 8323726C: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 83237270: 90686DC4  stw r3, 0x6dc4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(28100 as u32), ctx.r[3].u32 ) };
	// 83237274: 4800000C  b 0x83237280
	pc = 0x83237280; continue 'dispatch;
            }
            0x83237278 => {
    //   block [0x83237278..0x83237280)
	// 83237278: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8323727C: 906B6DC4  stw r3, 0x6dc4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28100 as u32), ctx.r[3].u32 ) };
	pc = 0x83237280; continue 'dispatch;
            }
            0x83237280 => {
    //   block [0x83237280..0x832372C0)
	// 83237280: 383F0070  addi r1, r31, 0x70
	ctx.r[1].s64 = ctx.r[31].s64 + 112;
	// 83237284: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 83237288: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8323728C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 83237290: 4E800020  blr
	return;
	// 83237294: 3BECFF90  addi r31, r12, -0x70
	ctx.r[31].s64 = ctx.r[12].s64 + -112;
	// 83237298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323729C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832372A0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832372A4: 809F0050  lwz r4, 0x50(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 832372A8: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 832372AC: 4B95FBCD  bl 0x82b96e78
	ctx.lr = 0x832372B0;
	sub_82B96E78(ctx, base);
	// 832372B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832372B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832372B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832372BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832372C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832372C0 size=128
    let mut pc: u32 = 0x832372C0;
    'dispatch: loop {
        match pc {
            0x832372C0 => {
    //   block [0x832372C0..0x83237310)
	// 832372C0: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 832372C4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 832372C8: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 832372CC: 396AFFFF  addi r11, r10, -1
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	// 832372D0: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 832372D4: 7D0A2850  subf r8, r10, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 832372D8: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 832372DC: 7CAB2214  add r5, r11, r4
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 832372E0: 38880001  addi r4, r8, 1
	ctx.r[4].s64 = ctx.r[8].s64 + 1;
	// 832372E4: 7D295878  andc r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 & !ctx.r[11].u64;
	// 832372E8: 3BEAFFFF  addi r31, r10, -1
	ctx.r[31].s64 = ctx.r[10].s64 + -1;
	// 832372EC: 7CA85878  andc r8, r5, r11
	ctx.r[8].u64 = ctx.r[5].u64 & !ctx.r[11].u64;
	// 832372F0: 7C8BF878  andc r11, r4, r31
	ctx.r[11].u64 = ctx.r[4].u64 & !ctx.r[31].u64;
	// 832372F4: 7D291A14  add r9, r9, r3
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[3].u64;
	// 832372F8: 91060000  stw r8, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 832372FC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 83237300: 41980030  blt cr6, 0x83237330
	if ctx.cr[6].lt {
	pc = 0x83237330; continue 'dispatch;
	}
	// 83237304: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 83237308: 40980008  bge cr6, 0x83237310
	if !ctx.cr[6].lt {
	pc = 0x83237310; continue 'dispatch;
	}
	// 8323730C: 91260000  stw r9, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	pc = 0x83237310; continue 'dispatch;
            }
            0x83237310 => {
    //   block [0x83237310..0x83237330)
	// 83237310: 81260000  lwz r9, 0(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 83237314: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83237318: 41990018  bgt cr6, 0x83237330
	if ctx.cr[6].gt {
	pc = 0x83237330; continue 'dispatch;
	}
	// 8323731C: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 83237320: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 83237324: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83237328: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 8323732C: 4E800020  blr
	return;
            }
            0x83237330 => {
    //   block [0x83237330..0x83237340)
	// 83237330: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 83237334: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 83237338: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 8323733C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83237340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83237340 size=20
    let mut pc: u32 = 0x83237340;
    'dispatch: loop {
        match pc {
            0x83237340 => {
    //   block [0x83237340..0x83237354)
	// 83237340: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 83237344: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83237348: 409A000C  bne cr6, 0x83237354
	if !ctx.cr[6].eq {
		sub_83237354(ctx, base);
		return;
	}
	// 8323734C: 90830018  stw r4, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[4].u32 ) };
	// 83237350: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83237354(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83237354 size=44
    let mut pc: u32 = 0x83237354;
    'dispatch: loop {
        match pc {
            0x83237354 => {
    //   block [0x83237354..0x83237364)
	// 83237354: 396A0008  addi r11, r10, 8
	ctx.r[11].s64 = ctx.r[10].s64 + 8;
	// 83237358: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323735C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83237360: 419A0018  beq cr6, 0x83237378
	if ctx.cr[6].eq {
	pc = 0x83237378; continue 'dispatch;
	}
	pc = 0x83237364; continue 'dispatch;
            }
            0x83237364 => {
    //   block [0x83237364..0x83237378)
	// 83237364: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83237368: 396A0008  addi r11, r10, 8
	ctx.r[11].s64 = ctx.r[10].s64 + 8;
	// 8323736C: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 83237370: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83237374: 409AFFF0  bne cr6, 0x83237364
	if !ctx.cr[6].eq {
	pc = 0x83237364; continue 'dispatch;
	}
	pc = 0x83237378; continue 'dispatch;
            }
            0x83237378 => {
    //   block [0x83237378..0x83237380)
	// 83237378: 908A0008  stw r4, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 8323737C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83237380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83237380 size=80
    let mut pc: u32 = 0x83237380;
    'dispatch: loop {
        match pc {
            0x83237380 => {
    //   block [0x83237380..0x832373B8)
	// 83237380: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 83237384: 90830000  stw r4, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 83237388: 7D683850  subf r11, r8, r7
	ctx.r[11].s64 = ctx.r[7].s64 - ctx.r[8].s64;
	// 8323738C: 90A30004  stw r5, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 83237390: 90C30008  stw r6, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 83237394: 90E3000C  stw r7, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 83237398: 2B0B0400  cmplwi cr6, r11, 0x400
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1024 as u32, &mut ctx.xer);
	// 8323739C: 91030010  stw r8, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 832373A0: 91430014  stw r10, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 832373A4: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 832373A8: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 832373AC: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 832373B0: 91430024  stw r10, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 832373B4: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	pc = 0x832373B8; continue 'dispatch;
            }
            0x832373B8 => {
    //   block [0x832373B8..0x832373D0)
	// 832373B8: 556BF87E  srwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832373BC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 832373C0: 2B0B0400  cmplwi cr6, r11, 0x400
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1024 as u32, &mut ctx.xer);
	// 832373C4: 4199FFF4  bgt cr6, 0x832373b8
	if ctx.cr[6].gt {
	pc = 0x832373B8; continue 'dispatch;
	}
	// 832373C8: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 832373CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832373D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832373D0 size=4
    let mut pc: u32 = 0x832373D0;
    'dispatch: loop {
        match pc {
            0x832373D0 => {
    //   block [0x832373D0..0x832373D4)
	// 832373D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832373D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832373D8 size=4
    let mut pc: u32 = 0x832373D8;
    'dispatch: loop {
        match pc {
            0x832373D8 => {
    //   block [0x832373D8..0x832373DC)
	// 832373D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832373E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832373E0 size=4
    let mut pc: u32 = 0x832373E0;
    'dispatch: loop {
        match pc {
            0x832373E0 => {
    //   block [0x832373E0..0x832373E4)
	// 832373E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832373E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832373E8 size=4
    let mut pc: u32 = 0x832373E8;
    'dispatch: loop {
        match pc {
            0x832373E8 => {
    //   block [0x832373E8..0x832373EC)
	// 832373E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832373F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832373F0 size=60
    let mut pc: u32 = 0x832373F0;
    'dispatch: loop {
        match pc {
            0x832373F0 => {
    //   block [0x832373F0..0x832373FC)
	// 832373F0: 81230018  lwz r9, 0x18(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 832373F4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 832373F8: 419A002C  beq cr6, 0x83237424
	if ctx.cr[6].eq {
	pc = 0x83237424; continue 'dispatch;
	}
	pc = 0x832373FC; continue 'dispatch;
            }
            0x832373FC => {
    //   block [0x832373FC..0x83237418)
	// 832373FC: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 83237400: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83237404: 41980014  blt cr6, 0x83237418
	if ctx.cr[6].lt {
	pc = 0x83237418; continue 'dispatch;
	}
	// 83237408: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323740C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 83237410: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83237414: 41980018  blt cr6, 0x8323742c
	if ctx.cr[6].lt {
		sub_8323742C(ctx, base);
		return;
	}
	pc = 0x83237418; continue 'dispatch;
            }
            0x83237418 => {
    //   block [0x83237418..0x83237424)
	// 83237418: 81290008  lwz r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323741C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83237420: 409AFFDC  bne cr6, 0x832373fc
	if !ctx.cr[6].eq {
	pc = 0x832373FC; continue 'dispatch;
	}
	pc = 0x83237424; continue 'dispatch;
            }
            0x83237424 => {
    //   block [0x83237424..0x8323742C)
	// 83237424: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 83237428: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323742C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8323742C size=8
    let mut pc: u32 = 0x8323742C;
    'dispatch: loop {
        match pc {
            0x8323742C => {
    //   block [0x8323742C..0x83237434)
	// 8323742C: 8064FFFC  lwz r3, -4(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-4 as u32) ) } as u64;
	// 83237430: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83237438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83237438 size=88
    let mut pc: u32 = 0x83237438;
    'dispatch: loop {
        match pc {
            0x83237438 => {
    //   block [0x83237438..0x83237490)
	// 83237438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323743C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83237440: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 83237444: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 83237448: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323744C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 83237450: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 83237454: 83EB6DBC  lwz r31, 0x6dbc(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28092 as u32) ) } as u64;
	// 83237458: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 8323745C: 4B09F82D  bl 0x822d6c88
	ctx.lr = 0x83237460;
	sub_822D6C88(ctx, base);
	// 83237460: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 83237464: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83237468: 4BFFEEB1  bl 0x83236318
	ctx.lr = 0x8323746C;
	sub_83236318(ctx, base);
	// 8323746C: 7C2004AC  lwsync
	// 83237470: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 83237474: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 83237478: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8323747C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 83237480: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83237484: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 83237488: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8323748C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83237490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83237490 size=112
    let mut pc: u32 = 0x83237490;
    'dispatch: loop {
        match pc {
            0x83237490 => {
    //   block [0x83237490..0x832374E4)
	// 83237490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83237494: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83237498: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8323749C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832374A0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 832374A4: 83EB6DBC  lwz r31, 0x6dbc(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28092 as u32) ) } as u64;
	// 832374A8: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 832374AC: 4B09F7DD  bl 0x822d6c88
	ctx.lr = 0x832374B0;
	sub_822D6C88(ctx, base);
	// 832374B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832374B4: 4BFFEEF5  bl 0x832363a8
	ctx.lr = 0x832374B8;
	sub_832363A8(ctx, base);
	// 832374B8: 7C2004AC  lwsync
	// 832374BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832374C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832374C4: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 832374C8: 409A001C  bne cr6, 0x832374e4
	if !ctx.cr[6].eq {
	pc = 0x832374E4; continue 'dispatch;
	}
	// 832374CC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 832374D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832374D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832374D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832374DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832374E0: 4E800020  blr
	return;
            }
            0x832374E4 => {
    //   block [0x832374E4..0x83237500)
	// 832374E4: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 832374E8: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 832374EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832374F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832374F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832374F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832374FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83237500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83237500 size=116
    let mut pc: u32 = 0x83237500;
    'dispatch: loop {
        match pc {
            0x83237500 => {
    //   block [0x83237500..0x8323755C)
	// 83237500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83237504: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83237508: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8323750C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 83237510: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83237514: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 83237518: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	// 8323751C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 83237520: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 83237524: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 83237528: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8323752C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83237530: 4BFFFD91  bl 0x832372c0
	ctx.lr = 0x83237534;
	sub_832372C0(ctx, base);
	// 83237534: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 83237538: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8323753C: 419A0020  beq cr6, 0x8323755c
	if ctx.cr[6].eq {
	pc = 0x8323755C; continue 'dispatch;
	}
	// 83237540: 38A04000  li r5, 0x4000
	ctx.r[5].s64 = 16384;
	// 83237544: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 83237548: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8323754C: 4BA8FFFD  bl 0x82cc7548
	ctx.lr = 0x83237550;
	sub_82CC7548(ctx, base);
	// 83237550: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 83237554: 7D5E5850  subf r10, r30, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 83237558: 915F0020  stw r10, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	pc = 0x8323755C; continue 'dispatch;
            }
            0x8323755C => {
    //   block [0x8323755C..0x83237574)
	// 8323755C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 83237560: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 83237564: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83237568: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8323756C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 83237570: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83237578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83237578 size=160
    let mut pc: u32 = 0x83237578;
    'dispatch: loop {
        match pc {
            0x83237578 => {
    //   block [0x83237578..0x832375D4)
	// 83237578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323757C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83237580: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 83237584: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 83237588: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323758C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 83237590: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	// 83237594: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 83237598: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 8323759C: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 832375A0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 832375A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832375A8: 4BFFFD19  bl 0x832372c0
	ctx.lr = 0x832375AC;
	sub_832372C0(ctx, base);
	// 832375AC: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 832375B0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 832375B4: 419A0048  beq cr6, 0x832375fc
	if ctx.cr[6].eq {
	pc = 0x832375FC; continue 'dispatch;
	}
	// 832375B8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832375BC: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 832375C0: 39601000  li r11, 0x1000
	ctx.r[11].s64 = 4096;
	// 832375C4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 832375C8: 409A000C  bne cr6, 0x832375d4
	if !ctx.cr[6].eq {
	pc = 0x832375D4; continue 'dispatch;
	}
	// 832375CC: 3D602000  lis r11, 0x2000
	ctx.r[11].s64 = 536870912;
	// 832375D0: 616B1000  ori r11, r11, 0x1000
	ctx.r[11].u64 = ctx.r[11].u64 | 4096;
	pc = 0x832375D4; continue 'dispatch;
            }
            0x832375D4 => {
    //   block [0x832375D4..0x832375FC)
	// 832375D4: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 832375D8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 832375DC: 65650080  oris r5, r11, 0x80
	ctx.r[5].u64 = ctx.r[11].u64 | 8388608;
	// 832375E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 832375E4: 4BA8FF15  bl 0x82cc74f8
	ctx.lr = 0x832375E8;
	sub_82CC74F8(ctx, base);
	// 832375E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832375EC: 419A0014  beq cr6, 0x83237600
	if ctx.cr[6].eq {
	pc = 0x83237600; continue 'dispatch;
	}
	// 832375F0: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 832375F4: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 832375F8: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	pc = 0x832375FC; continue 'dispatch;
            }
            0x832375FC => {
    //   block [0x832375FC..0x83237600)
	// 832375FC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x83237600; continue 'dispatch;
            }
            0x83237600 => {
    //   block [0x83237600..0x83237618)
	// 83237600: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 83237604: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 83237608: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8323760C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 83237610: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 83237614: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83237618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83237618 size=332
    let mut pc: u32 = 0x83237618;
    'dispatch: loop {
        match pc {
            0x83237618 => {
    //   block [0x83237618..0x8323765C)
	// 83237618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323761C: 4BA71DE5  bl 0x82ca9400
	ctx.lr = 0x83237620;
	sub_82CA93D0(ctx, base);
	// 83237620: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83237624: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83237628: 3FA00001  lis r29, 1
	ctx.r[29].s64 = 65536;
	// 8323762C: 39602000  li r11, 0x2000
	ctx.r[11].s64 = 8192;
	// 83237630: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83237634: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83237638: 555A103A  slwi r26, r10, 2
	ctx.r[26].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[26].u64 = ctx.r[26].u32 as u64;
	// 8323763C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83237640: 7F09E840  cmplw cr6, r9, r29
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[29].u32, &mut ctx.xer);
	// 83237644: 391A001F  addi r8, r26, 0x1f
	ctx.r[8].s64 = ctx.r[26].s64 + 31;
	// 83237648: 551B0036  rlwinm r27, r8, 0, 0, 0x1b
	ctx.r[27].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 8323764C: 937F0014  stw r27, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[27].u32 ) };
	// 83237650: 409A000C  bne cr6, 0x8323765c
	if !ctx.cr[6].eq {
	pc = 0x8323765C; continue 'dispatch;
	}
	// 83237654: 3D602000  lis r11, 0x2000
	ctx.r[11].s64 = 536870912;
	// 83237658: 616B2000  ori r11, r11, 0x2000
	ctx.r[11].u64 = ctx.r[11].u64 | 8192;
	pc = 0x8323765C; continue 'dispatch;
            }
            0x8323765C => {
    //   block [0x8323765C..0x83237678)
	// 8323765C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 83237660: 65650080  oris r5, r11, 0x80
	ctx.r[5].u64 = ctx.r[11].u64 | 8388608;
	// 83237664: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 83237668: 4BA8FE91  bl 0x82cc74f8
	ctx.lr = 0x8323766C;
	sub_82CC74F8(ctx, base);
	// 8323766C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 83237670: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 83237674: 409A0010  bne cr6, 0x83237684
	if !ctx.cr[6].eq {
	pc = 0x83237684; continue 'dispatch;
	}
	pc = 0x83237678; continue 'dispatch;
            }
            0x83237678 => {
    //   block [0x83237678..0x83237684)
	// 83237678: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8323767C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 83237680: 4BA71DD0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x83237684 => {
    //   block [0x83237684..0x832376AC)
	// 83237684: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83237688: 39201000  li r9, 0x1000
	ctx.r[9].s64 = 4096;
	// 8323768C: 396AFFFF  addi r11, r10, -1
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	// 83237690: 7F0AE840  cmplw cr6, r10, r29
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[29].u32, &mut ctx.xer);
	// 83237694: 7D4BDA14  add r10, r11, r27
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 83237698: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 8323769C: 7D5D5878  andc r29, r10, r11
	ctx.r[29].u64 = ctx.r[10].u64 & !ctx.r[11].u64;
	// 832376A0: 409A000C  bne cr6, 0x832376ac
	if !ctx.cr[6].eq {
	pc = 0x832376AC; continue 'dispatch;
	}
	// 832376A4: 3D202000  lis r9, 0x2000
	ctx.r[9].s64 = 536870912;
	// 832376A8: 61291000  ori r9, r9, 0x1000
	ctx.r[9].u64 = ctx.r[9].u64 | 4096;
	pc = 0x832376AC; continue 'dispatch;
            }
            0x832376AC => {
    //   block [0x832376AC..0x83237764)
	// 832376AC: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 832376B0: 65250080  oris r5, r9, 0x80
	ctx.r[5].u64 = ctx.r[9].u64 | 8388608;
	// 832376B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 832376B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832376BC: 4BA8FE3D  bl 0x82cc74f8
	ctx.lr = 0x832376C0;
	sub_82CC74F8(ctx, base);
	// 832376C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832376C4: 419AFFB4  beq cr6, 0x83237678
	if ctx.cr[6].eq {
	pc = 0x83237678; continue 'dispatch;
	}
	// 832376C8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 832376CC: 3B9E0010  addi r28, r30, 0x10
	ctx.r[28].s64 = ctx.r[30].s64 + 16;
	// 832376D0: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 832376D4: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 832376D8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 832376DC: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 832376E0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 832376E4: 93DE0000  stw r30, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 832376E8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832376EC: 915E000C  stw r10, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 832376F0: 4BA722C1  bl 0x82ca99b0
	ctx.lr = 0x832376F4;
	sub_82CA99B0(ctx, base);
	// 832376F4: 7D7CD214  add r11, r28, r26
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[26].u64;
	// 832376F8: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 832376FC: 3D20ABCD  lis r9, -0x5433
	ctx.r[9].s64 = -1412628480;
	// 83237700: 390B000F  addi r8, r11, 0xf
	ctx.r[8].s64 = ctx.r[11].s64 + 15;
	// 83237704: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 83237708: 551D0036  rlwinm r29, r8, 0, 0, 0x1b
	ctx.r[29].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 8323770C: 6127EF12  ori r7, r9, 0xef12
	ctx.r[7].u64 = ctx.r[9].u64 | 61202;
	// 83237710: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 83237714: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83237718: 90FD0000  stw r7, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 8323771C: 915D0008  stw r10, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 83237720: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83237724: 7F7B3050  subf r27, r27, r6
	ctx.r[27].s64 = ctx.r[6].s64 - ctx.r[27].s64;
	// 83237728: 937D000C  stw r27, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	// 8323772C: 4BFFFD65  bl 0x83237490
	ctx.lr = 0x83237730;
	sub_83237490(ctx, base);
	// 83237730: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 83237734: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83237738: 419AFF40  beq cr6, 0x83237678
	if ctx.cr[6].eq {
	pc = 0x83237678; continue 'dispatch;
	}
	// 8323773C: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 83237740: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 83237744: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 83237748: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8323774C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83237750: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 83237754: 7D2AE214  add r9, r10, r28
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 83237758: 9169FFFC  stw r11, -4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-4 as u32), ctx.r[11].u32 ) };
	// 8323775C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 83237760: 4BA71CF0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83237770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83237770 size=164
    let mut pc: u32 = 0x83237770;
    'dispatch: loop {
        match pc {
            0x83237770 => {
    //   block [0x83237770..0x832377CC)
	// 83237770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83237774: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83237778: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8323777C: 3BE1FF90  addi r31, r1, -0x70
	ctx.r[31].s64 = ctx.r[1].s64 + -112;
	// 83237780: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83237784: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 83237788: 4BA72D01  bl 0x82caa488
	ctx.lr = 0x8323778C;
	sub_82CAA488(ctx, base);
	// 8323778C: 907F0050  stw r3, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 83237790: 907F0054  stw r3, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 83237794: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 83237798: 419A0034  beq cr6, 0x832377cc
	if ctx.cr[6].eq {
	pc = 0x832377CC; continue 'dispatch;
	}
	// 8323779C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832377A0: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 832377A4: 392000FF  li r9, 0xff
	ctx.r[9].s64 = 255;
	// 832377A8: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 832377AC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 832377B0: 3903000C  addi r8, r3, 0xc
	ctx.r[8].s64 = ctx.r[3].s64 + 12;
	// 832377B4: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 832377B8: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 832377BC: 911F0058  stw r8, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 832377C0: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 832377C4: 90676DBC  stw r3, 0x6dbc(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(28092 as u32), ctx.r[3].u32 ) };
	// 832377C8: 4800000C  b 0x832377d4
	pc = 0x832377D4; continue 'dispatch;
            }
            0x832377CC => {
    //   block [0x832377CC..0x832377D4)
	// 832377CC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 832377D0: 906B6DBC  stw r3, 0x6dbc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28092 as u32), ctx.r[3].u32 ) };
	pc = 0x832377D4; continue 'dispatch;
            }
            0x832377D4 => {
    //   block [0x832377D4..0x83237814)
	// 832377D4: 383F0070  addi r1, r31, 0x70
	ctx.r[1].s64 = ctx.r[31].s64 + 112;
	// 832377D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832377DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832377E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832377E4: 4E800020  blr
	return;
	// 832377E8: 3BECFF90  addi r31, r12, -0x70
	ctx.r[31].s64 = ctx.r[12].s64 + -112;
	// 832377EC: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832377F0: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832377F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832377F8: 809F0050  lwz r4, 0x50(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 832377FC: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 83237800: 4B95F679  bl 0x82b96e78
	ctx.lr = 0x83237804;
	sub_82B96E78(ctx, base);
	// 83237804: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 83237808: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8323780C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83237810: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83237818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83237818 size=184
    let mut pc: u32 = 0x83237818;
    'dispatch: loop {
        match pc {
            0x83237818 => {
    //   block [0x83237818..0x8323783C)
	// 83237818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323781C: 4BA71BD9  bl 0x82ca93f4
	ctx.lr = 0x83237820;
	sub_82CA93D0(ctx, base);
	// 83237820: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83237824: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 83237828: 83170018  lwz r24, 0x18(r23)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(24 as u32) ) } as u64;
	// 8323782C: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 83237830: 419A0098  beq cr6, 0x832378c8
	if ctx.cr[6].eq {
	pc = 0x832378C8; continue 'dispatch;
	}
	// 83237834: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 83237838: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	pc = 0x8323783C; continue 'dispatch;
            }
            0x8323783C => {
    //   block [0x8323783C..0x83237850)
	// 8323783C: 81770008  lwz r11, 8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 83237840: 7F99E378  mr r25, r28
	ctx.r[25].u64 = ctx.r[28].u64;
	// 83237844: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83237848: 4099005C  ble cr6, 0x832378a4
	if !ctx.cr[6].gt {
	pc = 0x832378A4; continue 'dispatch;
	}
	// 8323784C: 7F9AE378  mr r26, r28
	ctx.r[26].u64 = ctx.r[28].u64;
	pc = 0x83237850; continue 'dispatch;
            }
            0x83237850 => {
    //   block [0x83237850..0x83237860)
	// 83237850: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 83237854: 7FDA582E  lwzx r30, r26, r11
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 83237858: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8323785C: 419A0034  beq cr6, 0x83237890
	if ctx.cr[6].eq {
	pc = 0x83237890; continue 'dispatch;
	}
	pc = 0x83237860; continue 'dispatch;
            }
            0x83237860 => {
    //   block [0x83237860..0x83237890)
	// 83237860: 83FB6DBC  lwz r31, 0x6dbc(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28092 as u32) ) } as u64;
	// 83237864: 83BE000C  lwz r29, 0xc(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 83237868: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 8323786C: 4B09F41D  bl 0x822d6c88
	ctx.lr = 0x83237870;
	sub_822D6C88(ctx, base);
	// 83237870: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 83237874: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83237878: 4BFFEAA1  bl 0x83236318
	ctx.lr = 0x8323787C;
	sub_83236318(ctx, base);
	// 8323787C: 7C2004AC  lwsync
	// 83237880: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 83237884: 939F000C  stw r28, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 83237888: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8323788C: 409AFFD4  bne cr6, 0x83237860
	if !ctx.cr[6].eq {
	pc = 0x83237860; continue 'dispatch;
	}
	pc = 0x83237890; continue 'dispatch;
            }
            0x83237890 => {
    //   block [0x83237890..0x832378A4)
	// 83237890: 81770008  lwz r11, 8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 83237894: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 83237898: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 8323789C: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 832378A0: 4198FFB0  blt cr6, 0x83237850
	if ctx.cr[6].lt {
	pc = 0x83237850; continue 'dispatch;
	}
	pc = 0x832378A4; continue 'dispatch;
            }
            0x832378A4 => {
    //   block [0x832378A4..0x832378C8)
	// 832378A4: 3CA00000  lis r5, 0
	ctx.r[5].s64 = 0;
	// 832378A8: 83F80008  lwz r31, 8(r24)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 832378AC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 832378B0: 80780000  lwz r3, 0(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 832378B4: 60A58000  ori r5, r5, 0x8000
	ctx.r[5].u64 = ctx.r[5].u64 | 32768;
	// 832378B8: 4BA8FC91  bl 0x82cc7548
	ctx.lr = 0x832378BC;
	sub_82CC7548(ctx, base);
	// 832378BC: 7FF8FB78  mr r24, r31
	ctx.r[24].u64 = ctx.r[31].u64;
	// 832378C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 832378C4: 409AFF78  bne cr6, 0x8323783c
	if !ctx.cr[6].eq {
	pc = 0x8323783C; continue 'dispatch;
	}
	pc = 0x832378C8; continue 'dispatch;
            }
            0x832378C8 => {
    //   block [0x832378C8..0x832378D0)
	// 832378C8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 832378CC: 4BA71B78  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832378D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x832378D0 size=484
    let mut pc: u32 = 0x832378D0;
    'dispatch: loop {
        match pc {
            0x832378D0 => {
    //   block [0x832378D0..0x832378F4)
	// 832378D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832378D4: 4BA71B19  bl 0x82ca93ec
	ctx.lr = 0x832378D8;
	sub_82CA93D0(ctx, base);
	// 832378D8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832378DC: 7CB52B78  mr r21, r5
	ctx.r[21].u64 = ctx.r[5].u64;
	// 832378E0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 832378E4: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 832378E8: 83F50000  lwz r31, 0(r21)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 832378EC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 832378F0: 419A001C  beq cr6, 0x8323790c
	if ctx.cr[6].eq {
	pc = 0x8323790C; continue 'dispatch;
	}
	pc = 0x832378F4; continue 'dispatch;
            }
            0x832378F4 => {
    //   block [0x832378F4..0x8323790C)
	// 832378F4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832378F8: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 832378FC: 4098001C  bge cr6, 0x83237918
	if !ctx.cr[6].lt {
	pc = 0x83237918; continue 'dispatch;
	}
	// 83237900: 83FF000C  lwz r31, 0xc(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 83237904: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 83237908: 409AFFEC  bne cr6, 0x832378f4
	if !ctx.cr[6].eq {
	pc = 0x832378F4; continue 'dispatch;
	}
	pc = 0x8323790C; continue 'dispatch;
            }
            0x8323790C => {
    //   block [0x8323790C..0x83237918)
	// 8323790C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 83237910: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 83237914: 4BA71B28  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            0x83237918 => {
    //   block [0x83237918..0x83237940)
	// 83237918: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323791C: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 83237920: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 83237924: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 83237928: 837F0004  lwz r27, 4(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323792C: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 83237930: 7F5EDA14  add r26, r30, r27
	ctx.r[26].u64 = ctx.r[30].u64 + ctx.r[27].u64;
	// 83237934: 7F1A5040  cmplw cr6, r26, r10
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[10].u32, &mut ctx.xer);
	// 83237938: 41980008  blt cr6, 0x83237940
	if ctx.cr[6].lt {
	pc = 0x83237940; continue 'dispatch;
	}
	// 8323793C: 7F1AC378  mr r26, r24
	ctx.r[26].u64 = ctx.r[24].u64;
	pc = 0x83237940; continue 'dispatch;
            }
            0x83237940 => {
    //   block [0x83237940..0x83237964)
	// 83237940: 3ADB0010  addi r22, r27, 0x10
	ctx.r[22].s64 = ctx.r[27].s64 + 16;
	// 83237944: 7F84F050  subf r28, r4, r30
	ctx.r[28].s64 = ctx.r[30].s64 - ctx.r[4].s64;
	// 83237948: 7D762214  add r11, r22, r4
	ctx.r[11].u64 = ctx.r[22].u64 + ctx.r[4].u64;
	// 8323794C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 83237950: 38ABFFEF  addi r5, r11, -0x11
	ctx.r[5].s64 = ctx.r[11].s64 + -17;
	// 83237954: 419A0010  beq cr6, 0x83237964
	if ctx.cr[6].eq {
	pc = 0x83237964; continue 'dispatch;
	}
	// 83237958: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323795C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 83237960: 7F4A5878  andc r10, r26, r11
	ctx.r[10].u64 = ctx.r[26].u64 & !ctx.r[11].u64;
	pc = 0x83237964; continue 'dispatch;
            }
            0x83237964 => {
    //   block [0x83237964..0x83237984)
	// 83237964: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 83237968: 7D2BE010  subfc r9, r11, r28
	ctx.xer.ca = ctx.r[28].u32 >= ctx.r[11].u32;
	ctx.r[9].s64 = ctx.r[28].s64 - ctx.r[11].s64;
	// 8323796C: 7D694910  subfe r11, r9, r9
	let x = (!ctx.r[9].u32);
	let y = ctx.r[9].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 83237970: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 83237974: 5579063E  clrlwi r25, r11, 0x18
	ctx.r[25].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 83237978: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 8323797C: 419A0008  beq cr6, 0x83237984
	if ctx.cr[6].eq {
	pc = 0x83237984; continue 'dispatch;
	}
	// 83237980: 38A50010  addi r5, r5, 0x10
	ctx.r[5].s64 = ctx.r[5].s64 + 16;
	pc = 0x83237984; continue 'dispatch;
            }
            0x83237984 => {
    //   block [0x83237984..0x832379A0)
	// 83237984: 7F055040  cmplw cr6, r5, r10
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[10].u32, &mut ctx.xer);
	// 83237988: 40980018  bge cr6, 0x832379a0
	if !ctx.cr[6].lt {
	pc = 0x832379A0; continue 'dispatch;
	}
	// 8323798C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 83237990: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 83237994: 7D4B2A14  add r10, r11, r5
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 83237998: 7D4B5878  andc r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 & !ctx.r[11].u64;
	// 8323799C: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	pc = 0x832379A0; continue 'dispatch;
            }
            0x832379A0 => {
    //   block [0x832379A0..0x832379D4)
	// 832379A0: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 832379A4: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 832379A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 832379AC: 4BFFFBCD  bl 0x83237578
	ctx.lr = 0x832379B0;
	sub_83237578(ctx, base);
	// 832379B0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 832379B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832379B8: 419AFF54  beq cr6, 0x8323790c
	if ctx.cr[6].eq {
	pc = 0x8323790C; continue 'dispatch;
	}
	// 832379BC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 832379C0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 832379C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832379C8: 419A000C  beq cr6, 0x832379d4
	if ctx.cr[6].eq {
	pc = 0x832379D4; continue 'dispatch;
	}
	// 832379CC: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 832379D0: 48000008  b 0x832379d8
	pc = 0x832379D8; continue 'dispatch;
            }
            0x832379D4 => {
    //   block [0x832379D4..0x832379D8)
	// 832379D4: 91750000  stw r11, 0(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x832379D8; continue 'dispatch;
            }
            0x832379D8 => {
    //   block [0x832379D8..0x832379E4)
	// 832379D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832379DC: 419A0008  beq cr6, 0x832379e4
	if ctx.cr[6].eq {
	pc = 0x832379E4; continue 'dispatch;
	}
	// 832379E0: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x832379E4; continue 'dispatch;
            }
            0x832379E4 => {
    //   block [0x832379E4..0x83237A60)
	// 832379E4: 931F0008  stw r24, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[24].u32 ) };
	// 832379E8: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 832379EC: 931F000C  stw r24, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[24].u32 ) };
	// 832379F0: 931B0004  stw r24, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	// 832379F4: 931B0008  stw r24, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[24].u32 ) };
	// 832379F8: 419A0088  beq cr6, 0x83237a80
	if ctx.cr[6].eq {
	pc = 0x83237A80; continue 'dispatch;
	}
	// 832379FC: 7D7CF050  subf r11, r28, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[28].s64;
	// 83237A00: 3D20ABCD  lis r9, -0x5433
	ctx.r[9].s64 = -1412628480;
	// 83237A04: 917B000C  stw r11, 0xc(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 83237A08: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 83237A0C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83237A10: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 83237A14: 6128EF12  ori r8, r9, 0xef12
	ctx.r[8].u64 = ctx.r[9].u64 | 61202;
	// 83237A18: 931E0008  stw r24, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[24].u32 ) };
	// 83237A1C: 939E000C  stw r28, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 83237A20: 7D0A592E  stwx r8, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[8].u32) };
	// 83237A24: 80FD0010  lwz r7, 0x10(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 83237A28: 7F1C3840  cmplw cr6, r28, r7
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[7].u32, &mut ctx.xer);
	// 83237A2C: 41980034  blt cr6, 0x83237a60
	if ctx.cr[6].lt {
	pc = 0x83237A60; continue 'dispatch;
	}
	// 83237A30: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 83237A34: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 83237A38: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 83237A3C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 83237A40: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 83237A44: 4B7CA265  bl 0x82a01ca8
	ctx.lr = 0x83237A48;
	sub_82A01CA8(ctx, base);
	// 83237A48: 81570004  lwz r10, 4(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 83237A4C: 546B103A  slwi r11, r3, 2
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 83237A50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 83237A54: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 83237A58: 4B7CA1E1  bl 0x82a01c38
	ctx.lr = 0x83237A5C;
	sub_82A01C38(ctx, base);
	// 83237A5C: 48000014  b 0x83237a70
	pc = 0x83237A70; continue 'dispatch;
            }
            0x83237A60 => {
    //   block [0x83237A60..0x83237A70)
	// 83237A60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 83237A64: 4BFFF9D5  bl 0x83237438
	ctx.lr = 0x83237A68;
	sub_83237438(ctx, base);
	// 83237A68: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 83237A6C: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x83237A70; continue 'dispatch;
            }
            0x83237A70 => {
    //   block [0x83237A70..0x83237A80)
	// 83237A70: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 83237A74: 419A0024  beq cr6, 0x83237a98
	if ctx.cr[6].eq {
	pc = 0x83237A98; continue 'dispatch;
	}
	// 83237A78: 939A0008  stw r28, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 83237A7C: 4800001C  b 0x83237a98
	pc = 0x83237A98; continue 'dispatch;
            }
            0x83237A80 => {
    //   block [0x83237A80..0x83237A98)
	// 83237A80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 83237A84: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 83237A88: 4BFFF9B1  bl 0x83237438
	ctx.lr = 0x83237A8C;
	sub_83237438(ctx, base);
	// 83237A8C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 83237A90: 419A0008  beq cr6, 0x83237a98
	if ctx.cr[6].eq {
	pc = 0x83237A98; continue 'dispatch;
	}
	// 83237A94: 931A0008  stw r24, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[24].u32 ) };
	pc = 0x83237A98; continue 'dispatch;
            }
            0x83237A98 => {
    //   block [0x83237A98..0x83237AB4)
	// 83237A98: 817B000C  lwz r11, 0xc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 83237A9C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 83237AA0: 815D0024  lwz r10, 0x24(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 83237AA4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 83237AA8: 917D0024  stw r11, 0x24(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 83237AAC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 83237AB0: 4BA7198C  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83237AB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83237AB8 size=728
    let mut pc: u32 = 0x83237AB8;
    'dispatch: loop {
        match pc {
            0x83237AB8 => {
    //   block [0x83237AB8..0x83237B0C)
	// 83237AB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83237ABC: 4BA7192D  bl 0x82ca93e8
	ctx.lr = 0x83237AC0;
	sub_82CA93D0(ctx, base);
	// 83237AC0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83237AC4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 83237AC8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 83237ACC: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 83237AD0: 3AFD000C  addi r23, r29, 0xc
	ctx.r[23].s64 = ctx.r[29].s64 + 12;
	// 83237AD4: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 83237AD8: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 83237ADC: 815E0024  lwz r10, 0x24(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 83237AE0: 837D0008  lwz r27, 8(r29)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 83237AE4: 7F0BEA14  add r24, r11, r29
	ctx.r[24].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 83237AE8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 83237AEC: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 83237AF0: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 83237AF4: 913E0024  stw r9, 0x24(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), ctx.r[9].u32 ) };
	// 83237AF8: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 83237AFC: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 83237B00: 7F184040  cmplw cr6, r24, r8
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[8].u32, &mut ctx.xer);
	// 83237B04: 41980008  blt cr6, 0x83237b0c
	if ctx.cr[6].lt {
	pc = 0x83237B0C; continue 'dispatch;
	}
	// 83237B08: 7E98A378  mr r24, r20
	ctx.r[24].u64 = ctx.r[20].u64;
	pc = 0x83237B0C; continue 'dispatch;
            }
            0x83237B0C => {
    //   block [0x83237B0C..0x83237B54)
	// 83237B0C: 3ADD0010  addi r22, r29, 0x10
	ctx.r[22].s64 = ctx.r[29].s64 + 16;
	// 83237B10: 7E9AA378  mr r26, r20
	ctx.r[26].u64 = ctx.r[20].u64;
	// 83237B14: 7D76E214  add r11, r22, r28
	ctx.r[11].u64 = ctx.r[22].u64 + ctx.r[28].u64;
	// 83237B18: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 83237B1C: 3AABFFEF  addi r21, r11, -0x11
	ctx.r[21].s64 = ctx.r[11].s64 + -17;
	// 83237B20: 419A00B4  beq cr6, 0x83237bd4
	if ctx.cr[6].eq {
	pc = 0x83237BD4; continue 'dispatch;
	}
	// 83237B24: 7FBBE850  subf r29, r27, r29
	ctx.r[29].s64 = ctx.r[29].s64 - ctx.r[27].s64;
	// 83237B28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 83237B2C: 83FD0004  lwz r31, 4(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 83237B30: 2F1FFFFF  cmpwi cr6, r31, -1
	ctx.cr[6].compare_i32(ctx.r[31].s32, -1, &mut ctx.xer);
	// 83237B34: 409A0020  bne cr6, 0x83237b54
	if !ctx.cr[6].eq {
	pc = 0x83237B54; continue 'dispatch;
	}
	// 83237B38: 4BFFF959  bl 0x83237490
	ctx.lr = 0x83237B3C;
	sub_83237490(ctx, base);
	// 83237B3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83237B40: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 83237B44: 419A0244  beq cr6, 0x83237d88
	if ctx.cr[6].eq {
	pc = 0x83237D88; continue 'dispatch;
	}
	// 83237B48: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 83237B4C: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 83237B50: 48000048  b 0x83237b98
	pc = 0x83237B98; continue 'dispatch;
            }
            0x83237B54 => {
    //   block [0x83237B54..0x83237B80)
	// 83237B54: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 83237B58: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 83237B5C: 4B7CA14D  bl 0x82a01ca8
	ctx.lr = 0x83237B60;
	sub_82A01CA8(ctx, base);
	// 83237B60: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83237B64: 81190004  lwz r8, 4(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 83237B68: 5469103A  slwi r9, r3, 2
	ctx.r[9].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 83237B6C: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 83237B70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83237B74: 419A000C  beq cr6, 0x83237b80
	if ctx.cr[6].eq {
	pc = 0x83237B80; continue 'dispatch;
	}
	// 83237B78: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 83237B7C: 48000008  b 0x83237b84
	pc = 0x83237B84; continue 'dispatch;
            }
            0x83237B80 => {
    //   block [0x83237B80..0x83237B84)
	// 83237B80: 7D49412E  stwx r10, r9, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), ctx.r[10].u32) };
	pc = 0x83237B84; continue 'dispatch;
            }
            0x83237B84 => {
    //   block [0x83237B84..0x83237B90)
	// 83237B84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83237B88: 419A0008  beq cr6, 0x83237b90
	if ctx.cr[6].eq {
	pc = 0x83237B90; continue 'dispatch;
	}
	// 83237B8C: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x83237B90; continue 'dispatch;
            }
            0x83237B90 => {
    //   block [0x83237B90..0x83237B98)
	// 83237B90: 929F0008  stw r20, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[20].u32 ) };
	// 83237B94: 929F000C  stw r20, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[20].u32 ) };
	pc = 0x83237B98; continue 'dispatch;
            }
            0x83237B98 => {
    //   block [0x83237B98..0x83237BD4)
	// 83237B98: 7F9BE214  add r28, r27, r28
	ctx.r[28].u64 = ctx.r[27].u64 + ctx.r[28].u64;
	// 83237B9C: 393D000F  addi r9, r29, 0xf
	ctx.r[9].s64 = ctx.r[29].s64 + 15;
	// 83237BA0: 939D000C  stw r28, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 83237BA4: 3AD6FFF0  addi r22, r22, -0x10
	ctx.r[22].s64 = ctx.r[22].s64 + -16;
	// 83237BA8: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 83237BAC: 3AFD000C  addi r23, r29, 0xc
	ctx.r[23].s64 = ctx.r[29].s64 + 12;
	// 83237BB0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 83237BB4: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	// 83237BB8: 38EBFFFF  addi r7, r11, -1
	ctx.r[7].s64 = ctx.r[11].s64 + -1;
	// 83237BBC: 7D264078  andc r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 & !ctx.r[8].u64;
	// 83237BC0: 7ECB3878  andc r11, r22, r7
	ctx.r[11].u64 = ctx.r[22].u64 & !ctx.r[7].u64;
	// 83237BC4: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 83237BC8: 7F065840  cmplw cr6, r6, r11
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83237BCC: 40980008  bge cr6, 0x83237bd4
	if !ctx.cr[6].lt {
	pc = 0x83237BD4; continue 'dispatch;
	}
	// 83237BD0: 7D765B78  mr r22, r11
	ctx.r[22].u64 = ctx.r[11].u64;
	pc = 0x83237BD4; continue 'dispatch;
            }
            0x83237BD4 => {
    //   block [0x83237BD4..0x83237C28)
	// 83237BD4: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 83237BD8: 419A0144  beq cr6, 0x83237d1c
	if ctx.cr[6].eq {
	pc = 0x83237D1C; continue 'dispatch;
	}
	// 83237BDC: 83F80004  lwz r31, 4(r24)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 83237BE0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 83237BE4: 419A0138  beq cr6, 0x83237d1c
	if ctx.cr[6].eq {
	pc = 0x83237D1C; continue 'dispatch;
	}
	// 83237BE8: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 83237BEC: 419A0064  beq cr6, 0x83237c50
	if ctx.cr[6].eq {
	pc = 0x83237C50; continue 'dispatch;
	}
	// 83237BF0: 2F1FFFFF  cmpwi cr6, r31, -1
	ctx.cr[6].compare_i32(ctx.r[31].s32, -1, &mut ctx.xer);
	// 83237BF4: 419A00CC  beq cr6, 0x83237cc0
	if ctx.cr[6].eq {
	pc = 0x83237CC0; continue 'dispatch;
	}
	// 83237BF8: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 83237BFC: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83237C00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 83237C04: 4B7CA0A5  bl 0x82a01ca8
	ctx.lr = 0x83237C08;
	sub_82A01CA8(ctx, base);
	// 83237C08: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83237C0C: 81190004  lwz r8, 4(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 83237C10: 5469103A  slwi r9, r3, 2
	ctx.r[9].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 83237C14: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 83237C18: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83237C1C: 419A000C  beq cr6, 0x83237c28
	if ctx.cr[6].eq {
	pc = 0x83237C28; continue 'dispatch;
	}
	// 83237C20: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 83237C24: 48000008  b 0x83237c2c
	pc = 0x83237C2C; continue 'dispatch;
            }
            0x83237C28 => {
    //   block [0x83237C28..0x83237C2C)
	// 83237C28: 7D69412E  stwx r11, r9, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), ctx.r[11].u32) };
	pc = 0x83237C2C; continue 'dispatch;
            }
            0x83237C2C => {
    //   block [0x83237C2C..0x83237C38)
	// 83237C2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83237C30: 419A0008  beq cr6, 0x83237c38
	if ctx.cr[6].eq {
	pc = 0x83237C38; continue 'dispatch;
	}
	// 83237C34: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x83237C38; continue 'dispatch;
            }
            0x83237C38 => {
    //   block [0x83237C38..0x83237C50)
	// 83237C38: 929F0008  stw r20, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[20].u32 ) };
	// 83237C3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 83237C40: 929F000C  stw r20, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[20].u32 ) };
	// 83237C44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 83237C48: 4BFFF7F1  bl 0x83237438
	ctx.lr = 0x83237C4C;
	sub_83237438(ctx, base);
	// 83237C4C: 48000074  b 0x83237cc0
	pc = 0x83237CC0; continue 'dispatch;
            }
            0x83237C50 => {
    //   block [0x83237C50..0x83237C70)
	// 83237C50: 2F1FFFFF  cmpwi cr6, r31, -1
	ctx.cr[6].compare_i32(ctx.r[31].s32, -1, &mut ctx.xer);
	// 83237C54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 83237C58: 409A0018  bne cr6, 0x83237c70
	if !ctx.cr[6].eq {
	pc = 0x83237C70; continue 'dispatch;
	}
	// 83237C5C: 4BFFF835  bl 0x83237490
	ctx.lr = 0x83237C60;
	sub_83237490(ctx, base);
	// 83237C60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83237C64: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 83237C68: 419A0120  beq cr6, 0x83237d88
	if ctx.cr[6].eq {
	pc = 0x83237D88; continue 'dispatch;
	}
	// 83237C6C: 48000048  b 0x83237cb4
	pc = 0x83237CB4; continue 'dispatch;
            }
            0x83237C70 => {
    //   block [0x83237C70..0x83237C9C)
	// 83237C70: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 83237C74: 8098000C  lwz r4, 0xc(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) } as u64;
	// 83237C78: 4B7CA031  bl 0x82a01ca8
	ctx.lr = 0x83237C7C;
	sub_82A01CA8(ctx, base);
	// 83237C7C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83237C80: 81190004  lwz r8, 4(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 83237C84: 5469103A  slwi r9, r3, 2
	ctx.r[9].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 83237C88: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 83237C8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83237C90: 419A000C  beq cr6, 0x83237c9c
	if ctx.cr[6].eq {
	pc = 0x83237C9C; continue 'dispatch;
	}
	// 83237C94: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 83237C98: 48000008  b 0x83237ca0
	pc = 0x83237CA0; continue 'dispatch;
            }
            0x83237C9C => {
    //   block [0x83237C9C..0x83237CA0)
	// 83237C9C: 7D49412E  stwx r10, r9, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), ctx.r[10].u32) };
	pc = 0x83237CA0; continue 'dispatch;
            }
            0x83237CA0 => {
    //   block [0x83237CA0..0x83237CAC)
	// 83237CA0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83237CA4: 419A0008  beq cr6, 0x83237cac
	if ctx.cr[6].eq {
	pc = 0x83237CAC; continue 'dispatch;
	}
	// 83237CA8: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x83237CAC; continue 'dispatch;
            }
            0x83237CAC => {
    //   block [0x83237CAC..0x83237CB4)
	// 83237CAC: 929F0008  stw r20, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[20].u32 ) };
	// 83237CB0: 929F000C  stw r20, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[20].u32 ) };
	pc = 0x83237CB4; continue 'dispatch;
            }
            0x83237CB4 => {
    //   block [0x83237CB4..0x83237CC0)
	// 83237CB4: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 83237CB8: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 83237CBC: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	pc = 0x83237CC0; continue 'dispatch;
            }
            0x83237CC0 => {
    //   block [0x83237CC0..0x83237CEC)
	// 83237CC0: 8178000C  lwz r11, 0xc(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) } as u64;
	// 83237CC4: 7F8BE214  add r28, r11, r28
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 83237CC8: 939A0000  stw r28, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 83237CCC: 7F1CEA14  add r24, r28, r29
	ctx.r[24].u64 = ctx.r[28].u64 + ctx.r[29].u64;
	// 83237CD0: 93970000  stw r28, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 83237CD4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 83237CD8: 81590000  lwz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 83237CDC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 83237CE0: 7F185840  cmplw cr6, r24, r11
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83237CE4: 41980008  blt cr6, 0x83237cec
	if ctx.cr[6].lt {
	pc = 0x83237CEC; continue 'dispatch;
	}
	// 83237CE8: 7E98A378  mr r24, r20
	ctx.r[24].u64 = ctx.r[20].u64;
	pc = 0x83237CEC; continue 'dispatch;
            }
            0x83237CEC => {
    //   block [0x83237CEC..0x83237D0C)
	// 83237CEC: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 83237CF0: 3AB50010  addi r21, r21, 0x10
	ctx.r[21].s64 = ctx.r[21].s64 + 16;
	// 83237CF4: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 83237CF8: 3949FFFF  addi r10, r9, -1
	ctx.r[10].s64 = ctx.r[9].s64 + -1;
	// 83237CFC: 7D4A50F8  nor r10, r10, r10
	ctx.r[10].u64 = !(ctx.r[10].u64 | ctx.r[10].u64);
	// 83237D00: 7D48A838  and r8, r10, r21
	ctx.r[8].u64 = ctx.r[10].u64 & ctx.r[21].u64;
	// 83237D04: 419A0008  beq cr6, 0x83237d0c
	if ctx.cr[6].eq {
	pc = 0x83237D0C; continue 'dispatch;
	}
	// 83237D08: 7D4BC038  and r11, r10, r24
	ctx.r[11].u64 = ctx.r[10].u64 & ctx.r[24].u64;
	pc = 0x83237D0C; continue 'dispatch;
            }
            0x83237D0C => {
    //   block [0x83237D0C..0x83237D1C)
	// 83237D0C: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83237D10: 4098000C  bge cr6, 0x83237d1c
	if !ctx.cr[6].lt {
	pc = 0x83237D1C; continue 'dispatch;
	}
	// 83237D14: 7D694214  add r11, r9, r8
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 83237D18: 3AABFFFF  addi r21, r11, -1
	ctx.r[21].s64 = ctx.r[11].s64 + -1;
	pc = 0x83237D1C; continue 'dispatch;
            }
            0x83237D1C => {
    //   block [0x83237D1C..0x83237D44)
	// 83237D1C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 83237D20: 409A0024  bne cr6, 0x83237d44
	if !ctx.cr[6].eq {
	pc = 0x83237D44; continue 'dispatch;
	}
	// 83237D24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 83237D28: 4BFFF769  bl 0x83237490
	ctx.lr = 0x83237D2C;
	sub_83237490(ctx, base);
	// 83237D2C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 83237D30: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 83237D34: 419A0054  beq cr6, 0x83237d88
	if ctx.cr[6].eq {
	pc = 0x83237D88; continue 'dispatch;
	}
	// 83237D38: 939A0000  stw r28, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 83237D3C: 93BA0004  stw r29, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 83237D40: 935D0004  stw r26, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	pc = 0x83237D44; continue 'dispatch;
            }
            0x83237D44 => {
    //   block [0x83237D44..0x83237D88)
	// 83237D44: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 83237D48: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 83237D4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 83237D50: 4B7C9F59  bl 0x82a01ca8
	ctx.lr = 0x83237D54;
	sub_82A01CA8(ctx, base);
	// 83237D54: 81590004  lwz r10, 4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 83237D58: 546B103A  slwi r11, r3, 2
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 83237D5C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 83237D60: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 83237D64: 4B7C9ED5  bl 0x82a01c38
	ctx.lr = 0x83237D68;
	sub_82A01C38(ctx, base);
	// 83237D68: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 83237D6C: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 83237D70: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 83237D74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 83237D78: 4BFFF789  bl 0x83237500
	ctx.lr = 0x83237D7C;
	sub_83237500(ctx, base);
	// 83237D7C: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 83237D80: 419A0008  beq cr6, 0x83237d88
	if ctx.cr[6].eq {
	pc = 0x83237D88; continue 'dispatch;
	}
	// 83237D84: 93980008  stw r28, 8(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	pc = 0x83237D88; continue 'dispatch;
            }
            0x83237D88 => {
    //   block [0x83237D88..0x83237D90)
	// 83237D88: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 83237D8C: 4BA716AC  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83237D90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83237D90 size=120
    let mut pc: u32 = 0x83237D90;
    'dispatch: loop {
        match pc {
            0x83237D90 => {
    //   block [0x83237D90..0x83237DB0)
	// 83237D90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83237D94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83237D98: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83237D9C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 83237DA0: 419A0054  beq cr6, 0x83237df4
	if ctx.cr[6].eq {
	pc = 0x83237DF4; continue 'dispatch;
	}
	// 83237DA4: 80A30018  lwz r5, 0x18(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 83237DA8: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 83237DAC: 419A002C  beq cr6, 0x83237dd8
	if ctx.cr[6].eq {
	pc = 0x83237DD8; continue 'dispatch;
	}
	pc = 0x83237DB0; continue 'dispatch;
            }
            0x83237DB0 => {
    //   block [0x83237DB0..0x83237DCC)
	// 83237DB0: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 83237DB4: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83237DB8: 41980014  blt cr6, 0x83237dcc
	if ctx.cr[6].lt {
	pc = 0x83237DCC; continue 'dispatch;
	}
	// 83237DBC: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 83237DC0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 83237DC4: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83237DC8: 41980024  blt cr6, 0x83237dec
	if ctx.cr[6].lt {
	pc = 0x83237DEC; continue 'dispatch;
	}
	pc = 0x83237DCC; continue 'dispatch;
            }
            0x83237DCC => {
    //   block [0x83237DCC..0x83237DD8)
	// 83237DCC: 80A50008  lwz r5, 8(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 83237DD0: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 83237DD4: 409AFFDC  bne cr6, 0x83237db0
	if !ctx.cr[6].eq {
	pc = 0x83237DB0; continue 'dispatch;
	}
	pc = 0x83237DD8; continue 'dispatch;
            }
            0x83237DD8 => {
    //   block [0x83237DD8..0x83237DEC)
	// 83237DD8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 83237DDC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 83237DE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 83237DE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83237DE8: 4E800020  blr
	return;
            }
            0x83237DEC => {
    //   block [0x83237DEC..0x83237DF4)
	// 83237DEC: 3884FFF0  addi r4, r4, -0x10
	ctx.r[4].s64 = ctx.r[4].s64 + -16;
	// 83237DF0: 4BFFFCC9  bl 0x83237ab8
	ctx.lr = 0x83237DF4;
	sub_83237AB8(ctx, base);
	pc = 0x83237DF4; continue 'dispatch;
            }
            0x83237DF4 => {
    //   block [0x83237DF4..0x83237E08)
	// 83237DF4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 83237DF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 83237DFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 83237E00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83237E04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83237E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83237E08 size=348
    let mut pc: u32 = 0x83237E08;
    'dispatch: loop {
        match pc {
            0x83237E08 => {
    //   block [0x83237E08..0x83237E28)
	// 83237E08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83237E0C: 4BA715F5  bl 0x82ca9400
	ctx.lr = 0x83237E10;
	sub_82CA93D0(ctx, base);
	// 83237E10: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83237E14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83237E18: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 83237E1C: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83237E20: 40980008  bge cr6, 0x83237e28
	if !ctx.cr[6].lt {
	pc = 0x83237E28; continue 'dispatch;
	}
	// 83237E24: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	pc = 0x83237E28; continue 'dispatch;
            }
            0x83237E28 => {
    //   block [0x83237E28..0x83237E38)
	// 83237E28: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 83237E2C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 83237E30: 409A0008  bne cr6, 0x83237e38
	if !ctx.cr[6].eq {
	pc = 0x83237E38; continue 'dispatch;
	}
	// 83237E34: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	pc = 0x83237E38; continue 'dispatch;
            }
            0x83237E38 => {
    //   block [0x83237E38..0x83237E44)
	// 83237E38: 3964001F  addi r11, r4, 0x1f
	ctx.r[11].s64 = ctx.r[4].s64 + 31;
	// 83237E3C: 839F0018  lwz r28, 0x18(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 83237E40: 557B0036  rlwinm r27, r11, 0, 0, 0x1b
	ctx.r[27].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	pc = 0x83237E44; continue 'dispatch;
            }
            0x83237E44 => {
    //   block [0x83237E44..0x83237E74)
	// 83237E44: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 83237E48: 409A0054  bne cr6, 0x83237e9c
	if !ctx.cr[6].eq {
	pc = 0x83237E9C; continue 'dispatch;
	}
	// 83237E4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83237E50: 4BFFF7C9  bl 0x83237618
	ctx.lr = 0x83237E54;
	sub_83237618(ctx, base);
	// 83237E54: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 83237E58: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 83237E5C: 419A00FC  beq cr6, 0x83237f58
	if ctx.cr[6].eq {
	pc = 0x83237F58; continue 'dispatch;
	}
	// 83237E60: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 83237E64: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83237E68: 409A000C  bne cr6, 0x83237e74
	if !ctx.cr[6].eq {
	pc = 0x83237E74; continue 'dispatch;
	}
	// 83237E6C: 939F0018  stw r28, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[28].u32 ) };
	// 83237E70: 4800002C  b 0x83237e9c
	pc = 0x83237E9C; continue 'dispatch;
            }
            0x83237E74 => {
    //   block [0x83237E74..0x83237E84)
	// 83237E74: 396A0008  addi r11, r10, 8
	ctx.r[11].s64 = ctx.r[10].s64 + 8;
	// 83237E78: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83237E7C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83237E80: 419A0018  beq cr6, 0x83237e98
	if ctx.cr[6].eq {
	pc = 0x83237E98; continue 'dispatch;
	}
	pc = 0x83237E84; continue 'dispatch;
            }
            0x83237E84 => {
    //   block [0x83237E84..0x83237E98)
	// 83237E84: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83237E88: 396A0008  addi r11, r10, 8
	ctx.r[11].s64 = ctx.r[10].s64 + 8;
	// 83237E8C: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 83237E90: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83237E94: 409AFFF0  bne cr6, 0x83237e84
	if !ctx.cr[6].eq {
	pc = 0x83237E84; continue 'dispatch;
	}
	pc = 0x83237E98; continue 'dispatch;
            }
            0x83237E98 => {
    //   block [0x83237E98..0x83237E9C)
	// 83237E98: 938A0008  stw r28, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	pc = 0x83237E9C; continue 'dispatch;
            }
            0x83237E9C => {
    //   block [0x83237E9C..0x83237EB4)
	// 83237E9C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 83237EA0: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 83237EA4: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 83237EA8: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83237EAC: 41980008  blt cr6, 0x83237eb4
	if ctx.cr[6].lt {
	pc = 0x83237EB4; continue 'dispatch;
	}
	// 83237EB0: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	pc = 0x83237EB4; continue 'dispatch;
            }
            0x83237EB4 => {
    //   block [0x83237EB4..0x83237F18)
	// 83237EB4: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 83237EB8: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 83237EBC: 811F001C  lwz r8, 0x1c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 83237EC0: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 83237EC4: 7CCB5050  subf r6, r11, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 83237EC8: 7D493850  subf r10, r9, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[9].s64;
	// 83237ECC: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83237ED0: 7CE54430  srw r5, r7, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[5].u64 = 0;
	} else {
		ctx.r[5].u64 = ((ctx.r[7].u32) >> ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 83237ED4: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 83237ED8: 7C8529D6  mullw r4, r5, r5
	ctx.r[4].s32 = ((ctx.r[5].s32 as i64 * ctx.r[5].s32 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 83237EDC: 7D434430  srw r3, r10, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[3].u64 = 0;
	} else {
		ctx.r[3].u64 = ((ctx.r[10].u32) >> ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 83237EE0: 7CA319D6  mullw r5, r3, r3
	ctx.r[5].s32 = ((ctx.r[3].s32 as i64 * ctx.r[3].s32 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 83237EE4: 7CA34430  srw r3, r5, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[3].u64 = 0;
	} else {
		ctx.r[3].u64 = ((ctx.r[5].u32) >> ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 83237EE8: 7D4351D6  mullw r10, r3, r10
	ctx.r[10].s32 = ((ctx.r[3].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 83237EEC: 7C884430  srw r8, r4, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = ((ctx.r[4].u32) >> ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 83237EF0: 7CAA4396  divwu r5, r10, r8
	ctx.r[5].u32 = ctx.r[10].u32 / ctx.r[8].u32;
	// 83237EF4: 3889FFFF  addi r4, r9, -1
	ctx.r[4].s64 = ctx.r[9].s64 + -1;
	// 83237EF8: 7C653850  subf r3, r5, r7
	ctx.r[3].s64 = ctx.r[7].s64 - ctx.r[5].s64;
	// 83237EFC: 0CC80000  twi 6, r8, 0
	// 83237F00: 7D4B1850  subf r10, r11, r3
	ctx.r[10].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 83237F04: 0CC60000  twi 6, r6, 0
	// 83237F08: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 83237F0C: 7D4B21D6  mullw r10, r11, r4
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 83237F10: 7FAA3396  divwu r29, r10, r6
	ctx.r[29].u32 = ctx.r[10].u32 / ctx.r[6].u32;
	// 83237F14: 57BE103A  slwi r30, r29, 2
	ctx.r[30].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	pc = 0x83237F18; continue 'dispatch;
            }
            0x83237F18 => {
    //   block [0x83237F18..0x83237F58)
	// 83237F18: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 83237F1C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 83237F20: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 83237F24: 7CBE5A14  add r5, r30, r11
	ctx.r[5].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 83237F28: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 83237F2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83237F30: 4BFFF9A1  bl 0x832378d0
	ctx.lr = 0x83237F34;
	sub_832378D0(ctx, base);
	// 83237F34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 83237F38: 409A0024  bne cr6, 0x83237f5c
	if !ctx.cr[6].eq {
	pc = 0x83237F5C; continue 'dispatch;
	}
	// 83237F3C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83237F40: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 83237F44: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 83237F48: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83237F4C: 4198FFCC  blt cr6, 0x83237f18
	if ctx.cr[6].lt {
	pc = 0x83237F18; continue 'dispatch;
	}
	// 83237F50: 839C0008  lwz r28, 8(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 83237F54: 4BFFFEF0  b 0x83237e44
	pc = 0x83237E44; continue 'dispatch;
            }
            0x83237F58 => {
    //   block [0x83237F58..0x83237F5C)
	// 83237F58: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x83237F5C; continue 'dispatch;
            }
            0x83237F5C => {
    //   block [0x83237F5C..0x83237F64)
	// 83237F5C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 83237F60: 4BA714F0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83237F70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83237F70 size=208
    let mut pc: u32 = 0x83237F70;
    'dispatch: loop {
        match pc {
            0x83237F70 => {
    //   block [0x83237F70..0x83237FAC)
	// 83237F70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83237F74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83237F78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 83237F7C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83237F80: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 83237F84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83237F88: 894B6DA4  lbz r10, 0x6da4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28068 as u32) ) } as u64;
	// 83237F8C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83237F90: 409A001C  bne cr6, 0x83237fac
	if !ctx.cr[6].eq {
	pc = 0x83237FAC; continue 'dispatch;
	}
	// 83237F94: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 83237F98: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 83237F9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 83237FA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83237FA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 83237FA8: 4E800020  blr
	return;
            }
            0x83237FAC => {
    //   block [0x83237FAC..0x8323802C)
	// 83237FAC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 83237FB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 83237FB4: 806B6DA8  lwz r3, 0x6da8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28072 as u32) ) } as u64;
	// 83237FB8: 48004E31  bl 0x8323cde8
	ctx.lr = 0x83237FBC;
	sub_8323CDE8(ctx, base);
	// 83237FBC: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 83237FC0: 409A006C  bne cr6, 0x8323802c
	if !ctx.cr[6].eq {
	pc = 0x8323802C; continue 'dispatch;
	}
	// 83237FC4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 83237FC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 83237FCC: 806B6DAC  lwz r3, 0x6dac(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28076 as u32) ) } as u64;
	// 83237FD0: 48004E19  bl 0x8323cde8
	ctx.lr = 0x83237FD4;
	sub_8323CDE8(ctx, base);
	// 83237FD4: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 83237FD8: 409A0054  bne cr6, 0x8323802c
	if !ctx.cr[6].eq {
	pc = 0x8323802C; continue 'dispatch;
	}
	// 83237FDC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 83237FE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 83237FE4: 806B6DB0  lwz r3, 0x6db0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28080 as u32) ) } as u64;
	// 83237FE8: 4B7C9951  bl 0x82a01938
	ctx.lr = 0x83237FEC;
	sub_82A01938(ctx, base);
	// 83237FEC: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 83237FF0: 409A003C  bne cr6, 0x8323802c
	if !ctx.cr[6].eq {
	pc = 0x8323802C; continue 'dispatch;
	}
	// 83237FF4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 83237FF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 83237FFC: 806B6DB4  lwz r3, 0x6db4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28084 as u32) ) } as u64;
	// 83238000: 4B7C9939  bl 0x82a01938
	ctx.lr = 0x83238004;
	sub_82A01938(ctx, base);
	// 83238004: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 83238008: 409A0024  bne cr6, 0x8323802c
	if !ctx.cr[6].eq {
	pc = 0x8323802C; continue 'dispatch;
	}
	// 8323800C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 83238010: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 83238014: 806B6DB8  lwz r3, 0x6db8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28088 as u32) ) } as u64;
	// 83238018: 4B7C9921  bl 0x82a01938
	ctx.lr = 0x8323801C;
	sub_82A01938(ctx, base);
	// 8323801C: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 83238020: 409A000C  bne cr6, 0x8323802c
	if !ctx.cr[6].eq {
	pc = 0x8323802C; continue 'dispatch;
	}
	// 83238024: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83238028: 4BFFF011  bl 0x83237038
	ctx.lr = 0x8323802C;
	sub_83237038(ctx, base);
	pc = 0x8323802C; continue 'dispatch;
            }
            0x8323802C => {
    //   block [0x8323802C..0x83238040)
	// 8323802C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 83238030: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 83238034: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83238038: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8323803C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83238040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83238040 size=72
    let mut pc: u32 = 0x83238040;
    'dispatch: loop {
        match pc {
            0x83238040 => {
    //   block [0x83238040..0x83238088)
	// 83238040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83238044: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83238048: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323804C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 83238050: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 83238054: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 83238058: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8323805C: 388AB404  addi r4, r10, -0x4bfc
	ctx.r[4].s64 = ctx.r[10].s64 + -19452;
	// 83238060: 38E40004  addi r7, r4, 4
	ctx.r[7].s64 = ctx.r[4].s64 + 4;
	// 83238064: 38C4FFF8  addi r6, r4, -8
	ctx.r[6].s64 = ctx.r[4].s64 + -8;
	// 83238068: 38A4FFF4  addi r5, r4, -0xc
	ctx.r[5].s64 = ctx.r[4].s64 + -12;
	// 8323806C: 4B7C99ED  bl 0x82a01a58
	ctx.lr = 0x83238070;
	sub_82A01A58(ctx, base);
	// 83238070: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 83238074: 90696DB8  stw r3, 0x6db8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28088 as u32), ctx.r[3].u32 ) };
	// 83238078: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8323807C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 83238080: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83238084: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83238088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83238088 size=72
    let mut pc: u32 = 0x83238088;
    'dispatch: loop {
        match pc {
            0x83238088 => {
    //   block [0x83238088..0x832380D0)
	// 83238088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323808C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83238090: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83238094: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 83238098: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8323809C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 832380A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 832380A4: 388AB3F4  addi r4, r10, -0x4c0c
	ctx.r[4].s64 = ctx.r[10].s64 + -19468;
	// 832380A8: 38E4FFE8  addi r7, r4, -0x18
	ctx.r[7].s64 = ctx.r[4].s64 + -24;
	// 832380AC: 38C4000C  addi r6, r4, 0xc
	ctx.r[6].s64 = ctx.r[4].s64 + 12;
	// 832380B0: 38A40004  addi r5, r4, 4
	ctx.r[5].s64 = ctx.r[4].s64 + 4;
	// 832380B4: 4B7C99A5  bl 0x82a01a58
	ctx.lr = 0x832380B8;
	sub_82A01A58(ctx, base);
	// 832380B8: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 832380BC: 90696DB4  stw r3, 0x6db4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28084 as u32), ctx.r[3].u32 ) };
	// 832380C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832380C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832380C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832380CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832380D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832380D0 size=72
    let mut pc: u32 = 0x832380D0;
    'dispatch: loop {
        match pc {
            0x832380D0 => {
    //   block [0x832380D0..0x83238118)
	// 832380D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832380D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832380D8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832380DC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 832380E0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 832380E4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 832380E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 832380EC: 388AB3F0  addi r4, r10, -0x4c10
	ctx.r[4].s64 = ctx.r[10].s64 + -19472;
	// 832380F0: 38E4FFE8  addi r7, r4, -0x18
	ctx.r[7].s64 = ctx.r[4].s64 + -24;
	// 832380F4: 38C4000C  addi r6, r4, 0xc
	ctx.r[6].s64 = ctx.r[4].s64 + 12;
	// 832380F8: 38A40008  addi r5, r4, 8
	ctx.r[5].s64 = ctx.r[4].s64 + 8;
	// 832380FC: 4B7C995D  bl 0x82a01a58
	ctx.lr = 0x83238100;
	sub_82A01A58(ctx, base);
	// 83238100: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 83238104: 90696DB0  stw r3, 0x6db0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28080 as u32), ctx.r[3].u32 ) };
	// 83238108: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8323810C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 83238110: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83238114: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83238118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83238118 size=220
    let mut pc: u32 = 0x83238118;
    'dispatch: loop {
        match pc {
            0x83238118 => {
    //   block [0x83238118..0x83238150)
	// 83238118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323811C: 4BA712E5  bl 0x82ca9400
	ctx.lr = 0x83238120;
	sub_82CA93D0(ctx, base);
	// 83238120: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83238124: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 83238128: 386BB3E8  addi r3, r11, -0x4c18
	ctx.r[3].s64 = ctx.r[11].s64 + -19480;
	// 8323812C: 38A3FFF0  addi r5, r3, -0x10
	ctx.r[5].s64 = ctx.r[3].s64 + -16;
	// 83238130: 38830004  addi r4, r3, 4
	ctx.r[4].s64 = ctx.r[3].s64 + 4;
	// 83238134: 4B7C9895  bl 0x82a019c8
	ctx.lr = 0x83238138;
	sub_82A019C8(ctx, base);
	// 83238138: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 8323813C: 3B400010  li r26, 0x10
	ctx.r[26].s64 = 16;
	// 83238140: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83238144: 3BA00044  li r29, 0x44
	ctx.r[29].s64 = 68;
	// 83238148: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 8323814C: 93FB6DAC  stw r31, 0x6dac(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(28076 as u32), ctx.r[31].u32 ) };
	pc = 0x83238150; continue 'dispatch;
            }
            0x83238150 => {
    //   block [0x83238150..0x832381B8)
	// 83238150: 397D000F  addi r11, r29, 0xf
	ctx.r[11].s64 = ctx.r[29].s64 + 15;
	// 83238154: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 83238158: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 8323815C: 556B0036  rlwinm r11, r11, 0, 0, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 83238160: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 83238164: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 83238168: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8323816C: 557E103A  slwi r30, r11, 2
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 83238170: 7C6AF02E  lwzx r3, r10, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 83238174: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 83238178: 419A0040  beq cr6, 0x832381b8
	if ctx.cr[6].eq {
	pc = 0x832381B8; continue 'dispatch;
	}
	// 8323817C: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 83238180: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 83238184: 419A0050  beq cr6, 0x832381d4
	if ctx.cr[6].eq {
	pc = 0x832381D4; continue 'dispatch;
	}
	// 83238188: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323818C: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 83238190: 392B000F  addi r9, r11, 0xf
	ctx.r[9].s64 = ctx.r[11].s64 + 15;
	// 83238194: 9343000C  stw r26, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 83238198: 55280036  rlwinm r8, r9, 0, 0, 0x1b
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 8323819C: 91030004  stw r8, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 832381A0: 0CC80000  twi 6, r8, 0
	// 832381A4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 832381A8: 38EBFFF0  addi r7, r11, -0x10
	ctx.r[7].s64 = ctx.r[11].s64 + -16;
	// 832381AC: 7CC74396  divwu r6, r7, r8
	ctx.r[6].u32 = ctx.r[7].u32 / ctx.r[8].u32;
	// 832381B0: 90C30008  stw r6, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 832381B4: 48000020  b 0x832381d4
	pc = 0x832381D4; continue 'dispatch;
            }
            0x832381B8 => {
    //   block [0x832381B8..0x832381D4)
	// 832381B8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 832381BC: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 832381C0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 832381C4: 4B7C997D  bl 0x82a01b40
	ctx.lr = 0x832381C8;
	sub_82A01B40(ctx, base);
	// 832381C8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 832381CC: 83FB6DAC  lwz r31, 0x6dac(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28076 as u32) ) } as u64;
	// 832381D0: 7C7E592E  stwx r3, r30, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32), ctx.r[3].u32) };
	pc = 0x832381D4; continue 'dispatch;
            }
            0x832381D4 => {
    //   block [0x832381D4..0x832381F4)
	// 832381D4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 832381D8: 57AA003A  rlwinm r10, r29, 0, 0, 0x1d
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 832381DC: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 832381E0: 2B1D0200  cmplwi cr6, r29, 0x200
	ctx.cr[6].compare_u32(ctx.r[29].u32, 512 as u32, &mut ctx.xer);
	// 832381E4: 7C6A592E  stwx r3, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[3].u32) };
	// 832381E8: 4099FF68  ble cr6, 0x83238150
	if !ctx.cr[6].gt {
	pc = 0x83238150; continue 'dispatch;
	}
	// 832381EC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 832381F0: 4BA71260  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832381F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832381F8 size=476
    let mut pc: u32 = 0x832381F8;
    'dispatch: loop {
        match pc {
            0x832381F8 => {
    //   block [0x832381F8..0x83238238)
	// 832381F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832381FC: 4BA71201  bl 0x82ca93fc
	ctx.lr = 0x83238200;
	sub_82CA93D0(ctx, base);
	// 83238200: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83238204: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 83238208: 386BB3E0  addi r3, r11, -0x4c20
	ctx.r[3].s64 = ctx.r[11].s64 + -19488;
	// 8323820C: 38A3FFF4  addi r5, r3, -0xc
	ctx.r[5].s64 = ctx.r[3].s64 + -12;
	// 83238210: 38830004  addi r4, r3, 4
	ctx.r[4].s64 = ctx.r[3].s64 + 4;
	// 83238214: 4B7C97B5  bl 0x82a019c8
	ctx.lr = 0x83238218;
	sub_82A019C8(ctx, base);
	// 83238218: 3F208349  lis r25, -0x7cb7
	ctx.r[25].s64 = -2092367872;
	// 8323821C: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 83238220: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 83238224: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 83238228: 90796DA8  stw r3, 0x6da8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(28072 as u32), ctx.r[3].u32 ) };
	// 8323822C: 48004C0D  bl 0x8323ce38
	ctx.lr = 0x83238230;
	sub_8323CE38(ctx, base);
	// 83238230: 3BE00004  li r31, 4
	ctx.r[31].s64 = 4;
	// 83238234: 83D96DA8  lwz r30, 0x6da8(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28072 as u32) ) } as u64;
	pc = 0x83238238; continue 'dispatch;
            }
            0x83238238 => {
    //   block [0x83238238..0x832382B8)
	// 83238238: 57FCF0BE  srwi r28, r31, 2
	ctx.r[28].u32 = ctx.r[31].u32.wrapping_shr(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 8323823C: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 83238240: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 83238244: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	// 83238248: 397CFFFF  addi r11, r28, -1
	ctx.r[11].s64 = ctx.r[28].s64 + -1;
	// 8323824C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 83238250: 557D103A  slwi r29, r11, 2
	ctx.r[29].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 83238254: 7C7D502E  lwzx r3, r29, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 83238258: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8323825C: 419A005C  beq cr6, 0x832382b8
	if ctx.cr[6].eq {
	pc = 0x832382B8; continue 'dispatch;
	}
	// 83238260: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 83238264: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 83238268: 419A006C  beq cr6, 0x832382d4
	if ctx.cr[6].eq {
	pc = 0x832382D4; continue 'dispatch;
	}
	// 8323826C: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 83238270: 395F000F  addi r10, r31, 0xf
	ctx.r[10].s64 = ctx.r[31].s64 + 15;
	// 83238274: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83238278: 0CDF0000  twi 6, r31, 0
	// 8323827C: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 83238280: 7D0AFB96  divwu r8, r10, r31
	ctx.r[8].u32 = ctx.r[10].u32 / ctx.r[31].u32;
	// 83238284: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 83238288: 7CC8F9D6  mullw r6, r8, r31
	ctx.r[6].s32 = ((ctx.r[8].s32 as i64 * ctx.r[31].s32 as i64) as i32);
	ctx.r[6].s64 = ctx.r[6].s32 as i64;
	// 8323828C: 38EBFFFF  addi r7, r11, -1
	ctx.r[7].s64 = ctx.r[11].s64 + -1;
	// 83238290: 0CDF0000  twi 6, r31, 0
	// 83238294: 7CA7FB96  divwu r5, r7, r31
	ctx.r[5].u32 = ctx.r[7].u32 / ctx.r[31].u32;
	// 83238298: 7C85F9D6  mullw r4, r5, r31
	ctx.r[4].s32 = ((ctx.r[5].s32 as i64 * ctx.r[31].s32 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 8323829C: 90830004  stw r4, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 832382A0: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 832382A4: 7D465850  subf r10, r6, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[6].s64;
	// 832382A8: 7D2A2396  divwu r9, r10, r4
	ctx.r[9].u32 = ctx.r[10].u32 / ctx.r[4].u32;
	// 832382AC: 0CC40000  twi 6, r4, 0
	// 832382B0: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 832382B4: 48000020  b 0x832382d4
	pc = 0x832382D4; continue 'dispatch;
            }
            0x832382B8 => {
    //   block [0x832382B8..0x832382D4)
	// 832382B8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 832382BC: 389E000C  addi r4, r30, 0xc
	ctx.r[4].s64 = ctx.r[30].s64 + 12;
	// 832382C0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 832382C4: 4B7C987D  bl 0x82a01b40
	ctx.lr = 0x832382C8;
	sub_82A01B40(ctx, base);
	// 832382C8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 832382CC: 83D96DA8  lwz r30, 0x6da8(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28072 as u32) ) } as u64;
	// 832382D0: 7C7D592E  stwx r3, r29, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32), ctx.r[3].u32) };
	pc = 0x832382D4; continue 'dispatch;
            }
            0x832382D4 => {
    //   block [0x832382D4..0x832382F8)
	// 832382D4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 832382D8: 578A103A  slwi r10, r28, 2
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 832382DC: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 832382E0: 2B1F0030  cmplwi cr6, r31, 0x30
	ctx.cr[6].compare_u32(ctx.r[31].u32, 48 as u32, &mut ctx.xer);
	// 832382E4: 7C6A592E  stwx r3, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[3].u32) };
	// 832382E8: 4099FF50  ble cr6, 0x83238238
	if !ctx.cr[6].gt {
	pc = 0x83238238; continue 'dispatch;
	}
	// 832382EC: 3B400010  li r26, 0x10
	ctx.r[26].s64 = 16;
	// 832382F0: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 832382F4: 48000008  b 0x832382fc
	pc = 0x832382FC; continue 'dispatch;
            }
            0x832382F8 => {
    //   block [0x832382F8..0x832382FC)
	// 832382F8: 83D96DA8  lwz r30, 0x6da8(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28072 as u32) ) } as u64;
	pc = 0x832382FC; continue 'dispatch;
            }
            0x832382FC => {
    //   block [0x832382FC..0x83238330)
	// 832382FC: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 83238300: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 83238304: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 83238308: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323830C: 48004B2D  bl 0x8323ce38
	ctx.lr = 0x83238310;
	sub_8323CE38(ctx, base);
	// 83238310: 3BBD0010  addi r29, r29, 0x10
	ctx.r[29].s64 = ctx.r[29].s64 + 16;
	// 83238314: 2B1D0030  cmplwi cr6, r29, 0x30
	ctx.cr[6].compare_u32(ctx.r[29].u32, 48 as u32, &mut ctx.xer);
	// 83238318: 4099FFE0  ble cr6, 0x832382f8
	if !ctx.cr[6].gt {
	pc = 0x832382F8; continue 'dispatch;
	}
	// 8323831C: 2B1F0040  cmplwi cr6, r31, 0x40
	ctx.cr[6].compare_u32(ctx.r[31].u32, 64 as u32, &mut ctx.xer);
	// 83238320: 419900AC  bgt cr6, 0x832383cc
	if ctx.cr[6].gt {
	pc = 0x832383CC; continue 'dispatch;
	}
	// 83238324: 83D96DA8  lwz r30, 0x6da8(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28072 as u32) ) } as u64;
	// 83238328: 3B9F000F  addi r28, r31, 0xf
	ctx.r[28].s64 = ctx.r[31].s64 + 15;
	// 8323832C: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	pc = 0x83238330; continue 'dispatch;
            }
            0x83238330 => {
    //   block [0x83238330..0x83238394)
	// 83238330: 578BF0BA  rlwinm r11, r28, 0x1e, 2, 0x1d
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000003u64;
	// 83238334: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 83238338: 57890036  rlwinm r9, r28, 0, 0, 0x1b
	ctx.r[9].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	// 8323833C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 83238340: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 83238344: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	// 83238348: 557D103A  slwi r29, r11, 2
	ctx.r[29].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 8323834C: 7C7D502E  lwzx r3, r29, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 83238350: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 83238354: 419A0040  beq cr6, 0x83238394
	if ctx.cr[6].eq {
	pc = 0x83238394; continue 'dispatch;
	}
	// 83238358: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323835C: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 83238360: 419A0050  beq cr6, 0x832383b0
	if ctx.cr[6].eq {
	pc = 0x832383B0; continue 'dispatch;
	}
	// 83238364: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83238368: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323836C: 392B000F  addi r9, r11, 0xf
	ctx.r[9].s64 = ctx.r[11].s64 + 15;
	// 83238370: 9343000C  stw r26, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 83238374: 55280036  rlwinm r8, r9, 0, 0, 0x1b
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 83238378: 91030004  stw r8, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 8323837C: 0CC80000  twi 6, r8, 0
	// 83238380: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 83238384: 38EBFFF0  addi r7, r11, -0x10
	ctx.r[7].s64 = ctx.r[11].s64 + -16;
	// 83238388: 7CC74396  divwu r6, r7, r8
	ctx.r[6].u32 = ctx.r[7].u32 / ctx.r[8].u32;
	// 8323838C: 90C30008  stw r6, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 83238390: 48000020  b 0x832383b0
	pc = 0x832383B0; continue 'dispatch;
            }
            0x83238394 => {
    //   block [0x83238394..0x832383B0)
	// 83238394: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 83238398: 389E000C  addi r4, r30, 0xc
	ctx.r[4].s64 = ctx.r[30].s64 + 12;
	// 8323839C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 832383A0: 4B7C97A1  bl 0x82a01b40
	ctx.lr = 0x832383A4;
	sub_82A01B40(ctx, base);
	// 832383A4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 832383A8: 83D96DA8  lwz r30, 0x6da8(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28072 as u32) ) } as u64;
	// 832383AC: 7C7D592E  stwx r3, r29, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32), ctx.r[3].u32) };
	pc = 0x832383B0; continue 'dispatch;
            }
            0x832383B0 => {
    //   block [0x832383B0..0x832383CC)
	// 832383B0: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 832383B4: 57EA003A  rlwinm r10, r31, 0, 0, 0x1d
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 832383B8: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 832383BC: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 832383C0: 2B1F0040  cmplwi cr6, r31, 0x40
	ctx.cr[6].compare_u32(ctx.r[31].u32, 64 as u32, &mut ctx.xer);
	// 832383C4: 7C6A592E  stwx r3, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[3].u32) };
	// 832383C8: 4099FF68  ble cr6, 0x83238330
	if !ctx.cr[6].gt {
	pc = 0x83238330; continue 'dispatch;
	}
	pc = 0x832383CC; continue 'dispatch;
            }
            0x832383CC => {
    //   block [0x832383CC..0x832383D4)
	// 832383CC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 832383D0: 4BA7107C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832383D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832383D8 size=136
    let mut pc: u32 = 0x832383D8;
    'dispatch: loop {
        match pc {
            0x832383D8 => {
    //   block [0x832383D8..0x83238410)
	// 832383D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832383DC: 4BA71031  bl 0x82ca940c
	ctx.lr = 0x832383E0;
	sub_82CA93D0(ctx, base);
	// 832383E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832383E4: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 832383E8: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 832383EC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 832383F0: 3BEB3558  addi r31, r11, 0x3558
	ctx.r[31].s64 = ctx.r[11].s64 + 13656;
	// 832383F4: 816A355C  lwz r11, 0x355c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(13660 as u32) ) } as u64;
	// 832383F8: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 832383FC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83238400: 409A0010  bne cr6, 0x83238410
	if !ctx.cr[6].eq {
	pc = 0x83238410; continue 'dispatch;
	}
	// 83238404: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 83238408: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 8323840C: 916A355C  stw r11, 0x355c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(13660 as u32), ctx.r[11].u32 ) };
	pc = 0x83238410; continue 'dispatch;
            }
            0x83238410 => {
    //   block [0x83238410..0x83238450)
	// 83238410: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83238414: 4B09E875  bl 0x822d6c88
	ctx.lr = 0x83238418;
	sub_822D6C88(ctx, base);
	// 83238418: 3FC08349  lis r30, -0x7cb7
	ctx.r[30].s64 = -2092367872;
	// 8323841C: 897E6DA4  lbz r11, 0x6da4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(28068 as u32) ) } as u64;
	// 83238420: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83238424: 409A002C  bne cr6, 0x83238450
	if !ctx.cr[6].eq {
	pc = 0x83238450; continue 'dispatch;
	}
	// 83238428: 480045A1  bl 0x8323c9c8
	ctx.lr = 0x8323842C;
	sub_8323C9C8(ctx, base);
	// 8323842C: 4BFFF345  bl 0x83237770
	ctx.lr = 0x83238430;
	sub_83237770(ctx, base);
	// 83238430: 4BFFEDF9  bl 0x83237228
	ctx.lr = 0x83238434;
	sub_83237228(ctx, base);
	// 83238434: 4BFFFDC5  bl 0x832381f8
	ctx.lr = 0x83238438;
	sub_832381F8(ctx, base);
	// 83238438: 4BFFFCE1  bl 0x83238118
	ctx.lr = 0x8323843C;
	sub_83238118(ctx, base);
	// 8323843C: 4BFFFC95  bl 0x832380d0
	ctx.lr = 0x83238440;
	sub_832380D0(ctx, base);
	// 83238440: 4BFFFC49  bl 0x83238088
	ctx.lr = 0x83238444;
	sub_83238088(ctx, base);
	// 83238444: 4BFFFBFD  bl 0x83238040
	ctx.lr = 0x83238448;
	sub_83238040(ctx, base);
	// 83238448: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8323844C: 997E6DA4  stb r11, 0x6da4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(28068 as u32), ctx.r[11].u8 ) };
	pc = 0x83238450; continue 'dispatch;
            }
            0x83238450 => {
    //   block [0x83238450..0x83238460)
	// 83238450: 7C2004AC  lwsync
	// 83238454: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 83238458: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8323845C: 4BA71000  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83238460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83238460 size=308
    let mut pc: u32 = 0x83238460;
    'dispatch: loop {
        match pc {
            0x83238460 => {
    //   block [0x83238460..0x8323848C)
	// 83238460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83238464: 4BA70FA9  bl 0x82ca940c
	ctx.lr = 0x83238468;
	sub_82CA93D0(ctx, base);
	// 83238468: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323846C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 83238470: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83238474: 894B6DA4  lbz r10, 0x6da4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28068 as u32) ) } as u64;
	// 83238478: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323847C: 409A0010  bne cr6, 0x8323848c
	if !ctx.cr[6].eq {
	pc = 0x8323848C; continue 'dispatch;
	}
	// 83238480: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 83238484: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 83238488: 4BA70FD4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x8323848C => {
    //   block [0x8323848C..0x83238494)
	// 8323848C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 83238490: 409A0010  bne cr6, 0x832384a0
	if !ctx.cr[6].eq {
	pc = 0x832384A0; continue 'dispatch;
	}
	pc = 0x83238494; continue 'dispatch;
            }
            0x83238494 => {
    //   block [0x83238494..0x832384A0)
	// 83238494: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 83238498: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8323849C: 4BA70FC0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x832384A0 => {
    //   block [0x832384A0..0x83238594)
	// 832384A0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 832384A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832384A8: 816B6DA8  lwz r11, 0x6da8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28072 as u32) ) } as u64;
	// 832384AC: 808B000C  lwz r4, 0xc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 832384B0: 4BFFE8B1  bl 0x83236d60
	ctx.lr = 0x832384B4;
	sub_83236D60(ctx, base);
	// 832384B4: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 832384B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832384BC: 409AFFD8  bne cr6, 0x83238494
	if !ctx.cr[6].eq {
	pc = 0x83238494; continue 'dispatch;
	}
	// 832384C0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 832384C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832384C8: 816B6DAC  lwz r11, 0x6dac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28076 as u32) ) } as u64;
	// 832384CC: 808B000C  lwz r4, 0xc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 832384D0: 4BFFE891  bl 0x83236d60
	ctx.lr = 0x832384D4;
	sub_83236D60(ctx, base);
	// 832384D4: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 832384D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832384DC: 409AFFB8  bne cr6, 0x83238494
	if !ctx.cr[6].eq {
	pc = 0x83238494; continue 'dispatch;
	}
	// 832384E0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 832384E4: 83CB6DB0  lwz r30, 0x6db0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28080 as u32) ) } as u64;
	// 832384E8: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 832384EC: 4B09E79D  bl 0x822d6c88
	ctx.lr = 0x832384F0;
	sub_822D6C88(ctx, base);
	// 832384F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 832384F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832384F8: 4BFFF899  bl 0x83237d90
	ctx.lr = 0x832384FC;
	sub_83237D90(ctx, base);
	// 832384FC: 7C2004AC  lwsync
	// 83238500: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 83238504: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 83238508: 93BE0028  stw r29, 0x28(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[29].u32 ) };
	// 8323850C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83238510: 409AFF84  bne cr6, 0x83238494
	if !ctx.cr[6].eq {
	pc = 0x83238494; continue 'dispatch;
	}
	// 83238514: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 83238518: 83CB6DB4  lwz r30, 0x6db4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28084 as u32) ) } as u64;
	// 8323851C: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 83238520: 4B09E769  bl 0x822d6c88
	ctx.lr = 0x83238524;
	sub_822D6C88(ctx, base);
	// 83238524: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 83238528: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323852C: 4BFFF865  bl 0x83237d90
	ctx.lr = 0x83238530;
	sub_83237D90(ctx, base);
	// 83238530: 7C2004AC  lwsync
	// 83238534: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 83238538: 93BE0028  stw r29, 0x28(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[29].u32 ) };
	// 8323853C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83238540: 409AFF54  bne cr6, 0x83238494
	if !ctx.cr[6].eq {
	pc = 0x83238494; continue 'dispatch;
	}
	// 83238544: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 83238548: 83CB6DB8  lwz r30, 0x6db8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28088 as u32) ) } as u64;
	// 8323854C: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 83238550: 4B09E739  bl 0x822d6c88
	ctx.lr = 0x83238554;
	sub_822D6C88(ctx, base);
	// 83238554: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 83238558: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323855C: 4BFFF835  bl 0x83237d90
	ctx.lr = 0x83238560;
	sub_83237D90(ctx, base);
	// 83238560: 7C2004AC  lwsync
	// 83238564: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 83238568: 93BE0028  stw r29, 0x28(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[29].u32 ) };
	// 8323856C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83238570: 409AFF24  bne cr6, 0x83238494
	if !ctx.cr[6].eq {
	pc = 0x83238494; continue 'dispatch;
	}
	// 83238574: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83238578: 4BFFEB49  bl 0x832370c0
	ctx.lr = 0x8323857C;
	sub_832370C0(ctx, base);
	// 8323857C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 83238580: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 83238584: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 83238588: 69230001  xori r3, r9, 1
	ctx.r[3].u64 = ctx.r[9].u64 ^ 1;
	// 8323858C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 83238590: 4BA70ECC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83238598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83238598 size=356
    let mut pc: u32 = 0x83238598;
    'dispatch: loop {
        match pc {
            0x83238598 => {
    //   block [0x83238598..0x832385BC)
	// 83238598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323859C: 4BA70E71  bl 0x82ca940c
	ctx.lr = 0x832385A0;
	sub_82CA93D0(ctx, base);
	// 832385A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832385A4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 832385A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832385AC: 894B6DA4  lbz r10, 0x6da4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28068 as u32) ) } as u64;
	// 832385B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832385B4: 409A0008  bne cr6, 0x832385bc
	if !ctx.cr[6].eq {
	pc = 0x832385BC; continue 'dispatch;
	}
	// 832385B8: 4BFFFE21  bl 0x832383d8
	ctx.lr = 0x832385BC;
	sub_832383D8(ctx, base);
	pc = 0x832385BC; continue 'dispatch;
            }
            0x832385BC => {
    //   block [0x832385BC..0x832385CC)
	// 832385BC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 832385C0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 832385C4: 396BB40C  addi r11, r11, -0x4bf4
	ctx.r[11].s64 = ctx.r[11].s64 + -19444;
	// 832385C8: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x832385CC; continue 'dispatch;
            }
            0x832385CC => {
    //   block [0x832385CC..0x83238610)
	// 832385CC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 832385D0: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 832385D4: 419A003C  beq cr6, 0x83238610
	if ctx.cr[6].eq {
	pc = 0x83238610; continue 'dispatch;
	}
	// 832385D8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 832385DC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 832385E0: 2B0A0018  cmplwi cr6, r10, 0x18
	ctx.cr[6].compare_u32(ctx.r[10].u32, 24 as u32, &mut ctx.xer);
	// 832385E4: 4198FFE8  blt cr6, 0x832385cc
	if ctx.cr[6].lt {
	pc = 0x832385CC; continue 'dispatch;
	}
	// 832385E8: 2B1F0040  cmplwi cr6, r31, 0x40
	ctx.cr[6].compare_u32(ctx.r[31].u32, 64 as u32, &mut ctx.xer);
	// 832385EC: 4199006C  bgt cr6, 0x83238658
	if ctx.cr[6].gt {
	pc = 0x83238658; continue 'dispatch;
	}
	// 832385F0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 832385F4: 816B6DA8  lwz r11, 0x6da8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28072 as u32) ) } as u64;
	// 832385F8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 832385FC: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 83238600: 4099003C  ble cr6, 0x8323863c
	if !ctx.cr[6].gt {
	pc = 0x8323863C; continue 'dispatch;
	}
	// 83238604: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 83238608: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8323860C: 4BA70E50  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x83238610 => {
    //   block [0x83238610..0x8323863C)
	// 83238610: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 83238614: 83CB6DB8  lwz r30, 0x6db8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28088 as u32) ) } as u64;
	// 83238618: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 8323861C: 4B09E66D  bl 0x822d6c88
	ctx.lr = 0x83238620;
	sub_822D6C88(ctx, base);
	// 83238620: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 83238624: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 83238628: 4BFFF7E1  bl 0x83237e08
	ctx.lr = 0x8323862C;
	sub_83237E08(ctx, base);
	// 8323862C: 7C2004AC  lwsync
	// 83238630: 93BE0028  stw r29, 0x28(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[29].u32 ) };
	// 83238634: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 83238638: 4BA70E24  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x8323863C => {
    //   block [0x8323863C..0x83238658)
	// 8323863C: 395F0003  addi r10, r31, 3
	ctx.r[10].s64 = ctx.r[31].s64 + 3;
	// 83238640: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 83238644: 5548003A  rlwinm r8, r10, 0, 0, 0x1d
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 83238648: 7C68482E  lwzx r3, r8, r9
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8323864C: 4BFFE8B5  bl 0x83236f00
	ctx.lr = 0x83238650;
	sub_83236F00(ctx, base);
	// 83238650: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 83238654: 4BA70E08  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x83238658 => {
    //   block [0x83238658..0x83238680)
	// 83238658: 2B1F0200  cmplwi cr6, r31, 0x200
	ctx.cr[6].compare_u32(ctx.r[31].u32, 512 as u32, &mut ctx.xer);
	// 8323865C: 41990024  bgt cr6, 0x83238680
	if ctx.cr[6].gt {
	pc = 0x83238680; continue 'dispatch;
	}
	// 83238660: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 83238664: 816B6DAC  lwz r11, 0x6dac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28076 as u32) ) } as u64;
	// 83238668: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323866C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 83238670: 4099FFCC  ble cr6, 0x8323863c
	if !ctx.cr[6].gt {
	pc = 0x8323863C; continue 'dispatch;
	}
	// 83238674: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 83238678: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8323867C: 4BA70DE0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x83238680 => {
    //   block [0x83238680..0x832386B4)
	// 83238680: 2B1F2800  cmplwi cr6, r31, 0x2800
	ctx.cr[6].compare_u32(ctx.r[31].u32, 10240 as u32, &mut ctx.xer);
	// 83238684: 41990030  bgt cr6, 0x832386b4
	if ctx.cr[6].gt {
	pc = 0x832386B4; continue 'dispatch;
	}
	// 83238688: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8323868C: 83CB6DB0  lwz r30, 0x6db0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28080 as u32) ) } as u64;
	// 83238690: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 83238694: 4B09E5F5  bl 0x822d6c88
	ctx.lr = 0x83238698;
	sub_822D6C88(ctx, base);
	// 83238698: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8323869C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832386A0: 4BFFF769  bl 0x83237e08
	ctx.lr = 0x832386A4;
	sub_83237E08(ctx, base);
	// 832386A4: 7C2004AC  lwsync
	// 832386A8: 93BE0028  stw r29, 0x28(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[29].u32 ) };
	// 832386AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832386B0: 4BA70DAC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x832386B4 => {
    //   block [0x832386B4..0x832386EC)
	// 832386B4: 3D6000A0  lis r11, 0xa0
	ctx.r[11].s64 = 10485760;
	// 832386B8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 832386BC: 41990030  bgt cr6, 0x832386ec
	if ctx.cr[6].gt {
	pc = 0x832386EC; continue 'dispatch;
	}
	// 832386C0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 832386C4: 83CB6DB4  lwz r30, 0x6db4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28084 as u32) ) } as u64;
	// 832386C8: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 832386CC: 4B09E5BD  bl 0x822d6c88
	ctx.lr = 0x832386D0;
	sub_822D6C88(ctx, base);
	// 832386D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 832386D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832386D8: 4BFFF731  bl 0x83237e08
	ctx.lr = 0x832386DC;
	sub_83237E08(ctx, base);
	// 832386DC: 7C2004AC  lwsync
	// 832386E0: 93BE0028  stw r29, 0x28(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[29].u32 ) };
	// 832386E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832386E8: 4BA70D74  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x832386EC => {
    //   block [0x832386EC..0x832386FC)
	// 832386EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832386F0: 4BFFEA89  bl 0x83237178
	ctx.lr = 0x832386F4;
	sub_83237178(ctx, base);
	// 832386F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832386F8: 4BA70D64  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83238700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x83238700 size=20
    let mut pc: u32 = 0x83238700;
    'dispatch: loop {
        match pc {
            0x83238700 => {
    //   block [0x83238700..0x83238714)
	// 83238700: 80630014  lwz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 83238704: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83238708: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323870C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83238710: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83238718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x83238718 size=56
    let mut pc: u32 = 0x83238718;
    'dispatch: loop {
        match pc {
            0x83238718 => {
    //   block [0x83238718..0x83238750)
	// 83238718: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323871C: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 83238720: 3D208336  lis r9, -0x7cca
	ctx.r[9].s64 = -2093613056;
	// 83238724: 7D6807B4  extsw r8, r11
	ctx.r[8].s64 = ctx.r[11].s32 as i64;
	// 83238728: 38E9F1BC  addi r7, r9, -0xe44
	ctx.r[7].s64 = ctx.r[9].s64 + -3652;
	// 8323872C: F901FFF0  std r8, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[8].u64 ) };
	// 83238730: C801FFF0  lfd f0, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 83238734: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 83238738: 816A6DD4  lwz r11, 0x6dd4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28116 as u32) ) } as u64;
	// 8323873C: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 83238740: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 83238744: 7D663C2E  lfsx f11, r6, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 83238748: EC2C5824  fdivs f1, f12, f11
	ctx.f[1].f64 = ((ctx.f[12].f64 / ctx.f[11].f64) as f32) as f64;
	// 8323874C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83238750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x83238750 size=172
    let mut pc: u32 = 0x83238750;
    'dispatch: loop {
        match pc {
            0x83238750 => {
    //   block [0x83238750..0x832387FC)
	// 83238750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83238754: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83238758: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8323875C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 83238760: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83238764: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 83238768: 3C8037E1  lis r4, 0x37e1
	ctx.r[4].s64 = 937492480;
	// 8323876C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83238770: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 83238774: 608485B9  ori r4, r4, 0x85b9
	ctx.r[4].u64 = ctx.r[4].u64 | 34233;
	// 83238778: 4B7E9E81  bl 0x82a225f8
	ctx.lr = 0x8323877C;
	sub_82A225F8(ctx, base);
	// 8323877C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 83238780: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 83238784: 4B7E9E75  bl 0x82a225f8
	ctx.lr = 0x83238788;
	sub_82A225F8(ctx, base);
	// 83238788: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323878C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 83238790: 7D0707B4  extsw r7, r8
	ctx.r[7].s64 = ctx.r[8].s32 as i64;
	// 83238794: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 83238798: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 8323879C: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 832387A0: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 832387A4: 396BF1BC  addi r11, r11, -0xe44
	ctx.r[11].s64 = ctx.r[11].s64 + -3652;
	// 832387A8: 392B0008  addi r9, r11, 8
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	// 832387AC: 816A6DD4  lwz r11, 0x6dd4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28116 as u32) ) } as u64;
	// 832387B0: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 832387B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832387B8: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 832387BC: 7D664C2E  lfsx f11, r6, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 832387C0: EC2B0332  fmuls f1, f11, f12
	ctx.f[1].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 832387C4: 4B7E9E9D  bl 0x82a22660
	ctx.lr = 0x832387C8;
	sub_82A22660(ctx, base);
	// 832387C8: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 832387CC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 832387D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 832387D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 832387D8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 832387DC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832387E0: 4E800421  bctrl
	ctx.lr = 0x832387E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832387E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832387E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832387EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832387F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832387F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832387F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83238800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x83238800 size=416
    let mut pc: u32 = 0x83238800;
    'dispatch: loop {
        match pc {
            0x83238800 => {
    //   block [0x83238800..0x83238834)
	// 83238800: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83238804: 4BA70C05  bl 0x82ca9408
	ctx.lr = 0x83238808;
	sub_82CA93D0(ctx, base);
	// 83238808: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323880C: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 83238810: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 83238814: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 83238818: 3BABFFDF  addi r29, r11, -0x21
	ctx.r[29].s64 = ctx.r[11].s64 + -33;
	// 8323881C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 83238820: 816AE9C8  lwz r11, -0x1638(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-5688 as u32) ) } as u64;
	// 83238824: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 83238828: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323882C: 419A0008  beq cr6, 0x83238834
	if ctx.cr[6].eq {
	pc = 0x83238834; continue 'dispatch;
	}
	// 83238830: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x83238834; continue 'dispatch;
            }
            0x83238834 => {
    //   block [0x83238834..0x8323886C)
	// 83238834: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83238838: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323883C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 83238840: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83238844: 4E800421  bctrl
	ctx.lr = 0x83238848;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83238848: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8323884C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83238850: 419A0148  beq cr6, 0x83238998
	if ctx.cr[6].eq {
	pc = 0x83238998; continue 'dispatch;
	}
	// 83238854: 3FC0834A  lis r30, -0x7cb6
	ctx.r[30].s64 = -2092302336;
	// 83238858: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8323885C: 817EE9D4  lwz r11, -0x162c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-5676 as u32) ) } as u64;
	// 83238860: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83238864: 419A0008  beq cr6, 0x8323886c
	if ctx.cr[6].eq {
	pc = 0x8323886C; continue 'dispatch;
	}
	// 83238868: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x8323886C => {
    //   block [0x8323886C..0x832388A8)
	// 8323886C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83238870: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83238874: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 83238878: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323887C: 4E800421  bctrl
	ctx.lr = 0x83238880;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83238880: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 83238884: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83238888: 419A0040  beq cr6, 0x832388c8
	if ctx.cr[6].eq {
	pc = 0x832388C8; continue 'dispatch;
	}
	// 8323888C: 817EE9D4  lwz r11, -0x162c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-5676 as u32) ) } as u64;
	// 83238890: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 83238894: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 83238898: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8323889C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832388A0: 419A0008  beq cr6, 0x832388a8
	if ctx.cr[6].eq {
	pc = 0x832388A8; continue 'dispatch;
	}
	// 832388A4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x832388A8 => {
    //   block [0x832388A8..0x832388C8)
	// 832388A8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 832388AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832388B0: 4B247F19  bl 0x824807c8
	ctx.lr = 0x832388B4;
	sub_824807C8(ctx, base);
	// 832388B4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832388B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832388BC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 832388C0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832388C4: 4E800421  bctrl
	ctx.lr = 0x832388C8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x832388C8 => {
    //   block [0x832388C8..0x8323891C)
	// 832388C8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 832388CC: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 832388D0: 3D008336  lis r8, -0x7cca
	ctx.r[8].s64 = -2093613056;
	// 832388D4: 7D6707B4  extsw r7, r11
	ctx.r[7].s64 = ctx.r[11].s32 as i64;
	// 832388D8: 3948F1BC  addi r10, r8, -0xe44
	ctx.r[10].s64 = ctx.r[8].s64 + -3652;
	// 832388DC: F8E10058  std r7, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u64 ) };
	// 832388E0: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 832388E4: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 832388E8: 81696DD4  lwz r11, 0x6dd4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28116 as u32) ) } as u64;
	// 832388EC: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 832388F0: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 832388F4: 3C80834A  lis r4, -0x7cb6
	ctx.r[4].s64 = -2092302336;
	// 832388F8: 38AA0008  addi r5, r10, 8
	ctx.r[5].s64 = ctx.r[10].s64 + 8;
	// 832388FC: 8164E9D0  lwz r11, -0x1630(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-5680 as u32) ) } as u64;
	// 83238900: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 83238904: 7D662C2E  lfsx f11, r6, r5
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[5].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 83238908: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323890C: ED4B0332  fmuls f10, f11, f12
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 83238910: D1410058  stfs f10, 0x58(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 83238914: 419A0008  beq cr6, 0x8323891c
	if ctx.cr[6].eq {
	pc = 0x8323891C; continue 'dispatch;
	}
	// 83238918: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8323891C; continue 'dispatch;
            }
            0x8323891C => {
    //   block [0x8323891C..0x83238968)
	// 8323891C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83238920: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83238924: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 83238928: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323892C: 4E800421  bctrl
	ctx.lr = 0x83238930;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83238930: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 83238934: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83238938: 419A0030  beq cr6, 0x83238968
	if ctx.cr[6].eq {
	pc = 0x83238968; continue 'dispatch;
	}
	// 8323893C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83238940: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 83238944: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83238948: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8323894C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83238950: 4E800421  bctrl
	ctx.lr = 0x83238954;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83238954: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83238958: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323895C: 8109000C  lwz r8, 0xc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 83238960: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 83238964: 4E800421  bctrl
	ctx.lr = 0x83238968;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x83238968 => {
    //   block [0x83238968..0x83238998)
	// 83238968: 807C0014  lwz r3, 0x14(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323896C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 83238970: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 83238974: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83238978: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323897C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83238980: 4E800421  bctrl
	ctx.lr = 0x83238984;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83238984: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83238988: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323898C: 8109000C  lwz r8, 0xc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 83238990: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 83238994: 4E800421  bctrl
	ctx.lr = 0x83238998;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x83238998 => {
    //   block [0x83238998..0x832389A0)
	// 83238998: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8323899C: 4BA70ABC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832389A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832389A0 size=128
    let mut pc: u32 = 0x832389A0;
    'dispatch: loop {
        match pc {
            0x832389A0 => {
    //   block [0x832389A0..0x83238A20)
	// 832389A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832389A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832389A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832389AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832389B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832389B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832389B8: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 832389BC: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 832389C0: 394B27E8  addi r10, r11, 0x27e8
	ctx.r[10].s64 = ctx.r[11].s64 + 10216;
	// 832389C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832389C8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 832389CC: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 832389D0: 80890004  lwz r4, 4(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 832389D4: 4B7E212D  bl 0x82a1ab00
	ctx.lr = 0x832389D8;
	sub_82A1AB00(ctx, base);
	// 832389D8: 80FF000C  lwz r7, 0xc(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 832389DC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 832389E0: 90E70004  stw r7, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 832389E4: 80DF000C  lwz r6, 0xc(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 832389E8: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 832389EC: 911F0010  stw r8, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 832389F0: 90C60000  stw r6, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 832389F4: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 832389F8: 90A50008  stw r5, 8(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 832389FC: 4AF7F11D  bl 0x821b7b18
	ctx.lr = 0x83238A00;
	sub_821B7B18(ctx, base);
	// 83238A00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 83238A04: 4B7DF35D  bl 0x82a17d60
	ctx.lr = 0x83238A08;
	sub_82A17D60(ctx, base);
	// 83238A08: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 83238A0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 83238A10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83238A14: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 83238A18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 83238A1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83238A20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x83238A20 size=88
    let mut pc: u32 = 0x83238A20;
    'dispatch: loop {
        match pc {
            0x83238A20 => {
    //   block [0x83238A20..0x83238A78)
	// 83238A20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83238A24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83238A28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 83238A2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 83238A30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83238A34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83238A38: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 83238A3C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 83238A40: 394B27E8  addi r10, r11, 0x27e8
	ctx.r[10].s64 = ctx.r[11].s64 + 10216;
	// 83238A44: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 83238A48: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 83238A4C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 83238A50: 4B2477E9  bl 0x82480238
	ctx.lr = 0x83238A54;
	sub_82480238(ctx, base);
	// 83238A54: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 83238A58: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 83238A5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83238A60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 83238A64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 83238A68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 83238A6C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 83238A70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 83238A74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83238A78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x83238A78 size=704
    let mut pc: u32 = 0x83238A78;
    'dispatch: loop {
        match pc {
            0x83238A78 => {
    //   block [0x83238A78..0x83238AFC)
	// 83238A78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83238A7C: 4BA70989  bl 0x82ca9404
	ctx.lr = 0x83238A80;
	sub_82CA93D0(ctx, base);
	// 83238A80: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83238A84: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 83238A88: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 83238A8C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 83238A90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83238A94: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83238A98: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 83238A9C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83238AA0: 4E800421  bctrl
	ctx.lr = 0x83238AA4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83238AA4: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 83238AA8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 83238AAC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 83238AB0: 4198004C  blt cr6, 0x83238afc
	if ctx.cr[6].lt {
	pc = 0x83238AFC; continue 'dispatch;
	}
	// 83238AB4: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 83238AB8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 83238ABC: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 83238AC0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83238AC4: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 83238AC8: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 83238ACC: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83238AD0: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 83238AD4: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 83238AD8: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 83238ADC: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 83238AE0: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 83238AE4: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 83238AE8: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 83238AEC: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 83238AF0: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 83238AF4: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 83238AF8: 48000014  b 0x83238b0c
	pc = 0x83238B0C; continue 'dispatch;
            }
            0x83238AFC => {
    //   block [0x83238AFC..0x83238B0C)
	// 83238AFC: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 83238B00: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 83238B04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83238B08: 4B7E83E1  bl 0x82a20ee8
	ctx.lr = 0x83238B0C;
	sub_82A20EE8(ctx, base);
	pc = 0x83238B0C; continue 'dispatch;
            }
            0x83238B0C => {
    //   block [0x83238B0C..0x83238B40)
	// 83238B0C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 83238B10: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 83238B14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83238B18: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 83238B1C: 419A0024  beq cr6, 0x83238b40
	if ctx.cr[6].eq {
	pc = 0x83238B40; continue 'dispatch;
	}
	// 83238B20: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 83238B24: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 83238B28: 8921005B  lbz r9, 0x5b(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(91 as u32) ) } as u64;
	// 83238B2C: 89010058  lbz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 83238B30: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 83238B34: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 83238B38: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 83238B3C: 99010053  stb r8, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[8].u8 ) };
	pc = 0x83238B40; continue 'dispatch;
            }
            0x83238B40 => {
    //   block [0x83238B40..0x83238BA8)
	// 83238B40: 3D6037E1  lis r11, 0x37e1
	ctx.r[11].s64 = 937492480;
	// 83238B44: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 83238B48: 616985B9  ori r9, r11, 0x85b9
	ctx.r[9].u64 = ctx.r[11].u64 | 34233;
	// 83238B4C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 83238B50: 409A006C  bne cr6, 0x83238bbc
	if !ctx.cr[6].eq {
	pc = 0x83238BBC; continue 'dispatch;
	}
	// 83238B54: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 83238B58: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 83238B5C: 4198004C  blt cr6, 0x83238ba8
	if ctx.cr[6].lt {
	pc = 0x83238BA8; continue 'dispatch;
	}
	// 83238B60: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 83238B64: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 83238B68: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 83238B6C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83238B70: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 83238B74: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 83238B78: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83238B7C: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 83238B80: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 83238B84: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 83238B88: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 83238B8C: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 83238B90: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 83238B94: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 83238B98: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 83238B9C: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 83238BA0: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 83238BA4: 48000030  b 0x83238bd4
	pc = 0x83238BD4; continue 'dispatch;
            }
            0x83238BA8 => {
    //   block [0x83238BA8..0x83238BBC)
	// 83238BA8: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 83238BAC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 83238BB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83238BB4: 4B7E8335  bl 0x82a20ee8
	ctx.lr = 0x83238BB8;
	sub_82A20EE8(ctx, base);
	// 83238BB8: 4800001C  b 0x83238bd4
	pc = 0x83238BD4; continue 'dispatch;
            }
            0x83238BBC => {
    //   block [0x83238BBC..0x83238BD4)
	// 83238BBC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83238BC0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 83238BC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83238BC8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 83238BCC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83238BD0: 4E800421  bctrl
	ctx.lr = 0x83238BD4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x83238BD4 => {
    //   block [0x83238BD4..0x83238C28)
	// 83238BD4: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 83238BD8: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 83238BDC: 4198004C  blt cr6, 0x83238c28
	if ctx.cr[6].lt {
	pc = 0x83238C28; continue 'dispatch;
	}
	// 83238BE0: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 83238BE4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 83238BE8: 3901005C  addi r8, r1, 0x5c
	ctx.r[8].s64 = ctx.r[1].s64 + 92;
	// 83238BEC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 83238BF0: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 83238BF4: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 83238BF8: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83238BFC: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 83238C00: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 83238C04: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 83238C08: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 83238C0C: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 83238C10: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 83238C14: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 83238C18: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 83238C1C: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 83238C20: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 83238C24: 48000014  b 0x83238c38
	pc = 0x83238C38; continue 'dispatch;
            }
            0x83238C28 => {
    //   block [0x83238C28..0x83238C38)
	// 83238C28: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 83238C2C: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 83238C30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83238C34: 4B7E82B5  bl 0x82a20ee8
	ctx.lr = 0x83238C38;
	sub_82A20EE8(ctx, base);
	pc = 0x83238C38; continue 'dispatch;
            }
            0x83238C38 => {
    //   block [0x83238C38..0x83238C70)
	// 83238C38: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 83238C3C: C001005C  lfs f0, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 83238C40: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 83238C44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83238C48: 419A0028  beq cr6, 0x83238c70
	if ctx.cr[6].eq {
	pc = 0x83238C70; continue 'dispatch;
	}
	// 83238C4C: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 83238C50: 89210051  lbz r9, 0x51(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 83238C54: 89410053  lbz r10, 0x53(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(83 as u32) ) } as u64;
	// 83238C58: 89010052  lbz r8, 0x52(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 83238C5C: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 83238C60: 99210052  stb r9, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[9].u8 ) };
	// 83238C64: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 83238C68: 99010051  stb r8, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[8].u8 ) };
	// 83238C6C: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x83238C70; continue 'dispatch;
            }
            0x83238C70 => {
    //   block [0x83238C70..0x83238CBC)
	// 83238C70: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 83238C74: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 83238C78: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 83238C7C: 390AF1BC  addi r8, r10, -0xe44
	ctx.r[8].s64 = ctx.r[10].s64 + -3652;
	// 83238C80: 816B6DD4  lwz r11, 0x6dd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28116 as u32) ) } as u64;
	// 83238C84: 5567103A  slwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 83238C88: C1A99484  lfs f13, -0x6b7c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 83238C8C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 83238C90: 7DA7442E  lfsx f13, r7, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 83238C94: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 83238C98: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 83238C9C: D9610050  stfd f11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[11].u64 ) };
	// 83238CA0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 83238CA4: 917C0004  stw r11, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 83238CA8: 40990014  ble cr6, 0x83238cbc
	if !ctx.cr[6].gt {
	pc = 0x83238CBC; continue 'dispatch;
	}
	// 83238CAC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 83238CB0: 409A000C  bne cr6, 0x83238cbc
	if !ctx.cr[6].eq {
	pc = 0x83238CBC; continue 'dispatch;
	}
	// 83238CB4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 83238CB8: 917C0004  stw r11, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x83238CBC; continue 'dispatch;
            }
            0x83238CBC => {
    //   block [0x83238CBC..0x83238D08)
	// 83238CBC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 83238CC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 83238CC4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 83238CC8: 4BFF3A31  bl 0x8322c6f8
	ctx.lr = 0x83238CCC;
	sub_8322C6F8(ctx, base);
	// 83238CCC: 817C0018  lwz r11, 0x18(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 83238CD0: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 83238CD4: 3BDC0014  addi r30, r28, 0x14
	ctx.r[30].s64 = ctx.r[28].s64 + 20;
	// 83238CD8: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83238CDC: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 83238CE0: 419A0028  beq cr6, 0x83238d08
	if ctx.cr[6].eq {
	pc = 0x83238D08; continue 'dispatch;
	}
	// 83238CE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 83238CE8: 4AF7EE31  bl 0x821b7b18
	ctx.lr = 0x83238CEC;
	sub_821B7B18(ctx, base);
	// 83238CEC: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 83238CF0: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 83238CF4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 83238CF8: 419A0010  beq cr6, 0x83238d08
	if ctx.cr[6].eq {
	pc = 0x83238D08; continue 'dispatch;
	}
	// 83238CFC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83238D00: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 83238D04: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x83238D08; continue 'dispatch;
            }
            0x83238D08 => {
    //   block [0x83238D08..0x83238D30)
	// 83238D08: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 83238D0C: 4AF7EE0D  bl 0x821b7b18
	ctx.lr = 0x83238D10;
	sub_821B7B18(ctx, base);
	// 83238D10: 576B063E  clrlwi r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 83238D14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83238D18: 419A0018  beq cr6, 0x83238d30
	if ctx.cr[6].eq {
	pc = 0x83238D30; continue 'dispatch;
	}
	// 83238D1C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 83238D20: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 83238D24: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 83238D28: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83238D2C: 4E800421  bctrl
	ctx.lr = 0x83238D30;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x83238D30 => {
    //   block [0x83238D30..0x83238D38)
	// 83238D30: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 83238D34: 4BA70720  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83238D38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x83238D38 size=436
    let mut pc: u32 = 0x83238D38;
    'dispatch: loop {
        match pc {
            0x83238D38 => {
    //   block [0x83238D38..0x83238D74)
	// 83238D38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83238D3C: 4BA706C5  bl 0x82ca9400
	ctx.lr = 0x83238D40;
	sub_82CA93D0(ctx, base);
	// 83238D40: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83238D44: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 83238D48: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 83238D4C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 83238D50: 3BABFFDF  addi r29, r11, -0x21
	ctx.r[29].s64 = ctx.r[11].s64 + -33;
	// 83238D54: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 83238D58: 816AE9C8  lwz r11, -0x1638(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-5688 as u32) ) } as u64;
	// 83238D5C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 83238D60: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 83238D64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83238D68: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 83238D6C: 419A0008  beq cr6, 0x83238d74
	if ctx.cr[6].eq {
	pc = 0x83238D74; continue 'dispatch;
	}
	// 83238D70: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x83238D74; continue 'dispatch;
            }
            0x83238D74 => {
    //   block [0x83238D74..0x83238DB4)
	// 83238D74: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83238D78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83238D7C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 83238D80: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83238D84: 4E800421  bctrl
	ctx.lr = 0x83238D88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83238D88: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 83238D8C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83238D90: 419A0154  beq cr6, 0x83238ee4
	if ctx.cr[6].eq {
	pc = 0x83238EE4; continue 'dispatch;
	}
	// 83238D94: 3FC0834A  lis r30, -0x7cb6
	ctx.r[30].s64 = -2092302336;
	// 83238D98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 83238D9C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 83238DA0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 83238DA4: 817EE9D4  lwz r11, -0x162c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-5676 as u32) ) } as u64;
	// 83238DA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83238DAC: 419A0008  beq cr6, 0x83238db4
	if ctx.cr[6].eq {
	pc = 0x83238DB4; continue 'dispatch;
	}
	// 83238DB0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x83238DB4 => {
    //   block [0x83238DB4..0x83238DE8)
	// 83238DB4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83238DB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83238DBC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 83238DC0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83238DC4: 4E800421  bctrl
	ctx.lr = 0x83238DC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83238DC8: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 83238DCC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83238DD0: 419A0038  beq cr6, 0x83238e08
	if ctx.cr[6].eq {
	pc = 0x83238E08; continue 'dispatch;
	}
	// 83238DD4: 817EE9D4  lwz r11, -0x162c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-5676 as u32) ) } as u64;
	// 83238DD8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 83238DDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83238DE0: 419A0008  beq cr6, 0x83238de8
	if ctx.cr[6].eq {
	pc = 0x83238DE8; continue 'dispatch;
	}
	// 83238DE4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x83238DE8 => {
    //   block [0x83238DE8..0x83238E08)
	// 83238DE8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 83238DEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83238DF0: 4B2479D9  bl 0x824807c8
	ctx.lr = 0x83238DF4;
	sub_824807C8(ctx, base);
	// 83238DF4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83238DF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83238DFC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 83238E00: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83238E04: 4E800421  bctrl
	ctx.lr = 0x83238E08;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x83238E08 => {
    //   block [0x83238E08..0x83238E2C)
	// 83238E08: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 83238E0C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 83238E10: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 83238E14: 409A0028  bne cr6, 0x83238e3c
	if !ctx.cr[6].eq {
	pc = 0x83238E3C; continue 'dispatch;
	}
	// 83238E18: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 83238E1C: 816BE9CC  lwz r11, -0x1634(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5684 as u32) ) } as u64;
	// 83238E20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83238E24: 419A0008  beq cr6, 0x83238e2c
	if ctx.cr[6].eq {
	pc = 0x83238E2C; continue 'dispatch;
	}
	// 83238E28: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x83238E2C; continue 'dispatch;
            }
            0x83238E2C => {
    //   block [0x83238E2C..0x83238E3C)
	// 83238E2C: 38BC0004  addi r5, r28, 4
	ctx.r[5].s64 = ctx.r[28].s64 + 4;
	// 83238E30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83238E34: 4B247995  bl 0x824807c8
	ctx.lr = 0x83238E38;
	sub_824807C8(ctx, base);
	// 83238E38: 48000050  b 0x83238e88
	pc = 0x83238E88; continue 'dispatch;
            }
            0x83238E3C => {
    //   block [0x83238E3C..0x83238E50)
	// 83238E3C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 83238E40: 816BE9D0  lwz r11, -0x1630(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5680 as u32) ) } as u64;
	// 83238E44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83238E48: 419A0008  beq cr6, 0x83238e50
	if ctx.cr[6].eq {
	pc = 0x83238E50; continue 'dispatch;
	}
	// 83238E4C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x83238E50; continue 'dispatch;
            }
            0x83238E50 => {
    //   block [0x83238E50..0x83238E88)
	// 83238E50: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 83238E54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83238E58: 4B2479F9  bl 0x82480850
	ctx.lr = 0x83238E5C;
	sub_82480850(ctx, base);
	// 83238E5C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 83238E60: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 83238E64: C1A10054  lfs f13, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 83238E68: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 83238E6C: 390AF1BC  addi r8, r10, -0xe44
	ctx.r[8].s64 = ctx.r[10].s64 + -3652;
	// 83238E70: 816B6DD4  lwz r11, 0x6dd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28116 as u32) ) } as u64;
	// 83238E74: 5567103A  slwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 83238E78: 7C07442E  lfsx f0, r7, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 83238E7C: ED800372  fmuls f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 83238E80: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 83238E84: 7D7C4FAE  stfiwx f11, r28, r9
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[28].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	pc = 0x83238E88; continue 'dispatch;
            }
            0x83238E88 => {
    //   block [0x83238E88..0x83238EE4)
	// 83238E88: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 83238E8C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 83238E90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 83238E94: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 83238E98: 4BFF38F9  bl 0x8322c790
	ctx.lr = 0x83238E9C;
	sub_8322C790(ctx, base);
	// 83238E9C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 83238EA0: 387C0014  addi r3, r28, 0x14
	ctx.r[3].s64 = ctx.r[28].s64 + 20;
	// 83238EA4: 4AF424F5  bl 0x8217b398
	ctx.lr = 0x83238EA8;
	sub_8217B398(ctx, base);
	// 83238EA8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 83238EAC: 4AF7EC6D  bl 0x821b7b18
	ctx.lr = 0x83238EB0;
	sub_821B7B18(ctx, base);
	// 83238EB0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83238EB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 83238EB8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 83238EBC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83238EC0: 4E800421  bctrl
	ctx.lr = 0x83238EC4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83238EC4: 5769063E  clrlwi r9, r27, 0x18
	ctx.r[9].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 83238EC8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83238ECC: 419A0018  beq cr6, 0x83238ee4
	if ctx.cr[6].eq {
	pc = 0x83238EE4; continue 'dispatch;
	}
	// 83238ED0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 83238ED4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 83238ED8: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 83238EDC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83238EE0: 4E800421  bctrl
	ctx.lr = 0x83238EE4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x83238EE4 => {
    //   block [0x83238EE4..0x83238EEC)
	// 83238EE4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 83238EE8: 4BA70568  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83238EF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x83238EF0 size=1012
    let mut pc: u32 = 0x83238EF0;
    'dispatch: loop {
        match pc {
            0x83238EF0 => {
    //   block [0x83238EF0..0x83238F40)
	// 83238EF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83238EF4: 4BA704FD  bl 0x82ca93f0
	ctx.lr = 0x83238EF8;
	sub_82CA93D0(ctx, base);
	// 83238EF8: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83238EFC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 83238F00: 39400018  li r10, 0x18
	ctx.r[10].s64 = 24;
	// 83238F04: 817C0028  lwz r11, 0x28(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) } as u64;
	// 83238F08: 813C0024  lwz r9, 0x24(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 83238F0C: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 83238F10: 7D4853D7  divw. r10, r8, r10
	ctx.r[10].s32 = ctx.r[8].s32 / ctx.r[10].s32;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 83238F14: 408103C8  ble 0x832392dc
	if !ctx.cr[0].gt {
	pc = 0x832392DC; continue 'dispatch;
	}
	// 83238F18: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 83238F1C: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 83238F20: 4198016C  blt cr6, 0x8323908c
	if ctx.cr[6].lt {
	pc = 0x8323908C; continue 'dispatch;
	}
	// 83238F24: 390AFFFC  addi r8, r10, -4
	ctx.r[8].s64 = ctx.r[10].s64 + -4;
	// 83238F28: 552B003E  slwi r11, r9, 0
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 83238F2C: 5508F0BE  srwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 83238F30: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 83238F34: 38E80001  addi r7, r8, 1
	ctx.r[7].s64 = ctx.r[8].s64 + 1;
	// 83238F38: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 83238F3C: 54E8103A  slwi r8, r7, 2
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	pc = 0x83238F40; continue 'dispatch;
            }
            0x83238F40 => {
    //   block [0x83238F40..0x8323908C)
	// 83238F40: 88CB0031  lbz r6, 0x31(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(49 as u32) ) } as u64;
	// 83238F44: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 83238F48: 888B0030  lbz r4, 0x30(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 83238F4C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 83238F50: 7CC60774  extsb r6, r6
	ctx.r[6].s64 = ctx.r[6].s8 as i64;
	// 83238F54: 8B0B004A  lbz r24, 0x4a(r11)
	ctx.r[24].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(74 as u32) ) } as u64;
	// 83238F58: 7C840774  extsb r4, r4
	ctx.r[4].s64 = ctx.r[4].s8 as i64;
	// 83238F5C: 8BEB0049  lbz r31, 0x49(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(73 as u32) ) } as u64;
	// 83238F60: 8BCB0048  lbz r30, 0x48(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 83238F64: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 83238F68: 7CC621D6  mullw r6, r6, r4
	ctx.r[6].s32 = ((ctx.r[6].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[6].s64 = ctx.r[6].s32 as i64;
	// 83238F6C: 888B0002  lbz r4, 2(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 83238F70: 8AEB0019  lbz r23, 0x19(r11)
	ctx.r[23].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 83238F74: 8ACB0018  lbz r22, 0x18(r11)
	ctx.r[22].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 83238F78: 8BAB0001  lbz r29, 1(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 83238F7C: 8B6B0000  lbz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 83238F80: F8810080  std r4, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[4].u64 ) };
	// 83238F84: 8B2B0032  lbz r25, 0x32(r11)
	ctx.r[25].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(50 as u32) ) } as u64;
	// 83238F88: 8B4B001A  lbz r26, 0x1a(r11)
	ctx.r[26].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(26 as u32) ) } as u64;
	// 83238F8C: 7CC607B4  extsw r6, r6
	ctx.r[6].s64 = ctx.r[6].s32 as i64;
	// 83238F90: 7FDE0774  extsb r30, r30
	ctx.r[30].s64 = ctx.r[30].s8 as i64;
	// 83238F94: F8C10058  std r6, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u64 ) };
	// 83238F98: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 83238F9C: 7FFF0774  extsb r31, r31
	ctx.r[31].s64 = ctx.r[31].s8 as i64;
	// 83238FA0: F8C10070  std r6, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[6].u64 ) };
	// 83238FA4: 7EC40774  extsb r4, r22
	ctx.r[4].s64 = ctx.r[22].s8 as i64;
	// 83238FA8: 7EE60774  extsb r6, r23
	ctx.r[6].s64 = ctx.r[23].s8 as i64;
	// 83238FAC: 7FBD0774  extsb r29, r29
	ctx.r[29].s64 = ctx.r[29].s8 as i64;
	// 83238FB0: 7F7B0774  extsb r27, r27
	ctx.r[27].s64 = ctx.r[27].s8 as i64;
	// 83238FB4: 7FFFF1D6  mullw r31, r31, r30
	ctx.r[31].s32 = ((ctx.r[31].s32 as i64 * ctx.r[30].s32 as i64) as i32);
	ctx.r[31].s64 = ctx.r[31].s32 as i64;
	// 83238FB8: C9010080  lfd f8, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 83238FBC: FCA0469C  fcfid f5, f8
	ctx.f[5].f64 = (ctx.f[8].s64 as f64);
	// 83238FC0: 7CC621D6  mullw r6, r6, r4
	ctx.r[6].s32 = ((ctx.r[6].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[6].s64 = ctx.r[6].s32 as i64;
	// 83238FC4: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 83238FC8: FC406E9C  fcfid f2, f13
	ctx.f[2].f64 = (ctx.f[13].s64 as f64);
	// 83238FCC: C9410070  lfd f10, 0x70(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 83238FD0: FDA0569C  fcfid f13, f10
	ctx.f[13].f64 = (ctx.f[10].s64 as f64);
	// 83238FD4: 7FDDD9D6  mullw r30, r29, r27
	ctx.r[30].s32 = ((ctx.r[29].s32 as i64 * ctx.r[27].s32 as i64) as i32);
	ctx.r[30].s64 = ctx.r[30].s32 as i64;
	// 83238FD8: FD001018  frsp f8, f2
	ctx.f[8].f64 = (ctx.f[2].f64 as f32) as f64;
	// 83238FDC: 7CC407B4  extsw r4, r6
	ctx.r[4].s64 = ctx.r[6].s32 as i64;
	// 83238FE0: 7F3BCB78  mr r27, r25
	ctx.r[27].u64 = ctx.r[25].u64;
	// 83238FE4: 7FFF07B4  extsw r31, r31
	ctx.r[31].s64 = ctx.r[31].s32 as i64;
	// 83238FE8: F8810088  std r4, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[4].u64 ) };
	// 83238FEC: 7FDE07B4  extsw r30, r30
	ctx.r[30].s64 = ctx.r[30].s32 as i64;
	// 83238FF0: C8E10088  lfd f7, 0x88(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 83238FF4: FB610060  std r27, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u64 ) };
	// 83238FF8: C9810060  lfd f12, 0x60(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 83238FFC: FBE10068  std r31, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u64 ) };
	// 83239000: C9610068  lfd f11, 0x68(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 83239004: FBC10078  std r30, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[30].u64 ) };
	// 83239008: C9210078  lfd f9, 0x78(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 8323900C: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 83239010: 3BE10094  addi r31, r1, 0x94
	ctx.r[31].s64 = ctx.r[1].s64 + 148;
	// 83239014: FBA10050  std r29, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u64 ) };
	// 83239018: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8323901C: FC60069C  fcfid f3, f0
	ctx.f[3].f64 = (ctx.f[0].s64 as f64);
	// 83239020: 38C100A4  addi r6, r1, 0xa4
	ctx.r[6].s64 = ctx.r[1].s64 + 164;
	// 83239024: FCC03E9C  fcfid f6, f7
	ctx.f[6].f64 = (ctx.f[7].s64 as f64);
	// 83239028: 38810098  addi r4, r1, 0x98
	ctx.r[4].s64 = ctx.r[1].s64 + 152;
	// 8323902C: FC804E9C  fcfid f4, f9
	ctx.f[4].f64 = (ctx.f[9].s64 as f64);
	// 83239030: 3BC100A8  addi r30, r1, 0xa8
	ctx.r[30].s64 = ctx.r[1].s64 + 168;
	// 83239034: FC20669C  fcfid f1, f12
	ctx.f[1].f64 = (ctx.f[12].s64 as f64);
	// 83239038: 3BA1009C  addi r29, r1, 0x9c
	ctx.r[29].s64 = ctx.r[1].s64 + 156;
	// 8323903C: FC005E9C  fcfid f0, f11
	ctx.f[0].f64 = (ctx.f[11].s64 as f64);
	// 83239040: 3B6100AC  addi r27, r1, 0xac
	ctx.r[27].s64 = ctx.r[1].s64 + 172;
	// 83239044: FD602818  frsp f11, f5
	ctx.f[11].f64 = (ctx.f[5].f64 as f32) as f64;
	// 83239048: 7D691D2E  stfsx f11, r9, r3
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[3].u32), tmp.u32) };
	// 8323904C: FD201818  frsp f9, f3
	ctx.f[9].f64 = (ctx.f[3].f64 as f32) as f64;
	// 83239050: 7D29352E  stfsx f9, r9, r6
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[6].u32), tmp.u32) };
	// 83239054: FCA06818  frsp f5, f13
	ctx.f[5].f64 = (ctx.f[13].f64 as f32) as f64;
	// 83239058: 7D09252E  stfsx f8, r9, r4
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[4].u32), tmp.u32) };
	// 8323905C: 396B0060  addi r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 + 96;
	// 83239060: 7CA9DD2E  stfsx f5, r9, r27
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[27].u32), tmp.u32) };
	// 83239064: FD803018  frsp f12, f6
	ctx.f[12].f64 = (ctx.f[6].f64 as f32) as f64;
	// 83239068: 7D89FD2E  stfsx f12, r9, r31
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 8323906C: FD402018  frsp f10, f4
	ctx.f[10].f64 = (ctx.f[4].f64 as f32) as f64;
	// 83239070: 7D492D2E  stfsx f10, r9, r5
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[5].u32), tmp.u32) };
	// 83239074: FCE00818  frsp f7, f1
	ctx.f[7].f64 = (ctx.f[1].f64 as f32) as f64;
	// 83239078: 7CE9F52E  stfsx f7, r9, r30
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[30].u32), tmp.u32) };
	// 8323907C: FCC00018  frsp f6, f0
	ctx.f[6].f64 = (ctx.f[0].f64 as f32) as f64;
	// 83239080: 7CC9ED2E  stfsx f6, r9, r29
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[29].u32), tmp.u32) };
	// 83239084: 39290010  addi r9, r9, 0x10
	ctx.r[9].s64 = ctx.r[9].s64 + 16;
	// 83239088: 4082FEB8  bne 0x83238f40
	if !ctx.cr[0].eq {
	pc = 0x83238F40; continue 'dispatch;
	}
	pc = 0x8323908C; continue 'dispatch;
            }
            0x8323908C => {
    //   block [0x8323908C..0x832390B4)
	// 8323908C: 7F085000  cmpw cr6, r8, r10
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[10].s32, &mut ctx.xer);
	// 83239090: 40980080  bge cr6, 0x83239110
	if !ctx.cr[6].lt {
	pc = 0x83239110; continue 'dispatch;
	}
	// 83239094: 550B083C  slwi r11, r8, 1
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 83239098: 80FC0024  lwz r7, 0x24(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 8323909C: 5509103A  slwi r9, r8, 2
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 832390A0: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 832390A4: 7D085050  subf r8, r8, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 832390A8: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832390AC: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 832390B0: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	pc = 0x832390B4; continue 'dispatch;
            }
            0x832390B4 => {
    //   block [0x832390B4..0x83239110)
	// 832390B4: 88EB0001  lbz r7, 1(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 832390B8: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 832390BC: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 832390C0: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 832390C4: 7CE30774  extsb r3, r7
	ctx.r[3].s64 = ctx.r[7].s8 as i64;
	// 832390C8: 88EB0002  lbz r7, 2(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 832390CC: 7CA50774  extsb r5, r5
	ctx.r[5].s64 = ctx.r[5].s8 as i64;
	// 832390D0: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 832390D4: 7CA329D6  mullw r5, r3, r5
	ctx.r[5].s32 = ((ctx.r[3].s32 as i64 * ctx.r[5].s32 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 832390D8: F8E10088  std r7, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[7].u64 ) };
	// 832390DC: C8010088  lfd f0, 0x88(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 832390E0: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 832390E4: 7CA307B4  extsw r3, r5
	ctx.r[3].s64 = ctx.r[5].s32 as i64;
	// 832390E8: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 832390EC: 7D89252E  stfsx f12, r9, r4
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[4].u32), tmp.u32) };
	// 832390F0: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 832390F4: F8610080  std r3, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[3].u64 ) };
	// 832390F8: C9610080  lfd f11, 0x80(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 832390FC: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 83239100: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 83239104: 7D29352E  stfsx f9, r9, r6
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[6].u32), tmp.u32) };
	// 83239108: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 8323910C: 4082FFA8  bne 0x832390b4
	if !ctx.cr[0].eq {
	pc = 0x832390B4; continue 'dispatch;
	}
	pc = 0x83239110; continue 'dispatch;
            }
            0x83239110 => {
    //   block [0x83239110..0x83239188)
	// 83239110: 216A0004  subfic r11, r10, 4
	ctx.xer.ca = ctx.r[10].u32 <= 4 as u32;
	ctx.r[11].s64 = (4 as i64) - ctx.r[10].s64;
	// 83239114: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 83239118: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 8323911C: 419800B8  blt cr6, 0x832391d4
	if ctx.cr[6].lt {
	pc = 0x832391D4; continue 'dispatch;
	}
	// 83239120: 554B083C  slwi r11, r10, 1
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 83239124: 813C0024  lwz r9, 0x24(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 83239128: 7D0A00D0  neg r8, r10
	ctx.r[8].s64 = -ctx.r[10].s64;
	// 8323912C: 7CEA5A14  add r7, r10, r11
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 83239130: 5508F0BE  srwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 83239134: 54EB1838  slwi r11, r7, 3
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 83239138: 38C80001  addi r6, r8, 1
	ctx.r[6].s64 = ctx.r[8].s64 + 1;
	// 8323913C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 83239140: 54C9103A  slwi r9, r6, 2
	ctx.r[9].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 83239144: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 83239148: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 8323914C: 88ABFFF8  lbz r5, -8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 83239150: 888BFFF9  lbz r4, -7(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-7 as u32) ) } as u64;
	// 83239154: 7CA30774  extsb r3, r5
	ctx.r[3].s64 = ctx.r[5].s8 as i64;
	// 83239158: 88CBFFFA  lbz r6, -6(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-6 as u32) ) } as u64;
	// 8323915C: 7C870774  extsb r7, r4
	ctx.r[7].s64 = ctx.r[4].s8 as i64;
	// 83239160: 7CA339D6  mullw r5, r3, r7
	ctx.r[5].s32 = ((ctx.r[3].s32 as i64 * ctx.r[7].s32 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 83239164: F8C10088  std r6, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[6].u64 ) };
	// 83239168: C8010088  lfd f0, 0x88(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 8323916C: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 83239170: 7CA407B4  extsw r4, r5
	ctx.r[4].s64 = ctx.r[5].s32 as i64;
	// 83239174: FC006818  frsp f0, f13
	ctx.f[0].f64 = (ctx.f[13].f64 as f32) as f64;
	// 83239178: F8810088  std r4, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[4].u64 ) };
	// 8323917C: C9810088  lfd f12, 0x88(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 83239180: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 83239184: FDA05818  frsp f13, f11
	ctx.f[13].f64 = (ctx.f[11].f64 as f32) as f64;
	pc = 0x83239188; continue 'dispatch;
            }
            0x83239188 => {
    //   block [0x83239188..0x832391D4)
	// 83239188: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 8323918C: 38E100A0  addi r7, r1, 0xa0
	ctx.r[7].s64 = ctx.r[1].s64 + 160;
	// 83239190: 38C10094  addi r6, r1, 0x94
	ctx.r[6].s64 = ctx.r[1].s64 + 148;
	// 83239194: 38A100A4  addi r5, r1, 0xa4
	ctx.r[5].s64 = ctx.r[1].s64 + 164;
	// 83239198: 38810098  addi r4, r1, 0x98
	ctx.r[4].s64 = ctx.r[1].s64 + 152;
	// 8323919C: 7DA85D2E  stfsx f13, r8, r11
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 832391A0: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 832391A4: 7C083D2E  stfsx f0, r8, r7
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32), tmp.u32) };
	// 832391A8: 3961009C  addi r11, r1, 0x9c
	ctx.r[11].s64 = ctx.r[1].s64 + 156;
	// 832391AC: 38E100AC  addi r7, r1, 0xac
	ctx.r[7].s64 = ctx.r[1].s64 + 172;
	// 832391B0: 7DA8352E  stfsx f13, r8, r6
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[6].u32), tmp.u32) };
	// 832391B4: 7C082D2E  stfsx f0, r8, r5
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[5].u32), tmp.u32) };
	// 832391B8: 7DA8252E  stfsx f13, r8, r4
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[4].u32), tmp.u32) };
	// 832391BC: 7C081D2E  stfsx f0, r8, r3
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[3].u32), tmp.u32) };
	// 832391C0: 7DA85D2E  stfsx f13, r8, r11
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 832391C4: 7C083D2E  stfsx f0, r8, r7
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32), tmp.u32) };
	// 832391C8: 39080010  addi r8, r8, 0x10
	ctx.r[8].s64 = ctx.r[8].s64 + 16;
	// 832391CC: 2F080004  cmpwi cr6, r8, 4
	ctx.cr[6].compare_i32(ctx.r[8].s32, 4, &mut ctx.xer);
	// 832391D0: 4198FFB8  blt cr6, 0x83239188
	if ctx.cr[6].lt {
	pc = 0x83239188; continue 'dispatch;
	}
	pc = 0x832391D4; continue 'dispatch;
            }
            0x832391D4 => {
    //   block [0x832391D4..0x83239274)
	// 832391D4: 2F090004  cmpwi cr6, r9, 4
	ctx.cr[6].compare_i32(ctx.r[9].s32, 4, &mut ctx.xer);
	// 832391D8: 4098009C  bge cr6, 0x83239274
	if !ctx.cr[6].lt {
	pc = 0x83239274; continue 'dispatch;
	}
	// 832391DC: 5547083C  slwi r7, r10, 1
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 832391E0: 811C0024  lwz r8, 0x24(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 832391E4: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 832391E8: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 832391EC: 38E100A0  addi r7, r1, 0xa0
	ctx.r[7].s64 = ctx.r[1].s64 + 160;
	// 832391F0: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 832391F4: 7C8B3A14  add r4, r11, r7
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 832391F8: 7FEA4214  add r31, r10, r8
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 832391FC: 21290004  subfic r9, r9, 4
	ctx.xer.ca = ctx.r[9].u32 <= 4 as u32;
	ctx.r[9].s64 = (4 as i64) - ctx.r[9].s64;
	// 83239200: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 83239204: 553D103A  slwi r29, r9, 2
	ctx.r[29].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 83239208: 38640004  addi r3, r4, 4
	ctx.r[3].s64 = ctx.r[4].s64 + 4;
	// 8323920C: 88DFFFFA  lbz r6, -6(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-6 as u32) ) } as u64;
	// 83239210: 38FDFFFC  addi r7, r29, -4
	ctx.r[7].s64 = ctx.r[29].s64 + -4;
	// 83239214: 7FCB5214  add r30, r11, r10
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 83239218: 54E5003A  rlwinm r5, r7, 0, 0, 0x1d
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 8323921C: F8C10088  std r6, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[6].u64 ) };
	// 83239220: C8010088  lfd f0, 0x88(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 83239224: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 83239228: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8323922C: D1840000  stfs f12, 0(r4)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 83239230: 4BA706D9  bl 0x82ca9908
	ctx.lr = 0x83239234;
	sub_82CA9908(ctx, base);
	// 83239234: 88BFFFF8  lbz r5, -8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) } as u64;
	// 83239238: 889FFFF9  lbz r4, -7(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-7 as u32) ) } as u64;
	// 8323923C: 397DFFFC  addi r11, r29, -4
	ctx.r[11].s64 = ctx.r[29].s64 + -4;
	// 83239240: 7CAA0774  extsb r10, r5
	ctx.r[10].s64 = ctx.r[5].s8 as i64;
	// 83239244: 7C890774  extsb r9, r4
	ctx.r[9].s64 = ctx.r[4].s8 as i64;
	// 83239248: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8323924C: 7D0A49D6  mullw r8, r10, r9
	ctx.r[8].s32 = ((ctx.r[10].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 83239250: 7D0707B4  extsw r7, r8
	ctx.r[7].s64 = ctx.r[8].s32 as i64;
	// 83239254: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 83239258: F8E10088  std r7, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[7].u64 ) };
	// 8323925C: C9610088  lfd f11, 0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 83239260: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 83239264: 5565003A  rlwinm r5, r11, 0, 0, 0x1d
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 83239268: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 8323926C: D13E0000  stfs f9, 0(r30)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 83239270: 4BA70699  bl 0x82ca9908
	ctx.lr = 0x83239274;
	sub_82CA9908(ctx, base);
	pc = 0x83239274; continue 'dispatch;
            }
            0x83239274 => {
    //   block [0x83239274..0x832392DC)
	// 83239274: 39610094  addi r11, r1, 0x94
	ctx.r[11].s64 = ctx.r[1].s64 + 148;
	// 83239278: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 8323927C: 392100A4  addi r9, r1, 0xa4
	ctx.r[9].s64 = ctx.r[1].s64 + 164;
	// 83239280: 390100A0  addi r8, r1, 0xa0
	ctx.r[8].s64 = ctx.r[1].s64 + 160;
	// 83239284: 38E1009C  addi r7, r1, 0x9c
	ctx.r[7].s64 = ctx.r[1].s64 + 156;
	// 83239288: 38C10098  addi r6, r1, 0x98
	ctx.r[6].s64 = ctx.r[1].s64 + 152;
	pc = 0x832392DC; continue 'dispatch;
            }
            0x832392DC => {
    //   block [0x832392DC..0x832392E4)
	// 832392DC: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 832392E0: 4BA70160  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832392E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x832392E8 size=212
    let mut pc: u32 = 0x832392E8;
    'dispatch: loop {
        match pc {
            0x832392E8 => {
    //   block [0x832392E8..0x83239348)
	// 832392E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832392EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832392F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832392F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832392F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 832392FC: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 83239300: 4B529511  bl 0x82762810
	ctx.lr = 0x83239304;
	sub_82762810(ctx, base);
	// 83239304: 813F0028  lwz r9, 0x28(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 83239308: 811F0024  lwz r8, 0x24(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 8323930C: 38DF0020  addi r6, r31, 0x20
	ctx.r[6].s64 = ctx.r[31].s64 + 32;
	// 83239310: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 83239314: 419A0094  beq cr6, 0x832393a8
	if ctx.cr[6].eq {
	pc = 0x832393A8; continue 'dispatch;
	}
	// 83239318: 39400018  li r10, 0x18
	ctx.r[10].s64 = 24;
	// 8323931C: 7D694850  subf r11, r9, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[9].s64;
	// 83239320: 7F094840  cmplw cr6, r9, r9
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[9].u32, &mut ctx.xer);
	// 83239324: 7D6B53D6  divw r11, r11, r10
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	// 83239328: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8323932C: 7CEB5214  add r7, r11, r10
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 83239330: 54EB1838  slwi r11, r7, 3
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 83239334: 7CEB4214  add r7, r11, r8
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 83239338: 419A006C  beq cr6, 0x832393a4
	if ctx.cr[6].eq {
	pc = 0x832393A4; continue 'dispatch;
	}
	// 8323933C: 39680008  addi r11, r8, 8
	ctx.r[11].s64 = ctx.r[8].s64 + 8;
	// 83239340: 3949000C  addi r10, r9, 0xc
	ctx.r[10].s64 = ctx.r[9].s64 + 12;
	// 83239344: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	pc = 0x83239348; continue 'dispatch;
            }
            0x83239348 => {
    //   block [0x83239348..0x832393A4)
	// 83239348: 80AAFFF4  lwz r5, -0xc(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) } as u64;
	// 8323934C: 90ABFFF8  stw r5, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[5].u32 ) };
	// 83239350: C00AFFF8  lfs f0, -8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 83239354: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 83239358: 7DA85C2E  lfsx f13, r8, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8323935C: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 83239360: C18A0000  lfs f12, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 83239364: D18B0004  stfs f12, 4(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 83239368: 888A0004  lbz r4, 4(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323936C: 988B0008  stb r4, 8(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u8 ) };
	// 83239370: 886A0005  lbz r3, 5(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(5 as u32) ) } as u64;
	// 83239374: 986B0009  stb r3, 9(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(9 as u32), ctx.r[3].u8 ) };
	// 83239378: 88AA0006  lbz r5, 6(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 8323937C: 98AB000A  stb r5, 0xa(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(10 as u32), ctx.r[5].u8 ) };
	// 83239380: 888A0007  lbz r4, 7(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(7 as u32) ) } as u64;
	// 83239384: 988B000B  stb r4, 0xb(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(11 as u32), ctx.r[4].u8 ) };
	// 83239388: 886A0008  lbz r3, 8(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323938C: 394A0018  addi r10, r10, 0x18
	ctx.r[10].s64 = ctx.r[10].s64 + 24;
	// 83239390: 986B000C  stb r3, 0xc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[3].u8 ) };
	// 83239394: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 83239398: 38AAFFF4  addi r5, r10, -0xc
	ctx.r[5].s64 = ctx.r[10].s64 + -12;
	// 8323939C: 7F054840  cmplw cr6, r5, r9
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[9].u32, &mut ctx.xer);
	// 832393A0: 409AFFA8  bne cr6, 0x83239348
	if !ctx.cr[6].eq {
	pc = 0x83239348; continue 'dispatch;
	}
	pc = 0x832393A4; continue 'dispatch;
            }
            0x832393A4 => {
    //   block [0x832393A4..0x832393A8)
	// 832393A4: 90E60008  stw r7, 8(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	pc = 0x832393A8; continue 'dispatch;
            }
            0x832393A8 => {
    //   block [0x832393A8..0x832393BC)
	// 832393A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832393AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832393B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832393B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832393B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832393C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832393C0 size=108
    let mut pc: u32 = 0x832393C0;
    'dispatch: loop {
        match pc {
            0x832393C0 => {
    //   block [0x832393C0..0x832393F4)
	// 832393C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832393C4: 4BA70049  bl 0x82ca940c
	ctx.lr = 0x832393C8;
	sub_82CA93D0(ctx, base);
	// 832393C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832393CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 832393D0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 832393D4: 394B27E4  addi r10, r11, 0x27e4
	ctx.r[10].s64 = ctx.r[11].s64 + 10212;
	// 832393D8: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 832393DC: 4BFFFF0D  bl 0x832392e8
	ctx.lr = 0x832393E0;
	sub_832392E8(ctx, base);
	// 832393E0: 807E0024  lwz r3, 0x24(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 832393E4: 3BFE0020  addi r31, r30, 0x20
	ctx.r[31].s64 = ctx.r[30].s64 + 32;
	// 832393E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832393EC: 419A0008  beq cr6, 0x832393f4
	if ctx.cr[6].eq {
	pc = 0x832393F4; continue 'dispatch;
	}
	// 832393F0: 4AFE2949  bl 0x8221bd38
	ctx.lr = 0x832393F4;
	sub_8221BD38(ctx, base);
	pc = 0x832393F4; continue 'dispatch;
            }
            0x832393F4 => {
    //   block [0x832393F4..0x83239418)
	// 832393F4: 3BBE0010  addi r29, r30, 0x10
	ctx.r[29].s64 = ctx.r[30].s64 + 16;
	// 832393F8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 832393FC: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 83239400: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 83239404: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 83239408: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323940C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 83239410: 419A0008  beq cr6, 0x83239418
	if ctx.cr[6].eq {
	pc = 0x83239418; continue 'dispatch;
	}
	// 83239414: 4AFE2925  bl 0x8221bd38
	ctx.lr = 0x83239418;
	sub_8221BD38(ctx, base);
	pc = 0x83239418; continue 'dispatch;
            }
            0x83239418 => {
    //   block [0x83239418..0x8323942C)
	// 83239418: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 8323941C: 93DD0008  stw r30, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 83239420: 93DD000C  stw r30, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 83239424: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 83239428: 4BA70034  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83239430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x83239430 size=1708
    let mut pc: u32 = 0x83239430;
    'dispatch: loop {
        match pc {
            0x83239430 => {
    //   block [0x83239430..0x83239488)
	// 83239430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83239434: 4BA6FFB1  bl 0x82ca93e4
	ctx.lr = 0x83239438;
	sub_82CA93D0(ctx, base);
	// 83239438: DBC1FF80  stfd f30, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[30].u64 ) };
	// 8323943C: DBE1FF88  stfd f31, -0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 83239440: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83239444: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 83239448: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 8323944C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 83239450: 3B0B38F4  addi r24, r11, 0x38f4
	ctx.r[24].s64 = ctx.r[11].s64 + 14580;
	// 83239454: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 83239458: 816A3900  lwz r11, 0x3900(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(14592 as u32) ) } as u64;
	// 8323945C: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 83239460: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 83239464: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83239468: 409A0020  bne cr6, 0x83239488
	if !ctx.cr[6].eq {
	pc = 0x83239488; continue 'dispatch;
	}
	// 8323946C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 83239470: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 83239474: 916A3900  stw r11, 0x3900(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(14592 as u32), ctx.r[11].u32 ) };
	// 83239478: 4B7DF4C9  bl 0x82a18940
	ctx.lr = 0x8323947C;
	sub_82A18940(ctx, base);
	// 8323947C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 83239480: 386B2868  addi r3, r11, 0x2868
	ctx.r[3].s64 = ctx.r[11].s64 + 10344;
	// 83239484: 4BA70A9D  bl 0x82ca9f20
	ctx.lr = 0x83239488;
	sub_82CA9F20(ctx, base);
	pc = 0x83239488; continue 'dispatch;
            }
            0x83239488 => {
    //   block [0x83239488..0x832394A0)
	// 83239488: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323948C: 3A600000  li r19, 0
	ctx.r[19].s64 = 0;
	// 83239490: 3A800001  li r20, 1
	ctx.r[20].s64 = 1;
	// 83239494: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83239498: 409A003C  bne cr6, 0x832394d4
	if !ctx.cr[6].eq {
	pc = 0x832394D4; continue 'dispatch;
	}
	// 8323949C: 7E7E9B78  mr r30, r19
	ctx.r[30].u64 = ctx.r[19].u64;
	pc = 0x832394A0; continue 'dispatch;
            }
            0x832394A0 => {
    //   block [0x832394A0..0x832394C8)
	// 832394A0: 7E8BF030  slw r11, r20, r30
	if (ctx.r[30].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[20].u32) << ((ctx.r[30].u8 & 0x1F) as u32)) as u64;
	}
	// 832394A4: 39807406  li r12, 0x7406
	ctx.r[12].s64 = 29702;
	// 832394A8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 832394AC: 7D6A6038  and r10, r11, r12
	ctx.r[10].u64 = ctx.r[11].u64 & ctx.r[12].u64;
	// 832394B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832394B4: 419A0014  beq cr6, 0x832394c8
	if ctx.cr[6].eq {
	pc = 0x832394C8; continue 'dispatch;
	}
	// 832394B8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 832394BC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 832394C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 832394C4: 4B23A3DD  bl 0x824738a0
	ctx.lr = 0x832394C8;
	sub_824738A0(ctx, base);
	pc = 0x832394C8; continue 'dispatch;
            }
            0x832394C8 => {
    //   block [0x832394C8..0x832394D4)
	// 832394C8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 832394CC: 2F1E0012  cmpwi cr6, r30, 0x12
	ctx.cr[6].compare_i32(ctx.r[30].s32, 18, &mut ctx.xer);
	// 832394D0: 4099FFD0  ble cr6, 0x832394a0
	if !ctx.cr[6].gt {
	pc = 0x832394A0; continue 'dispatch;
	}
	pc = 0x832394D4; continue 'dispatch;
            }
            0x832394D4 => {
    //   block [0x832394D4..0x83239504)
	// 832394D4: 82B80004  lwz r21, 4(r24)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 832394D8: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 832394DC: 815D0014  lwz r10, 0x14(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 832394E0: 93010060  stw r24, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u32 ) };
	// 832394E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832394E8: 81350000  lwz r9, 0(r21)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 832394EC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 832394F0: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 832394F4: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 832394F8: E9010060  ld r8, 0x60(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 832394FC: F9010060  std r8, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u64 ) };
	// 83239500: 419A0020  beq cr6, 0x83239520
	if ctx.cr[6].eq {
	pc = 0x83239520; continue 'dispatch;
	}
	pc = 0x83239504; continue 'dispatch;
            }
            0x83239504 => {
    //   block [0x83239504..0x83239520)
	// 83239504: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 83239508: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323950C: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 83239510: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 83239514: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 83239518: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323951C: 4082FFE8  bne 0x83239504
	if !ctx.cr[0].eq {
	pc = 0x83239504; continue 'dispatch;
	}
	pc = 0x83239520; continue 'dispatch;
            }
            0x83239520 => {
    //   block [0x83239520..0x83239554)
	// 83239520: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 83239524: 3BAA000C  addi r29, r10, 0xc
	ctx.r[29].s64 = ctx.r[10].s64 + 12;
	// 83239528: 4AF7E5F1  bl 0x821b7b18
	ctx.lr = 0x8323952C;
	sub_821B7B18(ctx, base);
	// 8323952C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 83239530: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 83239534: 392A9484  addi r9, r10, -0x6b7c
	ctx.r[9].s64 = ctx.r[10].s64 + -27516;
	// 83239538: 3AC00010  li r22, 0x10
	ctx.r[22].s64 = 16;
	// 8323953C: 3F408349  lis r26, -0x7cb7
	ctx.r[26].s64 = -2092367872;
	// 83239540: C3EA9484  lfs f31, -0x6b7c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 83239544: 3AE00020  li r23, 0x20
	ctx.r[23].s64 = 32;
	// 83239548: 3B200038  li r25, 0x38
	ctx.r[25].s64 = 56;
	// 8323954C: C3C9000C  lfs f30, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 83239550: 3B6BF1BC  addi r27, r11, -0xe44
	ctx.r[27].s64 = ctx.r[11].s64 + -3652;
	pc = 0x83239554; continue 'dispatch;
            }
            0x83239554 => {
    //   block [0x83239554..0x83239568)
	// 83239554: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 83239558: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323955C: 419A000C  beq cr6, 0x83239568
	if ctx.cr[6].eq {
	pc = 0x83239568; continue 'dispatch;
	}
	// 83239560: 7F0AC040  cmplw cr6, r10, r24
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[24].u32, &mut ctx.xer);
	// 83239564: 419A0008  beq cr6, 0x8323956c
	if ctx.cr[6].eq {
	pc = 0x8323956C; continue 'dispatch;
	}
	pc = 0x83239568; continue 'dispatch;
            }
            0x83239568 => {
    //   block [0x83239568..0x8323956C)
	// 83239568: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8323956C; continue 'dispatch;
            }
            0x8323956C => {
    //   block [0x8323956C..0x83239584)
	// 8323956C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 83239570: 7F0BA840  cmplw cr6, r11, r21
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[21].u32, &mut ctx.xer);
	// 83239574: 419A0558  beq cr6, 0x83239acc
	if ctx.cr[6].eq {
	pc = 0x83239ACC; continue 'dispatch;
	}
	// 83239578: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323957C: 409A0008  bne cr6, 0x83239584
	if !ctx.cr[6].eq {
	pc = 0x83239584; continue 'dispatch;
	}
	// 83239580: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x83239584; continue 'dispatch;
            }
            0x83239584 => {
    //   block [0x83239584..0x83239594)
	// 83239584: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 83239588: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8323958C: 409A0008  bne cr6, 0x83239594
	if !ctx.cr[6].eq {
	pc = 0x83239594; continue 'dispatch;
	}
	// 83239590: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x83239594; continue 'dispatch;
            }
            0x83239594 => {
    //   block [0x83239594..0x832395E8)
	// 83239594: 83CB000C  lwz r30, 0xc(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 83239598: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8323959C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 832395A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 832395A4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 832395A8: 4B7DE231  bl 0x82a177d8
	ctx.lr = 0x832395AC;
	sub_82A177D8(ctx, base);
	// 832395AC: 2F1E1000  cmpwi cr6, r30, 0x1000
	ctx.cr[6].compare_i32(ctx.r[30].s32, 4096, &mut ctx.xer);
	// 832395B0: 419902B8  bgt cr6, 0x83239868
	if ctx.cr[6].gt {
	pc = 0x83239868; continue 'dispatch;
	}
	// 832395B4: 419A020C  beq cr6, 0x832397c0
	if ctx.cr[6].eq {
	pc = 0x832397C0; continue 'dispatch;
	}
	// 832395B8: 2F1E0002  cmpwi cr6, r30, 2
	ctx.cr[6].compare_i32(ctx.r[30].s32, 2, &mut ctx.xer);
	// 832395BC: 419A017C  beq cr6, 0x83239738
	if ctx.cr[6].eq {
	pc = 0x83239738; continue 'dispatch;
	}
	// 832395C0: 2F1E0004  cmpwi cr6, r30, 4
	ctx.cr[6].compare_i32(ctx.r[30].s32, 4, &mut ctx.xer);
	// 832395C4: 419A0094  beq cr6, 0x83239658
	if ctx.cr[6].eq {
	pc = 0x83239658; continue 'dispatch;
	}
	// 832395C8: 2F1E0400  cmpwi cr6, r30, 0x400
	ctx.cr[6].compare_i32(ctx.r[30].s32, 1024, &mut ctx.xer);
	// 832395CC: 409A04F4  bne cr6, 0x83239ac0
	if !ctx.cr[6].eq {
	pc = 0x83239AC0; continue 'dispatch;
	}
	// 832395D0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 832395D4: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 832395D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832395DC: 419A000C  beq cr6, 0x832395e8
	if ctx.cr[6].eq {
	pc = 0x832395E8; continue 'dispatch;
	}
	// 832395E0: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 832395E4: 419A0008  beq cr6, 0x832395ec
	if ctx.cr[6].eq {
	pc = 0x832395EC; continue 'dispatch;
	}
	pc = 0x832395E8; continue 'dispatch;
            }
            0x832395E8 => {
    //   block [0x832395E8..0x832395EC)
	// 832395E8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x832395EC; continue 'dispatch;
            }
            0x832395EC => {
    //   block [0x832395EC..0x83239614)
	// 832395EC: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 832395F0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 832395F4: 409A0030  bne cr6, 0x83239624
	if !ctx.cr[6].eq {
	pc = 0x83239624; continue 'dispatch;
	}
	// 832395F8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 832395FC: 419A0018  beq cr6, 0x83239614
	if ctx.cr[6].eq {
	pc = 0x83239614; continue 'dispatch;
	}
	// 83239600: C01C0034  lfs f0, 0x34(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 83239604: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 83239608: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8323960C: 4B0C6B1D  bl 0x82300128
	ctx.lr = 0x83239610;
	sub_82300128(ctx, base);
	// 83239610: 4BFFFF44  b 0x83239554
	pc = 0x83239554; continue 'dispatch;
            }
            0x83239614 => {
    //   block [0x83239614..0x83239624)
	// 83239614: D3DF0034  stfs f30, 0x34(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 83239618: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323961C: 4B0C6B0D  bl 0x82300128
	ctx.lr = 0x83239620;
	sub_82300128(ctx, base);
	// 83239620: 4BFFFF34  b 0x83239554
	pc = 0x83239554; continue 'dispatch;
            }
            0x83239624 => {
    //   block [0x83239624..0x83239630)
	// 83239624: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83239628: 409A0008  bne cr6, 0x83239630
	if !ctx.cr[6].eq {
	pc = 0x83239630; continue 'dispatch;
	}
	// 8323962C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x83239630; continue 'dispatch;
            }
            0x83239630 => {
    //   block [0x83239630..0x83239640)
	// 83239630: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 83239634: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83239638: 409A0008  bne cr6, 0x83239640
	if !ctx.cr[6].eq {
	pc = 0x83239640; continue 'dispatch;
	}
	// 8323963C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x83239640; continue 'dispatch;
            }
            0x83239640 => {
    //   block [0x83239640..0x83239658)
	// 83239640: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 83239644: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 83239648: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323964C: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 83239650: 4B0C6AD9  bl 0x82300128
	ctx.lr = 0x83239654;
	sub_82300128(ctx, base);
	// 83239654: 4BFFFF00  b 0x83239554
	pc = 0x83239554; continue 'dispatch;
            }
            0x83239658 => {
    //   block [0x83239658..0x83239670)
	// 83239658: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8323965C: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 83239660: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83239664: 419A000C  beq cr6, 0x83239670
	if ctx.cr[6].eq {
	pc = 0x83239670; continue 'dispatch;
	}
	// 83239668: 7F0AE840  cmplw cr6, r10, r29
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8323966C: 419A0008  beq cr6, 0x83239674
	if ctx.cr[6].eq {
	pc = 0x83239674; continue 'dispatch;
	}
	pc = 0x83239670; continue 'dispatch;
            }
            0x83239670 => {
    //   block [0x83239670..0x83239674)
	// 83239670: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x83239674; continue 'dispatch;
            }
            0x83239674 => {
    //   block [0x83239674..0x832396AC)
	// 83239674: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 83239678: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8323967C: 409A006C  bne cr6, 0x832396e8
	if !ctx.cr[6].eq {
	pc = 0x832396E8; continue 'dispatch;
	}
	// 83239680: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 83239684: 419A0028  beq cr6, 0x832396ac
	if ctx.cr[6].eq {
	pc = 0x832396AC; continue 'dispatch;
	}
	// 83239688: C01C0008  lfs f0, 8(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323968C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 83239690: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 83239694: C1BC000C  lfs f13, 0xc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 83239698: D1BF000C  stfs f13, 0xc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8323969C: C19C0010  lfs f12, 0x10(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 832396A0: D19F0010  stfs f12, 0x10(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 832396A4: 4B0C6A85  bl 0x82300128
	ctx.lr = 0x832396A8;
	sub_82300128(ctx, base);
	// 832396A8: 4BFFFEAC  b 0x83239554
	pc = 0x83239554; continue 'dispatch;
            }
            0x832396AC => {
    //   block [0x832396AC..0x832396E8)
	// 832396AC: D3C10050  stfs f30, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 832396B0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 832396B4: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 832396B8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	pc = 0x832396E8; continue 'dispatch;
            }
            0x832396E8 => {
    //   block [0x832396E8..0x83239738)
	// 832396E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 832396EC: 409A0008  bne cr6, 0x832396f4
	if !ctx.cr[6].eq {
	pc = 0x832396F4; continue 'dispatch;
	}
	// 832396F0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 832396F4: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 832396F8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 832396FC: 409A0008  bne cr6, 0x83239704
	if !ctx.cr[6].eq {
	pc = 0x83239704; continue 'dispatch;
	}
	// 83239700: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 83239704: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 83239708: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 8323970C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	pc = 0x83239738; continue 'dispatch;
            }
            0x83239738 => {
    //   block [0x83239738..0x832397C0)
	// 83239738: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8323973C: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 83239740: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83239744: 419A000C  beq cr6, 0x83239750
	if ctx.cr[6].eq {
	pc = 0x83239750; continue 'dispatch;
	}
	// 83239748: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8323974C: 419A0008  beq cr6, 0x83239754
	if ctx.cr[6].eq {
	pc = 0x83239754; continue 'dispatch;
	}
	// 83239750: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 83239754: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 83239758: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8323975C: 409A0030  bne cr6, 0x8323978c
	if !ctx.cr[6].eq {
	pc = 0x8323978C; continue 'dispatch;
	}
	// 83239760: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 83239764: 419A0018  beq cr6, 0x8323977c
	if ctx.cr[6].eq {
	pc = 0x8323977C; continue 'dispatch;
	}
	// 83239768: C01C0014  lfs f0, 0x14(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323976C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 83239770: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 83239774: 4B0C69B5  bl 0x82300128
	ctx.lr = 0x83239778;
	sub_82300128(ctx, base);
	// 83239778: 4BFFFDDC  b 0x83239554
	pc = 0x83239554; continue 'dispatch;
	// 8323977C: D3DF0014  stfs f30, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 83239780: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 83239784: 4B0C69A5  bl 0x82300128
	ctx.lr = 0x83239788;
	sub_82300128(ctx, base);
	// 83239788: 4BFFFDCC  b 0x83239554
	pc = 0x83239554; continue 'dispatch;
	// 8323978C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83239790: 409A0008  bne cr6, 0x83239798
	if !ctx.cr[6].eq {
	pc = 0x83239798; continue 'dispatch;
	}
	// 83239794: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 83239798: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323979C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 832397A0: 409A0008  bne cr6, 0x832397a8
	if !ctx.cr[6].eq {
	pc = 0x832397A8; continue 'dispatch;
	}
	// 832397A4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 832397A8: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 832397AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 832397B0: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 832397B4: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 832397B8: 4B0C6971  bl 0x82300128
	ctx.lr = 0x832397BC;
	sub_82300128(ctx, base);
	// 832397BC: 4BFFFD98  b 0x83239554
	pc = 0x83239554; continue 'dispatch;
            }
            0x832397C0 => {
    //   block [0x832397C0..0x83239868)
	// 832397C0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 832397C4: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 832397C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 832397CC: 419A000C  beq cr6, 0x832397d8
	if ctx.cr[6].eq {
	pc = 0x832397D8; continue 'dispatch;
	}
	// 832397D0: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 832397D4: 419A0008  beq cr6, 0x832397dc
	if ctx.cr[6].eq {
	pc = 0x832397DC; continue 'dispatch;
	}
	// 832397D8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 832397DC: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 832397E0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 832397E4: 409A0048  bne cr6, 0x8323982c
	if !ctx.cr[6].eq {
	pc = 0x8323982C; continue 'dispatch;
	}
	// 832397E8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 832397EC: 419A0020  beq cr6, 0x8323980c
	if ctx.cr[6].eq {
	pc = 0x8323980C; continue 'dispatch;
	}
	// 832397F0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 832397F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 832397F8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832397FC: 895C0031  lbz r10, 0x31(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(49 as u32) ) } as u64;
	// 83239800: 995F0031  stb r10, 0x31(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(49 as u32), ctx.r[10].u8 ) };
	// 83239804: 4B0C6925  bl 0x82300128
	ctx.lr = 0x83239808;
	sub_82300128(ctx, base);
	// 83239808: 4BFFFD4C  b 0x83239554
	pc = 0x83239554; continue 'dispatch;
	// 8323980C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 83239810: 4BFE0151  bl 0x83219960
	ctx.lr = 0x83239814;
	sub_83219960(ctx, base);
	// 83239814: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 83239818: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323981C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 83239820: 9A7F0031  stb r19, 0x31(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(49 as u32), ctx.r[19].u8 ) };
	// 83239824: 4B0C6905  bl 0x82300128
	ctx.lr = 0x83239828;
	sub_82300128(ctx, base);
	// 83239828: 4BFFFD2C  b 0x83239554
	pc = 0x83239554; continue 'dispatch;
	// 8323982C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83239830: 409A0008  bne cr6, 0x83239838
	if !ctx.cr[6].eq {
	pc = 0x83239838; continue 'dispatch;
	}
	// 83239834: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 83239838: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323983C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83239840: 409A0008  bne cr6, 0x83239848
	if !ctx.cr[6].eq {
	pc = 0x83239848; continue 'dispatch;
	}
	// 83239844: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 83239848: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323984C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 83239850: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 83239854: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 83239858: 892B0014  lbz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323985C: 993F0031  stb r9, 0x31(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(49 as u32), ctx.r[9].u8 ) };
	// 83239860: 4B0C68C9  bl 0x82300128
	ctx.lr = 0x83239864;
	sub_82300128(ctx, base);
	// 83239864: 4BFFFCF0  b 0x83239554
	pc = 0x83239554; continue 'dispatch;
            }
            0x83239868 => {
    //   block [0x83239868..0x83239AC0)
	// 83239868: 2F1E2000  cmpwi cr6, r30, 0x2000
	ctx.cr[6].compare_i32(ctx.r[30].s32, 8192, &mut ctx.xer);
	// 8323986C: 419A0188  beq cr6, 0x832399f4
	if ctx.cr[6].eq {
	pc = 0x832399F4; continue 'dispatch;
	}
	// 83239870: 2F1E4000  cmpwi cr6, r30, 0x4000
	ctx.cr[6].compare_i32(ctx.r[30].s32, 16384, &mut ctx.xer);
	// 83239874: 409A024C  bne cr6, 0x83239ac0
	if !ctx.cr[6].eq {
	pc = 0x83239AC0; continue 'dispatch;
	}
	// 83239878: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8323987C: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 83239880: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83239884: 419A000C  beq cr6, 0x83239890
	if ctx.cr[6].eq {
	pc = 0x83239890; continue 'dispatch;
	}
	// 83239888: 7F0AE840  cmplw cr6, r10, r29
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8323988C: 419A0008  beq cr6, 0x83239894
	if ctx.cr[6].eq {
	pc = 0x83239894; continue 'dispatch;
	}
	// 83239890: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 83239894: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 83239898: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8323989C: 409A00D8  bne cr6, 0x83239974
	if !ctx.cr[6].eq {
	pc = 0x83239974; continue 'dispatch;
	}
	// 832398A0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 832398A4: 419A0048  beq cr6, 0x832398ec
	if ctx.cr[6].eq {
	pc = 0x832398EC; continue 'dispatch;
	}
	// 832398A8: C01C0018  lfs f0, 0x18(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 832398AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 832398B0: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 832398B4: C1BC001C  lfs f13, 0x1c(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 832398B8: D1BF001C  stfs f13, 0x1c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 832398BC: 897C0020  lbz r11, 0x20(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 832398C0: 997F0020  stb r11, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u8 ) };
	// 832398C4: 815C0024  lwz r10, 0x24(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 832398C8: 915F0024  stw r10, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 832398CC: 813C0028  lwz r9, 0x28(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) } as u64;
	// 832398D0: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 832398D4: 811C002C  lwz r8, 0x2c(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 832398D8: 911F002C  stw r8, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[8].u32 ) };
	// 832398DC: 88FC0030  lbz r7, 0x30(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) } as u64;
	// 832398E0: 98FF0030  stb r7, 0x30(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[7].u8 ) };
	// 832398E4: 4B0C6845  bl 0x82300128
	ctx.lr = 0x832398E8;
	sub_82300128(ctx, base);
	// 832398E8: 4BFFFC6C  b 0x83239554
	pc = 0x83239554; continue 'dispatch;
	// 832398EC: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 832398F0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 832398F4: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 832398F8: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 832398FC: D3C10074  stfs f30, 0x74(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 83239900: 39210074  addi r9, r1, 0x74
	ctx.r[9].s64 = ctx.r[1].s64 + 116;
	// 83239904: 3901006C  addi r8, r1, 0x6c
	ctx.r[8].s64 = ctx.r[1].s64 + 108;
	// 83239908: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8323990C: 38E100B0  addi r7, r1, 0xb0
	ctx.r[7].s64 = ctx.r[1].s64 + 176;
	// 83239910: D3FF0018  stfs f31, 0x18(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 83239914: 38A100F0  addi r5, r1, 0xf0
	ctx.r[5].s64 = ctx.r[1].s64 + 240;
	// 83239918: D3FF001C  stfs f31, 0x1c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8323991C: 38C100D0  addi r6, r1, 0xd0
	ctx.r[6].s64 = ctx.r[1].s64 + 208;
	// 83239920: 9A7F0020  stb r19, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[19].u8 ) };
	// 83239924: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
            }
            0x83239AC0 => {
    //   block [0x83239AC0..0x83239ACC)
	// 83239AC0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 83239AC4: 4B0C6665  bl 0x82300128
	ctx.lr = 0x83239AC8;
	sub_82300128(ctx, base);
	// 83239AC8: 4BFFFA8C  b 0x83239554
	pc = 0x83239554; continue 'dispatch;
            }
            0x83239ACC => {
    //   block [0x83239ACC..0x83239ADC)
	// 83239ACC: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 83239AD0: CBC1FF80  lfd f30, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 83239AD4: CBE1FF88  lfd f31, -0x78(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 83239AD8: 4BA6F95C  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83239AE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x83239AE0 size=2260
    let mut pc: u32 = 0x83239AE0;
    'dispatch: loop {
        match pc {
            0x83239AE0 => {
    //   block [0x83239AE0..0x83239B44)
	// 83239AE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 83239AE4: 4BA6F8FD  bl 0x82ca93e0
	ctx.lr = 0x83239AE8;
	sub_82CA93D0(ctx, base);
	// 83239AE8: DBA1FF70  stfd f29, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[29].u64 ) };
	// 83239AEC: DBC1FF78  stfd f30, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[30].u64 ) };
	// 83239AF0: DBE1FF80  stfd f31, -0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[31].u64 ) };
	// 83239AF4: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 83239AF8: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 83239AFC: FFA00890  fmr f29, f1
	ctx.f[29].f64 = ctx.f[1].f64;
	// 83239B00: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 83239B04: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 83239B08: 3AEB3904  addi r23, r11, 0x3904
	ctx.r[23].s64 = ctx.r[11].s64 + 14596;
	// 83239B0C: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 83239B10: 816A3910  lwz r11, 0x3910(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(14608 as u32) ) } as u64;
	// 83239B14: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 83239B18: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 83239B1C: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 83239B20: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83239B24: 409A0020  bne cr6, 0x83239b44
	if !ctx.cr[6].eq {
	pc = 0x83239B44; continue 'dispatch;
	}
	// 83239B28: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 83239B2C: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 83239B30: 916A3910  stw r11, 0x3910(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(14608 as u32), ctx.r[11].u32 ) };
	// 83239B34: 4B7DEE0D  bl 0x82a18940
	ctx.lr = 0x83239B38;
	sub_82A18940(ctx, base);
	// 83239B38: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 83239B3C: 386B2858  addi r3, r11, 0x2858
	ctx.r[3].s64 = ctx.r[11].s64 + 10328;
	// 83239B40: 4BA703E1  bl 0x82ca9f20
	ctx.lr = 0x83239B44;
	sub_82CA9F20(ctx, base);
	pc = 0x83239B44; continue 'dispatch;
            }
            0x83239B44 => {
    //   block [0x83239B44..0x83239B5C)
	// 83239B44: 81770008  lwz r11, 8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 83239B48: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 83239B4C: 3A400001  li r18, 1
	ctx.r[18].s64 = 1;
	// 83239B50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83239B54: 409A0040  bne cr6, 0x83239b94
	if !ctx.cr[6].eq {
	pc = 0x83239B94; continue 'dispatch;
	}
	// 83239B58: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	pc = 0x83239B5C; continue 'dispatch;
            }
            0x83239B5C => {
    //   block [0x83239B5C..0x83239B88)
	// 83239B5C: 3D800002  lis r12, 2
	ctx.r[12].s64 = 131072;
	// 83239B60: 7E4BF830  slw r11, r18, r31
	if (ctx.r[31].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[18].u32) << ((ctx.r[31].u8 & 0x1F) as u32)) as u64;
	}
	// 83239B64: 618C8DCE  ori r12, r12, 0x8dce
	ctx.r[12].u64 = ctx.r[12].u64 | 36302;
	// 83239B68: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 83239B6C: 7D6A6038  and r10, r11, r12
	ctx.r[10].u64 = ctx.r[11].u64 & ctx.r[12].u64;
	// 83239B70: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83239B74: 419A0014  beq cr6, 0x83239b88
	if ctx.cr[6].eq {
	pc = 0x83239B88; continue 'dispatch;
	}
	// 83239B78: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 83239B7C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 83239B80: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 83239B84: 4B239D1D  bl 0x824738a0
	ctx.lr = 0x83239B88;
	sub_824738A0(ctx, base);
	pc = 0x83239B88; continue 'dispatch;
            }
            0x83239B88 => {
    //   block [0x83239B88..0x83239B94)
	// 83239B88: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 83239B8C: 2F1F0012  cmpwi cr6, r31, 0x12
	ctx.cr[6].compare_i32(ctx.r[31].s32, 18, &mut ctx.xer);
	// 83239B90: 4099FFCC  ble cr6, 0x83239b5c
	if !ctx.cr[6].gt {
	pc = 0x83239B5C; continue 'dispatch;
	}
	pc = 0x83239B94; continue 'dispatch;
            }
            0x83239B94 => {
    //   block [0x83239B94..0x83239BC4)
	// 83239B94: 82B70004  lwz r21, 4(r23)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 83239B98: 81780018  lwz r11, 0x18(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(24 as u32) ) } as u64;
	// 83239B9C: 81580014  lwz r10, 0x14(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(20 as u32) ) } as u64;
	// 83239BA0: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 83239BA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83239BA8: 81350000  lwz r9, 0(r21)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 83239BAC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 83239BB0: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 83239BB4: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 83239BB8: E9010060  ld r8, 0x60(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 83239BBC: F9010060  std r8, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u64 ) };
	// 83239BC0: 419A0020  beq cr6, 0x83239be0
	if ctx.cr[6].eq {
	pc = 0x83239BE0; continue 'dispatch;
	}
	pc = 0x83239BC4; continue 'dispatch;
            }
            0x83239BC4 => {
    //   block [0x83239BC4..0x83239BE0)
	// 83239BC4: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 83239BC8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 83239BCC: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 83239BD0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 83239BD4: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 83239BD8: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 83239BDC: 4082FFE8  bne 0x83239bc4
	if !ctx.cr[0].eq {
	pc = 0x83239BC4; continue 'dispatch;
	}
	pc = 0x83239BE0; continue 'dispatch;
            }
            0x83239BE0 => {
    //   block [0x83239BE0..0x83239C08)
	// 83239BE0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 83239BE4: 3B8A000C  addi r28, r10, 0xc
	ctx.r[28].s64 = ctx.r[10].s64 + 12;
	// 83239BE8: 4AF7DF31  bl 0x821b7b18
	ctx.lr = 0x83239BEC;
	sub_821B7B18(ctx, base);
	// 83239BEC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 83239BF0: 3A800010  li r20, 0x10
	ctx.r[20].s64 = 16;
	// 83239BF4: 394B9484  addi r10, r11, -0x6b7c
	ctx.r[10].s64 = ctx.r[11].s64 + -27516;
	// 83239BF8: 3B400018  li r26, 0x18
	ctx.r[26].s64 = 24;
	// 83239BFC: 3A600005  li r19, 5
	ctx.r[19].s64 = 5;
	// 83239C00: C3CB9484  lfs f30, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 83239C04: C3EA000C  lfs f31, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x83239C08; continue 'dispatch;
            }
            0x83239C08 => {
    //   block [0x83239C08..0x83239C1C)
	// 83239C08: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 83239C0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83239C10: 419A000C  beq cr6, 0x83239c1c
	if ctx.cr[6].eq {
	pc = 0x83239C1C; continue 'dispatch;
	}
	// 83239C14: 7F0AB840  cmplw cr6, r10, r23
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[23].u32, &mut ctx.xer);
	// 83239C18: 419A0008  beq cr6, 0x83239c20
	if ctx.cr[6].eq {
	pc = 0x83239C20; continue 'dispatch;
	}
	pc = 0x83239C1C; continue 'dispatch;
            }
            0x83239C1C => {
    //   block [0x83239C1C..0x83239C20)
	// 83239C1C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x83239C20; continue 'dispatch;
            }
            0x83239C20 => {
    //   block [0x83239C20..0x83239C38)
	// 83239C20: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 83239C24: 7F0BA840  cmplw cr6, r11, r21
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[21].u32, &mut ctx.xer);
	// 83239C28: 419A0778  beq cr6, 0x8323a3a0
	if ctx.cr[6].eq {
	pc = 0x8323A3A0; continue 'dispatch;
	}
	// 83239C2C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83239C30: 409A0008  bne cr6, 0x83239c38
	if !ctx.cr[6].eq {
	pc = 0x83239C38; continue 'dispatch;
	}
	// 83239C34: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x83239C38; continue 'dispatch;
            }
            0x83239C38 => {
    //   block [0x83239C38..0x83239C48)
	// 83239C38: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 83239C3C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 83239C40: 409A0008  bne cr6, 0x83239c48
	if !ctx.cr[6].eq {
	pc = 0x83239C48; continue 'dispatch;
	}
	// 83239C44: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x83239C48; continue 'dispatch;
            }
            0x83239C48 => {
    //   block [0x83239C48..0x83239D8C)
	// 83239C48: 83EB000C  lwz r31, 0xc(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 83239C4C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 83239C50: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 83239C54: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 83239C58: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 83239C5C: 4B7DDB7D  bl 0x82a177d8
	ctx.lr = 0x83239C60;
	sub_82A177D8(ctx, base);
	// 83239C60: 2F1F0080  cmpwi cr6, r31, 0x80
	ctx.cr[6].compare_i32(ctx.r[31].s32, 128, &mut ctx.xer);
	// 83239C64: 419904F8  bgt cr6, 0x8323a15c
	if ctx.cr[6].gt {
	pc = 0x8323A15C; continue 'dispatch;
	}
	// 83239C68: 419A046C  beq cr6, 0x8323a0d4
	if ctx.cr[6].eq {
	pc = 0x8323A0D4; continue 'dispatch;
	}
	// 83239C6C: 397FFFFE  addi r11, r31, -2
	ctx.r[11].s64 = ctx.r[31].s64 + -2;
	// 83239C70: 2B0B003E  cmplwi cr6, r11, 0x3e
	ctx.cr[6].compare_u32(ctx.r[11].u32, 62 as u32, &mut ctx.xer);
	// 83239C74: 41990720  bgt cr6, 0x8323a394
	if ctx.cr[6].gt {
	pc = 0x8323A394; continue 'dispatch;
	}
	// 83239C78: 3D808324  lis r12, -0x7cdc
	ctx.r[12].s64 = -2094792704;
	// 83239C7C: 398C9C90  addi r12, r12, -0x6370
	ctx.r[12].s64 = ctx.r[12].s64 + -25456;
	// 83239C80: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 83239C84: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 83239C88: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 83239C8C: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x83239D8C; continue 'dispatch;
		},
		1 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		2 => {
	pc = 0x83239E14; continue 'dispatch;
		},
		3 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		4 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		5 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		6 => {
	pc = 0x83239EF4; continue 'dispatch;
		},
		7 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		8 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		9 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		10 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		11 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		12 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		13 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		14 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		15 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		16 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		17 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		18 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		19 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		20 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		21 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		22 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		23 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		24 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		25 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		26 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		27 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		28 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		29 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		30 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		31 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		32 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		33 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		34 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		35 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		36 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		37 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		38 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		39 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		40 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		41 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		42 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		43 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		44 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		45 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		46 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		47 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		48 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		49 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		50 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		51 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		52 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		53 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		54 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		55 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		56 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		57 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		58 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		59 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		60 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		61 => {
	pc = 0x8323A394; continue 'dispatch;
		},
		62 => {
	pc = 0x8323A04C; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 83239C90: 83239D8C  lwz r25, -0x6274(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-25204 as u32) ) } as u64;
	// 83239C94: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239C98: 83239E14  lwz r25, -0x61ec(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-25068 as u32) ) } as u64;
	// 83239C9C: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239CA0: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239CA4: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239CA8: 83239EF4  lwz r25, -0x610c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-24844 as u32) ) } as u64;
	// 83239CAC: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239CB0: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239CB4: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239CB8: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239CBC: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239CC0: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239CC4: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239CC8: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239CCC: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239CD0: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239CD4: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239CD8: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239CDC: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239CE0: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239CE4: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239CE8: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239CEC: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239CF0: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239CF4: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239CF8: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239CFC: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D00: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D04: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D08: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D0C: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D10: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D14: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D18: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D1C: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D20: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D24: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D28: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D2C: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D30: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D34: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D38: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D3C: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D40: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D44: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D48: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D4C: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D50: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D54: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D58: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D5C: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D60: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D64: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D68: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D6C: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D70: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D74: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D78: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D7C: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D80: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D84: 8323A394  lwz r25, -0x5c6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-23660 as u32) ) } as u64;
	// 83239D88: 8323A04C  lwz r25, -0x5fb4(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-24500 as u32) ) } as u64;
            }
            0x83239D8C => {
    //   block [0x83239D8C..0x83239DA4)
	// 83239D8C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 83239D90: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 83239D94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83239D98: 419A000C  beq cr6, 0x83239da4
	if ctx.cr[6].eq {
	pc = 0x83239DA4; continue 'dispatch;
	}
	// 83239D9C: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 83239DA0: 419A0008  beq cr6, 0x83239da8
	if ctx.cr[6].eq {
	pc = 0x83239DA8; continue 'dispatch;
	}
	pc = 0x83239DA4; continue 'dispatch;
            }
            0x83239DA4 => {
    //   block [0x83239DA4..0x83239DA8)
	// 83239DA4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x83239DA8; continue 'dispatch;
            }
            0x83239DA8 => {
    //   block [0x83239DA8..0x83239DD0)
	// 83239DA8: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 83239DAC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 83239DB0: 409A0030  bne cr6, 0x83239de0
	if !ctx.cr[6].eq {
	pc = 0x83239DE0; continue 'dispatch;
	}
	// 83239DB4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 83239DB8: 419A0018  beq cr6, 0x83239dd0
	if ctx.cr[6].eq {
	pc = 0x83239DD0; continue 'dispatch;
	}
	// 83239DBC: C01B0010  lfs f0, 0x10(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 83239DC0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 83239DC4: D01D0010  stfs f0, 0x10(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 83239DC8: 4B0C6361  bl 0x82300128
	ctx.lr = 0x83239DCC;
	sub_82300128(ctx, base);
	// 83239DCC: 4BFFFE3C  b 0x83239c08
	pc = 0x83239C08; continue 'dispatch;
            }
            0x83239DD0 => {
    //   block [0x83239DD0..0x83239DE0)
	// 83239DD0: D3FD0010  stfs f31, 0x10(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 83239DD4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 83239DD8: 4B0C6351  bl 0x82300128
	ctx.lr = 0x83239DDC;
	sub_82300128(ctx, base);
	// 83239DDC: 4BFFFE2C  b 0x83239c08
	pc = 0x83239C08; continue 'dispatch;
            }
            0x83239DE0 => {
    //   block [0x83239DE0..0x83239DEC)
	// 83239DE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83239DE4: 409A0008  bne cr6, 0x83239dec
	if !ctx.cr[6].eq {
	pc = 0x83239DEC; continue 'dispatch;
	}
	// 83239DE8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x83239DEC; continue 'dispatch;
            }
            0x83239DEC => {
    //   block [0x83239DEC..0x83239DFC)
	// 83239DEC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 83239DF0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 83239DF4: 409A0008  bne cr6, 0x83239dfc
	if !ctx.cr[6].eq {
	pc = 0x83239DFC; continue 'dispatch;
	}
	// 83239DF8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x83239DFC; continue 'dispatch;
            }
            0x83239DFC => {
    //   block [0x83239DFC..0x83239E14)
	// 83239DFC: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 83239E00: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 83239E04: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 83239E08: D01D0010  stfs f0, 0x10(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 83239E0C: 4B0C631D  bl 0x82300128
	ctx.lr = 0x83239E10;
	sub_82300128(ctx, base);
	// 83239E10: 4BFFFDF8  b 0x83239c08
	pc = 0x83239C08; continue 'dispatch;
            }
            0x83239E14 => {
    //   block [0x83239E14..0x83239E2C)
	// 83239E14: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 83239E18: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 83239E1C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83239E20: 419A000C  beq cr6, 0x83239e2c
	if ctx.cr[6].eq {
	pc = 0x83239E2C; continue 'dispatch;
	}
	// 83239E24: 7F0AE040  cmplw cr6, r10, r28
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[28].u32, &mut ctx.xer);
	// 83239E28: 419A0008  beq cr6, 0x83239e30
	if ctx.cr[6].eq {
	pc = 0x83239E30; continue 'dispatch;
	}
	pc = 0x83239E2C; continue 'dispatch;
            }
            0x83239E2C => {
    //   block [0x83239E2C..0x83239E30)
	// 83239E2C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x83239E30; continue 'dispatch;
            }
            0x83239E30 => {
    //   block [0x83239E30..0x83239E68)
	// 83239E30: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 83239E34: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 83239E38: 409A006C  bne cr6, 0x83239ea4
	if !ctx.cr[6].eq {
	pc = 0x83239EA4; continue 'dispatch;
	}
	// 83239E3C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 83239E40: 419A0028  beq cr6, 0x83239e68
	if ctx.cr[6].eq {
	pc = 0x83239E68; continue 'dispatch;
	}
	// 83239E44: C01B0004  lfs f0, 4(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 83239E48: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 83239E4C: D01D0004  stfs f0, 4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 83239E50: C1BB0008  lfs f13, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 83239E54: D1BD0008  stfs f13, 8(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 83239E58: C19B000C  lfs f12, 0xc(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 83239E5C: D19D000C  stfs f12, 0xc(r29)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 83239E60: 4B0C62C9  bl 0x82300128
	ctx.lr = 0x83239E64;
	sub_82300128(ctx, base);
	// 83239E64: 4BFFFDA4  b 0x83239c08
	pc = 0x83239C08; continue 'dispatch;
            }
            0x83239E68 => {
    //   block [0x83239E68..0x83239EA4)
	// 83239E68: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 83239E6C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 83239E70: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 83239E74: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	pc = 0x83239EA4; continue 'dispatch;
            }
            0x83239EA4 => {
    //   block [0x83239EA4..0x83239EF4)
	// 83239EA4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83239EA8: 409A0008  bne cr6, 0x83239eb0
	if !ctx.cr[6].eq {
	pc = 0x83239EB0; continue 'dispatch;
	}
	// 83239EAC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 83239EB0: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 83239EB4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 83239EB8: 409A0008  bne cr6, 0x83239ec0
	if !ctx.cr[6].eq {
	pc = 0x83239EC0; continue 'dispatch;
	}
	// 83239EBC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 83239EC0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 83239EC4: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 83239EC8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	pc = 0x83239EF4; continue 'dispatch;
            }
            0x83239EF4 => {
    //   block [0x83239EF4..0x8323A04C)
	// 83239EF4: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 83239EF8: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 83239EFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83239F00: 419A000C  beq cr6, 0x83239f0c
	if ctx.cr[6].eq {
	pc = 0x83239F0C; continue 'dispatch;
	}
	// 83239F04: 7F0AE040  cmplw cr6, r10, r28
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[28].u32, &mut ctx.xer);
	// 83239F08: 419A0008  beq cr6, 0x83239f10
	if ctx.cr[6].eq {
	pc = 0x83239F10; continue 'dispatch;
	}
	// 83239F0C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 83239F10: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 83239F14: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 83239F18: 409A0048  bne cr6, 0x83239f60
	if !ctx.cr[6].eq {
	pc = 0x83239F60; continue 'dispatch;
	}
	// 83239F1C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 83239F20: 419A0028  beq cr6, 0x83239f48
	if ctx.cr[6].eq {
	pc = 0x83239F48; continue 'dispatch;
	}
	// 83239F24: 897B0038  lbz r11, 0x38(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(56 as u32) ) } as u64;
	// 83239F28: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 83239F2C: 997D0038  stb r11, 0x38(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(56 as u32), ctx.r[11].u8 ) };
	// 83239F30: C01B003C  lfs f0, 0x3c(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 83239F34: D01D003C  stfs f0, 0x3c(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 83239F38: 895B0034  lbz r10, 0x34(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(52 as u32) ) } as u64;
	// 83239F3C: 995D0034  stb r10, 0x34(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(52 as u32), ctx.r[10].u8 ) };
	// 83239F40: 4B0C61E9  bl 0x82300128
	ctx.lr = 0x83239F44;
	sub_82300128(ctx, base);
	// 83239F44: 4BFFFCC4  b 0x83239c08
	pc = 0x83239C08; continue 'dispatch;
	// 83239F48: D3DD003C  stfs f30, 0x3c(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 83239F4C: 9B3D0038  stb r25, 0x38(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(56 as u32), ctx.r[25].u8 ) };
	// 83239F50: 9B3D0034  stb r25, 0x34(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(52 as u32), ctx.r[25].u8 ) };
	// 83239F54: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 83239F58: 4B0C61D1  bl 0x82300128
	ctx.lr = 0x83239F5C;
	sub_82300128(ctx, base);
	// 83239F5C: 4BFFFCAC  b 0x83239c08
	pc = 0x83239C08; continue 'dispatch;
	// 83239F60: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 83239F64: 409A0008  bne cr6, 0x83239f6c
	if !ctx.cr[6].eq {
	pc = 0x83239F6C; continue 'dispatch;
	}
	// 83239F68: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 83239F6C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 83239F70: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 83239F74: 409A0008  bne cr6, 0x83239f7c
	if !ctx.cr[6].eq {
	pc = 0x83239F7C; continue 'dispatch;
	}
	// 83239F78: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 83239F7C: 81580004  lwz r10, 4(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 83239F80: D3C100A8  stfs f30, 0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 83239F84: 83EB0010  lwz r31, 0x10(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 83239F88: 3BD60020  addi r30, r22, 0x20
	ctx.r[30].s64 = ctx.r[22].s64 + 32;
	// 83239F8C: 7D4907B4  extsw r9, r10
	ctx.r[9].s64 = ctx.r[10].s32 as i64;
	// 83239F90: 80F60024  lwz r7, 0x24(r22)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(36 as u32) ) } as u64;
	// 83239F94: 81160028  lwz r8, 0x28(r22)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(40 as u32) ) } as u64;
	// 83239F98: F9210068  std r9, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u64 ) };
	// 83239F9C: 7CC74050  subf r6, r7, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 83239FA0: 9B2100B4  stb r25, 0xb4(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[25].u8 ) };
	// 83239FA4: 80BF0014  lwz r5, 0x14(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 83239FA8: C01F0020  lfs f0, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 83239FAC: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 83239FB0: D00100AC  stfs f0, 0xac(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 83239FB4: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 83239FB8: 7C66D3D7  divw. r3, r6, r26
	ctx.r[3].s32 = ctx.r[6].s32 / ctx.r[26].s32;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 83239FBC: C9A10068  lfd f13, 0x68(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 83239FC0: 893F001C  lbz r9, 0x1c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 83239FC4: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 83239FC8: 88FF0024  lbz r7, 0x24(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 83239FCC: 98A100B0  stb r5, 0xb0(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[5].u8 ) };
	// 83239FD0: 988100B1  stb r4, 0xb1(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(177 as u32), ctx.r[4].u8 ) };
	// 83239FD4: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 83239FD8: 992100B2  stb r9, 0xb2(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(178 as u32), ctx.r[9].u8 ) };
	// 83239FDC: 98E100B3  stb r7, 0xb3(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(179 as u32), ctx.r[7].u8 ) };
	// 83239FE0: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 83239FE4: ED4BE824  fdivs f10, f11, f29
	ctx.f[10].f64 = ((ctx.f[11].f64 / ctx.f[29].f64) as f32) as f64;
	// 83239FE8: D14100A4  stfs f10, 0xa4(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 83239FEC: 41820020  beq 0x8323a00c
	if ctx.cr[0].eq {
	pc = 0x8323A00C; continue 'dispatch;
	}
	// 83239FF0: 550B003E  slwi r11, r8, 0
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 83239FF4: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 83239FF8: 386BFFE8  addi r3, r11, -0x18
	ctx.r[3].s64 = ctx.r[11].s64 + -24;
	// 83239FFC: 4B7DE775  bl 0x82a18770
	ctx.lr = 0x8323A000;
	sub_82A18770(ctx, base);
	// 8323A000: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8323A004: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323A008: 419A0010  beq cr6, 0x8323a018
	if ctx.cr[6].eq {
	pc = 0x8323A018; continue 'dispatch;
	}
	// 8323A00C: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 8323A010: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323A014: 4B7DE855  bl 0x82a18868
	ctx.lr = 0x8323A018;
	sub_82A18868(ctx, base);
	// 8323A018: 897F001C  lbz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8323A01C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323A020: 997D0038  stb r11, 0x38(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(56 as u32), ctx.r[11].u8 ) };
	// 8323A024: C01F0020  lfs f0, 0x20(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323A028: D01D003C  stfs f0, 0x3c(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 8323A02C: 895F0024  lbz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 8323A030: 995D0034  stb r10, 0x34(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(52 as u32), ctx.r[10].u8 ) };
	// 8323A034: 893F0025  lbz r9, 0x25(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(37 as u32) ) } as u64;
	// 8323A038: 993D0035  stb r9, 0x35(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(53 as u32), ctx.r[9].u8 ) };
	// 8323A03C: C1BF0028  lfs f13, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8323A040: D1BD0030  stfs f13, 0x30(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8323A044: 4B0C60E5  bl 0x82300128
	ctx.lr = 0x8323A048;
	sub_82300128(ctx, base);
	// 8323A048: 4BFFFBC0  b 0x83239c08
	pc = 0x83239C08; continue 'dispatch;
            }
            0x8323A04C => {
    //   block [0x8323A04C..0x8323A0D4)
	// 8323A04C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8323A050: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323A054: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323A058: 419A000C  beq cr6, 0x8323a064
	if ctx.cr[6].eq {
	pc = 0x8323A064; continue 'dispatch;
	}
	// 8323A05C: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8323A060: 419A0008  beq cr6, 0x8323a068
	if ctx.cr[6].eq {
	pc = 0x8323A068; continue 'dispatch;
	}
	// 8323A064: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323A068: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8323A06C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8323A070: 409A0030  bne cr6, 0x8323a0a0
	if !ctx.cr[6].eq {
	pc = 0x8323A0A0; continue 'dispatch;
	}
	// 8323A074: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8323A078: 419A0018  beq cr6, 0x8323a090
	if ctx.cr[6].eq {
	pc = 0x8323A090; continue 'dispatch;
	}
	// 8323A07C: 817B0024  lwz r11, 0x24(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(36 as u32) ) } as u64;
	// 8323A080: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323A084: 917D0024  stw r11, 0x24(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 8323A088: 4B0C60A1  bl 0x82300128
	ctx.lr = 0x8323A08C;
	sub_82300128(ctx, base);
	// 8323A08C: 4BFFFB7C  b 0x83239c08
	pc = 0x83239C08; continue 'dispatch;
	// 8323A090: 925D0024  stw r18, 0x24(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[18].u32 ) };
	// 8323A094: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323A098: 4B0C6091  bl 0x82300128
	ctx.lr = 0x8323A09C;
	sub_82300128(ctx, base);
	// 8323A09C: 4BFFFB6C  b 0x83239c08
	pc = 0x83239C08; continue 'dispatch;
	// 8323A0A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323A0A4: 409A0008  bne cr6, 0x8323a0ac
	if !ctx.cr[6].eq {
	pc = 0x8323A0AC; continue 'dispatch;
	}
	// 8323A0A8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323A0AC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323A0B0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8323A0B4: 409A0008  bne cr6, 0x8323a0bc
	if !ctx.cr[6].eq {
	pc = 0x8323A0BC; continue 'dispatch;
	}
	// 8323A0B8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323A0BC: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323A0C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323A0C4: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323A0C8: 915D0024  stw r10, 0x24(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 8323A0CC: 4B0C605D  bl 0x82300128
	ctx.lr = 0x8323A0D0;
	sub_82300128(ctx, base);
	// 8323A0D0: 4BFFFB38  b 0x83239c08
	pc = 0x83239C08; continue 'dispatch;
            }
            0x8323A0D4 => {
    //   block [0x8323A0D4..0x8323A15C)
	// 8323A0D4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8323A0D8: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323A0DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323A0E0: 419A000C  beq cr6, 0x8323a0ec
	if ctx.cr[6].eq {
	pc = 0x8323A0EC; continue 'dispatch;
	}
	// 8323A0E4: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8323A0E8: 419A0008  beq cr6, 0x8323a0f0
	if ctx.cr[6].eq {
	pc = 0x8323A0F0; continue 'dispatch;
	}
	// 8323A0EC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323A0F0: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8323A0F4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8323A0F8: 409A0030  bne cr6, 0x8323a128
	if !ctx.cr[6].eq {
	pc = 0x8323A128; continue 'dispatch;
	}
	// 8323A0FC: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8323A100: 419A0018  beq cr6, 0x8323a118
	if ctx.cr[6].eq {
	pc = 0x8323A118; continue 'dispatch;
	}
	// 8323A104: 817B0028  lwz r11, 0x28(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 8323A108: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323A10C: 917D0028  stw r11, 0x28(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 8323A110: 4B0C6019  bl 0x82300128
	ctx.lr = 0x8323A114;
	sub_82300128(ctx, base);
	// 8323A114: 4BFFFAF4  b 0x83239c08
	pc = 0x83239C08; continue 'dispatch;
	// 8323A118: 927D0028  stw r19, 0x28(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(40 as u32), ctx.r[19].u32 ) };
	// 8323A11C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323A120: 4B0C6009  bl 0x82300128
	ctx.lr = 0x8323A124;
	sub_82300128(ctx, base);
	// 8323A124: 4BFFFAE4  b 0x83239c08
	pc = 0x83239C08; continue 'dispatch;
	// 8323A128: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323A12C: 409A0008  bne cr6, 0x8323a134
	if !ctx.cr[6].eq {
	pc = 0x8323A134; continue 'dispatch;
	}
	// 8323A130: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323A134: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323A138: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8323A13C: 409A0008  bne cr6, 0x8323a144
	if !ctx.cr[6].eq {
	pc = 0x8323A144; continue 'dispatch;
	}
	// 8323A140: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323A144: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323A148: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323A14C: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323A150: 915D0028  stw r10, 0x28(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 8323A154: 4B0C5FD5  bl 0x82300128
	ctx.lr = 0x8323A158;
	sub_82300128(ctx, base);
	// 8323A158: 4BFFFAB0  b 0x83239c08
	pc = 0x83239C08; continue 'dispatch;
            }
            0x8323A15C => {
    //   block [0x8323A15C..0x8323A394)
	// 8323A15C: 2F1F0800  cmpwi cr6, r31, 0x800
	ctx.cr[6].compare_i32(ctx.r[31].s32, 2048, &mut ctx.xer);
	// 8323A160: 419901B0  bgt cr6, 0x8323a310
	if ctx.cr[6].gt {
	pc = 0x8323A310; continue 'dispatch;
	}
	// 8323A164: 419A0124  beq cr6, 0x8323a288
	if ctx.cr[6].eq {
	pc = 0x8323A288; continue 'dispatch;
	}
	// 8323A168: 2F1F0100  cmpwi cr6, r31, 0x100
	ctx.cr[6].compare_i32(ctx.r[31].s32, 256, &mut ctx.xer);
	// 8323A16C: 419A0094  beq cr6, 0x8323a200
	if ctx.cr[6].eq {
	pc = 0x8323A200; continue 'dispatch;
	}
	// 8323A170: 2F1F0400  cmpwi cr6, r31, 0x400
	ctx.cr[6].compare_i32(ctx.r[31].s32, 1024, &mut ctx.xer);
	// 8323A174: 409A0220  bne cr6, 0x8323a394
	if !ctx.cr[6].eq {
	pc = 0x8323A394; continue 'dispatch;
	}
	// 8323A178: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8323A17C: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323A180: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323A184: 419A000C  beq cr6, 0x8323a190
	if ctx.cr[6].eq {
	pc = 0x8323A190; continue 'dispatch;
	}
	// 8323A188: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8323A18C: 419A0008  beq cr6, 0x8323a194
	if ctx.cr[6].eq {
	pc = 0x8323A194; continue 'dispatch;
	}
	// 8323A190: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323A194: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8323A198: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8323A19C: 409A0030  bne cr6, 0x8323a1cc
	if !ctx.cr[6].eq {
	pc = 0x8323A1CC; continue 'dispatch;
	}
	// 8323A1A0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8323A1A4: 419A0018  beq cr6, 0x8323a1bc
	if ctx.cr[6].eq {
	pc = 0x8323A1BC; continue 'dispatch;
	}
	// 8323A1A8: C01B0014  lfs f0, 0x14(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323A1AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323A1B0: D01D0014  stfs f0, 0x14(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8323A1B4: 4B0C5F75  bl 0x82300128
	ctx.lr = 0x8323A1B8;
	sub_82300128(ctx, base);
	// 8323A1B8: 4BFFFA50  b 0x83239c08
	pc = 0x83239C08; continue 'dispatch;
	// 8323A1BC: D3FD0014  stfs f31, 0x14(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8323A1C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323A1C4: 4B0C5F65  bl 0x82300128
	ctx.lr = 0x8323A1C8;
	sub_82300128(ctx, base);
	// 8323A1C8: 4BFFFA40  b 0x83239c08
	pc = 0x83239C08; continue 'dispatch;
	// 8323A1CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323A1D0: 409A0008  bne cr6, 0x8323a1d8
	if !ctx.cr[6].eq {
	pc = 0x8323A1D8; continue 'dispatch;
	}
	// 8323A1D4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323A1D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323A1DC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8323A1E0: 409A0008  bne cr6, 0x8323a1e8
	if !ctx.cr[6].eq {
	pc = 0x8323A1E8; continue 'dispatch;
	}
	// 8323A1E4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323A1E8: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323A1EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323A1F0: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323A1F4: D01D0014  stfs f0, 0x14(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8323A1F8: 4B0C5F31  bl 0x82300128
	ctx.lr = 0x8323A1FC;
	sub_82300128(ctx, base);
	// 8323A1FC: 4BFFFA0C  b 0x83239c08
	pc = 0x83239C08; continue 'dispatch;
	// 8323A200: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8323A204: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323A208: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323A20C: 419A000C  beq cr6, 0x8323a218
	if ctx.cr[6].eq {
	pc = 0x8323A218; continue 'dispatch;
	}
	// 8323A210: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8323A214: 419A0008  beq cr6, 0x8323a21c
	if ctx.cr[6].eq {
	pc = 0x8323A21C; continue 'dispatch;
	}
	// 8323A218: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323A21C: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8323A220: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8323A224: 409A0030  bne cr6, 0x8323a254
	if !ctx.cr[6].eq {
	pc = 0x8323A254; continue 'dispatch;
	}
	// 8323A228: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8323A22C: 419A0018  beq cr6, 0x8323a244
	if ctx.cr[6].eq {
	pc = 0x8323A244; continue 'dispatch;
	}
	// 8323A230: 817B002C  lwz r11, 0x2c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(44 as u32) ) } as u64;
	// 8323A234: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323A238: 917D002C  stw r11, 0x2c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 8323A23C: 4B0C5EED  bl 0x82300128
	ctx.lr = 0x8323A240;
	sub_82300128(ctx, base);
	// 8323A240: 4BFFF9C8  b 0x83239c08
	pc = 0x83239C08; continue 'dispatch;
	// 8323A244: 933D002C  stw r25, 0x2c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(44 as u32), ctx.r[25].u32 ) };
	// 8323A248: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323A24C: 4B0C5EDD  bl 0x82300128
	ctx.lr = 0x8323A250;
	sub_82300128(ctx, base);
	// 8323A250: 4BFFF9B8  b 0x83239c08
	pc = 0x83239C08; continue 'dispatch;
	// 8323A254: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323A258: 409A0008  bne cr6, 0x8323a260
	if !ctx.cr[6].eq {
	pc = 0x8323A260; continue 'dispatch;
	}
	// 8323A25C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323A260: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323A264: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8323A268: 409A0008  bne cr6, 0x8323a270
	if !ctx.cr[6].eq {
	pc = 0x8323A270; continue 'dispatch;
	}
	// 8323A26C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323A270: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323A274: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323A278: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323A27C: 915D002C  stw r10, 0x2c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 8323A280: 4B0C5EA9  bl 0x82300128
	ctx.lr = 0x8323A284;
	sub_82300128(ctx, base);
	// 8323A284: 4BFFF984  b 0x83239c08
	pc = 0x83239C08; continue 'dispatch;
	// 8323A288: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8323A28C: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323A290: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323A294: 419A000C  beq cr6, 0x8323a2a0
	if ctx.cr[6].eq {
	pc = 0x8323A2A0; continue 'dispatch;
	}
	// 8323A298: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8323A29C: 419A0008  beq cr6, 0x8323a2a4
	if ctx.cr[6].eq {
	pc = 0x8323A2A4; continue 'dispatch;
	}
	// 8323A2A0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323A2A4: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8323A2A8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8323A2AC: 409A0030  bne cr6, 0x8323a2dc
	if !ctx.cr[6].eq {
	pc = 0x8323A2DC; continue 'dispatch;
	}
	// 8323A2B0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8323A2B4: 419A0018  beq cr6, 0x8323a2cc
	if ctx.cr[6].eq {
	pc = 0x8323A2CC; continue 'dispatch;
	}
	// 8323A2B8: 817B0020  lwz r11, 0x20(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 8323A2BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323A2C0: 917D0020  stw r11, 0x20(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 8323A2C4: 4B0C5E65  bl 0x82300128
	ctx.lr = 0x8323A2C8;
	sub_82300128(ctx, base);
	// 8323A2C8: 4BFFF940  b 0x83239c08
	pc = 0x83239C08; continue 'dispatch;
	// 8323A2CC: 925D0020  stw r18, 0x20(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), ctx.r[18].u32 ) };
	// 8323A2D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323A2D4: 4B0C5E55  bl 0x82300128
	ctx.lr = 0x8323A2D8;
	sub_82300128(ctx, base);
	// 8323A2D8: 4BFFF930  b 0x83239c08
	pc = 0x83239C08; continue 'dispatch;
	// 8323A2DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323A2E0: 409A0008  bne cr6, 0x8323a2e8
	if !ctx.cr[6].eq {
	pc = 0x8323A2E8; continue 'dispatch;
	}
	// 8323A2E4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323A2E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323A2EC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8323A2F0: 409A0008  bne cr6, 0x8323a2f8
	if !ctx.cr[6].eq {
	pc = 0x8323A2F8; continue 'dispatch;
	}
	// 8323A2F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323A2F8: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323A2FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323A300: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323A304: 915D0020  stw r10, 0x20(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 8323A308: 4B0C5E21  bl 0x82300128
	ctx.lr = 0x8323A30C;
	sub_82300128(ctx, base);
	// 8323A30C: 4BFFF8FC  b 0x83239c08
	pc = 0x83239C08; continue 'dispatch;
	// 8323A310: 2B1F8000  cmplwi cr6, r31, 0x8000
	ctx.cr[6].compare_u32(ctx.r[31].u32, 32768 as u32, &mut ctx.xer);
	// 8323A314: 409A0080  bne cr6, 0x8323a394
	if !ctx.cr[6].eq {
	pc = 0x8323A394; continue 'dispatch;
	}
	// 8323A318: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8323A31C: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323A320: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323A324: 419A000C  beq cr6, 0x8323a330
	if ctx.cr[6].eq {
	pc = 0x8323A330; continue 'dispatch;
	}
	// 8323A328: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8323A32C: 419A0008  beq cr6, 0x8323a334
	if ctx.cr[6].eq {
	pc = 0x8323A334; continue 'dispatch;
	}
	// 8323A330: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323A334: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8323A338: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8323A33C: 409A0030  bne cr6, 0x8323a36c
	if !ctx.cr[6].eq {
	pc = 0x8323A36C; continue 'dispatch;
	}
	// 8323A340: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8323A344: 419A0018  beq cr6, 0x8323a35c
	if ctx.cr[6].eq {
	pc = 0x8323A35C; continue 'dispatch;
	}
	// 8323A348: C01B0018  lfs f0, 0x18(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323A34C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323A350: D01D0018  stfs f0, 0x18(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8323A354: 4B0C5DD5  bl 0x82300128
	ctx.lr = 0x8323A358;
	sub_82300128(ctx, base);
	// 8323A358: 4BFFF8B0  b 0x83239c08
	pc = 0x83239C08; continue 'dispatch;
	// 8323A35C: D3FD0018  stfs f31, 0x18(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8323A360: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323A364: 4B0C5DC5  bl 0x82300128
	ctx.lr = 0x8323A368;
	sub_82300128(ctx, base);
	// 8323A368: 4BFFF8A0  b 0x83239c08
	pc = 0x83239C08; continue 'dispatch;
	// 8323A36C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323A370: 409A0008  bne cr6, 0x8323a378
	if !ctx.cr[6].eq {
	pc = 0x8323A378; continue 'dispatch;
	}
	// 8323A374: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323A378: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323A37C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8323A380: 409A0008  bne cr6, 0x8323a388
	if !ctx.cr[6].eq {
	pc = 0x8323A388; continue 'dispatch;
	}
	// 8323A384: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323A388: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323A38C: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323A390: D01D0018  stfs f0, 0x18(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), tmp.u32 ) };
            }
            0x8323A394 => {
    //   block [0x8323A394..0x8323A3A0)
	// 8323A394: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323A398: 4B0C5D91  bl 0x82300128
	ctx.lr = 0x8323A39C;
	sub_82300128(ctx, base);
	// 8323A39C: 4BFFF86C  b 0x83239c08
	pc = 0x83239C08; continue 'dispatch;
            }
            0x8323A3A0 => {
    //   block [0x8323A3A0..0x8323A3B4)
	// 8323A3A0: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 8323A3A4: CBA1FF70  lfd f29, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 8323A3A8: CBC1FF78  lfd f30, -0x88(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 8323A3AC: CBE1FF80  lfd f31, -0x80(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 8323A3B0: 4BA6F080  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323A3B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8323A3B8 size=2260
    let mut pc: u32 = 0x8323A3B8;
    'dispatch: loop {
        match pc {
            0x8323A3B8 => {
    //   block [0x8323A3B8..0x8323A41C)
	// 8323A3B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323A3BC: 4BA6F025  bl 0x82ca93e0
	ctx.lr = 0x8323A3C0;
	sub_82CA93D0(ctx, base);
	// 8323A3C0: DBA1FF70  stfd f29, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[29].u64 ) };
	// 8323A3C4: DBC1FF78  stfd f30, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[30].u64 ) };
	// 8323A3C8: DBE1FF80  stfd f31, -0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[31].u64 ) };
	// 8323A3CC: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323A3D0: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 8323A3D4: FFA00890  fmr f29, f1
	ctx.f[29].f64 = ctx.f[1].f64;
	// 8323A3D8: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 8323A3DC: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 8323A3E0: 3AEB3914  addi r23, r11, 0x3914
	ctx.r[23].s64 = ctx.r[11].s64 + 14612;
	// 8323A3E4: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 8323A3E8: 816A3920  lwz r11, 0x3920(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(14624 as u32) ) } as u64;
	// 8323A3EC: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 8323A3F0: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 8323A3F4: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 8323A3F8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8323A3FC: 409A0020  bne cr6, 0x8323a41c
	if !ctx.cr[6].eq {
	pc = 0x8323A41C; continue 'dispatch;
	}
	// 8323A400: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 8323A404: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 8323A408: 916A3920  stw r11, 0x3920(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(14624 as u32), ctx.r[11].u32 ) };
	// 8323A40C: 4B7DE535  bl 0x82a18940
	ctx.lr = 0x8323A410;
	sub_82A18940(ctx, base);
	// 8323A410: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8323A414: 386B2848  addi r3, r11, 0x2848
	ctx.r[3].s64 = ctx.r[11].s64 + 10312;
	// 8323A418: 4BA6FB09  bl 0x82ca9f20
	ctx.lr = 0x8323A41C;
	sub_82CA9F20(ctx, base);
	pc = 0x8323A41C; continue 'dispatch;
            }
            0x8323A41C => {
    //   block [0x8323A41C..0x8323A434)
	// 8323A41C: 81770008  lwz r11, 8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323A420: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 8323A424: 3A400001  li r18, 1
	ctx.r[18].s64 = 1;
	// 8323A428: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323A42C: 409A0040  bne cr6, 0x8323a46c
	if !ctx.cr[6].eq {
	pc = 0x8323A46C; continue 'dispatch;
	}
	// 8323A430: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	pc = 0x8323A434; continue 'dispatch;
            }
            0x8323A434 => {
    //   block [0x8323A434..0x8323A460)
	// 8323A434: 3D800002  lis r12, 2
	ctx.r[12].s64 = 131072;
	// 8323A438: 7E4BF830  slw r11, r18, r31
	if (ctx.r[31].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[18].u32) << ((ctx.r[31].u8 & 0x1F) as u32)) as u64;
	}
	// 8323A43C: 618C8DCE  ori r12, r12, 0x8dce
	ctx.r[12].u64 = ctx.r[12].u64 | 36302;
	// 8323A440: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8323A444: 7D6A6038  and r10, r11, r12
	ctx.r[10].u64 = ctx.r[11].u64 & ctx.r[12].u64;
	// 8323A448: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323A44C: 419A0014  beq cr6, 0x8323a460
	if ctx.cr[6].eq {
	pc = 0x8323A460; continue 'dispatch;
	}
	// 8323A450: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 8323A454: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8323A458: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8323A45C: 4B239445  bl 0x824738a0
	ctx.lr = 0x8323A460;
	sub_824738A0(ctx, base);
	pc = 0x8323A460; continue 'dispatch;
            }
            0x8323A460 => {
    //   block [0x8323A460..0x8323A46C)
	// 8323A460: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 8323A464: 2F1F0012  cmpwi cr6, r31, 0x12
	ctx.cr[6].compare_i32(ctx.r[31].s32, 18, &mut ctx.xer);
	// 8323A468: 4099FFCC  ble cr6, 0x8323a434
	if !ctx.cr[6].gt {
	pc = 0x8323A434; continue 'dispatch;
	}
	pc = 0x8323A46C; continue 'dispatch;
            }
            0x8323A46C => {
    //   block [0x8323A46C..0x8323A49C)
	// 8323A46C: 82B70004  lwz r21, 4(r23)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323A470: 81780018  lwz r11, 0x18(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(24 as u32) ) } as u64;
	// 8323A474: 81580014  lwz r10, 0x14(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323A478: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 8323A47C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323A480: 81350000  lwz r9, 0(r21)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323A484: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8323A488: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 8323A48C: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 8323A490: E9010060  ld r8, 0x60(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8323A494: F9010060  std r8, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u64 ) };
	// 8323A498: 419A0020  beq cr6, 0x8323a4b8
	if ctx.cr[6].eq {
	pc = 0x8323A4B8; continue 'dispatch;
	}
	pc = 0x8323A49C; continue 'dispatch;
            }
            0x8323A49C => {
    //   block [0x8323A49C..0x8323A4B8)
	// 8323A49C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 8323A4A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323A4A4: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 8323A4A8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8323A4AC: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8323A4B0: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323A4B4: 4082FFE8  bne 0x8323a49c
	if !ctx.cr[0].eq {
	pc = 0x8323A49C; continue 'dispatch;
	}
	pc = 0x8323A4B8; continue 'dispatch;
            }
            0x8323A4B8 => {
    //   block [0x8323A4B8..0x8323A4E0)
	// 8323A4B8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8323A4BC: 3B8A000C  addi r28, r10, 0xc
	ctx.r[28].s64 = ctx.r[10].s64 + 12;
	// 8323A4C0: 4AF7D659  bl 0x821b7b18
	ctx.lr = 0x8323A4C4;
	sub_821B7B18(ctx, base);
	// 8323A4C4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8323A4C8: 3A800010  li r20, 0x10
	ctx.r[20].s64 = 16;
	// 8323A4CC: 394B9484  addi r10, r11, -0x6b7c
	ctx.r[10].s64 = ctx.r[11].s64 + -27516;
	// 8323A4D0: 3B400018  li r26, 0x18
	ctx.r[26].s64 = 24;
	// 8323A4D4: 3A600005  li r19, 5
	ctx.r[19].s64 = 5;
	// 8323A4D8: C3CB9484  lfs f30, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8323A4DC: C3EA000C  lfs f31, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x8323A4E0; continue 'dispatch;
            }
            0x8323A4E0 => {
    //   block [0x8323A4E0..0x8323A4F4)
	// 8323A4E0: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8323A4E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323A4E8: 419A000C  beq cr6, 0x8323a4f4
	if ctx.cr[6].eq {
	pc = 0x8323A4F4; continue 'dispatch;
	}
	// 8323A4EC: 7F0AB840  cmplw cr6, r10, r23
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[23].u32, &mut ctx.xer);
	// 8323A4F0: 419A0008  beq cr6, 0x8323a4f8
	if ctx.cr[6].eq {
	pc = 0x8323A4F8; continue 'dispatch;
	}
	pc = 0x8323A4F4; continue 'dispatch;
            }
            0x8323A4F4 => {
    //   block [0x8323A4F4..0x8323A4F8)
	// 8323A4F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8323A4F8; continue 'dispatch;
            }
            0x8323A4F8 => {
    //   block [0x8323A4F8..0x8323A510)
	// 8323A4F8: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8323A4FC: 7F0BA840  cmplw cr6, r11, r21
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[21].u32, &mut ctx.xer);
	// 8323A500: 419A0778  beq cr6, 0x8323ac78
	if ctx.cr[6].eq {
	pc = 0x8323AC78; continue 'dispatch;
	}
	// 8323A504: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323A508: 409A0008  bne cr6, 0x8323a510
	if !ctx.cr[6].eq {
	pc = 0x8323A510; continue 'dispatch;
	}
	// 8323A50C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8323A510; continue 'dispatch;
            }
            0x8323A510 => {
    //   block [0x8323A510..0x8323A520)
	// 8323A510: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323A514: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8323A518: 409A0008  bne cr6, 0x8323a520
	if !ctx.cr[6].eq {
	pc = 0x8323A520; continue 'dispatch;
	}
	// 8323A51C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8323A520; continue 'dispatch;
            }
            0x8323A520 => {
    //   block [0x8323A520..0x8323A664)
	// 8323A520: 83EB000C  lwz r31, 0xc(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323A524: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8323A528: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8323A52C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8323A530: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8323A534: 4B7DD2A5  bl 0x82a177d8
	ctx.lr = 0x8323A538;
	sub_82A177D8(ctx, base);
	// 8323A538: 2F1F0080  cmpwi cr6, r31, 0x80
	ctx.cr[6].compare_i32(ctx.r[31].s32, 128, &mut ctx.xer);
	// 8323A53C: 419904F8  bgt cr6, 0x8323aa34
	if ctx.cr[6].gt {
	pc = 0x8323AA34; continue 'dispatch;
	}
	// 8323A540: 419A046C  beq cr6, 0x8323a9ac
	if ctx.cr[6].eq {
	pc = 0x8323A9AC; continue 'dispatch;
	}
	// 8323A544: 397FFFFE  addi r11, r31, -2
	ctx.r[11].s64 = ctx.r[31].s64 + -2;
	// 8323A548: 2B0B003E  cmplwi cr6, r11, 0x3e
	ctx.cr[6].compare_u32(ctx.r[11].u32, 62 as u32, &mut ctx.xer);
	// 8323A54C: 41990720  bgt cr6, 0x8323ac6c
	if ctx.cr[6].gt {
	pc = 0x8323AC6C; continue 'dispatch;
	}
	// 8323A550: 3D808324  lis r12, -0x7cdc
	ctx.r[12].s64 = -2094792704;
	// 8323A554: 398CA568  addi r12, r12, -0x5a98
	ctx.r[12].s64 = ctx.r[12].s64 + -23192;
	// 8323A558: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 8323A55C: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 8323A560: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 8323A564: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x8323A664; continue 'dispatch;
		},
		1 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		2 => {
	pc = 0x8323A6EC; continue 'dispatch;
		},
		3 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		4 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		5 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		6 => {
	pc = 0x8323A7CC; continue 'dispatch;
		},
		7 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		8 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		9 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		10 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		11 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		12 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		13 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		14 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		15 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		16 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		17 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		18 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		19 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		20 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		21 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		22 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		23 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		24 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		25 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		26 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		27 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		28 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		29 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		30 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		31 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		32 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		33 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		34 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		35 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		36 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		37 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		38 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		39 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		40 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		41 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		42 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		43 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		44 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		45 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		46 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		47 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		48 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		49 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		50 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		51 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		52 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		53 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		54 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		55 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		56 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		57 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		58 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		59 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		60 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		61 => {
	pc = 0x8323AC6C; continue 'dispatch;
		},
		62 => {
	pc = 0x8323A924; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 8323A568: 8323A664  lwz r25, -0x599c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-22940 as u32) ) } as u64;
	// 8323A56C: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A570: 8323A6EC  lwz r25, -0x5914(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-22804 as u32) ) } as u64;
	// 8323A574: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A578: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A57C: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A580: 8323A7CC  lwz r25, -0x5834(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-22580 as u32) ) } as u64;
	// 8323A584: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A588: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A58C: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A590: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A594: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A598: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A59C: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A5A0: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A5A4: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A5A8: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A5AC: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A5B0: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A5B4: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A5B8: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A5BC: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A5C0: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A5C4: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A5C8: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A5CC: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A5D0: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A5D4: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A5D8: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A5DC: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A5E0: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A5E4: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A5E8: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A5EC: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A5F0: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A5F4: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A5F8: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A5FC: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A600: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A604: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A608: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A60C: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A610: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A614: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A618: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A61C: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A620: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A624: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A628: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A62C: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A630: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A634: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A638: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A63C: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A640: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A644: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A648: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A64C: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A650: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A654: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A658: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A65C: 8323AC6C  lwz r25, -0x5394(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-21396 as u32) ) } as u64;
	// 8323A660: 8323A924  lwz r25, -0x56dc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-22236 as u32) ) } as u64;
            }
            0x8323A664 => {
    //   block [0x8323A664..0x8323A67C)
	// 8323A664: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8323A668: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323A66C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323A670: 419A000C  beq cr6, 0x8323a67c
	if ctx.cr[6].eq {
	pc = 0x8323A67C; continue 'dispatch;
	}
	// 8323A674: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8323A678: 419A0008  beq cr6, 0x8323a680
	if ctx.cr[6].eq {
	pc = 0x8323A680; continue 'dispatch;
	}
	pc = 0x8323A67C; continue 'dispatch;
            }
            0x8323A67C => {
    //   block [0x8323A67C..0x8323A680)
	// 8323A67C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8323A680; continue 'dispatch;
            }
            0x8323A680 => {
    //   block [0x8323A680..0x8323A6A8)
	// 8323A680: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8323A684: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8323A688: 409A0030  bne cr6, 0x8323a6b8
	if !ctx.cr[6].eq {
	pc = 0x8323A6B8; continue 'dispatch;
	}
	// 8323A68C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8323A690: 419A0018  beq cr6, 0x8323a6a8
	if ctx.cr[6].eq {
	pc = 0x8323A6A8; continue 'dispatch;
	}
	// 8323A694: C01B0010  lfs f0, 0x10(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323A698: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323A69C: D01D0010  stfs f0, 0x10(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8323A6A0: 4B0C5A89  bl 0x82300128
	ctx.lr = 0x8323A6A4;
	sub_82300128(ctx, base);
	// 8323A6A4: 4BFFFE3C  b 0x8323a4e0
	pc = 0x8323A4E0; continue 'dispatch;
            }
            0x8323A6A8 => {
    //   block [0x8323A6A8..0x8323A6B8)
	// 8323A6A8: D3FD0010  stfs f31, 0x10(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8323A6AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323A6B0: 4B0C5A79  bl 0x82300128
	ctx.lr = 0x8323A6B4;
	sub_82300128(ctx, base);
	// 8323A6B4: 4BFFFE2C  b 0x8323a4e0
	pc = 0x8323A4E0; continue 'dispatch;
            }
            0x8323A6B8 => {
    //   block [0x8323A6B8..0x8323A6C4)
	// 8323A6B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323A6BC: 409A0008  bne cr6, 0x8323a6c4
	if !ctx.cr[6].eq {
	pc = 0x8323A6C4; continue 'dispatch;
	}
	// 8323A6C0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8323A6C4; continue 'dispatch;
            }
            0x8323A6C4 => {
    //   block [0x8323A6C4..0x8323A6D4)
	// 8323A6C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323A6C8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8323A6CC: 409A0008  bne cr6, 0x8323a6d4
	if !ctx.cr[6].eq {
	pc = 0x8323A6D4; continue 'dispatch;
	}
	// 8323A6D0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8323A6D4; continue 'dispatch;
            }
            0x8323A6D4 => {
    //   block [0x8323A6D4..0x8323A6EC)
	// 8323A6D4: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323A6D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323A6DC: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323A6E0: D01D0010  stfs f0, 0x10(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8323A6E4: 4B0C5A45  bl 0x82300128
	ctx.lr = 0x8323A6E8;
	sub_82300128(ctx, base);
	// 8323A6E8: 4BFFFDF8  b 0x8323a4e0
	pc = 0x8323A4E0; continue 'dispatch;
            }
            0x8323A6EC => {
    //   block [0x8323A6EC..0x8323A704)
	// 8323A6EC: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8323A6F0: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323A6F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323A6F8: 419A000C  beq cr6, 0x8323a704
	if ctx.cr[6].eq {
	pc = 0x8323A704; continue 'dispatch;
	}
	// 8323A6FC: 7F0AE040  cmplw cr6, r10, r28
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8323A700: 419A0008  beq cr6, 0x8323a708
	if ctx.cr[6].eq {
	pc = 0x8323A708; continue 'dispatch;
	}
	pc = 0x8323A704; continue 'dispatch;
            }
            0x8323A704 => {
    //   block [0x8323A704..0x8323A708)
	// 8323A704: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8323A708; continue 'dispatch;
            }
            0x8323A708 => {
    //   block [0x8323A708..0x8323A740)
	// 8323A708: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8323A70C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8323A710: 409A006C  bne cr6, 0x8323a77c
	if !ctx.cr[6].eq {
	pc = 0x8323A77C; continue 'dispatch;
	}
	// 8323A714: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8323A718: 419A0028  beq cr6, 0x8323a740
	if ctx.cr[6].eq {
	pc = 0x8323A740; continue 'dispatch;
	}
	// 8323A71C: C01B0004  lfs f0, 4(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323A720: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323A724: D01D0004  stfs f0, 4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8323A728: C1BB0008  lfs f13, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8323A72C: D1BD0008  stfs f13, 8(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8323A730: C19B000C  lfs f12, 0xc(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8323A734: D19D000C  stfs f12, 0xc(r29)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8323A738: 4B0C59F1  bl 0x82300128
	ctx.lr = 0x8323A73C;
	sub_82300128(ctx, base);
	// 8323A73C: 4BFFFDA4  b 0x8323a4e0
	pc = 0x8323A4E0; continue 'dispatch;
            }
            0x8323A740 => {
    //   block [0x8323A740..0x8323A77C)
	// 8323A740: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8323A744: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8323A748: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 8323A74C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	pc = 0x8323A77C; continue 'dispatch;
            }
            0x8323A77C => {
    //   block [0x8323A77C..0x8323A7CC)
	// 8323A77C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323A780: 409A0008  bne cr6, 0x8323a788
	if !ctx.cr[6].eq {
	pc = 0x8323A788; continue 'dispatch;
	}
	// 8323A784: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323A788: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323A78C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8323A790: 409A0008  bne cr6, 0x8323a798
	if !ctx.cr[6].eq {
	pc = 0x8323A798; continue 'dispatch;
	}
	// 8323A794: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323A798: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323A79C: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 8323A7A0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	pc = 0x8323A7CC; continue 'dispatch;
            }
            0x8323A7CC => {
    //   block [0x8323A7CC..0x8323A924)
	// 8323A7CC: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8323A7D0: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323A7D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323A7D8: 419A000C  beq cr6, 0x8323a7e4
	if ctx.cr[6].eq {
	pc = 0x8323A7E4; continue 'dispatch;
	}
	// 8323A7DC: 7F0AE040  cmplw cr6, r10, r28
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8323A7E0: 419A0008  beq cr6, 0x8323a7e8
	if ctx.cr[6].eq {
	pc = 0x8323A7E8; continue 'dispatch;
	}
	// 8323A7E4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323A7E8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8323A7EC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8323A7F0: 409A0048  bne cr6, 0x8323a838
	if !ctx.cr[6].eq {
	pc = 0x8323A838; continue 'dispatch;
	}
	// 8323A7F4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8323A7F8: 419A0028  beq cr6, 0x8323a820
	if ctx.cr[6].eq {
	pc = 0x8323A820; continue 'dispatch;
	}
	// 8323A7FC: 897B0050  lbz r11, 0x50(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(80 as u32) ) } as u64;
	// 8323A800: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323A804: 997D0050  stb r11, 0x50(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 8323A808: C01B0054  lfs f0, 0x54(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323A80C: D01D0054  stfs f0, 0x54(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8323A810: 895B0034  lbz r10, 0x34(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(52 as u32) ) } as u64;
	// 8323A814: 995D0034  stb r10, 0x34(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(52 as u32), ctx.r[10].u8 ) };
	// 8323A818: 4B0C5911  bl 0x82300128
	ctx.lr = 0x8323A81C;
	sub_82300128(ctx, base);
	// 8323A81C: 4BFFFCC4  b 0x8323a4e0
	pc = 0x8323A4E0; continue 'dispatch;
	// 8323A820: D3DD0054  stfs f30, 0x54(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8323A824: 9B3D0050  stb r25, 0x50(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(80 as u32), ctx.r[25].u8 ) };
	// 8323A828: 9B3D0034  stb r25, 0x34(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(52 as u32), ctx.r[25].u8 ) };
	// 8323A82C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323A830: 4B0C58F9  bl 0x82300128
	ctx.lr = 0x8323A834;
	sub_82300128(ctx, base);
	// 8323A834: 4BFFFCAC  b 0x8323a4e0
	pc = 0x8323A4E0; continue 'dispatch;
	// 8323A838: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323A83C: 409A0008  bne cr6, 0x8323a844
	if !ctx.cr[6].eq {
	pc = 0x8323A844; continue 'dispatch;
	}
	// 8323A840: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323A844: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323A848: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8323A84C: 409A0008  bne cr6, 0x8323a854
	if !ctx.cr[6].eq {
	pc = 0x8323A854; continue 'dispatch;
	}
	// 8323A850: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323A854: 81580004  lwz r10, 4(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323A858: D3C100A8  stfs f30, 0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8323A85C: 83EB0010  lwz r31, 0x10(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323A860: 3BD60020  addi r30, r22, 0x20
	ctx.r[30].s64 = ctx.r[22].s64 + 32;
	// 8323A864: 7D4907B4  extsw r9, r10
	ctx.r[9].s64 = ctx.r[10].s32 as i64;
	// 8323A868: 80F60024  lwz r7, 0x24(r22)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(36 as u32) ) } as u64;
	// 8323A86C: 81160028  lwz r8, 0x28(r22)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(40 as u32) ) } as u64;
	// 8323A870: F9210068  std r9, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u64 ) };
	// 8323A874: 7CC74050  subf r6, r7, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 8323A878: 9B2100B4  stb r25, 0xb4(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[25].u8 ) };
	// 8323A87C: 80BF0014  lwz r5, 0x14(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323A880: C01F0020  lfs f0, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323A884: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8323A888: D00100AC  stfs f0, 0xac(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 8323A88C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323A890: 7C66D3D7  divw. r3, r6, r26
	ctx.r[3].s32 = ctx.r[6].s32 / ctx.r[26].s32;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 8323A894: C9A10068  lfd f13, 0x68(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 8323A898: 893F001C  lbz r9, 0x1c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8323A89C: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 8323A8A0: 88FF0024  lbz r7, 0x24(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 8323A8A4: 98A100B0  stb r5, 0xb0(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[5].u8 ) };
	// 8323A8A8: 988100B1  stb r4, 0xb1(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(177 as u32), ctx.r[4].u8 ) };
	// 8323A8AC: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 8323A8B0: 992100B2  stb r9, 0xb2(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(178 as u32), ctx.r[9].u8 ) };
	// 8323A8B4: 98E100B3  stb r7, 0xb3(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(179 as u32), ctx.r[7].u8 ) };
	// 8323A8B8: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8323A8BC: ED4BE824  fdivs f10, f11, f29
	ctx.f[10].f64 = ((ctx.f[11].f64 / ctx.f[29].f64) as f32) as f64;
	// 8323A8C0: D14100A4  stfs f10, 0xa4(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 8323A8C4: 41820020  beq 0x8323a8e4
	if ctx.cr[0].eq {
	pc = 0x8323A8E4; continue 'dispatch;
	}
	// 8323A8C8: 550B003E  slwi r11, r8, 0
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8323A8CC: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 8323A8D0: 386BFFE8  addi r3, r11, -0x18
	ctx.r[3].s64 = ctx.r[11].s64 + -24;
	// 8323A8D4: 4B7DDE9D  bl 0x82a18770
	ctx.lr = 0x8323A8D8;
	sub_82A18770(ctx, base);
	// 8323A8D8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8323A8DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323A8E0: 419A0010  beq cr6, 0x8323a8f0
	if ctx.cr[6].eq {
	pc = 0x8323A8F0; continue 'dispatch;
	}
	// 8323A8E4: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 8323A8E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323A8EC: 4B7DDF7D  bl 0x82a18868
	ctx.lr = 0x8323A8F0;
	sub_82A18868(ctx, base);
	// 8323A8F0: 897F001C  lbz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8323A8F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323A8F8: 997D0050  stb r11, 0x50(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 8323A8FC: C01F0020  lfs f0, 0x20(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323A900: D01D0054  stfs f0, 0x54(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8323A904: 895F0024  lbz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 8323A908: 995D0034  stb r10, 0x34(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(52 as u32), ctx.r[10].u8 ) };
	// 8323A90C: 893F0025  lbz r9, 0x25(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(37 as u32) ) } as u64;
	// 8323A910: 993D0035  stb r9, 0x35(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(53 as u32), ctx.r[9].u8 ) };
	// 8323A914: C1BF0028  lfs f13, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8323A918: D1BD0030  stfs f13, 0x30(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8323A91C: 4B0C580D  bl 0x82300128
	ctx.lr = 0x8323A920;
	sub_82300128(ctx, base);
	// 8323A920: 4BFFFBC0  b 0x8323a4e0
	pc = 0x8323A4E0; continue 'dispatch;
            }
            0x8323A924 => {
    //   block [0x8323A924..0x8323A9AC)
	// 8323A924: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8323A928: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323A92C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323A930: 419A000C  beq cr6, 0x8323a93c
	if ctx.cr[6].eq {
	pc = 0x8323A93C; continue 'dispatch;
	}
	// 8323A934: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8323A938: 419A0008  beq cr6, 0x8323a940
	if ctx.cr[6].eq {
	pc = 0x8323A940; continue 'dispatch;
	}
	// 8323A93C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323A940: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8323A944: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8323A948: 409A0030  bne cr6, 0x8323a978
	if !ctx.cr[6].eq {
	pc = 0x8323A978; continue 'dispatch;
	}
	// 8323A94C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8323A950: 419A0018  beq cr6, 0x8323a968
	if ctx.cr[6].eq {
	pc = 0x8323A968; continue 'dispatch;
	}
	// 8323A954: 817B0024  lwz r11, 0x24(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(36 as u32) ) } as u64;
	// 8323A958: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323A95C: 917D0024  stw r11, 0x24(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 8323A960: 4B0C57C9  bl 0x82300128
	ctx.lr = 0x8323A964;
	sub_82300128(ctx, base);
	// 8323A964: 4BFFFB7C  b 0x8323a4e0
	pc = 0x8323A4E0; continue 'dispatch;
	// 8323A968: 925D0024  stw r18, 0x24(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[18].u32 ) };
	// 8323A96C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323A970: 4B0C57B9  bl 0x82300128
	ctx.lr = 0x8323A974;
	sub_82300128(ctx, base);
	// 8323A974: 4BFFFB6C  b 0x8323a4e0
	pc = 0x8323A4E0; continue 'dispatch;
	// 8323A978: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323A97C: 409A0008  bne cr6, 0x8323a984
	if !ctx.cr[6].eq {
	pc = 0x8323A984; continue 'dispatch;
	}
	// 8323A980: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323A984: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323A988: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8323A98C: 409A0008  bne cr6, 0x8323a994
	if !ctx.cr[6].eq {
	pc = 0x8323A994; continue 'dispatch;
	}
	// 8323A990: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323A994: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323A998: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323A99C: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323A9A0: 915D0024  stw r10, 0x24(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 8323A9A4: 4B0C5785  bl 0x82300128
	ctx.lr = 0x8323A9A8;
	sub_82300128(ctx, base);
	// 8323A9A8: 4BFFFB38  b 0x8323a4e0
	pc = 0x8323A4E0; continue 'dispatch;
            }
            0x8323A9AC => {
    //   block [0x8323A9AC..0x8323AA34)
	// 8323A9AC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8323A9B0: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323A9B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323A9B8: 419A000C  beq cr6, 0x8323a9c4
	if ctx.cr[6].eq {
	pc = 0x8323A9C4; continue 'dispatch;
	}
	// 8323A9BC: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8323A9C0: 419A0008  beq cr6, 0x8323a9c8
	if ctx.cr[6].eq {
	pc = 0x8323A9C8; continue 'dispatch;
	}
	// 8323A9C4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323A9C8: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8323A9CC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8323A9D0: 409A0030  bne cr6, 0x8323aa00
	if !ctx.cr[6].eq {
	pc = 0x8323AA00; continue 'dispatch;
	}
	// 8323A9D4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8323A9D8: 419A0018  beq cr6, 0x8323a9f0
	if ctx.cr[6].eq {
	pc = 0x8323A9F0; continue 'dispatch;
	}
	// 8323A9DC: 817B0028  lwz r11, 0x28(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 8323A9E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323A9E4: 917D0028  stw r11, 0x28(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 8323A9E8: 4B0C5741  bl 0x82300128
	ctx.lr = 0x8323A9EC;
	sub_82300128(ctx, base);
	// 8323A9EC: 4BFFFAF4  b 0x8323a4e0
	pc = 0x8323A4E0; continue 'dispatch;
	// 8323A9F0: 927D0028  stw r19, 0x28(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(40 as u32), ctx.r[19].u32 ) };
	// 8323A9F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323A9F8: 4B0C5731  bl 0x82300128
	ctx.lr = 0x8323A9FC;
	sub_82300128(ctx, base);
	// 8323A9FC: 4BFFFAE4  b 0x8323a4e0
	pc = 0x8323A4E0; continue 'dispatch;
	// 8323AA00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323AA04: 409A0008  bne cr6, 0x8323aa0c
	if !ctx.cr[6].eq {
	pc = 0x8323AA0C; continue 'dispatch;
	}
	// 8323AA08: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323AA0C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323AA10: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8323AA14: 409A0008  bne cr6, 0x8323aa1c
	if !ctx.cr[6].eq {
	pc = 0x8323AA1C; continue 'dispatch;
	}
	// 8323AA18: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323AA1C: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323AA20: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323AA24: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323AA28: 915D0028  stw r10, 0x28(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 8323AA2C: 4B0C56FD  bl 0x82300128
	ctx.lr = 0x8323AA30;
	sub_82300128(ctx, base);
	// 8323AA30: 4BFFFAB0  b 0x8323a4e0
	pc = 0x8323A4E0; continue 'dispatch;
            }
            0x8323AA34 => {
    //   block [0x8323AA34..0x8323AC6C)
	// 8323AA34: 2F1F0800  cmpwi cr6, r31, 0x800
	ctx.cr[6].compare_i32(ctx.r[31].s32, 2048, &mut ctx.xer);
	// 8323AA38: 419901B0  bgt cr6, 0x8323abe8
	if ctx.cr[6].gt {
	pc = 0x8323ABE8; continue 'dispatch;
	}
	// 8323AA3C: 419A0124  beq cr6, 0x8323ab60
	if ctx.cr[6].eq {
	pc = 0x8323AB60; continue 'dispatch;
	}
	// 8323AA40: 2F1F0100  cmpwi cr6, r31, 0x100
	ctx.cr[6].compare_i32(ctx.r[31].s32, 256, &mut ctx.xer);
	// 8323AA44: 419A0094  beq cr6, 0x8323aad8
	if ctx.cr[6].eq {
	pc = 0x8323AAD8; continue 'dispatch;
	}
	// 8323AA48: 2F1F0400  cmpwi cr6, r31, 0x400
	ctx.cr[6].compare_i32(ctx.r[31].s32, 1024, &mut ctx.xer);
	// 8323AA4C: 409A0220  bne cr6, 0x8323ac6c
	if !ctx.cr[6].eq {
	pc = 0x8323AC6C; continue 'dispatch;
	}
	// 8323AA50: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8323AA54: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323AA58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323AA5C: 419A000C  beq cr6, 0x8323aa68
	if ctx.cr[6].eq {
	pc = 0x8323AA68; continue 'dispatch;
	}
	// 8323AA60: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8323AA64: 419A0008  beq cr6, 0x8323aa6c
	if ctx.cr[6].eq {
	pc = 0x8323AA6C; continue 'dispatch;
	}
	// 8323AA68: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323AA6C: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8323AA70: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8323AA74: 409A0030  bne cr6, 0x8323aaa4
	if !ctx.cr[6].eq {
	pc = 0x8323AAA4; continue 'dispatch;
	}
	// 8323AA78: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8323AA7C: 419A0018  beq cr6, 0x8323aa94
	if ctx.cr[6].eq {
	pc = 0x8323AA94; continue 'dispatch;
	}
	// 8323AA80: C01B0014  lfs f0, 0x14(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323AA84: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323AA88: D01D0014  stfs f0, 0x14(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8323AA8C: 4B0C569D  bl 0x82300128
	ctx.lr = 0x8323AA90;
	sub_82300128(ctx, base);
	// 8323AA90: 4BFFFA50  b 0x8323a4e0
	pc = 0x8323A4E0; continue 'dispatch;
	// 8323AA94: D3FD0014  stfs f31, 0x14(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8323AA98: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323AA9C: 4B0C568D  bl 0x82300128
	ctx.lr = 0x8323AAA0;
	sub_82300128(ctx, base);
	// 8323AAA0: 4BFFFA40  b 0x8323a4e0
	pc = 0x8323A4E0; continue 'dispatch;
	// 8323AAA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323AAA8: 409A0008  bne cr6, 0x8323aab0
	if !ctx.cr[6].eq {
	pc = 0x8323AAB0; continue 'dispatch;
	}
	// 8323AAAC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323AAB0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323AAB4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8323AAB8: 409A0008  bne cr6, 0x8323aac0
	if !ctx.cr[6].eq {
	pc = 0x8323AAC0; continue 'dispatch;
	}
	// 8323AABC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323AAC0: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323AAC4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323AAC8: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323AACC: D01D0014  stfs f0, 0x14(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8323AAD0: 4B0C5659  bl 0x82300128
	ctx.lr = 0x8323AAD4;
	sub_82300128(ctx, base);
	// 8323AAD4: 4BFFFA0C  b 0x8323a4e0
	pc = 0x8323A4E0; continue 'dispatch;
	// 8323AAD8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8323AADC: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323AAE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323AAE4: 419A000C  beq cr6, 0x8323aaf0
	if ctx.cr[6].eq {
	pc = 0x8323AAF0; continue 'dispatch;
	}
	// 8323AAE8: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8323AAEC: 419A0008  beq cr6, 0x8323aaf4
	if ctx.cr[6].eq {
	pc = 0x8323AAF4; continue 'dispatch;
	}
	// 8323AAF0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323AAF4: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8323AAF8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8323AAFC: 409A0030  bne cr6, 0x8323ab2c
	if !ctx.cr[6].eq {
	pc = 0x8323AB2C; continue 'dispatch;
	}
	// 8323AB00: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8323AB04: 419A0018  beq cr6, 0x8323ab1c
	if ctx.cr[6].eq {
	pc = 0x8323AB1C; continue 'dispatch;
	}
	// 8323AB08: 817B002C  lwz r11, 0x2c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(44 as u32) ) } as u64;
	// 8323AB0C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323AB10: 917D002C  stw r11, 0x2c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 8323AB14: 4B0C5615  bl 0x82300128
	ctx.lr = 0x8323AB18;
	sub_82300128(ctx, base);
	// 8323AB18: 4BFFF9C8  b 0x8323a4e0
	pc = 0x8323A4E0; continue 'dispatch;
	// 8323AB1C: 933D002C  stw r25, 0x2c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(44 as u32), ctx.r[25].u32 ) };
	// 8323AB20: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323AB24: 4B0C5605  bl 0x82300128
	ctx.lr = 0x8323AB28;
	sub_82300128(ctx, base);
	// 8323AB28: 4BFFF9B8  b 0x8323a4e0
	pc = 0x8323A4E0; continue 'dispatch;
	// 8323AB2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323AB30: 409A0008  bne cr6, 0x8323ab38
	if !ctx.cr[6].eq {
	pc = 0x8323AB38; continue 'dispatch;
	}
	// 8323AB34: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323AB38: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323AB3C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8323AB40: 409A0008  bne cr6, 0x8323ab48
	if !ctx.cr[6].eq {
	pc = 0x8323AB48; continue 'dispatch;
	}
	// 8323AB44: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323AB48: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323AB4C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323AB50: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323AB54: 915D002C  stw r10, 0x2c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 8323AB58: 4B0C55D1  bl 0x82300128
	ctx.lr = 0x8323AB5C;
	sub_82300128(ctx, base);
	// 8323AB5C: 4BFFF984  b 0x8323a4e0
	pc = 0x8323A4E0; continue 'dispatch;
	// 8323AB60: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8323AB64: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323AB68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323AB6C: 419A000C  beq cr6, 0x8323ab78
	if ctx.cr[6].eq {
	pc = 0x8323AB78; continue 'dispatch;
	}
	// 8323AB70: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8323AB74: 419A0008  beq cr6, 0x8323ab7c
	if ctx.cr[6].eq {
	pc = 0x8323AB7C; continue 'dispatch;
	}
	// 8323AB78: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323AB7C: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8323AB80: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8323AB84: 409A0030  bne cr6, 0x8323abb4
	if !ctx.cr[6].eq {
	pc = 0x8323ABB4; continue 'dispatch;
	}
	// 8323AB88: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8323AB8C: 419A0018  beq cr6, 0x8323aba4
	if ctx.cr[6].eq {
	pc = 0x8323ABA4; continue 'dispatch;
	}
	// 8323AB90: 817B0020  lwz r11, 0x20(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 8323AB94: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323AB98: 917D0020  stw r11, 0x20(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 8323AB9C: 4B0C558D  bl 0x82300128
	ctx.lr = 0x8323ABA0;
	sub_82300128(ctx, base);
	// 8323ABA0: 4BFFF940  b 0x8323a4e0
	pc = 0x8323A4E0; continue 'dispatch;
	// 8323ABA4: 925D0020  stw r18, 0x20(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), ctx.r[18].u32 ) };
	// 8323ABA8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323ABAC: 4B0C557D  bl 0x82300128
	ctx.lr = 0x8323ABB0;
	sub_82300128(ctx, base);
	// 8323ABB0: 4BFFF930  b 0x8323a4e0
	pc = 0x8323A4E0; continue 'dispatch;
	// 8323ABB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323ABB8: 409A0008  bne cr6, 0x8323abc0
	if !ctx.cr[6].eq {
	pc = 0x8323ABC0; continue 'dispatch;
	}
	// 8323ABBC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323ABC0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323ABC4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8323ABC8: 409A0008  bne cr6, 0x8323abd0
	if !ctx.cr[6].eq {
	pc = 0x8323ABD0; continue 'dispatch;
	}
	// 8323ABCC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323ABD0: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323ABD4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323ABD8: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323ABDC: 915D0020  stw r10, 0x20(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 8323ABE0: 4B0C5549  bl 0x82300128
	ctx.lr = 0x8323ABE4;
	sub_82300128(ctx, base);
	// 8323ABE4: 4BFFF8FC  b 0x8323a4e0
	pc = 0x8323A4E0; continue 'dispatch;
	// 8323ABE8: 2B1F8000  cmplwi cr6, r31, 0x8000
	ctx.cr[6].compare_u32(ctx.r[31].u32, 32768 as u32, &mut ctx.xer);
	// 8323ABEC: 409A0080  bne cr6, 0x8323ac6c
	if !ctx.cr[6].eq {
	pc = 0x8323AC6C; continue 'dispatch;
	}
	// 8323ABF0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8323ABF4: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323ABF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323ABFC: 419A000C  beq cr6, 0x8323ac08
	if ctx.cr[6].eq {
	pc = 0x8323AC08; continue 'dispatch;
	}
	// 8323AC00: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8323AC04: 419A0008  beq cr6, 0x8323ac0c
	if ctx.cr[6].eq {
	pc = 0x8323AC0C; continue 'dispatch;
	}
	// 8323AC08: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323AC0C: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8323AC10: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8323AC14: 409A0030  bne cr6, 0x8323ac44
	if !ctx.cr[6].eq {
	pc = 0x8323AC44; continue 'dispatch;
	}
	// 8323AC18: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8323AC1C: 419A0018  beq cr6, 0x8323ac34
	if ctx.cr[6].eq {
	pc = 0x8323AC34; continue 'dispatch;
	}
	// 8323AC20: C01B0018  lfs f0, 0x18(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323AC24: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323AC28: D01D0018  stfs f0, 0x18(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8323AC2C: 4B0C54FD  bl 0x82300128
	ctx.lr = 0x8323AC30;
	sub_82300128(ctx, base);
	// 8323AC30: 4BFFF8B0  b 0x8323a4e0
	pc = 0x8323A4E0; continue 'dispatch;
	// 8323AC34: D3FD0018  stfs f31, 0x18(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8323AC38: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323AC3C: 4B0C54ED  bl 0x82300128
	ctx.lr = 0x8323AC40;
	sub_82300128(ctx, base);
	// 8323AC40: 4BFFF8A0  b 0x8323a4e0
	pc = 0x8323A4E0; continue 'dispatch;
	// 8323AC44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323AC48: 409A0008  bne cr6, 0x8323ac50
	if !ctx.cr[6].eq {
	pc = 0x8323AC50; continue 'dispatch;
	}
	// 8323AC4C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323AC50: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323AC54: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8323AC58: 409A0008  bne cr6, 0x8323ac60
	if !ctx.cr[6].eq {
	pc = 0x8323AC60; continue 'dispatch;
	}
	// 8323AC5C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323AC60: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323AC64: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323AC68: D01D0018  stfs f0, 0x18(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), tmp.u32 ) };
            }
            0x8323AC6C => {
    //   block [0x8323AC6C..0x8323AC78)
	// 8323AC6C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323AC70: 4B0C54B9  bl 0x82300128
	ctx.lr = 0x8323AC74;
	sub_82300128(ctx, base);
	// 8323AC74: 4BFFF86C  b 0x8323a4e0
	pc = 0x8323A4E0; continue 'dispatch;
            }
            0x8323AC78 => {
    //   block [0x8323AC78..0x8323AC8C)
	// 8323AC78: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 8323AC7C: CBA1FF70  lfd f29, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 8323AC80: CBC1FF78  lfd f30, -0x88(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 8323AC84: CBE1FF80  lfd f31, -0x80(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 8323AC88: 4BA6E7A8  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323AC90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8323AC90 size=3480
    let mut pc: u32 = 0x8323AC90;
    'dispatch: loop {
        match pc {
            0x8323AC90 => {
    //   block [0x8323AC90..0x8323ACF4)
	// 8323AC90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323AC94: 4BA6E73D  bl 0x82ca93d0
	ctx.lr = 0x8323AC98;
	sub_82CA93D0(ctx, base);
	// 8323AC98: DBA1FF50  stfd f29, -0xb0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-176 as u32), ctx.f[29].u64 ) };
	// 8323AC9C: DBC1FF58  stfd f30, -0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.f[30].u64 ) };
	// 8323ACA0: DBE1FF60  stfd f31, -0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 8323ACA4: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323ACA8: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 8323ACAC: FFA00890  fmr f29, f1
	ctx.f[29].f64 = ctx.f[1].f64;
	// 8323ACB0: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 8323ACB4: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 8323ACB8: 3A6B3924  addi r19, r11, 0x3924
	ctx.r[19].s64 = ctx.r[11].s64 + 14628;
	// 8323ACBC: 7CB42B78  mr r20, r5
	ctx.r[20].u64 = ctx.r[5].u64;
	// 8323ACC0: 816A3930  lwz r11, 0x3930(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(14640 as u32) ) } as u64;
	// 8323ACC4: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 8323ACC8: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 8323ACCC: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 8323ACD0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8323ACD4: 409A0020  bne cr6, 0x8323acf4
	if !ctx.cr[6].eq {
	pc = 0x8323ACF4; continue 'dispatch;
	}
	// 8323ACD8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 8323ACDC: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 8323ACE0: 916A3930  stw r11, 0x3930(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(14640 as u32), ctx.r[11].u32 ) };
	// 8323ACE4: 4B7DDC5D  bl 0x82a18940
	ctx.lr = 0x8323ACE8;
	sub_82A18940(ctx, base);
	// 8323ACE8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8323ACEC: 386B2838  addi r3, r11, 0x2838
	ctx.r[3].s64 = ctx.r[11].s64 + 10296;
	// 8323ACF0: 4BA6F231  bl 0x82ca9f20
	ctx.lr = 0x8323ACF4;
	sub_82CA9F20(ctx, base);
	pc = 0x8323ACF4; continue 'dispatch;
            }
            0x8323ACF4 => {
    //   block [0x8323ACF4..0x8323AD0C)
	// 8323ACF4: 81730008  lwz r11, 8(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323ACF8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 8323ACFC: 3AE00001  li r23, 1
	ctx.r[23].s64 = 1;
	// 8323AD00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323AD04: 409A0040  bne cr6, 0x8323ad44
	if !ctx.cr[6].eq {
	pc = 0x8323AD44; continue 'dispatch;
	}
	// 8323AD08: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	pc = 0x8323AD0C; continue 'dispatch;
            }
            0x8323AD0C => {
    //   block [0x8323AD0C..0x8323AD38)
	// 8323AD0C: 3D800003  lis r12, 3
	ctx.r[12].s64 = 196608;
	// 8323AD10: 7EEBF830  slw r11, r23, r31
	if (ctx.r[31].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[23].u32) << ((ctx.r[31].u8 & 0x1F) as u32)) as u64;
	}
	// 8323AD14: 618CA3FE  ori r12, r12, 0xa3fe
	ctx.r[12].u64 = ctx.r[12].u64 | 41982;
	// 8323AD18: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8323AD1C: 7D6A6038  and r10, r11, r12
	ctx.r[10].u64 = ctx.r[11].u64 & ctx.r[12].u64;
	// 8323AD20: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323AD24: 419A0014  beq cr6, 0x8323ad38
	if ctx.cr[6].eq {
	pc = 0x8323AD38; continue 'dispatch;
	}
	// 8323AD28: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 8323AD2C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8323AD30: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 8323AD34: 4B238B6D  bl 0x824738a0
	ctx.lr = 0x8323AD38;
	sub_824738A0(ctx, base);
	pc = 0x8323AD38; continue 'dispatch;
            }
            0x8323AD38 => {
    //   block [0x8323AD38..0x8323AD44)
	// 8323AD38: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 8323AD3C: 2F1F0012  cmpwi cr6, r31, 0x12
	ctx.cr[6].compare_i32(ctx.r[31].s32, 18, &mut ctx.xer);
	// 8323AD40: 4099FFCC  ble cr6, 0x8323ad0c
	if !ctx.cr[6].gt {
	pc = 0x8323AD0C; continue 'dispatch;
	}
	pc = 0x8323AD44; continue 'dispatch;
            }
            0x8323AD44 => {
    //   block [0x8323AD44..0x8323AD78)
	// 8323AD44: 83F30004  lwz r31, 4(r19)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323AD48: 81740018  lwz r11, 0x18(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(24 as u32) ) } as u64;
	// 8323AD4C: 81540014  lwz r10, 0x14(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323AD50: 92610060  stw r19, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[19].u32 ) };
	// 8323AD54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323AD58: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323AD5C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8323AD60: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 8323AD64: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8323AD68: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 8323AD6C: E9010060  ld r8, 0x60(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8323AD70: F9010060  std r8, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u64 ) };
	// 8323AD74: 419A0020  beq cr6, 0x8323ad94
	if ctx.cr[6].eq {
	pc = 0x8323AD94; continue 'dispatch;
	}
	pc = 0x8323AD78; continue 'dispatch;
            }
            0x8323AD78 => {
    //   block [0x8323AD78..0x8323AD94)
	// 8323AD78: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 8323AD7C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323AD80: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 8323AD84: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8323AD88: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8323AD8C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323AD90: 4082FFE8  bne 0x8323ad78
	if !ctx.cr[0].eq {
	pc = 0x8323AD78; continue 'dispatch;
	}
	pc = 0x8323AD94; continue 'dispatch;
            }
            0x8323AD94 => {
    //   block [0x8323AD94..0x8323ADDC)
	// 8323AD94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8323AD98: 3BAA000C  addi r29, r10, 0xc
	ctx.r[29].s64 = ctx.r[10].s64 + 12;
	// 8323AD9C: 4AF7CD7D  bl 0x821b7b18
	ctx.lr = 0x8323ADA0;
	sub_821B7B18(ctx, base);
	// 8323ADA0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8323ADA4: 3D200000  lis r9, 0
	ctx.r[9].s64 = 0;
	// 8323ADA8: 390A9484  addi r8, r10, -0x6b7c
	ctx.r[8].s64 = ctx.r[10].s64 + -27516;
	// 8323ADAC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8323ADB0: 3A200010  li r17, 0x10
	ctx.r[17].s64 = 16;
	// 8323ADB4: C3EA9484  lfs f31, -0x6b7c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8323ADB8: 3F208349  lis r25, -0x7cb7
	ctx.r[25].s64 = -2092367872;
	// 8323ADBC: 3AC00018  li r22, 0x18
	ctx.r[22].s64 = 24;
	// 8323ADC0: C3C8000C  lfs f30, 0xc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8323ADC4: 39C00005  li r14, 5
	ctx.r[14].s64 = 5;
	// 8323ADC8: 61328000  ori r18, r9, 0x8000
	ctx.r[18].u64 = ctx.r[9].u64 | 32768;
	// 8323ADCC: 3B000070  li r24, 0x70
	ctx.r[24].s64 = 112;
	// 8323ADD0: 3DE00001  lis r15, 1
	ctx.r[15].s64 = 65536;
	// 8323ADD4: 3E000002  lis r16, 2
	ctx.r[16].s64 = 131072;
	// 8323ADD8: 3B4BF1BC  addi r26, r11, -0xe44
	ctx.r[26].s64 = ctx.r[11].s64 + -3652;
	pc = 0x8323ADDC; continue 'dispatch;
            }
            0x8323ADDC => {
    //   block [0x8323ADDC..0x8323ADF0)
	// 8323ADDC: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8323ADE0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323ADE4: 419A000C  beq cr6, 0x8323adf0
	if ctx.cr[6].eq {
	pc = 0x8323ADF0; continue 'dispatch;
	}
	// 8323ADE8: 7F0A9840  cmplw cr6, r10, r19
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[19].u32, &mut ctx.xer);
	// 8323ADEC: 419A0008  beq cr6, 0x8323adf4
	if ctx.cr[6].eq {
	pc = 0x8323ADF4; continue 'dispatch;
	}
	pc = 0x8323ADF0; continue 'dispatch;
            }
            0x8323ADF0 => {
    //   block [0x8323ADF0..0x8323ADF4)
	// 8323ADF0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8323ADF4; continue 'dispatch;
            }
            0x8323ADF4 => {
    //   block [0x8323ADF4..0x8323AE0C)
	// 8323ADF4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8323ADF8: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8323ADFC: 419A0C18  beq cr6, 0x8323ba14
	if ctx.cr[6].eq {
	pc = 0x8323BA14; continue 'dispatch;
	}
	// 8323AE00: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323AE04: 409A0008  bne cr6, 0x8323ae0c
	if !ctx.cr[6].eq {
	pc = 0x8323AE0C; continue 'dispatch;
	}
	// 8323AE08: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8323AE0C; continue 'dispatch;
            }
            0x8323AE0C => {
    //   block [0x8323AE0C..0x8323AE1C)
	// 8323AE0C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323AE10: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8323AE14: 409A0008  bne cr6, 0x8323ae1c
	if !ctx.cr[6].eq {
	pc = 0x8323AE1C; continue 'dispatch;
	}
	// 8323AE18: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8323AE1C; continue 'dispatch;
            }
            0x8323AE1C => {
    //   block [0x8323AE1C..0x8323AF60)
	// 8323AE1C: 83EB000C  lwz r31, 0xc(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323AE20: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8323AE24: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8323AE28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8323AE2C: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 8323AE30: 4B7DC9A9  bl 0x82a177d8
	ctx.lr = 0x8323AE34;
	sub_82A177D8(ctx, base);
	// 8323AE34: 2F1F0080  cmpwi cr6, r31, 0x80
	ctx.cr[6].compare_i32(ctx.r[31].s32, 128, &mut ctx.xer);
	// 8323AE38: 419906CC  bgt cr6, 0x8323b504
	if ctx.cr[6].gt {
	pc = 0x8323B504; continue 'dispatch;
	}
	// 8323AE3C: 419A0634  beq cr6, 0x8323b470
	if ctx.cr[6].eq {
	pc = 0x8323B470; continue 'dispatch;
	}
	// 8323AE40: 397FFFFE  addi r11, r31, -2
	ctx.r[11].s64 = ctx.r[31].s64 + -2;
	// 8323AE44: 2B0B003E  cmplwi cr6, r11, 0x3e
	ctx.cr[6].compare_u32(ctx.r[11].u32, 62 as u32, &mut ctx.xer);
	// 8323AE48: 41990BBC  bgt cr6, 0x8323ba04
	if ctx.cr[6].gt {
	pc = 0x8323BA04; continue 'dispatch;
	}
	// 8323AE4C: 3D808324  lis r12, -0x7cdc
	ctx.r[12].s64 = -2094792704;
	// 8323AE50: 398CAE64  addi r12, r12, -0x519c
	ctx.r[12].s64 = ctx.r[12].s64 + -20892;
	// 8323AE54: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 8323AE58: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 8323AE5C: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 8323AE60: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x8323AF60; continue 'dispatch;
		},
		1 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		2 => {
	pc = 0x8323AFF4; continue 'dispatch;
		},
		3 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		4 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		5 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		6 => {
	pc = 0x8323B0E0; continue 'dispatch;
		},
		7 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		8 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		9 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		10 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		11 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		12 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		13 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		14 => {
	pc = 0x8323B294; continue 'dispatch;
		},
		15 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		16 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		17 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		18 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		19 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		20 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		21 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		22 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		23 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		24 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		25 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		26 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		27 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		28 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		29 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		30 => {
	pc = 0x8323B344; continue 'dispatch;
		},
		31 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		32 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		33 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		34 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		35 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		36 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		37 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		38 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		39 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		40 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		41 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		42 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		43 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		44 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		45 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		46 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		47 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		48 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		49 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		50 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		51 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		52 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		53 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		54 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		55 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		56 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		57 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		58 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		59 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		60 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		61 => {
	pc = 0x8323BA04; continue 'dispatch;
		},
		62 => {
	pc = 0x8323B3DC; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 8323AE64: 8323AF60  lwz r25, -0x50a0(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-20640 as u32) ) } as u64;
	// 8323AE68: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AE6C: 8323AFF4  lwz r25, -0x500c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-20492 as u32) ) } as u64;
	// 8323AE70: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AE74: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AE78: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AE7C: 8323B0E0  lwz r25, -0x4f20(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-20256 as u32) ) } as u64;
	// 8323AE80: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AE84: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AE88: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AE8C: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AE90: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AE94: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AE98: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AE9C: 8323B294  lwz r25, -0x4d6c(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-19820 as u32) ) } as u64;
	// 8323AEA0: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AEA4: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AEA8: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AEAC: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AEB0: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AEB4: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AEB8: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AEBC: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AEC0: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AEC4: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AEC8: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AECC: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AED0: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AED4: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AED8: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AEDC: 8323B344  lwz r25, -0x4cbc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-19644 as u32) ) } as u64;
	// 8323AEE0: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AEE4: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AEE8: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AEEC: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AEF0: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AEF4: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AEF8: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AEFC: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AF00: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AF04: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AF08: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AF0C: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AF10: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AF14: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AF18: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AF1C: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AF20: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AF24: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AF28: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AF2C: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AF30: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AF34: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AF38: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AF3C: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AF40: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AF44: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AF48: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AF4C: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AF50: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AF54: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AF58: 8323BA04  lwz r25, -0x45fc(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17916 as u32) ) } as u64;
	// 8323AF5C: 8323B3DC  lwz r25, -0x4c24(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-19492 as u32) ) } as u64;
            }
            0x8323AF60 => {
    //   block [0x8323AF60..0x8323AF78)
	// 8323AF60: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8323AF64: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323AF68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323AF6C: 419A000C  beq cr6, 0x8323af78
	if ctx.cr[6].eq {
	pc = 0x8323AF78; continue 'dispatch;
	}
	// 8323AF70: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8323AF74: 419A0008  beq cr6, 0x8323af7c
	if ctx.cr[6].eq {
	pc = 0x8323AF7C; continue 'dispatch;
	}
	pc = 0x8323AF78; continue 'dispatch;
            }
            0x8323AF78 => {
    //   block [0x8323AF78..0x8323AF7C)
	// 8323AF78: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8323AF7C; continue 'dispatch;
            }
            0x8323AF7C => {
    //   block [0x8323AF7C..0x8323AFA8)
	// 8323AF7C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323AF80: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8323AF84: 409A0038  bne cr6, 0x8323afbc
	if !ctx.cr[6].eq {
	pc = 0x8323AFBC; continue 'dispatch;
	}
	// 8323AF88: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8323AF8C: 419A001C  beq cr6, 0x8323afa8
	if ctx.cr[6].eq {
	pc = 0x8323AFA8; continue 'dispatch;
	}
	// 8323AF90: C01C0010  lfs f0, 0x10(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323AF94: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323AF98: D01E0010  stfs f0, 0x10(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8323AF9C: 4B0C518D  bl 0x82300128
	ctx.lr = 0x8323AFA0;
	sub_82300128(ctx, base);
	// 8323AFA0: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323AFA4: 4BFFFE38  b 0x8323addc
	pc = 0x8323ADDC; continue 'dispatch;
            }
            0x8323AFA8 => {
    //   block [0x8323AFA8..0x8323AFBC)
	// 8323AFA8: D3DE0010  stfs f30, 0x10(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8323AFAC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323AFB0: 4B0C5179  bl 0x82300128
	ctx.lr = 0x8323AFB4;
	sub_82300128(ctx, base);
	// 8323AFB4: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323AFB8: 4BFFFE24  b 0x8323addc
	pc = 0x8323ADDC; continue 'dispatch;
            }
            0x8323AFBC => {
    //   block [0x8323AFBC..0x8323AFC8)
	// 8323AFBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323AFC0: 409A0008  bne cr6, 0x8323afc8
	if !ctx.cr[6].eq {
	pc = 0x8323AFC8; continue 'dispatch;
	}
	// 8323AFC4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8323AFC8; continue 'dispatch;
            }
            0x8323AFC8 => {
    //   block [0x8323AFC8..0x8323AFD8)
	// 8323AFC8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323AFCC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8323AFD0: 409A0008  bne cr6, 0x8323afd8
	if !ctx.cr[6].eq {
	pc = 0x8323AFD8; continue 'dispatch;
	}
	// 8323AFD4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8323AFD8; continue 'dispatch;
            }
            0x8323AFD8 => {
    //   block [0x8323AFD8..0x8323AFF4)
	// 8323AFD8: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323AFDC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323AFE0: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323AFE4: D01E0010  stfs f0, 0x10(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8323AFE8: 4B0C5141  bl 0x82300128
	ctx.lr = 0x8323AFEC;
	sub_82300128(ctx, base);
	// 8323AFEC: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323AFF0: 4BFFFDEC  b 0x8323addc
	pc = 0x8323ADDC; continue 'dispatch;
            }
            0x8323AFF4 => {
    //   block [0x8323AFF4..0x8323B00C)
	// 8323AFF4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8323AFF8: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323AFFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323B000: 419A000C  beq cr6, 0x8323b00c
	if ctx.cr[6].eq {
	pc = 0x8323B00C; continue 'dispatch;
	}
	// 8323B004: 7F0AE840  cmplw cr6, r10, r29
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8323B008: 419A0008  beq cr6, 0x8323b010
	if ctx.cr[6].eq {
	pc = 0x8323B010; continue 'dispatch;
	}
	pc = 0x8323B00C; continue 'dispatch;
            }
            0x8323B00C => {
    //   block [0x8323B00C..0x8323B010)
	// 8323B00C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8323B010; continue 'dispatch;
            }
            0x8323B010 => {
    //   block [0x8323B010..0x8323B04C)
	// 8323B010: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323B014: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8323B018: 409A0074  bne cr6, 0x8323b08c
	if !ctx.cr[6].eq {
	pc = 0x8323B08C; continue 'dispatch;
	}
	// 8323B01C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8323B020: 419A002C  beq cr6, 0x8323b04c
	if ctx.cr[6].eq {
	pc = 0x8323B04C; continue 'dispatch;
	}
	// 8323B024: C01C0004  lfs f0, 4(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323B028: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323B02C: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8323B030: C1BC0008  lfs f13, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8323B034: D1BE0008  stfs f13, 8(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8323B038: C19C000C  lfs f12, 0xc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8323B03C: D19E000C  stfs f12, 0xc(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8323B040: 4B0C50E9  bl 0x82300128
	ctx.lr = 0x8323B044;
	sub_82300128(ctx, base);
	// 8323B044: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323B048: 4BFFFD94  b 0x8323addc
	pc = 0x8323ADDC; continue 'dispatch;
            }
            0x8323B04C => {
    //   block [0x8323B04C..0x8323B08C)
	// 8323B04C: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 8323B050: D3C10058  stfs f30, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8323B054: 394100D0  addi r10, r1, 0xd0
	ctx.r[10].s64 = ctx.r[1].s64 + 208;
	// 8323B058: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	pc = 0x8323B08C; continue 'dispatch;
            }
            0x8323B08C => {
    //   block [0x8323B08C..0x8323B0E0)
	// 8323B08C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323B090: 409A0008  bne cr6, 0x8323b098
	if !ctx.cr[6].eq {
	pc = 0x8323B098; continue 'dispatch;
	}
	// 8323B094: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323B098: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323B09C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8323B0A0: 409A0008  bne cr6, 0x8323b0a8
	if !ctx.cr[6].eq {
	pc = 0x8323B0A8; continue 'dispatch;
	}
	// 8323B0A4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323B0A8: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323B0AC: 394100E0  addi r10, r1, 0xe0
	ctx.r[10].s64 = ctx.r[1].s64 + 224;
	// 8323B0B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	pc = 0x8323B0E0; continue 'dispatch;
            }
            0x8323B0E0 => {
    //   block [0x8323B0E0..0x8323B294)
	// 8323B0E0: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8323B0E4: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323B0E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323B0EC: 419A000C  beq cr6, 0x8323b0f8
	if ctx.cr[6].eq {
	pc = 0x8323B0F8; continue 'dispatch;
	}
	// 8323B0F0: 7F0AE840  cmplw cr6, r10, r29
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8323B0F4: 419A0008  beq cr6, 0x8323b0fc
	if ctx.cr[6].eq {
	pc = 0x8323B0FC; continue 'dispatch;
	}
	// 8323B0F8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323B0FC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323B100: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8323B104: 409A0050  bne cr6, 0x8323b154
	if !ctx.cr[6].eq {
	pc = 0x8323B154; continue 'dispatch;
	}
	// 8323B108: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8323B10C: 419A002C  beq cr6, 0x8323b138
	if ctx.cr[6].eq {
	pc = 0x8323B138; continue 'dispatch;
	}
	// 8323B110: 897C0069  lbz r11, 0x69(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(105 as u32) ) } as u64;
	// 8323B114: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323B118: 997E0069  stb r11, 0x69(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(105 as u32), ctx.r[11].u8 ) };
	// 8323B11C: C01C006C  lfs f0, 0x6c(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323B120: D01E006C  stfs f0, 0x6c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8323B124: 895C0044  lbz r10, 0x44(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(68 as u32) ) } as u64;
	// 8323B128: 995E0044  stb r10, 0x44(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(68 as u32), ctx.r[10].u8 ) };
	// 8323B12C: 4B0C4FFD  bl 0x82300128
	ctx.lr = 0x8323B130;
	sub_82300128(ctx, base);
	// 8323B130: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323B134: 4BFFFCA8  b 0x8323addc
	pc = 0x8323ADDC; continue 'dispatch;
	// 8323B138: D3FE006C  stfs f31, 0x6c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8323B13C: 9B7E0069  stb r27, 0x69(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(105 as u32), ctx.r[27].u8 ) };
	// 8323B140: 9B7E0044  stb r27, 0x44(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(68 as u32), ctx.r[27].u8 ) };
	// 8323B144: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323B148: 4B0C4FE1  bl 0x82300128
	ctx.lr = 0x8323B14C;
	sub_82300128(ctx, base);
	// 8323B14C: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323B150: 4BFFFC8C  b 0x8323addc
	pc = 0x8323ADDC; continue 'dispatch;
	// 8323B154: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323B158: 409A0008  bne cr6, 0x8323b160
	if !ctx.cr[6].eq {
	pc = 0x8323B160; continue 'dispatch;
	}
	// 8323B15C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323B160: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323B164: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8323B168: 409A0008  bne cr6, 0x8323b170
	if !ctx.cr[6].eq {
	pc = 0x8323B170; continue 'dispatch;
	}
	// 8323B16C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323B170: 81540004  lwz r10, 4(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323B174: D3E10088  stfs f31, 0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 8323B178: 83EB0010  lwz r31, 0x10(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323B17C: 38750020  addi r3, r21, 0x20
	ctx.r[3].s64 = ctx.r[21].s64 + 32;
	// 8323B180: 7D4907B4  extsw r9, r10
	ctx.r[9].s64 = ctx.r[10].s32 as i64;
	// 8323B184: 81150028  lwz r8, 0x28(r21)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(40 as u32) ) } as u64;
	// 8323B188: 80F50024  lwz r7, 0x24(r21)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(36 as u32) ) } as u64;
	// 8323B18C: F92100C0  std r9, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[9].u64 ) };
	// 8323B190: 7CC74050  subf r6, r7, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 8323B194: 9B610093  stb r27, 0x93(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(147 as u32), ctx.r[27].u8 ) };
	// 8323B198: 88BF001C  lbz r5, 0x1c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8323B19C: C01F0020  lfs f0, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323B1A0: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323B1A4: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8323B1A8: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8323B1AC: 7D66B3D7  divw. r11, r6, r22
	ctx.r[11].s32 = ctx.r[6].s32 / ctx.r[22].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8323B1B0: C9A100C0  lfd f13, 0xc0(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) };
	// 8323B1B4: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323B1B8: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 8323B1BC: 7C880774  extsb r8, r4
	ctx.r[8].s64 = ctx.r[4].s8 as i64;
	// 8323B1C0: 7D270774  extsb r7, r9
	ctx.r[7].s64 = ctx.r[9].s8 as i64;
	// 8323B1C4: 9B610094  stb r27, 0x94(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[27].u8 ) };
	// 8323B1C8: 99010090  stb r8, 0x90(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[8].u8 ) };
	// 8323B1CC: 98E10091  stb r7, 0x91(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(145 as u32), ctx.r[7].u8 ) };
	// 8323B1D0: 98A10092  stb r5, 0x92(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(146 as u32), ctx.r[5].u8 ) };
	// 8323B1D4: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 8323B1D8: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8323B1DC: ED4BE824  fdivs f10, f11, f29
	ctx.f[10].f64 = ((ctx.f[11].f64 / ctx.f[29].f64) as f32) as f64;
	// 8323B1E0: D1410084  stfs f10, 0x84(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 8323B1E4: 40820018  bne 0x8323b1fc
	if !ctx.cr[0].eq {
	pc = 0x8323B1FC; continue 'dispatch;
	}
	// 8323B1E8: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 8323B1EC: 4B7DD67D  bl 0x82a18868
	ctx.lr = 0x8323B1F0;
	sub_82A18868(ctx, base);
	// 8323B1F0: 897F001C  lbz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8323B1F4: 997E0069  stb r11, 0x69(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(105 as u32), ctx.r[11].u8 ) };
	// 8323B1F8: 48000074  b 0x8323b26c
	pc = 0x8323B26C; continue 'dispatch;
	// 8323B1FC: 81750028  lwz r11, 0x28(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(40 as u32) ) } as u64;
	// 8323B200: 392BFFE8  addi r9, r11, -0x18
	ctx.r[9].s64 = ctx.r[11].s64 + -24;
	// 8323B204: 912100B4  stw r9, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[9].u32 ) };
	// 8323B208: 80CBFFE8  lwz r6, -0x18(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) } as u64;
	// 8323B20C: 892BFFF8  lbz r9, -8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8323B210: 896BFFF9  lbz r11, -7(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-7 as u32) ) } as u64;
	// 8323B214: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 8323B218: 409A003C  bne cr6, 0x8323b254
	if !ctx.cr[6].eq {
	pc = 0x8323B254; continue 'dispatch;
	}
	// 8323B21C: 7D2A0774  extsb r10, r9
	ctx.r[10].s64 = ctx.r[9].s8 as i64;
	// 8323B220: 7D090774  extsb r9, r8
	ctx.r[9].s64 = ctx.r[8].s8 as i64;
	// 8323B224: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 8323B228: 409A002C  bne cr6, 0x8323b254
	if !ctx.cr[6].eq {
	pc = 0x8323B254; continue 'dispatch;
	}
	// 8323B22C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 8323B230: 7CEA0774  extsb r10, r7
	ctx.r[10].s64 = ctx.r[7].s8 as i64;
	// 8323B234: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8323B238: 409A001C  bne cr6, 0x8323b254
	if !ctx.cr[6].eq {
	pc = 0x8323B254; continue 'dispatch;
	}
	// 8323B23C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8323B240: 419A000C  beq cr6, 0x8323b24c
	if ctx.cr[6].eq {
	pc = 0x8323B24C; continue 'dispatch;
	}
	// 8323B244: 897C0069  lbz r11, 0x69(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(105 as u32) ) } as u64;
	// 8323B248: 48000018  b 0x8323b260
	pc = 0x8323B260; continue 'dispatch;
	// 8323B24C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 8323B250: 48000010  b 0x8323b260
	pc = 0x8323B260; continue 'dispatch;
	// 8323B254: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 8323B258: 4B7DD611  bl 0x82a18868
	ctx.lr = 0x8323B25C;
	sub_82A18868(ctx, base);
	// 8323B25C: 897F001C  lbz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8323B260: 997E0069  stb r11, 0x69(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(105 as u32), ctx.r[11].u8 ) };
	// 8323B264: C01F0020  lfs f0, 0x20(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323B268: D01E006C  stfs f0, 0x6c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8323B26C: 897F0024  lbz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 8323B270: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323B274: 997E0044  stb r11, 0x44(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(68 as u32), ctx.r[11].u8 ) };
	// 8323B278: 895F0025  lbz r10, 0x25(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(37 as u32) ) } as u64;
	// 8323B27C: 995E0045  stb r10, 0x45(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(69 as u32), ctx.r[10].u8 ) };
	// 8323B280: C01F0028  lfs f0, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323B284: D01E0040  stfs f0, 0x40(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 8323B288: 4B0C4EA1  bl 0x82300128
	ctx.lr = 0x8323B28C;
	sub_82300128(ctx, base);
	// 8323B28C: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323B290: 4BFFFB4C  b 0x8323addc
	pc = 0x8323ADDC; continue 'dispatch;
            }
            0x8323B294 => {
    //   block [0x8323B294..0x8323B344)
	// 8323B294: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8323B298: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323B29C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323B2A0: 419A000C  beq cr6, 0x8323b2ac
	if ctx.cr[6].eq {
	pc = 0x8323B2AC; continue 'dispatch;
	}
	// 8323B2A4: 7F0AE840  cmplw cr6, r10, r29
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8323B2A8: 419A0008  beq cr6, 0x8323b2b0
	if ctx.cr[6].eq {
	pc = 0x8323B2B0; continue 'dispatch;
	}
	// 8323B2AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323B2B0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323B2B4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8323B2B8: 409A004C  bne cr6, 0x8323b304
	if !ctx.cr[6].eq {
	pc = 0x8323B304; continue 'dispatch;
	}
	// 8323B2BC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8323B2C0: 419A0024  beq cr6, 0x8323b2e4
	if ctx.cr[6].eq {
	pc = 0x8323B2E4; continue 'dispatch;
	}
	// 8323B2C4: 817C0014  lwz r11, 0x14(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323B2C8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323B2CC: 917E0014  stw r11, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 8323B2D0: 815C0018  lwz r10, 0x18(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 8323B2D4: 915E0018  stw r10, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 8323B2D8: 4B0C4E51  bl 0x82300128
	ctx.lr = 0x8323B2DC;
	sub_82300128(ctx, base);
	// 8323B2DC: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323B2E0: 4BFFFAFC  b 0x8323addc
	pc = 0x8323ADDC; continue 'dispatch;
	// 8323B2E4: D3C1009C  stfs f30, 0x9c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 8323B2E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323B2EC: D3C10098  stfs f30, 0x98(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 8323B2F0: E9610098  ld r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 8323B2F4: F97E0014  std r11, 0x14(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[11].u64 ) };
	// 8323B2F8: 4B0C4E31  bl 0x82300128
	ctx.lr = 0x8323B2FC;
	sub_82300128(ctx, base);
	// 8323B2FC: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323B300: 4BFFFADC  b 0x8323addc
	pc = 0x8323ADDC; continue 'dispatch;
	// 8323B304: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323B308: 409A0008  bne cr6, 0x8323b310
	if !ctx.cr[6].eq {
	pc = 0x8323B310; continue 'dispatch;
	}
	// 8323B30C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323B310: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323B314: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8323B318: 409A0008  bne cr6, 0x8323b320
	if !ctx.cr[6].eq {
	pc = 0x8323B320; continue 'dispatch;
	}
	// 8323B31C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323B320: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323B324: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323B328: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323B32C: 915E0014  stw r10, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 8323B330: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323B334: 913E0018  stw r9, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 8323B338: 4B0C4DF1  bl 0x82300128
	ctx.lr = 0x8323B33C;
	sub_82300128(ctx, base);
	// 8323B33C: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323B340: 4BFFFA9C  b 0x8323addc
	pc = 0x8323ADDC; continue 'dispatch;
            }
            0x8323B344 => {
    //   block [0x8323B344..0x8323B3DC)
	// 8323B344: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8323B348: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323B34C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323B350: 419A000C  beq cr6, 0x8323b35c
	if ctx.cr[6].eq {
	pc = 0x8323B35C; continue 'dispatch;
	}
	// 8323B354: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8323B358: 419A0008  beq cr6, 0x8323b360
	if ctx.cr[6].eq {
	pc = 0x8323B360; continue 'dispatch;
	}
	// 8323B35C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323B360: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323B364: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8323B368: 409A003C  bne cr6, 0x8323b3a4
	if !ctx.cr[6].eq {
	pc = 0x8323B3A4; continue 'dispatch;
	}
	// 8323B36C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8323B370: 419A001C  beq cr6, 0x8323b38c
	if ctx.cr[6].eq {
	pc = 0x8323B38C; continue 'dispatch;
	}
	// 8323B374: 817C0030  lwz r11, 0x30(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) } as u64;
	// 8323B378: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323B37C: 917E0030  stw r11, 0x30(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 8323B380: 4B0C4DA9  bl 0x82300128
	ctx.lr = 0x8323B384;
	sub_82300128(ctx, base);
	// 8323B384: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323B388: 4BFFFA54  b 0x8323addc
	pc = 0x8323ADDC; continue 'dispatch;
	// 8323B38C: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 8323B390: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323B394: 917E0030  stw r11, 0x30(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 8323B398: 4B0C4D91  bl 0x82300128
	ctx.lr = 0x8323B39C;
	sub_82300128(ctx, base);
	// 8323B39C: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323B3A0: 4BFFFA3C  b 0x8323addc
	pc = 0x8323ADDC; continue 'dispatch;
	// 8323B3A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323B3A8: 409A0008  bne cr6, 0x8323b3b0
	if !ctx.cr[6].eq {
	pc = 0x8323B3B0; continue 'dispatch;
	}
	// 8323B3AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323B3B0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323B3B4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8323B3B8: 409A0008  bne cr6, 0x8323b3c0
	if !ctx.cr[6].eq {
	pc = 0x8323B3C0; continue 'dispatch;
	}
	// 8323B3BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323B3C0: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323B3C4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323B3C8: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323B3CC: 915E0030  stw r10, 0x30(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 8323B3D0: 4B0C4D59  bl 0x82300128
	ctx.lr = 0x8323B3D4;
	sub_82300128(ctx, base);
	// 8323B3D4: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323B3D8: 4BFFFA04  b 0x8323addc
	pc = 0x8323ADDC; continue 'dispatch;
            }
            0x8323B3DC => {
    //   block [0x8323B3DC..0x8323B470)
	// 8323B3DC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8323B3E0: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323B3E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323B3E8: 419A000C  beq cr6, 0x8323b3f4
	if ctx.cr[6].eq {
	pc = 0x8323B3F4; continue 'dispatch;
	}
	// 8323B3EC: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8323B3F0: 419A0008  beq cr6, 0x8323b3f8
	if ctx.cr[6].eq {
	pc = 0x8323B3F8; continue 'dispatch;
	}
	// 8323B3F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323B3F8: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323B3FC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8323B400: 409A0038  bne cr6, 0x8323b438
	if !ctx.cr[6].eq {
	pc = 0x8323B438; continue 'dispatch;
	}
	// 8323B404: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8323B408: 419A001C  beq cr6, 0x8323b424
	if ctx.cr[6].eq {
	pc = 0x8323B424; continue 'dispatch;
	}
	// 8323B40C: 817C0034  lwz r11, 0x34(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) } as u64;
	// 8323B410: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323B414: 917E0034  stw r11, 0x34(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 8323B418: 4B0C4D11  bl 0x82300128
	ctx.lr = 0x8323B41C;
	sub_82300128(ctx, base);
	// 8323B41C: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323B420: 4BFFF9BC  b 0x8323addc
	pc = 0x8323ADDC; continue 'dispatch;
	// 8323B424: 92FE0034  stw r23, 0x34(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(52 as u32), ctx.r[23].u32 ) };
	// 8323B428: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323B42C: 4B0C4CFD  bl 0x82300128
	ctx.lr = 0x8323B430;
	sub_82300128(ctx, base);
	// 8323B430: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323B434: 4BFFF9A8  b 0x8323addc
	pc = 0x8323ADDC; continue 'dispatch;
	// 8323B438: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323B43C: 409A0008  bne cr6, 0x8323b444
	if !ctx.cr[6].eq {
	pc = 0x8323B444; continue 'dispatch;
	}
	// 8323B440: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323B444: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323B448: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8323B44C: 409A0008  bne cr6, 0x8323b454
	if !ctx.cr[6].eq {
	pc = 0x8323B454; continue 'dispatch;
	}
	// 8323B450: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323B454: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323B458: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323B45C: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323B460: 915E0034  stw r10, 0x34(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	// 8323B464: 4B0C4CC5  bl 0x82300128
	ctx.lr = 0x8323B468;
	sub_82300128(ctx, base);
	// 8323B468: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323B46C: 4BFFF970  b 0x8323addc
	pc = 0x8323ADDC; continue 'dispatch;
            }
            0x8323B470 => {
    //   block [0x8323B470..0x8323B504)
	// 8323B470: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8323B474: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323B478: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323B47C: 419A000C  beq cr6, 0x8323b488
	if ctx.cr[6].eq {
	pc = 0x8323B488; continue 'dispatch;
	}
	// 8323B480: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8323B484: 419A0008  beq cr6, 0x8323b48c
	if ctx.cr[6].eq {
	pc = 0x8323B48C; continue 'dispatch;
	}
	// 8323B488: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323B48C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323B490: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8323B494: 409A0038  bne cr6, 0x8323b4cc
	if !ctx.cr[6].eq {
	pc = 0x8323B4CC; continue 'dispatch;
	}
	// 8323B498: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8323B49C: 419A001C  beq cr6, 0x8323b4b8
	if ctx.cr[6].eq {
	pc = 0x8323B4B8; continue 'dispatch;
	}
	// 8323B4A0: 817C0038  lwz r11, 0x38(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) } as u64;
	// 8323B4A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323B4A8: 917E0038  stw r11, 0x38(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 8323B4AC: 4B0C4C7D  bl 0x82300128
	ctx.lr = 0x8323B4B0;
	sub_82300128(ctx, base);
	// 8323B4B0: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323B4B4: 4BFFF928  b 0x8323addc
	pc = 0x8323ADDC; continue 'dispatch;
	// 8323B4B8: 91DE0038  stw r14, 0x38(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), ctx.r[14].u32 ) };
	// 8323B4BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323B4C0: 4B0C4C69  bl 0x82300128
	ctx.lr = 0x8323B4C4;
	sub_82300128(ctx, base);
	// 8323B4C4: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323B4C8: 4BFFF914  b 0x8323addc
	pc = 0x8323ADDC; continue 'dispatch;
	// 8323B4CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323B4D0: 409A0008  bne cr6, 0x8323b4d8
	if !ctx.cr[6].eq {
	pc = 0x8323B4D8; continue 'dispatch;
	}
	// 8323B4D4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323B4D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323B4DC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8323B4E0: 409A0008  bne cr6, 0x8323b4e8
	if !ctx.cr[6].eq {
	pc = 0x8323B4E8; continue 'dispatch;
	}
	// 8323B4E4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323B4E8: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323B4EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323B4F0: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323B4F4: 915E0038  stw r10, 0x38(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 8323B4F8: 4B0C4C31  bl 0x82300128
	ctx.lr = 0x8323B4FC;
	sub_82300128(ctx, base);
	// 8323B4FC: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323B500: 4BFFF8DC  b 0x8323addc
	pc = 0x8323ADDC; continue 'dispatch;
            }
            0x8323B504 => {
    //   block [0x8323B504..0x8323BA04)
	// 8323B504: 7F1F9000  cmpw cr6, r31, r18
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[18].s32, &mut ctx.xer);
	// 8323B508: 41990338  bgt cr6, 0x8323b840
	if ctx.cr[6].gt {
	pc = 0x8323B840; continue 'dispatch;
	}
	// 8323B50C: 2B1F8000  cmplwi cr6, r31, 0x8000
	ctx.cr[6].compare_u32(ctx.r[31].u32, 32768 as u32, &mut ctx.xer);
	// 8323B510: 419A029C  beq cr6, 0x8323b7ac
	if ctx.cr[6].eq {
	pc = 0x8323B7AC; continue 'dispatch;
	}
	// 8323B514: 2F1F0100  cmpwi cr6, r31, 0x100
	ctx.cr[6].compare_i32(ctx.r[31].s32, 256, &mut ctx.xer);
	// 8323B518: 419A0200  beq cr6, 0x8323b718
	if ctx.cr[6].eq {
	pc = 0x8323B718; continue 'dispatch;
	}
	// 8323B51C: 2F1F0200  cmpwi cr6, r31, 0x200
	ctx.cr[6].compare_i32(ctx.r[31].s32, 512, &mut ctx.xer);
	// 8323B520: 419A013C  beq cr6, 0x8323b65c
	if ctx.cr[6].eq {
	pc = 0x8323B65C; continue 'dispatch;
	}
	// 8323B524: 2F1F2000  cmpwi cr6, r31, 0x2000
	ctx.cr[6].compare_i32(ctx.r[31].s32, 8192, &mut ctx.xer);
	// 8323B528: 409A04DC  bne cr6, 0x8323ba04
	if !ctx.cr[6].eq {
	pc = 0x8323BA04; continue 'dispatch;
	}
	// 8323B52C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8323B530: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323B534: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323B538: 419A000C  beq cr6, 0x8323b544
	if ctx.cr[6].eq {
	pc = 0x8323B544; continue 'dispatch;
	}
	// 8323B53C: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8323B540: 419A0008  beq cr6, 0x8323b548
	if ctx.cr[6].eq {
	pc = 0x8323B548; continue 'dispatch;
	}
	// 8323B544: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323B548: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323B54C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8323B550: 409A0098  bne cr6, 0x8323b5e8
	if !ctx.cr[6].eq {
	pc = 0x8323B5E8; continue 'dispatch;
	}
	// 8323B554: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8323B558: 419A0044  beq cr6, 0x8323b59c
	if ctx.cr[6].eq {
	pc = 0x8323B59C; continue 'dispatch;
	}
	// 8323B55C: 817C0070  lwz r11, 0x70(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(112 as u32) ) } as u64;
	// 8323B560: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323B564: 917E0070  stw r11, 0x70(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 8323B568: 815C0074  lwz r10, 0x74(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(116 as u32) ) } as u64;
	// 8323B56C: 915E0074  stw r10, 0x74(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 8323B570: 813C0078  lwz r9, 0x78(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(120 as u32) ) } as u64;
	// 8323B574: 913E0078  stw r9, 0x78(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(120 as u32), ctx.r[9].u32 ) };
	// 8323B578: 811C007C  lwz r8, 0x7c(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(124 as u32) ) } as u64;
	// 8323B57C: 911E007C  stw r8, 0x7c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(124 as u32), ctx.r[8].u32 ) };
	// 8323B580: 80FC0080  lwz r7, 0x80(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(128 as u32) ) } as u64;
	// 8323B584: 90FE0080  stw r7, 0x80(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(128 as u32), ctx.r[7].u32 ) };
	// 8323B588: 88DC0084  lbz r6, 0x84(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(132 as u32) ) } as u64;
	// 8323B58C: 98DE0084  stb r6, 0x84(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(132 as u32), ctx.r[6].u8 ) };
	// 8323B590: 4B0C4B99  bl 0x82300128
	ctx.lr = 0x8323B594;
	sub_82300128(ctx, base);
	// 8323B594: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323B598: 4BFFF844  b 0x8323addc
	pc = 0x8323ADDC; continue 'dispatch;
	// 8323B59C: D3E100BC  stfs f31, 0xbc(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 8323B5A0: 81796DD4  lwz r11, 0x6dd4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28116 as u32) ) } as u64;
	// 8323B5A4: D3E100B8  stfs f31, 0xb8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 8323B5A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323B5AC: D3C100A0  stfs f30, 0xa0(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 8323B5B0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8323B5B4: D3C100A4  stfs f30, 0xa4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 8323B5B8: 7C0BD42E  lfsx f0, r11, r26
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323B5BC: 9AFE0084  stb r23, 0x84(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(132 as u32), ctx.r[23].u8 ) };
	// 8323B5C0: EDA007F2  fmuls f13, f0, f31
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 8323B5C4: FD80681E  fctiwz f12, f13
	ctx.f[12].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 8323B5C8: 7D9EC7AE  stfiwx f12, r30, r24
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[24].u32), tmp.u32) };
	// 8323B5CC: E94100B8  ld r10, 0xb8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	// 8323B5D0: E92100A0  ld r9, 0xa0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 8323B5D4: F93E0074  std r9, 0x74(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(116 as u32), ctx.r[9].u64 ) };
	// 8323B5D8: F95E007C  std r10, 0x7c(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(124 as u32), ctx.r[10].u64 ) };
	// 8323B5DC: 4B0C4B4D  bl 0x82300128
	ctx.lr = 0x8323B5E0;
	sub_82300128(ctx, base);
	// 8323B5E0: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323B5E4: 4BFFF7F8  b 0x8323addc
	pc = 0x8323ADDC; continue 'dispatch;
	// 8323B5E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323B5EC: 409A0008  bne cr6, 0x8323b5f4
	if !ctx.cr[6].eq {
	pc = 0x8323B5F4; continue 'dispatch;
	}
	// 8323B5F0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323B5F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323B5F8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8323B5FC: 409A0008  bne cr6, 0x8323b604
	if !ctx.cr[6].eq {
	pc = 0x8323B604; continue 'dispatch;
	}
	// 8323B600: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323B604: 81796DD4  lwz r11, 0x6dd4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28116 as u32) ) } as u64;
	// 8323B608: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323B60C: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323B610: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8323B614: C00A0010  lfs f0, 0x10(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323B618: 7DA9D42E  lfsx f13, r9, r26
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[26].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8323B61C: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8323B620: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 8323B624: 7D7EC7AE  stfiwx f11, r30, r24
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[24].u32), tmp.u32) };
	// 8323B628: 810A0014  lwz r8, 0x14(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323B62C: 911E0074  stw r8, 0x74(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(116 as u32), ctx.r[8].u32 ) };
	// 8323B630: 80EA0018  lwz r7, 0x18(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 8323B634: 90FE0078  stw r7, 0x78(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(120 as u32), ctx.r[7].u32 ) };
	// 8323B638: 80CA001C  lwz r6, 0x1c(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 8323B63C: 90DE007C  stw r6, 0x7c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(124 as u32), ctx.r[6].u32 ) };
	// 8323B640: 80AA0020  lwz r5, 0x20(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 8323B644: 90BE0080  stw r5, 0x80(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(128 as u32), ctx.r[5].u32 ) };
	// 8323B648: 888A0024  lbz r4, 0x24(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 8323B64C: 989E0084  stb r4, 0x84(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(132 as u32), ctx.r[4].u8 ) };
	// 8323B650: 4B0C4AD9  bl 0x82300128
	ctx.lr = 0x8323B654;
	sub_82300128(ctx, base);
	// 8323B654: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323B658: 4BFFF784  b 0x8323addc
	pc = 0x8323ADDC; continue 'dispatch;
	// 8323B65C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8323B660: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323B664: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323B668: 419A000C  beq cr6, 0x8323b674
	if ctx.cr[6].eq {
	pc = 0x8323B674; continue 'dispatch;
	}
	// 8323B66C: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8323B670: 419A0008  beq cr6, 0x8323b678
	if ctx.cr[6].eq {
	pc = 0x8323B678; continue 'dispatch;
	}
	// 8323B674: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323B678: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323B67C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8323B680: 409A0050  bne cr6, 0x8323b6d0
	if !ctx.cr[6].eq {
	pc = 0x8323B6D0; continue 'dispatch;
	}
	// 8323B684: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8323B688: 419A002C  beq cr6, 0x8323b6b4
	if ctx.cr[6].eq {
	pc = 0x8323B6B4; continue 'dispatch;
	}
	// 8323B68C: C01C0060  lfs f0, 0x60(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323B690: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323B694: D01E0060  stfs f0, 0x60(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8323B698: C1BC0064  lfs f13, 0x64(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8323B69C: D1BE0064  stfs f13, 0x64(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8323B6A0: 897C0068  lbz r11, 0x68(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323B6A4: 997E0068  stb r11, 0x68(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(104 as u32), ctx.r[11].u8 ) };
	// 8323B6A8: 4B0C4A81  bl 0x82300128
	ctx.lr = 0x8323B6AC;
	sub_82300128(ctx, base);
	// 8323B6AC: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323B6B0: 4BFFF72C  b 0x8323addc
	pc = 0x8323ADDC; continue 'dispatch;
	// 8323B6B4: D3FE0060  stfs f31, 0x60(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8323B6B8: 9B7E0068  stb r27, 0x68(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(104 as u32), ctx.r[27].u8 ) };
	// 8323B6BC: D3FE0064  stfs f31, 0x64(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8323B6C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323B6C4: 4B0C4A65  bl 0x82300128
	ctx.lr = 0x8323B6C8;
	sub_82300128(ctx, base);
	// 8323B6C8: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323B6CC: 4BFFF710  b 0x8323addc
	pc = 0x8323ADDC; continue 'dispatch;
	// 8323B6D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323B6D4: 409A0008  bne cr6, 0x8323b6dc
	if !ctx.cr[6].eq {
	pc = 0x8323B6DC; continue 'dispatch;
	}
	// 8323B6D8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323B6DC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323B6E0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8323B6E4: 409A0008  bne cr6, 0x8323b6ec
	if !ctx.cr[6].eq {
	pc = 0x8323B6EC; continue 'dispatch;
	}
	// 8323B6E8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323B6EC: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323B6F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323B6F4: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323B6F8: D01E0060  stfs f0, 0x60(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8323B6FC: C1AB0014  lfs f13, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8323B700: D1BE0064  stfs f13, 0x64(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8323B704: 894B0018  lbz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8323B708: 995E0068  stb r10, 0x68(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(104 as u32), ctx.r[10].u8 ) };
	// 8323B70C: 4B0C4A1D  bl 0x82300128
	ctx.lr = 0x8323B710;
	sub_82300128(ctx, base);
	// 8323B710: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323B714: 4BFFF6C8  b 0x8323addc
	pc = 0x8323ADDC; continue 'dispatch;
	// 8323B718: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8323B71C: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323B720: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323B724: 419A000C  beq cr6, 0x8323b730
	if ctx.cr[6].eq {
	pc = 0x8323B730; continue 'dispatch;
	}
	// 8323B728: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8323B72C: 419A0008  beq cr6, 0x8323b734
	if ctx.cr[6].eq {
	pc = 0x8323B734; continue 'dispatch;
	}
	// 8323B730: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323B734: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323B738: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8323B73C: 409A0038  bne cr6, 0x8323b774
	if !ctx.cr[6].eq {
	pc = 0x8323B774; continue 'dispatch;
	}
	// 8323B740: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8323B744: 419A001C  beq cr6, 0x8323b760
	if ctx.cr[6].eq {
	pc = 0x8323B760; continue 'dispatch;
	}
	// 8323B748: 817C003C  lwz r11, 0x3c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(60 as u32) ) } as u64;
	// 8323B74C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323B750: 917E003C  stw r11, 0x3c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 8323B754: 4B0C49D5  bl 0x82300128
	ctx.lr = 0x8323B758;
	sub_82300128(ctx, base);
	// 8323B758: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323B75C: 4BFFF680  b 0x8323addc
	pc = 0x8323ADDC; continue 'dispatch;
	// 8323B760: 937E003C  stw r27, 0x3c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(60 as u32), ctx.r[27].u32 ) };
	// 8323B764: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323B768: 4B0C49C1  bl 0x82300128
	ctx.lr = 0x8323B76C;
	sub_82300128(ctx, base);
	// 8323B76C: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323B770: 4BFFF66C  b 0x8323addc
	pc = 0x8323ADDC; continue 'dispatch;
	// 8323B774: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323B778: 409A0008  bne cr6, 0x8323b780
	if !ctx.cr[6].eq {
	pc = 0x8323B780; continue 'dispatch;
	}
	// 8323B77C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323B780: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323B784: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8323B788: 409A0008  bne cr6, 0x8323b790
	if !ctx.cr[6].eq {
	pc = 0x8323B790; continue 'dispatch;
	}
	// 8323B78C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323B790: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323B794: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323B798: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323B79C: 915E003C  stw r10, 0x3c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(60 as u32), ctx.r[10].u32 ) };
	// 8323B7A0: 4B0C4989  bl 0x82300128
	ctx.lr = 0x8323B7A4;
	sub_82300128(ctx, base);
	// 8323B7A4: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323B7A8: 4BFFF634  b 0x8323addc
	pc = 0x8323ADDC; continue 'dispatch;
	// 8323B7AC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8323B7B0: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323B7B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323B7B8: 419A000C  beq cr6, 0x8323b7c4
	if ctx.cr[6].eq {
	pc = 0x8323B7C4; continue 'dispatch;
	}
	// 8323B7BC: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8323B7C0: 419A0008  beq cr6, 0x8323b7c8
	if ctx.cr[6].eq {
	pc = 0x8323B7C8; continue 'dispatch;
	}
	// 8323B7C4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323B7C8: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323B7CC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8323B7D0: 409A0038  bne cr6, 0x8323b808
	if !ctx.cr[6].eq {
	pc = 0x8323B808; continue 'dispatch;
	}
	// 8323B7D4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8323B7D8: 419A001C  beq cr6, 0x8323b7f4
	if ctx.cr[6].eq {
	pc = 0x8323B7F4; continue 'dispatch;
	}
	// 8323B7DC: C01C0024  lfs f0, 0x24(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323B7E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323B7E4: D01E0024  stfs f0, 0x24(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8323B7E8: 4B0C4941  bl 0x82300128
	ctx.lr = 0x8323B7EC;
	sub_82300128(ctx, base);
	// 8323B7EC: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323B7F0: 4BFFF5EC  b 0x8323addc
	pc = 0x8323ADDC; continue 'dispatch;
	// 8323B7F4: D3DE0024  stfs f30, 0x24(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8323B7F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323B7FC: 4B0C492D  bl 0x82300128
	ctx.lr = 0x8323B800;
	sub_82300128(ctx, base);
	// 8323B800: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323B804: 4BFFF5D8  b 0x8323addc
	pc = 0x8323ADDC; continue 'dispatch;
	// 8323B808: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323B80C: 409A0008  bne cr6, 0x8323b814
	if !ctx.cr[6].eq {
	pc = 0x8323B814; continue 'dispatch;
	}
	// 8323B810: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323B814: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323B818: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8323B81C: 409A0008  bne cr6, 0x8323b824
	if !ctx.cr[6].eq {
	pc = 0x8323B824; continue 'dispatch;
	}
	// 8323B820: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323B824: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323B828: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323B82C: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323B830: D01E0024  stfs f0, 0x24(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8323B834: 4B0C48F5  bl 0x82300128
	ctx.lr = 0x8323B838;
	sub_82300128(ctx, base);
	// 8323B838: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323B83C: 4BFFF5A0  b 0x8323addc
	pc = 0x8323ADDC; continue 'dispatch;
	// 8323B840: 7F1F7800  cmpw cr6, r31, r15
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[15].s32, &mut ctx.xer);
	// 8323B844: 419A0120  beq cr6, 0x8323b964
	if ctx.cr[6].eq {
	pc = 0x8323B964; continue 'dispatch;
	}
	// 8323B848: 7F1F8000  cmpw cr6, r31, r16
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[16].s32, &mut ctx.xer);
	// 8323B84C: 409A01B8  bne cr6, 0x8323ba04
	if !ctx.cr[6].eq {
	pc = 0x8323BA04; continue 'dispatch;
	}
	// 8323B850: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8323B854: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323B858: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323B85C: 419A000C  beq cr6, 0x8323b868
	if ctx.cr[6].eq {
	pc = 0x8323B868; continue 'dispatch;
	}
	// 8323B860: 7F0AE840  cmplw cr6, r10, r29
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8323B864: 419A0008  beq cr6, 0x8323b86c
	if ctx.cr[6].eq {
	pc = 0x8323B86C; continue 'dispatch;
	}
	// 8323B868: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 8323B86C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323B870: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8323B874: 409A00A4  bne cr6, 0x8323b918
	if !ctx.cr[6].eq {
	pc = 0x8323B918; continue 'dispatch;
	}
	// 8323B878: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8323B87C: 419A002C  beq cr6, 0x8323b8a8
	if ctx.cr[6].eq {
	pc = 0x8323B8A8; continue 'dispatch;
	}
	// 8323B880: 9AFE0048  stb r23, 0x48(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(72 as u32), ctx.r[23].u8 ) };
	// 8323B884: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323B888: 397C0050  addi r11, r28, 0x50
	ctx.r[11].s64 = ctx.r[28].s64 + 80;
	// 8323B88C: E95C0050  ld r10, 0x50(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(80 as u32) ) };
	// 8323B890: F95E0050  std r10, 0x50(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 8323B894: E93C0058  ld r9, 0x58(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(88 as u32) ) };
	// 8323B898: F93E0058  std r9, 0x58(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 8323B89C: 4B0C488D  bl 0x82300128
	ctx.lr = 0x8323B8A0;
	sub_82300128(ctx, base);
	// 8323B8A0: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323B8A4: 4BFFF538  b 0x8323addc
	pc = 0x8323ADDC; continue 'dispatch;
	// 8323B8A8: D3E10058  stfs f31, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8323B8AC: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 8323B8B0: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8323B8B4: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 8323B8B8: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8323B8BC: 3921006C  addi r9, r1, 0x6c
	ctx.r[9].s64 = ctx.r[1].s64 + 108;
	// 8323B8C0: D3C100B0  stfs f30, 0xb0(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 8323B8C4: 390100B0  addi r8, r1, 0xb0
	ctx.r[8].s64 = ctx.r[1].s64 + 176;
	// 8323B8C8: 38E100F0  addi r7, r1, 0xf0
	ctx.r[7].s64 = ctx.r[1].s64 + 240;
	// 8323B8CC: 9B7E0048  stb r27, 0x48(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(72 as u32), ctx.r[27].u8 ) };
	// 8323B8D0: 38C100F0  addi r6, r1, 0xf0
	ctx.r[6].s64 = ctx.r[1].s64 + 240;
	// 8323B8D4: 38BE0050  addi r5, r30, 0x50
	ctx.r[5].s64 = ctx.r[30].s64 + 80;
            }
            0x8323BA04 => {
    //   block [0x8323BA04..0x8323BA14)
	// 8323BA04: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323BA08: 4B0C4721  bl 0x82300128
	ctx.lr = 0x8323BA0C;
	sub_82300128(ctx, base);
	// 8323BA0C: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323BA10: 4BFFF3CC  b 0x8323addc
	pc = 0x8323ADDC; continue 'dispatch;
            }
            0x8323BA14 => {
    //   block [0x8323BA14..0x8323BA28)
	// 8323BA14: 382101B0  addi r1, r1, 0x1b0
	ctx.r[1].s64 = ctx.r[1].s64 + 432;
	// 8323BA18: CBA1FF50  lfd f29, -0xb0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-176 as u32) ) };
	// 8323BA1C: CBC1FF58  lfd f30, -0xa8(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-168 as u32) ) };
	// 8323BA20: CBE1FF60  lfd f31, -0xa0(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 8323BA24: 4BA6D9FC  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323BA28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323BA28 size=548
    let mut pc: u32 = 0x8323BA28;
    'dispatch: loop {
        match pc {
            0x8323BA28 => {
    //   block [0x8323BA28..0x8323BA78)
	// 8323BA28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323BA2C: 4BA6D9D9  bl 0x82ca9404
	ctx.lr = 0x8323BA30;
	sub_82CA93D0(ctx, base);
	// 8323BA30: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323BA34: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8323BA38: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 8323BA3C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 8323BA40: 4BFFD8A9  bl 0x832392e8
	ctx.lr = 0x8323BA44;
	sub_832392E8(ctx, base);
	// 8323BA44: 397FFFFF  addi r11, r31, -1
	ctx.r[11].s64 = ctx.r[31].s64 + -1;
	// 8323BA48: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 8323BA4C: 419901F0  bgt cr6, 0x8323bc3c
	if ctx.cr[6].gt {
	pc = 0x8323BC3C; continue 'dispatch;
	}
	// 8323BA50: 3D808324  lis r12, -0x7cdc
	ctx.r[12].s64 = -2094792704;
	// 8323BA54: 398CBA68  addi r12, r12, -0x4598
	ctx.r[12].s64 = ctx.r[12].s64 + -17816;
	// 8323BA58: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 8323BA5C: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 8323BA60: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 8323BA64: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x8323BA78; continue 'dispatch;
		},
		1 => {
	pc = 0x8323BAF0; continue 'dispatch;
		},
		2 => {
	pc = 0x8323BB68; continue 'dispatch;
		},
		3 => {
	pc = 0x8323BBD8; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 8323BA68: 8323BA78  lwz r25, -0x4588(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17800 as u32) ) } as u64;
	// 8323BA6C: 8323BAF0  lwz r25, -0x4510(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17680 as u32) ) } as u64;
	// 8323BA70: 8323BB68  lwz r25, -0x4498(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17560 as u32) ) } as u64;
	// 8323BA74: 8323BBD8  lwz r25, -0x4428(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-17448 as u32) ) } as u64;
            }
            0x8323BA78 => {
    //   block [0x8323BA78..0x8323BAB8)
	// 8323BA78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8323BA7C: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323BA80: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323BA84: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8323BA88: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 8323BA8C: 387D0010  addi r3, r29, 0x10
	ctx.r[3].s64 = ctx.r[29].s64 + 16;
	// 8323BA90: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 8323BA94: 7D1F1E70  srawi r31, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 8323BA98: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8323BA9C: 7CFF5A14  add r7, r31, r11
	ctx.r[7].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 8323BAA0: 54E42036  slwi r4, r7, 4
	ctx.r[4].u32 = ctx.r[7].u32.wrapping_shl(4);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 8323BAA4: 4B0C4FDD  bl 0x82300a80
	ctx.lr = 0x8323BAA8;
	sub_82300A80(ctx, base);
	// 8323BAA8: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8323BAAC: 83DD0014  lwz r30, 0x14(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323BAB0: 40990020  ble cr6, 0x8323bad0
	if !ctx.cr[6].gt {
	pc = 0x8323BAD0; continue 'dispatch;
	}
	// 8323BAB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x8323BAB8; continue 'dispatch;
            }
            0x8323BAB8 => {
    //   block [0x8323BAB8..0x8323BAC4)
	// 8323BAB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8323BABC: 419A0008  beq cr6, 0x8323bac4
	if ctx.cr[6].eq {
	pc = 0x8323BAC4; continue 'dispatch;
	}
	// 8323BAC0: 4BFDC791  bl 0x83218250
	ctx.lr = 0x8323BAC4;
	sub_83218250(ctx, base);
	pc = 0x8323BAC4; continue 'dispatch;
            }
            0x8323BAC4 => {
    //   block [0x8323BAC4..0x8323BAD0)
	// 8323BAC4: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8323BAC8: 38630090  addi r3, r3, 0x90
	ctx.r[3].s64 = ctx.r[3].s64 + 144;
	// 8323BACC: 4082FFEC  bne 0x8323bab8
	if !ctx.cr[0].eq {
	pc = 0x8323BAB8; continue 'dispatch;
	}
	pc = 0x8323BAD0; continue 'dispatch;
            }
            0x8323BAD0 => {
    //   block [0x8323BAD0..0x8323BAF0)
	// 8323BAD0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8323BAD4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8323BAD8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8323BADC: 4B7DD2D5  bl 0x82a18db0
	ctx.lr = 0x8323BAE0;
	sub_82A18DB0(ctx, base);
	// 8323BAE0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8323BAE4: 4BFFD40D  bl 0x83238ef0
	ctx.lr = 0x8323BAE8;
	sub_83238EF0(ctx, base);
	// 8323BAE8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8323BAEC: 4BA6D968  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x8323BAF0 => {
    //   block [0x8323BAF0..0x8323BB30)
	// 8323BAF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8323BAF4: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323BAF8: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323BAFC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8323BB00: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 8323BB04: 387D0010  addi r3, r29, 0x10
	ctx.r[3].s64 = ctx.r[29].s64 + 16;
	// 8323BB08: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 8323BB0C: 7D1F1E70  srawi r31, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 8323BB10: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8323BB14: 7CFF5A14  add r7, r31, r11
	ctx.r[7].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 8323BB18: 54E42834  slwi r4, r7, 5
	ctx.r[4].u32 = ctx.r[7].u32.wrapping_shl(5);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 8323BB1C: 4B0C4F65  bl 0x82300a80
	ctx.lr = 0x8323BB20;
	sub_82300A80(ctx, base);
	// 8323BB20: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8323BB24: 83DD0014  lwz r30, 0x14(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323BB28: 40990020  ble cr6, 0x8323bb48
	if !ctx.cr[6].gt {
	pc = 0x8323BB48; continue 'dispatch;
	}
	// 8323BB2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x8323BB30; continue 'dispatch;
            }
            0x8323BB30 => {
    //   block [0x8323BB30..0x8323BB3C)
	// 8323BB30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8323BB34: 419A0008  beq cr6, 0x8323bb3c
	if ctx.cr[6].eq {
	pc = 0x8323BB3C; continue 'dispatch;
	}
	// 8323BB38: 4BFDC641  bl 0x83218178
	ctx.lr = 0x8323BB3C;
	sub_83218178(ctx, base);
	pc = 0x8323BB3C; continue 'dispatch;
            }
            0x8323BB3C => {
    //   block [0x8323BB3C..0x8323BB48)
	// 8323BB3C: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8323BB40: 38630060  addi r3, r3, 0x60
	ctx.r[3].s64 = ctx.r[3].s64 + 96;
	// 8323BB44: 4082FFEC  bne 0x8323bb30
	if !ctx.cr[0].eq {
	pc = 0x8323BB30; continue 'dispatch;
	}
	pc = 0x8323BB48; continue 'dispatch;
            }
            0x8323BB48 => {
    //   block [0x8323BB48..0x8323BB68)
	// 8323BB48: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8323BB4C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8323BB50: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8323BB54: 4B7DD4F5  bl 0x82a19048
	ctx.lr = 0x8323BB58;
	sub_82A19048(ctx, base);
	// 8323BB58: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8323BB5C: 4BFFD395  bl 0x83238ef0
	ctx.lr = 0x8323BB60;
	sub_83238EF0(ctx, base);
	// 8323BB60: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8323BB64: 4BA6D8F0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x8323BB68 => {
    //   block [0x8323BB68..0x8323BBA0)
	// 8323BB68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8323BB6C: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323BB70: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323BB74: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8323BB78: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 8323BB7C: 387D0010  addi r3, r29, 0x10
	ctx.r[3].s64 = ctx.r[29].s64 + 16;
	// 8323BB80: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 8323BB84: 7D1F1E70  srawi r31, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 8323BB88: 57E43032  slwi r4, r31, 6
	ctx.r[4].u32 = ctx.r[31].u32.wrapping_shl(6);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 8323BB8C: 4B0C4EF5  bl 0x82300a80
	ctx.lr = 0x8323BB90;
	sub_82300A80(ctx, base);
	// 8323BB90: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8323BB94: 83DD0014  lwz r30, 0x14(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323BB98: 40990020  ble cr6, 0x8323bbb8
	if !ctx.cr[6].gt {
	pc = 0x8323BBB8; continue 'dispatch;
	}
	// 8323BB9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x8323BBA0; continue 'dispatch;
            }
            0x8323BBA0 => {
    //   block [0x8323BBA0..0x8323BBAC)
	// 8323BBA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8323BBA4: 419A0008  beq cr6, 0x8323bbac
	if ctx.cr[6].eq {
	pc = 0x8323BBAC; continue 'dispatch;
	}
	// 8323BBA8: 4BFDC531  bl 0x832180d8
	ctx.lr = 0x8323BBAC;
	sub_832180D8(ctx, base);
	pc = 0x8323BBAC; continue 'dispatch;
            }
            0x8323BBAC => {
    //   block [0x8323BBAC..0x8323BBB8)
	// 8323BBAC: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8323BBB0: 38630040  addi r3, r3, 0x40
	ctx.r[3].s64 = ctx.r[3].s64 + 64;
	// 8323BBB4: 4082FFEC  bne 0x8323bba0
	if !ctx.cr[0].eq {
	pc = 0x8323BBA0; continue 'dispatch;
	}
	pc = 0x8323BBB8; continue 'dispatch;
            }
            0x8323BBB8 => {
    //   block [0x8323BBB8..0x8323BBD8)
	// 8323BBB8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8323BBBC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8323BBC0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8323BBC4: 4B7DD71D  bl 0x82a192e0
	ctx.lr = 0x8323BBC8;
	sub_82A192E0(ctx, base);
	// 8323BBC8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8323BBCC: 4BFFD325  bl 0x83238ef0
	ctx.lr = 0x8323BBD0;
	sub_83238EF0(ctx, base);
	// 8323BBD0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8323BBD4: 4BA6D880  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x8323BBD8 => {
    //   block [0x8323BBD8..0x8323BC10)
	// 8323BBD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8323BBDC: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323BBE0: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323BBE4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8323BBE8: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 8323BBEC: 387D0010  addi r3, r29, 0x10
	ctx.r[3].s64 = ctx.r[29].s64 + 16;
	// 8323BBF0: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 8323BBF4: 7D1E1E70  srawi r30, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 8323BBF8: 1C9E0044  mulli r4, r30, 0x44
	ctx.r[4].s32 = ((ctx.r[30].s32 as i64 * 68 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 8323BBFC: 4B0C4E85  bl 0x82300a80
	ctx.lr = 0x8323BC00;
	sub_82300A80(ctx, base);
	// 8323BC00: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8323BC04: 839D0014  lwz r28, 0x14(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323BC08: 40990024  ble cr6, 0x8323bc2c
	if !ctx.cr[6].gt {
	pc = 0x8323BC2C; continue 'dispatch;
	}
	// 8323BC0C: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	pc = 0x8323BC10; continue 'dispatch;
            }
            0x8323BC10 => {
    //   block [0x8323BC10..0x8323BC20)
	// 8323BC10: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8323BC14: 419A000C  beq cr6, 0x8323bc20
	if ctx.cr[6].eq {
	pc = 0x8323BC20; continue 'dispatch;
	}
	// 8323BC18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323BC1C: 4BFDC3ED  bl 0x83218008
	ctx.lr = 0x8323BC20;
	sub_83218008(ctx, base);
	pc = 0x8323BC20; continue 'dispatch;
            }
            0x8323BC20 => {
    //   block [0x8323BC20..0x8323BC2C)
	// 8323BC20: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8323BC24: 3BFF0044  addi r31, r31, 0x44
	ctx.r[31].s64 = ctx.r[31].s64 + 68;
	// 8323BC28: 4082FFE8  bne 0x8323bc10
	if !ctx.cr[0].eq {
	pc = 0x8323BC10; continue 'dispatch;
	}
	pc = 0x8323BC2C; continue 'dispatch;
            }
            0x8323BC2C => {
    //   block [0x8323BC2C..0x8323BC3C)
	// 8323BC2C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8323BC30: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8323BC34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8323BC38: 4B7DD929  bl 0x82a19560
	ctx.lr = 0x8323BC3C;
	sub_82A19560(ctx, base);
	pc = 0x8323BC3C; continue 'dispatch;
            }
            0x8323BC3C => {
    //   block [0x8323BC3C..0x8323BC4C)
	// 8323BC3C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8323BC40: 4BFFD2B1  bl 0x83238ef0
	ctx.lr = 0x8323BC44;
	sub_83238EF0(ctx, base);
	// 8323BC44: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8323BC48: 4BA6D80C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323BC50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8323BC50 size=44
    let mut pc: u32 = 0x8323BC50;
    'dispatch: loop {
        match pc {
            0x8323BC50 => {
    //   block [0x8323BC50..0x8323BC7C)
	// 8323BC50: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 8323BC54: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8323BC58: 392A27E4  addi r9, r10, 0x27e4
	ctx.r[9].s64 = ctx.r[10].s64 + 10212;
	// 8323BC5C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8323BC60: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 8323BC64: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 8323BC68: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 8323BC6C: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 8323BC70: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 8323BC74: 9163002C  stw r11, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 8323BC78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323BC80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8323BC80 size=16
    let mut pc: u32 = 0x8323BC80;
    'dispatch: loop {
        match pc {
            0x8323BC80 => {
    //   block [0x8323BC80..0x8323BC90)
	// 8323BC80: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 8323BC84: 394B2720  addi r10, r11, 0x2720
	ctx.r[10].s64 = ctx.r[11].s64 + 10016;
	// 8323BC88: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8323BC8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323BC90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8323BC90 size=28
    let mut pc: u32 = 0x8323BC90;
    'dispatch: loop {
        match pc {
            0x8323BC90 => {
    //   block [0x8323BC90..0x8323BCAC)
	// 8323BC90: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 8323BC94: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8323BC98: 392B2720  addi r9, r11, 0x2720
	ctx.r[9].s64 = ctx.r[11].s64 + 10016;
	// 8323BC9C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8323BCA0: 90830004  stw r4, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 8323BCA4: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8323BCA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323BCB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8323BCB0 size=16
    let mut pc: u32 = 0x8323BCB0;
    'dispatch: loop {
        match pc {
            0x8323BCB0 => {
    //   block [0x8323BCB0..0x8323BCC0)
	// 8323BCB0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8323BCB4: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 8323BCB8: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323BCBC: 4B7E693C  b 0x82a225f8
	sub_82A225F8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323BCC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323BCC0 size=164
    let mut pc: u32 = 0x8323BCC0;
    'dispatch: loop {
        match pc {
            0x8323BCC0 => {
    //   block [0x8323BCC0..0x8323BD30)
	// 8323BCC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323BCC4: 4BA6D749  bl 0x82ca940c
	ctx.lr = 0x8323BCC8;
	sub_82CA93D0(ctx, base);
	// 8323BCC8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323BCCC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8323BCD0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8323BCD4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8323BCD8: 3BCBA3B4  addi r30, r11, -0x5c4c
	ctx.r[30].s64 = ctx.r[11].s64 + -23628;
	// 8323BCDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323BCE0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323BCE4: 389EFFEC  addi r4, r30, -0x14
	ctx.r[4].s64 = ctx.r[30].s64 + -20;
	// 8323BCE8: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323BCEC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8323BCF0: 4E800421  bctrl
	ctx.lr = 0x8323BCF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323BCF4: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8323BCF8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8323BCFC: 419A0060  beq cr6, 0x8323bd5c
	if ctx.cr[6].eq {
	pc = 0x8323BD5C; continue 'dispatch;
	}
	// 8323BD00: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323BD04: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8323BD08: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8323BD0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8323BD10: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8323BD14: 4AFF11BD  bl 0x8222ced0
	ctx.lr = 0x8323BD18;
	sub_8222CED0(ctx, base);
	// 8323BD18: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8323BD1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323BD20: 409A0010  bne cr6, 0x8323bd30
	if !ctx.cr[6].eq {
	pc = 0x8323BD30; continue 'dispatch;
	}
	// 8323BD24: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8323BD28: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 8323BD2C: 48000008  b 0x8323bd34
	pc = 0x8323BD34; continue 'dispatch;
            }
            0x8323BD30 => {
    //   block [0x8323BD30..0x8323BD34)
	// 8323BD30: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8323BD34; continue 'dispatch;
            }
            0x8323BD34 => {
    //   block [0x8323BD34..0x8323BD5C)
	// 8323BD34: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 8323BD38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323BD3C: 4B15434D  bl 0x82390088
	ctx.lr = 0x8323BD40;
	sub_82390088(ctx, base);
	// 8323BD40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8323BD44: 4AFD9095  bl 0x82214dd8
	ctx.lr = 0x8323BD48;
	sub_82214DD8(ctx, base);
	// 8323BD48: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323BD4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323BD50: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323BD54: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323BD58: 4E800421  bctrl
	ctx.lr = 0x8323BD5C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8323BD5C => {
    //   block [0x8323BD5C..0x8323BD64)
	// 8323BD5C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8323BD60: 4BA6D6FC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323BD68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323BD68 size=172
    let mut pc: u32 = 0x8323BD68;
    'dispatch: loop {
        match pc {
            0x8323BD68 => {
    //   block [0x8323BD68..0x8323BDD8)
	// 8323BD68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323BD6C: 4BA6D6A1  bl 0x82ca940c
	ctx.lr = 0x8323BD70;
	sub_82CA93D0(ctx, base);
	// 8323BD70: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323BD74: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8323BD78: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8323BD7C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8323BD80: 3BCBA39C  addi r30, r11, -0x5c64
	ctx.r[30].s64 = ctx.r[11].s64 + -23652;
	// 8323BD84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323BD88: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323BD8C: 389EFFEC  addi r4, r30, -0x14
	ctx.r[4].s64 = ctx.r[30].s64 + -20;
	// 8323BD90: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323BD94: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8323BD98: 4E800421  bctrl
	ctx.lr = 0x8323BD9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323BD9C: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8323BDA0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8323BDA4: 419A0068  beq cr6, 0x8323be0c
	if ctx.cr[6].eq {
	pc = 0x8323BE0C; continue 'dispatch;
	}
	// 8323BDA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8323BDAC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8323BDB0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8323BDB4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8323BDB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8323BDBC: 4AFF1115  bl 0x8222ced0
	ctx.lr = 0x8323BDC0;
	sub_8222CED0(ctx, base);
	// 8323BDC0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8323BDC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323BDC8: 409A0010  bne cr6, 0x8323bdd8
	if !ctx.cr[6].eq {
	pc = 0x8323BDD8; continue 'dispatch;
	}
	// 8323BDCC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8323BDD0: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 8323BDD4: 48000008  b 0x8323bddc
	pc = 0x8323BDDC; continue 'dispatch;
            }
            0x8323BDD8 => {
    //   block [0x8323BDD8..0x8323BDDC)
	// 8323BDD8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8323BDDC; continue 'dispatch;
            }
            0x8323BDDC => {
    //   block [0x8323BDDC..0x8323BE0C)
	// 8323BDDC: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 8323BDE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323BDE4: 4B1542A5  bl 0x82390088
	ctx.lr = 0x8323BDE8;
	sub_82390088(ctx, base);
	// 8323BDE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8323BDEC: 4AFD8FED  bl 0x82214dd8
	ctx.lr = 0x8323BDF0;
	sub_82214DD8(ctx, base);
	// 8323BDF0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323BDF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323BDF8: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8323BDFC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323BE00: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323BE04: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8323BE08: 4E800421  bctrl
	ctx.lr = 0x8323BE0C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8323BE0C => {
    //   block [0x8323BE0C..0x8323BE14)
	// 8323BE0C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8323BE10: 4BA6D64C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323BE18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323BE18 size=100
    let mut pc: u32 = 0x8323BE18;
    'dispatch: loop {
        match pc {
            0x8323BE18 => {
    //   block [0x8323BE18..0x8323BE7C)
	// 8323BE18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323BE1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8323BE20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8323BE24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8323BE28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323BE2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8323BE30: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8323BE34: 4AFB2D05  bl 0x821eeb38
	ctx.lr = 0x8323BE38;
	sub_821EEB38(ctx, base);
	// 8323BE38: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8323BE3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8323BE40: 4AFB2CF9  bl 0x821eeb38
	ctx.lr = 0x8323BE44;
	sub_821EEB38(ctx, base);
	// 8323BE44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8323BE48: 4B9C79A9  bl 0x82c037f0
	ctx.lr = 0x8323BE4C;
	sub_82C037F0(ctx, base);
	// 8323BE4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8323BE50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8323BE54: 4AFD8F85  bl 0x82214dd8
	ctx.lr = 0x8323BE58;
	sub_82214DD8(ctx, base);
	// 8323BE58: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 8323BE5C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8323BE60: 4AFD8F79  bl 0x82214dd8
	ctx.lr = 0x8323BE64;
	sub_82214DD8(ctx, base);
	// 8323BE64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8323BE68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8323BE6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8323BE70: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8323BE74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8323BE78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323BE80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323BE80 size=228
    let mut pc: u32 = 0x8323BE80;
    'dispatch: loop {
        match pc {
            0x8323BE80 => {
    //   block [0x8323BE80..0x8323BEF0)
	// 8323BE80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323BE84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8323BE88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8323BE8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8323BE90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323BE94: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8323BE98: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8323BE9C: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323BEA0: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 8323BEA4: 4198004C  blt cr6, 0x8323bef0
	if ctx.cr[6].lt {
	pc = 0x8323BEF0; continue 'dispatch;
	}
	// 8323BEA8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323BEAC: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 8323BEB0: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323BEB4: 38EAFFFC  addi r7, r10, -4
	ctx.r[7].s64 = ctx.r[10].s64 + -4;
	// 8323BEB8: 38CB0004  addi r6, r11, 4
	ctx.r[6].s64 = ctx.r[11].s64 + 4;
	// 8323BEBC: 38A90004  addi r5, r9, 4
	ctx.r[5].s64 = ctx.r[9].s64 + 4;
	// 8323BEC0: 888B0000  lbz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323BEC4: 98880000  stb r4, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[4].u8 ) };
	// 8323BEC8: 886B0001  lbz r3, 1(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 8323BECC: 98680001  stb r3, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[3].u8 ) };
	// 8323BED0: 894B0002  lbz r10, 2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 8323BED4: 99480002  stb r10, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[10].u8 ) };
	// 8323BED8: 892B0003  lbz r9, 3(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 8323BEDC: 99280003  stb r9, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[9].u8 ) };
	// 8323BEE0: 90DF000C  stw r6, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[6].u32 ) };
	// 8323BEE4: 90FF0014  stw r7, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	// 8323BEE8: 90BF0004  stw r5, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 8323BEEC: 48000014  b 0x8323bf00
	pc = 0x8323BF00; continue 'dispatch;
            }
            0x8323BEF0 => {
    //   block [0x8323BEF0..0x8323BF00)
	// 8323BEF0: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 8323BEF4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8323BEF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323BEFC: 4B7E4FED  bl 0x82a20ee8
	ctx.lr = 0x8323BF00;
	sub_82A20EE8(ctx, base);
	pc = 0x8323BF00; continue 'dispatch;
            }
            0x8323BF00 => {
    //   block [0x8323BF00..0x8323BF34)
	// 8323BF00: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323BF04: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8323BF08: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323BF0C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8323BF10: 419A0024  beq cr6, 0x8323bf34
	if ctx.cr[6].eq {
	pc = 0x8323BF34; continue 'dispatch;
	}
	// 8323BF14: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 8323BF18: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 8323BF1C: 89210057  lbz r9, 0x57(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(87 as u32) ) } as u64;
	// 8323BF20: 89010054  lbz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323BF24: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 8323BF28: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 8323BF2C: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 8323BF30: 99010053  stb r8, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[8].u8 ) };
	pc = 0x8323BF34; continue 'dispatch;
            }
            0x8323BF34 => {
    //   block [0x8323BF34..0x8323BF64)
	// 8323BF34: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8323BF38: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8323BF3C: 5564003E  slwi r4, r11, 0
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 8323BF40: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8323BF44: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323BF48: 48004F51  bl 0x83240e98
	ctx.lr = 0x8323BF4C;
	sub_83240E98(ctx, base);
	// 8323BF4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8323BF50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8323BF54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8323BF58: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8323BF5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8323BF60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323BF88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8323BF88 size=268
    let mut pc: u32 = 0x8323BF88;
    'dispatch: loop {
        match pc {
            0x8323BF88 => {
    //   block [0x8323BF88..0x8323C094)
	// 8323BF88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323BF8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8323BF90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8323BF94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8323BF98: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323BF9C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8323BFA0: 3880001A  li r4, 0x1a
	ctx.r[4].s64 = 26;
	// 8323BFA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8323BFA8: C01E00FC  lfs f0, 0xfc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323BFAC: 807E0130  lwz r3, 0x130(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(304 as u32) ) } as u64;
	// 8323BFB0: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 8323BFB4: D9A10060  stfd f13, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[13].u64 ) };
	// 8323BFB8: 80A10064  lwz r5, 0x64(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8323BFBC: 4BFE8F5D  bl 0x83224f18
	ctx.lr = 0x8323BFC0;
	sub_83224F18(ctx, base);
	// 8323BFC0: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 8323BFC4: D0210050  stfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8323BFC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323BFCC: 4BFED625  bl 0x832295f0
	ctx.lr = 0x8323BFD0;
	sub_832295F0(ctx, base);
	// 8323BFD0: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 8323BFD4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8323BFD8: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8323BFDC: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 8323BFE0: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 8323BFE4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8323BFE8: C0099484  lfs f0, -0x6b7c(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323C098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8323C098 size=664
    let mut pc: u32 = 0x8323C098;
    'dispatch: loop {
        match pc {
            0x8323C098 => {
    //   block [0x8323C098..0x8323C330)
	// 8323C098: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323C09C: 4BA6D371  bl 0x82ca940c
	ctx.lr = 0x8323C0A0;
	sub_82CA93D0(ctx, base);
	// 8323C0A0: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 8323C0A4: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8323C0A8: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323C330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323C330 size=120
    let mut pc: u32 = 0x8323C330;
    'dispatch: loop {
        match pc {
            0x8323C330 => {
    //   block [0x8323C330..0x8323C390)
	// 8323C330: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323C334: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8323C338: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8323C33C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8323C340: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323C344: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8323C348: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8323C34C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323C350: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323C354: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323C358: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323C35C: 4E800421  bctrl
	ctx.lr = 0x8323C360;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323C360: 2F030004  cmpwi cr6, r3, 4
	ctx.cr[6].compare_i32(ctx.r[3].s32, 4, &mut ctx.xer);
	// 8323C364: 409A002C  bne cr6, 0x8323c390
	if !ctx.cr[6].eq {
	pc = 0x8323C390; continue 'dispatch;
	}
	// 8323C368: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8323C36C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323C370: 4B7CE0D1  bl 0x82a0a440
	ctx.lr = 0x8323C374;
	sub_82A0A440(ctx, base);
	// 8323C374: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323C378: 83DE0130  lwz r30, 0x130(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(304 as u32) ) } as u64;
	// 8323C37C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8323C380: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323C384: 4BFE9B5D  bl 0x83225ee0
	ctx.lr = 0x8323C388;
	sub_83225EE0(ctx, base);
	// 8323C388: 897F00C0  lbz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 8323C38C: 997E00C0  stb r11, 0xc0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(192 as u32), ctx.r[11].u8 ) };
            }
            0x8323C390 => {
    //   block [0x8323C390..0x8323C3A8)
	// 8323C390: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8323C394: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8323C398: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8323C39C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8323C3A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8323C3A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323C3B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323C3B0 size=276
    let mut pc: u32 = 0x8323C3B0;
    'dispatch: loop {
        match pc {
            0x8323C3B0 => {
    //   block [0x8323C3B0..0x8323C40C)
	// 8323C3B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323C3B4: 4BA6D055  bl 0x82ca9408
	ctx.lr = 0x8323C3B8;
	sub_82CA93D0(ctx, base);
	// 8323C3B8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 8323C3BC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323C3C0: 83E500D4  lwz r31, 0xd4(r5)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(212 as u32) ) } as u64;
	// 8323C3C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8323C3C8: 83A500D0  lwz r29, 0xd0(r5)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(208 as u32) ) } as u64;
	// 8323C3CC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8323C3D0: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8323C3D4: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 8323C3D8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8323C3DC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8323C3E0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8323C3E4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8323C3E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8323C3EC: 419A0020  beq cr6, 0x8323c40c
	if ctx.cr[6].eq {
	pc = 0x8323C40C; continue 'dispatch;
	}
	// 8323C3F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8323C3F4: 4AF7B725  bl 0x821b7b18
	ctx.lr = 0x8323C3F8;
	sub_821B7B18(ctx, base);
	// 8323C3F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323C3FC: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 8323C400: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8323C404: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8323C408: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x8323C40C; continue 'dispatch;
            }
            0x8323C40C => {
    //   block [0x8323C40C..0x8323C438)
	// 8323C40C: 83FE00D4  lwz r31, 0xd4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(212 as u32) ) } as u64;
	// 8323C410: 83DE00D0  lwz r30, 0xd0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(208 as u32) ) } as u64;
	// 8323C414: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8323C418: 419A0020  beq cr6, 0x8323c438
	if ctx.cr[6].eq {
	pc = 0x8323C438; continue 'dispatch;
	}
	// 8323C41C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8323C420: 4AF7B6F9  bl 0x821b7b18
	ctx.lr = 0x8323C424;
	sub_821B7B18(ctx, base);
	// 8323C424: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323C428: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8323C42C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8323C430: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8323C434: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x8323C438; continue 'dispatch;
            }
            0x8323C438 => {
    //   block [0x8323C438..0x8323C464)
	// 8323C438: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 8323C43C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8323C440: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8323C444: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8323C448: 48006219  bl 0x83242660
	ctx.lr = 0x8323C44C;
	sub_83242660(ctx, base);
	// 8323C44C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323C450: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8323C454: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323C458: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323C45C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8323C460: 419A0020  beq cr6, 0x8323c480
	if ctx.cr[6].eq {
	pc = 0x8323C480; continue 'dispatch;
	}
	pc = 0x8323C464; continue 'dispatch;
            }
            0x8323C464 => {
    //   block [0x8323C464..0x8323C480)
	// 8323C464: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8323C468: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323C46C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8323C470: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8323C474: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8323C478: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323C47C: 4082FFE8  bne 0x8323c464
	if !ctx.cr[0].eq {
	pc = 0x8323C464; continue 'dispatch;
	}
	pc = 0x8323C480; continue 'dispatch;
            }
            0x8323C480 => {
    //   block [0x8323C480..0x8323C4C4)
	// 8323C480: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323C484: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8323C488: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8323C48C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8323C490: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323C494: 4E800421  bctrl
	ctx.lr = 0x8323C498;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323C498: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323C49C: 4AF7B67D  bl 0x821b7b18
	ctx.lr = 0x8323C4A0;
	sub_821B7B18(ctx, base);
	// 8323C4A0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8323C4A4: 4AF7B675  bl 0x821b7b18
	ctx.lr = 0x8323C4A8;
	sub_821B7B18(ctx, base);
	// 8323C4A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8323C4AC: 4AF7B66D  bl 0x821b7b18
	ctx.lr = 0x8323C4B0;
	sub_821B7B18(ctx, base);
	// 8323C4B0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8323C4B4: 4AF7B665  bl 0x821b7b18
	ctx.lr = 0x8323C4B8;
	sub_821B7B18(ctx, base);
	// 8323C4B8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8323C4BC: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 8323C4C0: 4BA6CF98  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323C4C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8323C4C8 size=4
    let mut pc: u32 = 0x8323C4C8;
    'dispatch: loop {
        match pc {
            0x8323C4C8 => {
    //   block [0x8323C4C8..0x8323C4CC)
	// 8323C4C8: 4BFED7B8  b 0x83229c80
	sub_83229C80(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323C4D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323C4D0 size=140
    let mut pc: u32 = 0x8323C4D0;
    'dispatch: loop {
        match pc {
            0x8323C4D0 => {
    //   block [0x8323C4D0..0x8323C508)
	// 8323C4D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323C4D4: 4BA6CF35  bl 0x82ca9408
	ctx.lr = 0x8323C4D8;
	sub_82CA93D0(ctx, base);
	// 8323C4D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323C4DC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8323C4E0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8323C4E4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8323C4E8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8323C4EC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 8323C4F0: 816BE6F0  lwz r11, -0x1910(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6416 as u32) ) } as u64;
	// 8323C4F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323C4F8: 409A0010  bne cr6, 0x8323c508
	if !ctx.cr[6].eq {
	pc = 0x8323C508; continue 'dispatch;
	}
	// 8323C4FC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8323C500: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 8323C504: 48000008  b 0x8323c50c
	pc = 0x8323C50C; continue 'dispatch;
            }
            0x8323C508 => {
    //   block [0x8323C508..0x8323C50C)
	// 8323C508: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8323C50C; continue 'dispatch;
            }
            0x8323C50C => {
    //   block [0x8323C50C..0x8323C554)
	// 8323C50C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323C510: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323C514: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323C518: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323C51C: 4E800421  bctrl
	ctx.lr = 0x8323C520;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323C520: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8323C524: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8323C528: 419A002C  beq cr6, 0x8323c554
	if ctx.cr[6].eq {
	pc = 0x8323C554; continue 'dispatch;
	}
	// 8323C52C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 8323C530: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8323C534: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8323C538: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323C53C: 480045DD  bl 0x83240b18
	ctx.lr = 0x8323C540;
	sub_83240B18(ctx, base);
	// 8323C540: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323C544: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323C548: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323C54C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323C550: 4E800421  bctrl
	ctx.lr = 0x8323C554;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8323C554 => {
    //   block [0x8323C554..0x8323C55C)
	// 8323C554: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8323C558: 4BA6CF00  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323C560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323C560 size=148
    let mut pc: u32 = 0x8323C560;
    'dispatch: loop {
        match pc {
            0x8323C560 => {
    //   block [0x8323C560..0x8323C594)
	// 8323C560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323C564: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8323C568: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8323C56C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8323C570: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323C574: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8323C578: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8323C57C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323C580: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323C584: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323C588: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8323C58C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8323C590: 419A0020  beq cr6, 0x8323c5b0
	if ctx.cr[6].eq {
	pc = 0x8323C5B0; continue 'dispatch;
	}
	pc = 0x8323C594; continue 'dispatch;
            }
            0x8323C594 => {
    //   block [0x8323C594..0x8323C5B0)
	// 8323C594: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8323C598: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323C59C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8323C5A0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8323C5A4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8323C5A8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323C5AC: 4082FFE8  bne 0x8323c594
	if !ctx.cr[0].eq {
	pc = 0x8323C594; continue 'dispatch;
	}
	pc = 0x8323C5B0; continue 'dispatch;
            }
            0x8323C5B0 => {
    //   block [0x8323C5B0..0x8323C5F4)
	// 8323C5B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8323C5B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323C5B8: 480045F1  bl 0x83240ba8
	ctx.lr = 0x8323C5BC;
	sub_83240BA8(ctx, base);
	// 8323C5BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8323C5C0: 4AF7B559  bl 0x821b7b18
	ctx.lr = 0x8323C5C4;
	sub_821B7B18(ctx, base);
	// 8323C5C4: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 8323C5C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323C5CC: 394B2398  addi r10, r11, 0x2398
	ctx.r[10].s64 = ctx.r[11].s64 + 9112;
	// 8323C5D0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8323C5D4: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323C5D8: 913F0130  stw r9, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[9].u32 ) };
	// 8323C5DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8323C5E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8323C5E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8323C5E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8323C5EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8323C5F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323C5F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323C5F8 size=220
    let mut pc: u32 = 0x8323C5F8;
    'dispatch: loop {
        match pc {
            0x8323C5F8 => {
    //   block [0x8323C5F8..0x8323C630)
	// 8323C5F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323C5FC: 4BA6CE11  bl 0x82ca940c
	ctx.lr = 0x8323C600;
	sub_82CA93D0(ctx, base);
	// 8323C600: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323C604: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8323C608: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
	// 8323C60C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8323C610: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8323C614: 4AFE2C45  bl 0x8221f258
	ctx.lr = 0x8323C618;
	sub_8221F258(ctx, base);
	// 8323C618: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8323C61C: 419A0014  beq cr6, 0x8323c630
	if ctx.cr[6].eq {
	pc = 0x8323C630; continue 'dispatch;
	}
	// 8323C620: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8323C624: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8323C628: 4BFFFF39  bl 0x8323c560
	ctx.lr = 0x8323C62C;
	sub_8323C560(ctx, base);
	// 8323C62C: 48000008  b 0x8323c634
	pc = 0x8323C634; continue 'dispatch;
            }
            0x8323C630 => {
    //   block [0x8323C630..0x8323C634)
	// 8323C630: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x8323C634; continue 'dispatch;
            }
            0x8323C634 => {
    //   block [0x8323C634..0x8323C674)
	// 8323C634: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 8323C638: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8323C63C: 419A0038  beq cr6, 0x8323c674
	if ctx.cr[6].eq {
	pc = 0x8323C674; continue 'dispatch;
	}
	// 8323C640: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8323C644: 4AFE2C15  bl 0x8221f258
	ctx.lr = 0x8323C648;
	sub_8221F258(ctx, base);
	// 8323C648: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8323C64C: 419A0028  beq cr6, 0x8323c674
	if ctx.cr[6].eq {
	pc = 0x8323C674; continue 'dispatch;
	}
	// 8323C650: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323C654: 3D208253  lis r9, -0x7dad
	ctx.r[9].s64 = -2108489728;
	// 8323C658: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 8323C65C: 38E99238  addi r7, r9, -0x6dc8
	ctx.r[7].s64 = ctx.r[9].s64 + -28104;
	// 8323C660: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 8323C664: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8323C668: 90E30004  stw r7, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 8323C66C: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8323C670: 48000008  b 0x8323c678
	pc = 0x8323C678; continue 'dispatch;
            }
            0x8323C674 => {
    //   block [0x8323C674..0x8323C678)
	// 8323C674: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8323C678; continue 'dispatch;
            }
            0x8323C678 => {
    //   block [0x8323C678..0x8323C694)
	// 8323C678: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323C67C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8323C680: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8323C684: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323C688: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8323C68C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8323C690: 419A0020  beq cr6, 0x8323c6b0
	if ctx.cr[6].eq {
	pc = 0x8323C6B0; continue 'dispatch;
	}
	pc = 0x8323C694; continue 'dispatch;
            }
            0x8323C694 => {
    //   block [0x8323C694..0x8323C6B0)
	// 8323C694: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8323C698: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323C69C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8323C6A0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8323C6A4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8323C6A8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323C6AC: 4082FFE8  bne 0x8323c694
	if !ctx.cr[0].eq {
	pc = 0x8323C694; continue 'dispatch;
	}
	pc = 0x8323C6B0; continue 'dispatch;
            }
            0x8323C6B0 => {
    //   block [0x8323C6B0..0x8323C6D4)
	// 8323C6B0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8323C6B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8323C6B8: 386BE48C  addi r3, r11, -0x1b74
	ctx.r[3].s64 = ctx.r[11].s64 + -7028;
	// 8323C6BC: 4B2146FD  bl 0x82450db8
	ctx.lr = 0x8323C6C0;
	sub_82450DB8(ctx, base);
	// 8323C6C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8323C6C4: 4AF7B455  bl 0x821b7b18
	ctx.lr = 0x8323C6C8;
	sub_821B7B18(ctx, base);
	// 8323C6C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323C6CC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8323C6D0: 4BA6CD8C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323C6D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323C6D8 size=92
    let mut pc: u32 = 0x8323C6D8;
    'dispatch: loop {
        match pc {
            0x8323C6D8 => {
    //   block [0x8323C6D8..0x8323C734)
	// 8323C6D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323C6DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8323C6E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8323C6E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8323C6E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323C6EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8323C6F0: 4BFEE9A1  bl 0x8322b090
	ctx.lr = 0x8323C6F4;
	sub_8322B090(ctx, base);
	// 8323C6F4: 809F00D0  lwz r4, 0xd0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 8323C6F8: 807F0120  lwz r3, 0x120(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 8323C6FC: 4BFE97E5  bl 0x83225ee0
	ctx.lr = 0x8323C700;
	sub_83225EE0(ctx, base);
	// 8323C700: 83DF00D0  lwz r30, 0xd0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 8323C704: 83FF0130  lwz r31, 0x130(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 8323C708: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8323C70C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323C710: 4BFE97D1  bl 0x83225ee0
	ctx.lr = 0x8323C714;
	sub_83225EE0(ctx, base);
	// 8323C714: 897E00C0  lbz r11, 0xc0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(192 as u32) ) } as u64;
	// 8323C718: 997F00C0  stb r11, 0xc0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[11].u8 ) };
	// 8323C71C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8323C720: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8323C724: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8323C728: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8323C72C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8323C730: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323C738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323C738 size=184
    let mut pc: u32 = 0x8323C738;
    'dispatch: loop {
        match pc {
            0x8323C738 => {
    //   block [0x8323C738..0x8323C778)
	// 8323C738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323C73C: 4BA6CCC5  bl 0x82ca9400
	ctx.lr = 0x8323C740;
	sub_82CA93D0(ctx, base);
	// 8323C740: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323C744: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8323C748: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8323C74C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8323C750: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8323C754: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 8323C758: 816BE6F0  lwz r11, -0x1910(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6416 as u32) ) } as u64;
	// 8323C75C: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 8323C760: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 8323C764: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323C768: 409A0010  bne cr6, 0x8323c778
	if !ctx.cr[6].eq {
	pc = 0x8323C778; continue 'dispatch;
	}
	// 8323C76C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8323C770: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 8323C774: 48000008  b 0x8323c77c
	pc = 0x8323C77C; continue 'dispatch;
            }
            0x8323C778 => {
    //   block [0x8323C778..0x8323C77C)
	// 8323C778: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8323C77C; continue 'dispatch;
            }
            0x8323C77C => {
    //   block [0x8323C77C..0x8323C7E8)
	// 8323C77C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323C780: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323C784: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323C788: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323C78C: 4E800421  bctrl
	ctx.lr = 0x8323C790;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323C790: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8323C794: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8323C798: 419A0050  beq cr6, 0x8323c7e8
	if ctx.cr[6].eq {
	pc = 0x8323C7E8; continue 'dispatch;
	}
	// 8323C79C: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 8323C7A0: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 8323C7A4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 8323C7A8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8323C7AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8323C7B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323C7B4: 480044CD  bl 0x83240c80
	ctx.lr = 0x8323C7B8;
	sub_83240C80(ctx, base);
	// 8323C7B8: 83BE00D0  lwz r29, 0xd0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(208 as u32) ) } as u64;
	// 8323C7BC: 83DE0130  lwz r30, 0x130(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(304 as u32) ) } as u64;
	// 8323C7C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8323C7C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323C7C8: 4BFE9719  bl 0x83225ee0
	ctx.lr = 0x8323C7CC;
	sub_83225EE0(ctx, base);
	// 8323C7CC: 897D00C0  lbz r11, 0xc0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(192 as u32) ) } as u64;
	// 8323C7D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323C7D4: 997E00C0  stb r11, 0xc0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(192 as u32), ctx.r[11].u8 ) };
	// 8323C7D8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323C7DC: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323C7E0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8323C7E4: 4E800421  bctrl
	ctx.lr = 0x8323C7E8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8323C7E8 => {
    //   block [0x8323C7E8..0x8323C7F0)
	// 8323C7E8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8323C7EC: 4BA6CC64  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323C7F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8323C7F0 size=72
    let mut pc: u32 = 0x8323C7F0;
    'dispatch: loop {
        match pc {
            0x8323C7F0 => {
    //   block [0x8323C7F0..0x8323C7FC)
	// 8323C7F0: 8123001C  lwz r9, 0x1c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 8323C7F4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8323C7F8: 419A002C  beq cr6, 0x8323c824
	if ctx.cr[6].eq {
	pc = 0x8323C824; continue 'dispatch;
	}
	pc = 0x8323C7FC; continue 'dispatch;
            }
            0x8323C7FC => {
    //   block [0x8323C7FC..0x8323C818)
	// 8323C7FC: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323C800: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8323C804: 41980014  blt cr6, 0x8323c818
	if ctx.cr[6].lt {
	pc = 0x8323C818; continue 'dispatch;
	}
	// 8323C808: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323C80C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8323C810: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8323C814: 41980014  blt cr6, 0x8323c828
	if ctx.cr[6].lt {
	pc = 0x8323C828; continue 'dispatch;
	}
	pc = 0x8323C818; continue 'dispatch;
            }
            0x8323C818 => {
    //   block [0x8323C818..0x8323C824)
	// 8323C818: 8129000C  lwz r9, 0xc(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323C81C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8323C820: 409AFFDC  bne cr6, 0x8323c7fc
	if !ctx.cr[6].eq {
	pc = 0x8323C7FC; continue 'dispatch;
	}
	pc = 0x8323C824; continue 'dispatch;
            }
            0x8323C824 => {
    //   block [0x8323C824..0x8323C828)
	// 8323C824: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x8323C828; continue 'dispatch;
            }
            0x8323C828 => {
    //   block [0x8323C828..0x8323C838)
	// 8323C828: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 8323C82C: 556ADFFE  rlwinm r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 8323C830: 69430001  xori r3, r10, 1
	ctx.r[3].u64 = ctx.r[10].u64 ^ 1;
	// 8323C834: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323C838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323C838 size=388
    let mut pc: u32 = 0x8323C838;
    'dispatch: loop {
        match pc {
            0x8323C838 => {
    //   block [0x8323C838..0x8323C878)
	// 8323C838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323C83C: 4BA6CBC5  bl 0x82ca9400
	ctx.lr = 0x8323C840;
	sub_82CA93D0(ctx, base);
	// 8323C840: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323C844: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8323C848: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8323C84C: 3B5F0020  addi r26, r31, 0x20
	ctx.r[26].s64 = ctx.r[31].s64 + 32;
	// 8323C850: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8323C854: 4B09A435  bl 0x822d6c88
	ctx.lr = 0x8323C858;
	sub_822D6C88(ctx, base);
	// 8323C858: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323C85C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 8323C860: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8323C864: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 8323C868: 7FBC5878  andc r28, r29, r11
	ctx.r[28].u64 = ctx.r[29].u64 & !ctx.r[11].u64;
	// 8323C86C: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323C870: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8323C874: 419A0020  beq cr6, 0x8323c894
	if ctx.cr[6].eq {
	pc = 0x8323C894; continue 'dispatch;
	}
	pc = 0x8323C878; continue 'dispatch;
            }
            0x8323C878 => {
    //   block [0x8323C878..0x8323C894)
	// 8323C878: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323C87C: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8323C880: 419A00A8  beq cr6, 0x8323c928
	if ctx.cr[6].eq {
	pc = 0x8323C928; continue 'dispatch;
	}
	// 8323C884: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 8323C888: 83DE0008  lwz r30, 8(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323C88C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8323C890: 409AFFE8  bne cr6, 0x8323c878
	if !ctx.cr[6].eq {
	pc = 0x8323C878; continue 'dispatch;
	}
	pc = 0x8323C894; continue 'dispatch;
            }
            0x8323C894 => {
    //   block [0x8323C894..0x8323C8EC)
	// 8323C894: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8323C898: 83CB6DC0  lwz r30, 0x6dc0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28096 as u32) ) } as u64;
	// 8323C89C: 387E000C  addi r3, r30, 0xc
	ctx.r[3].s64 = ctx.r[30].s64 + 12;
	// 8323C8A0: 4B09A3E9  bl 0x822d6c88
	ctx.lr = 0x8323C8A4;
	sub_822D6C88(ctx, base);
	// 8323C8A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323C8A8: 4BFF9B01  bl 0x832363a8
	ctx.lr = 0x8323C8AC;
	sub_832363A8(ctx, base);
	// 8323C8AC: 7C2004AC  lwsync
	// 8323C8B0: 937E000C  stw r27, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	// 8323C8B4: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 8323C8B8: 93830000  stw r28, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 8323C8BC: 937D0000  stw r27, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 8323C8C0: 93A30004  stw r29, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 8323C8C4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323C8C8: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323C8CC: 7D6A4396  divwu r11, r10, r8
	ctx.r[11].u32 = ctx.r[10].u32 / ctx.r[8].u32;
	// 8323C8D0: 38EBFFFF  addi r7, r11, -1
	ctx.r[7].s64 = ctx.r[11].s64 + -1;
	// 8323C8D4: 0CC80000  twi 6, r8, 0
	// 8323C8D8: 90E3000C  stw r7, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 8323C8DC: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323C8E0: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 8323C8E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323C8E8: 419A00BC  beq cr6, 0x8323c9a4
	if ctx.cr[6].eq {
	pc = 0x8323C9A4; continue 'dispatch;
	}
	pc = 0x8323C8EC; continue 'dispatch;
            }
            0x8323C8EC => {
    //   block [0x8323C8EC..0x8323C908)
	// 8323C8EC: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323C8F0: 7F08E040  cmplw cr6, r8, r28
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8323C8F4: 40980014  bge cr6, 0x8323c908
	if !ctx.cr[6].lt {
	pc = 0x8323C908; continue 'dispatch;
	}
	// 8323C8F8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 8323C8FC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323C900: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323C904: 409AFFE8  bne cr6, 0x8323c8ec
	if !ctx.cr[6].eq {
	pc = 0x8323C8EC; continue 'dispatch;
	}
	pc = 0x8323C908; continue 'dispatch;
            }
            0x8323C908 => {
    //   block [0x8323C908..0x8323C928)
	// 8323C908: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8323C90C: 419A0098  beq cr6, 0x8323c9a4
	if ctx.cr[6].eq {
	pc = 0x8323C9A4; continue 'dispatch;
	}
	// 8323C910: 90690008  stw r3, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 8323C914: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8323C918: 7C2004AC  lwsync
	// 8323C91C: 937A0000  stw r27, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 8323C920: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8323C924: 4BA6CB2C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x8323C928 => {
    //   block [0x8323C928..0x8323C94C)
	// 8323C928: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323C92C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8323C930: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 8323C934: 40820054  bne 0x8323c988
	if !ctx.cr[0].eq {
	pc = 0x8323C988; continue 'dispatch;
	}
	// 8323C938: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323C93C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323C940: 419A000C  beq cr6, 0x8323c94c
	if ctx.cr[6].eq {
	pc = 0x8323C94C; continue 'dispatch;
	}
	// 8323C944: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8323C948: 48000008  b 0x8323c950
	pc = 0x8323C950; continue 'dispatch;
            }
            0x8323C94C => {
    //   block [0x8323C94C..0x8323C950)
	// 8323C94C: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x8323C950; continue 'dispatch;
            }
            0x8323C950 => {
    //   block [0x8323C950..0x8323C988)
	// 8323C950: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 8323C954: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323C958: 4BFF9CD1  bl 0x83236628
	ctx.lr = 0x8323C95C;
	sub_83236628(ctx, base);
	// 8323C95C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323C960: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 8323C964: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 8323C968: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8323C96C: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 8323C970: 806A6DC0  lwz r3, 0x6dc0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28096 as u32) ) } as u64;
	// 8323C974: 4B7C53AD  bl 0x82a01d20
	ctx.lr = 0x8323C978;
	sub_82A01D20(ctx, base);
	// 8323C978: 7C2004AC  lwsync
	// 8323C97C: 937A0000  stw r27, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 8323C980: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8323C984: 4BA6CACC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x8323C988 => {
    //   block [0x8323C988..0x8323C9A4)
	// 8323C988: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323C98C: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8323C990: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 8323C994: 7C2004AC  lwsync
	// 8323C998: 937A0000  stw r27, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 8323C99C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8323C9A0: 4BA6CAB0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x8323C9A4 => {
    //   block [0x8323C9A4..0x8323C9BC)
	// 8323C9A4: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8323C9A8: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 8323C9AC: 7C2004AC  lwsync
	// 8323C9B0: 937A0000  stw r27, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 8323C9B4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8323C9B8: 4BA6CA98  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323C9C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323C9C8 size=164
    let mut pc: u32 = 0x8323C9C8;
    'dispatch: loop {
        match pc {
            0x8323C9C8 => {
    //   block [0x8323C9C8..0x8323CA24)
	// 8323C9C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323C9CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8323C9D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8323C9D4: 3BE1FF90  addi r31, r1, -0x70
	ctx.r[31].s64 = ctx.r[1].s64 + -112;
	// 8323C9D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323C9DC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8323C9E0: 4BA6DAA9  bl 0x82caa488
	ctx.lr = 0x8323C9E4;
	sub_82CAA488(ctx, base);
	// 8323C9E4: 907F0050  stw r3, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 8323C9E8: 907F0054  stw r3, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 8323C9EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8323C9F0: 419A0034  beq cr6, 0x8323ca24
	if ctx.cr[6].eq {
	pc = 0x8323CA24; continue 'dispatch;
	}
	// 8323C9F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8323C9F8: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 8323C9FC: 392000FF  li r9, 0xff
	ctx.r[9].s64 = 255;
	// 8323CA00: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8323CA04: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8323CA08: 3903000C  addi r8, r3, 0xc
	ctx.r[8].s64 = ctx.r[3].s64 + 12;
	// 8323CA0C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8323CA10: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 8323CA14: 911F0058  stw r8, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 8323CA18: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 8323CA1C: 90676DC0  stw r3, 0x6dc0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(28096 as u32), ctx.r[3].u32 ) };
	// 8323CA20: 4800000C  b 0x8323ca2c
	pc = 0x8323CA2C; continue 'dispatch;
            }
            0x8323CA24 => {
    //   block [0x8323CA24..0x8323CA2C)
	// 8323CA24: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8323CA28: 906B6DC0  stw r3, 0x6dc0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28096 as u32), ctx.r[3].u32 ) };
	pc = 0x8323CA2C; continue 'dispatch;
            }
            0x8323CA2C => {
    //   block [0x8323CA2C..0x8323CA6C)
	// 8323CA2C: 383F0070  addi r1, r31, 0x70
	ctx.r[1].s64 = ctx.r[31].s64 + 112;
	// 8323CA30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8323CA34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8323CA38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8323CA3C: 4E800020  blr
	return;
	// 8323CA40: 3BECFF90  addi r31, r12, -0x70
	ctx.r[31].s64 = ctx.r[12].s64 + -112;
	// 8323CA44: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323CA48: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8323CA4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323CA50: 809F0050  lwz r4, 0x50(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 8323CA54: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323CA58: 4B95A421  bl 0x82b96e78
	ctx.lr = 0x8323CA5C;
	sub_82B96E78(ctx, base);
	// 8323CA5C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8323CA60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8323CA64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8323CA68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323CAA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323CAA8 size=268
    let mut pc: u32 = 0x8323CAA8;
    'dispatch: loop {
        match pc {
            0x8323CAA8 => {
    //   block [0x8323CAA8..0x8323CAF4)
	// 8323CAA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323CAAC: 4BA6C955  bl 0x82ca9400
	ctx.lr = 0x8323CAB0;
	sub_82CA93D0(ctx, base);
	// 8323CAB0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323CAB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8323CAB8: 3B5F0020  addi r26, r31, 0x20
	ctx.r[26].s64 = ctx.r[31].s64 + 32;
	// 8323CABC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8323CAC0: 4B09A1C9  bl 0x822d6c88
	ctx.lr = 0x8323CAC4;
	sub_822D6C88(ctx, base);
	// 8323CAC4: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323CAC8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8323CACC: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 8323CAD0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8323CAD4: 409A0098  bne cr6, 0x8323cb6c
	if !ctx.cr[6].eq {
	pc = 0x8323CB6C; continue 'dispatch;
	}
	// 8323CAD8: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 8323CADC: 4BFF9D2D  bl 0x83236808
	ctx.lr = 0x8323CAE0;
	sub_83236808(ctx, base);
	// 8323CAE0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8323CAE4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8323CAE8: 409A000C  bne cr6, 0x8323caf4
	if !ctx.cr[6].eq {
	pc = 0x8323CAF4; continue 'dispatch;
	}
	// 8323CAEC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8323CAF0: 4BA6C960  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x8323CAF4 => {
    //   block [0x8323CAF4..0x8323CB4C)
	// 8323CAF4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323CAF8: 83DB6DC0  lwz r30, 0x6dc0(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28096 as u32) ) } as u64;
	// 8323CAFC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8323CB00: 387E000C  addi r3, r30, 0xc
	ctx.r[3].s64 = ctx.r[30].s64 + 12;
	// 8323CB04: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8323CB08: 4B09A181  bl 0x822d6c88
	ctx.lr = 0x8323CB0C;
	sub_822D6C88(ctx, base);
	// 8323CB0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323CB10: 4BFF9899  bl 0x832363a8
	ctx.lr = 0x8323CB14;
	sub_832363A8(ctx, base);
	// 8323CB14: 7C2004AC  lwsync
	// 8323CB18: 939E000C  stw r28, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 8323CB1C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8323CB20: 93A30000  stw r29, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 8323CB24: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 8323CB28: 93A30004  stw r29, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 8323CB2C: 93830008  stw r28, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 8323CB30: 9383000C  stw r28, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 8323CB34: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323CB38: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323CB3C: 0CCB0000  twi 6, r11, 0
	// 8323CB40: 7D095B96  divwu r8, r9, r11
	ctx.r[8].u32 = ctx.r[9].u32 / ctx.r[11].u32;
	// 8323CB44: 3528FFFF  addic. r9, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8323CB48: 4182001C  beq 0x8323cb64
	if ctx.cr[0].eq {
	pc = 0x8323CB64; continue 'dispatch;
	}
	pc = 0x8323CB4C; continue 'dispatch;
            }
            0x8323CB4C => {
    //   block [0x8323CB4C..0x8323CB64)
	// 8323CB4C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8323CB50: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8323CB54: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8323CB58: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323CB5C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8323CB60: 4082FFEC  bne 0x8323cb4c
	if !ctx.cr[0].eq {
	pc = 0x8323CB4C; continue 'dispatch;
	}
	pc = 0x8323CB64; continue 'dispatch;
            }
            0x8323CB64 => {
    //   block [0x8323CB64..0x8323CB6C)
	// 8323CB64: 938A0000  stw r28, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 8323CB68: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	pc = 0x8323CB6C; continue 'dispatch;
            }
            0x8323CB6C => {
    //   block [0x8323CB6C..0x8323CBA0)
	// 8323CB6C: 83C40004  lwz r30, 4(r4)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323CB70: 8164000C  lwz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323CB74: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8323CB78: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323CB7C: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 8323CB80: 5549003E  slwi r9, r10, 0
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8323CB84: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8323CB88: 91440004  stw r10, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8323CB8C: 409A0014  bne cr6, 0x8323cba0
	if !ctx.cr[6].eq {
	pc = 0x8323CBA0; continue 'dispatch;
	}
	// 8323CB90: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323CB94: 807B6DC0  lwz r3, 0x6dc0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28096 as u32) ) } as u64;
	// 8323CB98: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 8323CB9C: 4B7C5185  bl 0x82a01d20
	ctx.lr = 0x8323CBA0;
	sub_82A01D20(ctx, base);
	pc = 0x8323CBA0; continue 'dispatch;
            }
            0x8323CBA0 => {
    //   block [0x8323CBA0..0x8323CBB4)
	// 8323CBA0: 7C2004AC  lwsync
	// 8323CBA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323CBA8: 939A0000  stw r28, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 8323CBAC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8323CBB0: 4BA6C8A0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323CBB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8323CBB8 size=120
    let mut pc: u32 = 0x8323CBB8;
    'dispatch: loop {
        match pc {
            0x8323CBB8 => {
    //   block [0x8323CBB8..0x8323CBE4)
	// 8323CBB8: 81240010  lwz r9, 0x10(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323CBBC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8323CBC0: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323CBC4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8323CBC8: 550BF0BE  srwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8323CBCC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8323CBD0: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 8323CBD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323CBD8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 8323CBDC: 80A40008  lwz r5, 8(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323CBE0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	pc = 0x8323CBE4; continue 'dispatch;
            }
            0x8323CBE4 => {
    //   block [0x8323CBE4..0x8323CC20)
	// 8323CBE4: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323CBE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323CBEC: 419A0034  beq cr6, 0x8323cc20
	if ctx.cr[6].eq {
	pc = 0x8323CC20; continue 'dispatch;
	}
	// 8323CBF0: 80EB0018  lwz r7, 0x18(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8323CBF4: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 8323CBF8: 80C30000  lwz r6, 0(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323CBFC: 81030004  lwz r8, 4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323CC00: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323CC04: 7CE73214  add r7, r7, r6
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 8323CC08: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 8323CC0C: 7CC94214  add r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 8323CC10: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 8323CC14: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8323CC18: 90C30004  stw r6, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 8323CC1C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x8323CC20; continue 'dispatch;
            }
            0x8323CC20 => {
    //   block [0x8323CC20..0x8323CC30)
	// 8323CC20: 3484FFFF  addic. r4, r4, -1
	ctx.xer.ca = (ctx.r[4].u32 > (!(-1 as u32)));
	ctx.r[4].s64 = ctx.r[4].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 8323CC24: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 8323CC28: 4082FFBC  bne 0x8323cbe4
	if !ctx.cr[0].eq {
	pc = 0x8323CBE4; continue 'dispatch;
	}
	// 8323CC2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323CC50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323CC50 size=156
    let mut pc: u32 = 0x8323CC50;
    'dispatch: loop {
        match pc {
            0x8323CC50 => {
    //   block [0x8323CC50..0x8323CC78)
	// 8323CC50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323CC54: 4BA6C7B5  bl 0x82ca9408
	ctx.lr = 0x8323CC58;
	sub_82CA93D0(ctx, base);
	// 8323CC58: 3BE1FF80  addi r31, r1, -0x80
	ctx.r[31].s64 = ctx.r[1].s64 + -128;
	// 8323CC5C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323CC60: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8323CC64: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323CC68: 557EF0BE  srwi r30, r11, 2
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 8323CC6C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8323CC70: 419A0020  beq cr6, 0x8323cc90
	if ctx.cr[6].eq {
	pc = 0x8323CC90; continue 'dispatch;
	}
	// 8323CC74: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x8323CC78; continue 'dispatch;
            }
            0x8323CC78 => {
    //   block [0x8323CC78..0x8323CC90)
	// 8323CC78: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323CC7C: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 8323CC80: 4BA6F4C1  bl 0x82cac140
	ctx.lr = 0x8323CC84;
	sub_82CAC140(ctx, base);
	// 8323CC84: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8323CC88: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 8323CC8C: 4082FFEC  bne 0x8323cc78
	if !ctx.cr[0].eq {
	pc = 0x8323CC78; continue 'dispatch;
	}
	pc = 0x8323CC90; continue 'dispatch;
            }
            0x8323CC90 => {
    //   block [0x8323CC90..0x8323CCEC)
	// 8323CC90: 83DC000C  lwz r30, 0xc(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323CC94: 93DF0050  stw r30, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8323CC98: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 8323CC9C: 4BFF9B05  bl 0x832367a0
	ctx.lr = 0x8323CCA0;
	sub_832367A0(ctx, base);
	// 8323CCA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323CCA4: 4BA6F49D  bl 0x82cac140
	ctx.lr = 0x8323CCA8;
	sub_82CAC140(ctx, base);
	// 8323CCA8: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323CCAC: 4BA6F495  bl 0x82cac140
	ctx.lr = 0x8323CCB0;
	sub_82CAC140(ctx, base);
	// 8323CCB0: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323CCB4: 4BA6F48D  bl 0x82cac140
	ctx.lr = 0x8323CCB8;
	sub_82CAC140(ctx, base);
	// 8323CCB8: 383F0080  addi r1, r31, 0x80
	ctx.r[1].s64 = ctx.r[31].s64 + 128;
	// 8323CCBC: 4BA6C79C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 8323CCC0: 3BECFF80  addi r31, r12, -0x80
	ctx.r[31].s64 = ctx.r[12].s64 + -128;
	// 8323CCC4: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323CCC8: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8323CCCC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323CCD0: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 8323CCD4: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 8323CCD8: 4BFF9AC9  bl 0x832367a0
	ctx.lr = 0x8323CCDC;
	sub_832367A0(ctx, base);
	// 8323CCDC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8323CCE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8323CCE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8323CCE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323CCF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323CCF8 size=240
    let mut pc: u32 = 0x8323CCF8;
    'dispatch: loop {
        match pc {
            0x8323CCF8 => {
    //   block [0x8323CCF8..0x8323CD74)
	// 8323CCF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323CCFC: 4BA6C709  bl 0x82ca9404
	ctx.lr = 0x8323CD00;
	sub_82CA93D0(ctx, base);
	// 8323CD00: 3BE1FF70  addi r31, r1, -0x90
	ctx.r[31].s64 = ctx.r[1].s64 + -144;
	// 8323CD04: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323CD08: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8323CD0C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 8323CD10: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 8323CD14: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 8323CD18: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8323CD1C: 937E0000  stw r27, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 8323CD20: 4BA6D769  bl 0x82caa488
	ctx.lr = 0x8323CD24;
	sub_82CAA488(ctx, base);
	// 8323CD24: 907F0050  stw r3, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 8323CD28: 907F0054  stw r3, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 8323CD2C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8323CD30: 419A0044  beq cr6, 0x8323cd74
	if ctx.cr[6].eq {
	pc = 0x8323CD74; continue 'dispatch;
	}
	// 8323CD34: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8323CD38: 93830000  stw r28, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 8323CD3C: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8323CD40: 57A9843E  srwi r9, r29, 0x10
	ctx.r[9].u32 = ctx.r[29].u32.wrapping_shr(16);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8323CD44: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8323CD48: 39030010  addi r8, r3, 0x10
	ctx.r[8].s64 = ctx.r[3].s64 + 16;
	// 8323CD4C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8323CD50: 38E30020  addi r7, r3, 0x20
	ctx.r[7].s64 = ctx.r[3].s64 + 32;
	// 8323CD54: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 8323CD58: 91430010  stw r10, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8323CD5C: 93A30014  stw r29, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 8323CD60: 91230018  stw r9, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 8323CD64: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 8323CD68: 911F0058  stw r8, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 8323CD6C: 90FF0058  stw r7, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 8323CD70: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	pc = 0x8323CD74; continue 'dispatch;
            }
            0x8323CD74 => {
    //   block [0x8323CD74..0x8323CDE8)
	// 8323CD74: 907E000C  stw r3, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 8323CD78: 577D003A  rlwinm r29, r27, 0, 0, 0x1d
	ctx.r[29].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	// 8323CD7C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8323CD80: 4BA6D709  bl 0x82caa488
	ctx.lr = 0x8323CD84;
	sub_82CAA488(ctx, base);
	// 8323CD84: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8323CD88: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8323CD8C: 907E0008  stw r3, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 8323CD90: 4BA6CC21  bl 0x82ca99b0
	ctx.lr = 0x8323CD94;
	sub_82CA99B0(ctx, base);
	// 8323CD94: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 8323CD98: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8323CD9C: 4BA6D6ED  bl 0x82caa488
	ctx.lr = 0x8323CDA0;
	sub_82CAA488(ctx, base);
	// 8323CDA0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8323CDA4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8323CDA8: 907E0004  stw r3, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 8323CDAC: 4BA6CC05  bl 0x82ca99b0
	ctx.lr = 0x8323CDB0;
	sub_82CA99B0(ctx, base);
	// 8323CDB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323CDB4: 383F0090  addi r1, r31, 0x90
	ctx.r[1].s64 = ctx.r[31].s64 + 144;
	// 8323CDB8: 4BA6C69C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 8323CDBC: 3BECFF70  addi r31, r12, -0x90
	ctx.r[31].s64 = ctx.r[12].s64 + -144;
	// 8323CDC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323CDC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8323CDC8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323CDCC: 809F0050  lwz r4, 0x50(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 8323CDD0: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323CDD4: 4B95A0A5  bl 0x82b96e78
	ctx.lr = 0x8323CDD8;
	sub_82B96E78(ctx, base);
	// 8323CDD8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8323CDDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8323CDE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8323CDE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323CDE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8323CDE8 size=68
    let mut pc: u32 = 0x8323CDE8;
    'dispatch: loop {
        match pc {
            0x8323CDE8 => {
    //   block [0x8323CDE8..0x8323CDFC)
	// 8323CDE8: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 8323CDEC: 8083000C  lwz r4, 0xc(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323CDF0: 8104001C  lwz r8, 0x1c(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 8323CDF4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8323CDF8: 419A002C  beq cr6, 0x8323ce24
	if ctx.cr[6].eq {
	pc = 0x8323CE24; continue 'dispatch;
	}
	pc = 0x8323CDFC; continue 'dispatch;
            }
            0x8323CDFC => {
    //   block [0x8323CDFC..0x8323CE18)
	// 8323CDFC: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323CE00: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8323CE04: 41980014  blt cr6, 0x8323ce18
	if ctx.cr[6].lt {
	pc = 0x8323CE18; continue 'dispatch;
	}
	// 8323CE08: 81240014  lwz r9, 0x14(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323CE0C: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 8323CE10: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8323CE14: 41980018  blt cr6, 0x8323ce2c
	if ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x8323CE2C);
		return;
	}
	pc = 0x8323CE18; continue 'dispatch;
            }
            0x8323CE18 => {
    //   block [0x8323CE18..0x8323CE24)
	// 8323CE18: 8108000C  lwz r8, 0xc(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323CE1C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8323CE20: 409AFFDC  bne cr6, 0x8323cdfc
	if !ctx.cr[6].eq {
	pc = 0x8323CDFC; continue 'dispatch;
	}
	pc = 0x8323CE24; continue 'dispatch;
            }
            0x8323CE24 => {
    //   block [0x8323CE24..0x8323CE2C)
	// 8323CE24: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 8323CE28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323CE38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323CE38 size=128
    let mut pc: u32 = 0x8323CE38;
    'dispatch: loop {
        match pc {
            0x8323CE38 => {
    //   block [0x8323CE38..0x8323CE8C)
	// 8323CE38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323CE3C: 4BA6C5D1  bl 0x82ca940c
	ctx.lr = 0x8323CE40;
	sub_82CA93D0(ctx, base);
	// 8323CE40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323CE44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8323CE48: 90A10094  stw r5, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[5].u32 ) };
	// 8323CE4C: 54ABF0BE  srwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8323CE50: 90C1009C  stw r6, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[6].u32 ) };
	// 8323CE54: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8323CE58: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8323CE5C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323CE60: 557E103A  slwi r30, r11, 2
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 8323CE64: 7C6AF02E  lwzx r3, r10, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 8323CE68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8323CE6C: 419A0020  beq cr6, 0x8323ce8c
	if ctx.cr[6].eq {
	pc = 0x8323CE8C; continue 'dispatch;
	}
	// 8323CE70: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 8323CE74: 4BFF9E95  bl 0x83236d08
	ctx.lr = 0x8323CE78;
	sub_83236D08(ctx, base);
	// 8323CE78: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323CE7C: 57AA003A  rlwinm r10, r29, 0, 0, 0x1d
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 8323CE80: 7C6A592E  stwx r3, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[3].u32) };
	// 8323CE84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8323CE88: 4BA6C5D4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x8323CE8C => {
    //   block [0x8323CE8C..0x8323CEB8)
	// 8323CE8C: 38A1009C  addi r5, r1, 0x9c
	ctx.r[5].s64 = ctx.r[1].s64 + 156;
	// 8323CE90: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 8323CE94: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 8323CE98: 4B7C4CA9  bl 0x82a01b40
	ctx.lr = 0x8323CE9C;
	sub_82A01B40(ctx, base);
	// 8323CE9C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323CEA0: 57AA003A  rlwinm r10, r29, 0, 0, 0x1d
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 8323CEA4: 7C6BF12E  stwx r3, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[3].u32) };
	// 8323CEA8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323CEAC: 7C6A592E  stwx r3, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[3].u32) };
	// 8323CEB0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8323CEB4: 4BA6C5A8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323CEB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8323CEB8 size=16
    let mut pc: u32 = 0x8323CEB8;
    'dispatch: loop {
        match pc {
            0x8323CEB8 => {
    //   block [0x8323CEB8..0x8323CEC8)
	// 8323CEB8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8323CEBC: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 8323CEC0: 808B000C  lwz r4, 0xc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323CEC4: 4BFF9E9C  b 0x83236d60
	sub_83236D60(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323CEC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8323CEC8 size=20
    let mut pc: u32 = 0x8323CEC8;
    'dispatch: loop {
        match pc {
            0x8323CEC8 => {
    //   block [0x8323CEC8..0x8323CEDC)
	// 8323CEC8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323CECC: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8323CED0: 4099000C  ble cr6, 0x8323cedc
	if !ctx.cr[6].gt {
		sub_8323CEDC(ctx, base);
		return;
	}
	// 8323CED4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8323CED8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323CEDC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8323CEDC size=20
    let mut pc: u32 = 0x8323CEDC;
    'dispatch: loop {
        match pc {
            0x8323CEDC => {
    //   block [0x8323CEDC..0x8323CEF0)
	// 8323CEDC: 39640003  addi r11, r4, 3
	ctx.r[11].s64 = ctx.r[4].s64 + 3;
	// 8323CEE0: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323CEE4: 5569003A  rlwinm r9, r11, 0, 0, 0x1d
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8323CEE8: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8323CEEC: 4BFFA014  b 0x83236f00
	sub_83236F00(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323CEF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8323CEF0 size=200
    let mut pc: u32 = 0x8323CEF0;
    'dispatch: loop {
        match pc {
            0x8323CEF0 => {
    //   block [0x8323CEF0..0x8323CF44)
	// 8323CEF0: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 8323CEF4: C0030018  lfs f0, 0x18(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323CEF8: 3D208336  lis r9, -0x7cca
	ctx.r[9].s64 = -2093613056;
	// 8323CEFC: C1650000  lfs f11, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8323CF00: C1440000  lfs f10, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8323CF04: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8323CF08: 3929F1BC  addi r9, r9, -0xe44
	ctx.r[9].s64 = ctx.r[9].s64 + -3652;
	// 8323CF0C: 396BD5C8  addi r11, r11, -0x2a38
	ctx.r[11].s64 = ctx.r[11].s64 + -10808;
	// 8323CF10: 814A6DD4  lwz r10, 0x6dd4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28116 as u32) ) } as u64;
	// 8323CF14: 39090018  addi r8, r9, 0x18
	ctx.r[8].s64 = ctx.r[9].s64 + 24;
	// 8323CF18: 5547103A  slwi r7, r10, 2
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 8323CF1C: C1ABBEBC  lfs f13, -0x4144(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16708 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8323CF20: C18BBEC8  lfs f12, -0x4138(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16696 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8323CF24: 7D27442E  lfsx f9, r7, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8323CF28: ED090032  fmuls f8, f9, f0
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 8323CF2C: EC0852FA  fmadds f0, f8, f11, f10
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[11].f64 + ctx.f[10].f64) as f32) as f64);
	// 8323CF30: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8323CF34: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8323CF38: 4198000C  blt cr6, 0x8323cf44
	if ctx.cr[6].lt {
	pc = 0x8323CF44; continue 'dispatch;
	}
	// 8323CF3C: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 8323CF40: 40990028  ble cr6, 0x8323cf68
	if !ctx.cr[6].gt {
	pc = 0x8323CF68; continue 'dispatch;
	}
	pc = 0x8323CF44; continue 'dispatch;
            }
            0x8323CF44 => {
    //   block [0x8323CF44..0x8323CF64)
	// 8323CF44: 89430015  lbz r10, 0x15(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(21 as u32) ) } as u64;
	// 8323CF48: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323CF4C: 419A0018  beq cr6, 0x8323cf64
	if ctx.cr[6].eq {
	pc = 0x8323CF64; continue 'dispatch;
	}
	// 8323CF50: C1650000  lfs f11, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8323CF54: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323CF58: ED4B0032  fmuls f10, f11, f0
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 8323CF5C: D1450000  stfs f10, 0(r5)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8323CF60: 48000008  b 0x8323cf68
	pc = 0x8323CF68; continue 'dispatch;
            }
            0x8323CF64 => {
    //   block [0x8323CF64..0x8323CF68)
	// 8323CF64: D1A40000  stfs f13, 0(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x8323CF68; continue 'dispatch;
            }
            0x8323CF68 => {
    //   block [0x8323CF68..0x8323CFB8)
	// 8323CF68: C0040000  lfs f0, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323CF6C: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 8323CF70: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8323CF74: 7D400026  mfcr r10
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[10].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 8323CF78: 5549DF7A  rlwinm r9, r10, 0x1b, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 8323CF7C: 5548F77A  rlwinm r8, r10, 0x1e, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 8323CF80: 38EB0E68  addi r7, r11, 0xe68
	ctx.r[7].s64 = ctx.r[11].s64 + 3688;
	// 8323CF84: 7D264378  or r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 8323CF88: 7D67342E  lfsx f11, r7, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8323CF8C: FD4B682E  fsel f10, f11, f0, f13
	ctx.f[10].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 8323CF90: ED2A6028  fsubs f9, f10, f12
	ctx.f[9].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 8323CF94: FF096800  fcmpu cr6, f9, f13
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[13].f64);
	// 8323CF98: 7CA00026  mfcr r5
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[5].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[5].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 8323CF9C: 54A3DF7A  rlwinm r3, r5, 0x1b, 0x1d, 0x1d
	ctx.r[3].u64 = ctx.r[5].u32 as u64 & 0x0000001Fu64;
	// 8323CFA0: 54ABF77A  rlwinm r11, r5, 0x1e, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x00000003u64;
	// 8323CFA4: 7C6A5B78  or r10, r3, r11
	ctx.r[10].u64 = ctx.r[3].u64 | ctx.r[11].u64;
	// 8323CFA8: 7D07542E  lfsx f8, r7, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 8323CFAC: FCE8532E  fsel f7, f8, f12, f10
	ctx.f[7].f64 = if ctx.f[8].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[10].f64 };
	// 8323CFB0: D0E40000  stfs f7, 0(r4)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8323CFB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323CFB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323CFB8 size=84
    let mut pc: u32 = 0x8323CFB8;
    'dispatch: loop {
        match pc {
            0x8323CFB8 => {
    //   block [0x8323CFB8..0x8323CFE8)
	// 8323CFB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323CFBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8323CFC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8323CFC4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323CFC8: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 8323CFCC: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 8323CFD0: 394B2808  addi r10, r11, 0x2808
	ctx.r[10].s64 = ctx.r[11].s64 + 10248;
	// 8323CFD4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8323CFD8: 80630008  lwz r3, 8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323CFDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8323CFE0: 419A0008  beq cr6, 0x8323cfe8
	if ctx.cr[6].eq {
	pc = 0x8323CFE8; continue 'dispatch;
	}
	// 8323CFE4: 4AFDED55  bl 0x8221bd38
	ctx.lr = 0x8323CFE8;
	sub_8221BD38(ctx, base);
	pc = 0x8323CFE8; continue 'dispatch;
            }
            0x8323CFE8 => {
    //   block [0x8323CFE8..0x8323D00C)
	// 8323CFE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8323CFEC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8323CFF0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8323CFF4: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 8323CFF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8323CFFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8323D000: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8323D004: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8323D008: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323D010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8323D010 size=504
    let mut pc: u32 = 0x8323D010;
    'dispatch: loop {
        match pc {
            0x8323D010 => {
    //   block [0x8323D010..0x8323D090)
	// 8323D010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323D014: 4BA6C3F5  bl 0x82ca9408
	ctx.lr = 0x8323D018;
	sub_82CA93D0(ctx, base);
	// 8323D018: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323D01C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8323D020: 3C8050B5  lis r4, 0x50b5
	ctx.r[4].s64 = 1354039296;
	// 8323D024: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8323D028: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323D02C: 6084F001  ori r4, r4, 0xf001
	ctx.r[4].u64 = ctx.r[4].u64 | 61441;
	// 8323D030: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8323D034: 4B7E55C5  bl 0x82a225f8
	ctx.lr = 0x8323D038;
	sub_82A225F8(ctx, base);
	// 8323D038: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8323D03C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323D040: 4B7E55B9  bl 0x82a225f8
	ctx.lr = 0x8323D044;
	sub_82A225F8(ctx, base);
	// 8323D044: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8323D048: 409A0048  bne cr6, 0x8323d090
	if !ctx.cr[6].eq {
	pc = 0x8323D090; continue 'dispatch;
	}
	// 8323D04C: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323D050: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323D054: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323D058: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8323D05C: 7D3E2670  srawi r30, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[9].s32 >> 4) as i64;
	// 8323D060: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8323D064: 4B7E5595  bl 0x82a225f8
	ctx.lr = 0x8323D068;
	sub_82A225F8(ctx, base);
	// 8323D068: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8323D06C: 40990024  ble cr6, 0x8323d090
	if !ctx.cr[6].gt {
	pc = 0x8323D090; continue 'dispatch;
	}
	// 8323D070: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8323D074: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323D078: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x8323D090; continue 'dispatch;
            }
            0x8323D090 => {
    //   block [0x8323D090..0x8323D208)
	// 8323D090: 897C0014  lbz r11, 0x14(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323D094: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8323D098: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323D09C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8323D0A0: 7D690034  cntlzw r9, r11
	ctx.r[9].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8323D0A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323D0A8: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 8323D0AC: 69070001  xori r7, r8, 1
	ctx.r[7].u64 = ctx.r[8].u64 ^ 1;
	// 8323D0B0: 80CA0010  lwz r6, 0x10(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323D0B4: 98E10050  stb r7, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u8 ) };
	// 8323D0B8: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 8323D0BC: 4E800421  bctrl
	ctx.lr = 0x8323D0C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323D0C0: 897C0015  lbz r11, 0x15(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(21 as u32) ) } as u64;
	// 8323D0C4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323D0C8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8323D0CC: 7D690034  cntlzw r9, r11
	ctx.r[9].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8323D0D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8323D0D4: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 8323D0D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323D0DC: 69070001  xori r7, r8, 1
	ctx.r[7].u64 = ctx.r[8].u64 ^ 1;
	// 8323D0E0: 80CA0010  lwz r6, 0x10(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323D0E4: 98E10050  stb r7, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u8 ) };
	// 8323D0E8: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 8323D0EC: 4E800421  bctrl
	ctx.lr = 0x8323D0F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323D0F0: 88BF0008  lbz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323D0F4: C01C0018  lfs f0, 0x18(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323D0F8: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8323D0FC: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 8323D100: 419A0024  beq cr6, 0x8323d124
	if ctx.cr[6].eq {
	pc = 0x8323D124; continue 'dispatch;
	}
	// 8323D104: 89610054  lbz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323D108: 89410055  lbz r10, 0x55(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(85 as u32) ) } as u64;
	// 8323D10C: 89210057  lbz r9, 0x57(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(87 as u32) ) } as u64;
	// 8323D110: 89010056  lbz r8, 0x56(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 8323D114: 99610057  stb r11, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[11].u8 ) };
	// 8323D118: 99410056  stb r10, 0x56(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[10].u8 ) };
	// 8323D11C: 99210054  stb r9, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u8 ) };
	// 8323D120: 99010055  stb r8, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[8].u8 ) };
	// 8323D124: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323D128: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 8323D12C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8323D130: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323D134: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323D138: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323D13C: 4E800421  bctrl
	ctx.lr = 0x8323D140;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323D140: 893C001C  lbz r9, 0x1c(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 8323D144: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323D148: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8323D14C: 7D270034  cntlzw r7, r9
	ctx.r[7].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 8323D150: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8323D154: 54E6DFFE  rlwinm r6, r7, 0x1b, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 8323D158: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323D15C: 68CB0001  xori r11, r6, 1
	ctx.r[11].u64 = ctx.r[6].u64 ^ 1;
	// 8323D160: 81480010  lwz r10, 0x10(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323D164: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 8323D168: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323D16C: 4E800421  bctrl
	ctx.lr = 0x8323D170;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323D170: 893C001D  lbz r9, 0x1d(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(29 as u32) ) } as u64;
	// 8323D174: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323D178: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8323D17C: 7D270034  cntlzw r7, r9
	ctx.r[7].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 8323D180: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8323D184: 54E6DFFE  rlwinm r6, r7, 0x1b, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 8323D188: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323D18C: 68CB0001  xori r11, r6, 1
	ctx.r[11].u64 = ctx.r[6].u64 ^ 1;
	// 8323D190: 81480010  lwz r10, 0x10(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323D194: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 8323D198: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323D19C: 4E800421  bctrl
	ctx.lr = 0x8323D1A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323D1A0: 893C001E  lbz r9, 0x1e(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(30 as u32) ) } as u64;
	// 8323D1A4: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323D1A8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8323D1AC: 7D270034  cntlzw r7, r9
	ctx.r[7].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 8323D1B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8323D1B4: 54E6DFFE  rlwinm r6, r7, 0x1b, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 8323D1B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323D1BC: 68CB0001  xori r11, r6, 1
	ctx.r[11].u64 = ctx.r[6].u64 ^ 1;
	// 8323D1C0: 81480010  lwz r10, 0x10(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323D1C4: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 8323D1C8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323D1CC: 4E800421  bctrl
	ctx.lr = 0x8323D1D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323D1D0: 893C001F  lbz r9, 0x1f(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(31 as u32) ) } as u64;
	// 8323D1D4: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323D1D8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8323D1DC: 7D270034  cntlzw r7, r9
	ctx.r[7].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 8323D1E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8323D1E4: 54E6DFFE  rlwinm r6, r7, 0x1b, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 8323D1E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323D1EC: 68CB0001  xori r11, r6, 1
	ctx.r[11].u64 = ctx.r[6].u64 ^ 1;
	// 8323D1F0: 81480010  lwz r10, 0x10(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323D1F4: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 8323D1F8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323D1FC: 4E800421  bctrl
	ctx.lr = 0x8323D200;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323D200: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8323D204: 4BA6C254  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323D208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323D208 size=48
    let mut pc: u32 = 0x8323D208;
    'dispatch: loop {
        match pc {
            0x8323D208 => {
    //   block [0x8323D208..0x8323D238)
	// 8323D208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323D20C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8323D210: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323D214: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 8323D218: 39800080  li r12, 0x80
	ctx.r[12].s64 = 128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323D238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8323D238 size=180
    let mut pc: u32 = 0x8323D238;
    'dispatch: loop {
        match pc {
            0x8323D238 => {
    //   block [0x8323D238..0x8323D2EC)
	// 8323D238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323D23C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8323D240: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8323D244: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8323D248: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323D2F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8323D2F0 size=180
    let mut pc: u32 = 0x8323D2F0;
    'dispatch: loop {
        match pc {
            0x8323D2F0 => {
    //   block [0x8323D2F0..0x8323D3A4)
	// 8323D2F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323D2F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8323D2F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8323D2FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8323D300: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323D3A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8323D3A8 size=108
    let mut pc: u32 = 0x8323D3A8;
    'dispatch: loop {
        match pc {
            0x8323D3A8 => {
    //   block [0x8323D3A8..0x8323D414)
	// 8323D3A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323D3AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8323D3B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8323D3B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8323D3B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323D3BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8323D3C0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8323D3C4: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 8323D3C8: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 8323D3CC: 4B60FCF5  bl 0x8284d0c0
	ctx.lr = 0x8323D3D0;
	sub_8284D0C0(ctx, base);
	// 8323D3D0: 897E0014  lbz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323D3D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323D3D8: 997F0014  stb r11, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 8323D3DC: 895E0015  lbz r10, 0x15(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(21 as u32) ) } as u64;
	// 8323D3E0: 995F0015  stb r10, 0x15(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(21 as u32), ctx.r[10].u8 ) };
	// 8323D3E4: C01E0018  lfs f0, 0x18(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323D3E8: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8323D3EC: 893E001E  lbz r9, 0x1e(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(30 as u32) ) } as u64;
	// 8323D3F0: 993F001E  stb r9, 0x1e(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(30 as u32), ctx.r[9].u8 ) };
	// 8323D3F4: 891E001F  lbz r8, 0x1f(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(31 as u32) ) } as u64;
	// 8323D3F8: 991F001F  stb r8, 0x1f(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(31 as u32), ctx.r[8].u8 ) };
	// 8323D3FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8323D400: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8323D404: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8323D408: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8323D40C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8323D410: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323D418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8323D418 size=136
    let mut pc: u32 = 0x8323D418;
    'dispatch: loop {
        match pc {
            0x8323D418 => {
    //   block [0x8323D418..0x8323D4A0)
	// 8323D418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323D41C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8323D420: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8323D424: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8323D428: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323D42C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8323D430: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 8323D434: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8323D438: 394B2808  addi r10, r11, 0x2808
	ctx.r[10].s64 = ctx.r[11].s64 + 10248;
	// 8323D43C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 8323D440: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8323D444: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 8323D448: 4B64C771  bl 0x82889bb8
	ctx.lr = 0x8323D44C;
	sub_82889BB8(ctx, base);
	// 8323D44C: 893E0014  lbz r9, 0x14(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323D450: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323D454: 993F0014  stb r9, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u8 ) };
	// 8323D458: 891E0015  lbz r8, 0x15(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(21 as u32) ) } as u64;
	// 8323D45C: 991F0015  stb r8, 0x15(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(21 as u32), ctx.r[8].u8 ) };
	// 8323D460: C01E0018  lfs f0, 0x18(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323D464: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8323D468: 88FE001C  lbz r7, 0x1c(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 8323D46C: 98FF001C  stb r7, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[7].u8 ) };
	// 8323D470: 88DE001D  lbz r6, 0x1d(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(29 as u32) ) } as u64;
	// 8323D474: 98DF001D  stb r6, 0x1d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(29 as u32), ctx.r[6].u8 ) };
	// 8323D478: 88BE001E  lbz r5, 0x1e(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(30 as u32) ) } as u64;
	// 8323D47C: 98BF001E  stb r5, 0x1e(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(30 as u32), ctx.r[5].u8 ) };
	// 8323D480: 889E001F  lbz r4, 0x1f(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(31 as u32) ) } as u64;
	// 8323D484: 989F001F  stb r4, 0x1f(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(31 as u32), ctx.r[4].u8 ) };
	// 8323D488: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8323D48C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8323D490: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8323D494: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8323D498: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8323D49C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323D4A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8323D4A0 size=1400
    let mut pc: u32 = 0x8323D4A0;
    'dispatch: loop {
        match pc {
            0x8323D4A0 => {
    //   block [0x8323D4A0..0x8323D528)
	// 8323D4A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323D4A4: 4BA6BF5D  bl 0x82ca9400
	ctx.lr = 0x8323D4A8;
	sub_82CA93D0(ctx, base);
	// 8323D4A8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323D4AC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8323D4B0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8323D4B4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8323D4B8: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 8323D4BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323D4C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323D4C4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323D4C8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323D4CC: 4E800421  bctrl
	ctx.lr = 0x8323D4D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323D4D0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323D4D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8323D4D8: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 8323D4DC: 4198004C  blt cr6, 0x8323d528
	if ctx.cr[6].lt {
	pc = 0x8323D528; continue 'dispatch;
	}
	// 8323D4E0: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 8323D4E4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323D4E8: 3901005C  addi r8, r1, 0x5c
	ctx.r[8].s64 = ctx.r[1].s64 + 92;
	// 8323D4EC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323D4F0: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 8323D4F4: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 8323D4F8: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323D4FC: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 8323D500: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 8323D504: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 8323D508: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 8323D50C: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 8323D510: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 8323D514: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 8323D518: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 8323D51C: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 8323D520: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 8323D524: 48000014  b 0x8323d538
	pc = 0x8323D538; continue 'dispatch;
            }
            0x8323D528 => {
    //   block [0x8323D528..0x8323D538)
	// 8323D528: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 8323D52C: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 8323D530: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323D534: 4B7E39B5  bl 0x82a20ee8
	ctx.lr = 0x8323D538;
	sub_82A20EE8(ctx, base);
	pc = 0x8323D538; continue 'dispatch;
            }
            0x8323D538 => {
    //   block [0x8323D538..0x8323D56C)
	// 8323D538: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8323D53C: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8323D540: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323D544: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8323D548: 419A0024  beq cr6, 0x8323d56c
	if ctx.cr[6].eq {
	pc = 0x8323D56C; continue 'dispatch;
	}
	// 8323D54C: 89610059  lbz r11, 0x59(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 8323D550: 8941005A  lbz r10, 0x5a(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(90 as u32) ) } as u64;
	// 8323D554: 8921005F  lbz r9, 0x5f(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(95 as u32) ) } as u64;
	// 8323D558: 8901005C  lbz r8, 0x5c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8323D55C: 9961005A  stb r11, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[11].u8 ) };
	// 8323D560: 99410059  stb r10, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[10].u8 ) };
	// 8323D564: 99210058  stb r9, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 8323D568: 9901005B  stb r8, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[8].u8 ) };
	pc = 0x8323D56C; continue 'dispatch;
            }
            0x8323D56C => {
    //   block [0x8323D56C..0x8323D5D4)
	// 8323D56C: 3D6050B5  lis r11, 0x50b5
	ctx.r[11].s64 = 1354039296;
	// 8323D570: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8323D574: 6169F001  ori r9, r11, 0xf001
	ctx.r[9].u64 = ctx.r[11].u64 | 61441;
	// 8323D578: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8323D57C: 409A00A4  bne cr6, 0x8323d620
	if !ctx.cr[6].eq {
	pc = 0x8323D620; continue 'dispatch;
	}
	// 8323D580: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323D584: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 8323D588: 4198004C  blt cr6, 0x8323d5d4
	if ctx.cr[6].lt {
	pc = 0x8323D5D4; continue 'dispatch;
	}
	// 8323D58C: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 8323D590: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323D594: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 8323D598: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323D59C: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 8323D5A0: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 8323D5A4: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323D5A8: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 8323D5AC: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 8323D5B0: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 8323D5B4: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 8323D5B8: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 8323D5BC: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 8323D5C0: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 8323D5C4: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 8323D5C8: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 8323D5CC: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 8323D5D0: 48000014  b 0x8323d5e4
	pc = 0x8323D5E4; continue 'dispatch;
            }
            0x8323D5D4 => {
    //   block [0x8323D5D4..0x8323D5E4)
	// 8323D5D4: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 8323D5D8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8323D5DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323D5E0: 4B7E3909  bl 0x82a20ee8
	ctx.lr = 0x8323D5E4;
	sub_82A20EE8(ctx, base);
	pc = 0x8323D5E4; continue 'dispatch;
            }
            0x8323D5E4 => {
    //   block [0x8323D5E4..0x8323D618)
	// 8323D5E4: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8323D5E8: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8323D5EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323D5F0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8323D5F4: 419A0024  beq cr6, 0x8323d618
	if ctx.cr[6].eq {
	pc = 0x8323D618; continue 'dispatch;
	}
	// 8323D5F8: 89610059  lbz r11, 0x59(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 8323D5FC: 8941005A  lbz r10, 0x5a(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(90 as u32) ) } as u64;
	// 8323D600: 89210063  lbz r9, 0x63(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(99 as u32) ) } as u64;
	// 8323D604: 89010060  lbz r8, 0x60(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8323D608: 9961005A  stb r11, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[11].u8 ) };
	// 8323D60C: 99410059  stb r10, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[10].u8 ) };
	// 8323D610: 99210058  stb r9, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 8323D614: 9901005B  stb r8, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[8].u8 ) };
	pc = 0x8323D618; continue 'dispatch;
            }
            0x8323D618 => {
    //   block [0x8323D618..0x8323D620)
	// 8323D618: 83410058  lwz r26, 0x58(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8323D61C: 4800001C  b 0x8323d638
	pc = 0x8323D638; continue 'dispatch;
            }
            0x8323D620 => {
    //   block [0x8323D620..0x8323D638)
	// 8323D620: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323D624: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8323D628: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323D62C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323D630: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323D634: 4E800421  bctrl
	ctx.lr = 0x8323D638;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8323D638 => {
    //   block [0x8323D638..0x8323D694)
	// 8323D638: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8323D63C: 409A00E4  bne cr6, 0x8323d720
	if !ctx.cr[6].eq {
	pc = 0x8323D720; continue 'dispatch;
	}
	// 8323D640: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323D644: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 8323D648: 4198004C  blt cr6, 0x8323d694
	if ctx.cr[6].lt {
	pc = 0x8323D694; continue 'dispatch;
	}
	// 8323D64C: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 8323D650: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323D654: 39010064  addi r8, r1, 0x64
	ctx.r[8].s64 = ctx.r[1].s64 + 100;
	// 8323D658: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323D65C: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 8323D660: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 8323D664: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323D668: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 8323D66C: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 8323D670: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 8323D674: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 8323D678: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 8323D67C: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 8323D680: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 8323D684: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 8323D688: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 8323D68C: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 8323D690: 48000014  b 0x8323d6a4
	pc = 0x8323D6A4; continue 'dispatch;
            }
            0x8323D694 => {
    //   block [0x8323D694..0x8323D6A4)
	// 8323D694: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 8323D698: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 8323D69C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323D6A0: 4B7E3849  bl 0x82a20ee8
	ctx.lr = 0x8323D6A4;
	sub_82A20EE8(ctx, base);
	pc = 0x8323D6A4; continue 'dispatch;
            }
            0x8323D6A4 => {
    //   block [0x8323D6A4..0x8323D6DC)
	// 8323D6A4: 83C10064  lwz r30, 0x64(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8323D6A8: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8323D6AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323D6B0: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 8323D6B4: 419A0028  beq cr6, 0x8323d6dc
	if ctx.cr[6].eq {
	pc = 0x8323D6DC; continue 'dispatch;
	}
	// 8323D6B8: 89410064  lbz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8323D6BC: 89010067  lbz r8, 0x67(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(103 as u32) ) } as u64;
	// 8323D6C0: 8961005A  lbz r11, 0x5a(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(90 as u32) ) } as u64;
	// 8323D6C4: 89210059  lbz r9, 0x59(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 8323D6C8: 9941005B  stb r10, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[10].u8 ) };
	// 8323D6CC: 99010058  stb r8, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u8 ) };
	// 8323D6D0: 99610059  stb r11, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[11].u8 ) };
	// 8323D6D4: 9921005A  stb r9, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[9].u8 ) };
	// 8323D6D8: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	pc = 0x8323D6DC; continue 'dispatch;
            }
            0x8323D6DC => {
    //   block [0x8323D6DC..0x8323D720)
	// 8323D6DC: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 8323D6E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8323D6E4: 387B0004  addi r3, r27, 4
	ctx.r[3].s64 = ctx.r[27].s64 + 4;
	// 8323D6E8: 4B5BAEC1  bl 0x827f85a8
	ctx.lr = 0x8323D6EC;
	sub_827F85A8(ctx, base);
	// 8323D6EC: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8323D6F0: 40990030  ble cr6, 0x8323d720
	if !ctx.cr[6].gt {
	pc = 0x8323D720; continue 'dispatch;
	}
	// 8323D6F4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8323D6F8: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323D6FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8323D700: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8323D704: 7F9D5A14  add r28, r29, r11
	ctx.r[28].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 8323D708: 4B7E4209  bl 0x82a21910
	ctx.lr = 0x8323D70C;
	sub_82A21910(ctx, base);
	pc = 0x8323D720; continue 'dispatch;
            }
            0x8323D720 => {
    //   block [0x8323D720..0x8323DA18)
	// 8323D720: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323D724: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8323D728: 41980034  blt cr6, 0x8323d75c
	if ctx.cr[6].lt {
	pc = 0x8323D75C; continue 'dispatch;
	}
	// 8323D72C: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 8323D730: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323D734: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323D738: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 8323D73C: 38EB0001  addi r7, r11, 1
	ctx.r[7].s64 = ctx.r[11].s64 + 1;
	// 8323D740: 38CA0001  addi r6, r10, 1
	ctx.r[6].s64 = ctx.r[10].s64 + 1;
	// 8323D744: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323D748: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 8323D74C: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 8323D750: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 8323D754: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 8323D758: 48000014  b 0x8323d76c
	pc = 0x8323D76C; continue 'dispatch;
	// 8323D75C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8323D760: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8323D764: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323D768: 4B7E3781  bl 0x82a20ee8
	ctx.lr = 0x8323D76C;
	sub_82A20EE8(ctx, base);
	// 8323D76C: 89410050  lbz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8323D770: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 8323D774: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 8323D778: 69070001  xori r7, r8, 1
	ctx.r[7].u64 = ctx.r[8].u64 ^ 1;
	// 8323D77C: 98FB0014  stb r7, 0x14(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(20 as u32), ctx.r[7].u8 ) };
	// 8323D780: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323D784: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8323D788: 41980034  blt cr6, 0x8323d7bc
	if ctx.cr[6].lt {
	pc = 0x8323D7BC; continue 'dispatch;
	}
	// 8323D78C: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 8323D790: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323D794: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323D798: 39010051  addi r8, r1, 0x51
	ctx.r[8].s64 = ctx.r[1].s64 + 81;
	// 8323D79C: 38EB0001  addi r7, r11, 1
	ctx.r[7].s64 = ctx.r[11].s64 + 1;
	// 8323D7A0: 38CA0001  addi r6, r10, 1
	ctx.r[6].s64 = ctx.r[10].s64 + 1;
	// 8323D7A4: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323D7A8: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 8323D7AC: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 8323D7B0: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 8323D7B4: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 8323D7B8: 48000014  b 0x8323d7cc
	pc = 0x8323D7CC; continue 'dispatch;
	// 8323D7BC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8323D7C0: 38810051  addi r4, r1, 0x51
	ctx.r[4].s64 = ctx.r[1].s64 + 81;
	// 8323D7C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323D7C8: 4B7E3721  bl 0x82a20ee8
	ctx.lr = 0x8323D7CC;
	sub_82A20EE8(ctx, base);
	// 8323D7CC: 89410051  lbz r10, 0x51(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 8323D7D0: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 8323D7D4: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 8323D7D8: 69070001  xori r7, r8, 1
	ctx.r[7].u64 = ctx.r[8].u64 ^ 1;
	// 8323D7DC: 98FB0015  stb r7, 0x15(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(21 as u32), ctx.r[7].u8 ) };
	// 8323D7E0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323D7E4: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 8323D7E8: 4198004C  blt cr6, 0x8323d834
	if ctx.cr[6].lt {
	pc = 0x8323D834; continue 'dispatch;
	}
	// 8323D7EC: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 8323D7F0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323D7F4: 39010068  addi r8, r1, 0x68
	ctx.r[8].s64 = ctx.r[1].s64 + 104;
	// 8323D7F8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323D7FC: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 8323D800: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 8323D804: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323D808: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 8323D80C: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 8323D810: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 8323D814: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 8323D818: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 8323D81C: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 8323D820: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 8323D824: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 8323D828: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 8323D82C: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 8323D830: 48000014  b 0x8323d844
	pc = 0x8323D844; continue 'dispatch;
	// 8323D834: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 8323D838: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8323D83C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323D840: 4B7E36A9  bl 0x82a20ee8
	ctx.lr = 0x8323D844;
	sub_82A20EE8(ctx, base);
	// 8323D844: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8323D848: C0010068  lfs f0, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323D84C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8323D850: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323D854: 419A0024  beq cr6, 0x8323d878
	if ctx.cr[6].eq {
	pc = 0x8323D878; continue 'dispatch;
	}
	// 8323D858: 89610058  lbz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8323D85C: 89410059  lbz r10, 0x59(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 8323D860: 8921005B  lbz r9, 0x5b(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(91 as u32) ) } as u64;
	// 8323D864: 8901005A  lbz r8, 0x5a(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(90 as u32) ) } as u64;
	// 8323D868: 9961005B  stb r11, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[11].u8 ) };
	// 8323D86C: 9941005A  stb r10, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[10].u8 ) };
	// 8323D870: 99210058  stb r9, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 8323D874: 99010059  stb r8, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[8].u8 ) };
	// 8323D878: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323D87C: D01B0018  stfs f0, 0x18(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8323D880: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323D884: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8323D888: 41980034  blt cr6, 0x8323d8bc
	if ctx.cr[6].lt {
	pc = 0x8323D8BC; continue 'dispatch;
	}
	// 8323D88C: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 8323D890: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323D894: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323D898: 39010052  addi r8, r1, 0x52
	ctx.r[8].s64 = ctx.r[1].s64 + 82;
	// 8323D89C: 38EB0001  addi r7, r11, 1
	ctx.r[7].s64 = ctx.r[11].s64 + 1;
	// 8323D8A0: 38CA0001  addi r6, r10, 1
	ctx.r[6].s64 = ctx.r[10].s64 + 1;
	// 8323D8A4: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323D8A8: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 8323D8AC: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 8323D8B0: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 8323D8B4: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 8323D8B8: 48000014  b 0x8323d8cc
	pc = 0x8323D8CC; continue 'dispatch;
	// 8323D8BC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8323D8C0: 38810052  addi r4, r1, 0x52
	ctx.r[4].s64 = ctx.r[1].s64 + 82;
	// 8323D8C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323D8C8: 4B7E3621  bl 0x82a20ee8
	ctx.lr = 0x8323D8CC;
	sub_82A20EE8(ctx, base);
	// 8323D8CC: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 8323D8D0: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 8323D8D4: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 8323D8D8: 69070001  xori r7, r8, 1
	ctx.r[7].u64 = ctx.r[8].u64 ^ 1;
	// 8323D8DC: 98FB001C  stb r7, 0x1c(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(28 as u32), ctx.r[7].u8 ) };
	// 8323D8E0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323D8E4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8323D8E8: 41980034  blt cr6, 0x8323d91c
	if ctx.cr[6].lt {
	pc = 0x8323D91C; continue 'dispatch;
	}
	// 8323D8EC: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 8323D8F0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323D8F4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323D8F8: 39010053  addi r8, r1, 0x53
	ctx.r[8].s64 = ctx.r[1].s64 + 83;
	// 8323D8FC: 38EB0001  addi r7, r11, 1
	ctx.r[7].s64 = ctx.r[11].s64 + 1;
	// 8323D900: 38CA0001  addi r6, r10, 1
	ctx.r[6].s64 = ctx.r[10].s64 + 1;
	// 8323D904: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323D908: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 8323D90C: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 8323D910: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 8323D914: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 8323D918: 48000014  b 0x8323d92c
	pc = 0x8323D92C; continue 'dispatch;
	// 8323D91C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8323D920: 38810053  addi r4, r1, 0x53
	ctx.r[4].s64 = ctx.r[1].s64 + 83;
	// 8323D924: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323D928: 4B7E35C1  bl 0x82a20ee8
	ctx.lr = 0x8323D92C;
	sub_82A20EE8(ctx, base);
	// 8323D92C: 89410053  lbz r10, 0x53(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(83 as u32) ) } as u64;
	// 8323D930: 2B1A0003  cmplwi cr6, r26, 3
	ctx.cr[6].compare_u32(ctx.r[26].u32, 3 as u32, &mut ctx.xer);
	// 8323D934: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 8323D938: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 8323D93C: 69070001  xori r7, r8, 1
	ctx.r[7].u64 = ctx.r[8].u64 ^ 1;
	// 8323D940: 98FB001D  stb r7, 0x1d(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(29 as u32), ctx.r[7].u8 ) };
	// 8323D944: 41980064  blt cr6, 0x8323d9a8
	if ctx.cr[6].lt {
	pc = 0x8323D9A8; continue 'dispatch;
	}
	// 8323D948: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323D94C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8323D950: 41980034  blt cr6, 0x8323d984
	if ctx.cr[6].lt {
	pc = 0x8323D984; continue 'dispatch;
	}
	// 8323D954: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 8323D958: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323D95C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323D960: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 8323D964: 38EB0001  addi r7, r11, 1
	ctx.r[7].s64 = ctx.r[11].s64 + 1;
	// 8323D968: 38CA0001  addi r6, r10, 1
	ctx.r[6].s64 = ctx.r[10].s64 + 1;
	// 8323D96C: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323D970: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 8323D974: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 8323D978: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 8323D97C: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 8323D980: 48000014  b 0x8323d994
	pc = 0x8323D994; continue 'dispatch;
	// 8323D984: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8323D988: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8323D98C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323D990: 4B7E3559  bl 0x82a20ee8
	ctx.lr = 0x8323D994;
	sub_82A20EE8(ctx, base);
	// 8323D994: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323D998: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 8323D99C: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 8323D9A0: 69070001  xori r7, r8, 1
	ctx.r[7].u64 = ctx.r[8].u64 ^ 1;
	// 8323D9A4: 98FB001E  stb r7, 0x1e(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(30 as u32), ctx.r[7].u8 ) };
	// 8323D9A8: 2B1A0004  cmplwi cr6, r26, 4
	ctx.cr[6].compare_u32(ctx.r[26].u32, 4 as u32, &mut ctx.xer);
	// 8323D9AC: 41980064  blt cr6, 0x8323da10
	if ctx.cr[6].lt {
	pc = 0x8323DA10; continue 'dispatch;
	}
	// 8323D9B0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323D9B4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8323D9B8: 41980034  blt cr6, 0x8323d9ec
	if ctx.cr[6].lt {
	pc = 0x8323D9EC; continue 'dispatch;
	}
	// 8323D9BC: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 8323D9C0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323D9C4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323D9C8: 39010055  addi r8, r1, 0x55
	ctx.r[8].s64 = ctx.r[1].s64 + 85;
	// 8323D9CC: 38EB0001  addi r7, r11, 1
	ctx.r[7].s64 = ctx.r[11].s64 + 1;
	// 8323D9D0: 38CA0001  addi r6, r10, 1
	ctx.r[6].s64 = ctx.r[10].s64 + 1;
	// 8323D9D4: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323D9D8: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 8323D9DC: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 8323D9E0: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 8323D9E4: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 8323D9E8: 48000014  b 0x8323d9fc
	pc = 0x8323D9FC; continue 'dispatch;
	// 8323D9EC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8323D9F0: 38810055  addi r4, r1, 0x55
	ctx.r[4].s64 = ctx.r[1].s64 + 85;
	// 8323D9F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323D9F8: 4B7E34F1  bl 0x82a20ee8
	ctx.lr = 0x8323D9FC;
	sub_82A20EE8(ctx, base);
	// 8323D9FC: 89410055  lbz r10, 0x55(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(85 as u32) ) } as u64;
	// 8323DA00: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 8323DA04: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 8323DA08: 69070001  xori r7, r8, 1
	ctx.r[7].u64 = ctx.r[8].u64 ^ 1;
	// 8323DA0C: 98FB001F  stb r7, 0x1f(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(31 as u32), ctx.r[7].u8 ) };
	// 8323DA10: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8323DA14: 4BA6BA3C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323DA18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8323DA18 size=1028
    let mut pc: u32 = 0x8323DA18;
    'dispatch: loop {
        match pc {
            0x8323DA18 => {
    //   block [0x8323DA18..0x8323DA9C)
	// 8323DA18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323DA1C: 4BA6B9DD  bl 0x82ca93f8
	ctx.lr = 0x8323DA20;
	sub_82CA93D0(ctx, base);
	// 8323DA20: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323DA24: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8323DA28: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8323DA2C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 8323DA30: 3BCB9484  addi r30, r11, -0x6b7c
	ctx.r[30].s64 = ctx.r[11].s64 + -27516;
	// 8323DA34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323DA38: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323DA3C: 389E0B70  addi r4, r30, 0xb70
	ctx.r[4].s64 = ctx.r[30].s64 + 2928;
	// 8323DA40: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323DA44: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8323DA48: 4E800421  bctrl
	ctx.lr = 0x8323DA4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323DA4C: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8323DA50: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8323DA54: 419A03C0  beq cr6, 0x8323de14
	if ctx.cr[6].eq {
	pc = 0x8323DE14; continue 'dispatch;
	}
	// 8323DA58: 817A000C  lwz r11, 0xc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323DA5C: 389E0B80  addi r4, r30, 0xb80
	ctx.r[4].s64 = ctx.r[30].s64 + 2944;
	// 8323DA60: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323DA64: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8323DA68: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8323DA6C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8323DA70: 3BBA0004  addi r29, r26, 4
	ctx.r[29].s64 = ctx.r[26].s64 + 4;
	// 8323DA74: 7D282670  srawi r8, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 4) as i64;
	// 8323DA78: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 8323DA7C: 4AFEF455  bl 0x8222ced0
	ctx.lr = 0x8323DA80;
	sub_8222CED0(ctx, base);
	// 8323DA80: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8323DA84: 3B0BFFDF  addi r24, r11, -0x21
	ctx.r[24].s64 = ctx.r[11].s64 + -33;
	// 8323DA88: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8323DA8C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323DA90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323DA94: 419A0008  beq cr6, 0x8323da9c
	if ctx.cr[6].eq {
	pc = 0x8323DA9C; continue 'dispatch;
	}
	// 8323DA98: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x8323DA9C => {
    //   block [0x8323DA9C..0x8323DAE0)
	// 8323DA9C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8323DAA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323DAA4: 4B242D25  bl 0x824807c8
	ctx.lr = 0x8323DAA8;
	sub_824807C8(ctx, base);
	// 8323DAA8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8323DAAC: 4AFD732D  bl 0x82214dd8
	ctx.lr = 0x8323DAB0;
	sub_82214DD8(ctx, base);
	// 8323DAB0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8323DAB4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8323DAB8: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8323DABC: 4B5BAAED  bl 0x827f85a8
	ctx.lr = 0x8323DAC0;
	sub_827F85A8(ctx, base);
	// 8323DAC0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 8323DAC4: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 8323DAC8: 3BAB7088  addi r29, r11, 0x7088
	ctx.r[29].s64 = ctx.r[11].s64 + 28808;
	// 8323DACC: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	// 8323DAD0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8323DAD4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8323DAD8: 4099006C  ble cr6, 0x8323db44
	if !ctx.cr[6].gt {
	pc = 0x8323DB44; continue 'dispatch;
	}
	// 8323DADC: 7F3BCB78  mr r27, r25
	ctx.r[27].u64 = ctx.r[25].u64;
	pc = 0x8323DAE0; continue 'dispatch;
            }
            0x8323DAE0 => {
    //   block [0x8323DAE0..0x8323DB10)
	// 8323DAE0: 389E0B90  addi r4, r30, 0xb90
	ctx.r[4].s64 = ctx.r[30].s64 + 2960;
	// 8323DAE4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8323DAE8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8323DAEC: 4AFEF3E5  bl 0x8222ced0
	ctx.lr = 0x8323DAF0;
	sub_8222CED0(ctx, base);
	// 8323DAF0: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323DAF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8323DAF8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8323DAFC: 7CBB5A14  add r5, r27, r11
	ctx.r[5].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 8323DB00: 4BFF7A11  bl 0x83235510
	ctx.lr = 0x8323DB04;
	sub_83235510(ctx, base);
	// 8323DB04: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8323DB08: 4AF88C61  bl 0x821c6768
	ctx.lr = 0x8323DB0C;
	sub_821C6768(ctx, base);
	// 8323DB0C: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	pc = 0x8323DB10; continue 'dispatch;
            }
            0x8323DB10 => {
    //   block [0x8323DB10..0x8323DB44)
	// 8323DB10: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8323DB14: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323DB18: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8323DB1C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8323DB20: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8323DB24: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323DB28: 4082FFE8  bne 0x8323db10
	if !ctx.cr[0].eq {
	pc = 0x8323DB10; continue 'dispatch;
	}
	// 8323DB2C: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8323DB30: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 8323DB34: 3B7B0010  addi r27, r27, 0x10
	ctx.r[27].s64 = ctx.r[27].s64 + 16;
	// 8323DB38: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 8323DB3C: 7F1C4000  cmpw cr6, r28, r8
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[8].s32, &mut ctx.xer);
	// 8323DB40: 4198FFA0  blt cr6, 0x8323dae0
	if ctx.cr[6].lt {
	pc = 0x8323DAE0; continue 'dispatch;
	}
	pc = 0x8323DB44; continue 'dispatch;
            }
            0x8323DB44 => {
    //   block [0x8323DB44..0x8323DB70)
	// 8323DB44: 389E0B9C  addi r4, r30, 0xb9c
	ctx.r[4].s64 = ctx.r[30].s64 + 2972;
	// 8323DB48: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8323DB4C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8323DB50: 4AFEF381  bl 0x8222ced0
	ctx.lr = 0x8323DB54;
	sub_8222CED0(ctx, base);
	// 8323DB54: 38BA0014  addi r5, r26, 0x14
	ctx.r[5].s64 = ctx.r[26].s64 + 20;
	// 8323DB58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8323DB5C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8323DB60: 4BFF7AA1  bl 0x83235600
	ctx.lr = 0x8323DB64;
	sub_83235600(ctx, base);
	// 8323DB64: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8323DB68: 4AF88C01  bl 0x821c6768
	ctx.lr = 0x8323DB6C;
	sub_821C6768(ctx, base);
	// 8323DB6C: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	pc = 0x8323DB70; continue 'dispatch;
            }
            0x8323DB70 => {
    //   block [0x8323DB70..0x8323DBB8)
	// 8323DB70: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8323DB74: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323DB78: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8323DB7C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8323DB80: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8323DB84: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323DB88: 4082FFE8  bne 0x8323db70
	if !ctx.cr[0].eq {
	pc = 0x8323DB70; continue 'dispatch;
	}
	// 8323DB8C: 389E0BAC  addi r4, r30, 0xbac
	ctx.r[4].s64 = ctx.r[30].s64 + 2988;
	// 8323DB90: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8323DB94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8323DB98: 4AFEF339  bl 0x8222ced0
	ctx.lr = 0x8323DB9C;
	sub_8222CED0(ctx, base);
	// 8323DB9C: 38BA0015  addi r5, r26, 0x15
	ctx.r[5].s64 = ctx.r[26].s64 + 21;
	// 8323DBA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8323DBA4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8323DBA8: 4BFF7A59  bl 0x83235600
	ctx.lr = 0x8323DBAC;
	sub_83235600(ctx, base);
	// 8323DBAC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8323DBB0: 4AF88BB9  bl 0x821c6768
	ctx.lr = 0x8323DBB4;
	sub_821C6768(ctx, base);
	// 8323DBB4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	pc = 0x8323DBB8; continue 'dispatch;
            }
            0x8323DBB8 => {
    //   block [0x8323DBB8..0x8323DBF8)
	// 8323DBB8: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 8323DBBC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323DBC0: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 8323DBC4: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 8323DBC8: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8323DBCC: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323DBD0: 4082FFE8  bne 0x8323dbb8
	if !ctx.cr[0].eq {
	pc = 0x8323DBB8; continue 'dispatch;
	}
	// 8323DBD4: 389E0BB8  addi r4, r30, 0xbb8
	ctx.r[4].s64 = ctx.r[30].s64 + 3000;
	// 8323DBD8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8323DBDC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8323DBE0: 4AFEF2F1  bl 0x8222ced0
	ctx.lr = 0x8323DBE4;
	sub_8222CED0(ctx, base);
	// 8323DBE4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323DBE8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8323DBEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323DBF0: 419A0008  beq cr6, 0x8323dbf8
	if ctx.cr[6].eq {
	pc = 0x8323DBF8; continue 'dispatch;
	}
	// 8323DBF4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8323DBF8; continue 'dispatch;
            }
            0x8323DBF8 => {
    //   block [0x8323DBF8..0x8323DC10)
	// 8323DBF8: 38BA0018  addi r5, r26, 0x18
	ctx.r[5].s64 = ctx.r[26].s64 + 24;
	// 8323DBFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323DC00: 4B242C51  bl 0x82480850
	ctx.lr = 0x8323DC04;
	sub_82480850(ctx, base);
	// 8323DC04: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8323DC08: 4AF88B61  bl 0x821c6768
	ctx.lr = 0x8323DC0C;
	sub_821C6768(ctx, base);
	// 8323DC0C: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	pc = 0x8323DC10; continue 'dispatch;
            }
            0x8323DC10 => {
    //   block [0x8323DC10..0x8323DC58)
	// 8323DC10: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8323DC14: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323DC18: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8323DC1C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8323DC20: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8323DC24: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323DC28: 4082FFE8  bne 0x8323dc10
	if !ctx.cr[0].eq {
	pc = 0x8323DC10; continue 'dispatch;
	}
	// 8323DC2C: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8323DC30: 389E0BC0  addi r4, r30, 0xbc0
	ctx.r[4].s64 = ctx.r[30].s64 + 3008;
	// 8323DC34: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8323DC38: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8323DC3C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8323DC40: 4AFEF291  bl 0x8222ced0
	ctx.lr = 0x8323DC44;
	sub_8222CED0(ctx, base);
	// 8323DC44: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323DC48: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8323DC4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323DC50: 419A0008  beq cr6, 0x8323dc58
	if ctx.cr[6].eq {
	pc = 0x8323DC58; continue 'dispatch;
	}
	// 8323DC54: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8323DC58; continue 'dispatch;
            }
            0x8323DC58 => {
    //   block [0x8323DC58..0x8323DC70)
	// 8323DC58: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8323DC5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323DC60: 4B242BF1  bl 0x82480850
	ctx.lr = 0x8323DC64;
	sub_82480850(ctx, base);
	// 8323DC64: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8323DC68: 4AF88B01  bl 0x821c6768
	ctx.lr = 0x8323DC6C;
	sub_821C6768(ctx, base);
	// 8323DC6C: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	pc = 0x8323DC70; continue 'dispatch;
            }
            0x8323DC70 => {
    //   block [0x8323DC70..0x8323DCB0)
	// 8323DC70: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8323DC74: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323DC78: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8323DC7C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8323DC80: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8323DC84: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323DC88: 4082FFE8  bne 0x8323dc70
	if !ctx.cr[0].eq {
	pc = 0x8323DC70; continue 'dispatch;
	}
	// 8323DC8C: 389E0BCC  addi r4, r30, 0xbcc
	ctx.r[4].s64 = ctx.r[30].s64 + 3020;
	// 8323DC90: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8323DC94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8323DC98: 4AFEF239  bl 0x8222ced0
	ctx.lr = 0x8323DC9C;
	sub_8222CED0(ctx, base);
	// 8323DC9C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323DCA0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8323DCA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323DCA8: 419A0008  beq cr6, 0x8323dcb0
	if ctx.cr[6].eq {
	pc = 0x8323DCB0; continue 'dispatch;
	}
	// 8323DCAC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8323DCB0; continue 'dispatch;
            }
            0x8323DCB0 => {
    //   block [0x8323DCB0..0x8323DCC8)
	// 8323DCB0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8323DCB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323DCB8: 4B242B99  bl 0x82480850
	ctx.lr = 0x8323DCBC;
	sub_82480850(ctx, base);
	// 8323DCBC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8323DCC0: 4AF88AA9  bl 0x821c6768
	ctx.lr = 0x8323DCC4;
	sub_821C6768(ctx, base);
	// 8323DCC4: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	pc = 0x8323DCC8; continue 'dispatch;
            }
            0x8323DCC8 => {
    //   block [0x8323DCC8..0x8323DD10)
	// 8323DCC8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8323DCCC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323DCD0: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8323DCD4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8323DCD8: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8323DCDC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323DCE0: 4082FFE8  bne 0x8323dcc8
	if !ctx.cr[0].eq {
	pc = 0x8323DCC8; continue 'dispatch;
	}
	// 8323DCE4: 389E0BD8  addi r4, r30, 0xbd8
	ctx.r[4].s64 = ctx.r[30].s64 + 3032;
	// 8323DCE8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8323DCEC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8323DCF0: 4AFEF1E1  bl 0x8222ced0
	ctx.lr = 0x8323DCF4;
	sub_8222CED0(ctx, base);
	// 8323DCF4: 38BA001C  addi r5, r26, 0x1c
	ctx.r[5].s64 = ctx.r[26].s64 + 28;
	// 8323DCF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8323DCFC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8323DD00: 4BFF7901  bl 0x83235600
	ctx.lr = 0x8323DD04;
	sub_83235600(ctx, base);
	// 8323DD04: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8323DD08: 4AF88A61  bl 0x821c6768
	ctx.lr = 0x8323DD0C;
	sub_821C6768(ctx, base);
	// 8323DD0C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	pc = 0x8323DD10; continue 'dispatch;
            }
            0x8323DD10 => {
    //   block [0x8323DD10..0x8323DD58)
	// 8323DD10: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 8323DD14: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323DD18: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 8323DD1C: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 8323DD20: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8323DD24: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323DD28: 4082FFE8  bne 0x8323dd10
	if !ctx.cr[0].eq {
	pc = 0x8323DD10; continue 'dispatch;
	}
	// 8323DD2C: 389E0BE8  addi r4, r30, 0xbe8
	ctx.r[4].s64 = ctx.r[30].s64 + 3048;
	// 8323DD30: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8323DD34: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8323DD38: 4AFEF199  bl 0x8222ced0
	ctx.lr = 0x8323DD3C;
	sub_8222CED0(ctx, base);
	// 8323DD3C: 38BA001D  addi r5, r26, 0x1d
	ctx.r[5].s64 = ctx.r[26].s64 + 29;
	// 8323DD40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8323DD44: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8323DD48: 4BFF78B9  bl 0x83235600
	ctx.lr = 0x8323DD4C;
	sub_83235600(ctx, base);
	// 8323DD4C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8323DD50: 4AF88A19  bl 0x821c6768
	ctx.lr = 0x8323DD54;
	sub_821C6768(ctx, base);
	// 8323DD54: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	pc = 0x8323DD58; continue 'dispatch;
            }
            0x8323DD58 => {
    //   block [0x8323DD58..0x8323DDA0)
	// 8323DD58: 7C8000A6  mfmsr r4
	ctx.r[4].u64 = ctx.msr;
	// 8323DD5C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323DD60: 7CA01828  lwarx r5, 0, r3
	// lwarx
	let ea = ctx.r[3].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[5].u64 = ctx.reserved.u32 as u64;
	// 8323DD64: 38A5FFFF  addi r5, r5, -1
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	// 8323DD68: 7CA0192D  stwcx. r5, 0, r3
	// stwcx.
	let addr = ctx.r[3].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[5].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8323DD6C: 7C810164  mtmsrd r4, 1
	ctx.msr = (ctx.r[4].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323DD70: 4082FFE8  bne 0x8323dd58
	if !ctx.cr[0].eq {
	pc = 0x8323DD58; continue 'dispatch;
	}
	// 8323DD74: 389E0BFC  addi r4, r30, 0xbfc
	ctx.r[4].s64 = ctx.r[30].s64 + 3068;
	// 8323DD78: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8323DD7C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8323DD80: 4AFEF151  bl 0x8222ced0
	ctx.lr = 0x8323DD84;
	sub_8222CED0(ctx, base);
	// 8323DD84: 38BA001E  addi r5, r26, 0x1e
	ctx.r[5].s64 = ctx.r[26].s64 + 30;
	// 8323DD88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8323DD8C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8323DD90: 4BFF7871  bl 0x83235600
	ctx.lr = 0x8323DD94;
	sub_83235600(ctx, base);
	// 8323DD94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8323DD98: 4AF889D1  bl 0x821c6768
	ctx.lr = 0x8323DD9C;
	sub_821C6768(ctx, base);
	// 8323DD9C: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	pc = 0x8323DDA0; continue 'dispatch;
            }
            0x8323DDA0 => {
    //   block [0x8323DDA0..0x8323DDE4)
	// 8323DDA0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 8323DDA4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323DDA8: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8323DDAC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8323DDB0: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8323DDB4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323DDB8: 4082FFE8  bne 0x8323dda0
	if !ctx.cr[0].eq {
	pc = 0x8323DDA0; continue 'dispatch;
	}
	// 8323DDBC: 389E0C14  addi r4, r30, 0xc14
	ctx.r[4].s64 = ctx.r[30].s64 + 3092;
	// 8323DDC0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 8323DDC4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8323DDC8: 4AFEF109  bl 0x8222ced0
	ctx.lr = 0x8323DDCC;
	sub_8222CED0(ctx, base);
	// 8323DDCC: 38BA001F  addi r5, r26, 0x1f
	ctx.r[5].s64 = ctx.r[26].s64 + 31;
	// 8323DDD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8323DDD4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8323DDD8: 4BFF7829  bl 0x83235600
	ctx.lr = 0x8323DDDC;
	sub_83235600(ctx, base);
	// 8323DDDC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8323DDE0: 4AF88989  bl 0x821c6768
	ctx.lr = 0x8323DDE4;
	sub_821C6768(ctx, base);
	pc = 0x8323DDE4; continue 'dispatch;
            }
            0x8323DDE4 => {
    //   block [0x8323DDE4..0x8323DE14)
	// 8323DDE4: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 8323DDE8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323DDEC: 7D00E828  lwarx r8, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 8323DDF0: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 8323DDF4: 7D00E92D  stwcx. r8, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8323DDF8: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323DDFC: 4082FFE8  bne 0x8323dde4
	if !ctx.cr[0].eq {
	pc = 0x8323DDE4; continue 'dispatch;
	}
	// 8323DE00: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323DE04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323DE08: 80A6000C  lwz r5, 0xc(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323DE0C: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 8323DE10: 4E800421  bctrl
	ctx.lr = 0x8323DE14;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8323DE14 => {
    //   block [0x8323DE14..0x8323DE1C)
	// 8323DE14: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8323DE18: 4BA6B630  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323DE20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323DE20 size=708
    let mut pc: u32 = 0x8323DE20;
    'dispatch: loop {
        match pc {
            0x8323DE20 => {
    //   block [0x8323DE20..0x8323DEA4)
	// 8323DE20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323DE24: 4BA6B5D5  bl 0x82ca93f8
	ctx.lr = 0x8323DE28;
	sub_82CA93D0(ctx, base);
	// 8323DE28: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323DE2C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8323DE30: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8323DE34: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8323DE38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323DE3C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8323DE40: 897B001C  lbz r11, 0x1c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 8323DE44: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323DE48: 7D690034  cntlzw r9, r11
	ctx.r[9].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8323DE4C: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 8323DE50: 69070001  xori r7, r8, 1
	ctx.r[7].u64 = ctx.r[8].u64 ^ 1;
	// 8323DE54: 80CA0010  lwz r6, 0x10(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323DE58: 98E10050  stb r7, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u8 ) };
	// 8323DE5C: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 8323DE60: 4E800421  bctrl
	ctx.lr = 0x8323DE64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323DE64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323DE68: 809B0020  lwz r4, 0x20(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 8323DE6C: 4B7E478D  bl 0x82a225f8
	ctx.lr = 0x8323DE70;
	sub_82A225F8(ctx, base);
	// 8323DE70: 809B0014  lwz r4, 0x14(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323DE74: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323DE78: 38A00014  li r5, 0x14
	ctx.r[5].s64 = 20;
	// 8323DE7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323DE80: 7D4B2050  subf r10, r11, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 8323DE84: 7FCA2BD6  divw r30, r10, r5
	ctx.r[30].s32 = ctx.r[10].s32 / ctx.r[5].s32;
	// 8323DE88: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8323DE8C: 4B7E476D  bl 0x82a225f8
	ctx.lr = 0x8323DE90;
	sub_82A225F8(ctx, base);
	// 8323DE90: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8323DE94: 409901F8  ble cr6, 0x8323e08c
	if !ctx.cr[6].gt {
	pc = 0x8323E08C; continue 'dispatch;
	}
	// 8323DE98: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8323DE9C: 7FD8F378  mr r24, r30
	ctx.r[24].u64 = ctx.r[30].u64;
	// 8323DEA0: 3B20000C  li r25, 0xc
	ctx.r[25].s64 = 12;
            }
            0x8323DEA4 => {
    //   block [0x8323DEA4..0x8323DEE0)
	// 8323DEA4: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323DEA8: 895F0008  lbz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323DEAC: 7D3C5A14  add r9, r28, r11
	ctx.r[9].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 8323DEB0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323DEB4: 81090010  lwz r8, 0x10(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323DEB8: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 8323DEBC: 419A0024  beq cr6, 0x8323dee0
	if ctx.cr[6].eq {
	pc = 0x8323DEE0; continue 'dispatch;
	}
	// 8323DEC0: 89610054  lbz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323DEC4: 89410055  lbz r10, 0x55(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(85 as u32) ) } as u64;
	// 8323DEC8: 89210057  lbz r9, 0x57(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(87 as u32) ) } as u64;
	// 8323DECC: 89010056  lbz r8, 0x56(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 8323DED0: 99610057  stb r11, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[11].u8 ) };
	// 8323DED4: 99410056  stb r10, 0x56(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[10].u8 ) };
	// 8323DED8: 99210054  stb r9, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u8 ) };
	// 8323DEDC: 99010055  stb r8, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[8].u8 ) };
	pc = 0x8323DEE0; continue 'dispatch;
            }
            0x8323DEE0 => {
    //   block [0x8323DEE0..0x8323DF48)
	// 8323DEE0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323DEE4: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 8323DEE8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8323DEEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323DEF0: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323DEF4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323DEF8: 4E800421  bctrl
	ctx.lr = 0x8323DEFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323DEFC: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323DF00: 88FF0008  lbz r7, 8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323DF04: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 8323DF08: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8323DF0C: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323DF10: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323DF14: 7CC84850  subf r6, r8, r9
	ctx.r[6].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 8323DF18: 7FC6CBD6  divw r30, r6, r25
	ctx.r[30].s32 = ctx.r[6].s32 / ctx.r[25].s32;
	// 8323DF1C: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 8323DF20: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 8323DF24: 419A0024  beq cr6, 0x8323df48
	if ctx.cr[6].eq {
	pc = 0x8323DF48; continue 'dispatch;
	}
	// 8323DF28: 89610059  lbz r11, 0x59(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 8323DF2C: 8941005A  lbz r10, 0x5a(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(90 as u32) ) } as u64;
	// 8323DF30: 8921005F  lbz r9, 0x5f(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(95 as u32) ) } as u64;
	// 8323DF34: 8901005C  lbz r8, 0x5c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8323DF38: 9961005A  stb r11, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[11].u8 ) };
	// 8323DF3C: 99410059  stb r10, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[10].u8 ) };
	// 8323DF40: 99210058  stb r9, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 8323DF44: 9901005B  stb r8, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[8].u8 ) };
            }
            0x8323DF48 => {
    //   block [0x8323DF48..0x8323DF74)
	// 8323DF48: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323DF4C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 8323DF50: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8323DF54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323DF58: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323DF5C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323DF60: 4E800421  bctrl
	ctx.lr = 0x8323DF64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323DF64: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8323DF68: 40990118  ble cr6, 0x8323e080
	if !ctx.cr[6].gt {
	pc = 0x8323E080; continue 'dispatch;
	}
	// 8323DF6C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8323DF70: 7FDAF378  mr r26, r30
	ctx.r[26].u64 = ctx.r[30].u64;
            }
            0x8323DF74 => {
    //   block [0x8323DF74..0x8323DFB8)
	// 8323DF74: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323DF78: 895F0008  lbz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323DF7C: 7D3C5A14  add r9, r28, r11
	ctx.r[9].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 8323DF80: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323DF84: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323DF88: 7FCBEA14  add r30, r11, r29
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 8323DF8C: 7D0BE82E  lwzx r8, r11, r29
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 8323DF90: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 8323DF94: 419A0024  beq cr6, 0x8323dfb8
	if ctx.cr[6].eq {
	pc = 0x8323DFB8; continue 'dispatch;
	}
	// 8323DF98: 89610058  lbz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8323DF9C: 89410059  lbz r10, 0x59(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 8323DFA0: 8921005B  lbz r9, 0x5b(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(91 as u32) ) } as u64;
	// 8323DFA4: 8901005A  lbz r8, 0x5a(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(90 as u32) ) } as u64;
	// 8323DFA8: 9961005B  stb r11, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[11].u8 ) };
	// 8323DFAC: 9941005A  stb r10, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[10].u8 ) };
	// 8323DFB0: 99210058  stb r9, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 8323DFB4: 99010059  stb r8, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[8].u8 ) };
	pc = 0x8323DFB8; continue 'dispatch;
            }
            0x8323DFB8 => {
    //   block [0x8323DFB8..0x8323E008)
	// 8323DFB8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323DFBC: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 8323DFC0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8323DFC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323DFC8: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323DFCC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323DFD0: 4E800421  bctrl
	ctx.lr = 0x8323DFD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323DFD4: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323DFD8: 891F0008  lbz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323DFDC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8323DFE0: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 8323DFE4: 419A0024  beq cr6, 0x8323e008
	if ctx.cr[6].eq {
	pc = 0x8323E008; continue 'dispatch;
	}
	// 8323DFE8: 89610058  lbz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8323DFEC: 89410059  lbz r10, 0x59(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 8323DFF0: 8921005B  lbz r9, 0x5b(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(91 as u32) ) } as u64;
	// 8323DFF4: 8901005A  lbz r8, 0x5a(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(90 as u32) ) } as u64;
	// 8323DFF8: 9961005B  stb r11, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[11].u8 ) };
	// 8323DFFC: 9941005A  stb r10, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[10].u8 ) };
	// 8323E000: 99210058  stb r9, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 8323E004: 99010059  stb r8, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[8].u8 ) };
            }
            0x8323E008 => {
    //   block [0x8323E008..0x8323E058)
	// 8323E008: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323E00C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 8323E010: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8323E014: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323E018: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323E01C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323E020: 4E800421  bctrl
	ctx.lr = 0x8323E024;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323E024: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323E028: 891F0008  lbz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323E02C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8323E030: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 8323E034: 419A0024  beq cr6, 0x8323e058
	if ctx.cr[6].eq {
	pc = 0x8323E058; continue 'dispatch;
	}
	// 8323E038: 89610058  lbz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8323E03C: 89410059  lbz r10, 0x59(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 8323E040: 8921005B  lbz r9, 0x5b(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(91 as u32) ) } as u64;
	// 8323E044: 8901005A  lbz r8, 0x5a(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(90 as u32) ) } as u64;
	// 8323E048: 9961005B  stb r11, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[11].u8 ) };
	// 8323E04C: 9941005A  stb r10, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[10].u8 ) };
	// 8323E050: 99210058  stb r9, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 8323E054: 99010059  stb r8, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[8].u8 ) };
            }
            0x8323E058 => {
    //   block [0x8323E058..0x8323E080)
	// 8323E058: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323E05C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 8323E060: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8323E064: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323E068: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323E06C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323E070: 4E800421  bctrl
	ctx.lr = 0x8323E074;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323E074: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 8323E078: 3BBD000C  addi r29, r29, 0xc
	ctx.r[29].s64 = ctx.r[29].s64 + 12;
	// 8323E07C: 4082FEF8  bne 0x8323df74
	if !ctx.cr[0].eq {
	pc = 0x8323DF74; continue 'dispatch;
	}
            }
            0x8323E080 => {
    //   block [0x8323E080..0x8323E08C)
	// 8323E080: 3718FFFF  addic. r24, r24, -1
	ctx.xer.ca = (ctx.r[24].u32 > (!(-1 as u32)));
	ctx.r[24].s64 = ctx.r[24].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 8323E084: 3B9C0014  addi r28, r28, 0x14
	ctx.r[28].s64 = ctx.r[28].s64 + 20;
	// 8323E088: 4082FE1C  bne 0x8323dea4
	if !ctx.cr[0].eq {
	pc = 0x8323DEA4; continue 'dispatch;
	}
	pc = 0x8323E08C; continue 'dispatch;
            }
            0x8323E08C => {
    //   block [0x8323E08C..0x8323E0C0)
	// 8323E08C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323E090: 895F0008  lbz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323E094: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323E098: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8323E09C: 419A0024  beq cr6, 0x8323e0c0
	if ctx.cr[6].eq {
	pc = 0x8323E0C0; continue 'dispatch;
	}
	// 8323E0A0: 89610058  lbz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8323E0A4: 89410059  lbz r10, 0x59(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 8323E0A8: 8921005B  lbz r9, 0x5b(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(91 as u32) ) } as u64;
	// 8323E0AC: 8901005A  lbz r8, 0x5a(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(90 as u32) ) } as u64;
	// 8323E0B0: 9961005B  stb r11, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[11].u8 ) };
	// 8323E0B4: 9941005A  stb r10, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[10].u8 ) };
	// 8323E0B8: 99210058  stb r9, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 8323E0BC: 99010059  stb r8, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[8].u8 ) };
	pc = 0x8323E0C0; continue 'dispatch;
            }
            0x8323E0C0 => {
    //   block [0x8323E0C0..0x8323E0E4)
	// 8323E0C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323E0C4: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 8323E0C8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8323E0CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323E0D0: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323E0D4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323E0D8: 4E800421  bctrl
	ctx.lr = 0x8323E0DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323E0DC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8323E0E0: 4BA6B368  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323E0F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323E0F0 size=148
    let mut pc: u32 = 0x8323E0F0;
    'dispatch: loop {
        match pc {
            0x8323E0F0 => {
    //   block [0x8323E0F0..0x8323E124)
	// 8323E0F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323E0F4: 4BA6B319  bl 0x82ca940c
	ctx.lr = 0x8323E0F8;
	sub_82CA93D0(ctx, base);
	// 8323E0F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323E0FC: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8323E100: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8323E104: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8323E108: 3BCBFFDF  addi r30, r11, -0x21
	ctx.r[30].s64 = ctx.r[11].s64 + -33;
	// 8323E10C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8323E110: 816AE854  lwz r11, -0x17ac(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-6060 as u32) ) } as u64;
	// 8323E114: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8323E118: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323E11C: 419A0008  beq cr6, 0x8323e124
	if ctx.cr[6].eq {
	pc = 0x8323E124; continue 'dispatch;
	}
	// 8323E120: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8323E124; continue 'dispatch;
            }
            0x8323E124 => {
    //   block [0x8323E124..0x8323E15C)
	// 8323E124: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323E128: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323E12C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323E130: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323E134: 4E800421  bctrl
	ctx.lr = 0x8323E138;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323E138: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8323E13C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8323E140: 419A003C  beq cr6, 0x8323e17c
	if ctx.cr[6].eq {
	pc = 0x8323E17C; continue 'dispatch;
	}
	// 8323E144: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8323E148: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8323E14C: 816BE858  lwz r11, -0x17a8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6056 as u32) ) } as u64;
	// 8323E150: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323E154: 419A0008  beq cr6, 0x8323e15c
	if ctx.cr[6].eq {
	pc = 0x8323E15C; continue 'dispatch;
	}
	// 8323E158: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x8323E15C => {
    //   block [0x8323E15C..0x8323E17C)
	// 8323E15C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8323E160: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323E164: 4B151F25  bl 0x82390088
	ctx.lr = 0x8323E168;
	sub_82390088(ctx, base);
	// 8323E168: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323E16C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323E170: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323E174: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323E178: 4E800421  bctrl
	ctx.lr = 0x8323E17C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8323E17C => {
    //   block [0x8323E17C..0x8323E184)
	// 8323E17C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8323E180: 4BA6B2DC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323E188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323E188 size=156
    let mut pc: u32 = 0x8323E188;
    'dispatch: loop {
        match pc {
            0x8323E188 => {
    //   block [0x8323E188..0x8323E1BC)
	// 8323E188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323E18C: 4BA6B281  bl 0x82ca940c
	ctx.lr = 0x8323E190;
	sub_82CA93D0(ctx, base);
	// 8323E190: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323E194: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8323E198: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8323E19C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8323E1A0: 3BCBFFDF  addi r30, r11, -0x21
	ctx.r[30].s64 = ctx.r[11].s64 + -33;
	// 8323E1A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8323E1A8: 816AE854  lwz r11, -0x17ac(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-6060 as u32) ) } as u64;
	// 8323E1AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8323E1B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323E1B4: 419A0008  beq cr6, 0x8323e1bc
	if ctx.cr[6].eq {
	pc = 0x8323E1BC; continue 'dispatch;
	}
	// 8323E1B8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8323E1BC; continue 'dispatch;
            }
            0x8323E1BC => {
    //   block [0x8323E1BC..0x8323E1FC)
	// 8323E1BC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323E1C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323E1C4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323E1C8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323E1CC: 4E800421  bctrl
	ctx.lr = 0x8323E1D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323E1D0: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8323E1D4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8323E1D8: 419A0044  beq cr6, 0x8323e21c
	if ctx.cr[6].eq {
	pc = 0x8323E21C; continue 'dispatch;
	}
	// 8323E1DC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8323E1E0: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323E1E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8323E1E8: 816BE858  lwz r11, -0x17a8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6056 as u32) ) } as u64;
	// 8323E1EC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8323E1F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323E1F4: 419A0008  beq cr6, 0x8323e1fc
	if ctx.cr[6].eq {
	pc = 0x8323E1FC; continue 'dispatch;
	}
	// 8323E1F8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x8323E1FC => {
    //   block [0x8323E1FC..0x8323E21C)
	// 8323E1FC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8323E200: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323E204: 4B151E85  bl 0x82390088
	ctx.lr = 0x8323E208;
	sub_82390088(ctx, base);
	// 8323E208: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323E20C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323E210: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323E214: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323E218: 4E800421  bctrl
	ctx.lr = 0x8323E21C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8323E21C => {
    //   block [0x8323E21C..0x8323E224)
	// 8323E21C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8323E220: 4BA6B23C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323E228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323E228 size=88
    let mut pc: u32 = 0x8323E228;
    'dispatch: loop {
        match pc {
            0x8323E228 => {
    //   block [0x8323E228..0x8323E280)
	// 8323E228: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323E22C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8323E230: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8323E234: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8323E238: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323E23C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8323E240: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8323E244: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323E248: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323E24C: 4B7E43AD  bl 0x82a225f8
	ctx.lr = 0x8323E250;
	sub_82A225F8(ctx, base);
	// 8323E250: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323E254: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8323E258: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323E25C: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 8323E260: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323E264: 4E800421  bctrl
	ctx.lr = 0x8323E268;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323E268: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8323E26C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8323E270: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8323E274: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8323E278: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8323E27C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323E280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323E280 size=180
    let mut pc: u32 = 0x8323E280;
    'dispatch: loop {
        match pc {
            0x8323E280 => {
    //   block [0x8323E280..0x8323E2C0)
	// 8323E280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323E284: 4BA6B189  bl 0x82ca940c
	ctx.lr = 0x8323E288;
	sub_82CA93D0(ctx, base);
	// 8323E288: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323E28C: 54BD063E  clrlwi r29, r5, 0x18
	ctx.r[29].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 8323E290: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8323E294: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8323E298: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8323E29C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8323E2A0: 419A0038  beq cr6, 0x8323e2d8
	if ctx.cr[6].eq {
	pc = 0x8323E2D8; continue 'dispatch;
	}
	// 8323E2A4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8323E2A8: 816BE850  lwz r11, -0x17b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6064 as u32) ) } as u64;
	// 8323E2AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323E2B0: 409A0010  bne cr6, 0x8323e2c0
	if !ctx.cr[6].eq {
	pc = 0x8323E2C0; continue 'dispatch;
	}
	// 8323E2B4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8323E2B8: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 8323E2BC: 48000008  b 0x8323e2c4
	pc = 0x8323E2C4; continue 'dispatch;
            }
            0x8323E2C0 => {
    //   block [0x8323E2C0..0x8323E2C4)
	// 8323E2C0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8323E2C4; continue 'dispatch;
            }
            0x8323E2C4 => {
    //   block [0x8323E2C4..0x8323E2D8)
	// 8323E2C4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323E2C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323E2CC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323E2D0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323E2D4: 4E800421  bctrl
	ctx.lr = 0x8323E2D8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8323E2D8 => {
    //   block [0x8323E2D8..0x8323E310)
	// 8323E2D8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8323E2DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323E2E0: 419A0030  beq cr6, 0x8323e310
	if ctx.cr[6].eq {
	pc = 0x8323E310; continue 'dispatch;
	}
	// 8323E2E4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323E2E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8323E2EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323E2F0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8323E2F4: 4BFFFE95  bl 0x8323e188
	ctx.lr = 0x8323E2F8;
	sub_8323E188(ctx, base);
	// 8323E2F8: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323E2FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8323E300: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323E304: 812A0024  lwz r9, 0x24(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 8323E308: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 8323E30C: 4E800421  bctrl
	ctx.lr = 0x8323E310;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8323E310 => {
    //   block [0x8323E310..0x8323E32C)
	// 8323E310: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8323E314: 419A0018  beq cr6, 0x8323e32c
	if ctx.cr[6].eq {
	pc = 0x8323E32C; continue 'dispatch;
	}
	// 8323E318: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323E31C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323E320: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323E324: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323E328: 4E800421  bctrl
	ctx.lr = 0x8323E32C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8323E32C => {
    //   block [0x8323E32C..0x8323E334)
	// 8323E32C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8323E330: 4BA6B12C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323E338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323E338 size=188
    let mut pc: u32 = 0x8323E338;
    'dispatch: loop {
        match pc {
            0x8323E338 => {
    //   block [0x8323E338..0x8323E380)
	// 8323E338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323E33C: 4BA6B0C9  bl 0x82ca9404
	ctx.lr = 0x8323E340;
	sub_82CA93D0(ctx, base);
	// 8323E340: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323E344: 54FB063E  clrlwi r27, r7, 0x18
	ctx.r[27].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 8323E348: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8323E34C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8323E350: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8323E354: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 8323E358: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8323E35C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8323E360: 419A0038  beq cr6, 0x8323e398
	if ctx.cr[6].eq {
	pc = 0x8323E398; continue 'dispatch;
	}
	// 8323E364: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8323E368: 816BE850  lwz r11, -0x17b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6064 as u32) ) } as u64;
	// 8323E36C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323E370: 409A0010  bne cr6, 0x8323e380
	if !ctx.cr[6].eq {
	pc = 0x8323E380; continue 'dispatch;
	}
	// 8323E374: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8323E378: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 8323E37C: 48000008  b 0x8323e384
	pc = 0x8323E384; continue 'dispatch;
            }
            0x8323E380 => {
    //   block [0x8323E380..0x8323E384)
	// 8323E380: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8323E384; continue 'dispatch;
            }
            0x8323E384 => {
    //   block [0x8323E384..0x8323E398)
	// 8323E384: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323E388: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323E38C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323E390: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323E394: 4E800421  bctrl
	ctx.lr = 0x8323E398;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8323E398 => {
    //   block [0x8323E398..0x8323E3D0)
	// 8323E398: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8323E39C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323E3A0: 419A0030  beq cr6, 0x8323e3d0
	if ctx.cr[6].eq {
	pc = 0x8323E3D0; continue 'dispatch;
	}
	// 8323E3A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8323E3A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323E3AC: 4BFFFD45  bl 0x8323e0f0
	ctx.lr = 0x8323E3B0;
	sub_8323E0F0(ctx, base);
	// 8323E3B0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323E3B4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 8323E3B8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8323E3BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8323E3C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323E3C4: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 8323E3C8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323E3CC: 4E800421  bctrl
	ctx.lr = 0x8323E3D0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8323E3D0 => {
    //   block [0x8323E3D0..0x8323E3EC)
	// 8323E3D0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8323E3D4: 419A0018  beq cr6, 0x8323e3ec
	if ctx.cr[6].eq {
	pc = 0x8323E3EC; continue 'dispatch;
	}
	// 8323E3D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323E3DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323E3E0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323E3E4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323E3E8: 4E800421  bctrl
	ctx.lr = 0x8323E3EC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8323E3EC => {
    //   block [0x8323E3EC..0x8323E3F4)
	// 8323E3EC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8323E3F0: 4BA6B064  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323E3F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323E3F8 size=564
    let mut pc: u32 = 0x8323E3F8;
    'dispatch: loop {
        match pc {
            0x8323E3F8 => {
    //   block [0x8323E3F8..0x8323E42C)
	// 8323E3F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323E3FC: 4BA6AFF1  bl 0x82ca93ec
	ctx.lr = 0x8323E400;
	sub_82CA93D0(ctx, base);
	// 8323E400: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323E404: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8323E408: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8323E40C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 8323E410: 3B0BFFDF  addi r24, r11, -0x21
	ctx.r[24].s64 = ctx.r[11].s64 + -33;
	// 8323E414: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 8323E418: 816AE85C  lwz r11, -0x17a4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-6052 as u32) ) } as u64;
	// 8323E41C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8323E420: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323E424: 419A0008  beq cr6, 0x8323e42c
	if ctx.cr[6].eq {
	pc = 0x8323E42C; continue 'dispatch;
	}
	// 8323E428: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8323E42C; continue 'dispatch;
            }
            0x8323E42C => {
    //   block [0x8323E42C..0x8323E480)
	// 8323E42C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323E430: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8323E434: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323E438: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323E43C: 4E800421  bctrl
	ctx.lr = 0x8323E440;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323E440: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8323E444: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8323E448: 419A01DC  beq cr6, 0x8323e624
	if ctx.cr[6].eq {
	pc = 0x8323E624; continue 'dispatch;
	}
	// 8323E44C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8323E450: 38B9001C  addi r5, r25, 0x1c
	ctx.r[5].s64 = ctx.r[25].s64 + 28;
	// 8323E454: 386BE870  addi r3, r11, -0x1790
	ctx.r[3].s64 = ctx.r[11].s64 + -6032;
	// 8323E458: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8323E45C: 4BFF71A5  bl 0x83235600
	ctx.lr = 0x8323E460;
	sub_83235600(ctx, base);
	// 8323E460: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8323E464: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8323E468: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8323E46C: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 8323E470: 816AE874  lwz r11, -0x178c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-6028 as u32) ) } as u64;
	// 8323E474: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323E478: 419A0008  beq cr6, 0x8323e480
	if ctx.cr[6].eq {
	pc = 0x8323E480; continue 'dispatch;
	}
	// 8323E47C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x8323E480 => {
    //   block [0x8323E480..0x8323E4C4)
	// 8323E480: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8323E484: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8323E488: 4B151C01  bl 0x82390088
	ctx.lr = 0x8323E48C;
	sub_82390088(ctx, base);
	// 8323E48C: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8323E490: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8323E494: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 8323E498: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8323E49C: 91390020  stw r9, 0x20(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 8323E4A0: 81190014  lwz r8, 0x14(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323E4A4: 80F90010  lwz r7, 0x10(r25)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323E4A8: 7CC74050  subf r6, r7, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 8323E4AC: 7CA653D6  divw r5, r6, r10
	ctx.r[5].s32 = ctx.r[6].s32 / ctx.r[10].s32;
	// 8323E4B0: 816BE860  lwz r11, -0x17a0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6048 as u32) ) } as u64;
	// 8323E4B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323E4B8: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 8323E4BC: 419A0008  beq cr6, 0x8323e4c4
	if ctx.cr[6].eq {
	pc = 0x8323E4C4; continue 'dispatch;
	}
	// 8323E4C0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8323E4C4; continue 'dispatch;
            }
            0x8323E4C4 => {
    //   block [0x8323E4C4..0x8323E4F0)
	// 8323E4C4: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 8323E4C8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8323E4CC: 4B2422FD  bl 0x824807c8
	ctx.lr = 0x8323E4D0;
	sub_824807C8(ctx, base);
	// 8323E4D0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323E4D4: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 8323E4D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8323E4DC: 40990124  ble cr6, 0x8323e600
	if !ctx.cr[6].gt {
	pc = 0x8323E600; continue 'dispatch;
	}
	// 8323E4E0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 8323E4E4: 3AE0000C  li r23, 0xc
	ctx.r[23].s64 = 12;
	// 8323E4E8: 3FA0834A  lis r29, -0x7cb6
	ctx.r[29].s64 = -2092302336;
	// 8323E4EC: 3EC0834A  lis r22, -0x7cb6
	ctx.r[22].s64 = -2092302336;
	pc = 0x8323E4F0; continue 'dispatch;
            }
            0x8323E4F0 => {
    //   block [0x8323E4F0..0x8323E510)
	// 8323E4F0: 81590010  lwz r10, 0x10(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323E4F4: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8323E4F8: 8176E868  lwz r11, -0x1798(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(-6040 as u32) ) } as u64;
	// 8323E4FC: 7D4AD214  add r10, r10, r26
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 8323E500: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323E504: 38AA0010  addi r5, r10, 0x10
	ctx.r[5].s64 = ctx.r[10].s64 + 16;
	// 8323E508: 419A0008  beq cr6, 0x8323e510
	if ctx.cr[6].eq {
	pc = 0x8323E510; continue 'dispatch;
	}
	// 8323E50C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8323E510; continue 'dispatch;
            }
            0x8323E510 => {
    //   block [0x8323E510..0x8323E548)
	// 8323E510: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8323E514: 4B2422B5  bl 0x824807c8
	ctx.lr = 0x8323E518;
	sub_824807C8(ctx, base);
	// 8323E518: 81790010  lwz r11, 0x10(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323E51C: 815DE864  lwz r10, -0x179c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-6044 as u32) ) } as u64;
	// 8323E520: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8323E524: 7D6BD214  add r11, r11, r26
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 8323E528: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323E52C: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323E530: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323E534: 7CE84850  subf r7, r8, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 8323E538: 7CC7BBD6  divw r6, r7, r23
	ctx.r[6].s32 = ctx.r[7].s32 / ctx.r[23].s32;
	// 8323E53C: 90C10050  stw r6, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u32 ) };
	// 8323E540: 419A0008  beq cr6, 0x8323e548
	if ctx.cr[6].eq {
	pc = 0x8323E548; continue 'dispatch;
	}
	// 8323E544: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8323E548; continue 'dispatch;
            }
            0x8323E548 => {
    //   block [0x8323E548..0x8323E568)
	// 8323E548: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8323E54C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8323E550: 4B242279  bl 0x824807c8
	ctx.lr = 0x8323E554;
	sub_824807C8(ctx, base);
	// 8323E554: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8323E558: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 8323E55C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8323E560: 4099008C  ble cr6, 0x8323e5ec
	if !ctx.cr[6].gt {
	pc = 0x8323E5EC; continue 'dispatch;
	}
	// 8323E564: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x8323E568; continue 'dispatch;
            }
            0x8323E568 => {
    //   block [0x8323E568..0x8323E58C)
	// 8323E568: 81590010  lwz r10, 0x10(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323E56C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8323E570: 817DE864  lwz r11, -0x179c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-6044 as u32) ) } as u64;
	// 8323E574: 7D4AD214  add r10, r10, r26
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 8323E578: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323E57C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323E580: 7FEAF214  add r31, r10, r30
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 8323E584: 419A0008  beq cr6, 0x8323e58c
	if ctx.cr[6].eq {
	pc = 0x8323E58C; continue 'dispatch;
	}
	// 8323E588: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8323E58C; continue 'dispatch;
            }
            0x8323E58C => {
    //   block [0x8323E58C..0x8323E5AC)
	// 8323E58C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8323E590: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8323E594: 4B151AF5  bl 0x82390088
	ctx.lr = 0x8323E598;
	sub_82390088(ctx, base);
	// 8323E598: 817DE864  lwz r11, -0x179c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-6044 as u32) ) } as u64;
	// 8323E59C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8323E5A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323E5A4: 419A0008  beq cr6, 0x8323e5ac
	if ctx.cr[6].eq {
	pc = 0x8323E5AC; continue 'dispatch;
	}
	// 8323E5A8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8323E5AC; continue 'dispatch;
            }
            0x8323E5AC => {
    //   block [0x8323E5AC..0x8323E5CC)
	// 8323E5AC: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 8323E5B0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8323E5B4: 4B151AD5  bl 0x82390088
	ctx.lr = 0x8323E5B8;
	sub_82390088(ctx, base);
	// 8323E5B8: 817DE864  lwz r11, -0x179c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-6044 as u32) ) } as u64;
	// 8323E5BC: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8323E5C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323E5C4: 419A0008  beq cr6, 0x8323e5cc
	if ctx.cr[6].eq {
	pc = 0x8323E5CC; continue 'dispatch;
	}
	// 8323E5C8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8323E5CC; continue 'dispatch;
            }
            0x8323E5CC => {
    //   block [0x8323E5CC..0x8323E5EC)
	// 8323E5CC: 38BF0008  addi r5, r31, 8
	ctx.r[5].s64 = ctx.r[31].s64 + 8;
	// 8323E5D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8323E5D4: 4B151AB5  bl 0x82390088
	ctx.lr = 0x8323E5D8;
	sub_82390088(ctx, base);
	// 8323E5D8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8323E5DC: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 8323E5E0: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 8323E5E4: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8323E5E8: 4198FF80  blt cr6, 0x8323e568
	if ctx.cr[6].lt {
	pc = 0x8323E568; continue 'dispatch;
	}
	pc = 0x8323E5EC; continue 'dispatch;
            }
            0x8323E5EC => {
    //   block [0x8323E5EC..0x8323E600)
	// 8323E5EC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323E5F0: 3AB50001  addi r21, r21, 1
	ctx.r[21].s64 = ctx.r[21].s64 + 1;
	// 8323E5F4: 3B5A0014  addi r26, r26, 0x14
	ctx.r[26].s64 = ctx.r[26].s64 + 20;
	// 8323E5F8: 7F155800  cmpw cr6, r21, r11
	ctx.cr[6].compare_i32(ctx.r[21].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8323E5FC: 4198FEF4  blt cr6, 0x8323e4f0
	if ctx.cr[6].lt {
	pc = 0x8323E4F0; continue 'dispatch;
	}
	pc = 0x8323E600; continue 'dispatch;
            }
            0x8323E600 => {
    //   block [0x8323E600..0x8323E624)
	// 8323E600: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8323E604: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8323E608: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8323E60C: 4BFFD6B5  bl 0x8323bcc0
	ctx.lr = 0x8323E610;
	sub_8323BCC0(ctx, base);
	// 8323E610: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323E614: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8323E618: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323E61C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323E620: 4E800421  bctrl
	ctx.lr = 0x8323E624;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8323E624 => {
    //   block [0x8323E624..0x8323E62C)
	// 8323E624: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8323E628: 4BA6AE14  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323E630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323E630 size=220
    let mut pc: u32 = 0x8323E630;
    'dispatch: loop {
        match pc {
            0x8323E630 => {
    //   block [0x8323E630..0x8323E6A0)
	// 8323E630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323E634: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8323E638: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8323E63C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8323E640: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323E644: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8323E648: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8323E64C: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323E650: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 8323E654: 4198004C  blt cr6, 0x8323e6a0
	if ctx.cr[6].lt {
	pc = 0x8323E6A0; continue 'dispatch;
	}
	// 8323E658: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323E65C: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 8323E660: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323E664: 38EAFFFC  addi r7, r10, -4
	ctx.r[7].s64 = ctx.r[10].s64 + -4;
	// 8323E668: 38CB0004  addi r6, r11, 4
	ctx.r[6].s64 = ctx.r[11].s64 + 4;
	// 8323E66C: 38A90004  addi r5, r9, 4
	ctx.r[5].s64 = ctx.r[9].s64 + 4;
	// 8323E670: 888B0000  lbz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323E674: 98880000  stb r4, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[4].u8 ) };
	// 8323E678: 886B0001  lbz r3, 1(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 8323E67C: 98680001  stb r3, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[3].u8 ) };
	// 8323E680: 894B0002  lbz r10, 2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 8323E684: 99480002  stb r10, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[10].u8 ) };
	// 8323E688: 892B0003  lbz r9, 3(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 8323E68C: 99280003  stb r9, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[9].u8 ) };
	// 8323E690: 90DF000C  stw r6, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[6].u32 ) };
	// 8323E694: 90FF0014  stw r7, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	// 8323E698: 90BF0004  stw r5, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 8323E69C: 48000014  b 0x8323e6b0
	pc = 0x8323E6B0; continue 'dispatch;
            }
            0x8323E6A0 => {
    //   block [0x8323E6A0..0x8323E6B0)
	// 8323E6A0: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 8323E6A4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8323E6A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323E6AC: 4B7E283D  bl 0x82a20ee8
	ctx.lr = 0x8323E6B0;
	sub_82A20EE8(ctx, base);
	pc = 0x8323E6B0; continue 'dispatch;
            }
            0x8323E6B0 => {
    //   block [0x8323E6B0..0x8323E6F0)
	// 8323E6B0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323E6B4: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8323E6B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323E6BC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8323E6C0: 419A0030  beq cr6, 0x8323e6f0
	if ctx.cr[6].eq {
	pc = 0x8323E6F0; continue 'dispatch;
	}
	// 8323E6C4: 89010057  lbz r8, 0x57(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(87 as u32) ) } as u64;
	// 8323E6C8: 89410051  lbz r10, 0x51(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 8323E6CC: 89210052  lbz r9, 0x52(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 8323E6D0: 89610054  lbz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323E6D4: 99010050  stb r8, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u8 ) };
	// 8323E6D8: 99410052  stb r10, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[10].u8 ) };
	// 8323E6DC: 99210051  stb r9, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[9].u8 ) };
	// 8323E6E0: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 8323E6E4: 80E10050  lwz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8323E6E8: 90FE0000  stw r7, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 8323E6EC: 48000008  b 0x8323e6f4
	pc = 0x8323E6F4; continue 'dispatch;
            }
            0x8323E6F0 => {
    //   block [0x8323E6F0..0x8323E6F4)
	// 8323E6F0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x8323E6F4; continue 'dispatch;
            }
            0x8323E6F4 => {
    //   block [0x8323E6F4..0x8323E70C)
	// 8323E6F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8323E6F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8323E6FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8323E700: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8323E704: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8323E708: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323E710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323E710 size=88
    let mut pc: u32 = 0x8323E710;
    'dispatch: loop {
        match pc {
            0x8323E710 => {
    //   block [0x8323E710..0x8323E768)
	// 8323E710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323E714: 4BA6ACF1  bl 0x82ca9404
	ctx.lr = 0x8323E718;
	sub_82CA93D0(ctx, base);
	// 8323E718: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323E71C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8323E720: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8323E724: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323E728: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8323E72C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8323E730: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 8323E734: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 8323E738: 4BFFFEF9  bl 0x8323e630
	ctx.lr = 0x8323E73C;
	sub_8323E630(ctx, base);
	// 8323E73C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323E740: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 8323E744: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 8323E748: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8323E74C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8323E750: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323E754: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8323E758: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323E75C: 4E800421  bctrl
	ctx.lr = 0x8323E760;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323E760: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8323E764: 4BA6ACF0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323E768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323E768 size=124
    let mut pc: u32 = 0x8323E768;
    'dispatch: loop {
        match pc {
            0x8323E768 => {
    //   block [0x8323E768..0x8323E7B0)
	// 8323E768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323E76C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8323E770: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8323E774: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8323E778: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323E77C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8323E780: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 8323E784: 3BFE000C  addi r31, r30, 0xc
	ctx.r[31].s64 = ctx.r[30].s64 + 12;
	// 8323E788: 394B2548  addi r10, r11, 0x2548
	ctx.r[10].s64 = ctx.r[11].s64 + 9544;
	// 8323E78C: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8323E790: 809E0010  lwz r4, 0x10(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323E794: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8323E798: 419A0018  beq cr6, 0x8323e7b0
	if ctx.cr[6].eq {
	pc = 0x8323E7B0; continue 'dispatch;
	}
	// 8323E79C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323E7A0: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8323E7A4: 4B7D7C55  bl 0x82a163f8
	ctx.lr = 0x8323E7A8;
	sub_82A163F8(ctx, base);
	// 8323E7A8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323E7AC: 4AFDD58D  bl 0x8221bd38
	ctx.lr = 0x8323E7B0;
	sub_8221BD38(ctx, base);
	pc = 0x8323E7B0; continue 'dispatch;
            }
            0x8323E7B0 => {
    //   block [0x8323E7B0..0x8323E7E4)
	// 8323E7B0: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 8323E7B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8323E7B8: 392A2720  addi r9, r10, 0x2720
	ctx.r[9].s64 = ctx.r[10].s64 + 10016;
	// 8323E7BC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8323E7C0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8323E7C4: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 8323E7C8: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8323E7CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8323E7D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8323E7D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8323E7D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8323E7DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8323E7E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323E818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323E818 size=240
    let mut pc: u32 = 0x8323E818;
    'dispatch: loop {
        match pc {
            0x8323E818 => {
    //   block [0x8323E818..0x8323E86C)
	// 8323E818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323E81C: 4BA6ABF1  bl 0x82ca940c
	ctx.lr = 0x8323E820;
	sub_82CA93D0(ctx, base);
	// 8323E820: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323E824: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8323E828: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8323E82C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8323E830: 386BE568  addi r3, r11, -0x1a98
	ctx.r[3].s64 = ctx.r[11].s64 + -6808;
	// 8323E834: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8323E838: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8323E83C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8323E840: 480024F1  bl 0x83240d30
	ctx.lr = 0x8323E844;
	sub_83240D30(ctx, base);
	// 8323E844: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8323E848: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323E84C: 419A0020  beq cr6, 0x8323e86c
	if ctx.cr[6].eq {
	pc = 0x8323E86C; continue 'dispatch;
	}
	// 8323E850: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8323E854: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8323E858: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 8323E85C: 4AF792BD  bl 0x821b7b18
	ctx.lr = 0x8323E860;
	sub_821B7B18(ctx, base);
	// 8323E860: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8323E864: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8323E868: 4BA6ABF4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x8323E86C => {
    //   block [0x8323E86C..0x8323E8AC)
	// 8323E86C: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 8323E870: 4AFE09E9  bl 0x8221f258
	ctx.lr = 0x8323E874;
	sub_8221F258(ctx, base);
	// 8323E874: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8323E878: 419A0034  beq cr6, 0x8323e8ac
	if ctx.cr[6].eq {
	pc = 0x8323E8AC; continue 'dispatch;
	}
	// 8323E87C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 8323E880: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 8323E884: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 8323E888: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8323E88C: 394B2548  addi r10, r11, 0x2548
	ctx.r[10].s64 = ctx.r[11].s64 + 9544;
	// 8323E890: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8323E894: 93E30010  stw r31, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 8323E898: 93E30014  stw r31, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	// 8323E89C: 93E30018  stw r31, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[31].u32 ) };
	// 8323E8A0: 9BE3001C  stb r31, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[31].u8 ) };
	// 8323E8A4: 93E30020  stw r31, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[31].u32 ) };
	// 8323E8A8: 48000008  b 0x8323e8b0
	pc = 0x8323E8B0; continue 'dispatch;
            }
            0x8323E8AC => {
    //   block [0x8323E8AC..0x8323E8B0)
	// 8323E8AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	pc = 0x8323E8B0; continue 'dispatch;
            }
            0x8323E8B0 => {
    //   block [0x8323E8B0..0x8323E8D8)
	// 8323E8B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8323E8B4: 4B0347A5  bl 0x82273058
	ctx.lr = 0x8323E8B8;
	sub_82273058(ctx, base);
	// 8323E8B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8323E8BC: 4BFF158D  bl 0x8322fe48
	ctx.lr = 0x8323E8C0;
	sub_8322FE48(ctx, base);
	// 8323E8C0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323E8C4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8323E8C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323E8CC: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8323E8D0: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8323E8D4: 419A0020  beq cr6, 0x8323e8f4
	if ctx.cr[6].eq {
	pc = 0x8323E8F4; continue 'dispatch;
	}
	pc = 0x8323E8D8; continue 'dispatch;
            }
            0x8323E8D8 => {
    //   block [0x8323E8D8..0x8323E8F4)
	// 8323E8D8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8323E8DC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323E8E0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8323E8E4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8323E8E8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8323E8EC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323E8F0: 4082FFE8  bne 0x8323e8d8
	if !ctx.cr[0].eq {
	pc = 0x8323E8D8; continue 'dispatch;
	}
	pc = 0x8323E8F4; continue 'dispatch;
            }
            0x8323E8F4 => {
    //   block [0x8323E8F4..0x8323E908)
	// 8323E8F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8323E8F8: 4AF79221  bl 0x821b7b18
	ctx.lr = 0x8323E8FC;
	sub_821B7B18(ctx, base);
	// 8323E8FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8323E900: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8323E904: 4BA6AB58  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323E908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323E908 size=1392
    let mut pc: u32 = 0x8323E908;
    'dispatch: loop {
        match pc {
            0x8323E908 => {
    //   block [0x8323E908..0x8323E96C)
	// 8323E908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323E90C: 4BA6AAED  bl 0x82ca93f8
	ctx.lr = 0x8323E910;
	sub_82CA93D0(ctx, base);
	// 8323E910: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323E914: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 8323E918: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8323E91C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8323E920: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 8323E924: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 8323E928: 2F1E0002  cmpwi cr6, r30, 2
	ctx.cr[6].compare_i32(ctx.r[30].s32, 2, &mut ctx.xer);
	// 8323E92C: 41980064  blt cr6, 0x8323e990
	if ctx.cr[6].lt {
	pc = 0x8323E990; continue 'dispatch;
	}
	// 8323E930: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323E934: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8323E938: 41980034  blt cr6, 0x8323e96c
	if ctx.cr[6].lt {
	pc = 0x8323E96C; continue 'dispatch;
	}
	// 8323E93C: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 8323E940: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323E944: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323E948: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 8323E94C: 38EB0001  addi r7, r11, 1
	ctx.r[7].s64 = ctx.r[11].s64 + 1;
	// 8323E950: 38CA0001  addi r6, r10, 1
	ctx.r[6].s64 = ctx.r[10].s64 + 1;
	// 8323E954: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323E958: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 8323E95C: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 8323E960: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 8323E964: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 8323E968: 48000014  b 0x8323e97c
	pc = 0x8323E97C; continue 'dispatch;
            }
            0x8323E96C => {
    //   block [0x8323E96C..0x8323E97C)
	// 8323E96C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8323E970: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8323E974: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323E978: 4B7E2571  bl 0x82a20ee8
	ctx.lr = 0x8323E97C;
	sub_82A20EE8(ctx, base);
	pc = 0x8323E97C; continue 'dispatch;
            }
            0x8323E97C => {
    //   block [0x8323E97C..0x8323E990)
	// 8323E97C: 89410050  lbz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8323E980: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 8323E984: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 8323E988: 69070001  xori r7, r8, 1
	ctx.r[7].u64 = ctx.r[8].u64 ^ 1;
	// 8323E98C: 98FB001C  stb r7, 0x1c(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(28 as u32), ctx.r[7].u8 ) };
	pc = 0x8323E990; continue 'dispatch;
            }
            0x8323E990 => {
    //   block [0x8323E990..0x8323E9EC)
	// 8323E990: 2F1E0003  cmpwi cr6, r30, 3
	ctx.cr[6].compare_i32(ctx.r[30].s32, 3, &mut ctx.xer);
	// 8323E994: 419800A4  blt cr6, 0x8323ea38
	if ctx.cr[6].lt {
	pc = 0x8323EA38; continue 'dispatch;
	}
	// 8323E998: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323E99C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 8323E9A0: 4198004C  blt cr6, 0x8323e9ec
	if ctx.cr[6].lt {
	pc = 0x8323E9EC; continue 'dispatch;
	}
	// 8323E9A4: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 8323E9A8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323E9AC: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 8323E9B0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323E9B4: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 8323E9B8: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 8323E9BC: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323E9C0: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 8323E9C4: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 8323E9C8: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 8323E9CC: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 8323E9D0: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 8323E9D4: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 8323E9D8: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 8323E9DC: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 8323E9E0: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 8323E9E4: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 8323E9E8: 48000014  b 0x8323e9fc
	pc = 0x8323E9FC; continue 'dispatch;
            }
            0x8323E9EC => {
    //   block [0x8323E9EC..0x8323E9FC)
	// 8323E9EC: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 8323E9F0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8323E9F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323E9F8: 4B7E24F1  bl 0x82a20ee8
	ctx.lr = 0x8323E9FC;
	sub_82A20EE8(ctx, base);
	pc = 0x8323E9FC; continue 'dispatch;
            }
            0x8323E9FC => {
    //   block [0x8323E9FC..0x8323EA30)
	// 8323E9FC: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8323EA00: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8323EA04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323EA08: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8323EA0C: 419A0024  beq cr6, 0x8323ea30
	if ctx.cr[6].eq {
	pc = 0x8323EA30; continue 'dispatch;
	}
	// 8323EA10: 89610055  lbz r11, 0x55(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(85 as u32) ) } as u64;
	// 8323EA14: 89410056  lbz r10, 0x56(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 8323EA18: 89210063  lbz r9, 0x63(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(99 as u32) ) } as u64;
	// 8323EA1C: 89010060  lbz r8, 0x60(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8323EA20: 99610056  stb r11, 0x56(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[11].u8 ) };
	// 8323EA24: 99410055  stb r10, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[10].u8 ) };
	// 8323EA28: 99210054  stb r9, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u8 ) };
	// 8323EA2C: 99010057  stb r8, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[8].u8 ) };
	pc = 0x8323EA30; continue 'dispatch;
            }
            0x8323EA30 => {
    //   block [0x8323EA30..0x8323EA38)
	// 8323EA30: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323EA34: 917B0020  stw r11, 0x20(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	pc = 0x8323EA38; continue 'dispatch;
            }
            0x8323EA38 => {
    //   block [0x8323EA38..0x8323EA8C)
	// 8323EA38: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323EA3C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 8323EA40: 4198004C  blt cr6, 0x8323ea8c
	if ctx.cr[6].lt {
	pc = 0x8323EA8C; continue 'dispatch;
	}
	// 8323EA44: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 8323EA48: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323EA4C: 39010064  addi r8, r1, 0x64
	ctx.r[8].s64 = ctx.r[1].s64 + 100;
	// 8323EA50: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323EA54: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 8323EA58: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 8323EA5C: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323EA60: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 8323EA64: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 8323EA68: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 8323EA6C: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 8323EA70: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 8323EA74: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 8323EA78: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 8323EA7C: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 8323EA80: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 8323EA84: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 8323EA88: 48000014  b 0x8323ea9c
	pc = 0x8323EA9C; continue 'dispatch;
            }
            0x8323EA8C => {
    //   block [0x8323EA8C..0x8323EA9C)
	// 8323EA8C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 8323EA90: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 8323EA94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323EA98: 4B7E2451  bl 0x82a20ee8
	ctx.lr = 0x8323EA9C;
	sub_82A20EE8(ctx, base);
	pc = 0x8323EA9C; continue 'dispatch;
            }
            0x8323EA9C => {
    //   block [0x8323EA9C..0x8323EAD4)
	// 8323EA9C: 83C10064  lwz r30, 0x64(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8323EAA0: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8323EAA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323EAA8: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 8323EAAC: 419A0028  beq cr6, 0x8323ead4
	if ctx.cr[6].eq {
	pc = 0x8323EAD4; continue 'dispatch;
	}
	// 8323EAB0: 89410064  lbz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8323EAB4: 89010067  lbz r8, 0x67(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(103 as u32) ) } as u64;
	// 8323EAB8: 89610056  lbz r11, 0x56(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 8323EABC: 89210055  lbz r9, 0x55(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(85 as u32) ) } as u64;
	// 8323EAC0: 99410057  stb r10, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[10].u8 ) };
	// 8323EAC4: 99010054  stb r8, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u8 ) };
	// 8323EAC8: 99610055  stb r11, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[11].u8 ) };
	// 8323EACC: 99210056  stb r9, 0x56(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[9].u8 ) };
	// 8323EAD0: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x8323EAD4; continue 'dispatch;
            }
            0x8323EAD4 => {
    //   block [0x8323EAD4..0x8323EAF0)
	// 8323EAD4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8323EAD8: 387B000C  addi r3, r27, 0xc
	ctx.r[3].s64 = ctx.r[27].s64 + 12;
	// 8323EADC: 4B7D785D  bl 0x82a16338
	ctx.lr = 0x8323EAE0;
	sub_82A16338(ctx, base);
	// 8323EAE0: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8323EAE4: 40990374  ble cr6, 0x8323ee58
	if !ctx.cr[6].gt {
	pc = 0x8323EE58; continue 'dispatch;
	}
	// 8323EAE8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8323EAEC: 7FDAF378  mr r26, r30
	ctx.r[26].u64 = ctx.r[30].u64;
	pc = 0x8323EAF0; continue 'dispatch;
            }
            0x8323EAF0 => {
    //   block [0x8323EAF0..0x8323EB44)
	// 8323EAF0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323EAF4: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 8323EAF8: 4198004C  blt cr6, 0x8323eb44
	if ctx.cr[6].lt {
	pc = 0x8323EB44; continue 'dispatch;
	}
	// 8323EAFC: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 8323EB00: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323EB04: 39010068  addi r8, r1, 0x68
	ctx.r[8].s64 = ctx.r[1].s64 + 104;
	// 8323EB08: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323EB0C: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 8323EB10: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 8323EB14: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323EB18: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 8323EB1C: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 8323EB20: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 8323EB24: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 8323EB28: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 8323EB2C: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 8323EB30: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 8323EB34: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 8323EB38: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 8323EB3C: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 8323EB40: 48000014  b 0x8323eb54
	pc = 0x8323EB54; continue 'dispatch;
            }
            0x8323EB44 => {
    //   block [0x8323EB44..0x8323EB54)
	// 8323EB44: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 8323EB48: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8323EB4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323EB50: 4B7E2399  bl 0x82a20ee8
	ctx.lr = 0x8323EB54;
	sub_82A20EE8(ctx, base);
	pc = 0x8323EB54; continue 'dispatch;
            }
            0x8323EB54 => {
    //   block [0x8323EB54..0x8323EB88)
	// 8323EB54: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323EB58: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8323EB5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323EB60: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8323EB64: 419A0024  beq cr6, 0x8323eb88
	if ctx.cr[6].eq {
	pc = 0x8323EB88; continue 'dispatch;
	}
	// 8323EB68: 89610055  lbz r11, 0x55(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(85 as u32) ) } as u64;
	// 8323EB6C: 89410056  lbz r10, 0x56(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 8323EB70: 8921006B  lbz r9, 0x6b(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(107 as u32) ) } as u64;
	// 8323EB74: 89010068  lbz r8, 0x68(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323EB78: 99610056  stb r11, 0x56(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[11].u8 ) };
	// 8323EB7C: 99410055  stb r10, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[10].u8 ) };
	// 8323EB80: 99210054  stb r9, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u8 ) };
	// 8323EB84: 99010057  stb r8, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[8].u8 ) };
	pc = 0x8323EB88; continue 'dispatch;
            }
            0x8323EB88 => {
    //   block [0x8323EB88..0x8323EBEC)
	// 8323EB88: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323EB8C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323EB90: 7D2BE214  add r9, r11, r28
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 8323EB94: 91490010  stw r10, 0x10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8323EB98: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323EB9C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 8323EBA0: 4198004C  blt cr6, 0x8323ebec
	if ctx.cr[6].lt {
	pc = 0x8323EBEC; continue 'dispatch;
	}
	// 8323EBA4: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 8323EBA8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323EBAC: 3901006C  addi r8, r1, 0x6c
	ctx.r[8].s64 = ctx.r[1].s64 + 108;
	// 8323EBB0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323EBB4: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 8323EBB8: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 8323EBBC: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323EBC0: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 8323EBC4: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 8323EBC8: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 8323EBCC: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 8323EBD0: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 8323EBD4: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 8323EBD8: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 8323EBDC: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 8323EBE0: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 8323EBE4: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 8323EBE8: 48000014  b 0x8323ebfc
	pc = 0x8323EBFC; continue 'dispatch;
            }
            0x8323EBEC => {
    //   block [0x8323EBEC..0x8323EBFC)
	// 8323EBEC: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 8323EBF0: 3881006C  addi r4, r1, 0x6c
	ctx.r[4].s64 = ctx.r[1].s64 + 108;
	// 8323EBF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323EBF8: 4B7E22F1  bl 0x82a20ee8
	ctx.lr = 0x8323EBFC;
	sub_82A20EE8(ctx, base);
	pc = 0x8323EBFC; continue 'dispatch;
            }
            0x8323EBFC => {
    //   block [0x8323EBFC..0x8323EC34)
	// 8323EBFC: 83C1006C  lwz r30, 0x6c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8323EC00: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8323EC04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323EC08: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 8323EC0C: 419A0028  beq cr6, 0x8323ec34
	if ctx.cr[6].eq {
	pc = 0x8323EC34; continue 'dispatch;
	}
	// 8323EC10: 89010055  lbz r8, 0x55(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(85 as u32) ) } as u64;
	// 8323EC14: 8941006F  lbz r10, 0x6f(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(111 as u32) ) } as u64;
	// 8323EC18: 8921006C  lbz r9, 0x6c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8323EC1C: 89610056  lbz r11, 0x56(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 8323EC20: 99010056  stb r8, 0x56(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[8].u8 ) };
	// 8323EC24: 99410054  stb r10, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u8 ) };
	// 8323EC28: 99210057  stb r9, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[9].u8 ) };
	// 8323EC2C: 99610055  stb r11, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[11].u8 ) };
	// 8323EC30: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x8323EC34; continue 'dispatch;
            }
            0x8323EC34 => {
    //   block [0x8323EC34..0x8323EC50)
	// 8323EC34: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323EC38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8323EC3C: 7C6BE214  add r3, r11, r28
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 8323EC40: 4B7D7631  bl 0x82a16270
	ctx.lr = 0x8323EC44;
	sub_82A16270(ctx, base);
	// 8323EC44: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8323EC48: 40990204  ble cr6, 0x8323ee4c
	if !ctx.cr[6].gt {
	pc = 0x8323EE4C; continue 'dispatch;
	}
	// 8323EC4C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x8323EC50; continue 'dispatch;
            }
            0x8323EC50 => {
    //   block [0x8323EC50..0x8323ECA4)
	// 8323EC50: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323EC54: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 8323EC58: 4198004C  blt cr6, 0x8323eca4
	if ctx.cr[6].lt {
	pc = 0x8323ECA4; continue 'dispatch;
	}
	// 8323EC5C: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 8323EC60: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323EC64: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 8323EC68: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323EC6C: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 8323EC70: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 8323EC74: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323EC78: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 8323EC7C: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 8323EC80: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 8323EC84: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 8323EC88: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 8323EC8C: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 8323EC90: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 8323EC94: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 8323EC98: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 8323EC9C: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 8323ECA0: 48000014  b 0x8323ecb4
	pc = 0x8323ECB4; continue 'dispatch;
            }
            0x8323ECA4 => {
    //   block [0x8323ECA4..0x8323ECB4)
	// 8323ECA4: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 8323ECA8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8323ECAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323ECB0: 4B7E2239  bl 0x82a20ee8
	ctx.lr = 0x8323ECB4;
	sub_82A20EE8(ctx, base);
	pc = 0x8323ECB4; continue 'dispatch;
            }
            0x8323ECB4 => {
    //   block [0x8323ECB4..0x8323ECE8)
	// 8323ECB4: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 8323ECB8: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8323ECBC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323ECC0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8323ECC4: 419A0024  beq cr6, 0x8323ece8
	if ctx.cr[6].eq {
	pc = 0x8323ECE8; continue 'dispatch;
	}
	// 8323ECC8: 89610055  lbz r11, 0x55(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(85 as u32) ) } as u64;
	// 8323ECCC: 89410056  lbz r10, 0x56(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 8323ECD0: 89210073  lbz r9, 0x73(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(115 as u32) ) } as u64;
	// 8323ECD4: 89010070  lbz r8, 0x70(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 8323ECD8: 99610056  stb r11, 0x56(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[11].u8 ) };
	// 8323ECDC: 99410055  stb r10, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[10].u8 ) };
	// 8323ECE0: 99210054  stb r9, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u8 ) };
	// 8323ECE4: 99010057  stb r8, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[8].u8 ) };
	pc = 0x8323ECE8; continue 'dispatch;
            }
            0x8323ECE8 => {
    //   block [0x8323ECE8..0x8323ED3C)
	// 8323ECE8: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323ECEC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 8323ECF0: 4198004C  blt cr6, 0x8323ed3c
	if ctx.cr[6].lt {
	pc = 0x8323ED3C; continue 'dispatch;
	}
	// 8323ECF4: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 8323ECF8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323ECFC: 39010074  addi r8, r1, 0x74
	ctx.r[8].s64 = ctx.r[1].s64 + 116;
	// 8323ED00: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323ED04: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 8323ED08: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 8323ED0C: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323ED10: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 8323ED14: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 8323ED18: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 8323ED1C: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 8323ED20: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 8323ED24: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 8323ED28: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 8323ED2C: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 8323ED30: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 8323ED34: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 8323ED38: 48000014  b 0x8323ed4c
	pc = 0x8323ED4C; continue 'dispatch;
            }
            0x8323ED3C => {
    //   block [0x8323ED3C..0x8323ED4C)
	// 8323ED3C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 8323ED40: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 8323ED44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323ED48: 4B7E21A1  bl 0x82a20ee8
	ctx.lr = 0x8323ED4C;
	sub_82A20EE8(ctx, base);
	pc = 0x8323ED4C; continue 'dispatch;
            }
            0x8323ED4C => {
    //   block [0x8323ED4C..0x8323ED80)
	// 8323ED4C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8323ED50: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8323ED54: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323ED58: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8323ED5C: 419A0024  beq cr6, 0x8323ed80
	if ctx.cr[6].eq {
	pc = 0x8323ED80; continue 'dispatch;
	}
	// 8323ED60: 89610059  lbz r11, 0x59(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(89 as u32) ) } as u64;
	// 8323ED64: 8941005A  lbz r10, 0x5a(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(90 as u32) ) } as u64;
	// 8323ED68: 89210077  lbz r9, 0x77(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(119 as u32) ) } as u64;
	// 8323ED6C: 89010074  lbz r8, 0x74(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8323ED70: 9961005A  stb r11, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[11].u8 ) };
	// 8323ED74: 99410059  stb r10, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[10].u8 ) };
	// 8323ED78: 99210058  stb r9, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 8323ED7C: 9901005B  stb r8, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[8].u8 ) };
	pc = 0x8323ED80; continue 'dispatch;
            }
            0x8323ED80 => {
    //   block [0x8323ED80..0x8323EDD4)
	// 8323ED80: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323ED84: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 8323ED88: 4198004C  blt cr6, 0x8323edd4
	if ctx.cr[6].lt {
	pc = 0x8323EDD4; continue 'dispatch;
	}
	// 8323ED8C: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 8323ED90: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323ED94: 39010078  addi r8, r1, 0x78
	ctx.r[8].s64 = ctx.r[1].s64 + 120;
	// 8323ED98: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323ED9C: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 8323EDA0: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 8323EDA4: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323EDA8: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 8323EDAC: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 8323EDB0: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 8323EDB4: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 8323EDB8: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 8323EDBC: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 8323EDC0: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 8323EDC4: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 8323EDC8: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 8323EDCC: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 8323EDD0: 48000014  b 0x8323ede4
	pc = 0x8323EDE4; continue 'dispatch;
            }
            0x8323EDD4 => {
    //   block [0x8323EDD4..0x8323EDE4)
	// 8323EDD4: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 8323EDD8: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 8323EDDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323EDE0: 4B7E2109  bl 0x82a20ee8
	ctx.lr = 0x8323EDE4;
	sub_82A20EE8(ctx, base);
	pc = 0x8323EDE4; continue 'dispatch;
            }
            0x8323EDE4 => {
    //   block [0x8323EDE4..0x8323EE18)
	// 8323EDE4: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 8323EDE8: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8323EDEC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8323EDF0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8323EDF4: 419A0024  beq cr6, 0x8323ee18
	if ctx.cr[6].eq {
	pc = 0x8323EE18; continue 'dispatch;
	}
	// 8323EDF8: 8961005D  lbz r11, 0x5d(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(93 as u32) ) } as u64;
	// 8323EDFC: 8941005E  lbz r10, 0x5e(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(94 as u32) ) } as u64;
	// 8323EE00: 8921007B  lbz r9, 0x7b(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(123 as u32) ) } as u64;
	// 8323EE04: 89010078  lbz r8, 0x78(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 8323EE08: 9961005E  stb r11, 0x5e(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(94 as u32), ctx.r[11].u8 ) };
	// 8323EE0C: 9941005D  stb r10, 0x5d(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(93 as u32), ctx.r[10].u8 ) };
	// 8323EE10: 9921005C  stb r9, 0x5c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u8 ) };
	// 8323EE14: 9901005F  stb r8, 0x5f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(95 as u32), ctx.r[8].u8 ) };
	pc = 0x8323EE18; continue 'dispatch;
            }
            0x8323EE18 => {
    //   block [0x8323EE18..0x8323EE4C)
	// 8323EE18: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323EE1C: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8323EE20: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323EE24: 7D2BE214  add r9, r11, r28
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 8323EE28: 81010058  lwz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8323EE2C: 80E1005C  lwz r7, 0x5c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8323EE30: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323EE34: 7CCBEA14  add r6, r11, r29
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 8323EE38: 3BBD000C  addi r29, r29, 0xc
	ctx.r[29].s64 = ctx.r[29].s64 + 12;
	// 8323EE3C: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8323EE40: 91060004  stw r8, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 8323EE44: 90E60008  stw r7, 8(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 8323EE48: 4082FE08  bne 0x8323ec50
	if !ctx.cr[0].eq {
	pc = 0x8323EC50; continue 'dispatch;
	}
	pc = 0x8323EE4C; continue 'dispatch;
            }
            0x8323EE4C => {
    //   block [0x8323EE4C..0x8323EE58)
	// 8323EE4C: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 8323EE50: 3B9C0014  addi r28, r28, 0x14
	ctx.r[28].s64 = ctx.r[28].s64 + 20;
	// 8323EE54: 4082FC9C  bne 0x8323eaf0
	if !ctx.cr[0].eq {
	pc = 0x8323EAF0; continue 'dispatch;
	}
	pc = 0x8323EE58; continue 'dispatch;
            }
            0x8323EE58 => {
    //   block [0x8323EE58..0x8323EE78)
	// 8323EE58: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8323EE5C: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 8323EE60: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 8323EE64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8323EE68: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8323EE6C: 4BFFD015  bl 0x8323be80
	ctx.lr = 0x8323EE70;
	sub_8323BE80(ctx, base);
	// 8323EE70: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 8323EE74: 4BA6A5D4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323EE78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323EE78 size=592
    let mut pc: u32 = 0x8323EE78;
    'dispatch: loop {
        match pc {
            0x8323EE78 => {
    //   block [0x8323EE78..0x8323EEB4)
	// 8323EE78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323EE7C: 4BA6A56D  bl 0x82ca93e8
	ctx.lr = 0x8323EE80;
	sub_82CA93D0(ctx, base);
	// 8323EE80: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323EE84: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8323EE88: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8323EE8C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8323EE90: 3B0BFFDF  addi r24, r11, -0x21
	ctx.r[24].s64 = ctx.r[11].s64 + -33;
	// 8323EE94: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8323EE98: 816AE85C  lwz r11, -0x17a4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-6052 as u32) ) } as u64;
	// 8323EE9C: 7CB52B78  mr r21, r5
	ctx.r[21].u64 = ctx.r[5].u64;
	// 8323EEA0: 7CD43378  mr r20, r6
	ctx.r[20].u64 = ctx.r[6].u64;
	// 8323EEA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323EEA8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8323EEAC: 419A0008  beq cr6, 0x8323eeb4
	if ctx.cr[6].eq {
	pc = 0x8323EEB4; continue 'dispatch;
	}
	// 8323EEB0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8323EEB4; continue 'dispatch;
            }
            0x8323EEB4 => {
    //   block [0x8323EEB4..0x8323EF08)
	// 8323EEB4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323EEB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323EEBC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323EEC0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323EEC4: 4E800421  bctrl
	ctx.lr = 0x8323EEC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323EEC8: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8323EECC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8323EED0: 419A01F0  beq cr6, 0x8323f0c0
	if ctx.cr[6].eq {
	pc = 0x8323F0C0; continue 'dispatch;
	}
	// 8323EED4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8323EED8: 38BB001C  addi r5, r27, 0x1c
	ctx.r[5].s64 = ctx.r[27].s64 + 28;
	// 8323EEDC: 386BE870  addi r3, r11, -0x1790
	ctx.r[3].s64 = ctx.r[11].s64 + -6032;
	// 8323EEE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8323EEE4: 4BFF671D  bl 0x83235600
	ctx.lr = 0x8323EEE8;
	sub_83235600(ctx, base);
	// 8323EEE8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8323EEEC: 813B0020  lwz r9, 0x20(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 8323EEF0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8323EEF4: 816AE874  lwz r11, -0x178c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-6028 as u32) ) } as u64;
	// 8323EEF8: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 8323EEFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323EF00: 419A0008  beq cr6, 0x8323ef08
	if ctx.cr[6].eq {
	pc = 0x8323EF08; continue 'dispatch;
	}
	// 8323EF04: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x8323EF08 => {
    //   block [0x8323EF08..0x8323EF34)
	// 8323EF08: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8323EF0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323EF10: 4B151179  bl 0x82390088
	ctx.lr = 0x8323EF14;
	sub_82390088(ctx, base);
	// 8323EF14: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8323EF18: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 8323EF1C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8323EF20: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 8323EF24: 816BE860  lwz r11, -0x17a0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6048 as u32) ) } as u64;
	// 8323EF28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323EF2C: 419A0008  beq cr6, 0x8323ef34
	if ctx.cr[6].eq {
	pc = 0x8323EF34; continue 'dispatch;
	}
	// 8323EF30: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8323EF34; continue 'dispatch;
            }
            0x8323EF34 => {
    //   block [0x8323EF34..0x8323EF68)
	// 8323EF34: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 8323EF38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323EF3C: 4B24188D  bl 0x824807c8
	ctx.lr = 0x8323EF40;
	sub_824807C8(ctx, base);
	// 8323EF40: 387B000C  addi r3, r27, 0xc
	ctx.r[3].s64 = ctx.r[27].s64 + 12;
	// 8323EF44: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323EF48: 4B7D73F1  bl 0x82a16338
	ctx.lr = 0x8323EF4C;
	sub_82A16338(ctx, base);
	// 8323EF4C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323EF50: 7F36CB78  mr r22, r25
	ctx.r[22].u64 = ctx.r[25].u64;
	// 8323EF54: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8323EF58: 4099013C  ble cr6, 0x8323f094
	if !ctx.cr[6].gt {
	pc = 0x8323F094; continue 'dispatch;
	}
	// 8323EF5C: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	// 8323EF60: 3F40834A  lis r26, -0x7cb6
	ctx.r[26].s64 = -2092302336;
	// 8323EF64: 3EE0834A  lis r23, -0x7cb6
	ctx.r[23].s64 = -2092302336;
	pc = 0x8323EF68; continue 'dispatch;
            }
            0x8323EF68 => {
    //   block [0x8323EF68..0x8323EF88)
	// 8323EF68: 815B0010  lwz r10, 0x10(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323EF6C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8323EF70: 8177E868  lwz r11, -0x1798(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-6040 as u32) ) } as u64;
	// 8323EF74: 7D4AE214  add r10, r10, r28
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 8323EF78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323EF7C: 38AA0010  addi r5, r10, 0x10
	ctx.r[5].s64 = ctx.r[10].s64 + 16;
	// 8323EF80: 419A0008  beq cr6, 0x8323ef88
	if ctx.cr[6].eq {
	pc = 0x8323EF88; continue 'dispatch;
	}
	// 8323EF84: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8323EF88; continue 'dispatch;
            }
            0x8323EF88 => {
    //   block [0x8323EF88..0x8323EFA8)
	// 8323EF88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323EF8C: 4B24183D  bl 0x824807c8
	ctx.lr = 0x8323EF90;
	sub_824807C8(ctx, base);
	// 8323EF90: 817AE864  lwz r11, -0x179c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6044 as u32) ) } as u64;
	// 8323EF94: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 8323EF98: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8323EF9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323EFA0: 419A0008  beq cr6, 0x8323efa8
	if ctx.cr[6].eq {
	pc = 0x8323EFA8; continue 'dispatch;
	}
	// 8323EFA4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8323EFA8; continue 'dispatch;
            }
            0x8323EFA8 => {
    //   block [0x8323EFA8..0x8323EFD8)
	// 8323EFA8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8323EFAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323EFB0: 4B241819  bl 0x824807c8
	ctx.lr = 0x8323EFB4;
	sub_824807C8(ctx, base);
	// 8323EFB4: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323EFB8: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8323EFBC: 7C6BE214  add r3, r11, r28
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 8323EFC0: 4B7D72B1  bl 0x82a16270
	ctx.lr = 0x8323EFC4;
	sub_82A16270(ctx, base);
	// 8323EFC4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8323EFC8: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 8323EFCC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8323EFD0: 409900B0  ble cr6, 0x8323f080
	if !ctx.cr[6].gt {
	pc = 0x8323F080; continue 'dispatch;
	}
	// 8323EFD4: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	pc = 0x8323EFD8; continue 'dispatch;
            }
            0x8323EFD8 => {
    //   block [0x8323EFD8..0x8323EFF8)
	// 8323EFD8: 817AE864  lwz r11, -0x179c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6044 as u32) ) } as u64;
	// 8323EFDC: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8323EFE0: 93210060  stw r25, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[25].u32 ) };
	// 8323EFE4: 93210064  stw r25, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[25].u32 ) };
	// 8323EFE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323EFEC: 93210068  stw r25, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[25].u32 ) };
	// 8323EFF0: 419A0008  beq cr6, 0x8323eff8
	if ctx.cr[6].eq {
	pc = 0x8323EFF8; continue 'dispatch;
	}
	// 8323EFF4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8323EFF8; continue 'dispatch;
            }
            0x8323EFF8 => {
    //   block [0x8323EFF8..0x8323F018)
	// 8323EFF8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8323EFFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323F000: 4B151089  bl 0x82390088
	ctx.lr = 0x8323F004;
	sub_82390088(ctx, base);
	// 8323F004: 817AE864  lwz r11, -0x179c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6044 as u32) ) } as u64;
	// 8323F008: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8323F00C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323F010: 419A0008  beq cr6, 0x8323f018
	if ctx.cr[6].eq {
	pc = 0x8323F018; continue 'dispatch;
	}
	// 8323F014: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8323F018; continue 'dispatch;
            }
            0x8323F018 => {
    //   block [0x8323F018..0x8323F038)
	// 8323F018: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 8323F01C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323F020: 4B151069  bl 0x82390088
	ctx.lr = 0x8323F024;
	sub_82390088(ctx, base);
	// 8323F024: 817AE864  lwz r11, -0x179c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6044 as u32) ) } as u64;
	// 8323F028: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8323F02C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323F030: 419A0008  beq cr6, 0x8323f038
	if ctx.cr[6].eq {
	pc = 0x8323F038; continue 'dispatch;
	}
	// 8323F034: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8323F038; continue 'dispatch;
            }
            0x8323F038 => {
    //   block [0x8323F038..0x8323F080)
	// 8323F038: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 8323F03C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323F040: 4B151049  bl 0x82390088
	ctx.lr = 0x8323F044;
	sub_82390088(ctx, base);
	// 8323F044: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 8323F048: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8323F04C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 8323F050: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 8323F054: 81210064  lwz r9, 0x64(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8323F058: 80E10068  lwz r7, 0x68(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8323F05C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323F060: 7D0BEA14  add r8, r11, r29
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 8323F064: 3BBD000C  addi r29, r29, 0xc
	ctx.r[29].s64 = ctx.r[29].s64 + 12;
	// 8323F068: 91480000  stw r10, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8323F06C: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8323F070: 90E80008  stw r7, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 8323F074: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8323F078: 7F1F3000  cmpw cr6, r31, r6
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[6].s32, &mut ctx.xer);
	// 8323F07C: 4198FF5C  blt cr6, 0x8323efd8
	if ctx.cr[6].lt {
	pc = 0x8323EFD8; continue 'dispatch;
	}
	pc = 0x8323F080; continue 'dispatch;
            }
            0x8323F080 => {
    //   block [0x8323F080..0x8323F094)
	// 8323F080: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8323F084: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	// 8323F088: 3B9C0014  addi r28, r28, 0x14
	ctx.r[28].s64 = ctx.r[28].s64 + 20;
	// 8323F08C: 7F165800  cmpw cr6, r22, r11
	ctx.cr[6].compare_i32(ctx.r[22].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8323F090: 4198FED8  blt cr6, 0x8323ef68
	if ctx.cr[6].lt {
	pc = 0x8323EF68; continue 'dispatch;
	}
	pc = 0x8323F094; continue 'dispatch;
            }
            0x8323F094 => {
    //   block [0x8323F094..0x8323F0C0)
	// 8323F094: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8323F098: 7E86A378  mr r6, r20
	ctx.r[6].u64 = ctx.r[20].u64;
	// 8323F09C: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 8323F0A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8323F0A4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8323F0A8: 4BFFCCC1  bl 0x8323bd68
	ctx.lr = 0x8323F0AC;
	sub_8323BD68(ctx, base);
	// 8323F0AC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323F0B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323F0B4: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323F0B8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323F0BC: 4E800421  bctrl
	ctx.lr = 0x8323F0C0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8323F0C0 => {
    //   block [0x8323F0C0..0x8323F0C8)
	// 8323F0C0: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 8323F0C4: 4BA6A374  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323F0C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8323F0C8 size=8
    let mut pc: u32 = 0x8323F0C8;
    'dispatch: loop {
        match pc {
            0x8323F0C8 => {
    //   block [0x8323F0C8..0x8323F0D0)
	// 8323F0C8: 38630130  addi r3, r3, 0x130
	ctx.r[3].s64 = ctx.r[3].s64 + 304;
	// 8323F0CC: 4BFDF16C  b 0x8321e238
	sub_8321E238(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323F0D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323F0D0 size=120
    let mut pc: u32 = 0x8323F0D0;
    'dispatch: loop {
        match pc {
            0x8323F0D0 => {
    //   block [0x8323F0D0..0x8323F118)
	// 8323F0D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323F0D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8323F0D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8323F0DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323F0E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8323F0E4: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 8323F0E8: 387F0130  addi r3, r31, 0x130
	ctx.r[3].s64 = ctx.r[31].s64 + 304;
	// 8323F0EC: 394B2440  addi r10, r11, 0x2440
	ctx.r[10].s64 = ctx.r[11].s64 + 9280;
	// 8323F0F0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8323F0F4: 4BFDF145  bl 0x8321e238
	ctx.lr = 0x8323F0F8;
	sub_8321E238(ctx, base);
	// 8323F0F8: 807F013C  lwz r3, 0x13c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 8323F0FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8323F100: 419A0018  beq cr6, 0x8323f118
	if ctx.cr[6].eq {
	pc = 0x8323F118; continue 'dispatch;
	}
	// 8323F104: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323F108: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8323F10C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323F110: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323F114: 4E800421  bctrl
	ctx.lr = 0x8323F118;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8323F118 => {
    //   block [0x8323F118..0x8323F148)
	// 8323F118: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 8323F11C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8323F120: 392B25A8  addi r9, r11, 0x25a8
	ctx.r[9].s64 = ctx.r[11].s64 + 9640;
	// 8323F124: 915F013C  stw r10, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[10].u32 ) };
	// 8323F128: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323F12C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8323F130: 4BFEA1E9  bl 0x83229318
	ctx.lr = 0x8323F134;
	sub_83229318(ctx, base);
	// 8323F134: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8323F138: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8323F13C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8323F140: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8323F144: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323F148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323F148 size=160
    let mut pc: u32 = 0x8323F148;
    'dispatch: loop {
        match pc {
            0x8323F148 => {
    //   block [0x8323F148..0x8323F1E8)
	// 8323F148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323F14C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8323F150: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8323F154: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323F158: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8323F15C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 8323F160: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 8323F164: 4BFEA48D  bl 0x832295f0
	ctx.lr = 0x8323F168;
	sub_832295F0(ctx, base);
	// 8323F168: 396100D0  addi r11, r1, 0xd0
	ctx.r[11].s64 = ctx.r[1].s64 + 208;
	// 8323F16C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 8323F170: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8323F174: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 8323F178: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 8323F17C: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323F1E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323F1E8 size=104
    let mut pc: u32 = 0x8323F1E8;
    'dispatch: loop {
        match pc {
            0x8323F1E8 => {
    //   block [0x8323F1E8..0x8323F238)
	// 8323F1E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323F1EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8323F1F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8323F1F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8323F1F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323F1FC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8323F200: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8323F204: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323F208: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323F20C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323F210: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323F214: 4E800421  bctrl
	ctx.lr = 0x8323F218;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323F218: 2F030008  cmpwi cr6, r3, 8
	ctx.cr[6].compare_i32(ctx.r[3].s32, 8, &mut ctx.xer);
	// 8323F21C: 409A001C  bne cr6, 0x8323f238
	if !ctx.cr[6].eq {
	pc = 0x8323F238; continue 'dispatch;
	}
	// 8323F220: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8323F224: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323F228: 48001639  bl 0x83240860
	ctx.lr = 0x8323F22C;
	sub_83240860(ctx, base);
	// 8323F22C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323F230: 807E0140  lwz r3, 0x140(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(320 as u32) ) } as u64;
	// 8323F234: 4BFDDBAD  bl 0x8321cde0
	ctx.lr = 0x8323F238;
	sub_8321CDE0(ctx, base);
            }
            0x8323F238 => {
    //   block [0x8323F238..0x8323F250)
	// 8323F238: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8323F23C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8323F240: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8323F244: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8323F248: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8323F24C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323F250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8323F250 size=536
    let mut pc: u32 = 0x8323F250;
    'dispatch: loop {
        match pc {
            0x8323F250 => {
    //   block [0x8323F250..0x8323F468)
	// 8323F250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323F254: 4BA6A1B9  bl 0x82ca940c
	ctx.lr = 0x8323F258;
	sub_82CA93D0(ctx, base);
	// 8323F258: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 8323F25C: 4BA6EA79  bl 0x82cadcd4
	ctx.lr = 0x8323F260;
	sub_82CADCA0(ctx, base);
	// 8323F260: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323F468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323F468 size=276
    let mut pc: u32 = 0x8323F468;
    'dispatch: loop {
        match pc {
            0x8323F468 => {
    //   block [0x8323F468..0x8323F4C4)
	// 8323F468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323F46C: 4BA69F9D  bl 0x82ca9408
	ctx.lr = 0x8323F470;
	sub_82CA93D0(ctx, base);
	// 8323F470: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 8323F474: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323F478: 83E500D4  lwz r31, 0xd4(r5)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(212 as u32) ) } as u64;
	// 8323F47C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8323F480: 83A500D0  lwz r29, 0xd0(r5)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(208 as u32) ) } as u64;
	// 8323F484: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8323F488: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8323F48C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 8323F490: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8323F494: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8323F498: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8323F49C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8323F4A0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8323F4A4: 419A0020  beq cr6, 0x8323f4c4
	if ctx.cr[6].eq {
	pc = 0x8323F4C4; continue 'dispatch;
	}
	// 8323F4A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8323F4AC: 4AF7866D  bl 0x821b7b18
	ctx.lr = 0x8323F4B0;
	sub_821B7B18(ctx, base);
	// 8323F4B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323F4B4: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 8323F4B8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8323F4BC: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8323F4C0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x8323F4C4; continue 'dispatch;
            }
            0x8323F4C4 => {
    //   block [0x8323F4C4..0x8323F4F0)
	// 8323F4C4: 83FE00D4  lwz r31, 0xd4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(212 as u32) ) } as u64;
	// 8323F4C8: 83DE00D0  lwz r30, 0xd0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(208 as u32) ) } as u64;
	// 8323F4CC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8323F4D0: 419A0020  beq cr6, 0x8323f4f0
	if ctx.cr[6].eq {
	pc = 0x8323F4F0; continue 'dispatch;
	}
	// 8323F4D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8323F4D8: 4AF78641  bl 0x821b7b18
	ctx.lr = 0x8323F4DC;
	sub_821B7B18(ctx, base);
	// 8323F4DC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323F4E0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8323F4E4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8323F4E8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8323F4EC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x8323F4F0; continue 'dispatch;
            }
            0x8323F4F0 => {
    //   block [0x8323F4F0..0x8323F51C)
	// 8323F4F0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 8323F4F4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8323F4F8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8323F4FC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8323F500: 4BFDDC51  bl 0x8321d150
	ctx.lr = 0x8323F504;
	sub_8321D150(ctx, base);
	// 8323F504: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323F508: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8323F50C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323F510: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323F514: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8323F518: 419A0020  beq cr6, 0x8323f538
	if ctx.cr[6].eq {
	pc = 0x8323F538; continue 'dispatch;
	}
	pc = 0x8323F51C; continue 'dispatch;
            }
            0x8323F51C => {
    //   block [0x8323F51C..0x8323F538)
	// 8323F51C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8323F520: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323F524: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8323F528: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8323F52C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8323F530: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323F534: 4082FFE8  bne 0x8323f51c
	if !ctx.cr[0].eq {
	pc = 0x8323F51C; continue 'dispatch;
	}
	pc = 0x8323F538; continue 'dispatch;
            }
            0x8323F538 => {
    //   block [0x8323F538..0x8323F57C)
	// 8323F538: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323F53C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8323F540: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8323F544: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8323F548: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323F54C: 4E800421  bctrl
	ctx.lr = 0x8323F550;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323F550: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323F554: 4AF785C5  bl 0x821b7b18
	ctx.lr = 0x8323F558;
	sub_821B7B18(ctx, base);
	// 8323F558: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8323F55C: 4AF785BD  bl 0x821b7b18
	ctx.lr = 0x8323F560;
	sub_821B7B18(ctx, base);
	// 8323F560: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8323F564: 4AF785B5  bl 0x821b7b18
	ctx.lr = 0x8323F568;
	sub_821B7B18(ctx, base);
	// 8323F568: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8323F56C: 4AF785AD  bl 0x821b7b18
	ctx.lr = 0x8323F570;
	sub_821B7B18(ctx, base);
	// 8323F570: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8323F574: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 8323F578: 4BA69EE0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323F580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8323F580 size=4
    let mut pc: u32 = 0x8323F580;
    'dispatch: loop {
        match pc {
            0x8323F580 => {
    //   block [0x8323F580..0x8323F584)
	// 8323F580: 4BFEA700  b 0x83229c80
	sub_83229C80(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323F588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323F588 size=140
    let mut pc: u32 = 0x8323F588;
    'dispatch: loop {
        match pc {
            0x8323F588 => {
    //   block [0x8323F588..0x8323F5C0)
	// 8323F588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323F58C: 4BA69E7D  bl 0x82ca9408
	ctx.lr = 0x8323F590;
	sub_82CA93D0(ctx, base);
	// 8323F590: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323F594: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8323F598: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8323F59C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8323F5A0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8323F5A4: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 8323F5A8: 816BE720  lwz r11, -0x18e0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6368 as u32) ) } as u64;
	// 8323F5AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323F5B0: 409A0010  bne cr6, 0x8323f5c0
	if !ctx.cr[6].eq {
	pc = 0x8323F5C0; continue 'dispatch;
	}
	// 8323F5B4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8323F5B8: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 8323F5BC: 48000008  b 0x8323f5c4
	pc = 0x8323F5C4; continue 'dispatch;
            }
            0x8323F5C0 => {
    //   block [0x8323F5C0..0x8323F5C4)
	// 8323F5C0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8323F5C4; continue 'dispatch;
            }
            0x8323F5C4 => {
    //   block [0x8323F5C4..0x8323F60C)
	// 8323F5C4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323F5C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323F5CC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323F5D0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323F5D4: 4E800421  bctrl
	ctx.lr = 0x8323F5D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323F5D8: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8323F5DC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8323F5E0: 419A002C  beq cr6, 0x8323f60c
	if ctx.cr[6].eq {
	pc = 0x8323F60C; continue 'dispatch;
	}
	// 8323F5E4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 8323F5E8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8323F5EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8323F5F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323F5F4: 48001525  bl 0x83240b18
	ctx.lr = 0x8323F5F8;
	sub_83240B18(ctx, base);
	// 8323F5F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323F5FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323F600: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323F604: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323F608: 4E800421  bctrl
	ctx.lr = 0x8323F60C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8323F60C => {
    //   block [0x8323F60C..0x8323F614)
	// 8323F60C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8323F610: 4BA69E48  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323F618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323F618 size=200
    let mut pc: u32 = 0x8323F618;
    'dispatch: loop {
        match pc {
            0x8323F618 => {
    //   block [0x8323F618..0x8323F648)
	// 8323F618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323F61C: 4BA69DED  bl 0x82ca9408
	ctx.lr = 0x8323F620;
	sub_82CA93D0(ctx, base);
	// 8323F620: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323F624: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8323F628: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8323F62C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 8323F630: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323F634: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323F638: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323F63C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8323F640: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8323F644: 419A0020  beq cr6, 0x8323f664
	if ctx.cr[6].eq {
	pc = 0x8323F664; continue 'dispatch;
	}
	pc = 0x8323F648; continue 'dispatch;
            }
            0x8323F648 => {
    //   block [0x8323F648..0x8323F664)
	// 8323F648: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8323F64C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323F650: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8323F654: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8323F658: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8323F65C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323F660: 4082FFE8  bne 0x8323f648
	if !ctx.cr[0].eq {
	pc = 0x8323F648; continue 'dispatch;
	}
	pc = 0x8323F664; continue 'dispatch;
            }
            0x8323F664 => {
    //   block [0x8323F664..0x8323F6E0)
	// 8323F664: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8323F668: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8323F66C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323F670: 48001539  bl 0x83240ba8
	ctx.lr = 0x8323F674;
	sub_83240BA8(ctx, base);
	// 8323F674: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8323F678: 4AF784A1  bl 0x821b7b18
	ctx.lr = 0x8323F67C;
	sub_821B7B18(ctx, base);
	// 8323F67C: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 8323F680: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8323F684: 392A2440  addi r9, r10, 0x2440
	ctx.r[9].s64 = ctx.r[10].s64 + 9280;
	// 8323F688: 3D00834C  lis r8, -0x7cb4
	ctx.r[8].s64 = -2092171264;
	// 8323F68C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8323F690: 3BDF0130  addi r30, r31, 0x130
	ctx.r[30].s64 = ctx.r[31].s64 + 304;
	// 8323F694: 917F0130  stw r11, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 8323F698: 917F0134  stw r11, 0x134(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[11].u32 ) };
	// 8323F69C: 997F0138  stb r11, 0x138(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), ctx.r[11].u8 ) };
	// 8323F6A0: 80FD0000  lwz r7, 0(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323F6A4: 90FF0140  stw r7, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[7].u32 ) };
	// 8323F6A8: 8068E8D0  lwz r3, -0x1730(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-5936 as u32) ) } as u64;
	// 8323F6AC: 80C30000  lwz r6, 0(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323F6B0: 80A60004  lwz r5, 4(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323F6B4: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 8323F6B8: 4E800421  bctrl
	ctx.lr = 0x8323F6BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323F6BC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8323F6C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323F6C4: 93BF013C  stw r29, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[29].u32 ) };
	// 8323F6C8: 4BFDEB71  bl 0x8321e238
	ctx.lr = 0x8323F6CC;
	sub_8321E238(ctx, base);
	// 8323F6CC: 93BF0130  stw r29, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[29].u32 ) };
	// 8323F6D0: 939F0134  stw r28, 0x134(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[28].u32 ) };
	// 8323F6D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323F6D8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8323F6DC: 4BA69D7C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323F6E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323F6E0 size=220
    let mut pc: u32 = 0x8323F6E0;
    'dispatch: loop {
        match pc {
            0x8323F6E0 => {
    //   block [0x8323F6E0..0x8323F718)
	// 8323F6E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323F6E4: 4BA69D29  bl 0x82ca940c
	ctx.lr = 0x8323F6E8;
	sub_82CA93D0(ctx, base);
	// 8323F6E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323F6EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8323F6F0: 38600150  li r3, 0x150
	ctx.r[3].s64 = 336;
	// 8323F6F4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8323F6F8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8323F6FC: 4AFDFB5D  bl 0x8221f258
	ctx.lr = 0x8323F700;
	sub_8221F258(ctx, base);
	// 8323F700: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8323F704: 419A0014  beq cr6, 0x8323f718
	if ctx.cr[6].eq {
	pc = 0x8323F718; continue 'dispatch;
	}
	// 8323F708: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8323F70C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8323F710: 4BFFFF09  bl 0x8323f618
	ctx.lr = 0x8323F714;
	sub_8323F618(ctx, base);
	// 8323F714: 48000008  b 0x8323f71c
	pc = 0x8323F71C; continue 'dispatch;
            }
            0x8323F718 => {
    //   block [0x8323F718..0x8323F71C)
	// 8323F718: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x8323F71C; continue 'dispatch;
            }
            0x8323F71C => {
    //   block [0x8323F71C..0x8323F75C)
	// 8323F71C: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 8323F720: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8323F724: 419A0038  beq cr6, 0x8323f75c
	if ctx.cr[6].eq {
	pc = 0x8323F75C; continue 'dispatch;
	}
	// 8323F728: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8323F72C: 4AFDFB2D  bl 0x8221f258
	ctx.lr = 0x8323F730;
	sub_8221F258(ctx, base);
	// 8323F730: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8323F734: 419A0028  beq cr6, 0x8323f75c
	if ctx.cr[6].eq {
	pc = 0x8323F75C; continue 'dispatch;
	}
	// 8323F738: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323F73C: 3D208253  lis r9, -0x7dad
	ctx.r[9].s64 = -2108489728;
	// 8323F740: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 8323F744: 38E99238  addi r7, r9, -0x6dc8
	ctx.r[7].s64 = ctx.r[9].s64 + -28104;
	// 8323F748: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 8323F74C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8323F750: 90E30004  stw r7, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 8323F754: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8323F758: 48000008  b 0x8323f760
	pc = 0x8323F760; continue 'dispatch;
            }
            0x8323F75C => {
    //   block [0x8323F75C..0x8323F760)
	// 8323F75C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8323F760; continue 'dispatch;
            }
            0x8323F760 => {
    //   block [0x8323F760..0x8323F77C)
	// 8323F760: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323F764: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8323F768: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8323F76C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323F770: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8323F774: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8323F778: 419A0020  beq cr6, 0x8323f798
	if ctx.cr[6].eq {
	pc = 0x8323F798; continue 'dispatch;
	}
	pc = 0x8323F77C; continue 'dispatch;
            }
            0x8323F77C => {
    //   block [0x8323F77C..0x8323F798)
	// 8323F77C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8323F780: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323F784: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8323F788: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8323F78C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8323F790: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323F794: 4082FFE8  bne 0x8323f77c
	if !ctx.cr[0].eq {
	pc = 0x8323F77C; continue 'dispatch;
	}
	pc = 0x8323F798; continue 'dispatch;
            }
            0x8323F798 => {
    //   block [0x8323F798..0x8323F7BC)
	// 8323F798: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8323F79C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8323F7A0: 386BE48C  addi r3, r11, -0x1b74
	ctx.r[3].s64 = ctx.r[11].s64 + -7028;
	// 8323F7A4: 4B211615  bl 0x82450db8
	ctx.lr = 0x8323F7A8;
	sub_82450DB8(ctx, base);
	// 8323F7A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8323F7AC: 4AF7836D  bl 0x821b7b18
	ctx.lr = 0x8323F7B0;
	sub_821B7B18(ctx, base);
	// 8323F7B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323F7B4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8323F7B8: 4BA69CA4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323F7C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323F7C0 size=68
    let mut pc: u32 = 0x8323F7C0;
    'dispatch: loop {
        match pc {
            0x8323F7C0 => {
    //   block [0x8323F7C0..0x8323F804)
	// 8323F7C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323F7C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8323F7C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8323F7CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323F7D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8323F7D4: 4BFEB8BD  bl 0x8322b090
	ctx.lr = 0x8323F7D8;
	sub_8322B090(ctx, base);
	// 8323F7D8: 809F00D0  lwz r4, 0xd0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 8323F7DC: 807F0120  lwz r3, 0x120(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 8323F7E0: 4BFE6701  bl 0x83225ee0
	ctx.lr = 0x8323F7E4;
	sub_83225EE0(ctx, base);
	// 8323F7E4: 809F00D0  lwz r4, 0xd0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 8323F7E8: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 8323F7EC: 4BFDD5F5  bl 0x8321cde0
	ctx.lr = 0x8323F7F0;
	sub_8321CDE0(ctx, base);
	// 8323F7F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8323F7F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8323F7F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8323F7FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8323F800: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323F808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323F808 size=168
    let mut pc: u32 = 0x8323F808;
    'dispatch: loop {
        match pc {
            0x8323F808 => {
    //   block [0x8323F808..0x8323F848)
	// 8323F808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323F80C: 4BA69BF5  bl 0x82ca9400
	ctx.lr = 0x8323F810;
	sub_82CA93D0(ctx, base);
	// 8323F810: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323F814: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8323F818: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8323F81C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8323F820: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8323F824: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 8323F828: 816BE720  lwz r11, -0x18e0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6368 as u32) ) } as u64;
	// 8323F82C: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 8323F830: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 8323F834: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323F838: 409A0010  bne cr6, 0x8323f848
	if !ctx.cr[6].eq {
	pc = 0x8323F848; continue 'dispatch;
	}
	// 8323F83C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8323F840: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 8323F844: 48000008  b 0x8323f84c
	pc = 0x8323F84C; continue 'dispatch;
            }
            0x8323F848 => {
    //   block [0x8323F848..0x8323F84C)
	// 8323F848: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8323F84C; continue 'dispatch;
            }
            0x8323F84C => {
    //   block [0x8323F84C..0x8323F8A8)
	// 8323F84C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323F850: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323F854: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323F858: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323F85C: 4E800421  bctrl
	ctx.lr = 0x8323F860;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323F860: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8323F864: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8323F868: 419A0040  beq cr6, 0x8323f8a8
	if ctx.cr[6].eq {
	pc = 0x8323F8A8; continue 'dispatch;
	}
	// 8323F86C: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 8323F870: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 8323F874: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 8323F878: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8323F87C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8323F880: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323F884: 480013FD  bl 0x83240c80
	ctx.lr = 0x8323F888;
	sub_83240C80(ctx, base);
	// 8323F888: 809E00D0  lwz r4, 0xd0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(208 as u32) ) } as u64;
	// 8323F88C: 807E0140  lwz r3, 0x140(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(320 as u32) ) } as u64;
	// 8323F890: 4BFDD551  bl 0x8321cde0
	ctx.lr = 0x8323F894;
	sub_8321CDE0(ctx, base);
	// 8323F894: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323F898: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323F89C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323F8A0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323F8A4: 4E800421  bctrl
	ctx.lr = 0x8323F8A8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8323F8A8 => {
    //   block [0x8323F8A8..0x8323F8B0)
	// 8323F8A8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8323F8AC: 4BA69BA4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323F8B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8323F8B0 size=8
    let mut pc: u32 = 0x8323F8B0;
    'dispatch: loop {
        match pc {
            0x8323F8B0 => {
    //   block [0x8323F8B0..0x8323F8B8)
	// 8323F8B0: 38630130  addi r3, r3, 0x130
	ctx.r[3].s64 = ctx.r[3].s64 + 304;
	// 8323F8B4: 4BFDE984  b 0x8321e238
	sub_8321E238(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323F8B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323F8B8 size=120
    let mut pc: u32 = 0x8323F8B8;
    'dispatch: loop {
        match pc {
            0x8323F8B8 => {
    //   block [0x8323F8B8..0x8323F900)
	// 8323F8B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323F8BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8323F8C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8323F8C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323F8C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8323F8CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8323F8D0: 387F0130  addi r3, r31, 0x130
	ctx.r[3].s64 = ctx.r[31].s64 + 304;
	// 8323F8D4: 394B5968  addi r10, r11, 0x5968
	ctx.r[10].s64 = ctx.r[11].s64 + 22888;
	// 8323F8D8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8323F8DC: 4BFDE95D  bl 0x8321e238
	ctx.lr = 0x8323F8E0;
	sub_8321E238(ctx, base);
	// 8323F8E0: 807F013C  lwz r3, 0x13c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 8323F8E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8323F8E8: 419A0018  beq cr6, 0x8323f900
	if ctx.cr[6].eq {
	pc = 0x8323F900; continue 'dispatch;
	}
	// 8323F8EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323F8F0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8323F8F4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323F8F8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323F8FC: 4E800421  bctrl
	ctx.lr = 0x8323F900;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8323F900 => {
    //   block [0x8323F900..0x8323F930)
	// 8323F900: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 8323F904: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8323F908: 392B25A8  addi r9, r11, 0x25a8
	ctx.r[9].s64 = ctx.r[11].s64 + 9640;
	// 8323F90C: 915F013C  stw r10, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[10].u32 ) };
	// 8323F910: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323F914: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8323F918: 4BFE9A01  bl 0x83229318
	ctx.lr = 0x8323F91C;
	sub_83229318(ctx, base);
	// 8323F91C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8323F920: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8323F924: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8323F928: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8323F92C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323F930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323F930 size=160
    let mut pc: u32 = 0x8323F930;
    'dispatch: loop {
        match pc {
            0x8323F930 => {
    //   block [0x8323F930..0x8323F9D0)
	// 8323F930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323F934: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8323F938: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8323F93C: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323F940: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8323F944: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 8323F948: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 8323F94C: 4BFE9CA5  bl 0x832295f0
	ctx.lr = 0x8323F950;
	sub_832295F0(ctx, base);
	// 8323F950: 396100D0  addi r11, r1, 0xd0
	ctx.r[11].s64 = ctx.r[1].s64 + 208;
	// 8323F954: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 8323F958: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8323F95C: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 8323F960: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 8323F964: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323F9D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323F9D0 size=128
    let mut pc: u32 = 0x8323F9D0;
    'dispatch: loop {
        match pc {
            0x8323F9D0 => {
    //   block [0x8323F9D0..0x8323FA38)
	// 8323F9D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323F9D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8323F9D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8323F9DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8323F9E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323F9E4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8323F9E8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8323F9EC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323F9F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323F9F4: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8323F9F8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323F9FC: 4E800421  bctrl
	ctx.lr = 0x8323FA00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323FA00: 2F030007  cmpwi cr6, r3, 7
	ctx.cr[6].compare_i32(ctx.r[3].s32, 7, &mut ctx.xer);
	// 8323FA04: 409A0034  bne cr6, 0x8323fa38
	if !ctx.cr[6].eq {
	pc = 0x8323FA38; continue 'dispatch;
	}
	// 8323FA08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8323FA0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323FA10: 48000E51  bl 0x83240860
	ctx.lr = 0x8323FA14;
	sub_83240860(ctx, base);
	// 8323FA14: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323FA18: 83DE0140  lwz r30, 0x140(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(320 as u32) ) } as u64;
	// 8323FA1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8323FA20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323FA24: 4BFE64BD  bl 0x83225ee0
	ctx.lr = 0x8323FA28;
	sub_83225EE0(ctx, base);
	// 8323FA28: 897F00C0  lbz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 8323FA2C: 997E00C0  stb r11, 0xc0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(192 as u32), ctx.r[11].u8 ) };
	// 8323FA30: 815F00C4  lwz r10, 0xc4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 8323FA34: 915E00C4  stw r10, 0xc4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(196 as u32), ctx.r[10].u32 ) };
            }
            0x8323FA38 => {
    //   block [0x8323FA38..0x8323FA50)
	// 8323FA38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8323FA3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8323FA40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8323FA44: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8323FA48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8323FA4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323FA50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8323FA50 size=480
    let mut pc: u32 = 0x8323FA50;
    'dispatch: loop {
        match pc {
            0x8323FA50 => {
    //   block [0x8323FA50..0x8323FC30)
	// 8323FA50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323FA54: 4BA699B5  bl 0x82ca9408
	ctx.lr = 0x8323FA58;
	sub_82CA93D0(ctx, base);
	// 8323FA58: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 8323FA5C: 4BA6E27D  bl 0x82cadcd8
	ctx.lr = 0x8323FA60;
	sub_82CADCA0(ctx, base);
	// 8323FA60: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323FC30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323FC30 size=276
    let mut pc: u32 = 0x8323FC30;
    'dispatch: loop {
        match pc {
            0x8323FC30 => {
    //   block [0x8323FC30..0x8323FC8C)
	// 8323FC30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323FC34: 4BA697D5  bl 0x82ca9408
	ctx.lr = 0x8323FC38;
	sub_82CA93D0(ctx, base);
	// 8323FC38: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 8323FC3C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323FC40: 83E500D4  lwz r31, 0xd4(r5)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(212 as u32) ) } as u64;
	// 8323FC44: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8323FC48: 83A500D0  lwz r29, 0xd0(r5)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(208 as u32) ) } as u64;
	// 8323FC4C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8323FC50: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8323FC54: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 8323FC58: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8323FC5C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8323FC60: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8323FC64: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8323FC68: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8323FC6C: 419A0020  beq cr6, 0x8323fc8c
	if ctx.cr[6].eq {
	pc = 0x8323FC8C; continue 'dispatch;
	}
	// 8323FC70: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8323FC74: 4AF77EA5  bl 0x821b7b18
	ctx.lr = 0x8323FC78;
	sub_821B7B18(ctx, base);
	// 8323FC78: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323FC7C: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 8323FC80: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8323FC84: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8323FC88: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x8323FC8C; continue 'dispatch;
            }
            0x8323FC8C => {
    //   block [0x8323FC8C..0x8323FCB8)
	// 8323FC8C: 83FE00D4  lwz r31, 0xd4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(212 as u32) ) } as u64;
	// 8323FC90: 83DE00D0  lwz r30, 0xd0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(208 as u32) ) } as u64;
	// 8323FC94: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8323FC98: 419A0020  beq cr6, 0x8323fcb8
	if ctx.cr[6].eq {
	pc = 0x8323FCB8; continue 'dispatch;
	}
	// 8323FC9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8323FCA0: 4AF77E79  bl 0x821b7b18
	ctx.lr = 0x8323FCA4;
	sub_821B7B18(ctx, base);
	// 8323FCA4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323FCA8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8323FCAC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8323FCB0: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8323FCB4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x8323FCB8; continue 'dispatch;
            }
            0x8323FCB8 => {
    //   block [0x8323FCB8..0x8323FCE4)
	// 8323FCB8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 8323FCBC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8323FCC0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8323FCC4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8323FCC8: 4BFDDF61  bl 0x8321dc28
	ctx.lr = 0x8323FCCC;
	sub_8321DC28(ctx, base);
	// 8323FCCC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323FCD0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8323FCD4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323FCD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323FCDC: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8323FCE0: 419A0020  beq cr6, 0x8323fd00
	if ctx.cr[6].eq {
	pc = 0x8323FD00; continue 'dispatch;
	}
	pc = 0x8323FCE4; continue 'dispatch;
            }
            0x8323FCE4 => {
    //   block [0x8323FCE4..0x8323FD00)
	// 8323FCE4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8323FCE8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323FCEC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8323FCF0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8323FCF4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8323FCF8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323FCFC: 4082FFE8  bne 0x8323fce4
	if !ctx.cr[0].eq {
	pc = 0x8323FCE4; continue 'dispatch;
	}
	pc = 0x8323FD00; continue 'dispatch;
            }
            0x8323FD00 => {
    //   block [0x8323FD00..0x8323FD44)
	// 8323FD00: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323FD04: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8323FD08: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8323FD0C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 8323FD10: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323FD14: 4E800421  bctrl
	ctx.lr = 0x8323FD18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323FD18: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8323FD1C: 4AF77DFD  bl 0x821b7b18
	ctx.lr = 0x8323FD20;
	sub_821B7B18(ctx, base);
	// 8323FD20: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8323FD24: 4AF77DF5  bl 0x821b7b18
	ctx.lr = 0x8323FD28;
	sub_821B7B18(ctx, base);
	// 8323FD28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8323FD2C: 4AF77DED  bl 0x821b7b18
	ctx.lr = 0x8323FD30;
	sub_821B7B18(ctx, base);
	// 8323FD30: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8323FD34: 4AF77DE5  bl 0x821b7b18
	ctx.lr = 0x8323FD38;
	sub_821B7B18(ctx, base);
	// 8323FD38: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8323FD3C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 8323FD40: 4BA69718  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323FD48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8323FD48 size=4
    let mut pc: u32 = 0x8323FD48;
    'dispatch: loop {
        match pc {
            0x8323FD48 => {
    //   block [0x8323FD48..0x8323FD4C)
	// 8323FD48: 4BFE9F38  b 0x83229c80
	sub_83229C80(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323FD50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323FD50 size=140
    let mut pc: u32 = 0x8323FD50;
    'dispatch: loop {
        match pc {
            0x8323FD50 => {
    //   block [0x8323FD50..0x8323FD88)
	// 8323FD50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323FD54: 4BA696B5  bl 0x82ca9408
	ctx.lr = 0x8323FD58;
	sub_82CA93D0(ctx, base);
	// 8323FD58: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323FD5C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8323FD60: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8323FD64: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8323FD68: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8323FD6C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 8323FD70: 816BE710  lwz r11, -0x18f0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6384 as u32) ) } as u64;
	// 8323FD74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323FD78: 409A0010  bne cr6, 0x8323fd88
	if !ctx.cr[6].eq {
	pc = 0x8323FD88; continue 'dispatch;
	}
	// 8323FD7C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8323FD80: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 8323FD84: 48000008  b 0x8323fd8c
	pc = 0x8323FD8C; continue 'dispatch;
            }
            0x8323FD88 => {
    //   block [0x8323FD88..0x8323FD8C)
	// 8323FD88: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8323FD8C; continue 'dispatch;
            }
            0x8323FD8C => {
    //   block [0x8323FD8C..0x8323FDD4)
	// 8323FD8C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323FD90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323FD94: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323FD98: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323FD9C: 4E800421  bctrl
	ctx.lr = 0x8323FDA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323FDA0: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8323FDA4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8323FDA8: 419A002C  beq cr6, 0x8323fdd4
	if ctx.cr[6].eq {
	pc = 0x8323FDD4; continue 'dispatch;
	}
	// 8323FDAC: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 8323FDB0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8323FDB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8323FDB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323FDBC: 48000D5D  bl 0x83240b18
	ctx.lr = 0x8323FDC0;
	sub_83240B18(ctx, base);
	// 8323FDC0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323FDC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323FDC8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8323FDCC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8323FDD0: 4E800421  bctrl
	ctx.lr = 0x8323FDD4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8323FDD4 => {
    //   block [0x8323FDD4..0x8323FDDC)
	// 8323FDD4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8323FDD8: 4BA69680  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323FDE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323FDE0 size=200
    let mut pc: u32 = 0x8323FDE0;
    'dispatch: loop {
        match pc {
            0x8323FDE0 => {
    //   block [0x8323FDE0..0x8323FE10)
	// 8323FDE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323FDE4: 4BA69625  bl 0x82ca9408
	ctx.lr = 0x8323FDE8;
	sub_82CA93D0(ctx, base);
	// 8323FDE8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323FDEC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8323FDF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8323FDF4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 8323FDF8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323FDFC: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323FE00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323FE04: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8323FE08: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8323FE0C: 419A0020  beq cr6, 0x8323fe2c
	if ctx.cr[6].eq {
	pc = 0x8323FE2C; continue 'dispatch;
	}
	pc = 0x8323FE10; continue 'dispatch;
            }
            0x8323FE10 => {
    //   block [0x8323FE10..0x8323FE2C)
	// 8323FE10: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8323FE14: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323FE18: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8323FE1C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8323FE20: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8323FE24: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323FE28: 4082FFE8  bne 0x8323fe10
	if !ctx.cr[0].eq {
	pc = 0x8323FE10; continue 'dispatch;
	}
	pc = 0x8323FE2C; continue 'dispatch;
            }
            0x8323FE2C => {
    //   block [0x8323FE2C..0x8323FEA8)
	// 8323FE2C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8323FE30: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8323FE34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323FE38: 48000D71  bl 0x83240ba8
	ctx.lr = 0x8323FE3C;
	sub_83240BA8(ctx, base);
	// 8323FE3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8323FE40: 4AF77CD9  bl 0x821b7b18
	ctx.lr = 0x8323FE44;
	sub_821B7B18(ctx, base);
	// 8323FE44: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8323FE48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8323FE4C: 392A5968  addi r9, r10, 0x5968
	ctx.r[9].s64 = ctx.r[10].s64 + 22888;
	// 8323FE50: 3D00834C  lis r8, -0x7cb4
	ctx.r[8].s64 = -2092171264;
	// 8323FE54: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8323FE58: 3BDF0130  addi r30, r31, 0x130
	ctx.r[30].s64 = ctx.r[31].s64 + 304;
	// 8323FE5C: 917F0130  stw r11, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 8323FE60: 917F0134  stw r11, 0x134(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[11].u32 ) };
	// 8323FE64: 997F0138  stb r11, 0x138(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), ctx.r[11].u8 ) };
	// 8323FE68: 80FD0000  lwz r7, 0(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323FE6C: 90FF0140  stw r7, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[7].u32 ) };
	// 8323FE70: 8068E8C8  lwz r3, -0x1738(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-5944 as u32) ) } as u64;
	// 8323FE74: 80C30000  lwz r6, 0(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323FE78: 80A60004  lwz r5, 4(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 8323FE7C: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 8323FE80: 4E800421  bctrl
	ctx.lr = 0x8323FE84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8323FE84: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8323FE88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8323FE8C: 93BF013C  stw r29, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[29].u32 ) };
	// 8323FE90: 4BFDE3A9  bl 0x8321e238
	ctx.lr = 0x8323FE94;
	sub_8321E238(ctx, base);
	// 8323FE94: 93BF0130  stw r29, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[29].u32 ) };
	// 8323FE98: 939F0134  stw r28, 0x134(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[28].u32 ) };
	// 8323FE9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323FEA0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8323FEA4: 4BA695B4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323FEA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323FEA8 size=220
    let mut pc: u32 = 0x8323FEA8;
    'dispatch: loop {
        match pc {
            0x8323FEA8 => {
    //   block [0x8323FEA8..0x8323FEE0)
	// 8323FEA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323FEAC: 4BA69561  bl 0x82ca940c
	ctx.lr = 0x8323FEB0;
	sub_82CA93D0(ctx, base);
	// 8323FEB0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323FEB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8323FEB8: 38600150  li r3, 0x150
	ctx.r[3].s64 = 336;
	// 8323FEBC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8323FEC0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8323FEC4: 4AFDF395  bl 0x8221f258
	ctx.lr = 0x8323FEC8;
	sub_8221F258(ctx, base);
	// 8323FEC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8323FECC: 419A0014  beq cr6, 0x8323fee0
	if ctx.cr[6].eq {
	pc = 0x8323FEE0; continue 'dispatch;
	}
	// 8323FED0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8323FED4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8323FED8: 4BFFFF09  bl 0x8323fde0
	ctx.lr = 0x8323FEDC;
	sub_8323FDE0(ctx, base);
	// 8323FEDC: 48000008  b 0x8323fee4
	pc = 0x8323FEE4; continue 'dispatch;
            }
            0x8323FEE0 => {
    //   block [0x8323FEE0..0x8323FEE4)
	// 8323FEE0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x8323FEE4; continue 'dispatch;
            }
            0x8323FEE4 => {
    //   block [0x8323FEE4..0x8323FF24)
	// 8323FEE4: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 8323FEE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8323FEEC: 419A0038  beq cr6, 0x8323ff24
	if ctx.cr[6].eq {
	pc = 0x8323FF24; continue 'dispatch;
	}
	// 8323FEF0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8323FEF4: 4AFDF365  bl 0x8221f258
	ctx.lr = 0x8323FEF8;
	sub_8221F258(ctx, base);
	// 8323FEF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8323FEFC: 419A0028  beq cr6, 0x8323ff24
	if ctx.cr[6].eq {
	pc = 0x8323FF24; continue 'dispatch;
	}
	// 8323FF00: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323FF04: 3D208253  lis r9, -0x7dad
	ctx.r[9].s64 = -2108489728;
	// 8323FF08: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 8323FF0C: 38E99238  addi r7, r9, -0x6dc8
	ctx.r[7].s64 = ctx.r[9].s64 + -28104;
	// 8323FF10: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 8323FF14: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8323FF18: 90E30004  stw r7, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 8323FF1C: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8323FF20: 48000008  b 0x8323ff28
	pc = 0x8323FF28; continue 'dispatch;
            }
            0x8323FF24 => {
    //   block [0x8323FF24..0x8323FF28)
	// 8323FF24: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8323FF28; continue 'dispatch;
            }
            0x8323FF28 => {
    //   block [0x8323FF28..0x8323FF44)
	// 8323FF28: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8323FF2C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8323FF30: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8323FF34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8323FF38: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8323FF3C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8323FF40: 419A0020  beq cr6, 0x8323ff60
	if ctx.cr[6].eq {
	pc = 0x8323FF60; continue 'dispatch;
	}
	pc = 0x8323FF44; continue 'dispatch;
            }
            0x8323FF44 => {
    //   block [0x8323FF44..0x8323FF60)
	// 8323FF44: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8323FF48: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323FF4C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8323FF50: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8323FF54: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8323FF58: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8323FF5C: 4082FFE8  bne 0x8323ff44
	if !ctx.cr[0].eq {
	pc = 0x8323FF44; continue 'dispatch;
	}
	pc = 0x8323FF60; continue 'dispatch;
            }
            0x8323FF60 => {
    //   block [0x8323FF60..0x8323FF84)
	// 8323FF60: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8323FF64: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8323FF68: 386BE48C  addi r3, r11, -0x1b74
	ctx.r[3].s64 = ctx.r[11].s64 + -7028;
	// 8323FF6C: 4B210E4D  bl 0x82450db8
	ctx.lr = 0x8323FF70;
	sub_82450DB8(ctx, base);
	// 8323FF70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8323FF74: 4AF77BA5  bl 0x821b7b18
	ctx.lr = 0x8323FF78;
	sub_821B7B18(ctx, base);
	// 8323FF78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323FF7C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8323FF80: 4BA694DC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323FF88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323FF88 size=100
    let mut pc: u32 = 0x8323FF88;
    'dispatch: loop {
        match pc {
            0x8323FF88 => {
    //   block [0x8323FF88..0x8323FFEC)
	// 8323FF88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323FF8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8323FF90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8323FF94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8323FF98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323FF9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8323FFA0: 4BFEB0F1  bl 0x8322b090
	ctx.lr = 0x8323FFA4;
	sub_8322B090(ctx, base);
	// 8323FFA4: 809F00D0  lwz r4, 0xd0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 8323FFA8: 807F0120  lwz r3, 0x120(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 8323FFAC: 4BFE5F35  bl 0x83225ee0
	ctx.lr = 0x8323FFB0;
	sub_83225EE0(ctx, base);
	// 8323FFB0: 83DF00D0  lwz r30, 0xd0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 8323FFB4: 83FF0140  lwz r31, 0x140(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 8323FFB8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8323FFBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8323FFC0: 4BFE5F21  bl 0x83225ee0
	ctx.lr = 0x8323FFC4;
	sub_83225EE0(ctx, base);
	// 8323FFC4: 897E00C0  lbz r11, 0xc0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(192 as u32) ) } as u64;
	// 8323FFC8: 997F00C0  stb r11, 0xc0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[11].u8 ) };
	// 8323FFCC: 815E00C4  lwz r10, 0xc4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(196 as u32) ) } as u64;
	// 8323FFD0: 915F00C4  stw r10, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[10].u32 ) };
	// 8323FFD4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8323FFD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8323FFDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8323FFE0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8323FFE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8323FFE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8323FFF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8323FFF0 size=192
    let mut pc: u32 = 0x8323FFF0;
    'dispatch: loop {
        match pc {
            0x8323FFF0 => {
    //   block [0x8323FFF0..0x83240030)
	// 8323FFF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8323FFF4: 4BA6940D  bl 0x82ca9400
	ctx.lr = 0x8323FFF8;
	sub_82CA93D0(ctx, base);
	// 8323FFF8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8323FFFC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 83240000: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 83240004: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 83240008: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8324000C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 83240010: 816BE710  lwz r11, -0x18f0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6384 as u32) ) } as u64;
	// 83240014: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 83240018: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 8324001C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 83240020: 409A0010  bne cr6, 0x83240030
	if !ctx.cr[6].eq {
	pc = 0x83240030; continue 'dispatch;
	}
	// 83240024: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 83240028: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 8324002C: 48000008  b 0x83240034
	pc = 0x83240034; continue 'dispatch;
            }
            0x83240030 => {
    //   block [0x83240030..0x83240034)
	// 83240030: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x83240034; continue 'dispatch;
            }
            0x83240034 => {
    //   block [0x83240034..0x832400A8)
	// 83240034: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 83240038: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8324003C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 83240040: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 83240044: 4E800421  bctrl
	ctx.lr = 0x83240048;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 83240048: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8324004C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 83240050: 419A0058  beq cr6, 0x832400a8
	if ctx.cr[6].eq {
	pc = 0x832400A8; continue 'dispatch;
	}
	// 83240054: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 83240058: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 8324005C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 83240060: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 83240064: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 83240068: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8324006C: 48000C15  bl 0x83240c80
	ctx.lr = 0x83240070;
	sub_83240C80(ctx, base);
	// 83240070: 83BE00D0  lwz r29, 0xd0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(208 as u32) ) } as u64;
	// 83240074: 83DE0140  lwz r30, 0x140(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(320 as u32) ) } as u64;
	// 83240078: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8324007C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 83240080: 4BFE5E61  bl 0x83225ee0
	ctx.lr = 0x83240084;
	sub_83225EE0(ctx, base);
	// 83240084: 897D00C0  lbz r11, 0xc0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(192 as u32) ) } as u64;
	// 83240088: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8324008C: 997E00C0  stb r11, 0xc0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(192 as u32), ctx.r[11].u8 ) };
	// 83240090: 815D00C4  lwz r10, 0xc4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(196 as u32) ) } as u64;
	// 83240094: 915E00C4  stw r10, 0xc4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(196 as u32), ctx.r[10].u32 ) };
	// 83240098: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8324009C: 8109000C  lwz r8, 0xc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 832400A0: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 832400A4: 4E800421  bctrl
	ctx.lr = 0x832400A8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x832400A8 => {
    //   block [0x832400A8..0x832400B0)
	// 832400A8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 832400AC: 4BA693A4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832400B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x832400B0 size=132
    let mut pc: u32 = 0x832400B0;
    'dispatch: loop {
        match pc {
            0x832400B0 => {
    //   block [0x832400B0..0x832400F8)
	// 832400B0: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 832400B4: 81030130  lwz r8, 0x130(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(304 as u32) ) } as u64;
	// 832400B8: 3CE08336  lis r7, -0x7cca
	ctx.r[7].s64 = -2093613056;
	// 832400BC: C1A30134  lfs f13, 0x134(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 832400C0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 832400C4: 3927F1BC  addi r9, r7, -0xe44
	ctx.r[9].s64 = ctx.r[7].s64 + -3652;
	// 832400C8: 814A6DD4  lwz r10, 0x6dd4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28116 as u32) ) } as u64;
	// 832400CC: 38C90018  addi r6, r9, 0x18
	ctx.r[6].s64 = ctx.r[9].s64 + 24;
	// 832400D0: C18800C4  lfs f12, 0xc4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(196 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 832400D4: 5545103A  slwi r5, r10, 2
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 832400D8: C00B9044  lfs f0, -0x6fbc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28604 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 832400DC: 7D65342E  lfsx f11, r5, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 832400E0: EDAB6B3A  fmadds f13, f11, f12, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 832400E4: D1A30134  stfs f13, 0x134(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 832400E8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 832400EC: 4198000C  blt cr6, 0x832400f8
	if ctx.cr[6].lt {
	pc = 0x832400F8; continue 'dispatch;
	}
	// 832400F0: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 832400F4: D1A30134  stfs f13, 0x134(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(308 as u32), tmp.u32 ) };
	pc = 0x832400F8; continue 'dispatch;
            }
            0x832400F8 => {
    //   block [0x832400F8..0x83240114)
	// 832400F8: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 832400FC: C1A30134  lfs f13, 0x134(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 83240100: C18B0EE0  lfs f12, 0xee0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3808 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 83240104: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 83240108: 4199000C  bgt cr6, 0x83240114
	if ctx.cr[6].gt {
	pc = 0x83240114; continue 'dispatch;
	}
	// 8324010C: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 83240110: D0030134  stfs f0, 0x134(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(308 as u32), tmp.u32 ) };
	pc = 0x83240114; continue 'dispatch;
            }
            0x83240114 => {
    //   block [0x83240114..0x83240134)
	// 83240114: 814300D0  lwz r10, 0xd0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(208 as u32) ) } as u64;
	// 83240118: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8324011C: 39200040  li r9, 0x40
	ctx.r[9].s64 = 64;
	// 83240120: C0230134  lfs f1, 0x134(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(308 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 83240124: 38630020  addi r3, r3, 0x20
	ctx.r[3].s64 = ctx.r[3].s64 + 32;
	// 83240128: C04B9054  lfs f2, -0x6fac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28588 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_83240138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x83240138 size=172
    let mut pc: u32 = 0x83240138;
    'dispatch: loop {
        match pc {
            0x83240138 => {
    //   block [0x83240138..0x832401E4)
	// 83240138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8324013C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83240140: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 83240144: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 83240148: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8324014C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 83240150: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 83240154: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 83240158: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8324015C: 817F00D0  lwz r11, 0xd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 83240160: 388B0020  addi r4, r11, 0x20
	ctx.r[4].s64 = ctx.r[11].s64 + 32;
	// 83240164: 4AFDAA2D  bl 0x8221ab90
	ctx.lr = 0x83240168;
	sub_8221AB90(ctx, base);
	// 83240168: C01F00FC  lfs f0, 0xfc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8324016C: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 83240170: 38800019  li r4, 0x19
	ctx.r[4].s64 = 25;
	// 83240174: D9A10050  stfd f13, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[13].u64 ) };
	// 83240178: 80A10054  lwz r5, 0x54(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8324017C: 807F0130  lwz r3, 0x130(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 83240180: 4BFE4D99  bl 0x83224f18
	ctx.lr = 0x83240184;
	sub_83224F18(ctx, base);
	// 83240184: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 83240188: D0210050  stfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8324018C: 39400110  li r10, 0x110
	ctx.r[10].s64 = 272;
	// 83240190: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 83240194: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 83240198: 38E000CC  li r7, 0xcc
	ctx.r[7].s64 = 204;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832401F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x832401F8 size=268
    let mut pc: u32 = 0x832401F8;
    'dispatch: loop {
        match pc {
            0x832401F8 => {
    //   block [0x832401F8..0x83240304)
	// 832401F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832401FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 83240200: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 83240204: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 83240208: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8324020C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 83240210: 38800019  li r4, 0x19
	ctx.r[4].s64 = 25;
	// 83240214: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 83240218: C01E00FC  lfs f0, 0xfc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8324021C: 807E0130  lwz r3, 0x130(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(304 as u32) ) } as u64;
	// 83240220: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 83240224: D9A10060  stfd f13, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[13].u64 ) };
	// 83240228: 80A10064  lwz r5, 0x64(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8324022C: 4BFE4CED  bl 0x83224f18
	ctx.lr = 0x83240230;
	sub_83224F18(ctx, base);
	// 83240230: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 83240234: D0210050  stfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 83240238: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8324023C: 4BFE93B5  bl 0x832295f0
	ctx.lr = 0x83240240;
	sub_832295F0(ctx, base);
	// 83240240: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 83240244: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 83240248: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8324024C: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 83240250: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 83240254: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 83240258: C0099484  lfs f0, -0x6b7c(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


