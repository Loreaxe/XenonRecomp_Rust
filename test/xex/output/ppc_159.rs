pub fn sub_82E856B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E856B8 size=196
    let mut pc: u32 = 0x82E856B8;
    'dispatch: loop {
        match pc {
            0x82E856B8 => {
    //   block [0x82E856B8..0x82E856F0)
	// 82E856B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E856BC: 4BE23D49  bl 0x82ca9404
	ctx.lr = 0x82E856C0;
	sub_82CA93D0(ctx, base);
	// 82E856C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E856C4: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82E856C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E856CC: 392B2390  addi r9, r11, 0x2390
	ctx.r[9].s64 = ctx.r[11].s64 + 9104;
	// 82E856D0: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82E856D4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82E856D8: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82E856DC: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82E856E0: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82E856E4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E856E8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82E856EC: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	pc = 0x82E856F0; continue 'dispatch;
            }
            0x82E856F0 => {
    //   block [0x82E856F0..0x82E8571C)
	// 82E856F0: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E856F4: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E856F8: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82E856FC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E85700: 4082FFF0  bne 0x82e856f0
	if !ctx.cr[0].eq {
	pc = 0x82E856F0; continue 'dispatch;
	}
	// 82E85704: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E85708: 4BFFFE21  bl 0x82e85528
	ctx.lr = 0x82E8570C;
	sub_82E85528(ctx, base);
	// 82E8570C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E85710: 4082000C  bne 0x82e8571c
	if !ctx.cr[0].eq {
	pc = 0x82E8571C; continue 'dispatch;
	}
	// 82E85714: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82E85718: 48000010  b 0x82e85728
	pc = 0x82E85728; continue 'dispatch;
            }
            0x82E8571C => {
    //   block [0x82E8571C..0x82E85728)
	// 82E8571C: 4BFFE19D  bl 0x82e838b8
	ctx.lr = 0x82E85720;
	sub_82E838B8(ctx, base);
	// 82E85720: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E85724: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82E85728; continue 'dispatch;
            }
            0x82E85728 => {
    //   block [0x82E85728..0x82E8574C)
	// 82E85728: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E8572C: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82E85730: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82E85734: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E85738: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82E8573C: 409A0010  bne cr6, 0x82e8574c
	if !ctx.cr[6].eq {
	pc = 0x82E8574C; continue 'dispatch;
	}
	// 82E85740: 4BFFA319  bl 0x82e7fa58
	ctx.lr = 0x82E85744;
	sub_82E7FA58(ctx, base);
	// 82E85744: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82E85748: 4800000C  b 0x82e85754
	pc = 0x82E85754; continue 'dispatch;
            }
            0x82E8574C => {
    //   block [0x82E8574C..0x82E85754)
	// 82E8574C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E85750: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	pc = 0x82E85754; continue 'dispatch;
            }
            0x82E85754 => {
    //   block [0x82E85754..0x82E85770)
	// 82E85754: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E85758: 41820018  beq 0x82e85770
	if ctx.cr[0].eq {
	pc = 0x82E85770; continue 'dispatch;
	}
	// 82E8575C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E85760: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82E85764: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82E85768: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82E8576C: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	pc = 0x82E85770; continue 'dispatch;
            }
            0x82E85770 => {
    //   block [0x82E85770..0x82E8577C)
	// 82E85770: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E85774: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E85778: 4BE23CDC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E85780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E85780 size=60
    let mut pc: u32 = 0x82E85780;
    'dispatch: loop {
        match pc {
            0x82E85780 => {
    //   block [0x82E85780..0x82E857BC)
	// 82E85780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E85784: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E85788: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8578C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E85790: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E85794: 4BFFFE5D  bl 0x82e855f0
	ctx.lr = 0x82E85798;
	sub_82E855F0(ctx, base);
	// 82E85798: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8579C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E857A0: 396B9830  addi r11, r11, -0x67d0
	ctx.r[11].s64 = ctx.r[11].s64 + -26576;
	// 82E857A4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E857A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E857AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E857B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E857B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E857B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E857C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E857C0 size=60
    let mut pc: u32 = 0x82E857C0;
    'dispatch: loop {
        match pc {
            0x82E857C0 => {
    //   block [0x82E857C0..0x82E857FC)
	// 82E857C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E857C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E857C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E857CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E857D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E857D4: 4BFFFEE5  bl 0x82e856b8
	ctx.lr = 0x82E857D8;
	sub_82E856B8(ctx, base);
	// 82E857D8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E857DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E857E0: 396B9830  addi r11, r11, -0x67d0
	ctx.r[11].s64 = ctx.r[11].s64 + -26576;
	// 82E857E4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E857E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E857EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E857F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E857F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E857F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E85800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E85800 size=120
    let mut pc: u32 = 0x82E85800;
    'dispatch: loop {
        match pc {
            0x82E85800 => {
    //   block [0x82E85800..0x82E85820)
	// 82E85800: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E85804: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82E85808: 814B0718  lwz r10, 0x718(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E8580C: C1890C14  lfs f12, 0xc14(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3092 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E85810: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E85814: 4182000C  beq 0x82e85820
	if ctx.cr[0].eq {
	pc = 0x82E85820; continue 'dispatch;
	}
	// 82E85818: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8581C: 48000008  b 0x82e85824
	pc = 0x82E85824; continue 'dispatch;
            }
            0x82E85820 => {
    //   block [0x82E85820..0x82E85824)
	// 82E85820: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	pc = 0x82E85824; continue 'dispatch;
            }
            0x82E85824 => {
    //   block [0x82E85824..0x82E8583C)
	// 82E85824: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82E85828: 814B0718  lwz r10, 0x718(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E8582C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E85830: 4182000C  beq 0x82e8583c
	if ctx.cr[0].eq {
	pc = 0x82E8583C; continue 'dispatch;
	}
	// 82E85834: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E85838: 48000008  b 0x82e85840
	pc = 0x82E85840; continue 'dispatch;
            }
            0x82E8583C => {
    //   block [0x82E8583C..0x82E85840)
	// 82E8583C: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	pc = 0x82E85840; continue 'dispatch;
            }
            0x82E85840 => {
    //   block [0x82E85840..0x82E85864)
	// 82E85840: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E85844: C1AA0BFC  lfs f13, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E85848: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82E8584C: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82E85850: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E85854: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E85858: 4182000C  beq 0x82e85864
	if ctx.cr[0].eq {
	pc = 0x82E85864; continue 'dispatch;
	}
	// 82E8585C: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E85860: 48000008  b 0x82e85868
	pc = 0x82E85868; continue 'dispatch;
            }
            0x82E85864 => {
    //   block [0x82E85864..0x82E85868)
	// 82E85864: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	pc = 0x82E85868; continue 'dispatch;
            }
            0x82E85868 => {
    //   block [0x82E85868..0x82E85878)
	// 82E85868: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8586C: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82E85870: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82E85874: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E85878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E85878 size=96
    let mut pc: u32 = 0x82E85878;
    'dispatch: loop {
        match pc {
            0x82E85878 => {
    //   block [0x82E85878..0x82E858B8)
	// 82E85878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8587C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E85880: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E85884: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E85888: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8588C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E85890: 396B93F8  addi r11, r11, -0x6c08
	ctx.r[11].s64 = ctx.r[11].s64 + -27656;
	// 82E85894: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E85898: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8589C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E858A0: 41820018  beq 0x82e858b8
	if ctx.cr[0].eq {
	pc = 0x82E858B8; continue 'dispatch;
	}
	// 82E858A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E858A8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E858AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E858B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E858B4: 4E800421  bctrl
	ctx.lr = 0x82E858B8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E858B8 => {
    //   block [0x82E858B8..0x82E858D8)
	// 82E858B8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E858BC: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82E858C0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E858C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E858C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E858CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E858D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E858D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E858D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E858D8 size=20
    let mut pc: u32 = 0x82E858D8;
    'dispatch: loop {
        match pc {
            0x82E858D8 => {
    //   block [0x82E858D8..0x82E858EC)
	// 82E858D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E858DC: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 82E858E0: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E858E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E858E8: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E858F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E858F0 size=16
    let mut pc: u32 = 0x82E858F0;
    'dispatch: loop {
        match pc {
            0x82E858F0 => {
    //   block [0x82E858F0..0x82E85900)
	// 82E858F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E858F4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E858F8: 908B000C  stw r4, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	// 82E858FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E85900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E85900 size=148
    let mut pc: u32 = 0x82E85900;
    'dispatch: loop {
        match pc {
            0x82E85900 => {
    //   block [0x82E85900..0x82E85994)
	// 82E85900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E85904: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E85908: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8590C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E85910: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E85914: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E85918: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8591C: 4BFFFB2D  bl 0x82e85448
	ctx.lr = 0x82E85920;
	sub_82E85448(ctx, base);
	// 82E85920: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E85924: 396B93F8  addi r11, r11, -0x6c08
	ctx.r[11].s64 = ctx.r[11].s64 + -27656;
	// 82E85928: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E8592C: 807E0018  lwz r3, 0x18(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E85930: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E85934: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E85938: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8593C: 4E800421  bctrl
	ctx.lr = 0x82E85940;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E85940: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E85944: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E85948: 4E800421  bctrl
	ctx.lr = 0x82E8594C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8594C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E85950: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E85954: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E85958: 4BFFFEA9  bl 0x82e85800
	ctx.lr = 0x82E8595C;
	sub_82E85800(ctx, base);
	// 82E8595C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E85960: 3BCB944C  addi r30, r11, -0x6bb4
	ctx.r[30].s64 = ctx.r[11].s64 + -27572;
	// 82E85964: 4B3DB055  bl 0x822609b8
	ctx.lr = 0x82E85968;
	sub_822609B8(ctx, base);
	// 82E85968: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8596C: 4BFFB8CD  bl 0x82e81238
	ctx.lr = 0x82E85970;
	sub_82E81238(ctx, base);
	// 82E85970: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E85974: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E85978: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82E8597C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E85980: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E85984: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E85988: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8598C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E85990: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E85998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E85998 size=88
    let mut pc: u32 = 0x82E85998;
    'dispatch: loop {
        match pc {
            0x82E85998 => {
    //   block [0x82E85998..0x82E859D4)
	// 82E85998: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8599C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E859A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E859A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E859A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E859AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E859B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E859B4: 4BFFFEC5  bl 0x82e85878
	ctx.lr = 0x82E859B8;
	sub_82E85878(ctx, base);
	// 82E859B8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E859BC: 41820018  beq 0x82e859d4
	if ctx.cr[0].eq {
	pc = 0x82E859D4; continue 'dispatch;
	}
	// 82E859C0: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E859C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E859C8: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E859CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E859D0: 4E800421  bctrl
	ctx.lr = 0x82E859D4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E859D4 => {
    //   block [0x82E859D4..0x82E859F0)
	// 82E859D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E859D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E859DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E859E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E859E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E859E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E859EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E859F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E859F0 size=116
    let mut pc: u32 = 0x82E859F0;
    'dispatch: loop {
        match pc {
            0x82E859F0 => {
    //   block [0x82E859F0..0x82E85A38)
	// 82E859F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E859F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E859F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E859FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E85A00: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82E85A04: 816A1044  lwz r11, 0x1044(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4164 as u32) ) } as u64;
	// 82E85A08: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82E85A0C: 3D208334  lis r9, -0x7ccc
	ctx.r[9].s64 = -2093744128;
	// 82E85A10: 3BE90C40  addi r31, r9, 0xc40
	ctx.r[31].s64 = ctx.r[9].s64 + 3136;
	// 82E85A14: 40820038  bne 0x82e85a4c
	if !ctx.cr[0].eq {
	pc = 0x82E85A4C; continue 'dispatch;
	}
	// 82E85A18: 3D20832D  lis r9, -0x7cd3
	ctx.r[9].s64 = -2094202880;
	// 82E85A1C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82E85A20: 89095F54  lbz r8, 0x5f54(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(24404 as u32) ) } as u64;
	// 82E85A24: 916A1044  stw r11, 0x1044(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4164 as u32), ctx.r[11].u32 ) };
	// 82E85A28: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E85A2C: 4182000C  beq 0x82e85a38
	if ctx.cr[0].eq {
	pc = 0x82E85A38; continue 'dispatch;
	}
	// 82E85A30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E85A34: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	pc = 0x82E85A38; continue 'dispatch;
            }
            0x82E85A38 => {
    //   block [0x82E85A38..0x82E85A4C)
	// 82E85A38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E85A3C: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82E85A40: 386A83B8  addi r3, r10, -0x7c48
	ctx.r[3].s64 = ctx.r[10].s64 + -31816;
	// 82E85A44: 99695F54  stb r11, 0x5f54(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(24404 as u32), ctx.r[11].u8 ) };
	// 82E85A48: 4BE244D9  bl 0x82ca9f20
	ctx.lr = 0x82E85A4C;
	sub_82CA9F20(ctx, base);
	pc = 0x82E85A4C; continue 'dispatch;
            }
            0x82E85A4C => {
    //   block [0x82E85A4C..0x82E85A64)
	// 82E85A4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E85A50: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E85A54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E85A58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E85A5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E85A60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E85A68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E85A68 size=200
    let mut pc: u32 = 0x82E85A68;
    'dispatch: loop {
        match pc {
            0x82E85A68 => {
    //   block [0x82E85A68..0x82E85A9C)
	// 82E85A68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E85A6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E85A70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E85A74: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E85A78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E85A7C: 4BFFFF75  bl 0x82e859f0
	ctx.lr = 0x82E85A80;
	sub_82E859F0(ctx, base);
	// 82E85A80: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E85A84: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82E85A88: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E85A8C: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E85A90: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E85A94: 40810054  ble 0x82e85ae8
	if !ctx.cr[0].gt {
	pc = 0x82E85AE8; continue 'dispatch;
	}
	// 82E85A98: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82E85A9C; continue 'dispatch;
            }
            0x82E85A9C => {
    //   block [0x82E85A9C..0x82E85AA8)
	// 82E85A9C: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E85AA0: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82E85AA4: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	pc = 0x82E85AA8; continue 'dispatch;
            }
            0x82E85AA8 => {
    //   block [0x82E85AA8..0x82E85ACC)
	// 82E85AA8: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E85AAC: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E85AB0: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E85AB4: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82E85AB8: 41820014  beq 0x82e85acc
	if ctx.cr[0].eq {
	pc = 0x82E85ACC; continue 'dispatch;
	}
	// 82E85ABC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E85AC0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82E85AC4: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82E85AC8: 419AFFE0  beq cr6, 0x82e85aa8
	if ctx.cr[6].eq {
	pc = 0x82E85AA8; continue 'dispatch;
	}
	pc = 0x82E85ACC; continue 'dispatch;
            }
            0x82E85ACC => {
    //   block [0x82E85ACC..0x82E85AE8)
	// 82E85ACC: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E85AD0: 41820028  beq 0x82e85af8
	if ctx.cr[0].eq {
	pc = 0x82E85AF8; continue 'dispatch;
	}
	// 82E85AD4: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E85AD8: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82E85ADC: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82E85AE0: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82E85AE4: 4198FFB8  blt cr6, 0x82e85a9c
	if ctx.cr[6].lt {
	pc = 0x82E85A9C; continue 'dispatch;
	}
	pc = 0x82E85AE8; continue 'dispatch;
            }
            0x82E85AE8 => {
    //   block [0x82E85AE8..0x82E85AF8)
	// 82E85AE8: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82E85AEC: 409A0018  bne cr6, 0x82e85b04
	if !ctx.cr[6].eq {
	pc = 0x82E85B04; continue 'dispatch;
	}
	// 82E85AF0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E85AF4: 48000028  b 0x82e85b1c
	pc = 0x82E85B1C; continue 'dispatch;
            }
            0x82E85AF8 => {
    //   block [0x82E85AF8..0x82E85B04)
	// 82E85AF8: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E85AFC: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82E85B00: 48000018  b 0x82e85b18
	pc = 0x82E85B18; continue 'dispatch;
            }
            0x82E85B04 => {
    //   block [0x82E85B04..0x82E85B18)
	// 82E85B04: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E85B08: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82E85B0C: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E85B10: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E85B14: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	pc = 0x82E85B18; continue 'dispatch;
            }
            0x82E85B18 => {
    //   block [0x82E85B18..0x82E85B1C)
	// 82E85B18: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82E85B1C; continue 'dispatch;
            }
            0x82E85B1C => {
    //   block [0x82E85B1C..0x82E85B30)
	// 82E85B1C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E85B20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E85B24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E85B28: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E85B2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E85B30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E85B30 size=196
    let mut pc: u32 = 0x82E85B30;
    'dispatch: loop {
        match pc {
            0x82E85B30 => {
    //   block [0x82E85B30..0x82E85B68)
	// 82E85B30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E85B34: 4BE238D1  bl 0x82ca9404
	ctx.lr = 0x82E85B38;
	sub_82CA93D0(ctx, base);
	// 82E85B38: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E85B3C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82E85B40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E85B44: 392B2390  addi r9, r11, 0x2390
	ctx.r[9].s64 = ctx.r[11].s64 + 9104;
	// 82E85B48: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82E85B4C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82E85B50: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82E85B54: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82E85B58: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82E85B5C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E85B60: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82E85B64: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	pc = 0x82E85B68; continue 'dispatch;
            }
            0x82E85B68 => {
    //   block [0x82E85B68..0x82E85B94)
	// 82E85B68: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E85B6C: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E85B70: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82E85B74: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E85B78: 4082FFF0  bne 0x82e85b68
	if !ctx.cr[0].eq {
	pc = 0x82E85B68; continue 'dispatch;
	}
	// 82E85B7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E85B80: 4BFFFEE9  bl 0x82e85a68
	ctx.lr = 0x82E85B84;
	sub_82E85A68(ctx, base);
	// 82E85B84: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E85B88: 4082000C  bne 0x82e85b94
	if !ctx.cr[0].eq {
	pc = 0x82E85B94; continue 'dispatch;
	}
	// 82E85B8C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82E85B90: 48000010  b 0x82e85ba0
	pc = 0x82E85BA0; continue 'dispatch;
            }
            0x82E85B94 => {
    //   block [0x82E85B94..0x82E85BA0)
	// 82E85B94: 4BFFFE5D  bl 0x82e859f0
	ctx.lr = 0x82E85B98;
	sub_82E859F0(ctx, base);
	// 82E85B98: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E85B9C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82E85BA0; continue 'dispatch;
            }
            0x82E85BA0 => {
    //   block [0x82E85BA0..0x82E85BC4)
	// 82E85BA0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E85BA4: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82E85BA8: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82E85BAC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E85BB0: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82E85BB4: 409A0010  bne cr6, 0x82e85bc4
	if !ctx.cr[6].eq {
	pc = 0x82E85BC4; continue 'dispatch;
	}
	// 82E85BB8: 4BFF9EA1  bl 0x82e7fa58
	ctx.lr = 0x82E85BBC;
	sub_82E7FA58(ctx, base);
	// 82E85BBC: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82E85BC0: 4800000C  b 0x82e85bcc
	pc = 0x82E85BCC; continue 'dispatch;
            }
            0x82E85BC4 => {
    //   block [0x82E85BC4..0x82E85BCC)
	// 82E85BC4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E85BC8: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	pc = 0x82E85BCC; continue 'dispatch;
            }
            0x82E85BCC => {
    //   block [0x82E85BCC..0x82E85BE8)
	// 82E85BCC: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E85BD0: 41820018  beq 0x82e85be8
	if ctx.cr[0].eq {
	pc = 0x82E85BE8; continue 'dispatch;
	}
	// 82E85BD4: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E85BD8: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82E85BDC: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82E85BE0: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82E85BE4: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	pc = 0x82E85BE8; continue 'dispatch;
            }
            0x82E85BE8 => {
    //   block [0x82E85BE8..0x82E85BF4)
	// 82E85BE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E85BEC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E85BF0: 4BE23864  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E85BF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E85BF8 size=68
    let mut pc: u32 = 0x82E85BF8;
    'dispatch: loop {
        match pc {
            0x82E85BF8 => {
    //   block [0x82E85BF8..0x82E85C3C)
	// 82E85BF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E85BFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E85C00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E85C04: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E85C08: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82E85C0C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82E85C10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E85C14: 4BFFFF1D  bl 0x82e85b30
	ctx.lr = 0x82E85C18;
	sub_82E85B30(ctx, base);
	// 82E85C18: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E85C1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E85C20: 396B9830  addi r11, r11, -0x67d0
	ctx.r[11].s64 = ctx.r[11].s64 + -26576;
	// 82E85C24: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E85C28: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E85C2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E85C30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E85C34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E85C38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E85C40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E85C40 size=48
    let mut pc: u32 = 0x82E85C40;
    'dispatch: loop {
        match pc {
            0x82E85C40 => {
    //   block [0x82E85C40..0x82E85C70)
	// 82E85C40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E85C44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E85C48: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E85C4C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E85C50: C00BDC10  lfs f0, -0x23f0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9200 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E85C54: EC200072  fmuls f1, f0, f1
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 82E85C58: 4B3B4259  bl 0x82239eb0
	ctx.lr = 0x82E85C5C;
	sub_82239EB0(ctx, base);
	// 82E85C5C: FC200818  frsp f1, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E85C60: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E85C64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E85C68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E85C6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E85C70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E85C70 size=48
    let mut pc: u32 = 0x82E85C70;
    'dispatch: loop {
        match pc {
            0x82E85C70 => {
    //   block [0x82E85C70..0x82E85CA0)
	// 82E85C70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E85C74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E85C78: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E85C7C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E85C80: C00BDC10  lfs f0, -0x23f0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9200 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E85C84: EC200072  fmuls f1, f0, f1
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 82E85C88: 4B3B4309  bl 0x82239f90
	ctx.lr = 0x82E85C8C;
	sub_82239F90(ctx, base);
	// 82E85C8C: FC200818  frsp f1, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E85C90: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E85C94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E85C98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E85C9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E85CA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E85CA0 size=200
    let mut pc: u32 = 0x82E85CA0;
    'dispatch: loop {
        match pc {
            0x82E85CA0 => {
    //   block [0x82E85CA0..0x82E85D68)
	// 82E85CA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E85CA4: 4BE23769  bl 0x82ca940c
	ctx.lr = 0x82E85CA8;
	sub_82CA93D0(ctx, base);
	// 82E85CA8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82E85CAC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E85CB0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E85CB4: 3FA08330  lis r29, -0x7cd0
	ctx.r[29].s64 = -2094006272;
	// 82E85CB8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E85CBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E85CC0: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E85CC4: C1BDDC10  lfs f13, -0x23f0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9200 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E85CC8: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E85CCC: EC2C0372  fmuls f1, f12, f13
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82E85CD0: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E85CD4: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E85CD8: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E85CDC: 4B3B42B5  bl 0x82239f90
	ctx.lr = 0x82E85CE0;
	sub_82239F90(ctx, base);
	// 82E85CE0: C1BE0000  lfs f13, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E85CE4: FFE00818  frsp f31, f1
	ctx.f[31].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E85CE8: C01DDC10  lfs f0, -0x23f0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9200 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E85CEC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E85CF0: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 82E85CF4: 4B3B41BD  bl 0x82239eb0
	ctx.lr = 0x82E85CF8;
	sub_82239EB0(ctx, base);
	// 82E85CF8: C1BE0004  lfs f13, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E85CFC: C01DDC10  lfs f0, -0x23f0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9200 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E85D00: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E85D04: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E85D08: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 82E85D0C: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E85D10: D1BF0000  stfs f13, 0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E85D14: 4B3B419D  bl 0x82239eb0
	ctx.lr = 0x82E85D18;
	sub_82239EB0(ctx, base);
	// 82E85D18: C1BE0000  lfs f13, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E85D1C: C01DDC10  lfs f0, -0x23f0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9200 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E85D20: FFE00818  frsp f31, f1
	ctx.f[31].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E85D24: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E85D28: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 82E85D2C: 4B3B4185  bl 0x82239eb0
	ctx.lr = 0x82E85D30;
	sub_82239EB0(ctx, base);
	// 82E85D30: C1BE0000  lfs f13, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E85D34: C01DDC10  lfs f0, -0x23f0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-9200 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E85D38: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E85D3C: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E85D40: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 82E85D44: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E85D48: D1BF0008  stfs f13, 8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E85D4C: 4B3B4245  bl 0x82239f90
	ctx.lr = 0x82E85D50;
	sub_82239F90(ctx, base);
	// 82E85D50: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E85D54: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E85D58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E85D5C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E85D60: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82E85D64: 4BE236F8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E85D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E85D68 size=228
    let mut pc: u32 = 0x82E85D68;
    'dispatch: loop {
        match pc {
            0x82E85D68 => {
    //   block [0x82E85D68..0x82E85DD8)
	// 82E85D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E85D6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E85D70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E85D74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E85D78: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82E85D7C: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82E85D80: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E85D84: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E85D88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E85D8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E85D90: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E85D94: D3FF0000  stfs f31, 0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E85D98: D3FF0004  stfs f31, 4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E85D9C: D3FF0008  stfs f31, 8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E85DA0: 4B3F94C9  bl 0x8227f268
	ctx.lr = 0x82E85DA4;
	sub_8227F268(ctx, base);
	// 82E85DA4: C3C10058  lfs f30, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82E85DA8: FF1EF800  fcmpu cr6, f30, f31
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 82E85DAC: 419A002C  beq cr6, 0x82e85dd8
	if ctx.cr[6].eq {
	pc = 0x82E85DD8; continue 'dispatch;
	}
	// 82E85DB0: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E85DB4: EC20F024  fdivs f1, f0, f30
	ctx.f[1].f64 = ((ctx.f[0].f64 / ctx.f[30].f64) as f32) as f64;
	// 82E85DB8: 4B3F93C9  bl 0x8227f180
	ctx.lr = 0x82E85DBC;
	sub_8227F180(ctx, base);
	// 82E85DBC: FF1EF800  fcmpu cr6, f30, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 82E85DC0: FC000818  frsp f0, f1
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E85DC4: 40980038  bge cr6, 0x82e85dfc
	if !ctx.cr[6].lt {
	pc = 0x82E85DFC; continue 'dispatch;
	}
	// 82E85DC8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E85DCC: C1AB9468  lfs f13, -0x6b98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27544 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E85DD0: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82E85DD4: 48000028  b 0x82e85dfc
	pc = 0x82E85DFC; continue 'dispatch;
            }
            0x82E85DD8 => {
    //   block [0x82E85DD8..0x82E85DF0)
	// 82E85DD8: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E85DDC: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 82E85DE0: 40990010  ble cr6, 0x82e85df0
	if !ctx.cr[6].gt {
	pc = 0x82E85DF0; continue 'dispatch;
	}
	// 82E85DE4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82E85DE8: C00B692C  lfs f0, 0x692c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26924 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E85DEC: 48000010  b 0x82e85dfc
	pc = 0x82E85DFC; continue 'dispatch;
            }
            0x82E85DF0 => {
    //   block [0x82E85DF0..0x82E85DFC)
	// 82E85DF0: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82E85DF4: C00B1678  lfs f0, 0x1678(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5752 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E85DF8: FC0D07EE  fsel f0, f13, f31, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[31].f64 } else { ctx.f[0].f64 };
	pc = 0x82E85DFC; continue 'dispatch;
            }
            0x82E85DFC => {
    //   block [0x82E85DFC..0x82E85E4C)
	// 82E85DFC: 3FC08330  lis r30, -0x7cd0
	ctx.r[30].s64 = -2094006272;
	// 82E85E00: C0210054  lfs f1, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E85E04: D3FF0008  stfs f31, 8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E85E08: C1BEDC10  lfs f13, -0x23f0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9200 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E85E0C: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82E85E10: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E85E14: 4B3F94D5  bl 0x8227f2e8
	ctx.lr = 0x82E85E18;
	sub_8227F2E8(ctx, base);
	// 82E85E18: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E85E1C: C1BEDC10  lfs f13, -0x23f0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9200 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E85E20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E85E24: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82E85E28: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E85E2C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E85E30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E85E34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E85E38: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82E85E3C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82E85E40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E85E44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E85E48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E85E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E85E50 size=164
    let mut pc: u32 = 0x82E85E50;
    'dispatch: loop {
        match pc {
            0x82E85E50 => {
    //   block [0x82E85E50..0x82E85E8C)
	// 82E85E50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E85E54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E85E58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E85E5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E85E60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E85E64: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E85E68: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E85E6C: 396B9470  addi r11, r11, -0x6b90
	ctx.r[11].s64 = ctx.r[11].s64 + -27536;
	// 82E85E70: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E85E74: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E85E78: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E85E7C: 409A0010  bne cr6, 0x82e85e8c
	if !ctx.cr[6].eq {
	pc = 0x82E85E8C; continue 'dispatch;
	}
	// 82E85E80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E85E84: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E85E88: 48000050  b 0x82e85ed8
	pc = 0x82E85ED8; continue 'dispatch;
            }
            0x82E85E8C => {
    //   block [0x82E85E8C..0x82E85E94)
	// 82E85E8C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82E85E90: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82E85E94; continue 'dispatch;
            }
            0x82E85E94 => {
    //   block [0x82E85E94..0x82E85EC0)
	// 82E85E94: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E85E98: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E85E9C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E85EA0: 409AFFF4  bne cr6, 0x82e85e94
	if !ctx.cr[6].eq {
	pc = 0x82E85E94; continue 'dispatch;
	}
	// 82E85EA4: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82E85EA8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82E85EAC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E85EB0: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 82E85EB4: 4B790A75  bl 0x82616928
	ctx.lr = 0x82E85EB8;
	sub_82616928(ctx, base);
	// 82E85EB8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E85EBC: 907E0004  stw r3, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	pc = 0x82E85EC0; continue 'dispatch;
            }
            0x82E85EC0 => {
    //   block [0x82E85EC0..0x82E85ED8)
	// 82E85EC0: 895F0000  lbz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E85EC4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82E85EC8: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E85ECC: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82E85ED0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E85ED4: 4082FFEC  bne 0x82e85ec0
	if !ctx.cr[0].eq {
	pc = 0x82E85EC0; continue 'dispatch;
	}
	pc = 0x82E85ED8; continue 'dispatch;
            }
            0x82E85ED8 => {
    //   block [0x82E85ED8..0x82E85EF4)
	// 82E85ED8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E85EDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E85EE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E85EE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E85EE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E85EEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E85EF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E85EF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E85EF8 size=60
    let mut pc: u32 = 0x82E85EF8;
    'dispatch: loop {
        match pc {
            0x82E85EF8 => {
    //   block [0x82E85EF8..0x82E85F34)
	// 82E85EF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E85EFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E85F00: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E85F04: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E85F08: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E85F0C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E85F10: 4E800421  bctrl
	ctx.lr = 0x82E85F14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E85F14: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E85F18: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82E85F1C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82E85F20: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82E85F24: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E85F28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E85F2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E85F30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E85F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E85F38 size=60
    let mut pc: u32 = 0x82E85F38;
    'dispatch: loop {
        match pc {
            0x82E85F38 => {
    //   block [0x82E85F38..0x82E85F74)
	// 82E85F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E85F3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E85F40: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E85F44: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E85F48: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E85F4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E85F50: 4E800421  bctrl
	ctx.lr = 0x82E85F54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E85F54: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E85F58: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82E85F5C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82E85F60: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82E85F64: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E85F68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E85F6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E85F70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E85F78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E85F78 size=92
    let mut pc: u32 = 0x82E85F78;
    'dispatch: loop {
        match pc {
            0x82E85F78 => {
    //   block [0x82E85F78..0x82E85FB4)
	// 82E85F78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E85F7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E85F80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E85F84: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E85F88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E85F8C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E85F90: 396B9470  addi r11, r11, -0x6b90
	ctx.r[11].s64 = ctx.r[11].s64 + -27536;
	// 82E85F94: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E85F98: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E85F9C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E85FA0: 41820014  beq 0x82e85fb4
	if ctx.cr[0].eq {
	pc = 0x82E85FB4; continue 'dispatch;
	}
	// 82E85FA4: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E85FA8: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E85FAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E85FB0: 4E800421  bctrl
	ctx.lr = 0x82E85FB4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E85FB4 => {
    //   block [0x82E85FB4..0x82E85FD4)
	// 82E85FB4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E85FB8: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82E85FBC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E85FC0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E85FC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E85FC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E85FCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E85FD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E85FD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E85FD8 size=148
    let mut pc: u32 = 0x82E85FD8;
    'dispatch: loop {
        match pc {
            0x82E85FD8 => {
    //   block [0x82E85FD8..0x82E86004)
	// 82E85FD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E85FDC: 4BE23429  bl 0x82ca9404
	ctx.lr = 0x82E85FE0;
	sub_82CA93D0(ctx, base);
	// 82E85FE0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E85FE4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E85FE8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82E85FEC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E85FF0: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E85FF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E85FF8: 40990060  ble cr6, 0x82e86058
	if !ctx.cr[6].gt {
	pc = 0x82E86058; continue 'dispatch;
	}
	// 82E85FFC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E86000: 3B8B8FD8  addi r28, r11, -0x7028
	ctx.r[28].s64 = ctx.r[11].s64 + -28712;
	pc = 0x82E86004; continue 'dispatch;
            }
            0x82E86004 => {
    //   block [0x82E86004..0x82E86048)
	// 82E86004: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E86008: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8600C: 4BFFE01D  bl 0x82e84028
	ctx.lr = 0x82E86010;
	sub_82E84028(ctx, base);
	// 82E86010: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E86014: 4833604D  bl 0x831bc060
	ctx.lr = 0x82E86018;
	sub_831BC060(ctx, base);
	// 82E86018: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E8601C: 4BE26B35  bl 0x82cacb50
	ctx.lr = 0x82E86020;
	sub_82CACB50(ctx, base);
	// 82E86020: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E86024: 41820024  beq 0x82e86048
	if ctx.cr[0].eq {
	pc = 0x82E86048; continue 'dispatch;
	}
	// 82E86028: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8602C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E86030: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82E86034: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86038: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8603C: 4E800421  bctrl
	ctx.lr = 0x82E86040;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E86040: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E86044: 41820020  beq 0x82e86064
	if ctx.cr[0].eq {
	pc = 0x82E86064; continue 'dispatch;
	}
            }
            0x82E86048 => {
    //   block [0x82E86048..0x82E86058)
	// 82E86048: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E8604C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82E86050: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E86054: 4198FFB0  blt cr6, 0x82e86004
	if ctx.cr[6].lt {
	pc = 0x82E86004; continue 'dispatch;
	}
	pc = 0x82E86058; continue 'dispatch;
            }
            0x82E86058 => {
    //   block [0x82E86058..0x82E8605C)
	// 82E86058: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82E8605C; continue 'dispatch;
            }
            0x82E8605C => {
    //   block [0x82E8605C..0x82E86064)
	// 82E8605C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E86060: 4BE233F4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82E86064 => {
    //   block [0x82E86064..0x82E8606C)
	// 82E86064: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E86068: 4BFFFFF4  b 0x82e8605c
	pc = 0x82E8605C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E86070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E86070 size=88
    let mut pc: u32 = 0x82E86070;
    'dispatch: loop {
        match pc {
            0x82E86070 => {
    //   block [0x82E86070..0x82E860AC)
	// 82E86070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E86074: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E86078: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8607C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E86080: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E86084: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E86088: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8608C: 4BFFFEED  bl 0x82e85f78
	ctx.lr = 0x82E86090;
	sub_82E85F78(ctx, base);
	// 82E86090: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E86094: 41820018  beq 0x82e860ac
	if ctx.cr[0].eq {
	pc = 0x82E860AC; continue 'dispatch;
	}
	// 82E86098: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E8609C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E860A0: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E860A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E860A8: 4E800421  bctrl
	ctx.lr = 0x82E860AC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E860AC => {
    //   block [0x82E860AC..0x82E860C8)
	// 82E860AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E860B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E860B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E860B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E860BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E860C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E860C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E860C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E860C8 size=116
    let mut pc: u32 = 0x82E860C8;
    'dispatch: loop {
        match pc {
            0x82E860C8 => {
    //   block [0x82E860C8..0x82E86110)
	// 82E860C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E860CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E860D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E860D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E860D8: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82E860DC: 816A156C  lwz r11, 0x156c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(5484 as u32) ) } as u64;
	// 82E860E0: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82E860E4: 3D208334  lis r9, -0x7ccc
	ctx.r[9].s64 = -2093744128;
	// 82E860E8: 3BE91168  addi r31, r9, 0x1168
	ctx.r[31].s64 = ctx.r[9].s64 + 4456;
	// 82E860EC: 40820038  bne 0x82e86124
	if !ctx.cr[0].eq {
	pc = 0x82E86124; continue 'dispatch;
	}
	// 82E860F0: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82E860F4: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82E860F8: 8909DC20  lbz r8, -0x23e0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-9184 as u32) ) } as u64;
	// 82E860FC: 916A156C  stw r11, 0x156c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(5484 as u32), ctx.r[11].u32 ) };
	// 82E86100: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E86104: 4182000C  beq 0x82e86110
	if ctx.cr[0].eq {
	pc = 0x82E86110; continue 'dispatch;
	}
	// 82E86108: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8610C: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	pc = 0x82E86110; continue 'dispatch;
            }
            0x82E86110 => {
    //   block [0x82E86110..0x82E86124)
	// 82E86110: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E86114: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82E86118: 386A83D0  addi r3, r10, -0x7c30
	ctx.r[3].s64 = ctx.r[10].s64 + -31792;
	// 82E8611C: 9969DC20  stb r11, -0x23e0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-9184 as u32), ctx.r[11].u8 ) };
	// 82E86120: 4BE23E01  bl 0x82ca9f20
	ctx.lr = 0x82E86124;
	sub_82CA9F20(ctx, base);
	pc = 0x82E86124; continue 'dispatch;
            }
            0x82E86124 => {
    //   block [0x82E86124..0x82E8613C)
	// 82E86124: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86128: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8612C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E86130: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E86134: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E86138: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E86140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E86140 size=200
    let mut pc: u32 = 0x82E86140;
    'dispatch: loop {
        match pc {
            0x82E86140 => {
    //   block [0x82E86140..0x82E86174)
	// 82E86140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E86144: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E86148: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8614C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E86150: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E86154: 4BFFFF75  bl 0x82e860c8
	ctx.lr = 0x82E86158;
	sub_82E860C8(ctx, base);
	// 82E86158: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E8615C: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82E86160: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E86164: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E86168: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8616C: 40810054  ble 0x82e861c0
	if !ctx.cr[0].gt {
	pc = 0x82E861C0; continue 'dispatch;
	}
	// 82E86170: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82E86174; continue 'dispatch;
            }
            0x82E86174 => {
    //   block [0x82E86174..0x82E86180)
	// 82E86174: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E86178: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82E8617C: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	pc = 0x82E86180; continue 'dispatch;
            }
            0x82E86180 => {
    //   block [0x82E86180..0x82E861A4)
	// 82E86180: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E86184: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E86188: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8618C: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82E86190: 41820014  beq 0x82e861a4
	if ctx.cr[0].eq {
	pc = 0x82E861A4; continue 'dispatch;
	}
	// 82E86194: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E86198: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82E8619C: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82E861A0: 419AFFE0  beq cr6, 0x82e86180
	if ctx.cr[6].eq {
	pc = 0x82E86180; continue 'dispatch;
	}
	pc = 0x82E861A4; continue 'dispatch;
            }
            0x82E861A4 => {
    //   block [0x82E861A4..0x82E861C0)
	// 82E861A4: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E861A8: 41820028  beq 0x82e861d0
	if ctx.cr[0].eq {
	pc = 0x82E861D0; continue 'dispatch;
	}
	// 82E861AC: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E861B0: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82E861B4: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82E861B8: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82E861BC: 4198FFB8  blt cr6, 0x82e86174
	if ctx.cr[6].lt {
	pc = 0x82E86174; continue 'dispatch;
	}
	pc = 0x82E861C0; continue 'dispatch;
            }
            0x82E861C0 => {
    //   block [0x82E861C0..0x82E861D0)
	// 82E861C0: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82E861C4: 409A0018  bne cr6, 0x82e861dc
	if !ctx.cr[6].eq {
	pc = 0x82E861DC; continue 'dispatch;
	}
	// 82E861C8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E861CC: 48000028  b 0x82e861f4
	pc = 0x82E861F4; continue 'dispatch;
            }
            0x82E861D0 => {
    //   block [0x82E861D0..0x82E861DC)
	// 82E861D0: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E861D4: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82E861D8: 48000018  b 0x82e861f0
	pc = 0x82E861F0; continue 'dispatch;
            }
            0x82E861DC => {
    //   block [0x82E861DC..0x82E861F0)
	// 82E861DC: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E861E0: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82E861E4: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E861E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E861EC: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	pc = 0x82E861F0; continue 'dispatch;
            }
            0x82E861F0 => {
    //   block [0x82E861F0..0x82E861F4)
	// 82E861F0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82E861F4; continue 'dispatch;
            }
            0x82E861F4 => {
    //   block [0x82E861F4..0x82E86208)
	// 82E861F4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E861F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E861FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E86200: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E86204: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E86208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E86208 size=196
    let mut pc: u32 = 0x82E86208;
    'dispatch: loop {
        match pc {
            0x82E86208 => {
    //   block [0x82E86208..0x82E86240)
	// 82E86208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8620C: 4BE231F9  bl 0x82ca9404
	ctx.lr = 0x82E86210;
	sub_82CA93D0(ctx, base);
	// 82E86210: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E86214: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82E86218: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8621C: 392B2390  addi r9, r11, 0x2390
	ctx.r[9].s64 = ctx.r[11].s64 + 9104;
	// 82E86220: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82E86224: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82E86228: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82E8622C: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82E86230: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82E86234: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E86238: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82E8623C: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	pc = 0x82E86240; continue 'dispatch;
            }
            0x82E86240 => {
    //   block [0x82E86240..0x82E8626C)
	// 82E86240: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E86244: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E86248: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82E8624C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E86250: 4082FFF0  bne 0x82e86240
	if !ctx.cr[0].eq {
	pc = 0x82E86240; continue 'dispatch;
	}
	// 82E86254: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86258: 4BFFFEE9  bl 0x82e86140
	ctx.lr = 0x82E8625C;
	sub_82E86140(ctx, base);
	// 82E8625C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E86260: 4082000C  bne 0x82e8626c
	if !ctx.cr[0].eq {
	pc = 0x82E8626C; continue 'dispatch;
	}
	// 82E86264: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82E86268: 48000010  b 0x82e86278
	pc = 0x82E86278; continue 'dispatch;
            }
            0x82E8626C => {
    //   block [0x82E8626C..0x82E86278)
	// 82E8626C: 4BFFFE5D  bl 0x82e860c8
	ctx.lr = 0x82E86270;
	sub_82E860C8(ctx, base);
	// 82E86270: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E86274: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82E86278; continue 'dispatch;
            }
            0x82E86278 => {
    //   block [0x82E86278..0x82E8629C)
	// 82E86278: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E8627C: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82E86280: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82E86284: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E86288: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82E8628C: 409A0010  bne cr6, 0x82e8629c
	if !ctx.cr[6].eq {
	pc = 0x82E8629C; continue 'dispatch;
	}
	// 82E86290: 4BFF97C9  bl 0x82e7fa58
	ctx.lr = 0x82E86294;
	sub_82E7FA58(ctx, base);
	// 82E86294: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82E86298: 4800000C  b 0x82e862a4
	pc = 0x82E862A4; continue 'dispatch;
            }
            0x82E8629C => {
    //   block [0x82E8629C..0x82E862A4)
	// 82E8629C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E862A0: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	pc = 0x82E862A4; continue 'dispatch;
            }
            0x82E862A4 => {
    //   block [0x82E862A4..0x82E862C0)
	// 82E862A4: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E862A8: 41820018  beq 0x82e862c0
	if ctx.cr[0].eq {
	pc = 0x82E862C0; continue 'dispatch;
	}
	// 82E862AC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E862B0: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82E862B4: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82E862B8: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82E862BC: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	pc = 0x82E862C0; continue 'dispatch;
            }
            0x82E862C0 => {
    //   block [0x82E862C0..0x82E862CC)
	// 82E862C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E862C4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E862C8: 4BE2318C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E862D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E862D0 size=68
    let mut pc: u32 = 0x82E862D0;
    'dispatch: loop {
        match pc {
            0x82E862D0 => {
    //   block [0x82E862D0..0x82E86314)
	// 82E862D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E862D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E862D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E862DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E862E0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82E862E4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82E862E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E862EC: 4BFFFF1D  bl 0x82e86208
	ctx.lr = 0x82E862F0;
	sub_82E86208(ctx, base);
	// 82E862F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E862F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E862F8: 396B9830  addi r11, r11, -0x67d0
	ctx.r[11].s64 = ctx.r[11].s64 + -26576;
	// 82E862FC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E86300: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E86304: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E86308: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8630C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E86310: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E86318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E86318 size=68
    let mut pc: u32 = 0x82E86318;
    'dispatch: loop {
        match pc {
            0x82E86318 => {
    //   block [0x82E86318..0x82E86344)
	// 82E86318: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8631C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E86320: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E86324: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E86328: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82E8632C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E86330: 396B2390  addi r11, r11, 0x2390
	ctx.r[11].s64 = ctx.r[11].s64 + 9104;
	// 82E86334: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E86338: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E8633C: 41820008  beq 0x82e86344
	if ctx.cr[0].eq {
	pc = 0x82E86344; continue 'dispatch;
	}
	// 82E86340: 4B9BF471  bl 0x828457b0
	ctx.lr = 0x82E86344;
	sub_828457B0(ctx, base);
	pc = 0x82E86344; continue 'dispatch;
            }
            0x82E86344 => {
    //   block [0x82E86344..0x82E8635C)
	// 82E86344: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86348: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8634C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E86350: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E86354: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E86358: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E86360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E86360 size=180
    let mut pc: u32 = 0x82E86360;
    'dispatch: loop {
        match pc {
            0x82E86360 => {
    //   block [0x82E86360..0x82E86384)
	// 82E86360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E86364: 4BE230A1  bl 0x82ca9404
	ctx.lr = 0x82E86368;
	sub_82CA93D0(ctx, base);
	// 82E86368: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8636C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82E86370: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82E86374: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82E86378: 409A000C  bne cr6, 0x82e86384
	if !ctx.cr[6].eq {
	pc = 0x82E86384; continue 'dispatch;
	}
	// 82E8637C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E86380: 4800008C  b 0x82e8640c
	pc = 0x82E8640C; continue 'dispatch;
            }
            0x82E86384 => {
    //   block [0x82E86384..0x82E863A0)
	// 82E86384: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86388: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E8638C: 3BEB0060  addi r31, r11, 0x60
	ctx.r[31].s64 = ctx.r[11].s64 + 96;
	// 82E86390: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E86394: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E86398: 40990070  ble cr6, 0x82e86408
	if !ctx.cr[6].gt {
	pc = 0x82E86408; continue 'dispatch;
	}
	// 82E8639C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82E863A0; continue 'dispatch;
            }
            0x82E863A0 => {
    //   block [0x82E863A0..0x82E863C8)
	// 82E863A0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E863A4: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82E863A8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E863AC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82E863B0: 41820018  beq 0x82e863c8
	if ctx.cr[0].eq {
	pc = 0x82E863C8; continue 'dispatch;
	}
	// 82E863B4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E863B8: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E863BC: 4BE26795  bl 0x82cacb50
	ctx.lr = 0x82E863C0;
	sub_82CACB50(ctx, base);
	// 82E863C0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E863C4: 4182001C  beq 0x82e863e0
	if ctx.cr[0].eq {
	pc = 0x82E863E0; continue 'dispatch;
	}
	pc = 0x82E863C8; continue 'dispatch;
            }
            0x82E863C8 => {
    //   block [0x82E863C8..0x82E863E0)
	// 82E863C8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E863CC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82E863D0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82E863D4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E863D8: 4198FFC8  blt cr6, 0x82e863a0
	if ctx.cr[6].lt {
	pc = 0x82E863A0; continue 'dispatch;
	}
	// 82E863DC: 4800002C  b 0x82e86408
	pc = 0x82E86408; continue 'dispatch;
            }
            0x82E863E0 => {
    //   block [0x82E863E0..0x82E86408)
	// 82E863E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E863E4: 809C0050  lwz r4, 0x50(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E863E8: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82E863EC: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82E863F0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E863F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E863F8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82E863FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E86400: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82E86404: 4BFF976D  bl 0x82e7fb70
	ctx.lr = 0x82E86408;
	sub_82E7FB70(ctx, base);
	pc = 0x82E86408; continue 'dispatch;
            }
            0x82E86408 => {
    //   block [0x82E86408..0x82E8640C)
	// 82E86408: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82E8640C; continue 'dispatch;
            }
            0x82E8640C => {
    //   block [0x82E8640C..0x82E86414)
	// 82E8640C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E86410: 4BE23044  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E86418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E86418 size=84
    let mut pc: u32 = 0x82E86418;
    'dispatch: loop {
        match pc {
            0x82E86418 => {
    //   block [0x82E86418..0x82E86454)
	// 82E86418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8641C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E86420: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E86424: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E86428: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E8642C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E86430: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82E86434: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E86438: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82E8643C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E86440: 41820014  beq 0x82e86454
	if ctx.cr[0].eq {
	pc = 0x82E86454; continue 'dispatch;
	}
	// 82E86444: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E86448: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E8644C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E86450: 4E800421  bctrl
	ctx.lr = 0x82E86454;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E86454 => {
    //   block [0x82E86454..0x82E8646C)
	// 82E86454: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86458: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8645C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E86460: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E86464: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E86468: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E86470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E86470 size=36
    let mut pc: u32 = 0x82E86470;
    'dispatch: loop {
        match pc {
            0x82E86470 => {
    //   block [0x82E86470..0x82E86494)
	// 82E86470: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86474: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E86478: 419A001C  beq cr6, 0x82e86494
	if ctx.cr[6].eq {
		sub_82E86494(ctx, base);
		return;
	}
	// 82E8647C: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E86480: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E86484: 419A0010  beq cr6, 0x82e86494
	if ctx.cr[6].eq {
		sub_82E86494(ctx, base);
		return;
	}
	// 82E86488: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E8648C: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86490: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E86494(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E86494 size=8
    let mut pc: u32 = 0x82E86494;
    'dispatch: loop {
        match pc {
            0x82E86494 => {
    //   block [0x82E86494..0x82E8649C)
	// 82E86494: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E86498: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E864A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E864A0 size=144
    let mut pc: u32 = 0x82E864A0;
    'dispatch: loop {
        match pc {
            0x82E864A0 => {
    //   block [0x82E864A0..0x82E864D8)
	// 82E864A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E864A4: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 82E864A8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82E864AC: 99630018  stb r11, 0x18(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 82E864B0: 9103000C  stw r8, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82E864B4: 91230014  stw r9, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82E864B8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E864BC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E864C0: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
	// 82E864C4: 396B002C  addi r11, r11, 0x2c
	ctx.r[11].s64 = ctx.r[11].s64 + 44;
	// 82E864C8: 9123000C  stw r9, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82E864CC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E864D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E864D4: 40990050  ble cr6, 0x82e86524
	if !ctx.cr[6].gt {
	pc = 0x82E86524; continue 'dispatch;
	}
	pc = 0x82E864D8; continue 'dispatch;
            }
            0x82E864D8 => {
    //   block [0x82E864D8..0x82E86508)
	// 82E864D8: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E864DC: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E864E0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E864E4: 7D4A382E  lwzx r10, r10, r7
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82E864E8: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E864EC: 4182001C  beq 0x82e86508
	if ctx.cr[0].eq {
	pc = 0x82E86508; continue 'dispatch;
	}
	// 82E864F0: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E864F4: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E864F8: 91430014  stw r10, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82E864FC: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E86500: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E86504: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	pc = 0x82E86508; continue 'dispatch;
            }
            0x82E86508 => {
    //   block [0x82E86508..0x82E86524)
	// 82E86508: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8650C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E86510: 9143000C  stw r10, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82E86514: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E86518: 80EB000C  lwz r7, 0xc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8651C: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82E86520: 4198FFB8  blt cr6, 0x82e864d8
	if ctx.cr[6].lt {
	pc = 0x82E864D8; continue 'dispatch;
	}
	pc = 0x82E86524; continue 'dispatch;
            }
            0x82E86524 => {
    //   block [0x82E86524..0x82E86530)
	// 82E86524: 9103000C  stw r8, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82E86528: 91230014  stw r9, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82E8652C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E86530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E86530 size=168
    let mut pc: u32 = 0x82E86530;
    'dispatch: loop {
        match pc {
            0x82E86530 => {
    //   block [0x82E86530..0x82E86580)
	// 82E86530: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E86534: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86538: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E8653C: 99630018  stb r11, 0x18(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 82E86540: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82E86544: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E86548: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8654C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82E86550: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E86554: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E86558: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82E8655C: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E86560: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E86564: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 82E86568: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8656C: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86570: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E86574: 394A002C  addi r10, r10, 0x2c
	ctx.r[10].s64 = ctx.r[10].s64 + 44;
	// 82E86578: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82E8657C: 48000044  b 0x82e865c0
	pc = 0x82E865C0; continue 'dispatch;
            }
            0x82E86580 => {
    //   block [0x82E86580..0x82E865B0)
	// 82E86580: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E86584: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86588: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E8658C: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82E86590: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E86594: 4182001C  beq 0x82e865b0
	if ctx.cr[0].eq {
	pc = 0x82E865B0; continue 'dispatch;
	}
	// 82E86598: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8659C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E865A0: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82E865A4: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E865A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E865AC: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	pc = 0x82E865B0; continue 'dispatch;
            }
            0x82E865B0 => {
    //   block [0x82E865B0..0x82E865C0)
	// 82E865B0: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E865B4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E865B8: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82E865BC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	pc = 0x82E865C0; continue 'dispatch;
            }
            0x82E865C0 => {
    //   block [0x82E865C0..0x82E865D8)
	// 82E865C0: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E865C4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E865C8: 4198FFB8  blt cr6, 0x82e86580
	if ctx.cr[6].lt {
	pc = 0x82E86580; continue 'dispatch;
	}
	// 82E865CC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82E865D0: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82E865D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E865D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E865D8 size=284
    let mut pc: u32 = 0x82E865D8;
    'dispatch: loop {
        match pc {
            0x82E865D8 => {
    //   block [0x82E865D8..0x82E86694)
	// 82E865D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E865DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E865E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E865E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E865E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E865EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E865F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E865F4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E865F8: 395F0010  addi r10, r31, 0x10
	ctx.r[10].s64 = ctx.r[31].s64 + 16;
	// 82E865FC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82E86600: C00B0A94  lfs f0, 0xa94(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2708 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E86604: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E86608: 90BF0004  stw r5, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82E8660C: 90DF0008  stw r6, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82E86610: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E86614: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E86618: 392B9498  addi r9, r11, -0x6b68
	ctx.r[9].s64 = ctx.r[11].s64 + -27496;
	// 82E8661C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E86620: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E86624: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82E86628: C18B9494  lfs f12, -0x6b6c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27500 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8662C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E86630: 3929A8F0  addi r9, r9, -0x5710
	ctx.r[9].s64 = ctx.r[9].s64 + -22288;
	// 82E86634: 390B9490  addi r8, r11, -0x6b70
	ctx.r[8].s64 = ctx.r[11].s64 + -27504;
	// 82E86638: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E8663C: 38EB9128  addi r7, r11, -0x6ed8
	ctx.r[7].s64 = ctx.r[11].s64 + -28376;
	// 82E86640: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E86644: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82E86648: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82E8664C: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E86650: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82E86654: 90EA0010  stw r7, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[7].u32 ) };
	// 82E86658: 916A0014  stw r11, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82E8665C: 996A0018  stb r11, 0x18(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 82E86660: 913F002C  stw r9, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 82E86664: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82E86668: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82E8666C: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 82E86670: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82E86674: D1BF0040  stfs f13, 0x40(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82E86678: 997F0044  stb r11, 0x44(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u8 ) };
	// 82E8667C: D19F0048  stfs f12, 0x48(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 82E86680: 917F004C  stw r11, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82E86684: 917F0050  stw r11, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82E86688: 419A0050  beq cr6, 0x82e866d8
	if ctx.cr[6].eq {
	pc = 0x82E866D8; continue 'dispatch;
	}
	// 82E8668C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82E86690: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82E86694; continue 'dispatch;
            }
            0x82E86694 => {
    //   block [0x82E86694..0x82E866C0)
	// 82E86694: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E86698: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E8669C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E866A0: 409AFFF4  bne cr6, 0x82e86694
	if !ctx.cr[6].eq {
	pc = 0x82E86694; continue 'dispatch;
	}
	// 82E866A4: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82E866A8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82E866AC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E866B0: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 82E866B4: 4B790275  bl 0x82616928
	ctx.lr = 0x82E866B8;
	sub_82616928(ctx, base);
	// 82E866B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E866BC: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	pc = 0x82E866C0; continue 'dispatch;
            }
            0x82E866C0 => {
    //   block [0x82E866C0..0x82E866D8)
	// 82E866C0: 895E0000  lbz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E866C4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82E866C8: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E866CC: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82E866D0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E866D4: 4082FFEC  bne 0x82e866c0
	if !ctx.cr[0].eq {
	pc = 0x82E866C0; continue 'dispatch;
	}
	pc = 0x82E866D8; continue 'dispatch;
            }
            0x82E866D8 => {
    //   block [0x82E866D8..0x82E866F4)
	// 82E866D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E866DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E866E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E866E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E866E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E866EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E866F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E866F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E866F8 size=140
    let mut pc: u32 = 0x82E866F8;
    'dispatch: loop {
        match pc {
            0x82E866F8 => {
    //   block [0x82E866F8..0x82E86738)
	// 82E866F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E866FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E86700: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E86704: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E86708: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8670C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E86710: 396B9498  addi r11, r11, -0x6b68
	ctx.r[11].s64 = ctx.r[11].s64 + -27496;
	// 82E86714: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E86718: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8671C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E86720: 41820018  beq 0x82e86738
	if ctx.cr[0].eq {
	pc = 0x82E86738; continue 'dispatch;
	}
	// 82E86724: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E86728: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E8672C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E86730: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E86734: 4E800421  bctrl
	ctx.lr = 0x82E86738;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E86738 => {
    //   block [0x82E86738..0x82E86754)
	// 82E86738: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8673C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E86740: 41820014  beq 0x82e86754
	if ctx.cr[0].eq {
	pc = 0x82E86754; continue 'dispatch;
	}
	// 82E86744: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E86748: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E8674C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E86750: 4E800421  bctrl
	ctx.lr = 0x82E86754;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E86754 => {
    //   block [0x82E86754..0x82E86784)
	// 82E86754: 387F002C  addi r3, r31, 0x2c
	ctx.r[3].s64 = ctx.r[31].s64 + 44;
	// 82E86758: 48032C29  bl 0x82eb9380
	ctx.lr = 0x82E8675C;
	sub_82EB9380(ctx, base);
	// 82E8675C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E86760: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82E86764: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82E86768: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82E8676C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E86770: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E86774: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E86778: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8677C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E86780: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E86788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E86788 size=164
    let mut pc: u32 = 0x82E86788;
    'dispatch: loop {
        match pc {
            0x82E86788 => {
    //   block [0x82E86788..0x82E867A4)
	// 82E86788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8678C: 4BE22C79  bl 0x82ca9404
	ctx.lr = 0x82E86790;
	sub_82CA93D0(ctx, base);
	// 82E86790: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E86794: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82E86798: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82E8679C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82E867A0: 409A000C  bne cr6, 0x82e867ac
	if !ctx.cr[6].eq {
	pc = 0x82E867AC; continue 'dispatch;
	}
	pc = 0x82E867A4; continue 'dispatch;
            }
            0x82E867A4 => {
    //   block [0x82E867A4..0x82E867AC)
	// 82E867A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E867A8: 4800007C  b 0x82e86824
	pc = 0x82E86824; continue 'dispatch;
            }
            0x82E867AC => {
    //   block [0x82E867AC..0x82E867C8)
	// 82E867AC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E867B0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E867B4: 3BEB0050  addi r31, r11, 0x50
	ctx.r[31].s64 = ctx.r[11].s64 + 80;
	// 82E867B8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E867BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E867C0: 4099FFE4  ble cr6, 0x82e867a4
	if !ctx.cr[6].gt {
	pc = 0x82E867A4; continue 'dispatch;
	}
	// 82E867C4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82E867C8; continue 'dispatch;
            }
            0x82E867C8 => {
    //   block [0x82E867C8..0x82E867FC)
	// 82E867C8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E867CC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E867D0: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82E867D4: 806B001C  lwz r3, 0x1c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E867D8: 4BE26379  bl 0x82cacb50
	ctx.lr = 0x82E867DC;
	sub_82CACB50(ctx, base);
	// 82E867DC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E867E0: 4182001C  beq 0x82e867fc
	if ctx.cr[0].eq {
	pc = 0x82E867FC; continue 'dispatch;
	}
	// 82E867E4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E867E8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82E867EC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82E867F0: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E867F4: 4198FFD4  blt cr6, 0x82e867c8
	if ctx.cr[6].lt {
	pc = 0x82E867C8; continue 'dispatch;
	}
	// 82E867F8: 4BFFFFAC  b 0x82e867a4
	pc = 0x82E867A4; continue 'dispatch;
            }
            0x82E867FC => {
    //   block [0x82E867FC..0x82E86824)
	// 82E867FC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86800: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E86804: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82E86808: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8680C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82E86810: 4182FF94  beq 0x82e867a4
	if ctx.cr[0].eq {
	pc = 0x82E867A4; continue 'dispatch;
	}
	// 82E86814: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E86818: 387B002C  addi r3, r27, 0x2c
	ctx.r[3].s64 = ctx.r[27].s64 + 44;
	// 82E8681C: 48032A75  bl 0x82eb9290
	ctx.lr = 0x82E86820;
	sub_82EB9290(ctx, base);
	// 82E86820: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82E86824; continue 'dispatch;
            }
            0x82E86824 => {
    //   block [0x82E86824..0x82E8682C)
	// 82E86824: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E86828: 4BE22C2C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E86830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E86830 size=116
    let mut pc: u32 = 0x82E86830;
    'dispatch: loop {
        match pc {
            0x82E86830 => {
    //   block [0x82E86830..0x82E86878)
	// 82E86830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E86834: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E86838: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8683C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E86840: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82E86844: 816A1974  lwz r11, 0x1974(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6516 as u32) ) } as u64;
	// 82E86848: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82E8684C: 3D208334  lis r9, -0x7ccc
	ctx.r[9].s64 = -2093744128;
	// 82E86850: 3BE91570  addi r31, r9, 0x1570
	ctx.r[31].s64 = ctx.r[9].s64 + 5488;
	// 82E86854: 40820038  bne 0x82e8688c
	if !ctx.cr[0].eq {
	pc = 0x82E8688C; continue 'dispatch;
	}
	// 82E86858: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82E8685C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82E86860: 8909DC30  lbz r8, -0x23d0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-9168 as u32) ) } as u64;
	// 82E86864: 916A1974  stw r11, 0x1974(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(6516 as u32), ctx.r[11].u32 ) };
	// 82E86868: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8686C: 4182000C  beq 0x82e86878
	if ctx.cr[0].eq {
	pc = 0x82E86878; continue 'dispatch;
	}
	// 82E86870: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E86874: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	pc = 0x82E86878; continue 'dispatch;
            }
            0x82E86878 => {
    //   block [0x82E86878..0x82E8688C)
	// 82E86878: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8687C: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82E86880: 386A8418  addi r3, r10, -0x7be8
	ctx.r[3].s64 = ctx.r[10].s64 + -31720;
	// 82E86884: 9969DC30  stb r11, -0x23d0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-9168 as u32), ctx.r[11].u8 ) };
	// 82E86888: 4BE23699  bl 0x82ca9f20
	ctx.lr = 0x82E8688C;
	sub_82CA9F20(ctx, base);
	pc = 0x82E8688C; continue 'dispatch;
            }
            0x82E8688C => {
    //   block [0x82E8688C..0x82E868A4)
	// 82E8688C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86890: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E86894: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E86898: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8689C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E868A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E868A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E868A8 size=200
    let mut pc: u32 = 0x82E868A8;
    'dispatch: loop {
        match pc {
            0x82E868A8 => {
    //   block [0x82E868A8..0x82E868DC)
	// 82E868A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E868AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E868B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E868B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E868B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E868BC: 4BFFFF75  bl 0x82e86830
	ctx.lr = 0x82E868C0;
	sub_82E86830(ctx, base);
	// 82E868C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E868C4: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82E868C8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E868CC: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E868D0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E868D4: 40810054  ble 0x82e86928
	if !ctx.cr[0].gt {
	pc = 0x82E86928; continue 'dispatch;
	}
	// 82E868D8: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82E868DC; continue 'dispatch;
            }
            0x82E868DC => {
    //   block [0x82E868DC..0x82E868E8)
	// 82E868DC: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E868E0: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82E868E4: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	pc = 0x82E868E8; continue 'dispatch;
            }
            0x82E868E8 => {
    //   block [0x82E868E8..0x82E8690C)
	// 82E868E8: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E868EC: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E868F0: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E868F4: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82E868F8: 41820014  beq 0x82e8690c
	if ctx.cr[0].eq {
	pc = 0x82E8690C; continue 'dispatch;
	}
	// 82E868FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E86900: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82E86904: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82E86908: 419AFFE0  beq cr6, 0x82e868e8
	if ctx.cr[6].eq {
	pc = 0x82E868E8; continue 'dispatch;
	}
	pc = 0x82E8690C; continue 'dispatch;
            }
            0x82E8690C => {
    //   block [0x82E8690C..0x82E86928)
	// 82E8690C: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E86910: 41820028  beq 0x82e86938
	if ctx.cr[0].eq {
	pc = 0x82E86938; continue 'dispatch;
	}
	// 82E86914: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E86918: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82E8691C: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82E86920: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82E86924: 4198FFB8  blt cr6, 0x82e868dc
	if ctx.cr[6].lt {
	pc = 0x82E868DC; continue 'dispatch;
	}
	pc = 0x82E86928; continue 'dispatch;
            }
            0x82E86928 => {
    //   block [0x82E86928..0x82E86938)
	// 82E86928: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82E8692C: 409A0018  bne cr6, 0x82e86944
	if !ctx.cr[6].eq {
	pc = 0x82E86944; continue 'dispatch;
	}
	// 82E86930: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E86934: 48000028  b 0x82e8695c
	pc = 0x82E8695C; continue 'dispatch;
            }
            0x82E86938 => {
    //   block [0x82E86938..0x82E86944)
	// 82E86938: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8693C: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82E86940: 48000018  b 0x82e86958
	pc = 0x82E86958; continue 'dispatch;
            }
            0x82E86944 => {
    //   block [0x82E86944..0x82E86958)
	// 82E86944: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E86948: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82E8694C: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E86950: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E86954: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	pc = 0x82E86958; continue 'dispatch;
            }
            0x82E86958 => {
    //   block [0x82E86958..0x82E8695C)
	// 82E86958: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82E8695C; continue 'dispatch;
            }
            0x82E8695C => {
    //   block [0x82E8695C..0x82E86970)
	// 82E8695C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E86960: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E86964: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E86968: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8696C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E86970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E86970 size=88
    let mut pc: u32 = 0x82E86970;
    'dispatch: loop {
        match pc {
            0x82E86970 => {
    //   block [0x82E86970..0x82E869AC)
	// 82E86970: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E86974: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E86978: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8697C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E86980: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E86984: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E86988: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8698C: 4BFFFD6D  bl 0x82e866f8
	ctx.lr = 0x82E86990;
	sub_82E866F8(ctx, base);
	// 82E86990: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E86994: 41820018  beq 0x82e869ac
	if ctx.cr[0].eq {
	pc = 0x82E869AC; continue 'dispatch;
	}
	// 82E86998: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E8699C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E869A0: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E869A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E869A8: 4E800421  bctrl
	ctx.lr = 0x82E869AC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E869AC => {
    //   block [0x82E869AC..0x82E869C8)
	// 82E869AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E869B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E869B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E869B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E869BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E869C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E869C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E869C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E869C8 size=676
    let mut pc: u32 = 0x82E869C8;
    'dispatch: loop {
        match pc {
            0x82E869C8 => {
    //   block [0x82E869C8..0x82E86A08)
	// 82E869C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E869CC: 4BE22A41  bl 0x82ca940c
	ctx.lr = 0x82E869D0;
	sub_82CA93D0(ctx, base);
	// 82E869D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E869D4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E869D8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E869DC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E869E0: 419A0030  beq cr6, 0x82e86a10
	if ctx.cr[6].eq {
	pc = 0x82E86A10; continue 'dispatch;
	}
	// 82E869E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E869E8: 48335679  bl 0x831bc060
	ctx.lr = 0x82E869EC;
	sub_831BC060(ctx, base);
	// 82E869EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E869F0: 41820020  beq 0x82e86a10
	if ctx.cr[0].eq {
	pc = 0x82E86A10; continue 'dispatch;
	}
	// 82E869F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E869F8: 48335669  bl 0x831bc060
	ctx.lr = 0x82E869FC;
	sub_831BC060(ctx, base);
	// 82E869FC: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E86A00: 2B0B005F  cmplwi cr6, r11, 0x5f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 95 as u32, &mut ctx.xer);
	// 82E86A04: 409A000C  bne cr6, 0x82e86a10
	if !ctx.cr[6].eq {
	pc = 0x82E86A10; continue 'dispatch;
	}
	pc = 0x82E86A08; continue 'dispatch;
            }
            0x82E86A08 => {
    //   block [0x82E86A08..0x82E86A10)
	// 82E86A08: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E86A0C: 48000258  b 0x82e86c64
	pc = 0x82E86C64; continue 'dispatch;
            }
            0x82E86A10 => {
    //   block [0x82E86A10..0x82E86A5C)
	// 82E86A10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86A14: 4833564D  bl 0x831bc060
	ctx.lr = 0x82E86A18;
	sub_831BC060(ctx, base);
	// 82E86A18: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82E86A1C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E86A20: 396BA224  addi r11, r11, -0x5ddc
	ctx.r[11].s64 = ctx.r[11].s64 + -24028;
	// 82E86A24: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E86A28: 4BE26129  bl 0x82cacb50
	ctx.lr = 0x82E86A2C;
	sub_82CACB50(ctx, base);
	// 82E86A2C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E86A30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86A34: 40820044  bne 0x82e86a78
	if !ctx.cr[0].eq {
	pc = 0x82E86A78; continue 'dispatch;
	}
	// 82E86A38: 4BA872D1  bl 0x8290dd08
	ctx.lr = 0x82E86A3C;
	sub_8290DD08(ctx, base);
	// 82E86A3C: 4BE25175  bl 0x82cabbb0
	ctx.lr = 0x82E86A40;
	sub_82CABBB0(ctx, base);
	// 82E86A40: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E86A44: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E86A48: C1BD003C  lfs f13, 0x3c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E86A4C: C00BBE14  lfs f0, -0x41ec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16876 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E86A50: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E86A54: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E86A58: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82E86A5C; continue 'dispatch;
            }
            0x82E86A5C => {
    //   block [0x82E86A5C..0x82E86A68)
	// 82E86A5C: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82E86A60: 41980008  blt cr6, 0x82e86a68
	if ctx.cr[6].lt {
	pc = 0x82E86A68; continue 'dispatch;
	}
	// 82E86A64: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	pc = 0x82E86A68; continue 'dispatch;
            }
            0x82E86A68 => {
    //   block [0x82E86A68..0x82E86A78)
	// 82E86A68: FF0D6800  fcmpu cr6, f13, f13
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[13].f64);
	// 82E86A6C: 409AFFF0  bne cr6, 0x82e86a5c
	if !ctx.cr[6].eq {
	pc = 0x82E86A5C; continue 'dispatch;
	}
	// 82E86A70: D1BD003C  stfs f13, 0x3c(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82E86A74: 4BFFFF94  b 0x82e86a08
	pc = 0x82E86A08; continue 'dispatch;
            }
            0x82E86A78 => {
    //   block [0x82E86A78..0x82E86AC0)
	// 82E86A78: 483355E9  bl 0x831bc060
	ctx.lr = 0x82E86A7C;
	sub_831BC060(ctx, base);
	// 82E86A7C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E86A80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E86A84: 396B94F0  addi r11, r11, -0x6b10
	ctx.r[11].s64 = ctx.r[11].s64 + -27408;
	// 82E86A88: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E86A8C: 4BE260C5  bl 0x82cacb50
	ctx.lr = 0x82E86A90;
	sub_82CACB50(ctx, base);
	// 82E86A90: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E86A94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86A98: 40820044  bne 0x82e86adc
	if !ctx.cr[0].eq {
	pc = 0x82E86ADC; continue 'dispatch;
	}
	// 82E86A9C: 4BA8726D  bl 0x8290dd08
	ctx.lr = 0x82E86AA0;
	sub_8290DD08(ctx, base);
	// 82E86AA0: 4BE25111  bl 0x82cabbb0
	ctx.lr = 0x82E86AA4;
	sub_82CABBB0(ctx, base);
	// 82E86AA4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E86AA8: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E86AAC: C1BD0040  lfs f13, 0x40(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E86AB0: C00BBE14  lfs f0, -0x41ec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16876 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E86AB4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E86AB8: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E86ABC: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82E86AC0; continue 'dispatch;
            }
            0x82E86AC0 => {
    //   block [0x82E86AC0..0x82E86ACC)
	// 82E86AC0: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82E86AC4: 41980008  blt cr6, 0x82e86acc
	if ctx.cr[6].lt {
	pc = 0x82E86ACC; continue 'dispatch;
	}
	// 82E86AC8: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	pc = 0x82E86ACC; continue 'dispatch;
            }
            0x82E86ACC => {
    //   block [0x82E86ACC..0x82E86ADC)
	// 82E86ACC: FF0D6800  fcmpu cr6, f13, f13
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[13].f64);
	// 82E86AD0: 409AFFF0  bne cr6, 0x82e86ac0
	if !ctx.cr[6].eq {
	pc = 0x82E86AC0; continue 'dispatch;
	}
	// 82E86AD4: D1BD0040  stfs f13, 0x40(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82E86AD8: 4BFFFF30  b 0x82e86a08
	pc = 0x82E86A08; continue 'dispatch;
            }
            0x82E86ADC => {
    //   block [0x82E86ADC..0x82E86BB8)
	// 82E86ADC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E86AE0: 3BCB94E0  addi r30, r11, -0x6b20
	ctx.r[30].s64 = ctx.r[11].s64 + -27424;
	// 82E86AE4: 4833557D  bl 0x831bc060
	ctx.lr = 0x82E86AE8;
	sub_831BC060(ctx, base);
	// 82E86AE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E86AEC: 4BE26065  bl 0x82cacb50
	ctx.lr = 0x82E86AF0;
	sub_82CACB50(ctx, base);
	// 82E86AF0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E86AF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86AF8: 408200D4  bne 0x82e86bcc
	if !ctx.cr[0].eq {
	pc = 0x82E86BCC; continue 'dispatch;
	}
	// 82E86AFC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82E86B00: 3BCB1694  addi r30, r11, 0x1694
	ctx.r[30].s64 = ctx.r[11].s64 + 5780;
	// 82E86B04: 4BA87205  bl 0x8290dd08
	ctx.lr = 0x82E86B08;
	sub_8290DD08(ctx, base);
	// 82E86B08: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E86B0C: 4BE26045  bl 0x82cacb50
	ctx.lr = 0x82E86B10;
	sub_82CACB50(ctx, base);
	// 82E86B10: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E86B14: 418200AC  beq 0x82e86bc0
	if ctx.cr[0].eq {
	pc = 0x82E86BC0; continue 'dispatch;
	}
	// 82E86B18: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E86B1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86B20: 3BCB0F40  addi r30, r11, 0xf40
	ctx.r[30].s64 = ctx.r[11].s64 + 3904;
	// 82E86B24: 4BA871E5  bl 0x8290dd08
	ctx.lr = 0x82E86B28;
	sub_8290DD08(ctx, base);
	// 82E86B28: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E86B2C: 4BE26025  bl 0x82cacb50
	ctx.lr = 0x82E86B30;
	sub_82CACB50(ctx, base);
	// 82E86B30: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E86B34: 4182008C  beq 0x82e86bc0
	if ctx.cr[0].eq {
	pc = 0x82E86BC0; continue 'dispatch;
	}
	// 82E86B38: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82E86B3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86B40: 3BCBD56C  addi r30, r11, -0x2a94
	ctx.r[30].s64 = ctx.r[11].s64 + -10900;
	// 82E86B44: 4BA871C5  bl 0x8290dd08
	ctx.lr = 0x82E86B48;
	sub_8290DD08(ctx, base);
	// 82E86B48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E86B4C: 4BE26005  bl 0x82cacb50
	ctx.lr = 0x82E86B50;
	sub_82CACB50(ctx, base);
	// 82E86B50: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E86B54: 4182006C  beq 0x82e86bc0
	if ctx.cr[0].eq {
	pc = 0x82E86BC0; continue 'dispatch;
	}
	// 82E86B58: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82E86B5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86B60: 3BCB1698  addi r30, r11, 0x1698
	ctx.r[30].s64 = ctx.r[11].s64 + 5784;
	// 82E86B64: 4BA871A5  bl 0x8290dd08
	ctx.lr = 0x82E86B68;
	sub_8290DD08(ctx, base);
	// 82E86B68: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E86B6C: 4BE25FE5  bl 0x82cacb50
	ctx.lr = 0x82E86B70;
	sub_82CACB50(ctx, base);
	// 82E86B70: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E86B74: 41820044  beq 0x82e86bb8
	if ctx.cr[0].eq {
	pc = 0x82E86BB8; continue 'dispatch;
	}
	// 82E86B78: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82E86B7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86B80: 3BCB1700  addi r30, r11, 0x1700
	ctx.r[30].s64 = ctx.r[11].s64 + 5888;
	// 82E86B84: 4BA87185  bl 0x8290dd08
	ctx.lr = 0x82E86B88;
	sub_8290DD08(ctx, base);
	// 82E86B88: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E86B8C: 4BE25FC5  bl 0x82cacb50
	ctx.lr = 0x82E86B90;
	sub_82CACB50(ctx, base);
	// 82E86B90: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E86B94: 41820024  beq 0x82e86bb8
	if ctx.cr[0].eq {
	pc = 0x82E86BB8; continue 'dispatch;
	}
	// 82E86B98: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82E86B9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86BA0: 3BCB7088  addi r30, r11, 0x7088
	ctx.r[30].s64 = ctx.r[11].s64 + 28808;
	// 82E86BA4: 4BA87165  bl 0x8290dd08
	ctx.lr = 0x82E86BA8;
	sub_8290DD08(ctx, base);
	// 82E86BA8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E86BAC: 4BE25FA5  bl 0x82cacb50
	ctx.lr = 0x82E86BB0;
	sub_82CACB50(ctx, base);
	// 82E86BB0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E86BB4: 408200AC  bne 0x82e86c60
	if !ctx.cr[0].eq {
	pc = 0x82E86C60; continue 'dispatch;
	}
	pc = 0x82E86BB8; continue 'dispatch;
            }
            0x82E86BB8 => {
    //   block [0x82E86BB8..0x82E86BC0)
	// 82E86BB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E86BBC: 48000008  b 0x82e86bc4
	pc = 0x82E86BC4; continue 'dispatch;
            }
            0x82E86BC0 => {
    //   block [0x82E86BC0..0x82E86BC4)
	// 82E86BC0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82E86BC4; continue 'dispatch;
            }
            0x82E86BC4 => {
    //   block [0x82E86BC4..0x82E86BCC)
	// 82E86BC4: 997D0044  stb r11, 0x44(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(68 as u32), ctx.r[11].u8 ) };
	// 82E86BC8: 4BFFFE40  b 0x82e86a08
	pc = 0x82E86A08; continue 'dispatch;
            }
            0x82E86BCC => {
    //   block [0x82E86BCC..0x82E86C28)
	// 82E86BCC: 48335495  bl 0x831bc060
	ctx.lr = 0x82E86BD0;
	sub_831BC060(ctx, base);
	// 82E86BD0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E86BD4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E86BD8: 396B94D4  addi r11, r11, -0x6b2c
	ctx.r[11].s64 = ctx.r[11].s64 + -27436;
	// 82E86BDC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E86BE0: 4BE25F71  bl 0x82cacb50
	ctx.lr = 0x82E86BE4;
	sub_82CACB50(ctx, base);
	// 82E86BE4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E86BE8: 4182FE20  beq 0x82e86a08
	if ctx.cr[0].eq {
	pc = 0x82E86A08; continue 'dispatch;
	}
	// 82E86BEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86BF0: 48335471  bl 0x831bc060
	ctx.lr = 0x82E86BF4;
	sub_831BC060(ctx, base);
	// 82E86BF4: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82E86BF8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E86BFC: 396B87C4  addi r11, r11, -0x783c
	ctx.r[11].s64 = ctx.r[11].s64 + -30780;
	// 82E86C00: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E86C04: 4BE25F4D  bl 0x82cacb50
	ctx.lr = 0x82E86C08;
	sub_82CACB50(ctx, base);
	// 82E86C08: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E86C0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86C10: 40820018  bne 0x82e86c28
	if !ctx.cr[0].eq {
	pc = 0x82E86C28; continue 'dispatch;
	}
	// 82E86C14: 4BA870F5  bl 0x8290dd08
	ctx.lr = 0x82E86C18;
	sub_8290DD08(ctx, base);
	// 82E86C18: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E86C1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E86C20: 4BFFF741  bl 0x82e86360
	ctx.lr = 0x82E86C24;
	sub_82E86360(ctx, base);
	// 82E86C24: 4BFFFDE4  b 0x82e86a08
	pc = 0x82E86A08; continue 'dispatch;
            }
            0x82E86C28 => {
    //   block [0x82E86C28..0x82E86C60)
	// 82E86C28: 48335439  bl 0x831bc060
	ctx.lr = 0x82E86C2C;
	sub_831BC060(ctx, base);
	// 82E86C2C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E86C30: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E86C34: 396B94C8  addi r11, r11, -0x6b38
	ctx.r[11].s64 = ctx.r[11].s64 + -27448;
	// 82E86C38: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E86C3C: 4BE25F15  bl 0x82cacb50
	ctx.lr = 0x82E86C40;
	sub_82CACB50(ctx, base);
	// 82E86C40: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E86C44: 4082001C  bne 0x82e86c60
	if !ctx.cr[0].eq {
	pc = 0x82E86C60; continue 'dispatch;
	}
	// 82E86C48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86C4C: 4BA870BD  bl 0x8290dd08
	ctx.lr = 0x82E86C50;
	sub_8290DD08(ctx, base);
	// 82E86C50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E86C54: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E86C58: 4BFFFB31  bl 0x82e86788
	ctx.lr = 0x82E86C5C;
	sub_82E86788(ctx, base);
	// 82E86C5C: 4BFFFDAC  b 0x82e86a08
	pc = 0x82E86A08; continue 'dispatch;
            }
            0x82E86C60 => {
    //   block [0x82E86C60..0x82E86C64)
	// 82E86C60: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E86C64; continue 'dispatch;
            }
            0x82E86C64 => {
    //   block [0x82E86C64..0x82E86C6C)
	// 82E86C64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E86C68: 4BE227F4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E86C70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E86C70 size=196
    let mut pc: u32 = 0x82E86C70;
    'dispatch: loop {
        match pc {
            0x82E86C70 => {
    //   block [0x82E86C70..0x82E86CA8)
	// 82E86C70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E86C74: 4BE22791  bl 0x82ca9404
	ctx.lr = 0x82E86C78;
	sub_82CA93D0(ctx, base);
	// 82E86C78: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E86C7C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E86C80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E86C84: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82E86C88: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82E86C8C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82E86C90: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82E86C94: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82E86C98: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82E86C9C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E86CA0: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82E86CA4: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	pc = 0x82E86CA8; continue 'dispatch;
            }
            0x82E86CA8 => {
    //   block [0x82E86CA8..0x82E86CD4)
	// 82E86CA8: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E86CAC: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E86CB0: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82E86CB4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E86CB8: 4082FFF0  bne 0x82e86ca8
	if !ctx.cr[0].eq {
	pc = 0x82E86CA8; continue 'dispatch;
	}
	// 82E86CBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86CC0: 4BFFFBE9  bl 0x82e868a8
	ctx.lr = 0x82E86CC4;
	sub_82E868A8(ctx, base);
	// 82E86CC4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E86CC8: 4082000C  bne 0x82e86cd4
	if !ctx.cr[0].eq {
	pc = 0x82E86CD4; continue 'dispatch;
	}
	// 82E86CCC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82E86CD0: 48000010  b 0x82e86ce0
	pc = 0x82E86CE0; continue 'dispatch;
            }
            0x82E86CD4 => {
    //   block [0x82E86CD4..0x82E86CE0)
	// 82E86CD4: 4BFFFB5D  bl 0x82e86830
	ctx.lr = 0x82E86CD8;
	sub_82E86830(ctx, base);
	// 82E86CD8: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E86CDC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82E86CE0; continue 'dispatch;
            }
            0x82E86CE0 => {
    //   block [0x82E86CE0..0x82E86D04)
	// 82E86CE0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E86CE4: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82E86CE8: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82E86CEC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E86CF0: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82E86CF4: 409A0010  bne cr6, 0x82e86d04
	if !ctx.cr[6].eq {
	pc = 0x82E86D04; continue 'dispatch;
	}
	// 82E86CF8: 4BFF8D61  bl 0x82e7fa58
	ctx.lr = 0x82E86CFC;
	sub_82E7FA58(ctx, base);
	// 82E86CFC: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82E86D00: 4800000C  b 0x82e86d0c
	pc = 0x82E86D0C; continue 'dispatch;
            }
            0x82E86D04 => {
    //   block [0x82E86D04..0x82E86D0C)
	// 82E86D04: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E86D08: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	pc = 0x82E86D0C; continue 'dispatch;
            }
            0x82E86D0C => {
    //   block [0x82E86D0C..0x82E86D28)
	// 82E86D0C: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E86D10: 41820018  beq 0x82e86d28
	if ctx.cr[0].eq {
	pc = 0x82E86D28; continue 'dispatch;
	}
	// 82E86D14: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E86D18: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82E86D1C: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82E86D20: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82E86D24: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	pc = 0x82E86D28; continue 'dispatch;
            }
            0x82E86D28 => {
    //   block [0x82E86D28..0x82E86D34)
	// 82E86D28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86D2C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E86D30: 4BE22724  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E86D38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E86D38 size=520
    let mut pc: u32 = 0x82E86D38;
    'dispatch: loop {
        match pc {
            0x82E86D38 => {
    //   block [0x82E86D38..0x82E86D94)
	// 82E86D38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E86D3C: 4BE226C1  bl 0x82ca93fc
	ctx.lr = 0x82E86D40;
	sub_82CA93D0(ctx, base);
	// 82E86D40: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E86D44: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82E86D48: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E86D4C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82E86D50: 387D002C  addi r3, r29, 0x2c
	ctx.r[3].s64 = ctx.r[29].s64 + 44;
	// 82E86D54: 809A0020  lwz r4, 0x20(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E86D58: 48032481  bl 0x82eb91d8
	ctx.lr = 0x82E86D5C;
	sub_82EB91D8(ctx, base);
	// 82E86D5C: 4BFFF36D  bl 0x82e860c8
	ctx.lr = 0x82E86D60;
	sub_82E860C8(ctx, base);
	// 82E86D60: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82E86D64: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E86D68: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82E86D6C: 388B94D4  addi r4, r11, -0x6b2c
	ctx.r[4].s64 = ctx.r[11].s64 + -27436;
	// 82E86D70: 83EA0400  lwz r31, 0x400(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E86D74: 4BFFD1A5  bl 0x82e83f18
	ctx.lr = 0x82E86D78;
	sub_82E83F18(ctx, base);
	// 82E86D78: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E86D7C: 41820018  beq 0x82e86d94
	if ctx.cr[0].eq {
	pc = 0x82E86D94; continue 'dispatch;
	}
	// 82E86D80: 4BA86F89  bl 0x8290dd08
	ctx.lr = 0x82E86D84;
	sub_8290DD08(ctx, base);
	// 82E86D84: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E86D88: 4182000C  beq 0x82e86d94
	if ctx.cr[0].eq {
	pc = 0x82E86D94; continue 'dispatch;
	}
	// 82E86D8C: 4BE23635  bl 0x82caa3c0
	ctx.lr = 0x82E86D90;
	sub_82CAA3C0(ctx, base);
	// 82E86D90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	pc = 0x82E86D94; continue 'dispatch;
            }
            0x82E86D94 => {
    //   block [0x82E86D94..0x82E86DB0)
	// 82E86D94: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82E86D98: 4B78FB91  bl 0x82616928
	ctx.lr = 0x82E86D9C;
	sub_82616928(ctx, base);
	// 82E86D9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E86DA0: 41820010  beq 0x82e86db0
	if ctx.cr[0].eq {
	pc = 0x82E86DB0; continue 'dispatch;
	}
	// 82E86DA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E86DA8: 48006489  bl 0x82e8d230
	ctx.lr = 0x82E86DAC;
	sub_82E8D230(ctx, base);
	// 82E86DAC: 48000008  b 0x82e86db4
	pc = 0x82E86DB4; continue 'dispatch;
            }
            0x82E86DB0 => {
    //   block [0x82E86DB0..0x82E86DB4)
	// 82E86DB0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E86DB4; continue 'dispatch;
            }
            0x82E86DB4 => {
    //   block [0x82E86DB4..0x82E86DD4)
	// 82E86DB4: 907D0050  stw r3, 0x50(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82E86DB8: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82E86DBC: 817C0020  lwz r11, 0x20(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E86DC0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E86DC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E86DC8: 40990070  ble cr6, 0x82e86e38
	if !ctx.cr[6].gt {
	pc = 0x82E86E38; continue 'dispatch;
	}
	// 82E86DCC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E86DD0: 3B6B8FD8  addi r27, r11, -0x7028
	ctx.r[27].s64 = ctx.r[11].s64 + -28712;
	pc = 0x82E86DD4; continue 'dispatch;
            }
            0x82E86DD4 => {
    //   block [0x82E86DD4..0x82E86E08)
	// 82E86DD4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E86DD8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E86DDC: 4BFFD24D  bl 0x82e84028
	ctx.lr = 0x82E86DE0;
	sub_82E84028(ctx, base);
	// 82E86DE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E86DE4: 4833527D  bl 0x831bc060
	ctx.lr = 0x82E86DE8;
	sub_831BC060(ctx, base);
	// 82E86DE8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E86DEC: 4BE25D65  bl 0x82cacb50
	ctx.lr = 0x82E86DF0;
	sub_82CACB50(ctx, base);
	// 82E86DF0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E86DF4: 40820014  bne 0x82e86e08
	if !ctx.cr[0].eq {
	pc = 0x82E86E08; continue 'dispatch;
	}
	// 82E86DF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86DFC: 4BA86F0D  bl 0x8290dd08
	ctx.lr = 0x82E86E00;
	sub_8290DD08(ctx, base);
	// 82E86E00: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82E86E04: 48000024  b 0x82e86e28
	pc = 0x82E86E28; continue 'dispatch;
            }
            0x82E86E08 => {
    //   block [0x82E86E08..0x82E86E28)
	// 82E86E08: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E86E0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E86E10: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E86E14: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86E18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E86E1C: 4E800421  bctrl
	ctx.lr = 0x82E86E20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E86E20: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E86E24: 41820114  beq 0x82e86f38
	if ctx.cr[0].eq {
	pc = 0x82E86F38; continue 'dispatch;
	}
            }
            0x82E86E28 => {
    //   block [0x82E86E28..0x82E86E38)
	// 82E86E28: 817C0020  lwz r11, 0x20(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E86E2C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82E86E30: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E86E34: 4198FFA0  blt cr6, 0x82e86dd4
	if ctx.cr[6].lt {
	pc = 0x82E86DD4; continue 'dispatch;
	}
	pc = 0x82E86E38; continue 'dispatch;
            }
            0x82E86E38 => {
    //   block [0x82E86E38..0x82E86E50)
	// 82E86E38: 817A0020  lwz r11, 0x20(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E86E3C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E86E40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E86E44: 40990068  ble cr6, 0x82e86eac
	if !ctx.cr[6].gt {
	pc = 0x82E86EAC; continue 'dispatch;
	}
	// 82E86E48: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82E86E4C: 3B8B2DF8  addi r28, r11, 0x2df8
	ctx.r[28].s64 = ctx.r[11].s64 + 11768;
	pc = 0x82E86E50; continue 'dispatch;
            }
            0x82E86E50 => {
    //   block [0x82E86E50..0x82E86E7C)
	// 82E86E50: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E86E54: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82E86E58: 4BFFD1D1  bl 0x82e84028
	ctx.lr = 0x82E86E5C;
	sub_82E84028(ctx, base);
	// 82E86E5C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82E86E60: 4182001C  beq 0x82e86e7c
	if ctx.cr[0].eq {
	pc = 0x82E86E7C; continue 'dispatch;
	}
	// 82E86E64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86E68: 483351F9  bl 0x831bc060
	ctx.lr = 0x82E86E6C;
	sub_831BC060(ctx, base);
	// 82E86E6C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E86E70: 4BE25CE1  bl 0x82cacb50
	ctx.lr = 0x82E86E74;
	sub_82CACB50(ctx, base);
	// 82E86E74: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E86E78: 41820024  beq 0x82e86e9c
	if ctx.cr[0].eq {
	pc = 0x82E86E9C; continue 'dispatch;
	}
	pc = 0x82E86E7C; continue 'dispatch;
            }
            0x82E86E7C => {
    //   block [0x82E86E7C..0x82E86E9C)
	// 82E86E7C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E86E80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E86E84: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E86E88: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86E8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E86E90: 4E800421  bctrl
	ctx.lr = 0x82E86E94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E86E94: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E86E98: 418200A0  beq 0x82e86f38
	if ctx.cr[0].eq {
	pc = 0x82E86F38; continue 'dispatch;
	}
            }
            0x82E86E9C => {
    //   block [0x82E86E9C..0x82E86EAC)
	// 82E86E9C: 817A0020  lwz r11, 0x20(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E86EA0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82E86EA4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E86EA8: 4198FFA8  blt cr6, 0x82e86e50
	if ctx.cr[6].lt {
	pc = 0x82E86E50; continue 'dispatch;
	}
	pc = 0x82E86EAC; continue 'dispatch;
            }
            0x82E86EAC => {
    //   block [0x82E86EAC..0x82E86ED4)
	// 82E86EAC: 897D0044  lbz r11, 0x44(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E86EB0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E86EB4: 40820020  bne 0x82e86ed4
	if !ctx.cr[0].eq {
	pc = 0x82E86ED4; continue 'dispatch;
	}
	// 82E86EB8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E86EBC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E86EC0: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E86EC4: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E86EC8: 808A0020  lwz r4, 0x20(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E86ECC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E86ED0: 4E800421  bctrl
	ctx.lr = 0x82E86ED4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E86ED4 => {
    //   block [0x82E86ED4..0x82E86EF4)
	// 82E86ED4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E86ED8: C1BD003C  lfs f13, 0x3c(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E86EDC: C00B0098  lfs f0, 0x98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(152 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E86EE0: C18B0094  lfs f12, 0x94(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E86EE4: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E86EE8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E86EEC: 40990008  ble cr6, 0x82e86ef4
	if !ctx.cr[6].gt {
	pc = 0x82E86EF4; continue 'dispatch;
	}
	// 82E86EF0: D01D003C  stfs f0, 0x3c(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(60 as u32), tmp.u32 ) };
	pc = 0x82E86EF4; continue 'dispatch;
            }
            0x82E86EF4 => {
    //   block [0x82E86EF4..0x82E86F04)
	// 82E86EF4: C1BD0040  lfs f13, 0x40(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E86EF8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E86EFC: 40990008  ble cr6, 0x82e86f04
	if !ctx.cr[6].gt {
	pc = 0x82E86F04; continue 'dispatch;
	}
	// 82E86F00: D01D0040  stfs f0, 0x40(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(64 as u32), tmp.u32 ) };
	pc = 0x82E86F04; continue 'dispatch;
            }
            0x82E86F04 => {
    //   block [0x82E86F04..0x82E86F2C)
	// 82E86F04: 4B3D9AB5  bl 0x822609b8
	ctx.lr = 0x82E86F08;
	sub_822609B8(ctx, base);
	// 82E86F08: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82E86F0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E86F10: 4BFFA329  bl 0x82e81238
	ctx.lr = 0x82E86F14;
	sub_82E81238(ctx, base);
	// 82E86F14: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E86F18: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 82E86F1C: 419A0010  beq cr6, 0x82e86f2c
	if ctx.cr[6].eq {
	pc = 0x82E86F2C; continue 'dispatch;
	}
	// 82E86F20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86F24: 4BFFA40D  bl 0x82e81330
	ctx.lr = 0x82E86F28;
	sub_82E81330(ctx, base);
	// 82E86F28: D03D0048  stfs f1, 0x48(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(72 as u32), tmp.u32 ) };
	pc = 0x82E86F2C; continue 'dispatch;
            }
            0x82E86F2C => {
    //   block [0x82E86F2C..0x82E86F30)
	// 82E86F2C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82E86F30; continue 'dispatch;
            }
            0x82E86F30 => {
    //   block [0x82E86F30..0x82E86F38)
	// 82E86F30: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E86F34: 4BE22518  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82E86F38 => {
    //   block [0x82E86F38..0x82E86F40)
	// 82E86F38: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E86F3C: 4BFFFFF4  b 0x82e86f30
	pc = 0x82E86F30; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E86F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E86F40 size=68
    let mut pc: u32 = 0x82E86F40;
    'dispatch: loop {
        match pc {
            0x82E86F40 => {
    //   block [0x82E86F40..0x82E86F84)
	// 82E86F40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E86F44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E86F48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E86F4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E86F50: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82E86F54: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82E86F58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E86F5C: 4BFFFD15  bl 0x82e86c70
	ctx.lr = 0x82E86F60;
	sub_82E86C70(ctx, base);
	// 82E86F60: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E86F64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86F68: 396BB230  addi r11, r11, -0x4dd0
	ctx.r[11].s64 = ctx.r[11].s64 + -19920;
	// 82E86F6C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E86F70: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E86F74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E86F78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E86F7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E86F80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E86F88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E86F88 size=968
    let mut pc: u32 = 0x82E86F88;
    'dispatch: loop {
        match pc {
            0x82E86F88 => {
    //   block [0x82E86F88..0x82E86FAC)
	// 82E86F88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E86F8C: 4BE22481  bl 0x82ca940c
	ctx.lr = 0x82E86F90;
	sub_82CA93D0(ctx, base);
	// 82E86F90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E86F94: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E86F98: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E86F9C: 4B79269D  bl 0x82619638
	ctx.lr = 0x82E86FA0;
	sub_82619638(ctx, base);
	// 82E86FA0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E86FA4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E86FA8: 409A000C  bne cr6, 0x82e86fb4
	if !ctx.cr[6].eq {
	pc = 0x82E86FB4; continue 'dispatch;
	}
	pc = 0x82E86FAC; continue 'dispatch;
            }
            0x82E86FAC => {
    //   block [0x82E86FAC..0x82E86FB4)
	// 82E86FAC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E86FB0: 48000398  b 0x82e87348
	pc = 0x82E87348; continue 'dispatch;
            }
            0x82E86FB4 => {
    //   block [0x82E86FB4..0x82E87008)
	// 82E86FB4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E86FB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86FBC: 3BCB95C4  addi r30, r11, -0x6a3c
	ctx.r[30].s64 = ctx.r[11].s64 + -27196;
	// 82E86FC0: 483350A1  bl 0x831bc060
	ctx.lr = 0x82E86FC4;
	sub_831BC060(ctx, base);
	// 82E86FC4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E86FC8: 4BE25B89  bl 0x82cacb50
	ctx.lr = 0x82E86FCC;
	sub_82CACB50(ctx, base);
	// 82E86FCC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E86FD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E86FD4: 40820034  bne 0x82e87008
	if !ctx.cr[0].eq {
	pc = 0x82E87008; continue 'dispatch;
	}
	// 82E86FD8: 4BA86D31  bl 0x8290dd08
	ctx.lr = 0x82E86FDC;
	sub_8290DD08(ctx, base);
	// 82E86FDC: 4BE24BD5  bl 0x82cabbb0
	ctx.lr = 0x82E86FE0;
	sub_82CABBB0(ctx, base);
	// 82E86FE0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E86FE4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E86FE8: D01D0008  stfs f0, 8(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E86FEC: C1AB0C18  lfs f13, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E86FF0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E86FF4: 4199FFB8  bgt cr6, 0x82e86fac
	if ctx.cr[6].gt {
	pc = 0x82E86FAC; continue 'dispatch;
	}
	// 82E86FF8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E86FFC: C00B0A7C  lfs f0, 0xa7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2684 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E87000: D01D0008  stfs f0, 8(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E87004: 4BFFFFA8  b 0x82e86fac
	pc = 0x82E86FAC; continue 'dispatch;
            }
            0x82E87008 => {
    //   block [0x82E87008..0x82E87060)
	// 82E87008: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8700C: 3BCB95B8  addi r30, r11, -0x6a48
	ctx.r[30].s64 = ctx.r[11].s64 + -27208;
	// 82E87010: 48335051  bl 0x831bc060
	ctx.lr = 0x82E87014;
	sub_831BC060(ctx, base);
	// 82E87014: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E87018: 4BE25B39  bl 0x82cacb50
	ctx.lr = 0x82E8701C;
	sub_82CACB50(ctx, base);
	// 82E8701C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E87020: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E87024: 40820068  bne 0x82e8708c
	if !ctx.cr[0].eq {
	pc = 0x82E8708C; continue 'dispatch;
	}
	// 82E87028: 4BA86CE1  bl 0x8290dd08
	ctx.lr = 0x82E8702C;
	sub_8290DD08(ctx, base);
	// 82E8702C: 4BE24B85  bl 0x82cabbb0
	ctx.lr = 0x82E87030;
	sub_82CABBB0(ctx, base);
	// 82E87030: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E87034: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E87038: D01D0004  stfs f0, 4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E8703C: C1AB0C18  lfs f13, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E87040: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E87044: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E87048: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E8704C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E87050: 4199001C  bgt cr6, 0x82e8706c
	if ctx.cr[6].gt {
	pc = 0x82E8706C; continue 'dispatch;
	}
	// 82E87054: 4182000C  beq 0x82e87060
	if ctx.cr[0].eq {
	pc = 0x82E87060; continue 'dispatch;
	}
	// 82E87058: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8705C: 48000028  b 0x82e87084
	pc = 0x82E87084; continue 'dispatch;
            }
            0x82E87060 => {
    //   block [0x82E87060..0x82E8706C)
	// 82E87060: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E87064: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E87068: 4800001C  b 0x82e87084
	pc = 0x82E87084; continue 'dispatch;
            }
            0x82E8706C => {
    //   block [0x82E8706C..0x82E87078)
	// 82E8706C: 4182000C  beq 0x82e87078
	if ctx.cr[0].eq {
	pc = 0x82E87078; continue 'dispatch;
	}
	// 82E87070: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E87074: 4800000C  b 0x82e87080
	pc = 0x82E87080; continue 'dispatch;
            }
            0x82E87078 => {
    //   block [0x82E87078..0x82E87080)
	// 82E87078: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8707C: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82E87080; continue 'dispatch;
            }
            0x82E87080 => {
    //   block [0x82E87080..0x82E87084)
	// 82E87080: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	pc = 0x82E87084; continue 'dispatch;
            }
            0x82E87084 => {
    //   block [0x82E87084..0x82E8708C)
	// 82E87084: D01D0004  stfs f0, 4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E87088: 4BFFFF24  b 0x82e86fac
	pc = 0x82E86FAC; continue 'dispatch;
            }
            0x82E8708C => {
    //   block [0x82E8708C..0x82E87130)
	// 82E8708C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E87090: 3BCB95B0  addi r30, r11, -0x6a50
	ctx.r[30].s64 = ctx.r[11].s64 + -27216;
	// 82E87094: 48334FCD  bl 0x831bc060
	ctx.lr = 0x82E87098;
	sub_831BC060(ctx, base);
	// 82E87098: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8709C: 4BE25AB5  bl 0x82cacb50
	ctx.lr = 0x82E870A0;
	sub_82CACB50(ctx, base);
	// 82E870A0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E870A4: 4182FF08  beq 0x82e86fac
	if ctx.cr[0].eq {
	pc = 0x82E86FAC; continue 'dispatch;
	}
	// 82E870A8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E870AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E870B0: 3BCB95A4  addi r30, r11, -0x6a5c
	ctx.r[30].s64 = ctx.r[11].s64 + -27228;
	// 82E870B4: 48334FAD  bl 0x831bc060
	ctx.lr = 0x82E870B8;
	sub_831BC060(ctx, base);
	// 82E870B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E870BC: 4BE25A95  bl 0x82cacb50
	ctx.lr = 0x82E870C0;
	sub_82CACB50(ctx, base);
	// 82E870C0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E870C4: 4182FEE8  beq 0x82e86fac
	if ctx.cr[0].eq {
	pc = 0x82E86FAC; continue 'dispatch;
	}
	// 82E870C8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E870CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E870D0: 3BCB9598  addi r30, r11, -0x6a68
	ctx.r[30].s64 = ctx.r[11].s64 + -27240;
	// 82E870D4: 48334F8D  bl 0x831bc060
	ctx.lr = 0x82E870D8;
	sub_831BC060(ctx, base);
	// 82E870D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E870DC: 4BE25A75  bl 0x82cacb50
	ctx.lr = 0x82E870E0;
	sub_82CACB50(ctx, base);
	// 82E870E0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E870E4: 4182FEC8  beq 0x82e86fac
	if ctx.cr[0].eq {
	pc = 0x82E86FAC; continue 'dispatch;
	}
	// 82E870E8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E870EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E870F0: 3BCB9588  addi r30, r11, -0x6a78
	ctx.r[30].s64 = ctx.r[11].s64 + -27256;
	// 82E870F4: 48334F6D  bl 0x831bc060
	ctx.lr = 0x82E870F8;
	sub_831BC060(ctx, base);
	// 82E870F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E870FC: 4BE25A55  bl 0x82cacb50
	ctx.lr = 0x82E87100;
	sub_82CACB50(ctx, base);
	// 82E87100: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E87104: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E87108: 40820044  bne 0x82e8714c
	if !ctx.cr[0].eq {
	pc = 0x82E8714C; continue 'dispatch;
	}
	// 82E8710C: 4BA86BFD  bl 0x8290dd08
	ctx.lr = 0x82E87110;
	sub_8290DD08(ctx, base);
	// 82E87110: 4BE24AA1  bl 0x82cabbb0
	ctx.lr = 0x82E87114;
	sub_82CABBB0(ctx, base);
	// 82E87114: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E87118: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E8711C: C1BD0094  lfs f13, 0x94(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E87120: C00BBE14  lfs f0, -0x41ec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16876 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E87124: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E87128: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8712C: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82E87130; continue 'dispatch;
            }
            0x82E87130 => {
    //   block [0x82E87130..0x82E8713C)
	// 82E87130: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82E87134: 40990008  ble cr6, 0x82e8713c
	if !ctx.cr[6].gt {
	pc = 0x82E8713C; continue 'dispatch;
	}
	// 82E87138: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	pc = 0x82E8713C; continue 'dispatch;
            }
            0x82E8713C => {
    //   block [0x82E8713C..0x82E8714C)
	// 82E8713C: FF0D6800  fcmpu cr6, f13, f13
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[13].f64);
	// 82E87140: 409AFFF0  bne cr6, 0x82e87130
	if !ctx.cr[6].eq {
	pc = 0x82E87130; continue 'dispatch;
	}
	// 82E87144: D1BD0094  stfs f13, 0x94(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82E87148: 4BFFFE64  b 0x82e86fac
	pc = 0x82E86FAC; continue 'dispatch;
            }
            0x82E8714C => {
    //   block [0x82E8714C..0x82E87190)
	// 82E8714C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E87150: 3BCB9574  addi r30, r11, -0x6a8c
	ctx.r[30].s64 = ctx.r[11].s64 + -27276;
	// 82E87154: 48334F0D  bl 0x831bc060
	ctx.lr = 0x82E87158;
	sub_831BC060(ctx, base);
	// 82E87158: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8715C: 4BE259F5  bl 0x82cacb50
	ctx.lr = 0x82E87160;
	sub_82CACB50(ctx, base);
	// 82E87160: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E87164: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E87168: 40820044  bne 0x82e871ac
	if !ctx.cr[0].eq {
	pc = 0x82E871AC; continue 'dispatch;
	}
	// 82E8716C: 4BA86B9D  bl 0x8290dd08
	ctx.lr = 0x82E87170;
	sub_8290DD08(ctx, base);
	// 82E87170: 4BE24A41  bl 0x82cabbb0
	ctx.lr = 0x82E87174;
	sub_82CABBB0(ctx, base);
	// 82E87174: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E87178: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E8717C: C1BD0098  lfs f13, 0x98(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(152 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E87180: C00BBE14  lfs f0, -0x41ec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16876 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E87184: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E87188: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8718C: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82E87190; continue 'dispatch;
            }
            0x82E87190 => {
    //   block [0x82E87190..0x82E8719C)
	// 82E87190: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82E87194: 40990008  ble cr6, 0x82e8719c
	if !ctx.cr[6].gt {
	pc = 0x82E8719C; continue 'dispatch;
	}
	// 82E87198: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	pc = 0x82E8719C; continue 'dispatch;
            }
            0x82E8719C => {
    //   block [0x82E8719C..0x82E871AC)
	// 82E8719C: FF0D6800  fcmpu cr6, f13, f13
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[13].f64);
	// 82E871A0: 409AFFF0  bne cr6, 0x82e87190
	if !ctx.cr[6].eq {
	pc = 0x82E87190; continue 'dispatch;
	}
	// 82E871A4: D1BD0098  stfs f13, 0x98(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82E871A8: 4BFFFE04  b 0x82e86fac
	pc = 0x82E86FAC; continue 'dispatch;
            }
            0x82E871AC => {
    //   block [0x82E871AC..0x82E871E8)
	// 82E871AC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E871B0: 3BCB9564  addi r30, r11, -0x6a9c
	ctx.r[30].s64 = ctx.r[11].s64 + -27292;
	// 82E871B4: 48334EAD  bl 0x831bc060
	ctx.lr = 0x82E871B8;
	sub_831BC060(ctx, base);
	// 82E871B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E871BC: 4BE25995  bl 0x82cacb50
	ctx.lr = 0x82E871C0;
	sub_82CACB50(ctx, base);
	// 82E871C0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E871C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E871C8: 4082002C  bne 0x82e871f4
	if !ctx.cr[0].eq {
	pc = 0x82E871F4; continue 'dispatch;
	}
	// 82E871CC: 4BA86B3D  bl 0x8290dd08
	ctx.lr = 0x82E871D0;
	sub_8290DD08(ctx, base);
	// 82E871D0: 4BE231F1  bl 0x82caa3c0
	ctx.lr = 0x82E871D4;
	sub_82CAA3C0(ctx, base);
	// 82E871D4: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82E871D8: 907D00AC  stw r3, 0xac(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(172 as u32), ctx.r[3].u32 ) };
	// 82E871DC: 4198000C  blt cr6, 0x82e871e8
	if ctx.cr[6].lt {
	pc = 0x82E871E8; continue 'dispatch;
	}
	// 82E871E0: 2B030010  cmplwi cr6, r3, 0x10
	ctx.cr[6].compare_u32(ctx.r[3].u32, 16 as u32, &mut ctx.xer);
	// 82E871E4: 4198FDC8  blt cr6, 0x82e86fac
	if ctx.cr[6].lt {
	pc = 0x82E86FAC; continue 'dispatch;
	}
	pc = 0x82E871E8; continue 'dispatch;
            }
            0x82E871E8 => {
    //   block [0x82E871E8..0x82E871F4)
	// 82E871E8: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82E871EC: 917D00AC  stw r11, 0xac(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 82E871F0: 4BFFFDBC  b 0x82e86fac
	pc = 0x82E86FAC; continue 'dispatch;
            }
            0x82E871F4 => {
    //   block [0x82E871F4..0x82E872D0)
	// 82E871F4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E871F8: 3BCB9554  addi r30, r11, -0x6aac
	ctx.r[30].s64 = ctx.r[11].s64 + -27308;
	// 82E871FC: 48334E65  bl 0x831bc060
	ctx.lr = 0x82E87200;
	sub_831BC060(ctx, base);
	// 82E87200: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E87204: 4BE2594D  bl 0x82cacb50
	ctx.lr = 0x82E87208;
	sub_82CACB50(ctx, base);
	// 82E87208: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8720C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E87210: 408200D4  bne 0x82e872e4
	if !ctx.cr[0].eq {
	pc = 0x82E872E4; continue 'dispatch;
	}
	// 82E87214: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82E87218: 3BCB1694  addi r30, r11, 0x1694
	ctx.r[30].s64 = ctx.r[11].s64 + 5780;
	// 82E8721C: 4BA86AED  bl 0x8290dd08
	ctx.lr = 0x82E87220;
	sub_8290DD08(ctx, base);
	// 82E87220: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E87224: 4BE2592D  bl 0x82cacb50
	ctx.lr = 0x82E87228;
	sub_82CACB50(ctx, base);
	// 82E87228: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8722C: 418200AC  beq 0x82e872d8
	if ctx.cr[0].eq {
	pc = 0x82E872D8; continue 'dispatch;
	}
	// 82E87230: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E87234: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E87238: 3BCB0F40  addi r30, r11, 0xf40
	ctx.r[30].s64 = ctx.r[11].s64 + 3904;
	// 82E8723C: 4BA86ACD  bl 0x8290dd08
	ctx.lr = 0x82E87240;
	sub_8290DD08(ctx, base);
	// 82E87240: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E87244: 4BE2590D  bl 0x82cacb50
	ctx.lr = 0x82E87248;
	sub_82CACB50(ctx, base);
	// 82E87248: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8724C: 4182008C  beq 0x82e872d8
	if ctx.cr[0].eq {
	pc = 0x82E872D8; continue 'dispatch;
	}
	// 82E87250: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82E87254: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E87258: 3BCBD56C  addi r30, r11, -0x2a94
	ctx.r[30].s64 = ctx.r[11].s64 + -10900;
	// 82E8725C: 4BA86AAD  bl 0x8290dd08
	ctx.lr = 0x82E87260;
	sub_8290DD08(ctx, base);
	// 82E87260: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E87264: 4BE258ED  bl 0x82cacb50
	ctx.lr = 0x82E87268;
	sub_82CACB50(ctx, base);
	// 82E87268: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8726C: 4182006C  beq 0x82e872d8
	if ctx.cr[0].eq {
	pc = 0x82E872D8; continue 'dispatch;
	}
	// 82E87270: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82E87274: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E87278: 3BCB1698  addi r30, r11, 0x1698
	ctx.r[30].s64 = ctx.r[11].s64 + 5784;
	// 82E8727C: 4BA86A8D  bl 0x8290dd08
	ctx.lr = 0x82E87280;
	sub_8290DD08(ctx, base);
	// 82E87280: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E87284: 4BE258CD  bl 0x82cacb50
	ctx.lr = 0x82E87288;
	sub_82CACB50(ctx, base);
	// 82E87288: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8728C: 41820044  beq 0x82e872d0
	if ctx.cr[0].eq {
	pc = 0x82E872D0; continue 'dispatch;
	}
	// 82E87290: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82E87294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E87298: 3BCB1700  addi r30, r11, 0x1700
	ctx.r[30].s64 = ctx.r[11].s64 + 5888;
	// 82E8729C: 4BA86A6D  bl 0x8290dd08
	ctx.lr = 0x82E872A0;
	sub_8290DD08(ctx, base);
	// 82E872A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E872A4: 4BE258AD  bl 0x82cacb50
	ctx.lr = 0x82E872A8;
	sub_82CACB50(ctx, base);
	// 82E872A8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E872AC: 41820024  beq 0x82e872d0
	if ctx.cr[0].eq {
	pc = 0x82E872D0; continue 'dispatch;
	}
	// 82E872B0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82E872B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E872B8: 3BCB7088  addi r30, r11, 0x7088
	ctx.r[30].s64 = ctx.r[11].s64 + 28808;
	// 82E872BC: 4BA86A4D  bl 0x8290dd08
	ctx.lr = 0x82E872C0;
	sub_8290DD08(ctx, base);
	// 82E872C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E872C4: 4BE2588D  bl 0x82cacb50
	ctx.lr = 0x82E872C8;
	sub_82CACB50(ctx, base);
	// 82E872C8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E872CC: 40820078  bne 0x82e87344
	if !ctx.cr[0].eq {
	pc = 0x82E87344; continue 'dispatch;
	}
	pc = 0x82E872D0; continue 'dispatch;
            }
            0x82E872D0 => {
    //   block [0x82E872D0..0x82E872D8)
	// 82E872D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E872D4: 48000008  b 0x82e872dc
	pc = 0x82E872DC; continue 'dispatch;
            }
            0x82E872D8 => {
    //   block [0x82E872D8..0x82E872DC)
	// 82E872D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82E872DC; continue 'dispatch;
            }
            0x82E872DC => {
    //   block [0x82E872DC..0x82E872E4)
	// 82E872DC: 997D0088  stb r11, 0x88(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(136 as u32), ctx.r[11].u8 ) };
	// 82E872E0: 4BFFFCCC  b 0x82e86fac
	pc = 0x82E86FAC; continue 'dispatch;
            }
            0x82E872E4 => {
    //   block [0x82E872E4..0x82E87334)
	// 82E872E4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E872E8: 3BCB953C  addi r30, r11, -0x6ac4
	ctx.r[30].s64 = ctx.r[11].s64 + -27332;
	// 82E872EC: 48334D75  bl 0x831bc060
	ctx.lr = 0x82E872F0;
	sub_831BC060(ctx, base);
	// 82E872F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E872F4: 4BE2585D  bl 0x82cacb50
	ctx.lr = 0x82E872F8;
	sub_82CACB50(ctx, base);
	// 82E872F8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E872FC: 40820048  bne 0x82e87344
	if !ctx.cr[0].eq {
	pc = 0x82E87344; continue 'dispatch;
	}
	// 82E87300: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E87304: 4BA86A05  bl 0x8290dd08
	ctx.lr = 0x82E87308;
	sub_8290DD08(ctx, base);
	// 82E87308: 4BE248A9  bl 0x82cabbb0
	ctx.lr = 0x82E8730C;
	sub_82CABBB0(ctx, base);
	// 82E8730C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E87310: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E87314: D01D00B0  stfs f0, 0xb0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82E87318: C1AB0C18  lfs f13, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8731C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E87320: 40990014  ble cr6, 0x82e87334
	if !ctx.cr[6].gt {
	pc = 0x82E87334; continue 'dispatch;
	}
	// 82E87324: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E87328: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8732C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E87330: 4099FC7C  ble cr6, 0x82e86fac
	if !ctx.cr[6].gt {
	pc = 0x82E86FAC; continue 'dispatch;
	}
	pc = 0x82E87334; continue 'dispatch;
            }
            0x82E87334 => {
    //   block [0x82E87334..0x82E87344)
	// 82E87334: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E87338: C00B0B6C  lfs f0, 0xb6c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2924 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8733C: D01D00B0  stfs f0, 0xb0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82E87340: 4BFFFC6C  b 0x82e86fac
	pc = 0x82E86FAC; continue 'dispatch;
            }
            0x82E87344 => {
    //   block [0x82E87344..0x82E87348)
	// 82E87344: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E87348; continue 'dispatch;
            }
            0x82E87348 => {
    //   block [0x82E87348..0x82E87350)
	// 82E87348: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8734C: 4BE22110  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E87350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E87350 size=32
    let mut pc: u32 = 0x82E87350;
    'dispatch: loop {
        match pc {
            0x82E87350 => {
    //   block [0x82E87350..0x82E87370)
	// 82E87350: 816300A0  lwz r11, 0xa0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(160 as u32) ) } as u64;
	// 82E87354: 39440001  addi r10, r4, 1
	ctx.r[10].s64 = ctx.r[4].s64 + 1;
	// 82E87358: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8735C: 40980014  bge cr6, 0x82e87370
	if !ctx.cr[6].lt {
		sub_82E87370(ctx, base);
		return;
	}
	// 82E87360: 8163009C  lwz r11, 0x9c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(156 as u32) ) } as u64;
	// 82E87364: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E87368: 7C2B542E  lfsx f1, r11, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E8736C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E87370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E87370 size=12
    let mut pc: u32 = 0x82E87370;
    'dispatch: loop {
        match pc {
            0x82E87370 => {
    //   block [0x82E87370..0x82E8737C)
	// 82E87370: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E87374: C02B0BEC  lfs f1, 0xbec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E87378: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E87380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E87380 size=24
    let mut pc: u32 = 0x82E87380;
    'dispatch: loop {
        match pc {
            0x82E87380 => {
    //   block [0x82E87380..0x82E87398)
	// 82E87380: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E87384: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E87388: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82E8738C: 4098000C  bge cr6, 0x82e87398
	if !ctx.cr[6].lt {
		sub_82E87398(ctx, base);
		return;
	}
	// 82E87390: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82E87394: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E87398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E87398 size=12
    let mut pc: u32 = 0x82E87398;
    'dispatch: loop {
        match pc {
            0x82E87398 => {
    //   block [0x82E87398..0x82E873A4)
	// 82E87398: 4099000C  ble cr6, 0x82e873a4
	if !ctx.cr[6].gt {
		sub_82E873A4(ctx, base);
		return;
	}
	// 82E8739C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E873A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E873A4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E873A4 size=32
    let mut pc: u32 = 0x82E873A4;
    'dispatch: loop {
        match pc {
            0x82E873A4 => {
    //   block [0x82E873A4..0x82E873C4)
	// 82E873A4: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E873A8: 81440008  lwz r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E873AC: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82E873B0: 4198FFE0  blt cr6, 0x82e87390
	if ctx.cr[6].lt {
		sub_82E87380(ctx, base);
		return;
	}
	// 82E873B4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E873B8: 4D990020  bgtlr cr6
	if ctx.cr[6].gt { return; }
	// 82E873BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E873C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E873C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E873C8 size=108
    let mut pc: u32 = 0x82E873C8;
    'dispatch: loop {
        match pc {
            0x82E873C8 => {
    //   block [0x82E873C8..0x82E873FC)
	// 82E873C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E873CC: 4BE2203D  bl 0x82ca9408
	ctx.lr = 0x82E873D0;
	sub_82CA93D0(ctx, base);
	// 82E873D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E873D4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E873D8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E873DC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82E873E0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E873E4: 815F007C  lwz r10, 0x7c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82E873E8: C00B0C1C  lfs f0, 0xc1c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E873EC: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82E873F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E873F4: 40990038  ble cr6, 0x82e8742c
	if !ctx.cr[6].gt {
	pc = 0x82E8742C; continue 'dispatch;
	}
	// 82E873F8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82E873FC; continue 'dispatch;
            }
            0x82E873FC => {
    //   block [0x82E873FC..0x82E8742C)
	// 82E873FC: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82E87400: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E87404: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82E87408: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8740C: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E87410: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E87414: 4E800421  bctrl
	ctx.lr = 0x82E87418;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E87418: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82E8741C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82E87420: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82E87424: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E87428: 4198FFD4  blt cr6, 0x82e873fc
	if ctx.cr[6].lt {
	pc = 0x82E873FC; continue 'dispatch;
	}
            }
            0x82E8742C => {
    //   block [0x82E8742C..0x82E87434)
	// 82E8742C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E87430: 4BE22028  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E87438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E87438 size=168
    let mut pc: u32 = 0x82E87438;
    'dispatch: loop {
        match pc {
            0x82E87438 => {
    //   block [0x82E87438..0x82E874A8)
	// 82E87438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8743C: 4BE21FD1  bl 0x82ca940c
	ctx.lr = 0x82E87440;
	sub_82CA93D0(ctx, base);
	// 82E87440: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82E87444: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E87448: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8744C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E87450: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82E87454: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E87458: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E8745C: D3FF00B4  stfs f31, 0xb4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82E87460: 915F00A8  stw r10, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[10].u32 ) };
	// 82E87464: 93DF0080  stw r30, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 82E87468: 93DF0090  stw r30, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[30].u32 ) };
	// 82E8746C: 4B3D954D  bl 0x822609b8
	ctx.lr = 0x82E87470;
	sub_822609B8(ctx, base);
	// 82E87470: C003004C  lfs f0, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E87474: D01F00C0  stfs f0, 0xc0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82E87478: 4B3D9541  bl 0x822609b8
	ctx.lr = 0x82E8747C;
	sub_822609B8(ctx, base);
	// 82E8747C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E87480: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82E87484: C003004C  lfs f0, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E87488: D01F00B8  stfs f0, 0xb8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82E8748C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E87490: D3FF00C4  stfs f31, 0xc4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82E87494: D3FF00BC  stfs f31, 0xbc(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82E87498: D3FF0010  stfs f31, 0x10(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82E8749C: 995F00C8  stb r10, 0xc8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[10].u8 ) };
	// 82E874A0: 40990034  ble cr6, 0x82e874d4
	if !ctx.cr[6].gt {
	pc = 0x82E874D4; continue 'dispatch;
	}
	// 82E874A4: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	pc = 0x82E874A8; continue 'dispatch;
            }
            0x82E874A8 => {
    //   block [0x82E874A8..0x82E874D4)
	// 82E874A8: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82E874AC: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82E874B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E874B4: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E874B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E874BC: 4E800421  bctrl
	ctx.lr = 0x82E874C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E874C0: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82E874C4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82E874C8: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82E874CC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E874D0: 4198FFD8  blt cr6, 0x82e874a8
	if ctx.cr[6].lt {
	pc = 0x82E874A8; continue 'dispatch;
	}
            }
            0x82E874D4 => {
    //   block [0x82E874D4..0x82E874E0)
	// 82E874D4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E874D8: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82E874DC: 4BE21F80  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E874E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E874E0 size=108
    let mut pc: u32 = 0x82E874E0;
    'dispatch: loop {
        match pc {
            0x82E874E0 => {
    //   block [0x82E874E0..0x82E87508)
	// 82E874E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E874E4: 4BE21F21  bl 0x82ca9404
	ctx.lr = 0x82E874E8;
	sub_82CA93D0(ctx, base);
	// 82E874E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E874EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E874F0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82E874F4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82E874F8: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E874FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E87500: 40990038  ble cr6, 0x82e87538
	if !ctx.cr[6].gt {
	pc = 0x82E87538; continue 'dispatch;
	}
	// 82E87504: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82E87508; continue 'dispatch;
            }
            0x82E87508 => {
    //   block [0x82E87508..0x82E87538)
	// 82E87508: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E8750C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E87510: 7FBE582E  lwzx r29, r30, r11
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82E87514: 807D001C  lwz r3, 0x1c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E87518: 4BE25639  bl 0x82cacb50
	ctx.lr = 0x82E8751C;
	sub_82CACB50(ctx, base);
	// 82E8751C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E87520: 41820024  beq 0x82e87544
	if ctx.cr[0].eq {
	pc = 0x82E87544; continue 'dispatch;
	}
	// 82E87524: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E87528: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82E8752C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82E87530: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E87534: 4198FFD4  blt cr6, 0x82e87508
	if ctx.cr[6].lt {
	pc = 0x82E87508; continue 'dispatch;
	}
	pc = 0x82E87538; continue 'dispatch;
            }
            0x82E87538 => {
    //   block [0x82E87538..0x82E8753C)
	// 82E87538: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E8753C; continue 'dispatch;
            }
            0x82E8753C => {
    //   block [0x82E8753C..0x82E87544)
	// 82E8753C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E87540: 4BE21F14  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82E87544 => {
    //   block [0x82E87544..0x82E8754C)
	// 82E87544: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E87548: 4BFFFFF4  b 0x82e8753c
	pc = 0x82E8753C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E87550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E87550 size=276
    let mut pc: u32 = 0x82E87550;
    'dispatch: loop {
        match pc {
            0x82E87550 => {
    //   block [0x82E87550..0x82E875A0)
	// 82E87550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E87554: 4BE21EB5  bl 0x82ca9408
	ctx.lr = 0x82E87558;
	sub_82CA93D0(ctx, base);
	// 82E87558: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82E8755C: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82E87560: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E87564: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E87568: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8756C: 3BCBDAC0  addi r30, r11, -0x2540
	ctx.r[30].s64 = ctx.r[11].s64 + -9536;
	// 82E87570: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82E87574: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E87578: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8757C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E87580: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E87584: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E87588: 419A0018  beq cr6, 0x82e875a0
	if ctx.cr[6].eq {
	pc = 0x82E875A0; continue 'dispatch;
	}
	// 82E8758C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E87590: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E87594: 4E800421  bctrl
	ctx.lr = 0x82E87598;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E87598: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82E8759C: 48000008  b 0x82e875a4
	pc = 0x82E875A4; continue 'dispatch;
            }
            0x82E875A0 => {
    //   block [0x82E875A0..0x82E875A4)
	// 82E875A0: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	pc = 0x82E875A4; continue 'dispatch;
            }
            0x82E875A4 => {
    //   block [0x82E875A4..0x82E875E4)
	// 82E875A4: 817F0090  lwz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82E875A8: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82E875AC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E875B0: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E875B4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E875B8: 4182002C  beq 0x82e875e4
	if ctx.cr[0].eq {
	pc = 0x82E875E4; continue 'dispatch;
	}
	// 82E875BC: 89630044  lbz r11, 0x44(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E875C0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E875C4: 40820020  bne 0x82e875e4
	if !ctx.cr[0].eq {
	pc = 0x82E875E4; continue 'dispatch;
	}
	// 82E875C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E875CC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E875D0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E875D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E875D8: 4E800421  bctrl
	ctx.lr = 0x82E875DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E875DC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E875E0: 4182004C  beq 0x82e8762c
	if ctx.cr[0].eq {
	pc = 0x82E8762C; continue 'dispatch;
	}
            }
            0x82E875E4 => {
    //   block [0x82E875E4..0x82E87610)
	// 82E875E4: 817F0090  lwz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82E875E8: 815F007C  lwz r10, 0x7c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82E875EC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E875F0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E875F4: 917F0090  stw r11, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82E875F8: 409A0018  bne cr6, 0x82e87610
	if !ctx.cr[6].eq {
	pc = 0x82E87610; continue 'dispatch;
	}
	// 82E875FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E87600: 917F0090  stw r11, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82E87604: 4B3D93B5  bl 0x822609b8
	ctx.lr = 0x82E87608;
	sub_822609B8(ctx, base);
	// 82E87608: C003004C  lfs f0, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8760C: D01F00C0  stfs f0, 0xc0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	pc = 0x82E87610; continue 'dispatch;
            }
            0x82E87610 => {
    //   block [0x82E87610..0x82E8762C)
	// 82E87610: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82E87614: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82E87618: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8761C: 40980010  bge cr6, 0x82e8762c
	if !ctx.cr[6].lt {
	pc = 0x82E8762C; continue 'dispatch;
	}
	// 82E87620: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E87624: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E87628: 409AFF7C  bne cr6, 0x82e875a4
	if !ctx.cr[6].eq {
	pc = 0x82E875A4; continue 'dispatch;
	}
	pc = 0x82E8762C; continue 'dispatch;
            }
            0x82E8762C => {
    //   block [0x82E8762C..0x82E87648)
	// 82E8762C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E87630: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E87634: 419A0014  beq cr6, 0x82e87648
	if ctx.cr[6].eq {
	pc = 0x82E87648; continue 'dispatch;
	}
	// 82E87638: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E8763C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E87640: 4E800421  bctrl
	ctx.lr = 0x82E87644;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E87644: 48000008  b 0x82e8764c
	pc = 0x82E8764C; continue 'dispatch;
            }
            0x82E87648 => {
    //   block [0x82E87648..0x82E8764C)
	// 82E87648: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	pc = 0x82E8764C; continue 'dispatch;
            }
            0x82E8764C => {
    //   block [0x82E8764C..0x82E87664)
	// 82E8764C: EC01F028  fsubs f0, f1, f30
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[30].f64) as f32) as f64);
	// 82E87650: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82E87654: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E87658: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82E8765C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82E87660: 4BE21DF8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E87668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E87668 size=104
    let mut pc: u32 = 0x82E87668;
    'dispatch: loop {
        match pc {
            0x82E87668 => {
    //   block [0x82E87668..0x82E87690)
	// 82E87668: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8766C: 4BE21DA1  bl 0x82ca940c
	ctx.lr = 0x82E87670;
	sub_82CA93D0(ctx, base);
	// 82E87670: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E87674: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E87678: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E8767C: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82E87680: 93BF0084  stw r29, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[29].u32 ) };
	// 82E87684: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E87688: 40990040  ble cr6, 0x82e876c8
	if !ctx.cr[6].gt {
	pc = 0x82E876C8; continue 'dispatch;
	}
	// 82E8768C: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	pc = 0x82E87690; continue 'dispatch;
            }
            0x82E87690 => {
    //   block [0x82E87690..0x82E876C8)
	// 82E87690: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82E87694: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82E87698: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8769C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E876A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E876A4: 4E800421  bctrl
	ctx.lr = 0x82E876A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E876A8: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82E876AC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82E876B0: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 82E876B4: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82E876B8: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82E876BC: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82E876C0: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E876C4: 4198FFCC  blt cr6, 0x82e87690
	if ctx.cr[6].lt {
	pc = 0x82E87690; continue 'dispatch;
	}
            }
            0x82E876C8 => {
    //   block [0x82E876C8..0x82E876D0)
	// 82E876C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E876CC: 4BE21D90  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E876D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E876D0 size=156
    let mut pc: u32 = 0x82E876D0;
    'dispatch: loop {
        match pc {
            0x82E876D0 => {
    //   block [0x82E876D0..0x82E876F8)
	// 82E876D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E876D4: 4BE21D31  bl 0x82ca9404
	ctx.lr = 0x82E876D8;
	sub_82CA93D0(ctx, base);
	// 82E876D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E876DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E876E0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82E876E4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82E876E8: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E876EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E876F0: 40990060  ble cr6, 0x82e87750
	if !ctx.cr[6].gt {
	pc = 0x82E87750; continue 'dispatch;
	}
	// 82E876F4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82E876F8; continue 'dispatch;
            }
            0x82E876F8 => {
    //   block [0x82E876F8..0x82E8771C)
	// 82E876F8: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E876FC: 7FEBE82E  lwzx r31, r11, r29
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82E87700: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E87704: 41820038  beq 0x82e8773c
	if ctx.cr[0].eq {
	pc = 0x82E8773C; continue 'dispatch;
	}
	// 82E87708: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8770C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E87710: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E87714: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E87718: 4E800421  bctrl
	ctx.lr = 0x82E8771C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8771C => {
    //   block [0x82E8771C..0x82E87734)
	// 82E8771C: 7F1B1840  cmplw cr6, r27, r3
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82E87720: 419A003C  beq cr6, 0x82e8775c
	if ctx.cr[6].eq {
	pc = 0x82E8775C; continue 'dispatch;
	}
	// 82E87724: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 82E87728: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8772C: 4082FFF0  bne 0x82e8771c
	if !ctx.cr[0].eq {
	pc = 0x82E8771C; continue 'dispatch;
	}
	// 82E87730: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82E87734; continue 'dispatch;
            }
            0x82E87734 => {
    //   block [0x82E87734..0x82E8773C)
	// 82E87734: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E87738: 4082002C  bne 0x82e87764
	if !ctx.cr[0].eq {
	pc = 0x82E87764; continue 'dispatch;
	}
	pc = 0x82E8773C; continue 'dispatch;
            }
            0x82E8773C => {
    //   block [0x82E8773C..0x82E87750)
	// 82E8773C: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E87740: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82E87744: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82E87748: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8774C: 4198FFAC  blt cr6, 0x82e876f8
	if ctx.cr[6].lt {
	pc = 0x82E876F8; continue 'dispatch;
	}
	pc = 0x82E87750; continue 'dispatch;
            }
            0x82E87750 => {
    //   block [0x82E87750..0x82E87754)
	// 82E87750: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E87754; continue 'dispatch;
            }
            0x82E87754 => {
    //   block [0x82E87754..0x82E8775C)
	// 82E87754: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E87758: 4BE21CFC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82E8775C => {
    //   block [0x82E8775C..0x82E87764)
	// 82E8775C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E87760: 4BFFFFD4  b 0x82e87734
	pc = 0x82E87734; continue 'dispatch;
            }
            0x82E87764 => {
    //   block [0x82E87764..0x82E8776C)
	// 82E87764: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E87768: 4BFFFFEC  b 0x82e87754
	pc = 0x82E87754; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E87770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E87770 size=772
    let mut pc: u32 = 0x82E87770;
    'dispatch: loop {
        match pc {
            0x82E87770 => {
    //   block [0x82E87770..0x82E8779C)
	// 82E87770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E87774: 4BE21C99  bl 0x82ca940c
	ctx.lr = 0x82E87778;
	sub_82CA93D0(ctx, base);
	// 82E87778: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E8777C: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E87780: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E87784: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82E87788: 40980298  bge cr6, 0x82e87a20
	if !ctx.cr[6].lt {
	pc = 0x82E87A20; continue 'dispatch;
	}
	// 82E8778C: 83CB0024  lwz r30, 0x24(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E87790: 3C808334  lis r4, -0x7ccc
	ctx.r[4].s64 = -2093744128;
	// 82E87794: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82E87798: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82E8779C; continue 'dispatch;
            }
            0x82E8779C => {
    //   block [0x82E8779C..0x82E877AC)
	// 82E8779C: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E877A0: 7F0AF000  cmpw cr6, r10, r30
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[30].s32, &mut ctx.xer);
	// 82E877A4: 40980254  bge cr6, 0x82e879f8
	if !ctx.cr[6].lt {
	pc = 0x82E879F8; continue 'dispatch;
	}
	// 82E877A8: 80CB0028  lwz r6, 0x28(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	pc = 0x82E877AC; continue 'dispatch;
            }
            0x82E877AC => {
    //   block [0x82E877AC..0x82E877DC)
	// 82E877AC: 80EB0030  lwz r7, 0x30(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E877B0: 80AB002C  lwz r5, 0x2c(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E877B4: 2F07FFFF  cmpwi cr6, r7, -1
	ctx.cr[6].compare_i32(ctx.r[7].s32, -1, &mut ctx.xer);
	// 82E877B8: 409A00C0  bne cr6, 0x82e87878
	if !ctx.cr[6].eq {
	pc = 0x82E87878; continue 'dispatch;
	}
	// 82E877BC: 93EB0030  stw r31, 0x30(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[31].u32 ) };
	// 82E877C0: 81440718  lwz r10, 0x718(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E877C4: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E877C8: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82E877CC: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82E877D0: 914B0034  stw r10, 0x34(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	// 82E877D4: 4099005C  ble cr6, 0x82e87830
	if !ctx.cr[6].gt {
	pc = 0x82E87830; continue 'dispatch;
	}
	// 82E877D8: 80EB000C  lwz r7, 0xc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x82E877DC; continue 'dispatch;
            }
            0x82E877DC => {
    //   block [0x82E877DC..0x82E87810)
	// 82E877DC: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E877E0: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82E877E4: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82E877E8: 5548F87E  srwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82E877EC: 1D48000C  mulli r10, r8, 0xc
	ctx.r[10].s32 = ((ctx.r[8].s32 as i64 * 12 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82E877F0: 7D2A3A14  add r9, r10, r7
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 82E877F4: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E877F8: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82E877FC: 41980014  blt cr6, 0x82e87810
	if ctx.cr[6].lt {
	pc = 0x82E87810; continue 'dispatch;
	}
	// 82E87800: 41990018  bgt cr6, 0x82e87818
	if ctx.cr[6].gt {
	pc = 0x82E87818; continue 'dispatch;
	}
	// 82E87804: 81490008  lwz r10, 8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E87808: 7F0A2800  cmpw cr6, r10, r5
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82E8780C: 4098000C  bge cr6, 0x82e87818
	if !ctx.cr[6].lt {
	pc = 0x82E87818; continue 'dispatch;
	}
	pc = 0x82E87810; continue 'dispatch;
            }
            0x82E87810 => {
    //   block [0x82E87810..0x82E87818)
	// 82E87810: 910B0030  stw r8, 0x30(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[8].u32 ) };
	// 82E87814: 48000008  b 0x82e8781c
	pc = 0x82E8781C; continue 'dispatch;
            }
            0x82E87818 => {
    //   block [0x82E87818..0x82E8781C)
	// 82E87818: 910B0034  stw r8, 0x34(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), ctx.r[8].u32 ) };
	pc = 0x82E8781C; continue 'dispatch;
            }
            0x82E8781C => {
    //   block [0x82E8781C..0x82E87830)
	// 82E8781C: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82E87820: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E87824: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82E87828: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82E8782C: 4199FFB0  bgt cr6, 0x82e877dc
	if ctx.cr[6].gt {
	pc = 0x82E877DC; continue 'dispatch;
	}
	pc = 0x82E87830; continue 'dispatch;
            }
            0x82E87830 => {
    //   block [0x82E87830..0x82E87860)
	// 82E87830: 80EB0030  lwz r7, 0x30(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E87834: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E87838: 1D47000C  mulli r10, r7, 0xc
	ctx.r[10].s32 = ((ctx.r[7].s32 as i64 * 12 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82E8783C: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82E87840: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E87844: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82E87848: 41980018  blt cr6, 0x82e87860
	if ctx.cr[6].lt {
	pc = 0x82E87860; continue 'dispatch;
	}
	// 82E8784C: 4199001C  bgt cr6, 0x82e87868
	if ctx.cr[6].gt {
	pc = 0x82E87868; continue 'dispatch;
	}
	// 82E87850: 81490008  lwz r10, 8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E87854: 7F0A2800  cmpw cr6, r10, r5
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82E87858: 41980008  blt cr6, 0x82e87860
	if ctx.cr[6].lt {
	pc = 0x82E87860; continue 'dispatch;
	}
	// 82E8785C: 4199000C  bgt cr6, 0x82e87868
	if ctx.cr[6].gt {
	pc = 0x82E87868; continue 'dispatch;
	}
	pc = 0x82E87860; continue 'dispatch;
            }
            0x82E87860 => {
    //   block [0x82E87860..0x82E87868)
	// 82E87860: 90EB0038  stw r7, 0x38(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[7].u32 ) };
	// 82E87864: 4800000C  b 0x82e87870
	pc = 0x82E87870; continue 'dispatch;
            }
            0x82E87868 => {
    //   block [0x82E87868..0x82E87870)
	// 82E87868: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82E8786C: 914B0038  stw r10, 0x38(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	pc = 0x82E87870; continue 'dispatch;
            }
            0x82E87870 => {
    //   block [0x82E87870..0x82E87878)
	// 82E87870: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E87874: 994B003C  stb r10, 0x3c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), ctx.r[10].u8 ) };
	pc = 0x82E87878; continue 'dispatch;
            }
            0x82E87878 => {
    //   block [0x82E87878..0x82E878A0)
	// 82E87878: 894B003C  lbz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82E8787C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E87880: 418200BC  beq 0x82e8793c
	if ctx.cr[0].eq {
	pc = 0x82E8793C; continue 'dispatch;
	}
	// 82E87884: 814B0038  lwz r10, 0x38(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E87888: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8788C: 1D4A000C  mulli r10, r10, 0xc
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 12 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82E87890: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82E87894: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E87898: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82E8789C: 409A0094  bne cr6, 0x82e87930
	if !ctx.cr[6].eq {
	pc = 0x82E87930; continue 'dispatch;
	}
	pc = 0x82E878A0; continue 'dispatch;
            }
            0x82E878A0 => {
    //   block [0x82E878A0..0x82E87900)
	// 82E878A0: 812B0038  lwz r9, 0x38(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E878A4: 1D49000C  mulli r10, r9, 0xc
	ctx.r[10].s32 = ((ctx.r[9].s32 as i64 * 12 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82E878A8: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82E878AC: 83AA0008  lwz r29, 8(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E878B0: 7F1D2800  cmpw cr6, r29, r5
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82E878B4: 409A007C  bne cr6, 0x82e87930
	if !ctx.cr[6].eq {
	pc = 0x82E87930; continue 'dispatch;
	}
	// 82E878B8: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E878BC: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E878C0: 41820040  beq 0x82e87900
	if ctx.cr[0].eq {
	pc = 0x82E87900; continue 'dispatch;
	}
	// 82E878C4: C1AA0034  lfs f13, 0x34(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E878C8: C00B0040  lfs f0, 0x40(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E878CC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E878D0: C18B0044  lfs f12, 0x44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E878D4: C1AA0038  lfs f13, 0x38(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E878D8: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E878DC: C14A003C  lfs f10, 0x3c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E878E0: C18B0048  lfs f12, 0x48(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E878E4: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82E878E8: C16B004C  lfs f11, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E878EC: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E878F0: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E878F4: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E878F8: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82E878FC: 4198012C  blt cr6, 0x82e87a28
	if ctx.cr[6].lt {
	pc = 0x82E87A28; continue 'dispatch;
	}
	pc = 0x82E87900; continue 'dispatch;
            }
            0x82E87900 => {
    //   block [0x82E87900..0x82E87930)
	// 82E87900: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E87904: 419A002C  beq cr6, 0x82e87930
	if ctx.cr[6].eq {
	pc = 0x82E87930; continue 'dispatch;
	}
	// 82E87908: 3949FFFF  addi r10, r9, -1
	ctx.r[10].s64 = ctx.r[9].s64 + -1;
	// 82E8790C: 914B0038  stw r10, 0x38(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 82E87910: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E87914: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E87918: 1D4A000C  mulli r10, r10, 0xc
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 12 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82E8791C: 83AB0028  lwz r29, 0x28(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E87920: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82E87924: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E87928: 7F0AE800  cmpw cr6, r10, r29
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82E8792C: 419AFF74  beq cr6, 0x82e878a0
	if ctx.cr[6].eq {
	pc = 0x82E878A0; continue 'dispatch;
	}
	pc = 0x82E87930; continue 'dispatch;
            }
            0x82E87930 => {
    //   block [0x82E87930..0x82E8793C)
	// 82E87930: 39470001  addi r10, r7, 1
	ctx.r[10].s64 = ctx.r[7].s64 + 1;
	// 82E87934: 9BEB003C  stb r31, 0x3c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), ctx.r[31].u8 ) };
	// 82E87938: 914B0038  stw r10, 0x38(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	pc = 0x82E8793C; continue 'dispatch;
            }
            0x82E8793C => {
    //   block [0x82E8793C..0x82E87954)
	// 82E8793C: 81440718  lwz r10, 0x718(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E87940: 812B0038  lwz r9, 0x38(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E87944: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E87948: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E8794C: 40980090  bge cr6, 0x82e879dc
	if !ctx.cr[6].lt {
	pc = 0x82E879DC; continue 'dispatch;
	}
	// 82E87950: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x82E87954; continue 'dispatch;
            }
            0x82E87954 => {
    //   block [0x82E87954..0x82E879C0)
	// 82E87954: 812B0038  lwz r9, 0x38(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E87958: 1D49000C  mulli r10, r9, 0xc
	ctx.r[10].s32 = ((ctx.r[9].s32 as i64 * 12 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82E8795C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82E87960: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E87964: 7F073000  cmpw cr6, r7, r6
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82E87968: 409A0074  bne cr6, 0x82e879dc
	if !ctx.cr[6].eq {
	pc = 0x82E879DC; continue 'dispatch;
	}
	// 82E8796C: 80EA0008  lwz r7, 8(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E87970: 7F072800  cmpw cr6, r7, r5
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82E87974: 409A0068  bne cr6, 0x82e879dc
	if !ctx.cr[6].eq {
	pc = 0x82E879DC; continue 'dispatch;
	}
	// 82E87978: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8797C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E87980: 41820040  beq 0x82e879c0
	if ctx.cr[0].eq {
	pc = 0x82E879C0; continue 'dispatch;
	}
	// 82E87984: C1AA0034  lfs f13, 0x34(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E87988: C00B0040  lfs f0, 0x40(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8798C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E87990: C18B0044  lfs f12, 0x44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E87994: C1AA0038  lfs f13, 0x38(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E87998: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E8799C: C14A003C  lfs f10, 0x3c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E879A0: C18B0048  lfs f12, 0x48(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E879A4: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82E879A8: C16B004C  lfs f11, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E879AC: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E879B0: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E879B4: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E879B8: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82E879BC: 419800A0  blt cr6, 0x82e87a5c
	if ctx.cr[6].lt {
	pc = 0x82E87A5C; continue 'dispatch;
	}
	pc = 0x82E879C0; continue 'dispatch;
            }
            0x82E879C0 => {
    //   block [0x82E879C0..0x82E879DC)
	// 82E879C0: 39490001  addi r10, r9, 1
	ctx.r[10].s64 = ctx.r[9].s64 + 1;
	// 82E879C4: 5549003E  slwi r9, r10, 0
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82E879C8: 914B0038  stw r10, 0x38(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 82E879CC: 81440718  lwz r10, 0x718(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E879D0: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E879D4: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E879D8: 4198FF7C  blt cr6, 0x82e87954
	if ctx.cr[6].lt {
	pc = 0x82E87954; continue 'dispatch;
	}
	pc = 0x82E879DC; continue 'dispatch;
            }
            0x82E879DC => {
    //   block [0x82E879DC..0x82E879F8)
	// 82E879DC: 39450001  addi r10, r5, 1
	ctx.r[10].s64 = ctx.r[5].s64 + 1;
	// 82E879E0: 906B0030  stw r3, 0x30(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[3].u32 ) };
	// 82E879E4: 914B002C  stw r10, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 82E879E8: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E879EC: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E879F0: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82E879F4: 4198FDB8  blt cr6, 0x82e877ac
	if ctx.cr[6].lt {
	pc = 0x82E877AC; continue 'dispatch;
	}
	pc = 0x82E879F8; continue 'dispatch;
            }
            0x82E879F8 => {
    //   block [0x82E879F8..0x82E87A20)
	// 82E879F8: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E879FC: 812B0020  lwz r9, 0x20(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E87A00: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E87A04: 906B0030  stw r3, 0x30(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[3].u32 ) };
	// 82E87A08: 912B002C  stw r9, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 82E87A0C: 914B0028  stw r10, 0x28(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82E87A10: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E87A14: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E87A18: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82E87A1C: 4198FD80  blt cr6, 0x82e8779c
	if ctx.cr[6].lt {
	pc = 0x82E8779C; continue 'dispatch;
	}
	pc = 0x82E87A20; continue 'dispatch;
            }
            0x82E87A20 => {
    //   block [0x82E87A20..0x82E87A24)
	// 82E87A20: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E87A24; continue 'dispatch;
            }
            0x82E87A24 => {
    //   block [0x82E87A24..0x82E87A28)
	// 82E87A24: 4BE21A38  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82E87A28 => {
    //   block [0x82E87A28..0x82E87A50)
	// 82E87A28: 814B0038  lwz r10, 0x38(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E87A2C: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E87A30: 1D0A000C  mulli r8, r10, 0xc
	ctx.r[8].s32 = ((ctx.r[10].s32 as i64 * 12 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82E87A34: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E87A38: 7C68482E  lwzx r3, r8, r9
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82E87A3C: 40820014  bne 0x82e87a50
	if !ctx.cr[0].eq {
	pc = 0x82E87A50; continue 'dispatch;
	}
	// 82E87A40: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E87A44: 9BEB003C  stb r31, 0x3c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), ctx.r[31].u8 ) };
	// 82E87A48: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E87A4C: 48000008  b 0x82e87a54
	pc = 0x82E87A54; continue 'dispatch;
            }
            0x82E87A50 => {
    //   block [0x82E87A50..0x82E87A54)
	// 82E87A50: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	pc = 0x82E87A54; continue 'dispatch;
            }
            0x82E87A54 => {
    //   block [0x82E87A54..0x82E87A5C)
	// 82E87A54: 914B0038  stw r10, 0x38(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 82E87A58: 4BFFFFCC  b 0x82e87a24
	pc = 0x82E87A24; continue 'dispatch;
            }
            0x82E87A5C => {
    //   block [0x82E87A5C..0x82E87A74)
	// 82E87A5C: 814B0038  lwz r10, 0x38(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E87A60: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E87A64: 1D0A000C  mulli r8, r10, 0xc
	ctx.r[8].s32 = ((ctx.r[10].s32 as i64 * 12 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82E87A68: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E87A6C: 7C68482E  lwzx r3, r8, r9
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82E87A70: 4BFFFFE4  b 0x82e87a54
	pc = 0x82E87A54; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E87A78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E87A78 size=164
    let mut pc: u32 = 0x82E87A78;
    'dispatch: loop {
        match pc {
            0x82E87A78 => {
    //   block [0x82E87A78..0x82E87AC0)
	// 82E87A78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E87A7C: 4BE21989  bl 0x82ca9404
	ctx.lr = 0x82E87A80;
	sub_82CA93D0(ctx, base);
	// 82E87A80: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E87A84: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82E87A88: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82E87A8C: 817B0028  lwz r11, 0x28(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E87A90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E87A94: 419A0080  beq cr6, 0x82e87b14
	if ctx.cr[6].eq {
	pc = 0x82E87B14; continue 'dispatch;
	}
	// 82E87A98: 817B006C  lwz r11, 0x6c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(108 as u32) ) } as u64;
	// 82E87A9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E87AA0: 419A0074  beq cr6, 0x82e87b14
	if ctx.cr[6].eq {
	pc = 0x82E87B14; continue 'dispatch;
	}
	// 82E87AA4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E87AA8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E87AAC: 3BEB0070  addi r31, r11, 0x70
	ctx.r[31].s64 = ctx.r[11].s64 + 112;
	// 82E87AB0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E87AB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E87AB8: 40990040  ble cr6, 0x82e87af8
	if !ctx.cr[6].gt {
	pc = 0x82E87AF8; continue 'dispatch;
	}
	// 82E87ABC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82E87AC0; continue 'dispatch;
            }
            0x82E87AC0 => {
    //   block [0x82E87AC0..0x82E87AE4)
	// 82E87AC0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E87AC4: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82E87AC8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E87ACC: 41820018  beq 0x82e87ae4
	if ctx.cr[0].eq {
	pc = 0x82E87AE4; continue 'dispatch;
	}
	// 82E87AD0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E87AD4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E87AD8: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E87ADC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E87AE0: 4E800421  bctrl
	ctx.lr = 0x82E87AE4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E87AE4 => {
    //   block [0x82E87AE4..0x82E87AF8)
	// 82E87AE4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E87AE8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82E87AEC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82E87AF0: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E87AF4: 4198FFCC  blt cr6, 0x82e87ac0
	if ctx.cr[6].lt {
	pc = 0x82E87AC0; continue 'dispatch;
	}
	pc = 0x82E87AF8; continue 'dispatch;
            }
            0x82E87AF8 => {
    //   block [0x82E87AF8..0x82E87B14)
	// 82E87AF8: 389B0068  addi r4, r27, 0x68
	ctx.r[4].s64 = ctx.r[27].s64 + 104;
	// 82E87AFC: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E87B00: 4BFFD381  bl 0x82e84e80
	ctx.lr = 0x82E87B04;
	sub_82E84E80(ctx, base);
	// 82E87B04: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E87B08: 917B006C  stw r11, 0x6c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82E87B0C: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E87B10: 4BFFFB59  bl 0x82e87668
	ctx.lr = 0x82E87B14;
	sub_82E87668(ctx, base);
	pc = 0x82E87B14; continue 'dispatch;
            }
            0x82E87B14 => {
    //   block [0x82E87B14..0x82E87B1C)
	// 82E87B14: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E87B18: 4BE2193C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E87B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E87B20 size=388
    let mut pc: u32 = 0x82E87B20;
    'dispatch: loop {
        match pc {
            0x82E87B20 => {
    //   block [0x82E87B20..0x82E87B74)
	// 82E87B20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E87B24: 4BE218E5  bl 0x82ca9408
	ctx.lr = 0x82E87B28;
	sub_82CA93D0(ctx, base);
	// 82E87B28: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82E87B2C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E87B30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E87B34: 4B3D8E85  bl 0x822609b8
	ctx.lr = 0x82E87B38;
	sub_822609B8(ctx, base);
	// 82E87B38: C1BF0010  lfs f13, 0x10(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E87B3C: C003004C  lfs f0, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E87B40: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E87B44: 41990154  bgt cr6, 0x82e87c98
	if ctx.cr[6].gt {
	pc = 0x82E87C98; continue 'dispatch;
	}
	// 82E87B48: 3F808334  lis r28, -0x7ccc
	ctx.r[28].s64 = -2093744128;
	// 82E87B4C: C1BF0008  lfs f13, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E87B50: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82E87B54: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82E87B58: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82E87B5C: 815C0718  lwz r10, 0x718(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E87B60: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E87B64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E87B68: 40990048  ble cr6, 0x82e87bb0
	if !ctx.cr[6].gt {
	pc = 0x82E87BB0; continue 'dispatch;
	}
	// 82E87B6C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E87B70: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	pc = 0x82E87B74; continue 'dispatch;
            }
            0x82E87B74 => {
    //   block [0x82E87B74..0x82E87BB0)
	// 82E87B74: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E87B78: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82E87B7C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82E87B80: 7CEB512E  stwx r7, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[7].u32) };
	// 82E87B84: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E87B88: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E87B8C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82E87B90: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E87B94: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E87B98: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82E87B9C: 910A0008  stw r8, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82E87BA0: 815C0718  lwz r10, 0x718(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E87BA4: 80EA0010  lwz r7, 0x10(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E87BA8: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82E87BAC: 4198FFC8  blt cr6, 0x82e87b74
	if ctx.cr[6].lt {
	pc = 0x82E87B74; continue 'dispatch;
	}
	pc = 0x82E87BB0; continue 'dispatch;
            }
            0x82E87BB0 => {
    //   block [0x82E87BB0..0x82E87BC8)
	// 82E87BB0: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E87BB4: 83AB0008  lwz r29, 8(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E87BB8: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E87BBC: 418200C4  beq 0x82e87c80
	if ctx.cr[0].eq {
	pc = 0x82E87C80; continue 'dispatch;
	}
	// 82E87BC0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E87BC4: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82E87BC8; continue 'dispatch;
            }
            0x82E87BC8 => {
    //   block [0x82E87BC8..0x82E87C04)
	// 82E87BC8: 83DD0004  lwz r30, 4(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E87BCC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E87BD0: 4B33C719  bl 0x821c42e8
	ctx.lr = 0x82E87BD4;
	sub_821C42E8(ctx, base);
	// 82E87BD4: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E87BD8: 1D63000C  mulli r11, r3, 0xc
	ctx.r[11].s32 = ((ctx.r[3].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82E87BDC: 7FCB512E  stwx r30, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[30].u32) };
	// 82E87BE0: C01E0034  lfs f0, 0x34(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E87BE4: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E87BE8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82E87BEC: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82E87BF0: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82E87BF4: 41980010  blt cr6, 0x82e87c04
	if ctx.cr[6].lt {
	pc = 0x82E87C04; continue 'dispatch;
	}
	// 82E87BF8: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 82E87BFC: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 82E87C00: 48000018  b 0x82e87c18
	pc = 0x82E87C18; continue 'dispatch;
            }
            0x82E87C04 => {
    //   block [0x82E87C04..0x82E87C18)
	// 82E87C04: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82E87C08: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 82E87C0C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E87C10: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82E87C14: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	pc = 0x82E87C18; continue 'dispatch;
            }
            0x82E87C18 => {
    //   block [0x82E87C18..0x82E87C4C)
	// 82E87C18: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E87C1C: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82E87C20: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E87C24: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82E87C28: C01E003C  lfs f0, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E87C2C: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E87C30: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82E87C34: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82E87C38: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82E87C3C: 41980010  blt cr6, 0x82e87c4c
	if ctx.cr[6].lt {
	pc = 0x82E87C4C; continue 'dispatch;
	}
	// 82E87C40: 3941005C  addi r10, r1, 0x5c
	ctx.r[10].s64 = ctx.r[1].s64 + 92;
	// 82E87C44: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 82E87C48: 48000018  b 0x82e87c60
	pc = 0x82E87C60; continue 'dispatch;
            }
            0x82E87C4C => {
    //   block [0x82E87C4C..0x82E87C60)
	// 82E87C4C: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 82E87C50: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 82E87C54: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E87C58: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82E87C5C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x82E87C60; continue 'dispatch;
            }
            0x82E87C60 => {
    //   block [0x82E87C60..0x82E87C80)
	// 82E87C60: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E87C64: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E87C68: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E87C6C: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82E87C70: 83BD000C  lwz r29, 0xc(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E87C74: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E87C78: 4082FF50  bne 0x82e87bc8
	if !ctx.cr[0].eq {
	pc = 0x82E87BC8; continue 'dispatch;
	}
	// 82E87C7C: 815C0718  lwz r10, 0x718(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	pc = 0x82E87C80; continue 'dispatch;
            }
            0x82E87C80 => {
    //   block [0x82E87C80..0x82E87C98)
	// 82E87C80: 3D6082E8  lis r11, -0x7d18
	ctx.r[11].s64 = -2098724864;
	// 82E87C84: 808A0010  lwz r4, 0x10(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E87C88: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 82E87C8C: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E87C90: 38CB7380  addi r6, r11, 0x7380
	ctx.r[6].s64 = ctx.r[11].s64 + 29568;
	// 82E87C94: 4BE23F25  bl 0x82cabbb8
	ctx.lr = 0x82E87C98;
	sub_82CABBB8(ctx, base);
	pc = 0x82E87C98; continue 'dispatch;
            }
            0x82E87C98 => {
    //   block [0x82E87C98..0x82E87CA4)
	// 82E87C98: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E87C9C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82E87CA0: 4BE217B8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E87CA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E87CA8 size=380
    let mut pc: u32 = 0x82E87CA8;
    'dispatch: loop {
        match pc {
            0x82E87CA8 => {
    //   block [0x82E87CA8..0x82E87D14)
	// 82E87CA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E87CAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E87CB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E87CB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E87CB8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82E87CBC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E87CC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E87CC4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82E87CC8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E87CCC: 4BFFFE55  bl 0x82e87b20
	ctx.lr = 0x82E87CD0;
	sub_82E87B20(ctx, base);
	// 82E87CD0: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E87CD4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E87CD8: ED80F828  fsubs f12, f0, f31
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82E87CDC: C17F0004  lfs f11, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E87CE0: ED40F82A  fadds f10, f0, f31
	ctx.f[10].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82E87CE4: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E87CE8: ED2DF828  fsubs f9, f13, f31
	ctx.f[9].f64 = (((ctx.f[13].f64 - ctx.f[31].f64) as f32) as f64);
	// 82E87CEC: EDADF82A  fadds f13, f13, f31
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64;
	// 82E87CF0: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E87CF4: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82E87CF8: ED8C5824  fdivs f12, f12, f11
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[11].f64) as f32) as f64;
	// 82E87CFC: FD80601E  fctiwz f12, f12
	ctx.f[12].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82E87D00: 41980014  blt cr6, 0x82e87d14
	if ctx.cr[6].lt {
	pc = 0x82E87D14; continue 'dispatch;
	}
	// 82E87D04: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82E87D08: 7D805FAE  stfiwx f12, 0, r11
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82E87D0C: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E87D10: 48000014  b 0x82e87d24
	pc = 0x82E87D24; continue 'dispatch;
            }
            0x82E87D14 => {
    //   block [0x82E87D14..0x82E87D24)
	// 82E87D14: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82E87D18: 7D805FAE  stfiwx f12, 0, r11
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82E87D1C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E87D20: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	pc = 0x82E87D24; continue 'dispatch;
            }
            0x82E87D24 => {
    //   block [0x82E87D24..0x82E87D48)
	// 82E87D24: ED8A5824  fdivs f12, f10, f11
	ctx.f[12].f64 = ((ctx.f[10].f64 / ctx.f[11].f64) as f32) as f64;
	// 82E87D28: 913F0018  stw r9, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 82E87D2C: FF0A0000  fcmpu cr6, f10, f0
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[0].f64);
	// 82E87D30: FD80601E  fctiwz f12, f12
	ctx.f[12].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82E87D34: 41980014  blt cr6, 0x82e87d48
	if ctx.cr[6].lt {
	pc = 0x82E87D48; continue 'dispatch;
	}
	// 82E87D38: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82E87D3C: 7D805FAE  stfiwx f12, 0, r11
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82E87D40: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E87D44: 48000014  b 0x82e87d58
	pc = 0x82E87D58; continue 'dispatch;
            }
            0x82E87D48 => {
    //   block [0x82E87D48..0x82E87D58)
	// 82E87D48: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82E87D4C: 7D805FAE  stfiwx f12, 0, r11
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82E87D50: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E87D54: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82E87D58; continue 'dispatch;
            }
            0x82E87D58 => {
    //   block [0x82E87D58..0x82E87D80)
	// 82E87D58: ED895824  fdivs f12, f9, f11
	ctx.f[12].f64 = ((ctx.f[9].f64 / ctx.f[11].f64) as f32) as f64;
	// 82E87D5C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E87D60: FF090000  fcmpu cr6, f9, f0
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[0].f64);
	// 82E87D64: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82E87D68: FD80601E  fctiwz f12, f12
	ctx.f[12].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82E87D6C: 41980014  blt cr6, 0x82e87d80
	if ctx.cr[6].lt {
	pc = 0x82E87D80; continue 'dispatch;
	}
	// 82E87D70: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82E87D74: 7D805FAE  stfiwx f12, 0, r11
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82E87D78: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E87D7C: 48000014  b 0x82e87d90
	pc = 0x82E87D90; continue 'dispatch;
            }
            0x82E87D80 => {
    //   block [0x82E87D80..0x82E87D90)
	// 82E87D80: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82E87D84: 7D805FAE  stfiwx f12, 0, r11
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82E87D88: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E87D8C: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	pc = 0x82E87D90; continue 'dispatch;
            }
            0x82E87D90 => {
    //   block [0x82E87D90..0x82E87DB4)
	// 82E87D90: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E87D94: 915F0020  stw r10, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 82E87D98: EC0D5824  fdivs f0, f13, f11
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[11].f64) as f32) as f64;
	// 82E87D9C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82E87DA0: 41980014  blt cr6, 0x82e87db4
	if ctx.cr[6].lt {
	pc = 0x82E87DB4; continue 'dispatch;
	}
	// 82E87DA4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82E87DA8: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82E87DAC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E87DB0: 48000014  b 0x82e87dc4
	pc = 0x82E87DC4; continue 'dispatch;
            }
            0x82E87DB4 => {
    //   block [0x82E87DB4..0x82E87DC4)
	// 82E87DB4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82E87DB8: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82E87DBC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E87DC0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82E87DC4; continue 'dispatch;
            }
            0x82E87DC4 => {
    //   block [0x82E87DC4..0x82E87E24)
	// 82E87DC4: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 82E87DC8: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 82E87DCC: 915F002C  stw r10, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 82E87DD0: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82E87DD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E87DD8: EC1F07F2  fmuls f0, f31, f31
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E87DDC: 911F0024  stw r8, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[8].u32 ) };
	// 82E87DE0: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E87DE4: D1BF0040  stfs f13, 0x40(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82E87DE8: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E87DEC: D1BF0044  stfs f13, 0x44(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82E87DF0: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E87DF4: D1BF0048  stfs f13, 0x48(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 82E87DF8: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82E87DFC: D01F004C  stfs f0, 0x4c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82E87E00: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82E87E04: 4BFFF96D  bl 0x82e87770
	ctx.lr = 0x82E87E08;
	sub_82E87770(ctx, base);
	// 82E87E08: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E87E0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E87E10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E87E14: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82E87E18: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E87E1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E87E20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E87E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E87E28 size=252
    let mut pc: u32 = 0x82E87E28;
    'dispatch: loop {
        match pc {
            0x82E87E28 => {
    //   block [0x82E87E28..0x82E87E58)
	// 82E87E28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E87E2C: 4BE215E1  bl 0x82ca940c
	ctx.lr = 0x82E87E30;
	sub_82CA93D0(ctx, base);
	// 82E87E30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E87E34: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E87E38: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82E87E3C: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E87E40: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82E87E44: 409A0014  bne cr6, 0x82e87e58
	if !ctx.cr[6].eq {
	pc = 0x82E87E58; continue 'dispatch;
	}
	// 82E87E48: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E87E4C: 419A0038  beq cr6, 0x82e87e84
	if ctx.cr[6].eq {
	pc = 0x82E87E84; continue 'dispatch;
	}
	// 82E87E50: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82E87E54: 48000030  b 0x82e87e84
	pc = 0x82E87E84; continue 'dispatch;
            }
            0x82E87E58 => {
    //   block [0x82E87E58..0x82E87E78)
	// 82E87E58: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 82E87E5C: 409A0028  bne cr6, 0x82e87e84
	if !ctx.cr[6].eq {
	pc = 0x82E87E84; continue 'dispatch;
	}
	// 82E87E60: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E87E64: 40990020  ble cr6, 0x82e87e84
	if !ctx.cr[6].gt {
	pc = 0x82E87E84; continue 'dispatch;
	}
	// 82E87E68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E87E6C: 409A0010  bne cr6, 0x82e87e7c
	if !ctx.cr[6].eq {
	pc = 0x82E87E7C; continue 'dispatch;
	}
	// 82E87E70: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82E87E74: 48000008  b 0x82e87e7c
	pc = 0x82E87E7C; continue 'dispatch;
            }
            0x82E87E78 => {
    //   block [0x82E87E78..0x82E87E7C)
	// 82E87E78: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	pc = 0x82E87E7C; continue 'dispatch;
            }
            0x82E87E7C => {
    //   block [0x82E87E7C..0x82E87E84)
	// 82E87E7C: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82E87E80: 4198FFF8  blt cr6, 0x82e87e78
	if ctx.cr[6].lt {
	pc = 0x82E87E78; continue 'dispatch;
	}
	pc = 0x82E87E84; continue 'dispatch;
            }
            0x82E87E84 => {
    //   block [0x82E87E84..0x82E87E98)
	// 82E87E84: 83FD000C  lwz r31, 0xc(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E87E88: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E87E8C: 4099000C  ble cr6, 0x82e87e98
	if !ctx.cr[6].gt {
	pc = 0x82E87E98; continue 'dispatch;
	}
	// 82E87E90: 917D000C  stw r11, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82E87E94: 48000008  b 0x82e87e9c
	pc = 0x82E87E9C; continue 'dispatch;
            }
            0x82E87E98 => {
    //   block [0x82E87E98..0x82E87E9C)
	// 82E87E98: 909D000C  stw r4, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	pc = 0x82E87E9C; continue 'dispatch;
            }
            0x82E87E9C => {
    //   block [0x82E87E9C..0x82E87EB0)
	// 82E87E9C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E87EA0: 419A007C  beq cr6, 0x82e87f1c
	if ctx.cr[6].eq {
	pc = 0x82E87F1C; continue 'dispatch;
	}
	// 82E87EA4: 7F1F2040  cmplw cr6, r31, r4
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82E87EA8: 41980008  blt cr6, 0x82e87eb0
	if ctx.cr[6].lt {
	pc = 0x82E87EB0; continue 'dispatch;
	}
	// 82E87EAC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	pc = 0x82E87EB0; continue 'dispatch;
            }
            0x82E87EB0 => {
    //   block [0x82E87EB0..0x82E87ECC)
	// 82E87EB0: 3D403FFF  lis r10, 0x3fff
	ctx.r[10].s64 = 1073676288;
	// 82E87EB4: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E87EB8: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82E87EBC: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 82E87EC0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E87EC4: 40990008  ble cr6, 0x82e87ecc
	if !ctx.cr[6].gt {
	pc = 0x82E87ECC; continue 'dispatch;
	}
	// 82E87EC8: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82E87ECC; continue 'dispatch;
            }
            0x82E87ECC => {
    //   block [0x82E87ECC..0x82E87EE4)
	// 82E87ECC: 4B78EA5D  bl 0x82616928
	ctx.lr = 0x82E87ED0;
	sub_82616928(ctx, base);
	// 82E87ED0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E87ED4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E87ED8: 419A0024  beq cr6, 0x82e87efc
	if ctx.cr[6].eq {
	pc = 0x82E87EFC; continue 'dispatch;
	}
	// 82E87EDC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E87EE0: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	pc = 0x82E87EE4; continue 'dispatch;
            }
            0x82E87EE4 => {
    //   block [0x82E87EE4..0x82E87EFC)
	// 82E87EE4: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E87EE8: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E87EEC: 7D29582E  lwzx r9, r9, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82E87EF0: 7D2BF12E  stwx r9, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[9].u32) };
	// 82E87EF4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E87EF8: 4082FFEC  bne 0x82e87ee4
	if !ctx.cr[0].eq {
	pc = 0x82E87EE4; continue 'dispatch;
	}
	pc = 0x82E87EFC; continue 'dispatch;
            }
            0x82E87EFC => {
    //   block [0x82E87EFC..0x82E87F18)
	// 82E87EFC: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E87F00: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E87F04: 41820014  beq 0x82e87f18
	if ctx.cr[0].eq {
	pc = 0x82E87F18; continue 'dispatch;
	}
	// 82E87F08: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E87F0C: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E87F10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E87F14: 4E800421  bctrl
	ctx.lr = 0x82E87F18;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E87F18 => {
    //   block [0x82E87F18..0x82E87F1C)
	// 82E87F18: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	pc = 0x82E87F1C; continue 'dispatch;
            }
            0x82E87F1C => {
    //   block [0x82E87F1C..0x82E87F24)
	// 82E87F1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E87F20: 4BE2153C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E87F28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E87F28 size=384
    let mut pc: u32 = 0x82E87F28;
    'dispatch: loop {
        match pc {
            0x82E87F28 => {
    //   block [0x82E87F28..0x82E87F64)
	// 82E87F28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E87F2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E87F30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E87F34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E87F38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E87F3C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E87F40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E87F44: 396B1CE4  addi r11, r11, 0x1ce4
	ctx.r[11].s64 = ctx.r[11].s64 + 7396;
	// 82E87F48: 3C608334  lis r3, -0x7ccc
	ctx.r[3].s64 = -2093744128;
	// 82E87F4C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E87F50: 81630718  lwz r11, 0x718(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E87F54: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E87F58: 4182000C  beq 0x82e87f64
	if ctx.cr[0].eq {
	pc = 0x82E87F64; continue 'dispatch;
	}
	// 82E87F5C: C1AB000C  lfs f13, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E87F60: 4800000C  b 0x82e87f6c
	pc = 0x82E87F6C; continue 'dispatch;
            }
            0x82E87F64 => {
    //   block [0x82E87F64..0x82E87F6C)
	// 82E87F64: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E87F68: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82E87F6C; continue 'dispatch;
            }
            0x82E87F6C => {
    //   block [0x82E87F6C..0x82E880A8)
	// 82E87F6C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E87F70: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E87F74: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82E87F78: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 82E87F7C: 3BC00004  li r30, 4
	ctx.r[30].s64 = 4;
	// 82E87F80: C00B0A54  lfs f0, 0xa54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E87F84: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E87F88: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E87F8C: D19F0004  stfs f12, 4(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E87F90: 993F0014  stb r9, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u8 ) };
	// 82E87F94: C1AB0B24  lfs f13, 0xb24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E87F98: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E87F9C: D1BF0008  stfs f13, 8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E87FA0: C1AA0BFC  lfs f13, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E87FA4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82E87FA8: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E87FAC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E87FB0: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82E87FB4: C18ABE10  lfs f12, -0x41f0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16880 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E87FB8: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82E87FBC: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82E87FC0: 7D455378  mr r5, r10
	ctx.r[5].u64 = ctx.r[10].u64;
	// 82E87FC4: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82E87FC8: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82E87FCC: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82E87FD0: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82E87FD4: 392AA8F0  addi r9, r10, -0x5710
	ctx.r[9].s64 = ctx.r[10].s64 + -22288;
	// 82E87FD8: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82E87FDC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82E87FE0: 90DF0030  stw r6, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[6].u32 ) };
	// 82E87FE4: 90BF0034  stw r5, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[5].u32 ) };
	// 82E87FE8: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82E87FEC: 390AA8F0  addi r8, r10, -0x5710
	ctx.r[8].s64 = ctx.r[10].s64 + -22288;
	// 82E87FF0: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82E87FF4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82E87FF8: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82E87FFC: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82E88000: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82E88004: 38EAA8F0  addi r7, r10, -0x5710
	ctx.r[7].s64 = ctx.r[10].s64 + -22288;
	// 82E88008: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82E8800C: C1460B6C  lfs f10, 0xb6c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(2924 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E88010: 3CC082E8  lis r6, -0x7d18
	ctx.r[6].s64 = -2098724864;
	// 82E88014: 394A115C  addi r10, r10, 0x115c
	ctx.r[10].s64 = ctx.r[10].s64 + 4444;
	// 82E88018: C16A0000  lfs f11, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8801C: D17F0040  stfs f11, 0x40(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82E88020: C16A0004  lfs f11, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E88024: D17F0044  stfs f11, 0x44(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82E88028: C16A0008  lfs f11, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8802C: D17F0048  stfs f11, 0x48(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 82E88030: D01F004C  stfs f0, 0x4c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82E88034: 913F0050  stw r9, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82E88038: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82E8803C: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82E88040: 917F005C  stw r11, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82E88044: 911F0060  stw r8, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 82E88048: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82E8804C: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82E88050: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82E88054: 90FF0070  stw r7, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[7].u32 ) };
	// 82E88058: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82E8805C: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82E88060: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82E88064: D1BF0094  stfs f13, 0x94(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82E88068: 909F00A0  stw r4, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[4].u32 ) };
	// 82E8806C: 388673C8  addi r4, r6, 0x73c8
	ctx.r[4].s64 = ctx.r[6].s64 + 29640;
	// 82E88070: D19F0098  stfs f12, 0x98(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82E88074: 997F0088  stb r11, 0x88(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[11].u8 ) };
	// 82E88078: D15F00B0  stfs f10, 0xb0(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82E8807C: 917F009C  stw r11, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 82E88080: 93DF00AC  stw r30, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[30].u32 ) };
	// 82E88084: 80630718  lwz r3, 0x718(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E88088: 4BFFAF81  bl 0x82e83008
	ctx.lr = 0x82E8808C;
	sub_82E83008(ctx, base);
	// 82E8808C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E88090: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E88094: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E88098: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8809C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E880A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E880A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E880A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E880A8 size=300
    let mut pc: u32 = 0x82E880A8;
    'dispatch: loop {
        match pc {
            0x82E880A8 => {
    //   block [0x82E880A8..0x82E880F8)
	// 82E880A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E880AC: 4BE21361  bl 0x82ca940c
	ctx.lr = 0x82E880B0;
	sub_82CA93D0(ctx, base);
	// 82E880B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E880B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E880B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E880BC: 396B1CE4  addi r11, r11, 0x1ce4
	ctx.r[11].s64 = ctx.r[11].s64 + 7396;
	// 82E880C0: 3D4082E8  lis r10, -0x7d18
	ctx.r[10].s64 = -2098724864;
	// 82E880C4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82E880C8: 388A73C8  addi r4, r10, 0x73c8
	ctx.r[4].s64 = ctx.r[10].s64 + 29640;
	// 82E880CC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E880D0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E880D4: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E880D8: 4BFFB091  bl 0x82e83168
	ctx.lr = 0x82E880DC;
	sub_82E83168(ctx, base);
	// 82E880DC: 807F009C  lwz r3, 0x9c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 82E880E0: 3FC08330  lis r30, -0x7cd0
	ctx.r[30].s64 = -2094006272;
	// 82E880E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E880E8: 41820010  beq 0x82e880f8
	if ctx.cr[0].eq {
	pc = 0x82E880F8; continue 'dispatch;
	}
	// 82E880EC: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E880F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E880F4: 4E800421  bctrl
	ctx.lr = 0x82E880F8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E880F8 => {
    //   block [0x82E880F8..0x82E88110)
	// 82E880F8: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E880FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E88100: 41820010  beq 0x82e88110
	if ctx.cr[0].eq {
	pc = 0x82E88110; continue 'dispatch;
	}
	// 82E88104: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E88108: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8810C: 4E800421  bctrl
	ctx.lr = 0x82E88110;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E88110 => {
    //   block [0x82E88110..0x82E88124)
	// 82E88110: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E88114: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E88118: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8811C: 40990040  ble cr6, 0x82e8815c
	if !ctx.cr[6].gt {
	pc = 0x82E8815C; continue 'dispatch;
	}
	// 82E88120: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82E88124; continue 'dispatch;
            }
            0x82E88124 => {
    //   block [0x82E88124..0x82E88148)
	// 82E88124: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E88128: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82E8812C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E88130: 41820018  beq 0x82e88148
	if ctx.cr[0].eq {
	pc = 0x82E88148; continue 'dispatch;
	}
	// 82E88134: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E88138: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E8813C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E88140: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E88144: 4E800421  bctrl
	ctx.lr = 0x82E88148;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E88148 => {
    //   block [0x82E88148..0x82E8815C)
	// 82E88148: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E8814C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82E88150: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82E88154: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E88158: 4198FFCC  blt cr6, 0x82e88124
	if ctx.cr[6].lt {
	pc = 0x82E88124; continue 'dispatch;
	}
	pc = 0x82E8815C; continue 'dispatch;
            }
            0x82E8815C => {
    //   block [0x82E8815C..0x82E88170)
	// 82E8815C: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82E88160: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E88164: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E88168: 40990040  ble cr6, 0x82e881a8
	if !ctx.cr[6].gt {
	pc = 0x82E881A8; continue 'dispatch;
	}
	// 82E8816C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82E88170; continue 'dispatch;
            }
            0x82E88170 => {
    //   block [0x82E88170..0x82E88194)
	// 82E88170: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E88174: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82E88178: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8817C: 41820018  beq 0x82e88194
	if ctx.cr[0].eq {
	pc = 0x82E88194; continue 'dispatch;
	}
	// 82E88180: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E88184: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E88188: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8818C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E88190: 4E800421  bctrl
	ctx.lr = 0x82E88194;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E88194 => {
    //   block [0x82E88194..0x82E881A8)
	// 82E88194: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82E88198: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82E8819C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82E881A0: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E881A4: 4198FFCC  blt cr6, 0x82e88170
	if ctx.cr[6].lt {
	pc = 0x82E88170; continue 'dispatch;
	}
	pc = 0x82E881A8; continue 'dispatch;
            }
            0x82E881A8 => {
    //   block [0x82E881A8..0x82E881D4)
	// 82E881A8: 387F0070  addi r3, r31, 0x70
	ctx.r[3].s64 = ctx.r[31].s64 + 112;
	// 82E881AC: 480311D5  bl 0x82eb9380
	ctx.lr = 0x82E881B0;
	sub_82EB9380(ctx, base);
	// 82E881B0: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82E881B4: 480311CD  bl 0x82eb9380
	ctx.lr = 0x82E881B8;
	sub_82EB9380(ctx, base);
	// 82E881B8: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 82E881BC: 480311C5  bl 0x82eb9380
	ctx.lr = 0x82E881C0;
	sub_82EB9380(ctx, base);
	// 82E881C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E881C4: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82E881C8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E881CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E881D0: 4BE2128C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E881D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E881D8 size=192
    let mut pc: u32 = 0x82E881D8;
    'dispatch: loop {
        match pc {
            0x82E881D8 => {
    //   block [0x82E881D8..0x82E88228)
	// 82E881D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E881DC: 4BE2122D  bl 0x82ca9408
	ctx.lr = 0x82E881E0;
	sub_82CA93D0(ctx, base);
	// 82E881E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E881E4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82E881E8: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82E881EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E881F0: 394A95D8  addi r10, r10, -0x6a28
	ctx.r[10].s64 = ctx.r[10].s64 + -27176;
	// 82E881F4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E881F8: 3929A8F0  addi r9, r9, -0x5710
	ctx.r[9].s64 = ctx.r[9].s64 + -22288;
	// 82E881FC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82E88200: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82E88204: 909F0004  stw r4, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82E88208: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82E8820C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E88210: 93BF0010  stw r29, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 82E88214: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82E88218: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82E8821C: 93BF0014  stw r29, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 82E88220: 93BF0018  stw r29, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 82E88224: 939F0020  stw r28, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[28].u32 ) };
	pc = 0x82E88228; continue 'dispatch;
            }
            0x82E88228 => {
    //   block [0x82E88228..0x82E88254)
	// 82E88228: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8822C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E88230: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E88234: 409AFFF4  bne cr6, 0x82e88228
	if !ctx.cr[6].eq {
	pc = 0x82E88228; continue 'dispatch;
	}
	// 82E88238: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82E8823C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82E88240: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E88244: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 82E88248: 4B78E6E1  bl 0x82616928
	ctx.lr = 0x82E8824C;
	sub_82616928(ctx, base);
	// 82E8824C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E88250: 907F001C  stw r3, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[3].u32 ) };
	pc = 0x82E88254; continue 'dispatch;
            }
            0x82E88254 => {
    //   block [0x82E88254..0x82E88288)
	// 82E88254: 895E0000  lbz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E88258: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82E8825C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E88260: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82E88264: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E88268: 4082FFEC  bne 0x82e88254
	if !ctx.cr[0].eq {
	pc = 0x82E88254; continue 'dispatch;
	}
	// 82E8826C: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82E88270: 4B78E6B9  bl 0x82616928
	ctx.lr = 0x82E88274;
	sub_82616928(ctx, base);
	// 82E88274: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E88278: 41820010  beq 0x82e88288
	if ctx.cr[0].eq {
	pc = 0x82E88288; continue 'dispatch;
	}
	// 82E8827C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E88280: 48004FB1  bl 0x82e8d230
	ctx.lr = 0x82E88284;
	sub_82E8D230(ctx, base);
	// 82E88284: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	pc = 0x82E88288; continue 'dispatch;
            }
            0x82E88288 => {
    //   block [0x82E88288..0x82E88298)
	// 82E88288: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8828C: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82E88290: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E88294: 4BE211C4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E88298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E88298 size=184
    let mut pc: u32 = 0x82E88298;
    'dispatch: loop {
        match pc {
            0x82E88298 => {
    //   block [0x82E88298..0x82E882C8)
	// 82E88298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8829C: 4BE21171  bl 0x82ca940c
	ctx.lr = 0x82E882A0;
	sub_82CA93D0(ctx, base);
	// 82E882A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E882A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E882A8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E882AC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E882B0: 396B95D8  addi r11, r11, -0x6a28
	ctx.r[11].s64 = ctx.r[11].s64 + -27176;
	// 82E882B4: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E882B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E882BC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E882C0: 40990040  ble cr6, 0x82e88300
	if !ctx.cr[6].gt {
	pc = 0x82E88300; continue 'dispatch;
	}
	// 82E882C4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82E882C8; continue 'dispatch;
            }
            0x82E882C8 => {
    //   block [0x82E882C8..0x82E882EC)
	// 82E882C8: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E882CC: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82E882D0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E882D4: 41820018  beq 0x82e882ec
	if ctx.cr[0].eq {
	pc = 0x82E882EC; continue 'dispatch;
	}
	// 82E882D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E882DC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E882E0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E882E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E882E8: 4E800421  bctrl
	ctx.lr = 0x82E882EC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E882EC => {
    //   block [0x82E882EC..0x82E88300)
	// 82E882EC: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E882F0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82E882F4: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82E882F8: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E882FC: 4198FFCC  blt cr6, 0x82e882c8
	if ctx.cr[6].lt {
	pc = 0x82E882C8; continue 'dispatch;
	}
	pc = 0x82E88300; continue 'dispatch;
            }
            0x82E88300 => {
    //   block [0x82E88300..0x82E88334)
	// 82E88300: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E88304: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E88308: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E8830C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E88310: 4E800421  bctrl
	ctx.lr = 0x82E88314;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E88314: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E88318: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8831C: 41820018  beq 0x82e88334
	if ctx.cr[0].eq {
	pc = 0x82E88334; continue 'dispatch;
	}
	// 82E88320: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E88324: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E88328: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8832C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E88330: 4E800421  bctrl
	ctx.lr = 0x82E88334;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E88334 => {
    //   block [0x82E88334..0x82E88350)
	// 82E88334: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82E88338: 48031049  bl 0x82eb9380
	ctx.lr = 0x82E8833C;
	sub_82EB9380(ctx, base);
	// 82E8833C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E88340: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82E88344: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E88348: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8834C: 4BE21110  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E88350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E88350 size=268
    let mut pc: u32 = 0x82E88350;
    'dispatch: loop {
        match pc {
            0x82E88350 => {
    //   block [0x82E88350..0x82E8837C)
	// 82E88350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E88354: 4BE210AD  bl 0x82ca9400
	ctx.lr = 0x82E88358;
	sub_82CA93D0(ctx, base);
	// 82E88358: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8835C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82E88360: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82E88364: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E88368: 807E0064  lwz r3, 0x64(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E8836C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E88370: 4182000C  beq 0x82e8837c
	if ctx.cr[0].eq {
	pc = 0x82E8837C; continue 'dispatch;
	}
	// 82E88374: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E88378: 4BFFF701  bl 0x82e87a78
	ctx.lr = 0x82E8837C;
	sub_82E87A78(ctx, base);
	pc = 0x82E8837C; continue 'dispatch;
            }
            0x82E8837C => {
    //   block [0x82E8837C..0x82E883B4)
	// 82E8837C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E88380: 93BE0064  stw r29, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82E88384: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E88388: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E8838C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E88390: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E88394: 409A0020  bne cr6, 0x82e883b4
	if !ctx.cr[6].eq {
	pc = 0x82E883B4; continue 'dispatch;
	}
	// 82E88398: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8839C: 4BFFF2CD  bl 0x82e87668
	ctx.lr = 0x82E883A0;
	sub_82E87668(ctx, base);
	// 82E883A0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E883A4: 93BA0004  stw r29, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82E883A8: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82E883AC: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E883B0: 480000A0  b 0x82e88450
	pc = 0x82E88450; continue 'dispatch;
            }
            0x82E883B4 => {
    //   block [0x82E883B4..0x82E88414)
	// 82E883B4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E883B8: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E883BC: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82E883C0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82E883C4: 3B8B9128  addi r28, r11, -0x6ed8
	ctx.r[28].s64 = ctx.r[11].s64 + -28376;
	// 82E883C8: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82E883CC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E883D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E883D4: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82E883D8: 4BFED2F1  bl 0x82e756c8
	ctx.lr = 0x82E883DC;
	sub_82E756C8(ctx, base);
	// 82E883DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E883E0: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E883E4: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82E883E8: 915E006C  stw r10, 0x6c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 82E883EC: 93FE0064  stw r31, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82E883F0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E883F4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82E883F8: 4BFFF271  bl 0x82e87668
	ctx.lr = 0x82E883FC;
	sub_82E87668(ctx, base);
	// 82E883FC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E88400: 3BEB0070  addi r31, r11, 0x70
	ctx.r[31].s64 = ctx.r[11].s64 + 112;
	// 82E88404: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E88408: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8840C: 40990038  ble cr6, 0x82e88444
	if !ctx.cr[6].gt {
	pc = 0x82E88444; continue 'dispatch;
	}
	// 82E88410: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	pc = 0x82E88414; continue 'dispatch;
            }
            0x82E88414 => {
    //   block [0x82E88414..0x82E88444)
	// 82E88414: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E88418: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8841C: 7C7B582E  lwzx r3, r27, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82E88420: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E88424: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E88428: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8842C: 4E800421  bctrl
	ctx.lr = 0x82E88430;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E88430: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E88434: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82E88438: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82E8843C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E88440: 4198FFD4  blt cr6, 0x82e88414
	if ctx.cr[6].lt {
	pc = 0x82E88414; continue 'dispatch;
	}
            }
            0x82E88444 => {
    //   block [0x82E88444..0x82E88450)
	// 82E88444: 817E006C  lwz r11, 0x6c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 82E88448: 939A0000  stw r28, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82E8844C: 917A0004  stw r11, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82E88450; continue 'dispatch;
            }
            0x82E88450 => {
    //   block [0x82E88450..0x82E8845C)
	// 82E88450: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82E88454: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E88458: 4BE20FF8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E88460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E88460 size=100
    let mut pc: u32 = 0x82E88460;
    'dispatch: loop {
        match pc {
            0x82E88460 => {
    //   block [0x82E88460..0x82E88498)
	// 82E88460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E88464: 4BE20FA5  bl 0x82ca9408
	ctx.lr = 0x82E88468;
	sub_82CA93D0(ctx, base);
	// 82E88468: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8846C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E88470: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82E88474: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82E88478: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E8847C: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E88480: 4BFFF9A9  bl 0x82e87e28
	ctx.lr = 0x82E88484;
	sub_82E87E28(ctx, base);
	// 82E88484: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E88488: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82E8848C: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E88490: 40980028  bge cr6, 0x82e884b8
	if !ctx.cr[6].lt {
	pc = 0x82E884B8; continue 'dispatch;
	}
	// 82E88494: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	pc = 0x82E88498; continue 'dispatch;
            }
            0x82E88498 => {
    //   block [0x82E88498..0x82E884B8)
	// 82E88498: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8849C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E884A0: 811C0000  lwz r8, 0(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E884A4: 7D0A492E  stwx r8, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[8].u32) };
	// 82E884A8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82E884AC: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E884B0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E884B4: 4198FFE4  blt cr6, 0x82e88498
	if ctx.cr[6].lt {
	pc = 0x82E88498; continue 'dispatch;
	}
	pc = 0x82E884B8; continue 'dispatch;
            }
            0x82E884B8 => {
    //   block [0x82E884B8..0x82E884C4)
	// 82E884B8: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82E884BC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E884C0: 4BE20F98  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E884C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E884C8 size=160
    let mut pc: u32 = 0x82E884C8;
    'dispatch: loop {
        match pc {
            0x82E884C8 => {
    //   block [0x82E884C8..0x82E884FC)
	// 82E884C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E884CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E884D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E884D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E884D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E884DC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E884E0: 419A0064  beq cr6, 0x82e88544
	if ctx.cr[6].eq {
	pc = 0x82E88544; continue 'dispatch;
	}
	// 82E884E4: 4BFFDBE5  bl 0x82e860c8
	ctx.lr = 0x82E884E8;
	sub_82E860C8(ctx, base);
	// 82E884E8: 80A30400  lwz r5, 0x400(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E884EC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82E884F0: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E884F4: 40810050  ble 0x82e88544
	if !ctx.cr[0].gt {
	pc = 0x82E88544; continue 'dispatch;
	}
	// 82E884F8: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x82E884FC; continue 'dispatch;
            }
            0x82E884FC => {
    //   block [0x82E884FC..0x82E88508)
	// 82E884FC: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E88500: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82E88504: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	pc = 0x82E88508; continue 'dispatch;
            }
            0x82E88508 => {
    //   block [0x82E88508..0x82E8852C)
	// 82E88508: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8850C: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E88510: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E88514: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82E88518: 41820014  beq 0x82e8852c
	if ctx.cr[0].eq {
	pc = 0x82E8852C; continue 'dispatch;
	}
	// 82E8851C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E88520: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E88524: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82E88528: 419AFFE0  beq cr6, 0x82e88508
	if ctx.cr[6].eq {
	pc = 0x82E88508; continue 'dispatch;
	}
	pc = 0x82E8852C; continue 'dispatch;
            }
            0x82E8852C => {
    //   block [0x82E8852C..0x82E88544)
	// 82E8852C: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E88530: 4182002C  beq 0x82e8855c
	if ctx.cr[0].eq {
	pc = 0x82E8855C; continue 'dispatch;
	}
	// 82E88534: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82E88538: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82E8853C: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82E88540: 4198FFBC  blt cr6, 0x82e884fc
	if ctx.cr[6].lt {
	pc = 0x82E884FC; continue 'dispatch;
	}
	pc = 0x82E88544; continue 'dispatch;
            }
            0x82E88544 => {
    //   block [0x82E88544..0x82E88548)
	// 82E88544: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E88548; continue 'dispatch;
            }
            0x82E88548 => {
    //   block [0x82E88548..0x82E8855C)
	// 82E88548: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8854C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E88550: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E88554: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E88558: 4E800020  blr
	return;
            }
            0x82E8855C => {
    //   block [0x82E8855C..0x82E88568)
	// 82E8855C: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E88560: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82E88564: 4BFFFFE4  b 0x82e88548
	pc = 0x82E88548; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E88568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E88568 size=160
    let mut pc: u32 = 0x82E88568;
    'dispatch: loop {
        match pc {
            0x82E88568 => {
    //   block [0x82E88568..0x82E8859C)
	// 82E88568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8856C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E88570: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E88574: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E88578: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8857C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E88580: 419A0064  beq cr6, 0x82e885e4
	if ctx.cr[6].eq {
	pc = 0x82E885E4; continue 'dispatch;
	}
	// 82E88584: 4BFFE2AD  bl 0x82e86830
	ctx.lr = 0x82E88588;
	sub_82E86830(ctx, base);
	// 82E88588: 80A30400  lwz r5, 0x400(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E8858C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82E88590: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E88594: 40810050  ble 0x82e885e4
	if !ctx.cr[0].gt {
	pc = 0x82E885E4; continue 'dispatch;
	}
	// 82E88598: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x82E8859C; continue 'dispatch;
            }
            0x82E8859C => {
    //   block [0x82E8859C..0x82E885A8)
	// 82E8859C: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E885A0: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82E885A4: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	pc = 0x82E885A8; continue 'dispatch;
            }
            0x82E885A8 => {
    //   block [0x82E885A8..0x82E885CC)
	// 82E885A8: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E885AC: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E885B0: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E885B4: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82E885B8: 41820014  beq 0x82e885cc
	if ctx.cr[0].eq {
	pc = 0x82E885CC; continue 'dispatch;
	}
	// 82E885BC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E885C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E885C4: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82E885C8: 419AFFE0  beq cr6, 0x82e885a8
	if ctx.cr[6].eq {
	pc = 0x82E885A8; continue 'dispatch;
	}
	pc = 0x82E885CC; continue 'dispatch;
            }
            0x82E885CC => {
    //   block [0x82E885CC..0x82E885E4)
	// 82E885CC: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E885D0: 4182002C  beq 0x82e885fc
	if ctx.cr[0].eq {
	pc = 0x82E885FC; continue 'dispatch;
	}
	// 82E885D4: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82E885D8: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82E885DC: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82E885E0: 4198FFBC  blt cr6, 0x82e8859c
	if ctx.cr[6].lt {
	pc = 0x82E8859C; continue 'dispatch;
	}
	pc = 0x82E885E4; continue 'dispatch;
            }
            0x82E885E4 => {
    //   block [0x82E885E4..0x82E885E8)
	// 82E885E4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E885E8; continue 'dispatch;
            }
            0x82E885E8 => {
    //   block [0x82E885E8..0x82E885FC)
	// 82E885E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E885EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E885F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E885F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E885F8: 4E800020  blr
	return;
            }
            0x82E885FC => {
    //   block [0x82E885FC..0x82E88608)
	// 82E885FC: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E88600: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82E88604: 4BFFFFE4  b 0x82e885e8
	pc = 0x82E885E8; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E88608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E88608 size=56
    let mut pc: u32 = 0x82E88608;
    'dispatch: loop {
        match pc {
            0x82E88608 => {
    //   block [0x82E88608..0x82E8862C)
	// 82E88608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8860C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E88610: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E88614: 386000CC  li r3, 0xcc
	ctx.r[3].s64 = 204;
	// 82E88618: 4B78E311  bl 0x82616928
	ctx.lr = 0x82E8861C;
	sub_82616928(ctx, base);
	// 82E8861C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E88620: 4182000C  beq 0x82e8862c
	if ctx.cr[0].eq {
	pc = 0x82E8862C; continue 'dispatch;
	}
	// 82E88624: 4BFFF905  bl 0x82e87f28
	ctx.lr = 0x82E88628;
	sub_82E87F28(ctx, base);
	// 82E88628: 48000008  b 0x82e88630
	pc = 0x82E88630; continue 'dispatch;
            }
            0x82E8862C => {
    //   block [0x82E8862C..0x82E88630)
	// 82E8862C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E88630; continue 'dispatch;
            }
            0x82E88630 => {
    //   block [0x82E88630..0x82E88640)
	// 82E88630: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E88634: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E88638: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8863C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E88640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E88640 size=88
    let mut pc: u32 = 0x82E88640;
    'dispatch: loop {
        match pc {
            0x82E88640 => {
    //   block [0x82E88640..0x82E8867C)
	// 82E88640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E88644: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E88648: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8864C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E88650: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E88654: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E88658: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8865C: 4BFFFA4D  bl 0x82e880a8
	ctx.lr = 0x82E88660;
	sub_82E880A8(ctx, base);
	// 82E88660: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E88664: 41820018  beq 0x82e8867c
	if ctx.cr[0].eq {
	pc = 0x82E8867C; continue 'dispatch;
	}
	// 82E88668: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E8866C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E88670: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E88674: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E88678: 4E800421  bctrl
	ctx.lr = 0x82E8867C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8867C => {
    //   block [0x82E8867C..0x82E88698)
	// 82E8867C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E88680: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E88684: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E88688: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8868C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E88690: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E88694: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E88698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E88698 size=340
    let mut pc: u32 = 0x82E88698;
    'dispatch: loop {
        match pc {
            0x82E88698 => {
    //   block [0x82E88698..0x82E886E0)
	// 82E88698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8869C: 4BE20D61  bl 0x82ca93fc
	ctx.lr = 0x82E886A0;
	sub_82CA93D0(ctx, base);
	// 82E886A0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E886A4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E886A8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82E886AC: 419A0134  beq cr6, 0x82e887e0
	if ctx.cr[6].eq {
	pc = 0x82E887E0; continue 'dispatch;
	}
	// 82E886B0: 3B230060  addi r25, r3, 0x60
	ctx.r[25].s64 = ctx.r[3].s64 + 96;
	// 82E886B4: 809D0020  lwz r4, 0x20(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E886B8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82E886BC: 48030B1D  bl 0x82eb91d8
	ctx.lr = 0x82E886C0;
	sub_82EB91D8(ctx, base);
	// 82E886C0: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E886C4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82E886C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E886CC: 40990114  ble cr6, 0x82e887e0
	if !ctx.cr[6].gt {
	pc = 0x82E887E0; continue 'dispatch;
	}
	// 82E886D0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E886D4: 3B4B8FD8  addi r26, r11, -0x7028
	ctx.r[26].s64 = ctx.r[11].s64 + -28712;
	// 82E886D8: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82E886DC: 3B6B87C4  addi r27, r11, -0x783c
	ctx.r[27].s64 = ctx.r[11].s64 + -30780;
	pc = 0x82E886E0; continue 'dispatch;
            }
            0x82E886E0 => {
    //   block [0x82E886E0..0x82E8875C)
	// 82E886E0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E886E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E886E8: 4BFFB941  bl 0x82e84028
	ctx.lr = 0x82E886EC;
	sub_82E84028(ctx, base);
	// 82E886EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E886F0: 48333971  bl 0x831bc060
	ctx.lr = 0x82E886F4;
	sub_831BC060(ctx, base);
	// 82E886F4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E886F8: 4BE24459  bl 0x82cacb50
	ctx.lr = 0x82E886FC;
	sub_82CACB50(ctx, base);
	// 82E886FC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E88700: 408200D0  bne 0x82e887d0
	if !ctx.cr[0].eq {
	pc = 0x82E887D0; continue 'dispatch;
	}
	// 82E88704: 83FE000C  lwz r31, 0xc(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E88708: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8870C: 418200C4  beq 0x82e887d0
	if ctx.cr[0].eq {
	pc = 0x82E887D0; continue 'dispatch;
	}
	// 82E88710: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E88714: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E88718: 419A00B8  beq cr6, 0x82e887d0
	if ctx.cr[6].eq {
	pc = 0x82E887D0; continue 'dispatch;
	}
	// 82E8871C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E88720: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82E88724: 4BFFB7F5  bl 0x82e83f18
	ctx.lr = 0x82E88728;
	sub_82E83F18(ctx, base);
	// 82E88728: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8872C: 418200A4  beq 0x82e887d0
	if ctx.cr[0].eq {
	pc = 0x82E887D0; continue 'dispatch;
	}
	// 82E88730: 4BA855D9  bl 0x8290dd08
	ctx.lr = 0x82E88734;
	sub_8290DD08(ctx, base);
	// 82E88734: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E88738: 41820098  beq 0x82e887d0
	if ctx.cr[0].eq {
	pc = 0x82E887D0; continue 'dispatch;
	}
	// 82E8873C: 4BFFFD8D  bl 0x82e884c8
	ctx.lr = 0x82E88740;
	sub_82E884C8(ctx, base);
	// 82E88740: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E88744: 40820030  bne 0x82e88774
	if !ctx.cr[0].eq {
	pc = 0x82E88774; continue 'dispatch;
	}
	// 82E88748: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82E8874C: 4BFFD97D  bl 0x82e860c8
	ctx.lr = 0x82E88750;
	sub_82E860C8(ctx, base);
	// 82E88750: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E88754: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E88758: 40990078  ble cr6, 0x82e887d0
	if !ctx.cr[6].gt {
	pc = 0x82E887D0; continue 'dispatch;
	}
	pc = 0x82E8875C; continue 'dispatch;
            }
            0x82E8875C => {
    //   block [0x82E8875C..0x82E88774)
	// 82E8875C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82E88760: 4BFFD969  bl 0x82e860c8
	ctx.lr = 0x82E88764;
	sub_82E860C8(ctx, base);
	// 82E88764: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E88768: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82E8876C: 4198FFF0  blt cr6, 0x82e8875c
	if ctx.cr[6].lt {
	pc = 0x82E8875C; continue 'dispatch;
	}
	// 82E88770: 48000060  b 0x82e887d0
	pc = 0x82E887D0; continue 'dispatch;
            }
            0x82E88774 => {
    //   block [0x82E88774..0x82E887C4)
	// 82E88774: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E88778: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8877C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E88780: 4E800421  bctrl
	ctx.lr = 0x82E88784;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E88784: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E88788: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8878C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E88790: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82E88794: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E88798: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8879C: 4E800421  bctrl
	ctx.lr = 0x82E887A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E887A0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E887A4: 40820020  bne 0x82e887c4
	if !ctx.cr[0].eq {
	pc = 0x82E887C4; continue 'dispatch;
	}
	// 82E887A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E887AC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E887B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E887B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E887B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E887BC: 4E800421  bctrl
	ctx.lr = 0x82E887C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E887C0: 48000010  b 0x82e887d0
	pc = 0x82E887D0; continue 'dispatch;
            }
            0x82E887C4 => {
    //   block [0x82E887C4..0x82E887D0)
	// 82E887C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E887C8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82E887CC: 48030AC5  bl 0x82eb9290
	ctx.lr = 0x82E887D0;
	sub_82EB9290(ctx, base);
	pc = 0x82E887D0; continue 'dispatch;
            }
            0x82E887D0 => {
    //   block [0x82E887D0..0x82E887E0)
	// 82E887D0: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E887D4: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82E887D8: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E887DC: 4198FF04  blt cr6, 0x82e886e0
	if ctx.cr[6].lt {
	pc = 0x82E886E0; continue 'dispatch;
	}
	pc = 0x82E887E0; continue 'dispatch;
            }
            0x82E887E0 => {
    //   block [0x82E887E0..0x82E887EC)
	// 82E887E0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E887E4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E887E8: 4BE20C64  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E887F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E887F0 size=236
    let mut pc: u32 = 0x82E887F0;
    'dispatch: loop {
        match pc {
            0x82E887F0 => {
    //   block [0x82E887F0..0x82E88838)
	// 82E887F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E887F4: 4BE20C01  bl 0x82ca93f4
	ctx.lr = 0x82E887F8;
	sub_82CA93D0(ctx, base);
	// 82E887F8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E887FC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82E88800: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E88804: 3B3B0050  addi r25, r27, 0x50
	ctx.r[25].s64 = ctx.r[27].s64 + 80;
	// 82E88808: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82E8880C: 809D0020  lwz r4, 0x20(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E88810: 480309C9  bl 0x82eb91d8
	ctx.lr = 0x82E88814;
	sub_82EB91D8(ctx, base);
	// 82E88814: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E88818: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82E8881C: 7EFCBB78  mr r28, r23
	ctx.r[28].u64 = ctx.r[23].u64;
	// 82E88820: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E88824: 409900AC  ble cr6, 0x82e888d0
	if !ctx.cr[6].gt {
	pc = 0x82E888D0; continue 'dispatch;
	}
	// 82E88828: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8882C: 3B0B95DC  addi r24, r11, -0x6a24
	ctx.r[24].s64 = ctx.r[11].s64 + -27172;
	// 82E88830: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E88834: 3B4B9158  addi r26, r11, -0x6ea8
	ctx.r[26].s64 = ctx.r[11].s64 + -28328;
	pc = 0x82E88838; continue 'dispatch;
            }
            0x82E88838 => {
    //   block [0x82E88838..0x82E888B0)
	// 82E88838: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E8883C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E88840: 4BFFB7E9  bl 0x82e84028
	ctx.lr = 0x82E88844;
	sub_82E84028(ctx, base);
	// 82E88844: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E88848: 48333819  bl 0x831bc060
	ctx.lr = 0x82E8884C;
	sub_831BC060(ctx, base);
	// 82E8884C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82E88850: 4BE24301  bl 0x82cacb50
	ctx.lr = 0x82E88854;
	sub_82CACB50(ctx, base);
	// 82E88854: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E88858: 40820068  bne 0x82e888c0
	if !ctx.cr[0].eq {
	pc = 0x82E888C0; continue 'dispatch;
	}
	// 82E8885C: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E88860: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E88864: 4182005C  beq 0x82e888c0
	if ctx.cr[0].eq {
	pc = 0x82E888C0; continue 'dispatch;
	}
	// 82E88868: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8886C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82E88870: 4BFFB6A9  bl 0x82e83f18
	ctx.lr = 0x82E88874;
	sub_82E83F18(ctx, base);
	// 82E88874: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E88878: 41820038  beq 0x82e888b0
	if ctx.cr[0].eq {
	pc = 0x82E888B0; continue 'dispatch;
	}
	// 82E8887C: 4BA8548D  bl 0x8290dd08
	ctx.lr = 0x82E88880;
	sub_8290DD08(ctx, base);
	// 82E88880: 4BE21B41  bl 0x82caa3c0
	ctx.lr = 0x82E88884;
	sub_82CAA3C0(ctx, base);
	// 82E88884: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E88888: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 82E8888C: 4B78E09D  bl 0x82616928
	ctx.lr = 0x82E88890;
	sub_82616928(ctx, base);
	// 82E88890: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E88894: 4182001C  beq 0x82e888b0
	if ctx.cr[0].eq {
	pc = 0x82E888B0; continue 'dispatch;
	}
	// 82E88898: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82E8889C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E888A0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E888A4: 4BFFF935  bl 0x82e881d8
	ctx.lr = 0x82E888A8;
	sub_82E881D8(ctx, base);
	// 82E888A8: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82E888AC: 48000008  b 0x82e888b4
	pc = 0x82E888B4; continue 'dispatch;
            }
            0x82E888B0 => {
    //   block [0x82E888B0..0x82E888B4)
	// 82E888B0: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	pc = 0x82E888B4; continue 'dispatch;
            }
            0x82E888B4 => {
    //   block [0x82E888B4..0x82E888C0)
	// 82E888B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E888B8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82E888BC: 480309D5  bl 0x82eb9290
	ctx.lr = 0x82E888C0;
	sub_82EB9290(ctx, base);
	pc = 0x82E888C0; continue 'dispatch;
            }
            0x82E888C0 => {
    //   block [0x82E888C0..0x82E888D0)
	// 82E888C0: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E888C4: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82E888C8: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E888CC: 4198FF6C  blt cr6, 0x82e88838
	if ctx.cr[6].lt {
	pc = 0x82E88838; continue 'dispatch;
	}
	pc = 0x82E888D0; continue 'dispatch;
            }
            0x82E888D0 => {
    //   block [0x82E888D0..0x82E888DC)
	// 82E888D0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E888D4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82E888D8: 4BE20B6C  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E888E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E888E0 size=88
    let mut pc: u32 = 0x82E888E0;
    'dispatch: loop {
        match pc {
            0x82E888E0 => {
    //   block [0x82E888E0..0x82E8891C)
	// 82E888E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E888E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E888E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E888EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E888F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E888F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E888F8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E888FC: 4BFFF99D  bl 0x82e88298
	ctx.lr = 0x82E88900;
	sub_82E88298(ctx, base);
	// 82E88900: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E88904: 41820018  beq 0x82e8891c
	if ctx.cr[0].eq {
	pc = 0x82E8891C; continue 'dispatch;
	}
	// 82E88908: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E8890C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E88910: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E88914: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E88918: 4E800421  bctrl
	ctx.lr = 0x82E8891C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8891C => {
    //   block [0x82E8891C..0x82E88938)
	// 82E8891C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E88920: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E88924: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E88928: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8892C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E88930: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E88934: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E88938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E88938 size=692
    let mut pc: u32 = 0x82E88938;
    'dispatch: loop {
        match pc {
            0x82E88938 => {
    //   block [0x82E88938..0x82E88990)
	// 82E88938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8893C: 4BE20AA9  bl 0x82ca93e4
	ctx.lr = 0x82E88940;
	sub_82CA93D0(ctx, base);
	// 82E88940: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E88944: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E88948: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 82E8894C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82E88950: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82E88954: 7CD43378  mr r20, r6
	ctx.r[20].u64 = ctx.r[6].u64;
	// 82E88958: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82E8895C: 4BFFDED5  bl 0x82e86830
	ctx.lr = 0x82E88960;
	sub_82E86830(ctx, base);
	// 82E88960: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E88964: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82E88968: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E8896C: 387A000C  addi r3, r26, 0xc
	ctx.r[3].s64 = ctx.r[26].s64 + 12;
	// 82E88970: 808B0400  lwz r4, 0x400(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E88974: 4BFFFAED  bl 0x82e88460
	ctx.lr = 0x82E88978;
	sub_82E88460(ctx, base);
	// 82E88978: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E8897C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E88980: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E88984: 4099025C  ble cr6, 0x82e88be0
	if !ctx.cr[6].gt {
	pc = 0x82E88BE0; continue 'dispatch;
	}
	// 82E88988: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8898C: 3BAB95A4  addi r29, r11, -0x6a5c
	ctx.r[29].s64 = ctx.r[11].s64 + -27228;
	pc = 0x82E88990; continue 'dispatch;
            }
            0x82E88990 => {
    //   block [0x82E88990..0x82E889C0)
	// 82E88990: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E88994: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E88998: 4BFFB691  bl 0x82e84028
	ctx.lr = 0x82E8899C;
	sub_82E84028(ctx, base);
	// 82E8899C: 7C781B79  or. r24, r3, r3
	ctx.r[24].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 82E889A0: 41820020  beq 0x82e889c0
	if ctx.cr[0].eq {
	pc = 0x82E889C0; continue 'dispatch;
	}
	// 82E889A4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82E889A8: 483336B9  bl 0x831bc060
	ctx.lr = 0x82E889AC;
	sub_831BC060(ctx, base);
	// 82E889AC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E889B0: 4BE241A1  bl 0x82cacb50
	ctx.lr = 0x82E889B4;
	sub_82CACB50(ctx, base);
	// 82E889B4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E889B8: 41820018  beq 0x82e889d0
	if ctx.cr[0].eq {
	pc = 0x82E889D0; continue 'dispatch;
	}
	// 82E889BC: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	pc = 0x82E889C0; continue 'dispatch;
            }
            0x82E889C0 => {
    //   block [0x82E889C0..0x82E889D0)
	// 82E889C0: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E889C4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82E889C8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E889CC: 4198FFC4  blt cr6, 0x82e88990
	if ctx.cr[6].lt {
	pc = 0x82E88990; continue 'dispatch;
	}
	pc = 0x82E889D0; continue 'dispatch;
            }
            0x82E889D0 => {
    //   block [0x82E889D0..0x82E88A00)
	// 82E889D0: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82E889D4: 419A020C  beq cr6, 0x82e88be0
	if ctx.cr[6].eq {
	pc = 0x82E88BE0; continue 'dispatch;
	}
	// 82E889D8: 81780020  lwz r11, 0x20(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E889DC: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 82E889E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E889E4: 409901FC  ble cr6, 0x82e88be0
	if !ctx.cr[6].gt {
	pc = 0x82E88BE0; continue 'dispatch;
	}
	// 82E889E8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E889EC: 3AEB8FD8  addi r23, r11, -0x7028
	ctx.r[23].s64 = ctx.r[11].s64 + -28712;
	// 82E889F0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82E889F4: 3AAB2DF8  addi r21, r11, 0x2df8
	ctx.r[21].s64 = ctx.r[11].s64 + 11768;
	// 82E889F8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E889FC: 3B2B95E8  addi r25, r11, -0x6a18
	ctx.r[25].s64 = ctx.r[11].s64 + -27160;
	pc = 0x82E88A00; continue 'dispatch;
            }
            0x82E88A00 => {
    //   block [0x82E88A00..0x82E88A44)
	// 82E88A00: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82E88A04: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82E88A08: 4BFFB621  bl 0x82e84028
	ctx.lr = 0x82E88A0C;
	sub_82E84028(ctx, base);
	// 82E88A0C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82E88A10: 48333651  bl 0x831bc060
	ctx.lr = 0x82E88A14;
	sub_831BC060(ctx, base);
	// 82E88A14: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E88A18: 418201B8  beq 0x82e88bd0
	if ctx.cr[0].eq {
	pc = 0x82E88BD0; continue 'dispatch;
	}
	// 82E88A1C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E88A20: 48333641  bl 0x831bc060
	ctx.lr = 0x82E88A24;
	sub_831BC060(ctx, base);
	// 82E88A24: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82E88A28: 4BE24129  bl 0x82cacb50
	ctx.lr = 0x82E88A2C;
	sub_82CACB50(ctx, base);
	// 82E88A2C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E88A30: 408201A0  bne 0x82e88bd0
	if !ctx.cr[0].eq {
	pc = 0x82E88BD0; continue 'dispatch;
	}
	// 82E88A34: 817C0020  lwz r11, 0x20(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E88A38: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82E88A3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E88A40: 40990190  ble cr6, 0x82e88bd0
	if !ctx.cr[6].gt {
	pc = 0x82E88BD0; continue 'dispatch;
	}
	pc = 0x82E88A44; continue 'dispatch;
            }
            0x82E88A44 => {
    //   block [0x82E88A44..0x82E88A70)
	// 82E88A44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E88A48: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E88A4C: 4BFFB5DD  bl 0x82e84028
	ctx.lr = 0x82E88A50;
	sub_82E84028(ctx, base);
	// 82E88A50: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82E88A54: 4182001C  beq 0x82e88a70
	if ctx.cr[0].eq {
	pc = 0x82E88A70; continue 'dispatch;
	}
	// 82E88A58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E88A5C: 48333605  bl 0x831bc060
	ctx.lr = 0x82E88A60;
	sub_831BC060(ctx, base);
	// 82E88A60: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82E88A64: 4BE240ED  bl 0x82cacb50
	ctx.lr = 0x82E88A68;
	sub_82CACB50(ctx, base);
	// 82E88A68: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E88A6C: 41820018  beq 0x82e88a84
	if ctx.cr[0].eq {
	pc = 0x82E88A84; continue 'dispatch;
	}
	pc = 0x82E88A70; continue 'dispatch;
            }
            0x82E88A70 => {
    //   block [0x82E88A70..0x82E88A84)
	// 82E88A70: 817C0020  lwz r11, 0x20(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E88A74: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82E88A78: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E88A7C: 4198FFC8  blt cr6, 0x82e88a44
	if ctx.cr[6].lt {
	pc = 0x82E88A44; continue 'dispatch;
	}
	// 82E88A80: 48000150  b 0x82e88bd0
	pc = 0x82E88BD0; continue 'dispatch;
            }
            0x82E88A84 => {
    //   block [0x82E88A84..0x82E88AA4)
	// 82E88A84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E88A88: 4BA85281  bl 0x8290dd08
	ctx.lr = 0x82E88A8C;
	sub_8290DD08(ctx, base);
	// 82E88A8C: 7C7B1B79  or. r27, r3, r3
	ctx.r[27].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82E88A90: 41820140  beq 0x82e88bd0
	if ctx.cr[0].eq {
	pc = 0x82E88BD0; continue 'dispatch;
	}
	// 82E88A94: 81740020  lwz r11, 0x20(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E88A98: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82E88A9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E88AA0: 40990130  ble cr6, 0x82e88bd0
	if !ctx.cr[6].gt {
	pc = 0x82E88BD0; continue 'dispatch;
	}
	pc = 0x82E88AA4; continue 'dispatch;
            }
            0x82E88AA4 => {
    //   block [0x82E88AA4..0x82E88AE4)
	// 82E88AA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E88AA8: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 82E88AAC: 4BFFB57D  bl 0x82e84028
	ctx.lr = 0x82E88AB0;
	sub_82E84028(ctx, base);
	// 82E88AB0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E88AB4: 483335AD  bl 0x831bc060
	ctx.lr = 0x82E88AB8;
	sub_831BC060(ctx, base);
	// 82E88AB8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82E88ABC: 4BE24095  bl 0x82cacb50
	ctx.lr = 0x82E88AC0;
	sub_82CACB50(ctx, base);
	// 82E88AC0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E88AC4: 40820020  bne 0x82e88ae4
	if !ctx.cr[0].eq {
	pc = 0x82E88AE4; continue 'dispatch;
	}
	// 82E88AC8: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E88ACC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E88AD0: 41820014  beq 0x82e88ae4
	if ctx.cr[0].eq {
	pc = 0x82E88AE4; continue 'dispatch;
	}
	// 82E88AD4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E88AD8: 4BE24079  bl 0x82cacb50
	ctx.lr = 0x82E88ADC;
	sub_82CACB50(ctx, base);
	// 82E88ADC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E88AE0: 41820018  beq 0x82e88af8
	if ctx.cr[0].eq {
	pc = 0x82E88AF8; continue 'dispatch;
	}
	pc = 0x82E88AE4; continue 'dispatch;
            }
            0x82E88AE4 => {
    //   block [0x82E88AE4..0x82E88AF8)
	// 82E88AE4: 81740020  lwz r11, 0x20(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E88AE8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82E88AEC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E88AF0: 4198FFB4  blt cr6, 0x82e88aa4
	if ctx.cr[6].lt {
	pc = 0x82E88AA4; continue 'dispatch;
	}
	// 82E88AF4: 480000DC  b 0x82e88bd0
	pc = 0x82E88BD0; continue 'dispatch;
            }
            0x82E88AF8 => {
    //   block [0x82E88AF8..0x82E88B38)
	// 82E88AF8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E88AFC: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82E88B00: 4BFFB419  bl 0x82e83f18
	ctx.lr = 0x82E88B04;
	sub_82E83F18(ctx, base);
	// 82E88B04: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E88B08: 418200C8  beq 0x82e88bd0
	if ctx.cr[0].eq {
	pc = 0x82E88BD0; continue 'dispatch;
	}
	// 82E88B0C: 4BA851FD  bl 0x8290dd08
	ctx.lr = 0x82E88B10;
	sub_8290DD08(ctx, base);
	// 82E88B10: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E88B14: 418200BC  beq 0x82e88bd0
	if ctx.cr[0].eq {
	pc = 0x82E88BD0; continue 'dispatch;
	}
	// 82E88B18: 4BFFFA51  bl 0x82e88568
	ctx.lr = 0x82E88B1C;
	sub_82E88568(ctx, base);
	// 82E88B1C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82E88B20: 40820030  bne 0x82e88b50
	if !ctx.cr[0].eq {
	pc = 0x82E88B50; continue 'dispatch;
	}
	// 82E88B24: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82E88B28: 4BFFDD09  bl 0x82e86830
	ctx.lr = 0x82E88B2C;
	sub_82E86830(ctx, base);
	// 82E88B2C: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E88B30: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E88B34: 4099009C  ble cr6, 0x82e88bd0
	if !ctx.cr[6].gt {
	pc = 0x82E88BD0; continue 'dispatch;
	}
	pc = 0x82E88B38; continue 'dispatch;
            }
            0x82E88B38 => {
    //   block [0x82E88B38..0x82E88B50)
	// 82E88B38: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82E88B3C: 4BFFDCF5  bl 0x82e86830
	ctx.lr = 0x82E88B40;
	sub_82E86830(ctx, base);
	// 82E88B40: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E88B44: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82E88B48: 4198FFF0  blt cr6, 0x82e88b38
	if ctx.cr[6].lt {
	pc = 0x82E88B38; continue 'dispatch;
	}
	// 82E88B4C: 48000084  b 0x82e88bd0
	pc = 0x82E88BD0; continue 'dispatch;
            }
            0x82E88B50 => {
    //   block [0x82E88B50..0x82E88BC0)
	// 82E88B50: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E88B54: 815A0010  lwz r10, 0x10(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E88B58: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E88B5C: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E88B60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E88B64: 409A006C  bne cr6, 0x82e88bd0
	if !ctx.cr[6].eq {
	pc = 0x82E88BD0; continue 'dispatch;
	}
	// 82E88B68: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E88B6C: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82E88B70: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 82E88B74: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82E88B78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E88B7C: 4E800421  bctrl
	ctx.lr = 0x82E88B80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E88B80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E88B84: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82E88B88: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E88B8C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E88B90: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E88B94: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E88B98: 4E800421  bctrl
	ctx.lr = 0x82E88B9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E88B9C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E88BA0: 40820020  bne 0x82e88bc0
	if !ctx.cr[0].eq {
	pc = 0x82E88BC0; continue 'dispatch;
	}
	// 82E88BA4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E88BA8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E88BAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E88BB0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E88BB4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E88BB8: 4E800421  bctrl
	ctx.lr = 0x82E88BBC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E88BBC: 48000014  b 0x82e88bd0
	pc = 0x82E88BD0; continue 'dispatch;
            }
            0x82E88BC0 => {
    //   block [0x82E88BC0..0x82E88BD0)
	// 82E88BC0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E88BC4: 815A0010  lwz r10, 0x10(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E88BC8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E88BCC: 7FEB512E  stwx r31, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[31].u32) };
	pc = 0x82E88BD0; continue 'dispatch;
            }
            0x82E88BD0 => {
    //   block [0x82E88BD0..0x82E88BE0)
	// 82E88BD0: 81780020  lwz r11, 0x20(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E88BD4: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	// 82E88BD8: 7F165840  cmplw cr6, r22, r11
	ctx.cr[6].compare_u32(ctx.r[22].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E88BDC: 4198FE24  blt cr6, 0x82e88a00
	if ctx.cr[6].lt {
	pc = 0x82E88A00; continue 'dispatch;
	}
	pc = 0x82E88BE0; continue 'dispatch;
            }
            0x82E88BE0 => {
    //   block [0x82E88BE0..0x82E88BEC)
	// 82E88BE0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E88BE4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82E88BE8: 4BE2084C  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E88BF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E88BF0 size=888
    let mut pc: u32 = 0x82E88BF0;
    'dispatch: loop {
        match pc {
            0x82E88BF0 => {
    //   block [0x82E88BF0..0x82E88C18)
	// 82E88BF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E88BF4: 4BE207F9  bl 0x82ca93ec
	ctx.lr = 0x82E88BF8;
	sub_82CA93D0(ctx, base);
	// 82E88BF8: DBC1FF90  stfd f30, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[30].u64 ) };
	// 82E88BFC: DBE1FF98  stfd f31, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 82E88C00: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E88C04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E88C08: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E88C0C: 4BFFC79D  bl 0x82e853a8
	ctx.lr = 0x82E88C10;
	sub_82E853A8(ctx, base);
	// 82E88C10: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E88C14: 4082000C  bne 0x82e88c20
	if !ctx.cr[0].eq {
	pc = 0x82E88C20; continue 'dispatch;
	}
	pc = 0x82E88C18; continue 'dispatch;
            }
            0x82E88C18 => {
    //   block [0x82E88C18..0x82E88C20)
	// 82E88C18: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E88C1C: 4800033C  b 0x82e88f58
	pc = 0x82E88F58; continue 'dispatch;
            }
            0x82E88C20 => {
    //   block [0x82E88C20..0x82E88C48)
	// 82E88C20: 3FC08334  lis r30, -0x7ccc
	ctx.r[30].s64 = -2093744128;
	// 82E88C24: 3D401555  lis r10, 0x1555
	ctx.r[10].s64 = 357892096;
	// 82E88C28: 3B80FFFF  li r28, -1
	ctx.r[28].s64 = -1;
	// 82E88C2C: 614A5555  ori r10, r10, 0x5555
	ctx.r[10].u64 = ctx.r[10].u64 | 21845;
	// 82E88C30: 817E0718  lwz r11, 0x718(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E88C34: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E88C38: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E88C3C: 1C6B000C  mulli r3, r11, 0xc
	ctx.r[3].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82E88C40: 40990008  ble cr6, 0x82e88c48
	if !ctx.cr[6].gt {
	pc = 0x82E88C48; continue 'dispatch;
	}
	// 82E88C44: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	pc = 0x82E88C48; continue 'dispatch;
            }
            0x82E88C48 => {
    //   block [0x82E88C48..0x82E88C70)
	// 82E88C48: 4B78DCE1  bl 0x82616928
	ctx.lr = 0x82E88C4C;
	sub_82616928(ctx, base);
	// 82E88C4C: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 82E88C50: 817E0718  lwz r11, 0x718(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E88C54: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 82E88C58: 7EAAAB78  mr r10, r21
	ctx.r[10].u64 = ctx.r[21].u64;
	// 82E88C5C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E88C60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E88C64: 40990044  ble cr6, 0x82e88ca8
	if !ctx.cr[6].gt {
	pc = 0x82E88CA8; continue 'dispatch;
	}
	// 82E88C68: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	// 82E88C6C: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	pc = 0x82E88C70; continue 'dispatch;
            }
            0x82E88C70 => {
    //   block [0x82E88C70..0x82E88CA8)
	// 82E88C70: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E88C74: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E88C78: 7EA9592E  stwx r21, r9, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[21].u32) };
	// 82E88C7C: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E88C80: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82E88C84: 91090004  stw r8, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82E88C88: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E88C8C: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82E88C90: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82E88C94: 91090008  stw r8, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82E88C98: 813E0718  lwz r9, 0x718(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E88C9C: 81290010  lwz r9, 0x10(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E88CA0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E88CA4: 4198FFCC  blt cr6, 0x82e88c70
	if ctx.cr[6].lt {
	pc = 0x82E88C70; continue 'dispatch;
	}
	pc = 0x82E88CA8; continue 'dispatch;
            }
            0x82E88CA8 => {
    //   block [0x82E88CA8..0x82E88CDC)
	// 82E88CA8: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82E88CAC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E88CB0: 3D203FFF  lis r9, 0x3fff
	ctx.r[9].s64 = 1073676288;
	// 82E88CB4: 92BF0084  stw r21, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[21].u32 ) };
	// 82E88CB8: 6129FFFF  ori r9, r9, 0xffff
	ctx.r[9].u64 = ctx.r[9].u64 | 65535;
	// 82E88CBC: 7D4A5830  slw r10, r10, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 82E88CC0: 396AFFFF  addi r11, r10, -1
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	// 82E88CC4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E88CC8: 915F00A0  stw r10, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 82E88CCC: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82E88CD0: 917F00A4  stw r11, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 82E88CD4: 40990008  ble cr6, 0x82e88cdc
	if !ctx.cr[6].gt {
	pc = 0x82E88CDC; continue 'dispatch;
	}
	// 82E88CD8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	pc = 0x82E88CDC; continue 'dispatch;
            }
            0x82E88CDC => {
    //   block [0x82E88CDC..0x82E88CF8)
	// 82E88CDC: 4B78DC4D  bl 0x82616928
	ctx.lr = 0x82E88CE0;
	sub_82616928(ctx, base);
	// 82E88CE0: C01F0094  lfs f0, 0x94(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E88CE4: C1BF0098  lfs f13, 0x98(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E88CE8: 907F009C  stw r3, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[3].u32 ) };
	// 82E88CEC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E88CF0: 40980008  bge cr6, 0x82e88cf8
	if !ctx.cr[6].lt {
	pc = 0x82E88CF8; continue 'dispatch;
	}
	// 82E88CF4: D01F0098  stfs f0, 0x98(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), tmp.u32 ) };
	pc = 0x82E88CF8; continue 'dispatch;
            }
            0x82E88CF8 => {
    //   block [0x82E88CF8..0x82E88D24)
	// 82E88CF8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E88CFC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E88D00: 388B95B0  addi r4, r11, -0x6a50
	ctx.r[4].s64 = ctx.r[11].s64 + -27216;
	// 82E88D04: 4BFFB215  bl 0x82e83f18
	ctx.lr = 0x82E88D08;
	sub_82E83F18(ctx, base);
	// 82E88D08: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E88D0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E88D10: 388B9598  addi r4, r11, -0x6a68
	ctx.r[4].s64 = ctx.r[11].s64 + -27240;
	// 82E88D14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E88D18: 4BFFB201  bl 0x82e83f18
	ctx.lr = 0x82E88D1C;
	sub_82E83F18(ctx, base);
	// 82E88D1C: 7C7B1B79  or. r27, r3, r3
	ctx.r[27].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82E88D20: 4082001C  bne 0x82e88d3c
	if !ctx.cr[0].eq {
	pc = 0x82E88D3C; continue 'dispatch;
	}
	pc = 0x82E88D24; continue 'dispatch;
            }
            0x82E88D24 => {
    //   block [0x82E88D24..0x82E88D3C)
	// 82E88D24: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E88D28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E88D2C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E88D30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E88D34: 4E800421  bctrl
	ctx.lr = 0x82E88D38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E88D38: 4800021C  b 0x82e88f54
	pc = 0x82E88F54; continue 'dispatch;
            }
            0x82E88D3C => {
    //   block [0x82E88D3C..0x82E88D9C)
	// 82E88D3C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E88D40: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E88D44: 388B95A4  addi r4, r11, -0x6a5c
	ctx.r[4].s64 = ctx.r[11].s64 + -27228;
	// 82E88D48: 4BFFB1D1  bl 0x82e83f18
	ctx.lr = 0x82E88D4C;
	sub_82E83F18(ctx, base);
	// 82E88D4C: 7C771B79  or. r23, r3, r3
	ctx.r[23].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 82E88D50: 4182FFD4  beq 0x82e88d24
	if ctx.cr[0].eq {
	pc = 0x82E88D24; continue 'dispatch;
	}
	// 82E88D54: 817F00A4  lwz r11, 0xa4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 82E88D58: C01F0094  lfs f0, 0x94(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E88D5C: C1BF0098  lfs f13, 0x98(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E88D60: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82E88D64: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E88D68: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82E88D6C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E88D70: C3CB0C18  lfs f30, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82E88D74: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82E88D78: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E88D7C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E88D80: 4198001C  blt cr6, 0x82e88d9c
	if ctx.cr[6].lt {
	pc = 0x82E88D9C; continue 'dispatch;
	}
	// 82E88D84: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E88D88: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82E88D8C: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E88D90: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E88D94: D1BF0098  stfs f13, 0x98(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82E88D98: 4099FE80  ble cr6, 0x82e88c18
	if !ctx.cr[6].gt {
	pc = 0x82E88C18; continue 'dispatch;
	}
	pc = 0x82E88D9C; continue 'dispatch;
            }
            0x82E88D9C => {
    //   block [0x82E88D9C..0x82E88DF8)
	// 82E88D9C: 81770020  lwz r11, 0x20(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E88DA0: 3ADF0070  addi r22, r31, 0x70
	ctx.r[22].s64 = ctx.r[31].s64 + 112;
	// 82E88DA4: 815B0020  lwz r10, 0x20(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E88DA8: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82E88DAC: 7C8B51D6  mullw r4, r11, r10
	ctx.r[4].s32 = ((ctx.r[11].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 82E88DB0: 48030429  bl 0x82eb91d8
	ctx.lr = 0x82E88DB4;
	sub_82EB91D8(ctx, base);
	// 82E88DB4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E88DB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E88DBC: 4BFFF8DD  bl 0x82e88698
	ctx.lr = 0x82E88DC0;
	sub_82E88698(ctx, base);
	// 82E88DC0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E88DC4: 4182FE54  beq 0x82e88c18
	if ctx.cr[0].eq {
	pc = 0x82E88C18; continue 'dispatch;
	}
	// 82E88DC8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E88DCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E88DD0: 4BFFFA21  bl 0x82e887f0
	ctx.lr = 0x82E88DD4;
	sub_82E887F0(ctx, base);
	// 82E88DD4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E88DD8: 4182FE40  beq 0x82e88c18
	if ctx.cr[0].eq {
	pc = 0x82E88C18; continue 'dispatch;
	}
	// 82E88DDC: 817B0020  lwz r11, 0x20(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E88DE0: 7EBAAB78  mr r26, r21
	ctx.r[26].u64 = ctx.r[21].u64;
	// 82E88DE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E88DE8: 409900D4  ble cr6, 0x82e88ebc
	if !ctx.cr[6].gt {
	pc = 0x82E88EBC; continue 'dispatch;
	}
	// 82E88DEC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E88DF0: 7EB8AB78  mr r24, r21
	ctx.r[24].u64 = ctx.r[21].u64;
	// 82E88DF4: 3B2B9158  addi r25, r11, -0x6ea8
	ctx.r[25].s64 = ctx.r[11].s64 + -28328;
	pc = 0x82E88DF8; continue 'dispatch;
            }
            0x82E88DF8 => {
    //   block [0x82E88DF8..0x82E88E68)
	// 82E88DF8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82E88DFC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82E88E00: 4BFFB229  bl 0x82e84028
	ctx.lr = 0x82E88E04;
	sub_82E84028(ctx, base);
	// 82E88E04: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E88E08: 48333259  bl 0x831bc060
	ctx.lr = 0x82E88E0C;
	sub_831BC060(ctx, base);
	// 82E88E0C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82E88E10: 4BE23D41  bl 0x82cacb50
	ctx.lr = 0x82E88E14;
	sub_82CACB50(ctx, base);
	// 82E88E14: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E88E18: 40820094  bne 0x82e88eac
	if !ctx.cr[0].eq {
	pc = 0x82E88EAC; continue 'dispatch;
	}
	// 82E88E1C: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E88E20: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E88E24: 419A0088  beq cr6, 0x82e88eac
	if ctx.cr[6].eq {
	pc = 0x82E88EAC; continue 'dispatch;
	}
	// 82E88E28: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E88E2C: 7FCBC02E  lwzx r30, r11, r24
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 82E88E30: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E88E34: 41820078  beq 0x82e88eac
	if ctx.cr[0].eq {
	pc = 0x82E88EAC; continue 'dispatch;
	}
	// 82E88E38: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 82E88E3C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E88E40: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E88E44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E88E48: 4BFFFAF1  bl 0x82e88938
	ctx.lr = 0x82E88E4C;
	sub_82E88938(ctx, base);
	// 82E88E4C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E88E50: 4182FDC8  beq 0x82e88c18
	if ctx.cr[0].eq {
	pc = 0x82E88C18; continue 'dispatch;
	}
	// 82E88E54: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E88E58: 7EBCAB78  mr r28, r21
	ctx.r[28].u64 = ctx.r[21].u64;
	// 82E88E5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E88E60: 40990048  ble cr6, 0x82e88ea8
	if !ctx.cr[6].gt {
	pc = 0x82E88EA8; continue 'dispatch;
	}
	// 82E88E64: 7EBDAB78  mr r29, r21
	ctx.r[29].u64 = ctx.r[21].u64;
	pc = 0x82E88E68; continue 'dispatch;
            }
            0x82E88E68 => {
    //   block [0x82E88E68..0x82E88E94)
	// 82E88E68: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E88E6C: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82E88E70: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E88E74: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82E88E78: 4182001C  beq 0x82e88e94
	if ctx.cr[0].eq {
	pc = 0x82E88E94; continue 'dispatch;
	}
	// 82E88E7C: 896B0044  lbz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E88E80: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E88E84: 40820010  bne 0x82e88e94
	if !ctx.cr[0].eq {
	pc = 0x82E88E94; continue 'dispatch;
	}
	// 82E88E88: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E88E8C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82E88E90: 48030401  bl 0x82eb9290
	ctx.lr = 0x82E88E94;
	sub_82EB9290(ctx, base);
	pc = 0x82E88E94; continue 'dispatch;
            }
            0x82E88E94 => {
    //   block [0x82E88E94..0x82E88EA8)
	// 82E88E94: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E88E98: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82E88E9C: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82E88EA0: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E88EA4: 4198FFC4  blt cr6, 0x82e88e68
	if ctx.cr[6].lt {
	pc = 0x82E88E68; continue 'dispatch;
	}
	pc = 0x82E88EA8; continue 'dispatch;
            }
            0x82E88EA8 => {
    //   block [0x82E88EA8..0x82E88EAC)
	// 82E88EA8: 3B180004  addi r24, r24, 4
	ctx.r[24].s64 = ctx.r[24].s64 + 4;
	pc = 0x82E88EAC; continue 'dispatch;
            }
            0x82E88EAC => {
    //   block [0x82E88EAC..0x82E88EBC)
	// 82E88EAC: 817B0020  lwz r11, 0x20(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E88EB0: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 82E88EB4: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E88EB8: 4198FF40  blt cr6, 0x82e88df8
	if ctx.cr[6].lt {
	pc = 0x82E88DF8; continue 'dispatch;
	}
	pc = 0x82E88EBC; continue 'dispatch;
            }
            0x82E88EBC => {
    //   block [0x82E88EBC..0x82E88F2C)
	// 82E88EBC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E88EC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E88EC4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E88EC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E88ECC: 4E800421  bctrl
	ctx.lr = 0x82E88ED0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E88ED0: 4B3D7AE9  bl 0x822609b8
	ctx.lr = 0x82E88ED4;
	sub_822609B8(ctx, base);
	// 82E88ED4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E88ED8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E88EDC: 388B9520  addi r4, r11, -0x6ae0
	ctx.r[4].s64 = ctx.r[11].s64 + -27360;
	// 82E88EE0: 4BFF8289  bl 0x82e81168
	ctx.lr = 0x82E88EE4;
	sub_82E81168(ctx, base);
	// 82E88EE4: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82E88EE8: 907F008C  stw r3, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[3].u32 ) };
	// 82E88EEC: 419AFD2C  beq cr6, 0x82e88c18
	if ctx.cr[6].eq {
	pc = 0x82E88C18; continue 'dispatch;
	}
	// 82E88EF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E88EF4: 4BAE9275  bl 0x82972168
	ctx.lr = 0x82E88EF8;
	sub_82972168(ctx, base);
	// 82E88EF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E88EFC: 809F008C  lwz r4, 0x8c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82E88F00: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82E88F04: 4BFF83CD  bl 0x82e812d0
	ctx.lr = 0x82E88F08;
	sub_82E812D0(ctx, base);
	// 82E88F08: FF01F000  fcmpu cr6, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[30].f64);
	// 82E88F0C: 409A0020  bne cr6, 0x82e88f2c
	if !ctx.cr[6].eq {
	pc = 0x82E88F2C; continue 'dispatch;
	}
	// 82E88F10: 809F008C  lwz r4, 0x8c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82E88F14: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 82E88F18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E88F1C: 409A0028  bne cr6, 0x82e88f44
	if !ctx.cr[6].eq {
	pc = 0x82E88F44; continue 'dispatch;
	}
	// 82E88F20: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E88F24: C02B0C4C  lfs f1, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E88F28: 48000028  b 0x82e88f50
	pc = 0x82E88F50; continue 'dispatch;
            }
            0x82E88F2C => {
    //   block [0x82E88F2C..0x82E88F44)
	// 82E88F2C: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 82E88F30: 419A0024  beq cr6, 0x82e88f54
	if ctx.cr[6].eq {
	pc = 0x82E88F54; continue 'dispatch;
	}
	// 82E88F34: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 82E88F38: 4198001C  blt cr6, 0x82e88f54
	if ctx.cr[6].lt {
	pc = 0x82E88F54; continue 'dispatch;
	}
	// 82E88F3C: 809F008C  lwz r4, 0x8c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82E88F40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x82E88F44; continue 'dispatch;
            }
            0x82E88F44 => {
    //   block [0x82E88F44..0x82E88F50)
	// 82E88F44: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E88F48: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E88F4C: EC3F0032  fmuls f1, f31, f0
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x82E88F50; continue 'dispatch;
            }
            0x82E88F50 => {
    //   block [0x82E88F50..0x82E88F54)
	// 82E88F50: 4BFF8359  bl 0x82e812a8
	ctx.lr = 0x82E88F54;
	sub_82E812A8(ctx, base);
	pc = 0x82E88F54; continue 'dispatch;
            }
            0x82E88F54 => {
    //   block [0x82E88F54..0x82E88F58)
	// 82E88F54: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82E88F58; continue 'dispatch;
            }
            0x82E88F58 => {
    //   block [0x82E88F58..0x82E88F68)
	// 82E88F58: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82E88F5C: CBC1FF90  lfd f30, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 82E88F60: CBE1FF98  lfd f31, -0x68(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 82E88F64: 4BE204D8  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E88F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E88F68 size=32
    let mut pc: u32 = 0x82E88F68;
    'dispatch: loop {
        match pc {
            0x82E88F68 => {
    //   block [0x82E88F68..0x82E88F88)
	// 82E88F68: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E88F6C: 90830004  stw r4, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82E88F70: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E88F74: 396B9608  addi r11, r11, -0x69f8
	ctx.r[11].s64 = ctx.r[11].s64 + -27128;
	// 82E88F78: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82E88F7C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E88F80: 9143000C  stw r10, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82E88F84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E88F88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E88F88 size=92
    let mut pc: u32 = 0x82E88F88;
    'dispatch: loop {
        match pc {
            0x82E88F88 => {
    //   block [0x82E88F88..0x82E88FC4)
	// 82E88F88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E88F8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E88F90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E88F94: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E88F98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E88F9C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E88FA0: 396B9608  addi r11, r11, -0x69f8
	ctx.r[11].s64 = ctx.r[11].s64 + -27128;
	// 82E88FA4: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E88FA8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E88FAC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E88FB0: 41820014  beq 0x82e88fc4
	if ctx.cr[0].eq {
	pc = 0x82E88FC4; continue 'dispatch;
	}
	// 82E88FB4: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E88FB8: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E88FBC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E88FC0: 4E800421  bctrl
	ctx.lr = 0x82E88FC4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E88FC4 => {
    //   block [0x82E88FC4..0x82E88FE4)
	// 82E88FC4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E88FC8: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82E88FCC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E88FD0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E88FD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E88FD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E88FDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E88FE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E88FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E88FE8 size=152
    let mut pc: u32 = 0x82E88FE8;
    'dispatch: loop {
        match pc {
            0x82E88FE8 => {
    //   block [0x82E88FE8..0x82E89020)
	// 82E88FE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E88FEC: 4BE2041D  bl 0x82ca9408
	ctx.lr = 0x82E88FF0;
	sub_82CA93D0(ctx, base);
	// 82E88FF0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E88FF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E88FF8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82E88FFC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E89000: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E89004: 7D4BE1D6  mullw r10, r11, r28
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * ctx.r[28].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82E89008: 7D6959D6  mullw r11, r9, r11
	ctx.r[11].s32 = ((ctx.r[9].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82E8900C: 557EE8FE  srwi r30, r11, 3
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shr(3);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82E89010: 5543E8FE  srwi r3, r10, 3
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shr(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82E89014: 554B077F  clrlwi. r11, r10, 0x1d
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E89018: 41820008  beq 0x82e89020
	if ctx.cr[0].eq {
	pc = 0x82E89020; continue 'dispatch;
	}
	// 82E8901C: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	pc = 0x82E89020; continue 'dispatch;
            }
            0x82E89020 => {
    //   block [0x82E89020..0x82E8903C)
	// 82E89020: 7F03F040  cmplw cr6, r3, r30
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82E89024: 40990054  ble cr6, 0x82e89078
	if !ctx.cr[6].gt {
	pc = 0x82E89078; continue 'dispatch;
	}
	// 82E89028: 4B78D901  bl 0x82616928
	ctx.lr = 0x82E8902C;
	sub_82616928(ctx, base);
	// 82E8902C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E89030: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E89034: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82E89038: 419A001C  beq cr6, 0x82e89054
	if ctx.cr[6].eq {
	pc = 0x82E89054; continue 'dispatch;
	}
	pc = 0x82E8903C; continue 'dispatch;
            }
            0x82E8903C => {
    //   block [0x82E8903C..0x82E89054)
	// 82E8903C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E89040: 7D4A58AE  lbzx r10, r10, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82E89044: 7D4BE9AE  stbx r10, r11, r29
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32), ctx.r[10].u8) };
	// 82E89048: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E8904C: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82E89050: 4198FFEC  blt cr6, 0x82e8903c
	if ctx.cr[6].lt {
	pc = 0x82E8903C; continue 'dispatch;
	}
	pc = 0x82E89054; continue 'dispatch;
            }
            0x82E89054 => {
    //   block [0x82E89054..0x82E89070)
	// 82E89054: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E89058: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8905C: 41820014  beq 0x82e89070
	if ctx.cr[0].eq {
	pc = 0x82E89070; continue 'dispatch;
	}
	// 82E89060: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E89064: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E89068: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8906C: 4E800421  bctrl
	ctx.lr = 0x82E89070;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E89070 => {
    //   block [0x82E89070..0x82E89078)
	// 82E89070: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82E89074: 939F000C  stw r28, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	pc = 0x82E89078; continue 'dispatch;
            }
            0x82E89078 => {
    //   block [0x82E89078..0x82E89080)
	// 82E89078: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E8907C: 4BE203DC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E89080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E89080 size=116
    let mut pc: u32 = 0x82E89080;
    'dispatch: loop {
        match pc {
            0x82E89080 => {
    //   block [0x82E89080..0x82E890B0)
	// 82E89080: 81030004  lwz r8, 4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E89084: 39640001  addi r11, r4, 1
	ctx.r[11].s64 = ctx.r[4].s64 + 1;
	// 82E89088: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8908C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82E89090: 7D6B41D6  mullw r11, r11, r8
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82E89094: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82E89098: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8909C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82E890A0: 556AE8FE  srwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E890A4: 556B077E  clrlwi r11, r11, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 82E890A8: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82E890AC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	pc = 0x82E890B0; continue 'dispatch;
            }
            0x82E890B0 => {
    //   block [0x82E890B0..0x82E890C8)
	// 82E890B0: 88AA0000  lbz r5, 0(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E890B4: 7D245830  slw r4, r9, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[4].u64 = 0;
	} else {
		ctx.r[4].u64 = ((ctx.r[9].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 82E890B8: 7C852839  and. r5, r4, r5
	ctx.r[5].u64 = ctx.r[4].u64 & ctx.r[5].u64;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82E890BC: 4182000C  beq 0x82e890c8
	if ctx.cr[0].eq {
	pc = 0x82E890C8; continue 'dispatch;
	}
	// 82E890C0: 7D253830  slw r5, r9, r7
	if (ctx.r[7].u8 & 0x20) != 0 {
		ctx.r[5].u64 = 0;
	} else {
		ctx.r[5].u64 = ((ctx.r[9].u32) << ((ctx.r[7].u8 & 0x1F) as u32)) as u64;
	}
	// 82E890C4: 7CA31B78  or r3, r5, r3
	ctx.r[3].u64 = ctx.r[5].u64 | ctx.r[3].u64;
	pc = 0x82E890C8; continue 'dispatch;
            }
            0x82E890C8 => {
    //   block [0x82E890C8..0x82E890E0)
	// 82E890C8: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82E890CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E890D0: 409A0010  bne cr6, 0x82e890e0
	if !ctx.cr[6].eq {
	pc = 0x82E890E0; continue 'dispatch;
	}
	// 82E890D4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82E890D8: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 82E890DC: 48000008  b 0x82e890e4
	pc = 0x82E890E4; continue 'dispatch;
            }
            0x82E890E0 => {
    //   block [0x82E890E0..0x82E890E4)
	// 82E890E0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82E890E4; continue 'dispatch;
            }
            0x82E890E4 => {
    //   block [0x82E890E4..0x82E890F4)
	// 82E890E4: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 82E890E8: 7F064040  cmplw cr6, r6, r8
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82E890EC: 409AFFC4  bne cr6, 0x82e890b0
	if !ctx.cr[6].eq {
	pc = 0x82E890B0; continue 'dispatch;
	}
	// 82E890F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E890F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E890F8 size=136
    let mut pc: u32 = 0x82E890F8;
    'dispatch: loop {
        match pc {
            0x82E890F8 => {
    //   block [0x82E890F8..0x82E89120)
	// 82E890F8: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82E890FC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E89100: 39440001  addi r10, r4, 1
	ctx.r[10].s64 = ctx.r[4].s64 + 1;
	// 82E89104: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82E89108: 7D6A59D6  mullw r11, r10, r11
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82E8910C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82E89110: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82E89114: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82E89118: 556AE8FE  srwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8911C: 5569077E  clrlwi r9, r11, 0x1d
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	pc = 0x82E89120; continue 'dispatch;
            }
            0x82E89120 => {
    //   block [0x82E89120..0x82E89144)
	// 82E89120: 80850000  lwz r4, 0(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E89124: 7CFF4030  slw r31, r7, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[31].u64 = 0;
	} else {
		ctx.r[31].u64 = ((ctx.r[7].u32) << ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 82E89128: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8912C: 7FE42039  and. r4, r31, r4
	ctx.r[4].u64 = ctx.r[31].u64 & ctx.r[4].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82E89130: 7C8A58AE  lbzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82E89134: 7CFF4830  slw r31, r7, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[31].u64 = 0;
	} else {
		ctx.r[31].u64 = ((ctx.r[7].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 82E89138: 4182000C  beq 0x82e89144
	if ctx.cr[0].eq {
	pc = 0x82E89144; continue 'dispatch;
	}
	// 82E8913C: 7FE42378  or r4, r31, r4
	ctx.r[4].u64 = ctx.r[31].u64 | ctx.r[4].u64;
	// 82E89140: 48000008  b 0x82e89148
	pc = 0x82E89148; continue 'dispatch;
            }
            0x82E89144 => {
    //   block [0x82E89144..0x82E89148)
	// 82E89144: 7C84F878  andc r4, r4, r31
	ctx.r[4].u64 = ctx.r[4].u64 & !ctx.r[31].u64;
	pc = 0x82E89148; continue 'dispatch;
            }
            0x82E89148 => {
    //   block [0x82E89148..0x82E89164)
	// 82E89148: 7C8A59AE  stbx r4, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[4].u8) };
	// 82E8914C: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82E89150: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E89154: 409A0010  bne cr6, 0x82e89164
	if !ctx.cr[6].eq {
	pc = 0x82E89164; continue 'dispatch;
	}
	// 82E89158: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82E8915C: 39200007  li r9, 7
	ctx.r[9].s64 = 7;
	// 82E89160: 48000008  b 0x82e89168
	pc = 0x82E89168; continue 'dispatch;
            }
            0x82E89164 => {
    //   block [0x82E89164..0x82E89168)
	// 82E89164: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	pc = 0x82E89168; continue 'dispatch;
            }
            0x82E89168 => {
    //   block [0x82E89168..0x82E89180)
	// 82E89168: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8916C: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82E89170: 7F065840  cmplw cr6, r6, r11
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E89174: 409AFFAC  bne cr6, 0x82e89120
	if !ctx.cr[6].eq {
	pc = 0x82E89120; continue 'dispatch;
	}
	// 82E89178: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82E8917C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E89180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E89180 size=88
    let mut pc: u32 = 0x82E89180;
    'dispatch: loop {
        match pc {
            0x82E89180 => {
    //   block [0x82E89180..0x82E891BC)
	// 82E89180: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E89184: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E89188: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8918C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E89190: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E89194: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E89198: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8919C: 4BFFFDED  bl 0x82e88f88
	ctx.lr = 0x82E891A0;
	sub_82E88F88(ctx, base);
	// 82E891A0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E891A4: 41820018  beq 0x82e891bc
	if ctx.cr[0].eq {
	pc = 0x82E891BC; continue 'dispatch;
	}
	// 82E891A8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E891AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E891B0: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E891B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E891B8: 4E800421  bctrl
	ctx.lr = 0x82E891BC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E891BC => {
    //   block [0x82E891BC..0x82E891D8)
	// 82E891BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E891C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E891C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E891C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E891CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E891D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E891D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E891D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E891D8 size=28
    let mut pc: u32 = 0x82E891D8;
    'dispatch: loop {
        match pc {
            0x82E891D8 => {
    //   block [0x82E891D8..0x82E891F4)
	// 82E891D8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E891DC: 90830008  stw r4, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 82E891E0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E891E4: 396B960C  addi r11, r11, -0x69f4
	ctx.r[11].s64 = ctx.r[11].s64 + -27124;
	// 82E891E8: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82E891EC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E891F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E891F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E891F8 size=120
    let mut pc: u32 = 0x82E891F8;
    'dispatch: loop {
        match pc {
            0x82E891F8 => {
    //   block [0x82E891F8..0x82E8923C)
	// 82E891F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E891FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E89200: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E89204: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E89208: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8920C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E89210: 396B960C  addi r11, r11, -0x69f4
	ctx.r[11].s64 = ctx.r[11].s64 + -27124;
	// 82E89214: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E89218: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8921C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E89220: 41820030  beq 0x82e89250
	if ctx.cr[0].eq {
	pc = 0x82E89250; continue 'dispatch;
	}
	// 82E89224: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E89228: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8922C: 41820010  beq 0x82e8923c
	if ctx.cr[0].eq {
	pc = 0x82E8923C; continue 'dispatch;
	}
	// 82E89230: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E89234: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E89238: 419A0018  beq cr6, 0x82e89250
	if ctx.cr[6].eq {
	pc = 0x82E89250; continue 'dispatch;
	}
	pc = 0x82E8923C; continue 'dispatch;
            }
            0x82E8923C => {
    //   block [0x82E8923C..0x82E89250)
	// 82E8923C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E89240: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E89244: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E89248: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8924C: 4E800421  bctrl
	ctx.lr = 0x82E89250;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E89250 => {
    //   block [0x82E89250..0x82E89270)
	// 82E89250: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E89254: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82E89258: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E8925C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E89260: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E89264: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E89268: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8926C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E89270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E89270 size=88
    let mut pc: u32 = 0x82E89270;
    'dispatch: loop {
        match pc {
            0x82E89270 => {
    //   block [0x82E89270..0x82E892AC)
	// 82E89270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E89274: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E89278: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8927C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E89280: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E89284: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E89288: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8928C: 4BFFFF6D  bl 0x82e891f8
	ctx.lr = 0x82E89290;
	sub_82E891F8(ctx, base);
	// 82E89290: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E89294: 41820018  beq 0x82e892ac
	if ctx.cr[0].eq {
	pc = 0x82E892AC; continue 'dispatch;
	}
	// 82E89298: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E8929C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E892A0: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E892A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E892A8: 4E800421  bctrl
	ctx.lr = 0x82E892AC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E892AC => {
    //   block [0x82E892AC..0x82E892C8)
	// 82E892AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E892B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E892B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E892B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E892BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E892C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E892C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E892C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E892C8 size=584
    let mut pc: u32 = 0x82E892C8;
    'dispatch: loop {
        match pc {
            0x82E892C8 => {
    //   block [0x82E892C8..0x82E89324)
	// 82E892C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E892CC: 4BE20125  bl 0x82ca93f0
	ctx.lr = 0x82E892D0;
	sub_82CA93D0(ctx, base);
	// 82E892D0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E892D4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E892D8: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 82E892DC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82E892E0: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E892E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E892E8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E892EC: 3ACB9634  addi r22, r11, -0x69cc
	ctx.r[22].s64 = ctx.r[11].s64 + -27084;
	// 82E892F0: 4099014C  ble cr6, 0x82e8943c
	if !ctx.cr[6].gt {
	pc = 0x82E8943C; continue 'dispatch;
	}
	// 82E892F4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82E892F8: 3BAB7088  addi r29, r11, 0x7088
	ctx.r[29].s64 = ctx.r[11].s64 + 28808;
	// 82E892FC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82E89300: 3B8B1700  addi r28, r11, 0x1700
	ctx.r[28].s64 = ctx.r[11].s64 + 5888;
	// 82E89304: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82E89308: 3B6B1698  addi r27, r11, 0x1698
	ctx.r[27].s64 = ctx.r[11].s64 + 5784;
	// 82E8930C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82E89310: 3B4BD56C  addi r26, r11, -0x2a94
	ctx.r[26].s64 = ctx.r[11].s64 + -10900;
	// 82E89314: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E89318: 3B2B0F40  addi r25, r11, 0xf40
	ctx.r[25].s64 = ctx.r[11].s64 + 3904;
	// 82E8931C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82E89320: 3B0B1694  addi r24, r11, 0x1694
	ctx.r[24].s64 = ctx.r[11].s64 + 5780;
	pc = 0x82E89324; continue 'dispatch;
            }
            0x82E89324 => {
    //   block [0x82E89324..0x82E89404)
	// 82E89324: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E89328: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8932C: 4BFFACFD  bl 0x82e84028
	ctx.lr = 0x82E89330;
	sub_82E84028(ctx, base);
	// 82E89330: 48332D31  bl 0x831bc060
	ctx.lr = 0x82E89334;
	sub_831BC060(ctx, base);
	// 82E89334: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82E89338: 4BE23819  bl 0x82cacb50
	ctx.lr = 0x82E8933C;
	sub_82CACB50(ctx, base);
	// 82E8933C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E89340: 408200EC  bne 0x82e8942c
	if !ctx.cr[0].eq {
	pc = 0x82E8942C; continue 'dispatch;
	}
	// 82E89344: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E89348: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8934C: 4BFFACDD  bl 0x82e84028
	ctx.lr = 0x82E89350;
	sub_82E84028(ctx, base);
	// 82E89350: 4BA849B9  bl 0x8290dd08
	ctx.lr = 0x82E89354;
	sub_8290DD08(ctx, base);
	// 82E89354: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82E89358: 4BE237F9  bl 0x82cacb50
	ctx.lr = 0x82E8935C;
	sub_82CACB50(ctx, base);
	// 82E8935C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E89360: 418200AC  beq 0x82e8940c
	if ctx.cr[0].eq {
	pc = 0x82E8940C; continue 'dispatch;
	}
	// 82E89364: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E89368: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8936C: 4BFFACBD  bl 0x82e84028
	ctx.lr = 0x82E89370;
	sub_82E84028(ctx, base);
	// 82E89370: 4BA84999  bl 0x8290dd08
	ctx.lr = 0x82E89374;
	sub_8290DD08(ctx, base);
	// 82E89374: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82E89378: 4BE237D9  bl 0x82cacb50
	ctx.lr = 0x82E8937C;
	sub_82CACB50(ctx, base);
	// 82E8937C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E89380: 4182008C  beq 0x82e8940c
	if ctx.cr[0].eq {
	pc = 0x82E8940C; continue 'dispatch;
	}
	// 82E89384: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E89388: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8938C: 4BFFAC9D  bl 0x82e84028
	ctx.lr = 0x82E89390;
	sub_82E84028(ctx, base);
	// 82E89390: 4BA84979  bl 0x8290dd08
	ctx.lr = 0x82E89394;
	sub_8290DD08(ctx, base);
	// 82E89394: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82E89398: 4BE237B9  bl 0x82cacb50
	ctx.lr = 0x82E8939C;
	sub_82CACB50(ctx, base);
	// 82E8939C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E893A0: 4182006C  beq 0x82e8940c
	if ctx.cr[0].eq {
	pc = 0x82E8940C; continue 'dispatch;
	}
	// 82E893A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E893A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E893AC: 4BFFAC7D  bl 0x82e84028
	ctx.lr = 0x82E893B0;
	sub_82E84028(ctx, base);
	// 82E893B0: 4BA84959  bl 0x8290dd08
	ctx.lr = 0x82E893B4;
	sub_8290DD08(ctx, base);
	// 82E893B4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E893B8: 4BE23799  bl 0x82cacb50
	ctx.lr = 0x82E893BC;
	sub_82CACB50(ctx, base);
	// 82E893BC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E893C0: 41820044  beq 0x82e89404
	if ctx.cr[0].eq {
	pc = 0x82E89404; continue 'dispatch;
	}
	// 82E893C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E893C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E893CC: 4BFFAC5D  bl 0x82e84028
	ctx.lr = 0x82E893D0;
	sub_82E84028(ctx, base);
	// 82E893D0: 4BA84939  bl 0x8290dd08
	ctx.lr = 0x82E893D4;
	sub_8290DD08(ctx, base);
	// 82E893D4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E893D8: 4BE23779  bl 0x82cacb50
	ctx.lr = 0x82E893DC;
	sub_82CACB50(ctx, base);
	// 82E893DC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E893E0: 41820024  beq 0x82e89404
	if ctx.cr[0].eq {
	pc = 0x82E89404; continue 'dispatch;
	}
	// 82E893E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E893E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E893EC: 4BFFAC3D  bl 0x82e84028
	ctx.lr = 0x82E893F0;
	sub_82E84028(ctx, base);
	// 82E893F0: 4BA84919  bl 0x8290dd08
	ctx.lr = 0x82E893F4;
	sub_8290DD08(ctx, base);
	// 82E893F4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E893F8: 4BE23759  bl 0x82cacb50
	ctx.lr = 0x82E893FC;
	sub_82CACB50(ctx, base);
	// 82E893FC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E89400: 40820108  bne 0x82e89508
	if !ctx.cr[0].eq {
	pc = 0x82E89508; continue 'dispatch;
	}
	pc = 0x82E89404; continue 'dispatch;
            }
            0x82E89404 => {
    //   block [0x82E89404..0x82E8940C)
	// 82E89404: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E89408: 48000008  b 0x82e89410
	pc = 0x82E89410; continue 'dispatch;
            }
            0x82E8940C => {
    //   block [0x82E8940C..0x82E89410)
	// 82E8940C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82E89410; continue 'dispatch;
            }
            0x82E89410 => {
    //   block [0x82E89410..0x82E8942C)
	// 82E89410: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E89414: 41820018  beq 0x82e8942c
	if ctx.cr[0].eq {
	pc = 0x82E8942C; continue 'dispatch;
	}
	// 82E89418: 81770008  lwz r11, 8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8941C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E89420: 418200E8  beq 0x82e89508
	if ctx.cr[0].eq {
	pc = 0x82E89508; continue 'dispatch;
	}
	// 82E89424: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E89428: 91770004  stw r11, 4(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82E8942C; continue 'dispatch;
            }
            0x82E8942C => {
    //   block [0x82E8942C..0x82E8943C)
	// 82E8942C: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E89430: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82E89434: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E89438: 4198FEEC  blt cr6, 0x82e89324
	if ctx.cr[6].lt {
	pc = 0x82E89324; continue 'dispatch;
	}
	pc = 0x82E8943C; continue 'dispatch;
            }
            0x82E8943C => {
    //   block [0x82E8943C..0x82E89478)
	// 82E8943C: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E89440: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E89444: 409A0034  bne cr6, 0x82e89478
	if !ctx.cr[6].eq {
	pc = 0x82E89478; continue 'dispatch;
	}
	// 82E89448: 81770008  lwz r11, 8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8944C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E89450: 41820028  beq 0x82e89478
	if ctx.cr[0].eq {
	pc = 0x82E89478; continue 'dispatch;
	}
	// 82E89454: 806B0018  lwz r3, 0x18(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E89458: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8945C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E89460: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E89464: 4E800421  bctrl
	ctx.lr = 0x82E89468;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E89468: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8946C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E89470: 4E800421  bctrl
	ctx.lr = 0x82E89474;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E89474: 90770004  stw r3, 4(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
            }
            0x82E89478 => {
    //   block [0x82E89478..0x82E89490)
	// 82E89478: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E8947C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E89480: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E89484: 40990078  ble cr6, 0x82e894fc
	if !ctx.cr[6].gt {
	pc = 0x82E894FC; continue 'dispatch;
	}
	// 82E89488: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8948C: 3B8B8FD8  addi r28, r11, -0x7028
	ctx.r[28].s64 = ctx.r[11].s64 + -28712;
	pc = 0x82E89490; continue 'dispatch;
            }
            0x82E89490 => {
    //   block [0x82E89490..0x82E894EC)
	// 82E89490: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E89494: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E89498: 4BFFAB91  bl 0x82e84028
	ctx.lr = 0x82E8949C;
	sub_82E84028(ctx, base);
	// 82E8949C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E894A0: 48332BC1  bl 0x831bc060
	ctx.lr = 0x82E894A4;
	sub_831BC060(ctx, base);
	// 82E894A4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E894A8: 4BE236A9  bl 0x82cacb50
	ctx.lr = 0x82E894AC;
	sub_82CACB50(ctx, base);
	// 82E894AC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E894B0: 4182003C  beq 0x82e894ec
	if ctx.cr[0].eq {
	pc = 0x82E894EC; continue 'dispatch;
	}
	// 82E894B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E894B8: 48332BA9  bl 0x831bc060
	ctx.lr = 0x82E894BC;
	sub_831BC060(ctx, base);
	// 82E894BC: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82E894C0: 4BE23691  bl 0x82cacb50
	ctx.lr = 0x82E894C4;
	sub_82CACB50(ctx, base);
	// 82E894C4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E894C8: 41820024  beq 0x82e894ec
	if ctx.cr[0].eq {
	pc = 0x82E894EC; continue 'dispatch;
	}
	// 82E894CC: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E894D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E894D4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82E894D8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E894DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E894E0: 4E800421  bctrl
	ctx.lr = 0x82E894E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E894E4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E894E8: 41820020  beq 0x82e89508
	if ctx.cr[0].eq {
	pc = 0x82E89508; continue 'dispatch;
	}
            }
            0x82E894EC => {
    //   block [0x82E894EC..0x82E894FC)
	// 82E894EC: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E894F0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82E894F4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E894F8: 4198FF98  blt cr6, 0x82e89490
	if ctx.cr[6].lt {
	pc = 0x82E89490; continue 'dispatch;
	}
	pc = 0x82E894FC; continue 'dispatch;
            }
            0x82E894FC => {
    //   block [0x82E894FC..0x82E89500)
	// 82E894FC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82E89500; continue 'dispatch;
            }
            0x82E89500 => {
    //   block [0x82E89500..0x82E89508)
	// 82E89500: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82E89504: 4BE1FF3C  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x82E89508 => {
    //   block [0x82E89508..0x82E89510)
	// 82E89508: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8950C: 4BFFFFF4  b 0x82e89500
	pc = 0x82E89500; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E89510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E89510 size=200
    let mut pc: u32 = 0x82E89510;
    'dispatch: loop {
        match pc {
            0x82E89510 => {
    //   block [0x82E89510..0x82E89544)
	// 82E89510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E89514: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E89518: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8951C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E89520: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E89524: 4BFF4C9D  bl 0x82e7e1c0
	ctx.lr = 0x82E89528;
	sub_82E7E1C0(ctx, base);
	// 82E89528: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E8952C: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82E89530: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E89534: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E89538: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8953C: 40810054  ble 0x82e89590
	if !ctx.cr[0].gt {
	pc = 0x82E89590; continue 'dispatch;
	}
	// 82E89540: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82E89544; continue 'dispatch;
            }
            0x82E89544 => {
    //   block [0x82E89544..0x82E89550)
	// 82E89544: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E89548: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82E8954C: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	pc = 0x82E89550; continue 'dispatch;
            }
            0x82E89550 => {
    //   block [0x82E89550..0x82E89574)
	// 82E89550: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E89554: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E89558: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8955C: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82E89560: 41820014  beq 0x82e89574
	if ctx.cr[0].eq {
	pc = 0x82E89574; continue 'dispatch;
	}
	// 82E89564: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E89568: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82E8956C: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82E89570: 419AFFE0  beq cr6, 0x82e89550
	if ctx.cr[6].eq {
	pc = 0x82E89550; continue 'dispatch;
	}
	pc = 0x82E89574; continue 'dispatch;
            }
            0x82E89574 => {
    //   block [0x82E89574..0x82E89590)
	// 82E89574: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E89578: 41820028  beq 0x82e895a0
	if ctx.cr[0].eq {
	pc = 0x82E895A0; continue 'dispatch;
	}
	// 82E8957C: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E89580: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82E89584: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82E89588: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82E8958C: 4198FFB8  blt cr6, 0x82e89544
	if ctx.cr[6].lt {
	pc = 0x82E89544; continue 'dispatch;
	}
	pc = 0x82E89590; continue 'dispatch;
            }
            0x82E89590 => {
    //   block [0x82E89590..0x82E895A0)
	// 82E89590: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82E89594: 409A0018  bne cr6, 0x82e895ac
	if !ctx.cr[6].eq {
	pc = 0x82E895AC; continue 'dispatch;
	}
	// 82E89598: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8959C: 48000028  b 0x82e895c4
	pc = 0x82E895C4; continue 'dispatch;
            }
            0x82E895A0 => {
    //   block [0x82E895A0..0x82E895AC)
	// 82E895A0: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E895A4: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82E895A8: 48000018  b 0x82e895c0
	pc = 0x82E895C0; continue 'dispatch;
            }
            0x82E895AC => {
    //   block [0x82E895AC..0x82E895C0)
	// 82E895AC: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E895B0: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82E895B4: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E895B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E895BC: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	pc = 0x82E895C0; continue 'dispatch;
            }
            0x82E895C0 => {
    //   block [0x82E895C0..0x82E895C4)
	// 82E895C0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82E895C4; continue 'dispatch;
            }
            0x82E895C4 => {
    //   block [0x82E895C4..0x82E895D8)
	// 82E895C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E895C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E895CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E895D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E895D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E895D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E895D8 size=196
    let mut pc: u32 = 0x82E895D8;
    'dispatch: loop {
        match pc {
            0x82E895D8 => {
    //   block [0x82E895D8..0x82E89610)
	// 82E895D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E895DC: 4BE1FE29  bl 0x82ca9404
	ctx.lr = 0x82E895E0;
	sub_82CA93D0(ctx, base);
	// 82E895E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E895E4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E895E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E895EC: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82E895F0: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82E895F4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82E895F8: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82E895FC: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82E89600: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82E89604: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E89608: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82E8960C: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	pc = 0x82E89610; continue 'dispatch;
            }
            0x82E89610 => {
    //   block [0x82E89610..0x82E8963C)
	// 82E89610: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E89614: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E89618: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82E8961C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E89620: 4082FFF0  bne 0x82e89610
	if !ctx.cr[0].eq {
	pc = 0x82E89610; continue 'dispatch;
	}
	// 82E89624: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E89628: 4BFFFEE9  bl 0x82e89510
	ctx.lr = 0x82E8962C;
	sub_82E89510(ctx, base);
	// 82E8962C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E89630: 4082000C  bne 0x82e8963c
	if !ctx.cr[0].eq {
	pc = 0x82E8963C; continue 'dispatch;
	}
	// 82E89634: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82E89638: 48000010  b 0x82e89648
	pc = 0x82E89648; continue 'dispatch;
            }
            0x82E8963C => {
    //   block [0x82E8963C..0x82E89648)
	// 82E8963C: 4BFF4B85  bl 0x82e7e1c0
	ctx.lr = 0x82E89640;
	sub_82E7E1C0(ctx, base);
	// 82E89640: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E89644: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82E89648; continue 'dispatch;
            }
            0x82E89648 => {
    //   block [0x82E89648..0x82E8966C)
	// 82E89648: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E8964C: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82E89650: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82E89654: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E89658: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82E8965C: 409A0010  bne cr6, 0x82e8966c
	if !ctx.cr[6].eq {
	pc = 0x82E8966C; continue 'dispatch;
	}
	// 82E89660: 4BFF63F9  bl 0x82e7fa58
	ctx.lr = 0x82E89664;
	sub_82E7FA58(ctx, base);
	// 82E89664: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82E89668: 4800000C  b 0x82e89674
	pc = 0x82E89674; continue 'dispatch;
            }
            0x82E8966C => {
    //   block [0x82E8966C..0x82E89674)
	// 82E8966C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E89670: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	pc = 0x82E89674; continue 'dispatch;
            }
            0x82E89674 => {
    //   block [0x82E89674..0x82E89690)
	// 82E89674: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E89678: 41820018  beq 0x82e89690
	if ctx.cr[0].eq {
	pc = 0x82E89690; continue 'dispatch;
	}
	// 82E8967C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E89680: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82E89684: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82E89688: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82E8968C: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	pc = 0x82E89690; continue 'dispatch;
            }
            0x82E89690 => {
    //   block [0x82E89690..0x82E8969C)
	// 82E89690: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E89694: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E89698: 4BE1FDBC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E896A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E896A0 size=60
    let mut pc: u32 = 0x82E896A0;
    'dispatch: loop {
        match pc {
            0x82E896A0 => {
    //   block [0x82E896A0..0x82E896DC)
	// 82E896A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E896A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E896A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E896AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E896B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E896B4: 4BFFFF25  bl 0x82e895d8
	ctx.lr = 0x82E896B8;
	sub_82E895D8(ctx, base);
	// 82E896B8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E896BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E896C0: 396BB254  addi r11, r11, -0x4dac
	ctx.r[11].s64 = ctx.r[11].s64 + -19884;
	// 82E896C4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E896C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E896CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E896D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E896D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E896D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E896E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E896E0 size=20
    let mut pc: u32 = 0x82E896E0;
    'dispatch: loop {
        match pc {
            0x82E896E0 => {
    //   block [0x82E896E0..0x82E896F4)
	// 82E896E0: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E896E4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E896E8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E896EC: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82E896F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E896F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E896F8 size=116
    let mut pc: u32 = 0x82E896F8;
    'dispatch: loop {
        match pc {
            0x82E896F8 => {
    //   block [0x82E896F8..0x82E89740)
	// 82E896F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E896FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E89700: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E89704: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E89708: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82E8970C: 816A20BC  lwz r11, 0x20bc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8380 as u32) ) } as u64;
	// 82E89710: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82E89714: 3D208334  lis r9, -0x7ccc
	ctx.r[9].s64 = -2093744128;
	// 82E89718: 3BE91CB8  addi r31, r9, 0x1cb8
	ctx.r[31].s64 = ctx.r[9].s64 + 7352;
	// 82E8971C: 40820038  bne 0x82e89754
	if !ctx.cr[0].eq {
	pc = 0x82E89754; continue 'dispatch;
	}
	// 82E89720: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82E89724: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82E89728: 8909DC54  lbz r8, -0x23ac(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-9132 as u32) ) } as u64;
	// 82E8972C: 916A20BC  stw r11, 0x20bc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8380 as u32), ctx.r[11].u32 ) };
	// 82E89730: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E89734: 4182000C  beq 0x82e89740
	if ctx.cr[0].eq {
	pc = 0x82E89740; continue 'dispatch;
	}
	// 82E89738: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8973C: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	pc = 0x82E89740; continue 'dispatch;
            }
            0x82E89740 => {
    //   block [0x82E89740..0x82E89754)
	// 82E89740: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E89744: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82E89748: 386A8460  addi r3, r10, -0x7ba0
	ctx.r[3].s64 = ctx.r[10].s64 + -31648;
	// 82E8974C: 9969DC54  stb r11, -0x23ac(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-9132 as u32), ctx.r[11].u8 ) };
	// 82E89750: 4BE207D1  bl 0x82ca9f20
	ctx.lr = 0x82E89754;
	sub_82CA9F20(ctx, base);
	pc = 0x82E89754; continue 'dispatch;
            }
            0x82E89754 => {
    //   block [0x82E89754..0x82E8976C)
	// 82E89754: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E89758: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8975C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E89760: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E89764: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E89768: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E89770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E89770 size=200
    let mut pc: u32 = 0x82E89770;
    'dispatch: loop {
        match pc {
            0x82E89770 => {
    //   block [0x82E89770..0x82E897A4)
	// 82E89770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E89774: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E89778: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8977C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E89780: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E89784: 4BFF1CCD  bl 0x82e7b450
	ctx.lr = 0x82E89788;
	sub_82E7B450(ctx, base);
	// 82E89788: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E8978C: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82E89790: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E89794: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E89798: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8979C: 40810054  ble 0x82e897f0
	if !ctx.cr[0].gt {
	pc = 0x82E897F0; continue 'dispatch;
	}
	// 82E897A0: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82E897A4; continue 'dispatch;
            }
            0x82E897A4 => {
    //   block [0x82E897A4..0x82E897B0)
	// 82E897A4: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E897A8: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82E897AC: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	pc = 0x82E897B0; continue 'dispatch;
            }
            0x82E897B0 => {
    //   block [0x82E897B0..0x82E897D4)
	// 82E897B0: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E897B4: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E897B8: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E897BC: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82E897C0: 41820014  beq 0x82e897d4
	if ctx.cr[0].eq {
	pc = 0x82E897D4; continue 'dispatch;
	}
	// 82E897C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E897C8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82E897CC: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82E897D0: 419AFFE0  beq cr6, 0x82e897b0
	if ctx.cr[6].eq {
	pc = 0x82E897B0; continue 'dispatch;
	}
	pc = 0x82E897D4; continue 'dispatch;
            }
            0x82E897D4 => {
    //   block [0x82E897D4..0x82E897F0)
	// 82E897D4: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E897D8: 41820028  beq 0x82e89800
	if ctx.cr[0].eq {
	pc = 0x82E89800; continue 'dispatch;
	}
	// 82E897DC: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E897E0: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82E897E4: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82E897E8: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82E897EC: 4198FFB8  blt cr6, 0x82e897a4
	if ctx.cr[6].lt {
	pc = 0x82E897A4; continue 'dispatch;
	}
	pc = 0x82E897F0; continue 'dispatch;
            }
            0x82E897F0 => {
    //   block [0x82E897F0..0x82E89800)
	// 82E897F0: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82E897F4: 409A0018  bne cr6, 0x82e8980c
	if !ctx.cr[6].eq {
	pc = 0x82E8980C; continue 'dispatch;
	}
	// 82E897F8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E897FC: 48000028  b 0x82e89824
	pc = 0x82E89824; continue 'dispatch;
            }
            0x82E89800 => {
    //   block [0x82E89800..0x82E8980C)
	// 82E89800: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E89804: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82E89808: 48000018  b 0x82e89820
	pc = 0x82E89820; continue 'dispatch;
            }
            0x82E8980C => {
    //   block [0x82E8980C..0x82E89820)
	// 82E8980C: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E89810: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82E89814: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E89818: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E8981C: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	pc = 0x82E89820; continue 'dispatch;
            }
            0x82E89820 => {
    //   block [0x82E89820..0x82E89824)
	// 82E89820: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82E89824; continue 'dispatch;
            }
            0x82E89824 => {
    //   block [0x82E89824..0x82E89838)
	// 82E89824: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E89828: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8982C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E89830: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E89834: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E89838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E89838 size=200
    let mut pc: u32 = 0x82E89838;
    'dispatch: loop {
        match pc {
            0x82E89838 => {
    //   block [0x82E89838..0x82E8986C)
	// 82E89838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8983C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E89840: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E89844: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E89848: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8984C: 4BFFFEAD  bl 0x82e896f8
	ctx.lr = 0x82E89850;
	sub_82E896F8(ctx, base);
	// 82E89850: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E89854: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82E89858: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E8985C: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E89860: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E89864: 40810054  ble 0x82e898b8
	if !ctx.cr[0].gt {
	pc = 0x82E898B8; continue 'dispatch;
	}
	// 82E89868: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82E8986C; continue 'dispatch;
            }
            0x82E8986C => {
    //   block [0x82E8986C..0x82E89878)
	// 82E8986C: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E89870: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82E89874: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	pc = 0x82E89878; continue 'dispatch;
            }
            0x82E89878 => {
    //   block [0x82E89878..0x82E8989C)
	// 82E89878: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8987C: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E89880: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E89884: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82E89888: 41820014  beq 0x82e8989c
	if ctx.cr[0].eq {
	pc = 0x82E8989C; continue 'dispatch;
	}
	// 82E8988C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E89890: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82E89894: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82E89898: 419AFFE0  beq cr6, 0x82e89878
	if ctx.cr[6].eq {
	pc = 0x82E89878; continue 'dispatch;
	}
	pc = 0x82E8989C; continue 'dispatch;
            }
            0x82E8989C => {
    //   block [0x82E8989C..0x82E898B8)
	// 82E8989C: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E898A0: 41820028  beq 0x82e898c8
	if ctx.cr[0].eq {
	pc = 0x82E898C8; continue 'dispatch;
	}
	// 82E898A4: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E898A8: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82E898AC: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82E898B0: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82E898B4: 4198FFB8  blt cr6, 0x82e8986c
	if ctx.cr[6].lt {
	pc = 0x82E8986C; continue 'dispatch;
	}
	pc = 0x82E898B8; continue 'dispatch;
            }
            0x82E898B8 => {
    //   block [0x82E898B8..0x82E898C8)
	// 82E898B8: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82E898BC: 409A0018  bne cr6, 0x82e898d4
	if !ctx.cr[6].eq {
	pc = 0x82E898D4; continue 'dispatch;
	}
	// 82E898C0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E898C4: 48000028  b 0x82e898ec
	pc = 0x82E898EC; continue 'dispatch;
            }
            0x82E898C8 => {
    //   block [0x82E898C8..0x82E898D4)
	// 82E898C8: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E898CC: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82E898D0: 48000018  b 0x82e898e8
	pc = 0x82E898E8; continue 'dispatch;
            }
            0x82E898D4 => {
    //   block [0x82E898D4..0x82E898E8)
	// 82E898D4: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E898D8: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82E898DC: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E898E0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E898E4: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	pc = 0x82E898E8; continue 'dispatch;
            }
            0x82E898E8 => {
    //   block [0x82E898E8..0x82E898EC)
	// 82E898E8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82E898EC; continue 'dispatch;
            }
            0x82E898EC => {
    //   block [0x82E898EC..0x82E89900)
	// 82E898EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E898F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E898F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E898F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E898FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E89900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E89900 size=196
    let mut pc: u32 = 0x82E89900;
    'dispatch: loop {
        match pc {
            0x82E89900 => {
    //   block [0x82E89900..0x82E89938)
	// 82E89900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E89904: 4BE1FB01  bl 0x82ca9404
	ctx.lr = 0x82E89908;
	sub_82CA93D0(ctx, base);
	// 82E89908: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8990C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E89910: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E89914: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82E89918: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82E8991C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82E89920: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82E89924: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82E89928: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82E8992C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E89930: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82E89934: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	pc = 0x82E89938; continue 'dispatch;
            }
            0x82E89938 => {
    //   block [0x82E89938..0x82E89964)
	// 82E89938: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8993C: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E89940: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82E89944: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E89948: 4082FFF0  bne 0x82e89938
	if !ctx.cr[0].eq {
	pc = 0x82E89938; continue 'dispatch;
	}
	// 82E8994C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E89950: 4BFFFE21  bl 0x82e89770
	ctx.lr = 0x82E89954;
	sub_82E89770(ctx, base);
	// 82E89954: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E89958: 4082000C  bne 0x82e89964
	if !ctx.cr[0].eq {
	pc = 0x82E89964; continue 'dispatch;
	}
	// 82E8995C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82E89960: 48000010  b 0x82e89970
	pc = 0x82E89970; continue 'dispatch;
            }
            0x82E89964 => {
    //   block [0x82E89964..0x82E89970)
	// 82E89964: 4BFF1AED  bl 0x82e7b450
	ctx.lr = 0x82E89968;
	sub_82E7B450(ctx, base);
	// 82E89968: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E8996C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82E89970; continue 'dispatch;
            }
            0x82E89970 => {
    //   block [0x82E89970..0x82E89994)
	// 82E89970: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E89974: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82E89978: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82E8997C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E89980: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82E89984: 409A0010  bne cr6, 0x82e89994
	if !ctx.cr[6].eq {
	pc = 0x82E89994; continue 'dispatch;
	}
	// 82E89988: 4BFF60D1  bl 0x82e7fa58
	ctx.lr = 0x82E8998C;
	sub_82E7FA58(ctx, base);
	// 82E8998C: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82E89990: 4800000C  b 0x82e8999c
	pc = 0x82E8999C; continue 'dispatch;
            }
            0x82E89994 => {
    //   block [0x82E89994..0x82E8999C)
	// 82E89994: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E89998: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	pc = 0x82E8999C; continue 'dispatch;
            }
            0x82E8999C => {
    //   block [0x82E8999C..0x82E899B8)
	// 82E8999C: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E899A0: 41820018  beq 0x82e899b8
	if ctx.cr[0].eq {
	pc = 0x82E899B8; continue 'dispatch;
	}
	// 82E899A4: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E899A8: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82E899AC: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82E899B0: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82E899B4: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	pc = 0x82E899B8; continue 'dispatch;
            }
            0x82E899B8 => {
    //   block [0x82E899B8..0x82E899C4)
	// 82E899B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E899BC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E899C0: 4BE1FA94  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E899C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E899C8 size=196
    let mut pc: u32 = 0x82E899C8;
    'dispatch: loop {
        match pc {
            0x82E899C8 => {
    //   block [0x82E899C8..0x82E89A00)
	// 82E899C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E899CC: 4BE1FA39  bl 0x82ca9404
	ctx.lr = 0x82E899D0;
	sub_82CA93D0(ctx, base);
	// 82E899D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E899D4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E899D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E899DC: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82E899E0: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82E899E4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82E899E8: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82E899EC: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82E899F0: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82E899F4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E899F8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82E899FC: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	pc = 0x82E89A00; continue 'dispatch;
            }
            0x82E89A00 => {
    //   block [0x82E89A00..0x82E89A2C)
	// 82E89A00: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E89A04: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E89A08: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82E89A0C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E89A10: 4082FFF0  bne 0x82e89a00
	if !ctx.cr[0].eq {
	pc = 0x82E89A00; continue 'dispatch;
	}
	// 82E89A14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E89A18: 4BFFFE21  bl 0x82e89838
	ctx.lr = 0x82E89A1C;
	sub_82E89838(ctx, base);
	// 82E89A1C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E89A20: 4082000C  bne 0x82e89a2c
	if !ctx.cr[0].eq {
	pc = 0x82E89A2C; continue 'dispatch;
	}
	// 82E89A24: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82E89A28: 48000010  b 0x82e89a38
	pc = 0x82E89A38; continue 'dispatch;
            }
            0x82E89A2C => {
    //   block [0x82E89A2C..0x82E89A38)
	// 82E89A2C: 4BFFFCCD  bl 0x82e896f8
	ctx.lr = 0x82E89A30;
	sub_82E896F8(ctx, base);
	// 82E89A30: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E89A34: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82E89A38; continue 'dispatch;
            }
            0x82E89A38 => {
    //   block [0x82E89A38..0x82E89A5C)
	// 82E89A38: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E89A3C: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82E89A40: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82E89A44: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E89A48: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82E89A4C: 409A0010  bne cr6, 0x82e89a5c
	if !ctx.cr[6].eq {
	pc = 0x82E89A5C; continue 'dispatch;
	}
	// 82E89A50: 4BFF6009  bl 0x82e7fa58
	ctx.lr = 0x82E89A54;
	sub_82E7FA58(ctx, base);
	// 82E89A54: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82E89A58: 4800000C  b 0x82e89a64
	pc = 0x82E89A64; continue 'dispatch;
            }
            0x82E89A5C => {
    //   block [0x82E89A5C..0x82E89A64)
	// 82E89A5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E89A60: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	pc = 0x82E89A64; continue 'dispatch;
            }
            0x82E89A64 => {
    //   block [0x82E89A64..0x82E89A80)
	// 82E89A64: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E89A68: 41820018  beq 0x82e89a80
	if ctx.cr[0].eq {
	pc = 0x82E89A80; continue 'dispatch;
	}
	// 82E89A6C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E89A70: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82E89A74: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82E89A78: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82E89A7C: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	pc = 0x82E89A80; continue 'dispatch;
            }
            0x82E89A80 => {
    //   block [0x82E89A80..0x82E89A8C)
	// 82E89A80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E89A84: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E89A88: 4BE1F9CC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E89A90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E89A90 size=68
    let mut pc: u32 = 0x82E89A90;
    'dispatch: loop {
        match pc {
            0x82E89A90 => {
    //   block [0x82E89A90..0x82E89AD4)
	// 82E89A90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E89A94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E89A98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E89A9C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E89AA0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82E89AA4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82E89AA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E89AAC: 4BFFFE55  bl 0x82e89900
	ctx.lr = 0x82E89AB0;
	sub_82E89900(ctx, base);
	// 82E89AB0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E89AB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E89AB8: 396BB254  addi r11, r11, -0x4dac
	ctx.r[11].s64 = ctx.r[11].s64 + -19884;
	// 82E89ABC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E89AC0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E89AC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E89AC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E89ACC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E89AD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E89AD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E89AD8 size=68
    let mut pc: u32 = 0x82E89AD8;
    'dispatch: loop {
        match pc {
            0x82E89AD8 => {
    //   block [0x82E89AD8..0x82E89B1C)
	// 82E89AD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E89ADC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E89AE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E89AE4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E89AE8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82E89AEC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82E89AF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E89AF4: 4BFFFED5  bl 0x82e899c8
	ctx.lr = 0x82E89AF8;
	sub_82E899C8(ctx, base);
	// 82E89AF8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E89AFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E89B00: 396BB254  addi r11, r11, -0x4dac
	ctx.r[11].s64 = ctx.r[11].s64 + -19884;
	// 82E89B04: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E89B08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E89B0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E89B10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E89B14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E89B18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E89B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E89B20 size=236
    let mut pc: u32 = 0x82E89B20;
    'dispatch: loop {
        match pc {
            0x82E89B20 => {
    //   block [0x82E89B20..0x82E89B84)
	// 82E89B20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E89B24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E89B28: DBA1FFE0  stfd f29, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[29].u64 ) };
	// 82E89B2C: DBC1FFE8  stfd f30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[30].u64 ) };
	// 82E89B30: DBE1FFF0  stfd f31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 82E89B34: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E89B38: C1A40000  lfs f13, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E89B3C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E89B40: C0030000  lfs f0, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E89B44: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E89B48: C1830008  lfs f12, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E89B4C: C1A40008  lfs f13, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E89B50: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E89B54: C1640004  lfs f11, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E89B58: C1830004  lfs f12, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E89B5C: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E89B60: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E89B64: FF02F800  fcmpu cr6, f2, f31
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[31].f64);
	// 82E89B68: ED6D0372  fmuls f11, f13, f13
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82E89B6C: ED60583A  fmadds f11, f0, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82E89B70: EFAC5B3A  fmadds f29, f12, f12, f11
	ctx.f[29].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64);
	// 82E89B74: 41980010  blt cr6, 0x82e89b84
	if ctx.cr[6].lt {
	pc = 0x82E89B84; continue 'dispatch;
	}
	// 82E89B78: ED6200B2  fmuls f11, f2, f2
	ctx.f[11].f64 = (((ctx.f[2].f64 * ctx.f[2].f64) as f32) as f64);
	// 82E89B7C: FF1D5800  fcmpu cr6, f29, f11
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[11].f64);
	// 82E89B80: 4199006C  bgt cr6, 0x82e89bec
	if ctx.cr[6].gt {
	pc = 0x82E89BEC; continue 'dispatch;
	}
	pc = 0x82E89B84; continue 'dispatch;
            }
            0x82E89B84 => {
    //   block [0x82E89B84..0x82E89BCC)
	// 82E89B84: C1650004  lfs f11, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E89B88: ED8B0332  fmuls f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82E89B8C: C1650008  lfs f11, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E89B90: C1450000  lfs f10, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E89B94: EDAB637A  fmadds f13, f11, f13, f12
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 82E89B98: EFCA683A  fmadds f30, f10, f0, f13
	ctx.f[30].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82E89B9C: 4BFFC0A5  bl 0x82e85c40
	ctx.lr = 0x82E89BA0;
	sub_82E85C40(ctx, base);
	// 82E89BA0: FF1EF800  fcmpu cr6, f30, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 82E89BA4: 40980028  bge cr6, 0x82e89bcc
	if !ctx.cr[6].lt {
	pc = 0x82E89BCC; continue 'dispatch;
	}
	// 82E89BA8: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 82E89BAC: 40980040  bge cr6, 0x82e89bec
	if !ctx.cr[6].lt {
	pc = 0x82E89BEC; continue 'dispatch;
	}
	// 82E89BB0: EC010072  fmuls f0, f1, f1
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[1].f64) as f32) as f64);
	// 82E89BB4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E89BB8: EDBE07B2  fmuls f13, f30, f30
	ctx.f[13].f64 = (((ctx.f[30].f64 * ctx.f[30].f64) as f32) as f64);
	// 82E89BBC: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82E89BC0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E89BC4: 4099002C  ble cr6, 0x82e89bf0
	if !ctx.cr[6].gt {
	pc = 0x82E89BF0; continue 'dispatch;
	}
	// 82E89BC8: 48000024  b 0x82e89bec
	pc = 0x82E89BEC; continue 'dispatch;
            }
            0x82E89BCC => {
    //   block [0x82E89BCC..0x82E89BEC)
	// 82E89BCC: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 82E89BD0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E89BD4: 4198001C  blt cr6, 0x82e89bf0
	if ctx.cr[6].lt {
	pc = 0x82E89BF0; continue 'dispatch;
	}
	// 82E89BD8: EC010072  fmuls f0, f1, f1
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[1].f64) as f32) as f64);
	// 82E89BDC: EDBE07B2  fmuls f13, f30, f30
	ctx.f[13].f64 = (((ctx.f[30].f64 * ctx.f[30].f64) as f32) as f64);
	// 82E89BE0: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82E89BE4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E89BE8: 40980008  bge cr6, 0x82e89bf0
	if !ctx.cr[6].lt {
	pc = 0x82E89BF0; continue 'dispatch;
	}
	pc = 0x82E89BEC; continue 'dispatch;
            }
            0x82E89BEC => {
    //   block [0x82E89BEC..0x82E89BF0)
	// 82E89BEC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E89BF0; continue 'dispatch;
            }
            0x82E89BF0 => {
    //   block [0x82E89BF0..0x82E89C0C)
	// 82E89BF0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E89BF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E89BF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E89BFC: CBA1FFE0  lfd f29, -0x20(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82E89C00: CBC1FFE8  lfd f30, -0x18(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E89C04: CBE1FFF0  lfd f31, -0x10(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E89C08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E89C10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E89C10 size=308
    let mut pc: u32 = 0x82E89C10;
    'dispatch: loop {
        match pc {
            0x82E89C10 => {
    //   block [0x82E89C10..0x82E89C44)
	// 82E89C10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E89C14: 4BE1F7F9  bl 0x82ca940c
	ctx.lr = 0x82E89C18;
	sub_82CA93D0(ctx, base);
	// 82E89C18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E89C1C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E89C20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E89C24: 419A0114  beq cr6, 0x82e89d38
	if ctx.cr[6].eq {
	pc = 0x82E89D38; continue 'dispatch;
	}
	// 82E89C28: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82E89C2C: 419A010C  beq cr6, 0x82e89d38
	if ctx.cr[6].eq {
	pc = 0x82E89D38; continue 'dispatch;
	}
	// 82E89C30: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E89C34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E89C38: 2B0B002E  cmplwi cr6, r11, 0x2e
	ctx.cr[6].compare_u32(ctx.r[11].u32, 46 as u32, &mut ctx.xer);
	// 82E89C3C: 409A0008  bne cr6, 0x82e89c44
	if !ctx.cr[6].eq {
	pc = 0x82E89C44; continue 'dispatch;
	}
	// 82E89C40: 3BC30001  addi r30, r3, 1
	ctx.r[30].s64 = ctx.r[3].s64 + 1;
	pc = 0x82E89C44; continue 'dispatch;
            }
            0x82E89C44 => {
    //   block [0x82E89C44..0x82E89C54)
	// 82E89C44: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E89C48: 2B0B002F  cmplwi cr6, r11, 0x2f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 47 as u32, &mut ctx.xer);
	// 82E89C4C: 409A0008  bne cr6, 0x82e89c54
	if !ctx.cr[6].eq {
	pc = 0x82E89C54; continue 'dispatch;
	}
	// 82E89C50: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	pc = 0x82E89C54; continue 'dispatch;
            }
            0x82E89C54 => {
    //   block [0x82E89C54..0x82E89C64)
	// 82E89C54: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E89C58: 2B0B005C  cmplwi cr6, r11, 0x5c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 92 as u32, &mut ctx.xer);
	// 82E89C5C: 409A0008  bne cr6, 0x82e89c64
	if !ctx.cr[6].eq {
	pc = 0x82E89C64; continue 'dispatch;
	}
	// 82E89C60: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	pc = 0x82E89C64; continue 'dispatch;
            }
            0x82E89C64 => {
    //   block [0x82E89C64..0x82E89C74)
	// 82E89C64: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E89C68: 2B0B003A  cmplwi cr6, r11, 0x3a
	ctx.cr[6].compare_u32(ctx.r[11].u32, 58 as u32, &mut ctx.xer);
	// 82E89C6C: 409A0008  bne cr6, 0x82e89c74
	if !ctx.cr[6].eq {
	pc = 0x82E89C74; continue 'dispatch;
	}
	// 82E89C70: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	pc = 0x82E89C74; continue 'dispatch;
            }
            0x82E89C74 => {
    //   block [0x82E89C74..0x82E89C84)
	// 82E89C74: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E89C78: 3BEB21D4  addi r31, r11, 0x21d4
	ctx.r[31].s64 = ctx.r[11].s64 + 8660;
	// 82E89C7C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82E89C80: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82E89C84; continue 'dispatch;
            }
            0x82E89C84 => {
    //   block [0x82E89C84..0x82E89CBC)
	// 82E89C84: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E89C88: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E89C8C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E89C90: 409AFFF4  bne cr6, 0x82e89c84
	if !ctx.cr[6].eq {
	pc = 0x82E89C84; continue 'dispatch;
	}
	// 82E89C94: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82E89C98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E89C9C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82E89CA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E89CA4: 5565003E  slwi r5, r11, 0
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82E89CA8: 4BE20449  bl 0x82caa0f0
	ctx.lr = 0x82E89CAC;
	sub_82CAA0F0(ctx, base);
	// 82E89CAC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E89CB0: 41820024  beq 0x82e89cd4
	if ctx.cr[0].eq {
	pc = 0x82E89CD4; continue 'dispatch;
	}
	// 82E89CB4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82E89CB8: 7D3FE850  subf r9, r31, r29
	ctx.r[9].s64 = ctx.r[29].s64 - ctx.r[31].s64;
	pc = 0x82E89CBC; continue 'dispatch;
            }
            0x82E89CBC => {
    //   block [0x82E89CBC..0x82E89CD4)
	// 82E89CBC: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E89CC0: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E89CC4: 7D4959AE  stbx r10, r9, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u8) };
	// 82E89CC8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E89CCC: 4082FFF0  bne 0x82e89cbc
	if !ctx.cr[0].eq {
	pc = 0x82E89CBC; continue 'dispatch;
	}
	// 82E89CD0: 4800000C  b 0x82e89cdc
	pc = 0x82E89CDC; continue 'dispatch;
            }
            0x82E89CD4 => {
    //   block [0x82E89CD4..0x82E89CDC)
	// 82E89CD4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E89CD8: 997D0000  stb r11, 0(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	pc = 0x82E89CDC; continue 'dispatch;
            }
            0x82E89CDC => {
    //   block [0x82E89CDC..0x82E89CE4)
	// 82E89CDC: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 82E89CE0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82E89CE4; continue 'dispatch;
            }
            0x82E89CE4 => {
    //   block [0x82E89CE4..0x82E89CF8)
	// 82E89CE4: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E89CE8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E89CEC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E89CF0: 409AFFF4  bne cr6, 0x82e89ce4
	if !ctx.cr[6].eq {
	pc = 0x82E89CE4; continue 'dispatch;
	}
	// 82E89CF4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82E89CF8; continue 'dispatch;
            }
            0x82E89CF8 => {
    //   block [0x82E89CF8..0x82E89D14)
	// 82E89CF8: 892A0000  lbz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E89CFC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E89D00: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E89D04: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 82E89D08: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E89D0C: 4082FFEC  bne 0x82e89cf8
	if !ctx.cr[0].eq {
	pc = 0x82E89CF8; continue 'dispatch;
	}
	// 82E89D10: 4800000C  b 0x82e89d1c
	pc = 0x82E89D1C; continue 'dispatch;
            }
            0x82E89D14 => {
    //   block [0x82E89D14..0x82E89D1C)
	// 82E89D14: 3940005C  li r10, 0x5c
	ctx.r[10].s64 = 92;
	// 82E89D18: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	pc = 0x82E89D1C; continue 'dispatch;
            }
            0x82E89D1C => {
    //   block [0x82E89D1C..0x82E89D38)
	// 82E89D1C: 3880002F  li r4, 0x2f
	ctx.r[4].s64 = 47;
	// 82E89D20: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E89D24: 4BE204ED  bl 0x82caa210
	ctx.lr = 0x82E89D28;
	sub_82CAA210(ctx, base);
	// 82E89D28: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E89D2C: 4082FFE8  bne 0x82e89d14
	if !ctx.cr[0].eq {
	pc = 0x82E89D14; continue 'dispatch;
	}
	// 82E89D30: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E89D34: 48000008  b 0x82e89d3c
	pc = 0x82E89D3C; continue 'dispatch;
            }
            0x82E89D38 => {
    //   block [0x82E89D38..0x82E89D3C)
	// 82E89D38: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E89D3C; continue 'dispatch;
            }
            0x82E89D3C => {
    //   block [0x82E89D3C..0x82E89D44)
	// 82E89D3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E89D40: 4BE1F71C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E89D48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E89D48 size=16
    let mut pc: u32 = 0x82E89D48;
    'dispatch: loop {
        match pc {
            0x82E89D48 => {
    //   block [0x82E89D48..0x82E89D58)
	// 82E89D48: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E89D4C: 396B9664  addi r11, r11, -0x699c
	ctx.r[11].s64 = ctx.r[11].s64 + -27036;
	// 82E89D50: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E89D54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E89D58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E89D58 size=16
    let mut pc: u32 = 0x82E89D58;
    'dispatch: loop {
        match pc {
            0x82E89D58 => {
    //   block [0x82E89D58..0x82E89D68)
	// 82E89D58: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E89D5C: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82E89D60: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E89D64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E89D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E89D68 size=236
    let mut pc: u32 = 0x82E89D68;
    'dispatch: loop {
        match pc {
            0x82E89D68 => {
    //   block [0x82E89D68..0x82E89D84)
	// 82E89D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E89D6C: 4BE1F689  bl 0x82ca93f4
	ctx.lr = 0x82E89D70;
	sub_82CA93D0(ctx, base);
	// 82E89D70: 9421FB50  stwu r1, -0x4b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-1200 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E89D74: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 82E89D78: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 82E89D7C: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82E89D80: 409A000C  bne cr6, 0x82e89d8c
	if !ctx.cr[6].eq {
	pc = 0x82E89D8C; continue 'dispatch;
	}
	pc = 0x82E89D84; continue 'dispatch;
            }
            0x82E89D84 => {
    //   block [0x82E89D84..0x82E89D8C)
	// 82E89D84: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E89D88: 480000C4  b 0x82e89e4c
	pc = 0x82E89E4C; continue 'dispatch;
            }
            0x82E89D8C => {
    //   block [0x82E89D8C..0x82E89DA0)
	// 82E89D8C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E89D90: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82E89D94: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E89D98: 3F408330  lis r26, -0x7cd0
	ctx.r[26].s64 = -2094006272;
	// 82E89D9C: 3B2BDAC0  addi r25, r11, -0x2540
	ctx.r[25].s64 = ctx.r[11].s64 + -9536;
	pc = 0x82E89DA0; continue 'dispatch;
            }
            0x82E89DA0 => {
    //   block [0x82E89DA0..0x82E89DF8)
	// 82E89DA0: 81790064  lwz r11, 0x64(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E89DA4: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 82E89DA8: 38A00400  li r5, 0x400
	ctx.r[5].s64 = 1024;
	// 82E89DAC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E89DB0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E89DB4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E89DB8: 4E800421  bctrl
	ctx.lr = 0x82E89DBC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E89DBC: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82E89DC0: 41820050  beq 0x82e89e10
	if ctx.cr[0].eq {
	pc = 0x82E89E10; continue 'dispatch;
	}
	// 82E89DC4: 7F7CF214  add r27, r28, r30
	ctx.r[27].u64 = ctx.r[28].u64 + ctx.r[30].u64;
	// 82E89DC8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82E89DCC: 4B78CB5D  bl 0x82616928
	ctx.lr = 0x82E89DD0;
	sub_82616928(ctx, base);
	// 82E89DD0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E89DD4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E89DD8: 419A0020  beq cr6, 0x82e89df8
	if ctx.cr[6].eq {
	pc = 0x82E89DF8; continue 'dispatch;
	}
	// 82E89DDC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E89DE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E89DE4: 4B4432C5  bl 0x822cd0a8
	ctx.lr = 0x82E89DE8;
	sub_822CD0A8(ctx, base);
	// 82E89DE8: 817ADAB4  lwz r11, -0x254c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E89DEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E89DF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E89DF4: 4E800421  bctrl
	ctx.lr = 0x82E89DF8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E89DF8 => {
    //   block [0x82E89DF8..0x82E89E10)
	// 82E89DF8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82E89DFC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82E89E00: 7C7DF214  add r3, r29, r30
	ctx.r[3].u64 = ctx.r[29].u64 + ctx.r[30].u64;
	// 82E89E04: 4B4432A5  bl 0x822cd0a8
	ctx.lr = 0x82E89E08;
	sub_822CD0A8(ctx, base);
	// 82E89E08: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 82E89E0C: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	pc = 0x82E89E10; continue 'dispatch;
            }
            0x82E89E10 => {
    //   block [0x82E89E10..0x82E89E4C)
	// 82E89E10: 2B1C0400  cmplwi cr6, r28, 0x400
	ctx.cr[6].compare_u32(ctx.r[28].u32, 1024 as u32, &mut ctx.xer);
	// 82E89E14: 419AFF8C  beq cr6, 0x82e89da0
	if ctx.cr[6].eq {
	pc = 0x82E89DA0; continue 'dispatch;
	}
	// 82E89E18: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E89E1C: 419AFF68  beq cr6, 0x82e89d84
	if ctx.cr[6].eq {
	pc = 0x82E89D84; continue 'dispatch;
	}
	// 82E89E20: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 82E89E24: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E89E28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E89E2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E89E30: 480013B9  bl 0x82e8b1e8
	ctx.lr = 0x82E89E34;
	sub_82E8B1E8(ctx, base);
	// 82E89E34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E89E38: 817ADAB4  lwz r11, -0x254c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E89E3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E89E40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E89E44: 4E800421  bctrl
	ctx.lr = 0x82E89E48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E89E48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
            }
            0x82E89E4C => {
    //   block [0x82E89E4C..0x82E89E54)
	// 82E89E4C: 382104B0  addi r1, r1, 0x4b0
	ctx.r[1].s64 = ctx.r[1].s64 + 1200;
	// 82E89E50: 4BE1F5F4  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E89E58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E89E58 size=124
    let mut pc: u32 = 0x82E89E58;
    'dispatch: loop {
        match pc {
            0x82E89E58 => {
    //   block [0x82E89E58..0x82E89E7C)
	// 82E89E58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E89E5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E89E60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E89E64: 9421FBA0  stwu r1, -0x460(r1)
	ea = ctx.r[1].u32.wrapping_add(-1120 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E89E68: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E89E6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E89E70: 4BA83E99  bl 0x8290dd08
	ctx.lr = 0x82E89E74;
	sub_8290DD08(ctx, base);
	// 82E89E74: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E89E78: 40820010  bne 0x82e89e88
	if !ctx.cr[0].eq {
	pc = 0x82E89E88; continue 'dispatch;
	}
	pc = 0x82E89E7C; continue 'dispatch;
            }
            0x82E89E7C => {
    //   block [0x82E89E7C..0x82E89E88)
	// 82E89E7C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E89E80: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E89E84: 48000038  b 0x82e89ebc
	pc = 0x82E89EBC; continue 'dispatch;
            }
            0x82E89E88 => {
    //   block [0x82E89E88..0x82E89EBC)
	// 82E89E88: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E89E8C: 4BFFFD85  bl 0x82e89c10
	ctx.lr = 0x82E89E90;
	sub_82E89C10(ctx, base);
	// 82E89E90: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E89E94: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82E89E98: 396BDAC0  addi r11, r11, -0x2540
	ctx.r[11].s64 = ctx.r[11].s64 + -9536;
	// 82E89E9C: 388A6B38  addi r4, r10, 0x6b38
	ctx.r[4].s64 = ctx.r[10].s64 + 27448;
	// 82E89EA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E89EA4: 816B0050  lwz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E89EA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E89EAC: 4E800421  bctrl
	ctx.lr = 0x82E89EB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E89EB0: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E89EB4: 4182FFC8  beq 0x82e89e7c
	if ctx.cr[0].eq {
	pc = 0x82E89E7C; continue 'dispatch;
	}
	// 82E89EB8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
            }
            0x82E89EBC => {
    //   block [0x82E89EBC..0x82E89ED4)
	// 82E89EBC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E89EC0: 38210460  addi r1, r1, 0x460
	ctx.r[1].s64 = ctx.r[1].s64 + 1120;
	// 82E89EC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E89EC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E89ECC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E89ED0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E89ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E89ED8 size=28
    let mut pc: u32 = 0x82E89ED8;
    'dispatch: loop {
        match pc {
            0x82E89ED8 => {
    //   block [0x82E89ED8..0x82E89EF4)
	// 82E89ED8: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82E89EDC: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82E89EE0: 80C40008  lwz r6, 8(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E89EE4: 28060000  cmplwi r6, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E89EE8: 4082000C  bne 0x82e89ef4
	if !ctx.cr[0].eq {
		sub_82E89EF4(ctx, base);
		return;
	}
	// 82E89EEC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E89EF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E89EF4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E89EF4 size=24
    let mut pc: u32 = 0x82E89EF4;
    'dispatch: loop {
        match pc {
            0x82E89EF4 => {
    //   block [0x82E89EF4..0x82E89F0C)
	// 82E89EF4: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E89EF8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E89EFC: 396BDAC0  addi r11, r11, -0x2540
	ctx.r[11].s64 = ctx.r[11].s64 + -9536;
	// 82E89F00: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E89F04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E89F08: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E89F10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E89F10 size=32
    let mut pc: u32 = 0x82E89F10;
    'dispatch: loop {
        match pc {
            0x82E89F10 => {
    //   block [0x82E89F10..0x82E89F30)
	// 82E89F10: 80640008  lwz r3, 8(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E89F14: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E89F18: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
	// 82E89F1C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E89F20: 396BDAC0  addi r11, r11, -0x2540
	ctx.r[11].s64 = ctx.r[11].s64 + -9536;
	// 82E89F24: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E89F28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E89F2C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E89F30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E89F30 size=4
    let mut pc: u32 = 0x82E89F30;
    'dispatch: loop {
        match pc {
            0x82E89F30 => {
    //   block [0x82E89F30..0x82E89F34)
	// 82E89F30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E89F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E89F38 size=268
    let mut pc: u32 = 0x82E89F38;
    'dispatch: loop {
        match pc {
            0x82E89F38 => {
    //   block [0x82E89F38..0x82E89FB4)
	// 82E89F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E89F3C: 4BE1F4CD  bl 0x82ca9408
	ctx.lr = 0x82E89F40;
	sub_82CA93D0(ctx, base);
	// 82E89F40: 9421FB80  stwu r1, -0x480(r1)
	ea = ctx.r[1].u32.wrapping_add(-1152 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E89F44: 83C40008  lwz r30, 8(r4)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E89F48: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E89F4C: 41820068  beq 0x82e89fb4
	if ctx.cr[0].eq {
	pc = 0x82E89FB4; continue 'dispatch;
	}
	// 82E89F50: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E89F54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E89F58: 3BEBDAC0  addi r31, r11, -0x2540
	ctx.r[31].s64 = ctx.r[11].s64 + -9536;
	// 82E89F5C: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82E89F60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E89F64: 4E800421  bctrl
	ctx.lr = 0x82E89F68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E89F68: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E89F6C: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82E89F70: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82E89F74: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82E89F78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E89F7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E89F80: 4E800421  bctrl
	ctx.lr = 0x82E89F84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E89F84: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82E89F88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E89F8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E89F90: 4E800421  bctrl
	ctx.lr = 0x82E89F94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E89F94: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82E89F98: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82E89F9C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E89FA0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E89FA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E89FA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E89FAC: 4E800421  bctrl
	ctx.lr = 0x82E89FB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E89FB0: 48000088  b 0x82e8a038
	pc = 0x82E8A038; continue 'dispatch;
            }
            0x82E89FB4 => {
    //   block [0x82E89FB4..0x82E89FC4)
	// 82E89FB4: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82E89FB8: 4BA83D51  bl 0x8290dd08
	ctx.lr = 0x82E89FBC;
	sub_8290DD08(ctx, base);
	// 82E89FBC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E89FC0: 4082000C  bne 0x82e89fcc
	if !ctx.cr[0].eq {
	pc = 0x82E89FCC; continue 'dispatch;
	}
	pc = 0x82E89FC4; continue 'dispatch;
            }
            0x82E89FC4 => {
    //   block [0x82E89FC4..0x82E89FCC)
	// 82E89FC4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E89FC8: 48000074  b 0x82e8a03c
	pc = 0x82E8A03C; continue 'dispatch;
            }
            0x82E89FCC => {
    //   block [0x82E89FCC..0x82E8A038)
	// 82E89FCC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E89FD0: 4BFFFC41  bl 0x82e89c10
	ctx.lr = 0x82E89FD4;
	sub_82E89C10(ctx, base);
	// 82E89FD4: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E89FD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E89FDC: 3BEBDAC0  addi r31, r11, -0x2540
	ctx.r[31].s64 = ctx.r[11].s64 + -9536;
	// 82E89FE0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82E89FE4: 388B6B38  addi r4, r11, 0x6b38
	ctx.r[4].s64 = ctx.r[11].s64 + 27448;
	// 82E89FE8: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E89FEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E89FF0: 4E800421  bctrl
	ctx.lr = 0x82E89FF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E89FF4: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82E89FF8: 4182FFCC  beq 0x82e89fc4
	if ctx.cr[0].eq {
	pc = 0x82E89FC4; continue 'dispatch;
	}
	// 82E89FFC: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82E8A000: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82E8A004: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82E8A008: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8A00C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8A010: 4E800421  bctrl
	ctx.lr = 0x82E8A014;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8A014: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82E8A018: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8A01C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8A020: 4E800421  bctrl
	ctx.lr = 0x82E8A024;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8A024: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82E8A028: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E8A02C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8A030: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8A034: 4E800421  bctrl
	ctx.lr = 0x82E8A038;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8A038 => {
    //   block [0x82E8A038..0x82E8A03C)
	// 82E8A038: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	pc = 0x82E8A03C; continue 'dispatch;
            }
            0x82E8A03C => {
    //   block [0x82E8A03C..0x82E8A044)
	// 82E8A03C: 38210480  addi r1, r1, 0x480
	ctx.r[1].s64 = ctx.r[1].s64 + 1152;
	// 82E8A040: 4BE1F418  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8A048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8A048 size=48
    let mut pc: u32 = 0x82E8A048;
    'dispatch: loop {
        match pc {
            0x82E8A048 => {
    //   block [0x82E8A048..0x82E8A078)
	// 82E8A048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8A04C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8A050: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8A054: 4BFF579D  bl 0x82e7f7f0
	ctx.lr = 0x82E8A058;
	sub_82E7F7F0(ctx, base);
	// 82E8A058: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E8A05C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82E8A060: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82E8A064: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82E8A068: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8A06C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8A070: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8A074: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8A078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8A078 size=164
    let mut pc: u32 = 0x82E8A078;
    'dispatch: loop {
        match pc {
            0x82E8A078 => {
    //   block [0x82E8A078..0x82E8A0AC)
	// 82E8A078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8A07C: 4BE1F389  bl 0x82ca9404
	ctx.lr = 0x82E8A080;
	sub_82CA93D0(ctx, base);
	// 82E8A080: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8A084: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8A088: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82E8A08C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82E8A090: 419A0078  beq cr6, 0x82e8a108
	if ctx.cr[6].eq {
	pc = 0x82E8A108; continue 'dispatch;
	}
	// 82E8A094: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E8A098: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82E8A09C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8A0A0: 40990068  ble cr6, 0x82e8a108
	if !ctx.cr[6].gt {
	pc = 0x82E8A108; continue 'dispatch;
	}
	// 82E8A0A4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8A0A8: 3B6B8FD8  addi r27, r11, -0x7028
	ctx.r[27].s64 = ctx.r[11].s64 + -28712;
	pc = 0x82E8A0AC; continue 'dispatch;
            }
            0x82E8A0AC => {
    //   block [0x82E8A0AC..0x82E8A0F8)
	// 82E8A0AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E8A0B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8A0B4: 4BFF9F75  bl 0x82e84028
	ctx.lr = 0x82E8A0B8;
	sub_82E84028(ctx, base);
	// 82E8A0B8: 48331FA9  bl 0x831bc060
	ctx.lr = 0x82E8A0BC;
	sub_831BC060(ctx, base);
	// 82E8A0BC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E8A0C0: 4BE22A91  bl 0x82cacb50
	ctx.lr = 0x82E8A0C4;
	sub_82CACB50(ctx, base);
	// 82E8A0C4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8A0C8: 41820030  beq 0x82e8a0f8
	if ctx.cr[0].eq {
	pc = 0x82E8A0F8; continue 'dispatch;
	}
	// 82E8A0CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E8A0D0: 83BC0000  lwz r29, 0(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8A0D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8A0D8: 4BFF9F51  bl 0x82e84028
	ctx.lr = 0x82E8A0DC;
	sub_82E84028(ctx, base);
	// 82E8A0DC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E8A0E0: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E8A0E4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E8A0E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8A0EC: 4E800421  bctrl
	ctx.lr = 0x82E8A0F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8A0F0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8A0F4: 41820020  beq 0x82e8a114
	if ctx.cr[0].eq {
	pc = 0x82E8A114; continue 'dispatch;
	}
            }
            0x82E8A0F8 => {
    //   block [0x82E8A0F8..0x82E8A108)
	// 82E8A0F8: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E8A0FC: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82E8A100: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8A104: 4198FFA8  blt cr6, 0x82e8a0ac
	if ctx.cr[6].lt {
	pc = 0x82E8A0AC; continue 'dispatch;
	}
	pc = 0x82E8A108; continue 'dispatch;
            }
            0x82E8A108 => {
    //   block [0x82E8A108..0x82E8A10C)
	// 82E8A108: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82E8A10C; continue 'dispatch;
            }
            0x82E8A10C => {
    //   block [0x82E8A10C..0x82E8A114)
	// 82E8A10C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E8A110: 4BE1F344  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82E8A114 => {
    //   block [0x82E8A114..0x82E8A11C)
	// 82E8A114: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8A118: 4BFFFFF4  b 0x82e8a10c
	pc = 0x82E8A10C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8A120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8A120 size=140
    let mut pc: u32 = 0x82E8A120;
    'dispatch: loop {
        match pc {
            0x82E8A120 => {
    //   block [0x82E8A120..0x82E8A158)
	// 82E8A120: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8A124: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8A128: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8A12C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8A130: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8A134: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8A138: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8A13C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8A140: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E8A144: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E8A148: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8A14C: 409A000C  bne cr6, 0x82e8a158
	if !ctx.cr[6].eq {
	pc = 0x82E8A158; continue 'dispatch;
	}
	// 82E8A150: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8A154: 48000040  b 0x82e8a194
	pc = 0x82E8A194; continue 'dispatch;
            }
            0x82E8A158 => {
    //   block [0x82E8A158..0x82E8A194)
	// 82E8A158: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E8A15C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8A160: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82E8A164: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82E8A168: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82E8A16C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E8A170: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E8A174: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82E8A178: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8A17C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82E8A180: 4BFEB549  bl 0x82e756c8
	ctx.lr = 0x82E8A184;
	sub_82E756C8(ctx, base);
	// 82E8A184: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E8A188: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8A18C: 4BFF4CB5  bl 0x82e7ee40
	ctx.lr = 0x82E8A190;
	sub_82E7EE40(ctx, base);
	// 82E8A190: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82E8A194; continue 'dispatch;
            }
            0x82E8A194 => {
    //   block [0x82E8A194..0x82E8A1AC)
	// 82E8A194: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E8A198: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8A19C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8A1A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8A1A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8A1A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8A1B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8A1B0 size=20
    let mut pc: u32 = 0x82E8A1B0;
    'dispatch: loop {
        match pc {
            0x82E8A1B0 => {
    //   block [0x82E8A1B0..0x82E8A1C4)
	// 82E8A1B0: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E8A1B4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8A1B8: 4082000C  bne 0x82e8a1c4
	if !ctx.cr[0].eq {
		crate::recompiler::externs::call(ctx, base, 0x82E8A1C4);
		return;
	}
	// 82E8A1BC: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82E8A1C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8A1E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8A1E8 size=216
    let mut pc: u32 = 0x82E8A1E8;
    'dispatch: loop {
        match pc {
            0x82E8A1E8 => {
    //   block [0x82E8A1E8..0x82E8A240)
	// 82E8A1E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8A1EC: 4BE1F21D  bl 0x82ca9408
	ctx.lr = 0x82E8A1F0;
	sub_82CA93D0(ctx, base);
	// 82E8A1F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8A1F4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8A1F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8A1FC: 396B968C  addi r11, r11, -0x6974
	ctx.r[11].s64 = ctx.r[11].s64 + -26996;
	// 82E8A200: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82E8A204: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E8A208: 394AAFB4  addi r10, r10, -0x504c
	ctx.r[10].s64 = ctx.r[10].s64 + -20556;
	// 82E8A20C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82E8A210: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E8A214: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8A218: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82E8A21C: 93BF0010  stw r29, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 82E8A220: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82E8A224: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82E8A228: 9BBF0014  stb r29, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82E8A22C: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E8A230: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82E8A234: 419A0054  beq cr6, 0x82e8a288
	if ctx.cr[6].eq {
	pc = 0x82E8A288; continue 'dispatch;
	}
	// 82E8A238: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82E8A23C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82E8A240; continue 'dispatch;
            }
            0x82E8A240 => {
    //   block [0x82E8A240..0x82E8A26C)
	// 82E8A240: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8A244: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E8A248: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E8A24C: 409AFFF4  bne cr6, 0x82e8a240
	if !ctx.cr[6].eq {
	pc = 0x82E8A240; continue 'dispatch;
	}
	// 82E8A250: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82E8A254: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82E8A258: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E8A25C: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 82E8A260: 4B78C6C9  bl 0x82616928
	ctx.lr = 0x82E8A264;
	sub_82616928(ctx, base);
	// 82E8A264: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E8A268: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	pc = 0x82E8A26C; continue 'dispatch;
            }
            0x82E8A26C => {
    //   block [0x82E8A26C..0x82E8A288)
	// 82E8A26C: 895E0000  lbz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8A270: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82E8A274: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8A278: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82E8A27C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E8A280: 4082FFEC  bne 0x82e8a26c
	if !ctx.cr[0].eq {
	pc = 0x82E8A26C; continue 'dispatch;
	}
	// 82E8A284: 48000008  b 0x82e8a28c
	pc = 0x82E8A28C; continue 'dispatch;
            }
            0x82E8A288 => {
    //   block [0x82E8A288..0x82E8A28C)
	// 82E8A288: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	pc = 0x82E8A28C; continue 'dispatch;
            }
            0x82E8A28C => {
    //   block [0x82E8A28C..0x82E8A2AC)
	// 82E8A28C: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82E8A290: 4B78C699  bl 0x82616928
	ctx.lr = 0x82E8A294;
	sub_82616928(ctx, base);
	// 82E8A294: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8A298: 41820014  beq 0x82e8a2ac
	if ctx.cr[0].eq {
	pc = 0x82E8A2AC; continue 'dispatch;
	}
	// 82E8A29C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E8A2A0: 48002F91  bl 0x82e8d230
	ctx.lr = 0x82E8A2A4;
	sub_82E8D230(ctx, base);
	// 82E8A2A4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E8A2A8: 48000008  b 0x82e8a2b0
	pc = 0x82E8A2B0; continue 'dispatch;
            }
            0x82E8A2AC => {
    //   block [0x82E8A2AC..0x82E8A2B0)
	// 82E8A2AC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82E8A2B0; continue 'dispatch;
            }
            0x82E8A2B0 => {
    //   block [0x82E8A2B0..0x82E8A2C0)
	// 82E8A2B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8A2B4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E8A2B8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E8A2BC: 4BE1F19C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8A2C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8A2C0 size=12
    let mut pc: u32 = 0x82E8A2C0;
    'dispatch: loop {
        match pc {
            0x82E8A2C0 => {
    //   block [0x82E8A2C0..0x82E8A2CC)
	// 82E8A2C0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8A2C4: 386B21D8  addi r3, r11, 0x21d8
	ctx.r[3].s64 = ctx.r[11].s64 + 8664;
	// 82E8A2C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8A2D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8A2D0 size=128
    let mut pc: u32 = 0x82E8A2D0;
    'dispatch: loop {
        match pc {
            0x82E8A2D0 => {
    //   block [0x82E8A2D0..0x82E8A310)
	// 82E8A2D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8A2D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8A2D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8A2DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8A2E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8A2E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8A2E8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8A2EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E8A2F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8A2F4: 4BFF4BFD  bl 0x82e7eef0
	ctx.lr = 0x82E8A2F8;
	sub_82E7EEF0(ctx, base);
	// 82E8A2F8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E8A2FC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8A300: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82E8A304: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82E8A308: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8A30C: 48000014  b 0x82e8a320
	pc = 0x82E8A320; continue 'dispatch;
            }
            0x82E8A310 => {
    //   block [0x82E8A310..0x82E8A320)
	// 82E8A310: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8A314: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82E8A318: 419A0018  beq cr6, 0x82e8a330
	if ctx.cr[6].eq {
	pc = 0x82E8A330; continue 'dispatch;
	}
	// 82E8A31C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x82E8A320; continue 'dispatch;
            }
            0x82E8A320 => {
    //   block [0x82E8A320..0x82E8A330)
	// 82E8A320: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8A324: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82E8A328: 4082FFE8  bne 0x82e8a310
	if !ctx.cr[0].eq {
	pc = 0x82E8A310; continue 'dispatch;
	}
	// 82E8A32C: 4800000C  b 0x82e8a338
	pc = 0x82E8A338; continue 'dispatch;
            }
            0x82E8A330 => {
    //   block [0x82E8A330..0x82E8A338)
	// 82E8A330: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E8A334: 4BFFAB4D  bl 0x82e84e80
	ctx.lr = 0x82E8A338;
	sub_82E84E80(ctx, base);
	pc = 0x82E8A338; continue 'dispatch;
            }
            0x82E8A338 => {
    //   block [0x82E8A338..0x82E8A350)
	// 82E8A338: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8A33C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8A340: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8A344: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8A348: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8A34C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8A350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8A350 size=88
    let mut pc: u32 = 0x82E8A350;
    'dispatch: loop {
        match pc {
            0x82E8A350 => {
    //   block [0x82E8A350..0x82E8A38C)
	// 82E8A350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8A354: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8A358: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8A35C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8A360: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8A364: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8A368: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82E8A36C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8A370: 4B78C5B9  bl 0x82616928
	ctx.lr = 0x82E8A374;
	sub_82616928(ctx, base);
	// 82E8A374: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8A378: 41820014  beq 0x82e8a38c
	if ctx.cr[0].eq {
	pc = 0x82E8A38C; continue 'dispatch;
	}
	// 82E8A37C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8A380: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E8A384: 4BFFFE65  bl 0x82e8a1e8
	ctx.lr = 0x82E8A388;
	sub_82E8A1E8(ctx, base);
	// 82E8A388: 48000008  b 0x82e8a390
	pc = 0x82E8A390; continue 'dispatch;
            }
            0x82E8A38C => {
    //   block [0x82E8A38C..0x82E8A390)
	// 82E8A38C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E8A390; continue 'dispatch;
            }
            0x82E8A390 => {
    //   block [0x82E8A390..0x82E8A3A8)
	// 82E8A390: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8A394: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8A398: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8A39C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8A3A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8A3A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8A3A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8A3A8 size=168
    let mut pc: u32 = 0x82E8A3A8;
    'dispatch: loop {
        match pc {
            0x82E8A3A8 => {
    //   block [0x82E8A3A8..0x82E8A3D4)
	// 82E8A3A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8A3AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8A3B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8A3B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8A3B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8A3BC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8A3C0: 396B968C  addi r11, r11, -0x6974
	ctx.r[11].s64 = ctx.r[11].s64 + -26996;
	// 82E8A3C4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8A3C8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E8A3CC: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8A3D0: 48000018  b 0x82e8a3e8
	pc = 0x82E8A3E8; continue 'dispatch;
            }
            0x82E8A3D4 => {
    //   block [0x82E8A3D4..0x82E8A3E8)
	// 82E8A3D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8A3D8: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8A3DC: 4BFFFEF5  bl 0x82e8a2d0
	ctx.lr = 0x82E8A3E0;
	sub_82E8A2D0(ctx, base);
	// 82E8A3E0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8A3E4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82E8A3E8; continue 'dispatch;
            }
            0x82E8A3E8 => {
    //   block [0x82E8A3E8..0x82E8A40C)
	// 82E8A3E8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8A3EC: 4082FFE8  bne 0x82e8a3d4
	if !ctx.cr[0].eq {
	pc = 0x82E8A3D4; continue 'dispatch;
	}
	// 82E8A3F0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8A3F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8A3F8: 41820014  beq 0x82e8a40c
	if ctx.cr[0].eq {
	pc = 0x82E8A40C; continue 'dispatch;
	}
	// 82E8A3FC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E8A400: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E8A404: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8A408: 4E800421  bctrl
	ctx.lr = 0x82E8A40C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8A40C => {
    //   block [0x82E8A40C..0x82E8A42C)
	// 82E8A40C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8A410: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8A414: 41820018  beq 0x82e8a42c
	if ctx.cr[0].eq {
	pc = 0x82E8A42C; continue 'dispatch;
	}
	// 82E8A418: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8A41C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E8A420: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8A424: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8A428: 4E800421  bctrl
	ctx.lr = 0x82E8A42C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8A42C => {
    //   block [0x82E8A42C..0x82E8A450)
	// 82E8A42C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E8A430: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82E8A434: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82E8A438: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E8A43C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8A440: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8A444: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8A448: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8A44C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8A450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8A450 size=200
    let mut pc: u32 = 0x82E8A450;
    'dispatch: loop {
        match pc {
            0x82E8A450 => {
    //   block [0x82E8A450..0x82E8A484)
	// 82E8A450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8A454: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8A458: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8A45C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8A460: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8A464: 4BFF5CDD  bl 0x82e80140
	ctx.lr = 0x82E8A468;
	sub_82E80140(ctx, base);
	// 82E8A468: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E8A46C: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82E8A470: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E8A474: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E8A478: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8A47C: 40810054  ble 0x82e8a4d0
	if !ctx.cr[0].gt {
	pc = 0x82E8A4D0; continue 'dispatch;
	}
	// 82E8A480: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82E8A484; continue 'dispatch;
            }
            0x82E8A484 => {
    //   block [0x82E8A484..0x82E8A490)
	// 82E8A484: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8A488: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82E8A48C: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	pc = 0x82E8A490; continue 'dispatch;
            }
            0x82E8A490 => {
    //   block [0x82E8A490..0x82E8A4B4)
	// 82E8A490: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8A494: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8A498: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8A49C: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82E8A4A0: 41820014  beq 0x82e8a4b4
	if ctx.cr[0].eq {
	pc = 0x82E8A4B4; continue 'dispatch;
	}
	// 82E8A4A4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E8A4A8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82E8A4AC: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82E8A4B0: 419AFFE0  beq cr6, 0x82e8a490
	if ctx.cr[6].eq {
	pc = 0x82E8A490; continue 'dispatch;
	}
	pc = 0x82E8A4B4; continue 'dispatch;
            }
            0x82E8A4B4 => {
    //   block [0x82E8A4B4..0x82E8A4D0)
	// 82E8A4B4: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8A4B8: 41820028  beq 0x82e8a4e0
	if ctx.cr[0].eq {
	pc = 0x82E8A4E0; continue 'dispatch;
	}
	// 82E8A4BC: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E8A4C0: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82E8A4C4: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82E8A4C8: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82E8A4CC: 4198FFB8  blt cr6, 0x82e8a484
	if ctx.cr[6].lt {
	pc = 0x82E8A484; continue 'dispatch;
	}
	pc = 0x82E8A4D0; continue 'dispatch;
            }
            0x82E8A4D0 => {
    //   block [0x82E8A4D0..0x82E8A4E0)
	// 82E8A4D0: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82E8A4D4: 409A0018  bne cr6, 0x82e8a4ec
	if !ctx.cr[6].eq {
	pc = 0x82E8A4EC; continue 'dispatch;
	}
	// 82E8A4D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8A4DC: 48000028  b 0x82e8a504
	pc = 0x82E8A504; continue 'dispatch;
            }
            0x82E8A4E0 => {
    //   block [0x82E8A4E0..0x82E8A4EC)
	// 82E8A4E0: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8A4E4: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82E8A4E8: 48000018  b 0x82e8a500
	pc = 0x82E8A500; continue 'dispatch;
            }
            0x82E8A4EC => {
    //   block [0x82E8A4EC..0x82E8A500)
	// 82E8A4EC: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8A4F0: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82E8A4F4: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E8A4F8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E8A4FC: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	pc = 0x82E8A500; continue 'dispatch;
            }
            0x82E8A500 => {
    //   block [0x82E8A500..0x82E8A504)
	// 82E8A500: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82E8A504; continue 'dispatch;
            }
            0x82E8A504 => {
    //   block [0x82E8A504..0x82E8A518)
	// 82E8A504: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8A508: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8A50C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8A510: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8A514: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8A518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8A518 size=88
    let mut pc: u32 = 0x82E8A518;
    'dispatch: loop {
        match pc {
            0x82E8A518 => {
    //   block [0x82E8A518..0x82E8A554)
	// 82E8A518: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8A51C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8A520: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8A524: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8A528: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8A52C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8A530: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8A534: 4BFFFE75  bl 0x82e8a3a8
	ctx.lr = 0x82E8A538;
	sub_82E8A3A8(ctx, base);
	// 82E8A538: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8A53C: 41820018  beq 0x82e8a554
	if ctx.cr[0].eq {
	pc = 0x82E8A554; continue 'dispatch;
	}
	// 82E8A540: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E8A544: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8A548: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E8A54C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8A550: 4E800421  bctrl
	ctx.lr = 0x82E8A554;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8A554 => {
    //   block [0x82E8A554..0x82E8A570)
	// 82E8A554: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8A558: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8A55C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8A560: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8A564: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8A568: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8A56C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8A570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8A570 size=196
    let mut pc: u32 = 0x82E8A570;
    'dispatch: loop {
        match pc {
            0x82E8A570 => {
    //   block [0x82E8A570..0x82E8A5A8)
	// 82E8A570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8A574: 4BE1EE91  bl 0x82ca9404
	ctx.lr = 0x82E8A578;
	sub_82CA93D0(ctx, base);
	// 82E8A578: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8A57C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8A580: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8A584: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82E8A588: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82E8A58C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82E8A590: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82E8A594: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82E8A598: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82E8A59C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E8A5A0: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82E8A5A4: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	pc = 0x82E8A5A8; continue 'dispatch;
            }
            0x82E8A5A8 => {
    //   block [0x82E8A5A8..0x82E8A5D4)
	// 82E8A5A8: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8A5AC: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8A5B0: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82E8A5B4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E8A5B8: 4082FFF0  bne 0x82e8a5a8
	if !ctx.cr[0].eq {
	pc = 0x82E8A5A8; continue 'dispatch;
	}
	// 82E8A5BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8A5C0: 4BFFFE91  bl 0x82e8a450
	ctx.lr = 0x82E8A5C4;
	sub_82E8A450(ctx, base);
	// 82E8A5C4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8A5C8: 4082000C  bne 0x82e8a5d4
	if !ctx.cr[0].eq {
	pc = 0x82E8A5D4; continue 'dispatch;
	}
	// 82E8A5CC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82E8A5D0: 48000010  b 0x82e8a5e0
	pc = 0x82E8A5E0; continue 'dispatch;
            }
            0x82E8A5D4 => {
    //   block [0x82E8A5D4..0x82E8A5E0)
	// 82E8A5D4: 4BFF5B6D  bl 0x82e80140
	ctx.lr = 0x82E8A5D8;
	sub_82E80140(ctx, base);
	// 82E8A5D8: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E8A5DC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82E8A5E0; continue 'dispatch;
            }
            0x82E8A5E0 => {
    //   block [0x82E8A5E0..0x82E8A604)
	// 82E8A5E0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E8A5E4: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82E8A5E8: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82E8A5EC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E8A5F0: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82E8A5F4: 409A0010  bne cr6, 0x82e8a604
	if !ctx.cr[6].eq {
	pc = 0x82E8A604; continue 'dispatch;
	}
	// 82E8A5F8: 4BFF5461  bl 0x82e7fa58
	ctx.lr = 0x82E8A5FC;
	sub_82E7FA58(ctx, base);
	// 82E8A5FC: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82E8A600: 4800000C  b 0x82e8a60c
	pc = 0x82E8A60C; continue 'dispatch;
            }
            0x82E8A604 => {
    //   block [0x82E8A604..0x82E8A60C)
	// 82E8A604: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8A608: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	pc = 0x82E8A60C; continue 'dispatch;
            }
            0x82E8A60C => {
    //   block [0x82E8A60C..0x82E8A628)
	// 82E8A60C: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8A610: 41820018  beq 0x82e8a628
	if ctx.cr[0].eq {
	pc = 0x82E8A628; continue 'dispatch;
	}
	// 82E8A614: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E8A618: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82E8A61C: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82E8A620: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82E8A624: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	pc = 0x82E8A628; continue 'dispatch;
            }
            0x82E8A628 => {
    //   block [0x82E8A628..0x82E8A634)
	// 82E8A628: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8A62C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E8A630: 4BE1EE24  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8A638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8A638 size=100
    let mut pc: u32 = 0x82E8A638;
    'dispatch: loop {
        match pc {
            0x82E8A638 => {
    //   block [0x82E8A638..0x82E8A63C)
	// 82E8A638: 48000054  b 0x82e8a68c
	pc = 0x82E8A68C; continue 'dispatch;
            }
            0x82E8A63C => {
    //   block [0x82E8A63C..0x82E8A66C)
	// 82E8A63C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8A640: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8A644: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82E8A648: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 82E8A64C: 419A0020  beq cr6, 0x82e8a66c
	if ctx.cr[6].eq {
	pc = 0x82E8A66C; continue 'dispatch;
	}
	// 82E8A650: 2F0B0009  cmpwi cr6, r11, 9
	ctx.cr[6].compare_i32(ctx.r[11].s32, 9, &mut ctx.xer);
	// 82E8A654: 419A0018  beq cr6, 0x82e8a66c
	if ctx.cr[6].eq {
	pc = 0x82E8A66C; continue 'dispatch;
	}
	// 82E8A658: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 82E8A65C: 419A0010  beq cr6, 0x82e8a66c
	if ctx.cr[6].eq {
	pc = 0x82E8A66C; continue 'dispatch;
	}
	// 82E8A660: 2F0B000D  cmpwi cr6, r11, 0xd
	ctx.cr[6].compare_i32(ctx.r[11].s32, 13, &mut ctx.xer);
	// 82E8A664: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8A668: 409A0008  bne cr6, 0x82e8a670
	if !ctx.cr[6].eq {
	pc = 0x82E8A670; continue 'dispatch;
	}
	pc = 0x82E8A66C; continue 'dispatch;
            }
            0x82E8A66C => {
    //   block [0x82E8A66C..0x82E8A670)
	// 82E8A66C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82E8A670; continue 'dispatch;
            }
            0x82E8A670 => {
    //   block [0x82E8A670..0x82E8A68C)
	// 82E8A670: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8A674: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
	// 82E8A678: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8A67C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E8A680: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82E8A684: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E8A688: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82E8A68C; continue 'dispatch;
            }
            0x82E8A68C => {
    //   block [0x82E8A68C..0x82E8A69C)
	// 82E8A68C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8A690: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8A694: 409AFFA8  bne cr6, 0x82e8a63c
	if !ctx.cr[6].eq {
	pc = 0x82E8A63C; continue 'dispatch;
	}
	// 82E8A698: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8A6A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8A6A0 size=80
    let mut pc: u32 = 0x82E8A6A0;
    'dispatch: loop {
        match pc {
            0x82E8A6A0 => {
    //   block [0x82E8A6A0..0x82E8A6B4)
	// 82E8A6A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8A6A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8A6A8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8A6AC: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82E8A6B0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82E8A6B4; continue 'dispatch;
            }
            0x82E8A6B4 => {
    //   block [0x82E8A6B4..0x82E8A6F0)
	// 82E8A6B4: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8A6B8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E8A6BC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E8A6C0: 409AFFF4  bne cr6, 0x82e8a6b4
	if !ctx.cr[6].eq {
	pc = 0x82E8A6B4; continue 'dispatch;
	}
	// 82E8A6C4: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82E8A6C8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8A6CC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82E8A6D0: 5565003E  slwi r5, r11, 0
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82E8A6D4: 4BE275B5  bl 0x82cb1c88
	ctx.lr = 0x82E8A6D8;
	sub_82CB1C88(ctx, base);
	// 82E8A6D8: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 82E8A6DC: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82E8A6E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8A6E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8A6E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8A6EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8A6F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8A6F0 size=92
    let mut pc: u32 = 0x82E8A6F0;
    'dispatch: loop {
        match pc {
            0x82E8A6F0 => {
    //   block [0x82E8A6F0..0x82E8A718)
	// 82E8A6F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8A6F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8A6F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8A6FC: 9421FE10  stwu r1, -0x1f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-496 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8A700: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82E8A704: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8A708: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82E8A70C: 409A000C  bne cr6, 0x82e8a718
	if !ctx.cr[6].eq {
	pc = 0x82E8A718; continue 'dispatch;
	}
	// 82E8A710: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8A714: 48000024  b 0x82e8a738
	pc = 0x82E8A738; continue 'dispatch;
            }
            0x82E8A718 => {
    //   block [0x82E8A718..0x82E8A738)
	// 82E8A718: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8A71C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E8A720: 388B96C4  addi r4, r11, -0x693c
	ctx.r[4].s64 = ctx.r[11].s64 + -26940;
	// 82E8A724: 4B3B517D  bl 0x8223f8a0
	ctx.lr = 0x82E8A728;
	sub_8223F8A0(ctx, base);
	// 82E8A728: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E8A72C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8A730: 4BFFFF71  bl 0x82e8a6a0
	ctx.lr = 0x82E8A734;
	sub_82E8A6A0(ctx, base);
	// 82E8A734: 5463063E  clrlwi r3, r3, 0x18
	ctx.r[3].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	pc = 0x82E8A738; continue 'dispatch;
            }
            0x82E8A738 => {
    //   block [0x82E8A738..0x82E8A74C)
	// 82E8A738: 382101F0  addi r1, r1, 0x1f0
	ctx.r[1].s64 = ctx.r[1].s64 + 496;
	// 82E8A73C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8A740: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8A744: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8A748: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8A750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8A750 size=148
    let mut pc: u32 = 0x82E8A750;
    'dispatch: loop {
        match pc {
            0x82E8A750 => {
    //   block [0x82E8A750..0x82E8A774)
	// 82E8A750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8A754: 4BE1ECB1  bl 0x82ca9404
	ctx.lr = 0x82E8A758;
	sub_82CA93D0(ctx, base);
	// 82E8A758: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8A75C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82E8A760: 3F600000  lis r27, 0
	ctx.r[27].s64 = 0;
	// 82E8A764: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82E8A768: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E8A76C: 637BF000  ori r27, r27, 0xf000
	ctx.r[27].u64 = ctx.r[27].u64 | 61440;
	// 82E8A770: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82E8A774; continue 'dispatch;
            }
            0x82E8A774 => {
    //   block [0x82E8A774..0x82E8A7A0)
	// 82E8A774: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8A778: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E8A77C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E8A780: 409AFFF4  bne cr6, 0x82e8a774
	if !ctx.cr[6].eq {
	pc = 0x82E8A774; continue 'dispatch;
	}
	// 82E8A784: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82E8A788: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8A78C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82E8A790: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82E8A794: 557E003E  slwi r30, r11, 0
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82E8A798: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E8A79C: 4199003C  bgt cr6, 0x82e8a7d8
	if ctx.cr[6].gt {
	pc = 0x82E8A7D8; continue 'dispatch;
	}
	pc = 0x82E8A7A0; continue 'dispatch;
            }
            0x82E8A7A0 => {
    //   block [0x82E8A7A0..0x82E8A7D4)
	// 82E8A7A0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8A7A4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8A7A8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E8A7AC: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82E8A7B0: 4BE274D9  bl 0x82cb1c88
	ctx.lr = 0x82E8A7B4;
	sub_82CB1C88(ctx, base);
	// 82E8A7B4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8A7B8: 4182001C  beq 0x82e8a7d4
	if ctx.cr[0].eq {
	pc = 0x82E8A7D4; continue 'dispatch;
	}
	// 82E8A7BC: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82E8A7C0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8A7C4: 7D5FF214  add r10, r31, r30
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[30].u64;
	// 82E8A7C8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8A7CC: 4099FFD4  ble cr6, 0x82e8a7a0
	if !ctx.cr[6].gt {
	pc = 0x82E8A7A0; continue 'dispatch;
	}
	// 82E8A7D0: 48000008  b 0x82e8a7d8
	pc = 0x82E8A7D8; continue 'dispatch;
            }
            0x82E8A7D4 => {
    //   block [0x82E8A7D4..0x82E8A7D8)
	// 82E8A7D4: 7F7FF214  add r27, r31, r30
	ctx.r[27].u64 = ctx.r[31].u64 + ctx.r[30].u64;
	pc = 0x82E8A7D8; continue 'dispatch;
            }
            0x82E8A7D8 => {
    //   block [0x82E8A7D8..0x82E8A7E4)
	// 82E8A7D8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82E8A7DC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E8A7E0: 4BE1EC74  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8A7E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8A7E8 size=96
    let mut pc: u32 = 0x82E8A7E8;
    'dispatch: loop {
        match pc {
            0x82E8A7E8 => {
    //   block [0x82E8A7E8..0x82E8A828)
	// 82E8A7E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8A7EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8A7F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8A7F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8A7F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8A7FC: 4BFFFF55  bl 0x82e8a750
	ctx.lr = 0x82E8A800;
	sub_82E8A750(ctx, base);
	// 82E8A800: 2B03F000  cmplwi cr6, r3, 0xf000
	ctx.cr[6].compare_u32(ctx.r[3].u32, 61440 as u32, &mut ctx.xer);
	// 82E8A804: 419A0030  beq cr6, 0x82e8a834
	if ctx.cr[6].eq {
	pc = 0x82E8A834; continue 'dispatch;
	}
	// 82E8A808: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8A80C: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8A810: 41990018  bgt cr6, 0x82e8a828
	if ctx.cr[6].gt {
	pc = 0x82E8A828; continue 'dispatch;
	}
	// 82E8A814: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8A818: 7D635850  subf r11, r3, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82E8A81C: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 82E8A820: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E8A824: 4800000C  b 0x82e8a830
	pc = 0x82E8A830; continue 'dispatch;
            }
            0x82E8A828 => {
    //   block [0x82E8A828..0x82E8A830)
	// 82E8A828: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8A82C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82E8A830; continue 'dispatch;
            }
            0x82E8A830 => {
    //   block [0x82E8A830..0x82E8A834)
	// 82E8A830: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82E8A834; continue 'dispatch;
            }
            0x82E8A834 => {
    //   block [0x82E8A834..0x82E8A848)
	// 82E8A834: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8A838: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8A83C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8A840: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8A844: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8A848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8A848 size=720
    let mut pc: u32 = 0x82E8A848;
    'dispatch: loop {
        match pc {
            0x82E8A848 => {
    //   block [0x82E8A848..0x82E8A8C0)
	// 82E8A848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8A84C: 4BE1EBA1  bl 0x82ca93ec
	ctx.lr = 0x82E8A850;
	sub_82CA93D0(ctx, base);
	// 82E8A850: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8A854: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E8A858: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 82E8A85C: 4BFFFDDD  bl 0x82e8a638
	ctx.lr = 0x82E8A860;
	sub_82E8A638(ctx, base);
	// 82E8A860: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82E8A864: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8A868: 388BF608  addi r4, r11, -0x9f8
	ctx.r[4].s64 = ctx.r[11].s64 + -2552;
	// 82E8A86C: 4BFFFEE5  bl 0x82e8a750
	ctx.lr = 0x82E8A870;
	sub_82E8A750(ctx, base);
	// 82E8A870: 3BE3FFFF  addi r31, r3, -1
	ctx.r[31].s64 = ctx.r[3].s64 + -1;
	// 82E8A874: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82E8A878: 837E0000  lwz r27, 0(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8A87C: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 82E8A880: 3B2B0754  addi r25, r11, 0x754
	ctx.r[25].s64 = ctx.r[11].s64 + 1876;
	// 82E8A884: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E8A888: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82E8A88C: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 82E8A890: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 82E8A894: 4BFFFEBD  bl 0x82e8a750
	ctx.lr = 0x82E8A898;
	sub_82E8A750(ctx, base);
	// 82E8A898: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E8A89C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E8A8A0: 419A0268  beq cr6, 0x82e8ab08
	if ctx.cr[6].eq {
	pc = 0x82E8AB08; continue 'dispatch;
	}
	// 82E8A8A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82E8A8A8: 3AABEB04  addi r21, r11, -0x14fc
	ctx.r[21].s64 = ctx.r[11].s64 + -5372;
	// 82E8A8AC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82E8A8B0: 3ACB2DF8  addi r22, r11, 0x2df8
	ctx.r[22].s64 = ctx.r[11].s64 + 11768;
	// 82E8A8B4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82E8A8B8: 3AEB4A60  addi r23, r11, 0x4a60
	ctx.r[23].s64 = ctx.r[11].s64 + 19040;
	// 82E8A8BC: 48000008  b 0x82e8a8c4
	pc = 0x82E8A8C4; continue 'dispatch;
            }
            0x82E8A8C0 => {
    //   block [0x82E8A8C0..0x82E8A8C4)
	// 82E8A8C0: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82E8A8C4; continue 'dispatch;
            }
            0x82E8A8C4 => {
    //   block [0x82E8A8C4..0x82E8A910)
	// 82E8A8C4: 2B1DF000  cmplwi cr6, r29, 0xf000
	ctx.cr[6].compare_u32(ctx.r[29].u32, 61440 as u32, &mut ctx.xer);
	// 82E8A8C8: 419A0240  beq cr6, 0x82e8ab08
	if ctx.cr[6].eq {
	pc = 0x82E8AB08; continue 'dispatch;
	}
	// 82E8A8CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E8A8D0: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82E8A8D4: 4BFFFDCD  bl 0x82e8a6a0
	ctx.lr = 0x82E8A8D8;
	sub_82E8A6A0(ctx, base);
	// 82E8A8D8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8A8DC: 4082022C  bne 0x82e8ab08
	if !ctx.cr[0].eq {
	pc = 0x82E8AB08; continue 'dispatch;
	}
	// 82E8A8E0: 897B0000  lbz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8A8E4: 2B0B003E  cmplwi cr6, r11, 0x3e
	ctx.cr[6].compare_u32(ctx.r[11].u32, 62 as u32, &mut ctx.xer);
	// 82E8A8E8: 419A0220  beq cr6, 0x82e8ab08
	if ctx.cr[6].eq {
	pc = 0x82E8AB08; continue 'dispatch;
	}
	// 82E8A8EC: 3B9DFFFF  addi r28, r29, -1
	ctx.r[28].s64 = ctx.r[29].s64 + -1;
	// 82E8A8F0: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 82E8A8F4: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 82E8A8F8: 7F1DD040  cmplw cr6, r29, r26
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82E8A8FC: 41990014  bgt cr6, 0x82e8a910
	if ctx.cr[6].gt {
	pc = 0x82E8A910; continue 'dispatch;
	}
	// 82E8A900: 7D7BEA14  add r11, r27, r29
	ctx.r[11].u64 = ctx.r[27].u64 + ctx.r[29].u64;
	// 82E8A904: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82E8A908: 7D7DD050  subf r11, r29, r26
	ctx.r[11].s64 = ctx.r[26].s64 - ctx.r[29].s64;
	// 82E8A90C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	pc = 0x82E8A910; continue 'dispatch;
            }
            0x82E8A910 => {
    //   block [0x82E8A910..0x82E8A93C)
	// 82E8A910: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82E8A914: 4BFFFD25  bl 0x82e8a638
	ctx.lr = 0x82E8A918;
	sub_82E8A638(ctx, base);
	// 82E8A918: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E8A91C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E8A920: 4198001C  blt cr6, 0x82e8a93c
	if ctx.cr[6].lt {
	pc = 0x82E8A93C; continue 'dispatch;
	}
	// 82E8A924: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82E8A928: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82E8A92C: 3BAA0001  addi r29, r10, 1
	ctx.r[29].s64 = ctx.r[10].s64 + 1;
	// 82E8A930: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82E8A934: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82E8A938: 48000008  b 0x82e8a940
	pc = 0x82E8A940; continue 'dispatch;
            }
            0x82E8A93C => {
    //   block [0x82E8A93C..0x82E8A940)
	// 82E8A93C: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	pc = 0x82E8A940; continue 'dispatch;
            }
            0x82E8A940 => {
    //   block [0x82E8A940..0x82E8A990)
	// 82E8A940: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82E8A944: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82E8A948: 4BFFFE09  bl 0x82e8a750
	ctx.lr = 0x82E8A94C;
	sub_82E8A750(ctx, base);
	// 82E8A94C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E8A950: 2B0BF000  cmplwi cr6, r11, 0xf000
	ctx.cr[6].compare_u32(ctx.r[11].u32, 61440 as u32, &mut ctx.xer);
	// 82E8A954: 419A0180  beq cr6, 0x82e8aad4
	if ctx.cr[6].eq {
	pc = 0x82E8AAD4; continue 'dispatch;
	}
	// 82E8A958: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82E8A95C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E8A960: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82E8A964: 3BEBFFFF  addi r31, r11, -1
	ctx.r[31].s64 = ctx.r[11].s64 + -1;
	// 82E8A968: 4BE27321  bl 0x82cb1c88
	ctx.lr = 0x82E8A96C;
	sub_82CB1C88(ctx, base);
	// 82E8A96C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8A970: 40820020  bne 0x82e8a990
	if !ctx.cr[0].eq {
	pc = 0x82E8A990; continue 'dispatch;
	}
	// 82E8A974: 2B1C0004  cmplwi cr6, r28, 4
	ctx.cr[6].compare_u32(ctx.r[28].u32, 4 as u32, &mut ctx.xer);
	// 82E8A978: 409A0018  bne cr6, 0x82e8a990
	if !ctx.cr[6].eq {
	pc = 0x82E8A990; continue 'dispatch;
	}
	// 82E8A97C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82E8A980: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E8A984: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82E8A988: 4BFF9AE1  bl 0x82e84468
	ctx.lr = 0x82E8A98C;
	sub_82E84468(ctx, base);
	// 82E8A98C: 4800001C  b 0x82e8a9a8
	pc = 0x82E8A9A8; continue 'dispatch;
            }
            0x82E8A990 => {
    //   block [0x82E8A990..0x82E8A9A8)
	// 82E8A990: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82E8A994: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82E8A998: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82E8A99C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E8A9A0: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82E8A9A4: 4BFF98B5  bl 0x82e84258
	ctx.lr = 0x82E8A9A8;
	sub_82E84258(ctx, base);
	pc = 0x82E8A9A8; continue 'dispatch;
            }
            0x82E8A9A8 => {
    //   block [0x82E8A9A8..0x82E8A9DC)
	// 82E8A9A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E8A9AC: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82E8A9B0: 4BFFFDA1  bl 0x82e8a750
	ctx.lr = 0x82E8A9B4;
	sub_82E8A750(ctx, base);
	// 82E8A9B4: 2B03F000  cmplwi cr6, r3, 0xf000
	ctx.cr[6].compare_u32(ctx.r[3].u32, 61440 as u32, &mut ctx.xer);
	// 82E8A9B8: 419A003C  beq cr6, 0x82e8a9f4
	if ctx.cr[6].eq {
	pc = 0x82E8A9F4; continue 'dispatch;
	}
	// 82E8A9BC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8A9C0: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8A9C4: 41990018  bgt cr6, 0x82e8a9dc
	if ctx.cr[6].gt {
	pc = 0x82E8A9DC; continue 'dispatch;
	}
	// 82E8A9C8: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8A9CC: 7D635850  subf r11, r3, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82E8A9D0: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 82E8A9D4: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E8A9D8: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82E8A9DC; continue 'dispatch;
            }
            0x82E8A9DC => {
    //   block [0x82E8A9DC..0x82E8A9F4)
	// 82E8A9DC: 7F03D040  cmplw cr6, r3, r26
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82E8A9E0: 41990014  bgt cr6, 0x82e8a9f4
	if ctx.cr[6].gt {
	pc = 0x82E8A9F4; continue 'dispatch;
	}
	// 82E8A9E4: 7F7B1A14  add r27, r27, r3
	ctx.r[27].u64 = ctx.r[27].u64 + ctx.r[3].u64;
	// 82E8A9E8: 7F43D050  subf r26, r3, r26
	ctx.r[26].s64 = ctx.r[26].s64 - ctx.r[3].s64;
	// 82E8A9EC: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 82E8A9F0: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	pc = 0x82E8A9F4; continue 'dispatch;
            }
            0x82E8A9F4 => {
    //   block [0x82E8A9F4..0x82E8AA28)
	// 82E8A9F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E8A9F8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82E8A9FC: 4BFFFD55  bl 0x82e8a750
	ctx.lr = 0x82E8AA00;
	sub_82E8A750(ctx, base);
	// 82E8AA00: 2B03F000  cmplwi cr6, r3, 0xf000
	ctx.cr[6].compare_u32(ctx.r[3].u32, 61440 as u32, &mut ctx.xer);
	// 82E8AA04: 419A00D8  beq cr6, 0x82e8aadc
	if ctx.cr[6].eq {
	pc = 0x82E8AADC; continue 'dispatch;
	}
	// 82E8AA08: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8AA0C: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8AA10: 41990018  bgt cr6, 0x82e8aa28
	if ctx.cr[6].gt {
	pc = 0x82E8AA28; continue 'dispatch;
	}
	// 82E8AA14: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8AA18: 7D635850  subf r11, r3, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82E8AA1C: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 82E8AA20: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E8AA24: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82E8AA28; continue 'dispatch;
            }
            0x82E8AA28 => {
    //   block [0x82E8AA28..0x82E8AA44)
	// 82E8AA28: 7F03D040  cmplw cr6, r3, r26
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82E8AA2C: 419900B0  bgt cr6, 0x82e8aadc
	if ctx.cr[6].gt {
	pc = 0x82E8AADC; continue 'dispatch;
	}
	// 82E8AA30: 7D7B1A14  add r11, r27, r3
	ctx.r[11].u64 = ctx.r[27].u64 + ctx.r[3].u64;
	// 82E8AA34: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82E8AA38: 7D63D050  subf r11, r3, r26
	ctx.r[11].s64 = ctx.r[26].s64 - ctx.r[3].s64;
	// 82E8AA3C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82E8AA40: 4800009C  b 0x82e8aadc
	pc = 0x82E8AADC; continue 'dispatch;
            }
            0x82E8AA44 => {
    //   block [0x82E8AA44..0x82E8AA70)
	// 82E8AA44: 897B0000  lbz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8AA48: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82E8AA4C: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 82E8AA50: 419A0020  beq cr6, 0x82e8aa70
	if ctx.cr[6].eq {
	pc = 0x82E8AA70; continue 'dispatch;
	}
	// 82E8AA54: 2F0B0009  cmpwi cr6, r11, 9
	ctx.cr[6].compare_i32(ctx.r[11].s32, 9, &mut ctx.xer);
	// 82E8AA58: 419A0018  beq cr6, 0x82e8aa70
	if ctx.cr[6].eq {
	pc = 0x82E8AA70; continue 'dispatch;
	}
	// 82E8AA5C: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 82E8AA60: 419A0010  beq cr6, 0x82e8aa70
	if ctx.cr[6].eq {
	pc = 0x82E8AA70; continue 'dispatch;
	}
	// 82E8AA64: 2F0B000D  cmpwi cr6, r11, 0xd
	ctx.cr[6].compare_i32(ctx.r[11].s32, 13, &mut ctx.xer);
	// 82E8AA68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8AA6C: 409A0008  bne cr6, 0x82e8aa74
	if !ctx.cr[6].eq {
	pc = 0x82E8AA74; continue 'dispatch;
	}
	pc = 0x82E8AA70; continue 'dispatch;
            }
            0x82E8AA70 => {
    //   block [0x82E8AA70..0x82E8AA74)
	// 82E8AA70: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82E8AA74; continue 'dispatch;
            }
            0x82E8AA74 => {
    //   block [0x82E8AA74..0x82E8AAB4)
	// 82E8AA74: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8AA78: 40820064  bne 0x82e8aadc
	if !ctx.cr[0].eq {
	pc = 0x82E8AADC; continue 'dispatch;
	}
	// 82E8AA7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E8AA80: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82E8AA84: 4BFFFC1D  bl 0x82e8a6a0
	ctx.lr = 0x82E8AA88;
	sub_82E8A6A0(ctx, base);
	// 82E8AA88: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8AA8C: 40820050  bne 0x82e8aadc
	if !ctx.cr[0].eq {
	pc = 0x82E8AADC; continue 'dispatch;
	}
	// 82E8AA90: 897B0000  lbz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8AA94: 2B0B003E  cmplwi cr6, r11, 0x3e
	ctx.cr[6].compare_u32(ctx.r[11].u32, 62 as u32, &mut ctx.xer);
	// 82E8AA98: 419A0044  beq cr6, 0x82e8aadc
	if ctx.cr[6].eq {
	pc = 0x82E8AADC; continue 'dispatch;
	}
	// 82E8AA9C: 2B1A0001  cmplwi cr6, r26, 1
	ctx.cr[6].compare_u32(ctx.r[26].u32, 1 as u32, &mut ctx.xer);
	// 82E8AAA0: 41980014  blt cr6, 0x82e8aab4
	if ctx.cr[6].lt {
	pc = 0x82E8AAB4; continue 'dispatch;
	}
	// 82E8AAA4: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82E8AAA8: 3B5AFFFF  addi r26, r26, -1
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	// 82E8AAAC: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 82E8AAB0: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	pc = 0x82E8AAB4; continue 'dispatch;
            }
            0x82E8AAB4 => {
    //   block [0x82E8AAB4..0x82E8AAD4)
	// 82E8AAB4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8AAB8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E8AABC: 41980018  blt cr6, 0x82e8aad4
	if ctx.cr[6].lt {
	pc = 0x82E8AAD4; continue 'dispatch;
	}
	// 82E8AAC0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8AAC4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82E8AAC8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E8AACC: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E8AAD0: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82E8AAD4; continue 'dispatch;
            }
            0x82E8AAD4 => {
    //   block [0x82E8AAD4..0x82E8AADC)
	// 82E8AAD4: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82E8AAD8: 409AFF6C  bne cr6, 0x82e8aa44
	if !ctx.cr[6].eq {
	pc = 0x82E8AA44; continue 'dispatch;
	}
	pc = 0x82E8AADC; continue 'dispatch;
            }
            0x82E8AADC => {
    //   block [0x82E8AADC..0x82E8AB08)
	// 82E8AADC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E8AAE0: 4BFFFB59  bl 0x82e8a638
	ctx.lr = 0x82E8AAE4;
	sub_82E8A638(ctx, base);
	// 82E8AAE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8AAE8: 4BFFFB51  bl 0x82e8a638
	ctx.lr = 0x82E8AAEC;
	sub_82E8A638(ctx, base);
	// 82E8AAEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E8AAF0: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82E8AAF4: 4BFFFC5D  bl 0x82e8a750
	ctx.lr = 0x82E8AAF8;
	sub_82E8A750(ctx, base);
	// 82E8AAF8: 83410054  lwz r26, 0x54(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E8AAFC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E8AB00: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82E8AB04: 409AFDBC  bne cr6, 0x82e8a8c0
	if !ctx.cr[6].eq {
	pc = 0x82E8A8C0; continue 'dispatch;
	}
	pc = 0x82E8AB08; continue 'dispatch;
            }
            0x82E8AB08 => {
    //   block [0x82E8AB08..0x82E8AB18)
	// 82E8AB08: 3C600000  lis r3, 0
	ctx.r[3].s64 = 0;
	// 82E8AB0C: 6063F001  ori r3, r3, 0xf001
	ctx.r[3].u64 = ctx.r[3].u64 | 61441;
	// 82E8AB10: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82E8AB14: 4BE1E928  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8AB18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8AB18 size=128
    let mut pc: u32 = 0x82E8AB18;
    'dispatch: loop {
        match pc {
            0x82E8AB18 => {
    //   block [0x82E8AB18..0x82E8AB30)
	// 82E8AB18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8AB1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8AB20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8AB24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8AB28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8AB2C: 48000038  b 0x82e8ab64
	pc = 0x82E8AB64; continue 'dispatch;
            }
            0x82E8AB30 => {
    //   block [0x82E8AB30..0x82E8AB64)
	// 82E8AB30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8AB34: 4BFFFB05  bl 0x82e8a638
	ctx.lr = 0x82E8AB38;
	sub_82E8A638(ctx, base);
	// 82E8AB38: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8AB3C: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8AB40: 2B0B003C  cmplwi cr6, r11, 0x3c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 60 as u32, &mut ctx.xer);
	// 82E8AB44: 419A002C  beq cr6, 0x82e8ab70
	if ctx.cr[6].eq {
	pc = 0x82E8AB70; continue 'dispatch;
	}
	// 82E8AB48: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8AB4C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E8AB50: 41980014  blt cr6, 0x82e8ab64
	if ctx.cr[6].lt {
	pc = 0x82E8AB64; continue 'dispatch;
	}
	// 82E8AB54: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E8AB58: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82E8AB5C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E8AB60: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82E8AB64; continue 'dispatch;
            }
            0x82E8AB64 => {
    //   block [0x82E8AB64..0x82E8AB70)
	// 82E8AB64: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8AB68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8AB6C: 409AFFC4  bne cr6, 0x82e8ab30
	if !ctx.cr[6].eq {
	pc = 0x82E8AB30; continue 'dispatch;
	}
	pc = 0x82E8AB70; continue 'dispatch;
            }
            0x82E8AB70 => {
    //   block [0x82E8AB70..0x82E8AB98)
	// 82E8AB70: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8AB74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8AB78: 388B96D4  addi r4, r11, -0x692c
	ctx.r[4].s64 = ctx.r[11].s64 + -26924;
	// 82E8AB7C: 4BFFFB25  bl 0x82e8a6a0
	ctx.lr = 0x82E8AB80;
	sub_82E8A6A0(ctx, base);
	// 82E8AB80: 5463063E  clrlwi r3, r3, 0x18
	ctx.r[3].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E8AB84: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8AB88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8AB8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8AB90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8AB94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8AB98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8AB98 size=508
    let mut pc: u32 = 0x82E8AB98;
    'dispatch: loop {
        match pc {
            0x82E8AB98 => {
    //   block [0x82E8AB98..0x82E8ABC0)
	// 82E8AB98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8AB9C: 4BE1E869  bl 0x82ca9404
	ctx.lr = 0x82E8ABA0;
	sub_82CA93D0(ctx, base);
	// 82E8ABA0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8ABA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8ABA8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82E8ABAC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E8ABB0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8ABB4: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8ABB8: 2B0A003C  cmplwi cr6, r10, 0x3c
	ctx.cr[6].compare_u32(ctx.r[10].u32, 60 as u32, &mut ctx.xer);
	// 82E8ABBC: 419A0010  beq cr6, 0x82e8abcc
	if ctx.cr[6].eq {
	pc = 0x82E8ABCC; continue 'dispatch;
	}
	pc = 0x82E8ABC0; continue 'dispatch;
            }
            0x82E8ABC0 => {
    //   block [0x82E8ABC0..0x82E8ABCC)
	// 82E8ABC0: 3C600000  lis r3, 0
	ctx.r[3].s64 = 0;
	// 82E8ABC4: 60638011  ori r3, r3, 0x8011
	ctx.r[3].u64 = ctx.r[3].u64 | 32785;
	// 82E8ABC8: 480001C4  b 0x82e8ad8c
	pc = 0x82E8AD8C; continue 'dispatch;
            }
            0x82E8ABCC => {
    //   block [0x82E8ABCC..0x82E8ABE8)
	// 82E8ABCC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8ABD0: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82E8ABD4: 41980014  blt cr6, 0x82e8abe8
	if ctx.cr[6].lt {
	pc = 0x82E8ABE8; continue 'dispatch;
	}
	// 82E8ABD8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E8ABDC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82E8ABE0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E8ABE4: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	pc = 0x82E8ABE8; continue 'dispatch;
            }
            0x82E8ABE8 => {
    //   block [0x82E8ABE8..0x82E8AC08)
	// 82E8ABE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8ABEC: 4BFFFA4D  bl 0x82e8a638
	ctx.lr = 0x82E8ABF0;
	sub_82E8A638(ctx, base);
	// 82E8ABF0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8ABF4: 837F0000  lwz r27, 0(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8ABF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8ABFC: 419A0188  beq cr6, 0x82e8ad84
	if ctx.cr[6].eq {
	pc = 0x82E8AD84; continue 'dispatch;
	}
	// 82E8AC00: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82E8AC04: 3BCBEB04  addi r30, r11, -0x14fc
	ctx.r[30].s64 = ctx.r[11].s64 + -5372;
	pc = 0x82E8AC08; continue 'dispatch;
            }
            0x82E8AC08 => {
    //   block [0x82E8AC08..0x82E8AC5C)
	// 82E8AC08: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8AC0C: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8AC10: 2B0B003E  cmplwi cr6, r11, 0x3e
	ctx.cr[6].compare_u32(ctx.r[11].u32, 62 as u32, &mut ctx.xer);
	// 82E8AC14: 419A0080  beq cr6, 0x82e8ac94
	if ctx.cr[6].eq {
	pc = 0x82E8AC94; continue 'dispatch;
	}
	// 82E8AC18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8AC1C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8AC20: 4BFFFA81  bl 0x82e8a6a0
	ctx.lr = 0x82E8AC24;
	sub_82E8A6A0(ctx, base);
	// 82E8AC24: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8AC28: 4082006C  bne 0x82e8ac94
	if !ctx.cr[0].eq {
	pc = 0x82E8AC94; continue 'dispatch;
	}
	// 82E8AC2C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8AC30: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8AC34: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82E8AC38: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 82E8AC3C: 419A0020  beq cr6, 0x82e8ac5c
	if ctx.cr[6].eq {
	pc = 0x82E8AC5C; continue 'dispatch;
	}
	// 82E8AC40: 2F0B0009  cmpwi cr6, r11, 9
	ctx.cr[6].compare_i32(ctx.r[11].s32, 9, &mut ctx.xer);
	// 82E8AC44: 419A0018  beq cr6, 0x82e8ac5c
	if ctx.cr[6].eq {
	pc = 0x82E8AC5C; continue 'dispatch;
	}
	// 82E8AC48: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 82E8AC4C: 419A0010  beq cr6, 0x82e8ac5c
	if ctx.cr[6].eq {
	pc = 0x82E8AC5C; continue 'dispatch;
	}
	// 82E8AC50: 2F0B000D  cmpwi cr6, r11, 0xd
	ctx.cr[6].compare_i32(ctx.r[11].s32, 13, &mut ctx.xer);
	// 82E8AC54: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8AC58: 409A0008  bne cr6, 0x82e8ac60
	if !ctx.cr[6].eq {
	pc = 0x82E8AC60; continue 'dispatch;
	}
	pc = 0x82E8AC5C; continue 'dispatch;
            }
            0x82E8AC5C => {
    //   block [0x82E8AC5C..0x82E8AC60)
	// 82E8AC5C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82E8AC60; continue 'dispatch;
            }
            0x82E8AC60 => {
    //   block [0x82E8AC60..0x82E8AC88)
	// 82E8AC60: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8AC64: 40820030  bne 0x82e8ac94
	if !ctx.cr[0].eq {
	pc = 0x82E8AC94; continue 'dispatch;
	}
	// 82E8AC68: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8AC6C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82E8AC70: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E8AC74: 41980014  blt cr6, 0x82e8ac88
	if ctx.cr[6].lt {
	pc = 0x82E8AC88; continue 'dispatch;
	}
	// 82E8AC78: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E8AC7C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82E8AC80: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E8AC84: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82E8AC88; continue 'dispatch;
            }
            0x82E8AC88 => {
    //   block [0x82E8AC88..0x82E8AC94)
	// 82E8AC88: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8AC8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8AC90: 409AFF78  bne cr6, 0x82e8ac08
	if !ctx.cr[6].eq {
	pc = 0x82E8AC08; continue 'dispatch;
	}
	pc = 0x82E8AC94; continue 'dispatch;
            }
            0x82E8AC94 => {
    //   block [0x82E8AC94..0x82E8ACC4)
	// 82E8AC94: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82E8AC98: 419A00EC  beq cr6, 0x82e8ad84
	if ctx.cr[6].eq {
	pc = 0x82E8AD84; continue 'dispatch;
	}
	// 82E8AC9C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8ACA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8ACA4: 419A00E0  beq cr6, 0x82e8ad84
	if ctx.cr[6].eq {
	pc = 0x82E8AD84; continue 'dispatch;
	}
	// 82E8ACA8: 897B0000  lbz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8ACAC: 2B0B002F  cmplwi cr6, r11, 0x2f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 47 as u32, &mut ctx.xer);
	// 82E8ACB0: 409A0040  bne cr6, 0x82e8acf0
	if !ctx.cr[6].eq {
	pc = 0x82E8ACF0; continue 'dispatch;
	}
	// 82E8ACB4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82E8ACB8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82E8ACBC: 3940000A  li r10, 0xa
	ctx.r[10].s64 = 10;
	// 82E8ACC0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82E8ACC4; continue 'dispatch;
            }
            0x82E8ACC4 => {
    //   block [0x82E8ACC4..0x82E8ACE0)
	// 82E8ACC4: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82E8ACC8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82E8ACCC: 4200FFF8  bdnz 0x82e8acc4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82E8ACC4; continue 'dispatch;
	}
	// 82E8ACD0: 2B1D004F  cmplwi cr6, r29, 0x4f
	ctx.cr[6].compare_u32(ctx.r[29].u32, 79 as u32, &mut ctx.xer);
	// 82E8ACD4: 38A0004F  li r5, 0x4f
	ctx.r[5].s64 = 79;
	// 82E8ACD8: 41990008  bgt cr6, 0x82e8ace0
	if ctx.cr[6].gt {
	pc = 0x82E8ACE0; continue 'dispatch;
	}
	// 82E8ACDC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	pc = 0x82E8ACE0; continue 'dispatch;
            }
            0x82E8ACE0 => {
    //   block [0x82E8ACE0..0x82E8ACF0)
	// 82E8ACE0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E8ACE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E8ACE8: 4B4423C1  bl 0x822cd0a8
	ctx.lr = 0x82E8ACEC;
	sub_822CD0A8(ctx, base);
	// 82E8ACEC: 4BFFFED4  b 0x82e8abc0
	pc = 0x82E8ABC0; continue 'dispatch;
            }
            0x82E8ACF0 => {
    //   block [0x82E8ACF0..0x82E8AD2C)
	// 82E8ACF0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E8ACF4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E8ACF8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E8ACFC: 4BFF9355  bl 0x82e84050
	ctx.lr = 0x82E8AD00;
	sub_82E84050(ctx, base);
	// 82E8AD00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8AD04: 4BFFF935  bl 0x82e8a638
	ctx.lr = 0x82E8AD08;
	sub_82E8A638(ctx, base);
	// 82E8AD08: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E8AD0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8AD10: 4BFFFB39  bl 0x82e8a848
	ctx.lr = 0x82E8AD14;
	sub_82E8A848(ctx, base);
	// 82E8AD14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8AD18: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8AD1C: 4BFFF985  bl 0x82e8a6a0
	ctx.lr = 0x82E8AD20;
	sub_82E8A6A0(ctx, base);
	// 82E8AD20: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8AD24: 4182001C  beq 0x82e8ad40
	if ctx.cr[0].eq {
	pc = 0x82E8AD40; continue 'dispatch;
	}
	// 82E8AD28: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	pc = 0x82E8AD2C; continue 'dispatch;
            }
            0x82E8AD2C => {
    //   block [0x82E8AD2C..0x82E8AD40)
	// 82E8AD2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8AD30: 4BFFFAB9  bl 0x82e8a7e8
	ctx.lr = 0x82E8AD34;
	sub_82E8A7E8(ctx, base);
	// 82E8AD34: 3C600000  lis r3, 0
	ctx.r[3].s64 = 0;
	// 82E8AD38: 6063F002  ori r3, r3, 0xf002
	ctx.r[3].u64 = ctx.r[3].u64 | 61442;
	// 82E8AD3C: 48000050  b 0x82e8ad8c
	pc = 0x82E8AD8C; continue 'dispatch;
            }
            0x82E8AD40 => {
    //   block [0x82E8AD40..0x82E8AD6C)
	// 82E8AD40: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8AD44: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8AD48: 2B0B003E  cmplwi cr6, r11, 0x3e
	ctx.cr[6].compare_u32(ctx.r[11].u32, 62 as u32, &mut ctx.xer);
	// 82E8AD4C: 409A002C  bne cr6, 0x82e8ad78
	if !ctx.cr[6].eq {
	pc = 0x82E8AD78; continue 'dispatch;
	}
	// 82E8AD50: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8AD54: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E8AD58: 41980014  blt cr6, 0x82e8ad6c
	if ctx.cr[6].lt {
	pc = 0x82E8AD6C; continue 'dispatch;
	}
	// 82E8AD5C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E8AD60: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82E8AD64: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E8AD68: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82E8AD6C; continue 'dispatch;
            }
            0x82E8AD6C => {
    //   block [0x82E8AD6C..0x82E8AD78)
	// 82E8AD6C: 3C600000  lis r3, 0
	ctx.r[3].s64 = 0;
	// 82E8AD70: 6063F004  ori r3, r3, 0xf004
	ctx.r[3].u64 = ctx.r[3].u64 | 61444;
	// 82E8AD74: 48000018  b 0x82e8ad8c
	pc = 0x82E8AD8C; continue 'dispatch;
            }
            0x82E8AD78 => {
    //   block [0x82E8AD78..0x82E8AD84)
	// 82E8AD78: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8AD7C: 388B0C88  addi r4, r11, 0xc88
	ctx.r[4].s64 = ctx.r[11].s64 + 3208;
	// 82E8AD80: 4BFFFFAC  b 0x82e8ad2c
	pc = 0x82E8AD2C; continue 'dispatch;
            }
            0x82E8AD84 => {
    //   block [0x82E8AD84..0x82E8AD8C)
	// 82E8AD84: 3C600000  lis r3, 0
	ctx.r[3].s64 = 0;
	// 82E8AD88: 60638012  ori r3, r3, 0x8012
	ctx.r[3].u64 = ctx.r[3].u64 | 32786;
	pc = 0x82E8AD8C; continue 'dispatch;
            }
            0x82E8AD8C => {
    //   block [0x82E8AD8C..0x82E8AD94)
	// 82E8AD8C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82E8AD90: 4BE1E6C4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8AD98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8AD98 size=572
    let mut pc: u32 = 0x82E8AD98;
    'dispatch: loop {
        match pc {
            0x82E8AD98 => {
    //   block [0x82E8AD98..0x82E8ADC8)
	// 82E8AD98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8AD9C: 4BE1E659  bl 0x82ca93f4
	ctx.lr = 0x82E8ADA0;
	sub_82CA93D0(ctx, base);
	// 82E8ADA0: 9421FDD0  stwu r1, -0x230(r1)
	ea = ctx.r[1].u32.wrapping_add(-560 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8ADA4: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 82E8ADA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8ADAC: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82E8ADB0: 483312B1  bl 0x831bc060
	ctx.lr = 0x82E8ADB4;
	sub_831BC060(ctx, base);
	// 82E8ADB4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8ADB8: 40820010  bne 0x82e8adc8
	if !ctx.cr[0].eq {
	pc = 0x82E8ADC8; continue 'dispatch;
	}
	// 82E8ADBC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82E8ADC0: 3AEB8CD0  addi r23, r11, -0x7330
	ctx.r[23].s64 = ctx.r[11].s64 + -29488;
	// 82E8ADC4: 48000010  b 0x82e8add4
	pc = 0x82E8ADD4; continue 'dispatch;
            }
            0x82E8ADC8 => {
    //   block [0x82E8ADC8..0x82E8ADD4)
	// 82E8ADC8: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82E8ADCC: 48331295  bl 0x831bc060
	ctx.lr = 0x82E8ADD0;
	sub_831BC060(ctx, base);
	// 82E8ADD0: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	pc = 0x82E8ADD4; continue 'dispatch;
            }
            0x82E8ADD4 => {
    //   block [0x82E8ADD4..0x82E8AE08)
	// 82E8ADD4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8ADD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8ADDC: 419A0178  beq cr6, 0x82e8af54
	if ctx.cr[6].eq {
	pc = 0x82E8AF54; continue 'dispatch;
	}
	// 82E8ADE0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8ADE4: 3BAB96D0  addi r29, r11, -0x6930
	ctx.r[29].s64 = ctx.r[11].s64 + -26928;
	// 82E8ADE8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8ADEC: 3B8B96B8  addi r28, r11, -0x6948
	ctx.r[28].s64 = ctx.r[11].s64 + -26952;
	// 82E8ADF0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82E8ADF4: 3B6BCAB8  addi r27, r11, -0x3548
	ctx.r[27].s64 = ctx.r[11].s64 + -13640;
	// 82E8ADF8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8ADFC: 3B4B96CC  addi r26, r11, -0x6934
	ctx.r[26].s64 = ctx.r[11].s64 + -26932;
	// 82E8AE00: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8AE04: 3B2B96B0  addi r25, r11, -0x6950
	ctx.r[25].s64 = ctx.r[11].s64 + -26960;
	pc = 0x82E8AE08; continue 'dispatch;
            }
            0x82E8AE08 => {
    //   block [0x82E8AE08..0x82E8AE54)
	// 82E8AE08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8AE0C: 4BFFF82D  bl 0x82e8a638
	ctx.lr = 0x82E8AE10;
	sub_82E8A638(ctx, base);
	// 82E8AE10: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8AE14: 89640000  lbz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8AE18: 2B0B003C  cmplwi cr6, r11, 0x3c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 60 as u32, &mut ctx.xer);
	// 82E8AE1C: 409A00DC  bne cr6, 0x82e8aef8
	if !ctx.cr[6].eq {
	pc = 0x82E8AEF8; continue 'dispatch;
	}
	// 82E8AE20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8AE24: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82E8AE28: 4BFFF879  bl 0x82e8a6a0
	ctx.lr = 0x82E8AE2C;
	sub_82E8A6A0(ctx, base);
	// 82E8AE2C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8AE30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8AE34: 41820020  beq 0x82e8ae54
	if ctx.cr[0].eq {
	pc = 0x82E8AE54; continue 'dispatch;
	}
	// 82E8AE38: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82E8AE3C: 4BFFF9AD  bl 0x82e8a7e8
	ctx.lr = 0x82E8AE40;
	sub_82E8A7E8(ctx, base);
	// 82E8AE40: 2B03F000  cmplwi cr6, r3, 0xf000
	ctx.cr[6].compare_u32(ctx.r[3].u32, 61440 as u32, &mut ctx.xer);
	// 82E8AE44: 409A0104  bne cr6, 0x82e8af48
	if !ctx.cr[6].eq {
	pc = 0x82E8AF48; continue 'dispatch;
	}
	// 82E8AE48: 3C600000  lis r3, 0
	ctx.r[3].s64 = 0;
	// 82E8AE4C: 60638001  ori r3, r3, 0x8001
	ctx.r[3].u64 = ctx.r[3].u64 | 32769;
	// 82E8AE50: 4800010C  b 0x82e8af5c
	pc = 0x82E8AF5C; continue 'dispatch;
            }
            0x82E8AE54 => {
    //   block [0x82E8AE54..0x82E8AE80)
	// 82E8AE54: 4BFFFCC5  bl 0x82e8ab18
	ctx.lr = 0x82E8AE58;
	sub_82E8AB18(ctx, base);
	// 82E8AE58: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8AE5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8AE60: 41820020  beq 0x82e8ae80
	if ctx.cr[0].eq {
	pc = 0x82E8AE80; continue 'dispatch;
	}
	// 82E8AE64: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E8AE68: 4BFFF981  bl 0x82e8a7e8
	ctx.lr = 0x82E8AE6C;
	sub_82E8A7E8(ctx, base);
	// 82E8AE6C: 2B03F000  cmplwi cr6, r3, 0xf000
	ctx.cr[6].compare_u32(ctx.r[3].u32, 61440 as u32, &mut ctx.xer);
	// 82E8AE70: 409A00D8  bne cr6, 0x82e8af48
	if !ctx.cr[6].eq {
	pc = 0x82E8AF48; continue 'dispatch;
	}
	// 82E8AE74: 3C600000  lis r3, 0
	ctx.r[3].s64 = 0;
	// 82E8AE78: 60638002  ori r3, r3, 0x8002
	ctx.r[3].u64 = ctx.r[3].u64 | 32770;
	// 82E8AE7C: 480000E0  b 0x82e8af5c
	pc = 0x82E8AF5C; continue 'dispatch;
            }
            0x82E8AE80 => {
    //   block [0x82E8AE80..0x82E8AEB0)
	// 82E8AE80: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E8AE84: 4BFFF81D  bl 0x82e8a6a0
	ctx.lr = 0x82E8AE88;
	sub_82E8A6A0(ctx, base);
	// 82E8AE88: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8AE8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8AE90: 41820020  beq 0x82e8aeb0
	if ctx.cr[0].eq {
	pc = 0x82E8AEB0; continue 'dispatch;
	}
	// 82E8AE94: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E8AE98: 4BFFF951  bl 0x82e8a7e8
	ctx.lr = 0x82E8AE9C;
	sub_82E8A7E8(ctx, base);
	// 82E8AE9C: 2B03F000  cmplwi cr6, r3, 0xf000
	ctx.cr[6].compare_u32(ctx.r[3].u32, 61440 as u32, &mut ctx.xer);
	// 82E8AEA0: 409A00A8  bne cr6, 0x82e8af48
	if !ctx.cr[6].eq {
	pc = 0x82E8AF48; continue 'dispatch;
	}
	// 82E8AEA4: 3C600000  lis r3, 0
	ctx.r[3].s64 = 0;
	// 82E8AEA8: 60638004  ori r3, r3, 0x8004
	ctx.r[3].u64 = ctx.r[3].u64 | 32772;
	// 82E8AEAC: 480000B0  b 0x82e8af5c
	pc = 0x82E8AF5C; continue 'dispatch;
            }
            0x82E8AEB0 => {
    //   block [0x82E8AEB0..0x82E8AEEC)
	// 82E8AEB0: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82E8AEB4: 4BFFF83D  bl 0x82e8a6f0
	ctx.lr = 0x82E8AEB8;
	sub_82E8A6F0(ctx, base);
	// 82E8AEB8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8AEBC: 408200A8  bne 0x82e8af64
	if !ctx.cr[0].eq {
	pc = 0x82E8AF64; continue 'dispatch;
	}
	// 82E8AEC0: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82E8AEC4: 4BFF945D  bl 0x82e84320
	ctx.lr = 0x82E8AEC8;
	sub_82E84320(ctx, base);
	// 82E8AEC8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E8AECC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8AED0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8AED4: 4BFFFCC5  bl 0x82e8ab98
	ctx.lr = 0x82E8AED8;
	sub_82E8AB98(ctx, base);
	// 82E8AED8: 2B03F004  cmplwi cr6, r3, 0xf004
	ctx.cr[6].compare_u32(ctx.r[3].u32, 61444 as u32, &mut ctx.xer);
	// 82E8AEDC: 409A0010  bne cr6, 0x82e8aeec
	if !ctx.cr[6].eq {
	pc = 0x82E8AEEC; continue 'dispatch;
	}
	// 82E8AEE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8AEE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8AEE8: 4BFFFEB1  bl 0x82e8ad98
	ctx.lr = 0x82E8AEEC;
	sub_82E8AD98(ctx, base);
	pc = 0x82E8AEEC; continue 'dispatch;
            }
            0x82E8AEEC => {
    //   block [0x82E8AEEC..0x82E8AEF8)
	// 82E8AEEC: 2B03F002  cmplwi cr6, r3, 0xf002
	ctx.cr[6].compare_u32(ctx.r[3].u32, 61442 as u32, &mut ctx.xer);
	// 82E8AEF0: 409A006C  bne cr6, 0x82e8af5c
	if !ctx.cr[6].eq {
	pc = 0x82E8AF5C; continue 'dispatch;
	}
	// 82E8AEF4: 48000054  b 0x82e8af48
	pc = 0x82E8AF48; continue 'dispatch;
            }
            0x82E8AEF8 => {
    //   block [0x82E8AEF8..0x82E8AF00)
	// 82E8AEF8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8AEFC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82E8AF00; continue 'dispatch;
            }
            0x82E8AF00 => {
    //   block [0x82E8AF00..0x82E8AF48)
	// 82E8AF00: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82E8AF04: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8AF08: 409800C0  bge cr6, 0x82e8afc8
	if !ctx.cr[6].lt {
	pc = 0x82E8AFC8; continue 'dispatch;
	}
	// 82E8AF0C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8AF10: 7D4AF0AE  lbzx r10, r10, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82E8AF14: 2B0A003C  cmplwi cr6, r10, 0x3c
	ctx.cr[6].compare_u32(ctx.r[10].u32, 60 as u32, &mut ctx.xer);
	// 82E8AF18: 409AFFE8  bne cr6, 0x82e8af00
	if !ctx.cr[6].eq {
	pc = 0x82E8AF00; continue 'dispatch;
	}
	// 82E8AF1C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8AF20: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82E8AF24: 4BFF919D  bl 0x82e840c0
	ctx.lr = 0x82E8AF28;
	sub_82E840C0(ctx, base);
	// 82E8AF28: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8AF2C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8AF30: 41990018  bgt cr6, 0x82e8af48
	if ctx.cr[6].gt {
	pc = 0x82E8AF48; continue 'dispatch;
	}
	// 82E8AF34: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8AF38: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 82E8AF3C: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82E8AF40: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E8AF44: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82E8AF48; continue 'dispatch;
            }
            0x82E8AF48 => {
    //   block [0x82E8AF48..0x82E8AF54)
	// 82E8AF48: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8AF4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8AF50: 409AFEB8  bne cr6, 0x82e8ae08
	if !ctx.cr[6].eq {
	pc = 0x82E8AE08; continue 'dispatch;
	}
	pc = 0x82E8AF54; continue 'dispatch;
            }
            0x82E8AF54 => {
    //   block [0x82E8AF54..0x82E8AF5C)
	// 82E8AF54: 3C600000  lis r3, 0
	ctx.r[3].s64 = 0;
	// 82E8AF58: 6063F002  ori r3, r3, 0xf002
	ctx.r[3].u64 = ctx.r[3].u64 | 61442;
	pc = 0x82E8AF5C; continue 'dispatch;
            }
            0x82E8AF5C => {
    //   block [0x82E8AF5C..0x82E8AF64)
	// 82E8AF5C: 38210230  addi r1, r1, 0x230
	ctx.r[1].s64 = ctx.r[1].s64 + 560;
	// 82E8AF60: 4BE1E4E4  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82E8AF64 => {
    //   block [0x82E8AF64..0x82E8AF98)
	// 82E8AF64: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8AF68: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 82E8AF6C: 388B96C4  addi r4, r11, -0x693c
	ctx.r[4].s64 = ctx.r[11].s64 + -26940;
	// 82E8AF70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E8AF74: 4B3B492D  bl 0x8223f8a0
	ctx.lr = 0x82E8AF78;
	sub_8223F8A0(ctx, base);
	// 82E8AF78: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E8AF7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8AF80: 4BFFF869  bl 0x82e8a7e8
	ctx.lr = 0x82E8AF84;
	sub_82E8A7E8(ctx, base);
	// 82E8AF84: 2B03F000  cmplwi cr6, r3, 0xf000
	ctx.cr[6].compare_u32(ctx.r[3].u32, 61440 as u32, &mut ctx.xer);
	// 82E8AF88: 409A0010  bne cr6, 0x82e8af98
	if !ctx.cr[6].eq {
	pc = 0x82E8AF98; continue 'dispatch;
	}
	// 82E8AF8C: 3C600000  lis r3, 0
	ctx.r[3].s64 = 0;
	// 82E8AF90: 60638021  ori r3, r3, 0x8021
	ctx.r[3].u64 = ctx.r[3].u64 | 32801;
	// 82E8AF94: 4BFFFFC8  b 0x82e8af5c
	pc = 0x82E8AF5C; continue 'dispatch;
            }
            0x82E8AF98 => {
    //   block [0x82E8AF98..0x82E8AFC8)
	// 82E8AF98: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82E8AF9C: 4BA82D6D  bl 0x8290dd08
	ctx.lr = 0x82E8AFA0;
	sub_8290DD08(ctx, base);
	// 82E8AFA0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8AFA4: 4082FFB0  bne 0x82e8af54
	if !ctx.cr[0].eq {
	pc = 0x82E8AF54; continue 'dispatch;
	}
	// 82E8AFA8: 8178000C  lwz r11, 0xc(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8AFAC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8AFB0: 409AFFA4  bne cr6, 0x82e8af54
	if !ctx.cr[6].eq {
	pc = 0x82E8AF54; continue 'dispatch;
	}
	// 82E8AFB4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8AFB8: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82E8AFBC: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 82E8AFC0: 4BFF95F1  bl 0x82e845b0
	ctx.lr = 0x82E8AFC4;
	sub_82E845B0(ctx, base);
	// 82E8AFC4: 4BFFFF90  b 0x82e8af54
	pc = 0x82E8AF54; continue 'dispatch;
            }
            0x82E8AFC8 => {
    //   block [0x82E8AFC8..0x82E8AFD4)
	// 82E8AFC8: 3C600000  lis r3, 0
	ctx.r[3].s64 = 0;
	// 82E8AFCC: 60638010  ori r3, r3, 0x8010
	ctx.r[3].u64 = ctx.r[3].u64 | 32784;
	// 82E8AFD0: 4BFFFF8C  b 0x82e8af5c
	pc = 0x82E8AF5C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8AFD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8AFD8 size=524
    let mut pc: u32 = 0x82E8AFD8;
    'dispatch: loop {
        match pc {
            0x82E8AFD8 => {
    //   block [0x82E8AFD8..0x82E8B008)
	// 82E8AFD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8AFDC: 4BE1E425  bl 0x82ca9400
	ctx.lr = 0x82E8AFE0;
	sub_82CA93D0(ctx, base);
	// 82E8AFE0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8AFE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8AFE8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82E8AFEC: 4BFFFB2D  bl 0x82e8ab18
	ctx.lr = 0x82E8AFF0;
	sub_82E8AB18(ctx, base);
	// 82E8AFF0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8AFF4: 41820014  beq 0x82e8b008
	if ctx.cr[0].eq {
	pc = 0x82E8B008; continue 'dispatch;
	}
	// 82E8AFF8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82E8AFFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8B000: 388BCAB8  addi r4, r11, -0x3548
	ctx.r[4].s64 = ctx.r[11].s64 + -13640;
	// 82E8B004: 4BFFF7E5  bl 0x82e8a7e8
	ctx.lr = 0x82E8B008;
	sub_82E8A7E8(ctx, base);
	pc = 0x82E8B008; continue 'dispatch;
            }
            0x82E8B008 => {
    //   block [0x82E8B008..0x82E8B038)
	// 82E8B008: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8B00C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8B010: 3B6B96B0  addi r27, r11, -0x6950
	ctx.r[27].s64 = ctx.r[11].s64 + -26960;
	// 82E8B014: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E8B018: 4BFFF689  bl 0x82e8a6a0
	ctx.lr = 0x82E8B01C;
	sub_82E8A6A0(ctx, base);
	// 82E8B01C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8B020: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8B024: 3B4B96CC  addi r26, r11, -0x6934
	ctx.r[26].s64 = ctx.r[11].s64 + -26932;
	// 82E8B028: 41820010  beq 0x82e8b038
	if ctx.cr[0].eq {
	pc = 0x82E8B038; continue 'dispatch;
	}
	// 82E8B02C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8B030: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82E8B034: 4BFFF7B5  bl 0x82e8a7e8
	ctx.lr = 0x82E8B038;
	sub_82E8A7E8(ctx, base);
	pc = 0x82E8B038; continue 'dispatch;
            }
            0x82E8B038 => {
    //   block [0x82E8B038..0x82E8B070)
	// 82E8B038: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8B03C: 4BFFF5FD  bl 0x82e8a638
	ctx.lr = 0x82E8B040;
	sub_82E8A638(ctx, base);
	// 82E8B040: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8B044: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8B048: 2B0B003C  cmplwi cr6, r11, 0x3c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 60 as u32, &mut ctx.xer);
	// 82E8B04C: 409A0188  bne cr6, 0x82e8b1d4
	if !ctx.cr[6].eq {
	pc = 0x82E8B1D4; continue 'dispatch;
	}
	// 82E8B050: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8B054: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E8B058: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E8B05C: 41980014  blt cr6, 0x82e8b070
	if ctx.cr[6].lt {
	pc = 0x82E8B070; continue 'dispatch;
	}
	// 82E8B060: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E8B064: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82E8B068: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E8B06C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82E8B070; continue 'dispatch;
            }
            0x82E8B070 => {
    //   block [0x82E8B070..0x82E8B088)
	// 82E8B070: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8B074: 4BFFF5C5  bl 0x82e8a638
	ctx.lr = 0x82E8B078;
	sub_82E8A638(ctx, base);
	// 82E8B078: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8B07C: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8B080: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8B084: 419A0144  beq cr6, 0x82e8b1c8
	if ctx.cr[6].eq {
	pc = 0x82E8B1C8; continue 'dispatch;
	}
	pc = 0x82E8B088; continue 'dispatch;
            }
            0x82E8B088 => {
    //   block [0x82E8B088..0x82E8B0C0)
	// 82E8B088: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8B08C: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8B090: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82E8B094: 2F0B003E  cmpwi cr6, r11, 0x3e
	ctx.cr[6].compare_i32(ctx.r[11].s32, 62, &mut ctx.xer);
	// 82E8B098: 419A0060  beq cr6, 0x82e8b0f8
	if ctx.cr[6].eq {
	pc = 0x82E8B0F8; continue 'dispatch;
	}
	// 82E8B09C: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 82E8B0A0: 419A0020  beq cr6, 0x82e8b0c0
	if ctx.cr[6].eq {
	pc = 0x82E8B0C0; continue 'dispatch;
	}
	// 82E8B0A4: 2F0B0009  cmpwi cr6, r11, 9
	ctx.cr[6].compare_i32(ctx.r[11].s32, 9, &mut ctx.xer);
	// 82E8B0A8: 419A0018  beq cr6, 0x82e8b0c0
	if ctx.cr[6].eq {
	pc = 0x82E8B0C0; continue 'dispatch;
	}
	// 82E8B0AC: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 82E8B0B0: 419A0010  beq cr6, 0x82e8b0c0
	if ctx.cr[6].eq {
	pc = 0x82E8B0C0; continue 'dispatch;
	}
	// 82E8B0B4: 2F0B000D  cmpwi cr6, r11, 0xd
	ctx.cr[6].compare_i32(ctx.r[11].s32, 13, &mut ctx.xer);
	// 82E8B0B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8B0BC: 409A0008  bne cr6, 0x82e8b0c4
	if !ctx.cr[6].eq {
	pc = 0x82E8B0C4; continue 'dispatch;
	}
	pc = 0x82E8B0C0; continue 'dispatch;
            }
            0x82E8B0C0 => {
    //   block [0x82E8B0C0..0x82E8B0C4)
	// 82E8B0C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82E8B0C4; continue 'dispatch;
            }
            0x82E8B0C4 => {
    //   block [0x82E8B0C4..0x82E8B0EC)
	// 82E8B0C4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8B0C8: 40820030  bne 0x82e8b0f8
	if !ctx.cr[0].eq {
	pc = 0x82E8B0F8; continue 'dispatch;
	}
	// 82E8B0CC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8B0D0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82E8B0D4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E8B0D8: 41980014  blt cr6, 0x82e8b0ec
	if ctx.cr[6].lt {
	pc = 0x82E8B0EC; continue 'dispatch;
	}
	// 82E8B0DC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E8B0E0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82E8B0E4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E8B0E8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82E8B0EC; continue 'dispatch;
            }
            0x82E8B0EC => {
    //   block [0x82E8B0EC..0x82E8B0F8)
	// 82E8B0EC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8B0F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8B0F4: 409AFF94  bne cr6, 0x82e8b088
	if !ctx.cr[6].eq {
	pc = 0x82E8B088; continue 'dispatch;
	}
	pc = 0x82E8B0F8; continue 'dispatch;
            }
            0x82E8B0F8 => {
    //   block [0x82E8B0F8..0x82E8B160)
	// 82E8B0F8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82E8B0FC: 419A00CC  beq cr6, 0x82e8b1c8
	if ctx.cr[6].eq {
	pc = 0x82E8B1C8; continue 'dispatch;
	}
	// 82E8B100: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8B104: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8B108: 419A00C0  beq cr6, 0x82e8b1c8
	if ctx.cr[6].eq {
	pc = 0x82E8B1C8; continue 'dispatch;
	}
	// 82E8B10C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8B110: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E8B114: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E8B118: 4BFF8F39  bl 0x82e84050
	ctx.lr = 0x82E8B11C;
	sub_82E84050(ctx, base);
	// 82E8B11C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82E8B120: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8B124: 388BF608  addi r4, r11, -0x9f8
	ctx.r[4].s64 = ctx.r[11].s64 + -2552;
	// 82E8B128: 4BFFF6C1  bl 0x82e8a7e8
	ctx.lr = 0x82E8B12C;
	sub_82E8A7E8(ctx, base);
	// 82E8B12C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8B130: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E8B134: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E8B138: 4BFF8F19  bl 0x82e84050
	ctx.lr = 0x82E8B13C;
	sub_82E84050(ctx, base);
	// 82E8B13C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E8B140: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8B144: 4BFFFC55  bl 0x82e8ad98
	ctx.lr = 0x82E8B148;
	sub_82E8AD98(ctx, base);
	// 82E8B148: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E8B14C: 2B1EF002  cmplwi cr6, r30, 0xf002
	ctx.cr[6].compare_u32(ctx.r[30].u32, 61442 as u32, &mut ctx.xer);
	// 82E8B150: 409A0044  bne cr6, 0x82e8b194
	if !ctx.cr[6].eq {
	pc = 0x82E8B194; continue 'dispatch;
	}
	// 82E8B154: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8B158: 4BFFF4E1  bl 0x82e8a638
	ctx.lr = 0x82E8B15C;
	sub_82E8A638(ctx, base);
	// 82E8B15C: 4800002C  b 0x82e8b188
	pc = 0x82E8B188; continue 'dispatch;
            }
            0x82E8B160 => {
    //   block [0x82E8B160..0x82E8B188)
	// 82E8B160: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8B164: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E8B168: 4BFFF539  bl 0x82e8a6a0
	ctx.lr = 0x82E8B16C;
	sub_82E8A6A0(ctx, base);
	// 82E8B16C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8B170: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8B174: 41820034  beq 0x82e8b1a8
	if ctx.cr[0].eq {
	pc = 0x82E8B1A8; continue 'dispatch;
	}
	// 82E8B178: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82E8B17C: 4BFFF66D  bl 0x82e8a7e8
	ctx.lr = 0x82E8B180;
	sub_82E8A7E8(ctx, base);
	// 82E8B180: 2B03F000  cmplwi cr6, r3, 0xf000
	ctx.cr[6].compare_u32(ctx.r[3].u32, 61440 as u32, &mut ctx.xer);
	// 82E8B184: 419A0018  beq cr6, 0x82e8b19c
	if ctx.cr[6].eq {
	pc = 0x82E8B19C; continue 'dispatch;
	}
	pc = 0x82E8B188; continue 'dispatch;
            }
            0x82E8B188 => {
    //   block [0x82E8B188..0x82E8B194)
	// 82E8B188: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8B18C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8B190: 409AFFD0  bne cr6, 0x82e8b160
	if !ctx.cr[6].eq {
	pc = 0x82E8B160; continue 'dispatch;
	}
	pc = 0x82E8B194; continue 'dispatch;
            }
            0x82E8B194 => {
    //   block [0x82E8B194..0x82E8B19C)
	// 82E8B194: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8B198: 48000044  b 0x82e8b1dc
	pc = 0x82E8B1DC; continue 'dispatch;
            }
            0x82E8B19C => {
    //   block [0x82E8B19C..0x82E8B1A8)
	// 82E8B19C: 3C600000  lis r3, 0
	ctx.r[3].s64 = 0;
	// 82E8B1A0: 60638031  ori r3, r3, 0x8031
	ctx.r[3].u64 = ctx.r[3].u64 | 32817;
	// 82E8B1A4: 48000038  b 0x82e8b1dc
	pc = 0x82E8B1DC; continue 'dispatch;
            }
            0x82E8B1A8 => {
    //   block [0x82E8B1A8..0x82E8B1C8)
	// 82E8B1A8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82E8B1AC: 388B8CD0  addi r4, r11, -0x7330
	ctx.r[4].s64 = ctx.r[11].s64 + -29488;
	// 82E8B1B0: 4BFFF541  bl 0x82e8a6f0
	ctx.lr = 0x82E8B1B4;
	sub_82E8A6F0(ctx, base);
	// 82E8B1B4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8B1B8: 3C600000  lis r3, 0
	ctx.r[3].s64 = 0;
	// 82E8B1BC: 4182001C  beq 0x82e8b1d8
	if ctx.cr[0].eq {
	pc = 0x82E8B1D8; continue 'dispatch;
	}
	// 82E8B1C0: 6063F002  ori r3, r3, 0xf002
	ctx.r[3].u64 = ctx.r[3].u64 | 61442;
	// 82E8B1C4: 48000018  b 0x82e8b1dc
	pc = 0x82E8B1DC; continue 'dispatch;
            }
            0x82E8B1C8 => {
    //   block [0x82E8B1C8..0x82E8B1D4)
	// 82E8B1C8: 3C600000  lis r3, 0
	ctx.r[3].s64 = 0;
	// 82E8B1CC: 60638012  ori r3, r3, 0x8012
	ctx.r[3].u64 = ctx.r[3].u64 | 32786;
	// 82E8B1D0: 4800000C  b 0x82e8b1dc
	pc = 0x82E8B1DC; continue 'dispatch;
            }
            0x82E8B1D4 => {
    //   block [0x82E8B1D4..0x82E8B1D8)
	// 82E8B1D4: 3C600000  lis r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E8B1D8; continue 'dispatch;
            }
            0x82E8B1D8 => {
    //   block [0x82E8B1D8..0x82E8B1DC)
	// 82E8B1D8: 60638030  ori r3, r3, 0x8030
	ctx.r[3].u64 = ctx.r[3].u64 | 32816;
	pc = 0x82E8B1DC; continue 'dispatch;
            }
            0x82E8B1DC => {
    //   block [0x82E8B1DC..0x82E8B1E4)
	// 82E8B1DC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E8B1E0: 4BE1E270  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8B1E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8B1E8 size=92
    let mut pc: u32 = 0x82E8B1E8;
    'dispatch: loop {
        match pc {
            0x82E8B1E8 => {
    //   block [0x82E8B1E8..0x82E8B208)
	// 82E8B1E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8B1EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8B1F0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8B1F4: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82E8B1F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8B1FC: 409A000C  bne cr6, 0x82e8b208
	if !ctx.cr[6].eq {
	pc = 0x82E8B208; continue 'dispatch;
	}
	// 82E8B200: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8B204: 48000030  b 0x82e8b234
	pc = 0x82E8B234; continue 'dispatch;
            }
            0x82E8B208 => {
    //   block [0x82E8B208..0x82E8B230)
	// 82E8B208: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82E8B20C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82E8B210: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E8B214: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 82E8B218: 4BFFFDC1  bl 0x82e8afd8
	ctx.lr = 0x82E8B21C;
	sub_82E8AFD8(ctx, base);
	// 82E8B21C: 2B038030  cmplwi cr6, r3, 0x8030
	ctx.cr[6].compare_u32(ctx.r[3].u32, 32816 as u32, &mut ctx.xer);
	// 82E8B220: 419A0010  beq cr6, 0x82e8b230
	if ctx.cr[6].eq {
	pc = 0x82E8B230; continue 'dispatch;
	}
	// 82E8B224: 2B03F002  cmplwi cr6, r3, 0xf002
	ctx.cr[6].compare_u32(ctx.r[3].u32, 61442 as u32, &mut ctx.xer);
	// 82E8B228: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8B22C: 409A0008  bne cr6, 0x82e8b234
	if !ctx.cr[6].eq {
	pc = 0x82E8B234; continue 'dispatch;
	}
	pc = 0x82E8B230; continue 'dispatch;
            }
            0x82E8B230 => {
    //   block [0x82E8B230..0x82E8B234)
	// 82E8B230: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82E8B234; continue 'dispatch;
            }
            0x82E8B234 => {
    //   block [0x82E8B234..0x82E8B244)
	// 82E8B234: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8B238: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8B23C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8B240: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8B248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8B248 size=160
    let mut pc: u32 = 0x82E8B248;
    'dispatch: loop {
        match pc {
            0x82E8B248 => {
    //   block [0x82E8B248..0x82E8B2E8)
	// 82E8B248: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8B24C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8B250: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8B254: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8B258: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8B25C: 4BFFABF5  bl 0x82e85e50
	ctx.lr = 0x82E8B260;
	sub_82E85E50(ctx, base);
	// 82E8B260: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8B264: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E8B268: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8B26C: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8B270: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8B274: C1AA0BA8  lfs f13, 0xba8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2984 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8B278: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E8B27C: 396B96DC  addi r11, r11, -0x6924
	ctx.r[11].s64 = ctx.r[11].s64 + -26916;
	// 82E8B280: C18A0B20  lfs f12, 0xb20(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2848 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8B284: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E8B288: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8B28C: 396B115C  addi r11, r11, 0x115c
	ctx.r[11].s64 = ctx.r[11].s64 + 4444;
	// 82E8B290: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8B294: D17F0008  stfs f11, 8(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E8B298: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8B29C: D17F000C  stfs f11, 0xc(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E8B2A0: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8B2A4: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E8B2A8: D17F0010  stfs f11, 0x10(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82E8B2AC: 396BDBE4  addi r11, r11, -0x241c
	ctx.r[11].s64 = ctx.r[11].s64 + -9244;
	// 82E8B2B0: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8B2B4: D17F0014  stfs f11, 0x14(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82E8B2B8: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8B2BC: D17F0018  stfs f11, 0x18(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82E8B2C0: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8B2C4: D17F001C  stfs f11, 0x1c(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82E8B2C8: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82E8B2CC: D1BF0024  stfs f13, 0x24(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82E8B2D0: D19F0028  stfs f12, 0x28(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82E8B2D4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8B2D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8B2DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8B2E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8B2E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8B2E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8B2E8 size=12
    let mut pc: u32 = 0x82E8B2E8;
    'dispatch: loop {
        match pc {
            0x82E8B2E8 => {
    //   block [0x82E8B2E8..0x82E8B2F4)
	// 82E8B2E8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8B2EC: 386B22EC  addi r3, r11, 0x22ec
	ctx.r[3].s64 = ctx.r[11].s64 + 8940;
	// 82E8B2F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8B2F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8B2F8 size=100
    let mut pc: u32 = 0x82E8B2F8;
    'dispatch: loop {
        match pc {
            0x82E8B2F8 => {
    //   block [0x82E8B2F8..0x82E8B340)
	// 82E8B2F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8B2FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8B300: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8B304: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8B308: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8B30C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8B310: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8B314: 396B96DC  addi r11, r11, -0x6924
	ctx.r[11].s64 = ctx.r[11].s64 + -26916;
	// 82E8B318: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8B31C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E8B320: 4BFFAC59  bl 0x82e85f78
	ctx.lr = 0x82E8B324;
	sub_82E85F78(ctx, base);
	// 82E8B324: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8B328: 41820018  beq 0x82e8b340
	if ctx.cr[0].eq {
	pc = 0x82E8B340; continue 'dispatch;
	}
	// 82E8B32C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E8B330: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8B334: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E8B338: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8B33C: 4E800421  bctrl
	ctx.lr = 0x82E8B340;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8B340 => {
    //   block [0x82E8B340..0x82E8B35C)
	// 82E8B340: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8B344: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8B348: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8B34C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8B350: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8B354: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8B358: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8B360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8B360 size=132
    let mut pc: u32 = 0x82E8B360;
    'dispatch: loop {
        match pc {
            0x82E8B360 => {
    //   block [0x82E8B360..0x82E8B3A4)
	// 82E8B360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8B364: 4BE1E0A5  bl 0x82ca9408
	ctx.lr = 0x82E8B368;
	sub_82CA93D0(ctx, base);
	// 82E8B368: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8B36C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8B370: 3B850034  addi r28, r5, 0x34
	ctx.r[28].s64 = ctx.r[5].s64 + 52;
	// 82E8B374: 3BDF0014  addi r30, r31, 0x14
	ctx.r[30].s64 = ctx.r[31].s64 + 20;
	// 82E8B378: 3BBF0008  addi r29, r31, 8
	ctx.r[29].s64 = ctx.r[31].s64 + 8;
	// 82E8B37C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8B380: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E8B384: C05F0024  lfs f2, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82E8B388: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E8B38C: C03F0028  lfs f1, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E8B390: 4BFFE791  bl 0x82e89b20
	ctx.lr = 0x82E8B394;
	sub_82E89B20(ctx, base);
	// 82E8B394: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8B398: 4082000C  bne 0x82e8b3a4
	if !ctx.cr[0].eq {
	pc = 0x82E8B3A4; continue 'dispatch;
	}
	// 82E8B39C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E8B3A0: 4800003C  b 0x82e8b3dc
	pc = 0x82E8B3DC; continue 'dispatch;
            }
            0x82E8B3A4 => {
    //   block [0x82E8B3A4..0x82E8B3D8)
	// 82E8B3A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8B3A8: C05F0020  lfs f2, 0x20(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82E8B3AC: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8B3B0: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82E8B3B4: 40990024  ble cr6, 0x82e8b3d8
	if !ctx.cr[6].gt {
	pc = 0x82E8B3D8; continue 'dispatch;
	}
	// 82E8B3B8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8B3BC: C03F0028  lfs f1, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E8B3C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E8B3C4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E8B3C8: 4BFFE759  bl 0x82e89b20
	ctx.lr = 0x82E8B3CC;
	sub_82E89B20(ctx, base);
	// 82E8B3CC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8B3D0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E8B3D4: 40820008  bne 0x82e8b3dc
	if !ctx.cr[0].eq {
	pc = 0x82E8B3DC; continue 'dispatch;
	}
	pc = 0x82E8B3D8; continue 'dispatch;
            }
            0x82E8B3D8 => {
    //   block [0x82E8B3D8..0x82E8B3DC)
	// 82E8B3D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E8B3DC; continue 'dispatch;
            }
            0x82E8B3DC => {
    //   block [0x82E8B3DC..0x82E8B3E4)
	// 82E8B3DC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E8B3E0: 4BE1E078  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8B3E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8B3E8 size=312
    let mut pc: u32 = 0x82E8B3E8;
    'dispatch: loop {
        match pc {
            0x82E8B3E8 => {
    //   block [0x82E8B3E8..0x82E8B42C)
	// 82E8B3E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8B3EC: 4BE1E005  bl 0x82ca93f0
	ctx.lr = 0x82E8B3F0;
	sub_82CA93D0(ctx, base);
	// 82E8B3F0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8B3F4: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 82E8B3F8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82E8B3FC: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 82E8B400: 81760020  lwz r11, 0x20(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E8B404: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82E8B408: 409A00F4  bne cr6, 0x82e8b4fc
	if !ctx.cr[6].eq {
	pc = 0x82E8B4FC; continue 'dispatch;
	}
	// 82E8B40C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E8B410: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E8B414: 3B2B0F00  addi r25, r11, 0xf00
	ctx.r[25].s64 = ctx.r[11].s64 + 3840;
	// 82E8B418: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82E8B41C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82E8B420: 3B0B1150  addi r24, r11, 0x1150
	ctx.r[24].s64 = ctx.r[11].s64 + 4432;
	// 82E8B424: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82E8B428: 3B6B115C  addi r27, r11, 0x115c
	ctx.r[27].s64 = ctx.r[11].s64 + 4444;
	pc = 0x82E8B42C; continue 'dispatch;
            }
            0x82E8B42C => {
    //   block [0x82E8B42C..0x82E8B47C)
	// 82E8B42C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82E8B430: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82E8B434: 4BFF8BF5  bl 0x82e84028
	ctx.lr = 0x82E8B438;
	sub_82E84028(ctx, base);
	// 82E8B438: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82E8B43C: 418200A4  beq 0x82e8b4e0
	if ctx.cr[0].eq {
	pc = 0x82E8B4E0; continue 'dispatch;
	}
	// 82E8B440: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8B444: 48330C1D  bl 0x831bc060
	ctx.lr = 0x82E8B448;
	sub_831BC060(ctx, base);
	// 82E8B448: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E8B44C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E8B450: 4BE21701  bl 0x82cacb50
	ctx.lr = 0x82E8B454;
	sub_82CACB50(ctx, base);
	// 82E8B454: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8B458: 40820024  bne 0x82e8b47c
	if !ctx.cr[0].eq {
	pc = 0x82E8B47C; continue 'dispatch;
	}
	// 82E8B45C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8B460: 4BA828A9  bl 0x8290dd08
	ctx.lr = 0x82E8B464;
	sub_8290DD08(ctx, base);
	// 82E8B464: 4BE2074D  bl 0x82cabbb0
	ctx.lr = 0x82E8B468;
	sub_82CABBB0(ctx, base);
	// 82E8B468: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82E8B46C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E8B470: D01C0000  stfs f0, 0(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E8B474: 617D0001  ori r29, r11, 1
	ctx.r[29].u64 = ctx.r[11].u64 | 1;
	// 82E8B478: 48000068  b 0x82e8b4e0
	pc = 0x82E8B4E0; continue 'dispatch;
            }
            0x82E8B47C => {
    //   block [0x82E8B47C..0x82E8B4B0)
	// 82E8B47C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8B480: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82E8B484: 4BE216CD  bl 0x82cacb50
	ctx.lr = 0x82E8B488;
	sub_82CACB50(ctx, base);
	// 82E8B488: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8B48C: 40820024  bne 0x82e8b4b0
	if !ctx.cr[0].eq {
	pc = 0x82E8B4B0; continue 'dispatch;
	}
	// 82E8B490: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8B494: 4BA82875  bl 0x8290dd08
	ctx.lr = 0x82E8B498;
	sub_8290DD08(ctx, base);
	// 82E8B498: 4BE20719  bl 0x82cabbb0
	ctx.lr = 0x82E8B49C;
	sub_82CABBB0(ctx, base);
	// 82E8B49C: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82E8B4A0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E8B4A4: D01C0004  stfs f0, 4(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E8B4A8: 617D0002  ori r29, r11, 2
	ctx.r[29].u64 = ctx.r[11].u64 | 2;
	// 82E8B4AC: 48000034  b 0x82e8b4e0
	pc = 0x82E8B4E0; continue 'dispatch;
            }
            0x82E8B4B0 => {
    //   block [0x82E8B4B0..0x82E8B4E0)
	// 82E8B4B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8B4B4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82E8B4B8: 4BE21699  bl 0x82cacb50
	ctx.lr = 0x82E8B4BC;
	sub_82CACB50(ctx, base);
	// 82E8B4BC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8B4C0: 40820020  bne 0x82e8b4e0
	if !ctx.cr[0].eq {
	pc = 0x82E8B4E0; continue 'dispatch;
	}
	// 82E8B4C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8B4C8: 4BA82841  bl 0x8290dd08
	ctx.lr = 0x82E8B4CC;
	sub_8290DD08(ctx, base);
	// 82E8B4CC: 4BE206E5  bl 0x82cabbb0
	ctx.lr = 0x82E8B4D0;
	sub_82CABBB0(ctx, base);
	// 82E8B4D0: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82E8B4D4: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E8B4D8: D01C0008  stfs f0, 8(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E8B4DC: 617D0004  ori r29, r11, 4
	ctx.r[29].u64 = ctx.r[11].u64 | 4;
	pc = 0x82E8B4E0; continue 'dispatch;
            }
            0x82E8B4E0 => {
    //   block [0x82E8B4E0..0x82E8B4FC)
	// 82E8B4E0: 397A0001  addi r11, r26, 1
	ctx.r[11].s64 = ctx.r[26].s64 + 1;
	// 82E8B4E4: 557A063E  clrlwi r26, r11, 0x18
	ctx.r[26].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82E8B4E8: 2B1A0003  cmplwi cr6, r26, 3
	ctx.cr[6].compare_u32(ctx.r[26].u32, 3 as u32, &mut ctx.xer);
	// 82E8B4EC: 4198FF40  blt cr6, 0x82e8b42c
	if ctx.cr[6].lt {
	pc = 0x82E8B42C; continue 'dispatch;
	}
	// 82E8B4F0: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82E8B4F4: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 82E8B4F8: 419A001C  beq cr6, 0x82e8b514
	if ctx.cr[6].eq {
	pc = 0x82E8B514; continue 'dispatch;
	}
	pc = 0x82E8B4FC; continue 'dispatch;
            }
            0x82E8B4FC => {
    //   block [0x82E8B4FC..0x82E8B514)
	// 82E8B4FC: C0170000  lfs f0, 0(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8B500: D01C0000  stfs f0, 0(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E8B504: C0170004  lfs f0, 4(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8B508: D01C0004  stfs f0, 4(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E8B50C: C0170008  lfs f0, 8(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8B510: D01C0008  stfs f0, 8(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x82E8B514; continue 'dispatch;
            }
            0x82E8B514 => {
    //   block [0x82E8B514..0x82E8B520)
	// 82E8B514: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E8B518: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82E8B51C: 4BE1DF24  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8B520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8B520 size=72
    let mut pc: u32 = 0x82E8B520;
    'dispatch: loop {
        match pc {
            0x82E8B520 => {
    //   block [0x82E8B520..0x82E8B550)
	// 82E8B520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8B524: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8B528: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8B52C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8B530: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8B534: 3860002C  li r3, 0x2c
	ctx.r[3].s64 = 44;
	// 82E8B538: 4B78B3F1  bl 0x82616928
	ctx.lr = 0x82E8B53C;
	sub_82616928(ctx, base);
	// 82E8B53C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8B540: 41820010  beq 0x82e8b550
	if ctx.cr[0].eq {
	pc = 0x82E8B550; continue 'dispatch;
	}
	// 82E8B544: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E8B548: 4BFFFD01  bl 0x82e8b248
	ctx.lr = 0x82E8B54C;
	sub_82E8B248(ctx, base);
	// 82E8B54C: 48000008  b 0x82e8b554
	pc = 0x82E8B554; continue 'dispatch;
            }
            0x82E8B550 => {
    //   block [0x82E8B550..0x82E8B554)
	// 82E8B550: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E8B554; continue 'dispatch;
            }
            0x82E8B554 => {
    //   block [0x82E8B554..0x82E8B568)
	// 82E8B554: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8B558: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8B55C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8B560: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8B564: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8B568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8B568 size=540
    let mut pc: u32 = 0x82E8B568;
    'dispatch: loop {
        match pc {
            0x82E8B568 => {
    //   block [0x82E8B568..0x82E8B5A8)
	// 82E8B568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8B56C: 4BE1DEA1  bl 0x82ca940c
	ctx.lr = 0x82E8B570;
	sub_82CA93D0(ctx, base);
	// 82E8B570: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8B574: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8B578: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E8B57C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82E8B580: 419A0030  beq cr6, 0x82e8b5b0
	if ctx.cr[6].eq {
	pc = 0x82E8B5B0; continue 'dispatch;
	}
	// 82E8B584: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8B588: 48330AD9  bl 0x831bc060
	ctx.lr = 0x82E8B58C;
	sub_831BC060(ctx, base);
	// 82E8B58C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8B590: 41820020  beq 0x82e8b5b0
	if ctx.cr[0].eq {
	pc = 0x82E8B5B0; continue 'dispatch;
	}
	// 82E8B594: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8B598: 48330AC9  bl 0x831bc060
	ctx.lr = 0x82E8B59C;
	sub_831BC060(ctx, base);
	// 82E8B59C: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8B5A0: 2B0B005F  cmplwi cr6, r11, 0x5f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 95 as u32, &mut ctx.xer);
	// 82E8B5A4: 409A000C  bne cr6, 0x82e8b5b0
	if !ctx.cr[6].eq {
	pc = 0x82E8B5B0; continue 'dispatch;
	}
	pc = 0x82E8B5A8; continue 'dispatch;
            }
            0x82E8B5A8 => {
    //   block [0x82E8B5A8..0x82E8B5B0)
	// 82E8B5A8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E8B5AC: 480001D0  b 0x82e8b77c
	pc = 0x82E8B77C; continue 'dispatch;
            }
            0x82E8B5B0 => {
    //   block [0x82E8B5B0..0x82E8B5D4)
	// 82E8B5B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8B5B4: 48330AAD  bl 0x831bc060
	ctx.lr = 0x82E8B5B8;
	sub_831BC060(ctx, base);
	// 82E8B5B8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8B5BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8B5C0: 388B9710  addi r4, r11, -0x68f0
	ctx.r[4].s64 = ctx.r[11].s64 + -26864;
	// 82E8B5C4: 4BE2158D  bl 0x82cacb50
	ctx.lr = 0x82E8B5C8;
	sub_82CACB50(ctx, base);
	// 82E8B5C8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8B5CC: 40820020  bne 0x82e8b5ec
	if !ctx.cr[0].eq {
	pc = 0x82E8B5EC; continue 'dispatch;
	}
	// 82E8B5D0: 38BD0008  addi r5, r29, 8
	ctx.r[5].s64 = ctx.r[29].s64 + 8;
	pc = 0x82E8B5D4; continue 'dispatch;
            }
            0x82E8B5D4 => {
    //   block [0x82E8B5D4..0x82E8B5EC)
	// 82E8B5D4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8B5D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8B5DC: 38CB115C  addi r6, r11, 0x115c
	ctx.r[6].s64 = ctx.r[11].s64 + 4444;
	// 82E8B5E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8B5E4: 4BFFFE05  bl 0x82e8b3e8
	ctx.lr = 0x82E8B5E8;
	sub_82E8B3E8(ctx, base);
	// 82E8B5E8: 4BFFFFC0  b 0x82e8b5a8
	pc = 0x82E8B5A8; continue 'dispatch;
            }
            0x82E8B5EC => {
    //   block [0x82E8B5EC..0x82E8B60C)
	// 82E8B5EC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8B5F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8B5F4: 388B970C  addi r4, r11, -0x68f4
	ctx.r[4].s64 = ctx.r[11].s64 + -26868;
	// 82E8B5F8: 4BE21559  bl 0x82cacb50
	ctx.lr = 0x82E8B5FC;
	sub_82CACB50(ctx, base);
	// 82E8B5FC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8B600: 4082000C  bne 0x82e8b60c
	if !ctx.cr[0].eq {
	pc = 0x82E8B60C; continue 'dispatch;
	}
	// 82E8B604: 38BD0014  addi r5, r29, 0x14
	ctx.r[5].s64 = ctx.r[29].s64 + 20;
	// 82E8B608: 4BFFFFCC  b 0x82e8b5d4
	pc = 0x82E8B5D4; continue 'dispatch;
            }
            0x82E8B60C => {
    //   block [0x82E8B60C..0x82E8B644)
	// 82E8B60C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8B610: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8B614: 388B9700  addi r4, r11, -0x6900
	ctx.r[4].s64 = ctx.r[11].s64 + -26880;
	// 82E8B618: 4BE21539  bl 0x82cacb50
	ctx.lr = 0x82E8B61C;
	sub_82CACB50(ctx, base);
	// 82E8B61C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8B620: 4082006C  bne 0x82e8b68c
	if !ctx.cr[0].eq {
	pc = 0x82E8B68C; continue 'dispatch;
	}
	// 82E8B624: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8B628: 4BA826E1  bl 0x8290dd08
	ctx.lr = 0x82E8B62C;
	sub_8290DD08(ctx, base);
	// 82E8B62C: 4BE20585  bl 0x82cabbb0
	ctx.lr = 0x82E8B630;
	sub_82CABBB0(ctx, base);
	// 82E8B630: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8B634: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E8B638: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8B63C: D01D0020  stfs f0, 0x20(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82E8B640: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	pc = 0x82E8B644; continue 'dispatch;
            }
            0x82E8B644 => {
    //   block [0x82E8B644..0x82E8B650)
	// 82E8B644: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82E8B648: 41980008  blt cr6, 0x82e8b650
	if ctx.cr[6].lt {
	pc = 0x82E8B650; continue 'dispatch;
	}
	// 82E8B64C: FDA06090  fmr f13, f12
	ctx.f[13].f64 = ctx.f[12].f64;
	pc = 0x82E8B650; continue 'dispatch;
            }
            0x82E8B650 => {
    //   block [0x82E8B650..0x82E8B674)
	// 82E8B650: FF0D6800  fcmpu cr6, f13, f13
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[13].f64);
	// 82E8B654: 409AFFF0  bne cr6, 0x82e8b644
	if !ctx.cr[6].eq {
	pc = 0x82E8B644; continue 'dispatch;
	}
	// 82E8B658: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8B65C: D1BD0020  stfs f13, 0x20(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82E8B660: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E8B664: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8B668: 4182000C  beq 0x82e8b674
	if ctx.cr[0].eq {
	pc = 0x82E8B674; continue 'dispatch;
	}
	// 82E8B66C: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8B670: 4800000C  b 0x82e8b67c
	pc = 0x82E8B67C; continue 'dispatch;
            }
            0x82E8B674 => {
    //   block [0x82E8B674..0x82E8B67C)
	// 82E8B674: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8B678: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82E8B67C; continue 'dispatch;
            }
            0x82E8B67C => {
    //   block [0x82E8B67C..0x82E8B68C)
	// 82E8B67C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82E8B680: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E8B684: D01D0020  stfs f0, 0x20(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82E8B688: 480000F4  b 0x82e8b77c
	pc = 0x82E8B77C; continue 'dispatch;
            }
            0x82E8B68C => {
    //   block [0x82E8B68C..0x82E8B6C8)
	// 82E8B68C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8B690: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8B694: 388B96F8  addi r4, r11, -0x6908
	ctx.r[4].s64 = ctx.r[11].s64 + -26888;
	// 82E8B698: 4BE214B9  bl 0x82cacb50
	ctx.lr = 0x82E8B69C;
	sub_82CACB50(ctx, base);
	// 82E8B69C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8B6A0: 40820070  bne 0x82e8b710
	if !ctx.cr[0].eq {
	pc = 0x82E8B710; continue 'dispatch;
	}
	// 82E8B6A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8B6A8: 4BA82661  bl 0x8290dd08
	ctx.lr = 0x82E8B6AC;
	sub_8290DD08(ctx, base);
	// 82E8B6AC: 4BE20505  bl 0x82cabbb0
	ctx.lr = 0x82E8B6B0;
	sub_82CABBB0(ctx, base);
	// 82E8B6B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8B6B4: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E8B6B8: C00B0BA8  lfs f0, 0xba8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8B6BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8B6C0: D01D0024  stfs f0, 0x24(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82E8B6C4: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82E8B6C8; continue 'dispatch;
            }
            0x82E8B6C8 => {
    //   block [0x82E8B6C8..0x82E8B6D4)
	// 82E8B6C8: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82E8B6CC: 40990008  ble cr6, 0x82e8b6d4
	if !ctx.cr[6].gt {
	pc = 0x82E8B6D4; continue 'dispatch;
	}
	// 82E8B6D0: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82E8B6D4; continue 'dispatch;
            }
            0x82E8B6D4 => {
    //   block [0x82E8B6D4..0x82E8B6F8)
	// 82E8B6D4: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82E8B6D8: 409AFFF0  bne cr6, 0x82e8b6c8
	if !ctx.cr[6].eq {
	pc = 0x82E8B6C8; continue 'dispatch;
	}
	// 82E8B6DC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8B6E0: D01D0024  stfs f0, 0x24(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82E8B6E4: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E8B6E8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8B6EC: 4182000C  beq 0x82e8b6f8
	if ctx.cr[0].eq {
	pc = 0x82E8B6F8; continue 'dispatch;
	}
	// 82E8B6F0: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8B6F4: 4800000C  b 0x82e8b700
	pc = 0x82E8B700; continue 'dispatch;
            }
            0x82E8B6F8 => {
    //   block [0x82E8B6F8..0x82E8B700)
	// 82E8B6F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8B6FC: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82E8B700; continue 'dispatch;
            }
            0x82E8B700 => {
    //   block [0x82E8B700..0x82E8B710)
	// 82E8B700: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8B704: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E8B708: D01D0024  stfs f0, 0x24(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82E8B70C: 48000070  b 0x82e8b77c
	pc = 0x82E8B77C; continue 'dispatch;
            }
            0x82E8B710 => {
    //   block [0x82E8B710..0x82E8B754)
	// 82E8B710: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E8B714: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8B718: 388B1294  addi r4, r11, 0x1294
	ctx.r[4].s64 = ctx.r[11].s64 + 4756;
	// 82E8B71C: 4BE21435  bl 0x82cacb50
	ctx.lr = 0x82E8B720;
	sub_82CACB50(ctx, base);
	// 82E8B720: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8B724: 40820054  bne 0x82e8b778
	if !ctx.cr[0].eq {
	pc = 0x82E8B778; continue 'dispatch;
	}
	// 82E8B728: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8B72C: 4BA825DD  bl 0x8290dd08
	ctx.lr = 0x82E8B730;
	sub_8290DD08(ctx, base);
	// 82E8B730: 4BE20481  bl 0x82cabbb0
	ctx.lr = 0x82E8B734;
	sub_82CABBB0(ctx, base);
	// 82E8B734: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8B738: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E8B73C: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E8B740: C00B0B20  lfs f0, 0xb20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2848 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8B744: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8B748: C16A2594  lfs f11, 0x2594(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9620 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8B74C: D01D0028  stfs f0, 0x28(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82E8B750: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82E8B754; continue 'dispatch;
            }
            0x82E8B754 => {
    //   block [0x82E8B754..0x82E8B768)
	// 82E8B754: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82E8B758: 41980010  blt cr6, 0x82e8b768
	if ctx.cr[6].lt {
	pc = 0x82E8B768; continue 'dispatch;
	}
	// 82E8B75C: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82E8B760: 41990008  bgt cr6, 0x82e8b768
	if ctx.cr[6].gt {
	pc = 0x82E8B768; continue 'dispatch;
	}
	// 82E8B764: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82E8B768; continue 'dispatch;
            }
            0x82E8B768 => {
    //   block [0x82E8B768..0x82E8B778)
	// 82E8B768: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82E8B76C: 409AFFE8  bne cr6, 0x82e8b754
	if !ctx.cr[6].eq {
	pc = 0x82E8B754; continue 'dispatch;
	}
	// 82E8B770: D01D0028  stfs f0, 0x28(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82E8B774: 4BFFFE34  b 0x82e8b5a8
	pc = 0x82E8B5A8; continue 'dispatch;
            }
            0x82E8B778 => {
    //   block [0x82E8B778..0x82E8B77C)
	// 82E8B778: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E8B77C; continue 'dispatch;
            }
            0x82E8B77C => {
    //   block [0x82E8B77C..0x82E8B784)
	// 82E8B77C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8B780: 4BE1DCDC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8B788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8B788 size=12
    let mut pc: u32 = 0x82E8B788;
    'dispatch: loop {
        match pc {
            0x82E8B788 => {
    //   block [0x82E8B788..0x82E8B794)
	// 82E8B788: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8B78C: 386B2400  addi r3, r11, 0x2400
	ctx.r[3].s64 = ctx.r[11].s64 + 9216;
	// 82E8B790: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8B798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8B798 size=100
    let mut pc: u32 = 0x82E8B798;
    'dispatch: loop {
        match pc {
            0x82E8B798 => {
    //   block [0x82E8B798..0x82E8B7E0)
	// 82E8B798: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8B79C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8B7A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8B7A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8B7A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8B7AC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8B7B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8B7B4: 396B9730  addi r11, r11, -0x68d0
	ctx.r[11].s64 = ctx.r[11].s64 + -26832;
	// 82E8B7B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8B7BC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E8B7C0: 4BFFA7B9  bl 0x82e85f78
	ctx.lr = 0x82E8B7C4;
	sub_82E85F78(ctx, base);
	// 82E8B7C4: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8B7C8: 41820018  beq 0x82e8b7e0
	if ctx.cr[0].eq {
	pc = 0x82E8B7E0; continue 'dispatch;
	}
	// 82E8B7CC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E8B7D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8B7D4: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E8B7D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8B7DC: 4E800421  bctrl
	ctx.lr = 0x82E8B7E0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8B7E0 => {
    //   block [0x82E8B7E0..0x82E8B7FC)
	// 82E8B7E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8B7E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8B7E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8B7EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8B7F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8B7F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8B7F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8B800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8B800 size=100
    let mut pc: u32 = 0x82E8B800;
    'dispatch: loop {
        match pc {
            0x82E8B800 => {
    //   block [0x82E8B800..0x82E8B848)
	// 82E8B800: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8B804: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8B808: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8B80C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8B810: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8B814: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E8B818: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82E8B81C: 4B78B10D  bl 0x82616928
	ctx.lr = 0x82E8B820;
	sub_82616928(ctx, base);
	// 82E8B820: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82E8B824: 41820024  beq 0x82e8b848
	if ctx.cr[0].eq {
	pc = 0x82E8B848; continue 'dispatch;
	}
	// 82E8B828: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8B82C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8B830: 4BFFA621  bl 0x82e85e50
	ctx.lr = 0x82E8B834;
	sub_82E85E50(ctx, base);
	// 82E8B834: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8B838: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8B83C: 396B9730  addi r11, r11, -0x68d0
	ctx.r[11].s64 = ctx.r[11].s64 + -26832;
	// 82E8B840: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E8B844: 48000008  b 0x82e8b84c
	pc = 0x82E8B84C; continue 'dispatch;
            }
            0x82E8B848 => {
    //   block [0x82E8B848..0x82E8B84C)
	// 82E8B848: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E8B84C; continue 'dispatch;
            }
            0x82E8B84C => {
    //   block [0x82E8B84C..0x82E8B864)
	// 82E8B84C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8B850: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8B854: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8B858: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8B85C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8B860: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8B868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8B868 size=120
    let mut pc: u32 = 0x82E8B868;
    'dispatch: loop {
        match pc {
            0x82E8B868 => {
    //   block [0x82E8B868..0x82E8B8E0)
	// 82E8B868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8B86C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8B870: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8B874: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8B878: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8B87C: 4BFFA5D5  bl 0x82e85e50
	ctx.lr = 0x82E8B880;
	sub_82E85E50(ctx, base);
	// 82E8B880: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8B884: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E8B888: 396B9768  addi r11, r11, -0x6898
	ctx.r[11].s64 = ctx.r[11].s64 + -26776;
	// 82E8B88C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82E8B890: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8B894: C00A0BEC  lfs f0, 0xbec(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8B898: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E8B89C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E8B8A0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8B8A4: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82E8B8A8: 396B115C  addi r11, r11, 0x115c
	ctx.r[11].s64 = ctx.r[11].s64 + 4444;
	// 82E8B8AC: 995F0008  stb r10, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 82E8B8B0: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8B8B4: D1BF0010  stfs f13, 0x10(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82E8B8B8: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8B8BC: D1BF0014  stfs f13, 0x14(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82E8B8C0: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8B8C4: D1BF0018  stfs f13, 0x18(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82E8B8C8: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82E8B8CC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8B8D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8B8D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8B8D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8B8DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8B8E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8B8E0 size=12
    let mut pc: u32 = 0x82E8B8E0;
    'dispatch: loop {
        match pc {
            0x82E8B8E0 => {
    //   block [0x82E8B8E0..0x82E8B8EC)
	// 82E8B8E0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8B8E4: 386B2514  addi r3, r11, 0x2514
	ctx.r[3].s64 = ctx.r[11].s64 + 9492;
	// 82E8B8E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8B8F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8B8F0 size=100
    let mut pc: u32 = 0x82E8B8F0;
    'dispatch: loop {
        match pc {
            0x82E8B8F0 => {
    //   block [0x82E8B8F0..0x82E8B938)
	// 82E8B8F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8B8F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8B8F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8B8FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8B900: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8B904: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8B908: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8B90C: 396B9768  addi r11, r11, -0x6898
	ctx.r[11].s64 = ctx.r[11].s64 + -26776;
	// 82E8B910: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8B914: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E8B918: 4BFFA661  bl 0x82e85f78
	ctx.lr = 0x82E8B91C;
	sub_82E85F78(ctx, base);
	// 82E8B91C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8B920: 41820018  beq 0x82e8b938
	if ctx.cr[0].eq {
	pc = 0x82E8B938; continue 'dispatch;
	}
	// 82E8B924: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E8B928: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8B92C: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E8B930: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8B934: 4E800421  bctrl
	ctx.lr = 0x82E8B938;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8B938 => {
    //   block [0x82E8B938..0x82E8B954)
	// 82E8B938: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8B93C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8B940: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8B944: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8B948: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8B94C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8B950: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8B958(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8B958 size=228
    let mut pc: u32 = 0x82E8B958;
    'dispatch: loop {
        match pc {
            0x82E8B958 => {
    //   block [0x82E8B958..0x82E8B980)
	// 82E8B958: 89630008  lbz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8B95C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8B960: 40820020  bne 0x82e8b980
	if !ctx.cr[0].eq {
	pc = 0x82E8B980; continue 'dispatch;
	}
	// 82E8B964: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8B968: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8B96C: 41820014  beq 0x82e8b980
	if ctx.cr[0].eq {
	pc = 0x82E8B980; continue 'dispatch;
	}
	// 82E8B970: C1AB0034  lfs f13, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8B974: C18B0038  lfs f12, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8B978: C16B003C  lfs f11, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8B97C: 48000010  b 0x82e8b98c
	pc = 0x82E8B98C; continue 'dispatch;
            }
            0x82E8B980 => {
    //   block [0x82E8B980..0x82E8B98C)
	// 82E8B980: C1A30010  lfs f13, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8B984: C1830014  lfs f12, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8B988: C1630018  lfs f11, 0x18(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	pc = 0x82E8B98C; continue 'dispatch;
            }
            0x82E8B98C => {
    //   block [0x82E8B98C..0x82E8B9C0)
	// 82E8B98C: C0050034  lfs f0, 0x34(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8B990: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8B994: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E8B998: C1A50038  lfs f13, 0x38(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8B99C: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E8B9A0: C185003C  lfs f12, 0x3c(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8B9A4: D1A1FFF4  stfs f13, -0xc(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 82E8B9A8: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E8B9AC: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 82E8B9B0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E8B9B4: C1A3001C  lfs f13, 0x1c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8B9B8: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8B9BC: D181FFF8  stfs f12, -8(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	pc = 0x82E8B9C0; continue 'dispatch;
            }
            0x82E8B9C0 => {
    //   block [0x82E8B9C0..0x82E8B9D8)
	// 82E8B9C0: 2C0A0000  cmpwi r10, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8B9C4: 41820020  beq 0x82e8b9e4
	if ctx.cr[0].eq {
	pc = 0x82E8B9E4; continue 'dispatch;
	}
	// 82E8B9C8: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 82E8B9CC: 409A000C  bne cr6, 0x82e8b9d8
	if !ctx.cr[6].eq {
	pc = 0x82E8B9D8; continue 'dispatch;
	}
	// 82E8B9D0: 3921FFF4  addi r9, r1, -0xc
	ctx.r[9].s64 = ctx.r[1].s64 + -12;
	// 82E8B9D4: 48000014  b 0x82e8b9e8
	pc = 0x82E8B9E8; continue 'dispatch;
            }
            0x82E8B9D8 => {
    //   block [0x82E8B9D8..0x82E8B9E4)
	// 82E8B9D8: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 82E8B9DC: 3921FFF8  addi r9, r1, -8
	ctx.r[9].s64 = ctx.r[1].s64 + -8;
	// 82E8B9E0: 419A0008  beq cr6, 0x82e8b9e8
	if ctx.cr[6].eq {
	pc = 0x82E8B9E8; continue 'dispatch;
	}
	pc = 0x82E8B9E4; continue 'dispatch;
            }
            0x82E8B9E4 => {
    //   block [0x82E8B9E4..0x82E8B9E8)
	// 82E8B9E4: 3921FFF0  addi r9, r1, -0x10
	ctx.r[9].s64 = ctx.r[1].s64 + -16;
	pc = 0x82E8B9E8; continue 'dispatch;
            }
            0x82E8B9E8 => {
    //   block [0x82E8B9E8..0x82E8BA00)
	// 82E8B9E8: 2C0A0000  cmpwi r10, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8B9EC: 41820020  beq 0x82e8ba0c
	if ctx.cr[0].eq {
	pc = 0x82E8BA0C; continue 'dispatch;
	}
	// 82E8B9F0: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 82E8B9F4: 409A000C  bne cr6, 0x82e8ba00
	if !ctx.cr[6].eq {
	pc = 0x82E8BA00; continue 'dispatch;
	}
	// 82E8B9F8: 3961FFF4  addi r11, r1, -0xc
	ctx.r[11].s64 = ctx.r[1].s64 + -12;
	// 82E8B9FC: 48000014  b 0x82e8ba10
	pc = 0x82E8BA10; continue 'dispatch;
            }
            0x82E8BA00 => {
    //   block [0x82E8BA00..0x82E8BA0C)
	// 82E8BA00: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 82E8BA04: 3961FFF8  addi r11, r1, -8
	ctx.r[11].s64 = ctx.r[1].s64 + -8;
	// 82E8BA08: 419A0008  beq cr6, 0x82e8ba10
	if ctx.cr[6].eq {
	pc = 0x82E8BA10; continue 'dispatch;
	}
	pc = 0x82E8BA0C; continue 'dispatch;
            }
            0x82E8BA0C => {
    //   block [0x82E8BA0C..0x82E8BA10)
	// 82E8BA0C: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	pc = 0x82E8BA10; continue 'dispatch;
            }
            0x82E8BA10 => {
    //   block [0x82E8BA10..0x82E8BA3C)
	// 82E8BA10: C1890000  lfs f12, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8BA14: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8BA18: EC0C02FA  fmadds f0, f12, f11, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8BA1C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E8BA20: 4199001C  bgt cr6, 0x82e8ba3c
	if ctx.cr[6].gt {
		sub_82E8BA3C(ctx, base);
		return;
	}
	// 82E8BA24: 396A0001  addi r11, r10, 1
	ctx.r[11].s64 = ctx.r[10].s64 + 1;
	// 82E8BA28: 556A063E  clrlwi r10, r11, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82E8BA2C: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 82E8BA30: 4198FF90  blt cr6, 0x82e8b9c0
	if ctx.cr[6].lt {
	pc = 0x82E8B9C0; continue 'dispatch;
	}
	// 82E8BA34: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8BA38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8BA3C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8BA3C size=8
    let mut pc: u32 = 0x82E8BA3C;
    'dispatch: loop {
        match pc {
            0x82E8BA3C => {
    //   block [0x82E8BA3C..0x82E8BA44)
	// 82E8BA3C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E8BA40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8BA48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8BA48 size=584
    let mut pc: u32 = 0x82E8BA48;
    'dispatch: loop {
        match pc {
            0x82E8BA48 => {
    //   block [0x82E8BA48..0x82E8BA88)
	// 82E8BA48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8BA4C: 4BE1D9A9  bl 0x82ca93f4
	ctx.lr = 0x82E8BA50;
	sub_82CA93D0(ctx, base);
	// 82E8BA50: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8BA54: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 82E8BA58: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82E8BA5C: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 82E8BA60: 419A0030  beq cr6, 0x82e8ba90
	if ctx.cr[6].eq {
	pc = 0x82E8BA90; continue 'dispatch;
	}
	// 82E8BA64: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82E8BA68: 483305F9  bl 0x831bc060
	ctx.lr = 0x82E8BA6C;
	sub_831BC060(ctx, base);
	// 82E8BA6C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8BA70: 41820020  beq 0x82e8ba90
	if ctx.cr[0].eq {
	pc = 0x82E8BA90; continue 'dispatch;
	}
	// 82E8BA74: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82E8BA78: 483305E9  bl 0x831bc060
	ctx.lr = 0x82E8BA7C;
	sub_831BC060(ctx, base);
	// 82E8BA7C: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8BA80: 2B0B005F  cmplwi cr6, r11, 0x5f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 95 as u32, &mut ctx.xer);
	// 82E8BA84: 409A000C  bne cr6, 0x82e8ba90
	if !ctx.cr[6].eq {
	pc = 0x82E8BA90; continue 'dispatch;
	}
	pc = 0x82E8BA88; continue 'dispatch;
            }
            0x82E8BA88 => {
    //   block [0x82E8BA88..0x82E8BA90)
	// 82E8BA88: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E8BA8C: 480001FC  b 0x82e8bc88
	pc = 0x82E8BC88; continue 'dispatch;
            }
            0x82E8BA90 => {
    //   block [0x82E8BA90..0x82E8BAE4)
	// 82E8BA90: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82E8BA94: 483305CD  bl 0x831bc060
	ctx.lr = 0x82E8BA98;
	sub_831BC060(ctx, base);
	// 82E8BA98: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8BA9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8BAA0: 388B9790  addi r4, r11, -0x6870
	ctx.r[4].s64 = ctx.r[11].s64 + -26736;
	// 82E8BAA4: 4BE210AD  bl 0x82cacb50
	ctx.lr = 0x82E8BAA8;
	sub_82CACB50(ctx, base);
	// 82E8BAA8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8BAAC: 4082014C  bne 0x82e8bbf8
	if !ctx.cr[0].eq {
	pc = 0x82E8BBF8; continue 'dispatch;
	}
	// 82E8BAB0: 81770020  lwz r11, 0x20(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E8BAB4: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82E8BAB8: 419A002C  beq cr6, 0x82e8bae4
	if ctx.cr[6].eq {
	pc = 0x82E8BAE4; continue 'dispatch;
	}
	// 82E8BABC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8BAC0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E8BAC4: 396B115C  addi r11, r11, 0x115c
	ctx.r[11].s64 = ctx.r[11].s64 + 4444;
	// 82E8BAC8: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8BACC: D0180010  stfs f0, 0x10(r24)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82E8BAD0: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8BAD4: D0180014  stfs f0, 0x14(r24)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82E8BAD8: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8BADC: D0180018  stfs f0, 0x18(r24)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82E8BAE0: 480001A8  b 0x82e8bc88
	pc = 0x82E8BC88; continue 'dispatch;
            }
            0x82E8BAE4 => {
    //   block [0x82E8BAE4..0x82E8BB04)
	// 82E8BAE4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E8BAE8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E8BAEC: 3B4B0F00  addi r26, r11, 0xf00
	ctx.r[26].s64 = ctx.r[11].s64 + 3840;
	// 82E8BAF0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82E8BAF4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82E8BAF8: 3B2B1150  addi r25, r11, 0x1150
	ctx.r[25].s64 = ctx.r[11].s64 + 4432;
	// 82E8BAFC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82E8BB00: 3B8B115C  addi r28, r11, 0x115c
	ctx.r[28].s64 = ctx.r[11].s64 + 4444;
	pc = 0x82E8BB04; continue 'dispatch;
            }
            0x82E8BB04 => {
    //   block [0x82E8BB04..0x82E8BB54)
	// 82E8BB04: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E8BB08: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82E8BB0C: 4BFF851D  bl 0x82e84028
	ctx.lr = 0x82E8BB10;
	sub_82E84028(ctx, base);
	// 82E8BB10: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82E8BB14: 418200A4  beq 0x82e8bbb8
	if ctx.cr[0].eq {
	pc = 0x82E8BBB8; continue 'dispatch;
	}
	// 82E8BB18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8BB1C: 48330545  bl 0x831bc060
	ctx.lr = 0x82E8BB20;
	sub_831BC060(ctx, base);
	// 82E8BB20: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E8BB24: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E8BB28: 4BE21029  bl 0x82cacb50
	ctx.lr = 0x82E8BB2C;
	sub_82CACB50(ctx, base);
	// 82E8BB2C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8BB30: 40820024  bne 0x82e8bb54
	if !ctx.cr[0].eq {
	pc = 0x82E8BB54; continue 'dispatch;
	}
	// 82E8BB34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8BB38: 4BA821D1  bl 0x8290dd08
	ctx.lr = 0x82E8BB3C;
	sub_8290DD08(ctx, base);
	// 82E8BB3C: 4BE20075  bl 0x82cabbb0
	ctx.lr = 0x82E8BB40;
	sub_82CABBB0(ctx, base);
	// 82E8BB40: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82E8BB44: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E8BB48: D0180010  stfs f0, 0x10(r24)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82E8BB4C: 617D0001  ori r29, r11, 1
	ctx.r[29].u64 = ctx.r[11].u64 | 1;
	// 82E8BB50: 48000068  b 0x82e8bbb8
	pc = 0x82E8BBB8; continue 'dispatch;
            }
            0x82E8BB54 => {
    //   block [0x82E8BB54..0x82E8BB88)
	// 82E8BB54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8BB58: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82E8BB5C: 4BE20FF5  bl 0x82cacb50
	ctx.lr = 0x82E8BB60;
	sub_82CACB50(ctx, base);
	// 82E8BB60: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8BB64: 40820024  bne 0x82e8bb88
	if !ctx.cr[0].eq {
	pc = 0x82E8BB88; continue 'dispatch;
	}
	// 82E8BB68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8BB6C: 4BA8219D  bl 0x8290dd08
	ctx.lr = 0x82E8BB70;
	sub_8290DD08(ctx, base);
	// 82E8BB70: 4BE20041  bl 0x82cabbb0
	ctx.lr = 0x82E8BB74;
	sub_82CABBB0(ctx, base);
	// 82E8BB74: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82E8BB78: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E8BB7C: D0180014  stfs f0, 0x14(r24)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82E8BB80: 617D0002  ori r29, r11, 2
	ctx.r[29].u64 = ctx.r[11].u64 | 2;
	// 82E8BB84: 48000034  b 0x82e8bbb8
	pc = 0x82E8BBB8; continue 'dispatch;
            }
            0x82E8BB88 => {
    //   block [0x82E8BB88..0x82E8BBB8)
	// 82E8BB88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8BB8C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82E8BB90: 4BE20FC1  bl 0x82cacb50
	ctx.lr = 0x82E8BB94;
	sub_82CACB50(ctx, base);
	// 82E8BB94: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8BB98: 40820020  bne 0x82e8bbb8
	if !ctx.cr[0].eq {
	pc = 0x82E8BBB8; continue 'dispatch;
	}
	// 82E8BB9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8BBA0: 4BA82169  bl 0x8290dd08
	ctx.lr = 0x82E8BBA4;
	sub_8290DD08(ctx, base);
	// 82E8BBA4: 4BE2000D  bl 0x82cabbb0
	ctx.lr = 0x82E8BBA8;
	sub_82CABBB0(ctx, base);
	// 82E8BBA8: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82E8BBAC: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E8BBB0: D0180018  stfs f0, 0x18(r24)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82E8BBB4: 617D0004  ori r29, r11, 4
	ctx.r[29].u64 = ctx.r[11].u64 | 4;
	pc = 0x82E8BBB8; continue 'dispatch;
            }
            0x82E8BBB8 => {
    //   block [0x82E8BBB8..0x82E8BBF8)
	// 82E8BBB8: 397B0001  addi r11, r27, 1
	ctx.r[11].s64 = ctx.r[27].s64 + 1;
	// 82E8BBBC: 557B063E  clrlwi r27, r11, 0x18
	ctx.r[27].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82E8BBC0: 2B1B0003  cmplwi cr6, r27, 3
	ctx.cr[6].compare_u32(ctx.r[27].u32, 3 as u32, &mut ctx.xer);
	// 82E8BBC4: 4198FF40  blt cr6, 0x82e8bb04
	if ctx.cr[6].lt {
	pc = 0x82E8BB04; continue 'dispatch;
	}
	// 82E8BBC8: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82E8BBCC: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 82E8BBD0: 419AFEB8  beq cr6, 0x82e8ba88
	if ctx.cr[6].eq {
	pc = 0x82E8BA88; continue 'dispatch;
	}
	// 82E8BBD4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8BBD8: 396B115C  addi r11, r11, 0x115c
	ctx.r[11].s64 = ctx.r[11].s64 + 4444;
	// 82E8BBDC: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8BBE0: D0180010  stfs f0, 0x10(r24)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82E8BBE4: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8BBE8: D0180014  stfs f0, 0x14(r24)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82E8BBEC: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8BBF0: D0180018  stfs f0, 0x18(r24)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82E8BBF4: 4BFFFE94  b 0x82e8ba88
	pc = 0x82E8BA88; continue 'dispatch;
            }
            0x82E8BBF8 => {
    //   block [0x82E8BBF8..0x82E8BC48)
	// 82E8BBF8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8BBFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8BC00: 388B9784  addi r4, r11, -0x687c
	ctx.r[4].s64 = ctx.r[11].s64 + -26748;
	// 82E8BC04: 4BE20F4D  bl 0x82cacb50
	ctx.lr = 0x82E8BC08;
	sub_82CACB50(ctx, base);
	// 82E8BC08: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8BC0C: 40820078  bne 0x82e8bc84
	if !ctx.cr[0].eq {
	pc = 0x82E8BC84; continue 'dispatch;
	}
	// 82E8BC10: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82E8BC14: 4BA820F5  bl 0x8290dd08
	ctx.lr = 0x82E8BC18;
	sub_8290DD08(ctx, base);
	// 82E8BC18: 4BE1FF99  bl 0x82cabbb0
	ctx.lr = 0x82E8BC1C;
	sub_82CABBB0(ctx, base);
	// 82E8BC1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8BC20: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82E8BC24: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8BC28: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8BC2C: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E8BC30: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E8BC34: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8BC38: 40980028  bge cr6, 0x82e8bc60
	if !ctx.cr[6].lt {
	pc = 0x82E8BC60; continue 'dispatch;
	}
	// 82E8BC3C: 4182000C  beq 0x82e8bc48
	if ctx.cr[0].eq {
	pc = 0x82E8BC48; continue 'dispatch;
	}
	// 82E8BC40: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8BC44: 4800000C  b 0x82e8bc50
	pc = 0x82E8BC50; continue 'dispatch;
            }
            0x82E8BC48 => {
    //   block [0x82E8BC48..0x82E8BC50)
	// 82E8BC48: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8BC4C: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82E8BC50; continue 'dispatch;
            }
            0x82E8BC50 => {
    //   block [0x82E8BC50..0x82E8BC60)
	// 82E8BC50: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8BC54: C00B0AEC  lfs f0, 0xaec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2796 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8BC58: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8BC5C: 4800001C  b 0x82e8bc78
	pc = 0x82E8BC78; continue 'dispatch;
            }
            0x82E8BC60 => {
    //   block [0x82E8BC60..0x82E8BC6C)
	// 82E8BC60: 4182000C  beq 0x82e8bc6c
	if ctx.cr[0].eq {
	pc = 0x82E8BC6C; continue 'dispatch;
	}
	// 82E8BC64: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8BC68: 4800000C  b 0x82e8bc74
	pc = 0x82E8BC74; continue 'dispatch;
            }
            0x82E8BC6C => {
    //   block [0x82E8BC6C..0x82E8BC74)
	// 82E8BC6C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8BC70: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82E8BC74; continue 'dispatch;
            }
            0x82E8BC74 => {
    //   block [0x82E8BC74..0x82E8BC78)
	// 82E8BC74: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	pc = 0x82E8BC78; continue 'dispatch;
            }
            0x82E8BC78 => {
    //   block [0x82E8BC78..0x82E8BC84)
	// 82E8BC78: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8BC7C: D018001C  stfs f0, 0x1c(r24)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82E8BC80: 4BFFFE08  b 0x82e8ba88
	pc = 0x82E8BA88; continue 'dispatch;
            }
            0x82E8BC84 => {
    //   block [0x82E8BC84..0x82E8BC88)
	// 82E8BC84: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E8BC88; continue 'dispatch;
            }
            0x82E8BC88 => {
    //   block [0x82E8BC88..0x82E8BC90)
	// 82E8BC88: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E8BC8C: 4BE1D7B8  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8BC90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8BC90 size=72
    let mut pc: u32 = 0x82E8BC90;
    'dispatch: loop {
        match pc {
            0x82E8BC90 => {
    //   block [0x82E8BC90..0x82E8BCC0)
	// 82E8BC90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8BC94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8BC98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8BC9C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8BCA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8BCA4: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 82E8BCA8: 4B78AC81  bl 0x82616928
	ctx.lr = 0x82E8BCAC;
	sub_82616928(ctx, base);
	// 82E8BCAC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8BCB0: 41820010  beq 0x82e8bcc0
	if ctx.cr[0].eq {
	pc = 0x82E8BCC0; continue 'dispatch;
	}
	// 82E8BCB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E8BCB8: 4BFFFBB1  bl 0x82e8b868
	ctx.lr = 0x82E8BCBC;
	sub_82E8B868(ctx, base);
	// 82E8BCBC: 48000008  b 0x82e8bcc4
	pc = 0x82E8BCC4; continue 'dispatch;
            }
            0x82E8BCC0 => {
    //   block [0x82E8BCC0..0x82E8BCC4)
	// 82E8BCC0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E8BCC4; continue 'dispatch;
            }
            0x82E8BCC4 => {
    //   block [0x82E8BCC4..0x82E8BCD8)
	// 82E8BCC4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8BCC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8BCCC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8BCD0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8BCD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8BCD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8BCD8 size=88
    let mut pc: u32 = 0x82E8BCD8;
    'dispatch: loop {
        match pc {
            0x82E8BCD8 => {
    //   block [0x82E8BCD8..0x82E8BD28)
	// 82E8BCD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8BCDC: 4BE1D731  bl 0x82ca940c
	ctx.lr = 0x82E8BCE0;
	sub_82CA93D0(ctx, base);
	// 82E8BCE0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8BCE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E8BCE8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E8BCEC: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82E8BCF0: 41980038  blt cr6, 0x82e8bd28
	if ctx.cr[6].lt {
	pc = 0x82E8BD28; continue 'dispatch;
	}
	// 82E8BCF4: 4B3D4CC5  bl 0x822609b8
	ctx.lr = 0x82E8BCF8;
	sub_822609B8(ctx, base);
	// 82E8BCF8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8BCFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8BD00: 4BFF5631  bl 0x82e81330
	ctx.lr = 0x82E8BD04;
	sub_82E81330(ctx, base);
	// 82E8BD04: 7BAB0020  clrldi r11, r29, 0x20
	ctx.r[11].u64 = ctx.r[29].u64 & 0x00000000FFFFFFFFu64;
	// 82E8BD08: C1BF0074  lfs f13, 0x74(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8BD0C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82E8BD10: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E8BD14: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82E8BD18: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82E8BD1C: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8BD20: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82E8BD24: D01F0074  stfs f0, 0x74(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	pc = 0x82E8BD28; continue 'dispatch;
            }
            0x82E8BD28 => {
    //   block [0x82E8BD28..0x82E8BD30)
	// 82E8BD28: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E8BD2C: 4BE1D730  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8BD30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8BD30 size=48
    let mut pc: u32 = 0x82E8BD30;
    'dispatch: loop {
        match pc {
            0x82E8BD30 => {
    //   block [0x82E8BD30..0x82E8BD60)
	// 82E8BD30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8BD34: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82E8BD38: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82E8BD3C: 396B97B8  addi r11, r11, -0x6848
	ctx.r[11].s64 = ctx.r[11].s64 + -26696;
	// 82E8BD40: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 82E8BD44: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82E8BD48: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82E8BD4C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E8BD50: 9143000C  stw r10, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82E8BD54: 99230010  stb r9, 0x10(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[9].u8 ) };
	// 82E8BD58: 91030014  stw r8, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 82E8BD5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8BD60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8BD60 size=148
    let mut pc: u32 = 0x82E8BD60;
    'dispatch: loop {
        match pc {
            0x82E8BD60 => {
    //   block [0x82E8BD60..0x82E8BD8C)
	// 82E8BD60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8BD64: 4BE1D6A1  bl 0x82ca9404
	ctx.lr = 0x82E8BD68;
	sub_82CA93D0(ctx, base);
	// 82E8BD68: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8BD6C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E8BD70: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82E8BD74: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E8BD78: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E8BD7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8BD80: 40990060  ble cr6, 0x82e8bde0
	if !ctx.cr[6].gt {
	pc = 0x82E8BDE0; continue 'dispatch;
	}
	// 82E8BD84: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8BD88: 3B8B8FD8  addi r28, r11, -0x7028
	ctx.r[28].s64 = ctx.r[11].s64 + -28712;
	pc = 0x82E8BD8C; continue 'dispatch;
            }
            0x82E8BD8C => {
    //   block [0x82E8BD8C..0x82E8BDD0)
	// 82E8BD8C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8BD90: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8BD94: 4BFF8295  bl 0x82e84028
	ctx.lr = 0x82E8BD98;
	sub_82E84028(ctx, base);
	// 82E8BD98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8BD9C: 483302C5  bl 0x831bc060
	ctx.lr = 0x82E8BDA0;
	sub_831BC060(ctx, base);
	// 82E8BDA0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E8BDA4: 4BE20DAD  bl 0x82cacb50
	ctx.lr = 0x82E8BDA8;
	sub_82CACB50(ctx, base);
	// 82E8BDA8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8BDAC: 41820024  beq 0x82e8bdd0
	if ctx.cr[0].eq {
	pc = 0x82E8BDD0; continue 'dispatch;
	}
	// 82E8BDB0: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8BDB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E8BDB8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82E8BDBC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8BDC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8BDC4: 4E800421  bctrl
	ctx.lr = 0x82E8BDC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8BDC8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8BDCC: 41820020  beq 0x82e8bdec
	if ctx.cr[0].eq {
	pc = 0x82E8BDEC; continue 'dispatch;
	}
            }
            0x82E8BDD0 => {
    //   block [0x82E8BDD0..0x82E8BDE0)
	// 82E8BDD0: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E8BDD4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82E8BDD8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8BDDC: 4198FFB0  blt cr6, 0x82e8bd8c
	if ctx.cr[6].lt {
	pc = 0x82E8BD8C; continue 'dispatch;
	}
	pc = 0x82E8BDE0; continue 'dispatch;
            }
            0x82E8BDE0 => {
    //   block [0x82E8BDE0..0x82E8BDE4)
	// 82E8BDE0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82E8BDE4; continue 'dispatch;
            }
            0x82E8BDE4 => {
    //   block [0x82E8BDE4..0x82E8BDEC)
	// 82E8BDE4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E8BDE8: 4BE1D66C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82E8BDEC => {
    //   block [0x82E8BDEC..0x82E8BDF4)
	// 82E8BDEC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8BDF0: 4BFFFFF4  b 0x82e8bde4
	pc = 0x82E8BDE4; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8BDF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8BDF8 size=12
    let mut pc: u32 = 0x82E8BDF8;
    'dispatch: loop {
        match pc {
            0x82E8BDF8 => {
    //   block [0x82E8BDF8..0x82E8BE04)
	// 82E8BDF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8BDFC: 99630010  stb r11, 0x10(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u8 ) };
	// 82E8BE00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8BE08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8BE08 size=220
    let mut pc: u32 = 0x82E8BE08;
    'dispatch: loop {
        match pc {
            0x82E8BE08 => {
    //   block [0x82E8BE08..0x82E8BE24)
	// 82E8BE08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8BE0C: 4BE1D601  bl 0x82ca940c
	ctx.lr = 0x82E8BE10;
	sub_82CA93D0(ctx, base);
	// 82E8BE10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8BE14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8BE18: 4B3D4BA1  bl 0x822609b8
	ctx.lr = 0x82E8BE1C;
	sub_822609B8(ctx, base);
	// 82E8BE1C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E8BE20: 48000094  b 0x82e8beb4
	pc = 0x82E8BEB4; continue 'dispatch;
            }
            0x82E8BE24 => {
    //   block [0x82E8BE24..0x82E8BE80)
	// 82E8BE24: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8BE28: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8BE2C: 4BFF5D85  bl 0x82e81bb0
	ctx.lr = 0x82E8BE30;
	sub_82E81BB0(ctx, base);
	// 82E8BE30: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8BE34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8BE38: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82E8BE3C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8BE40: 4E800421  bctrl
	ctx.lr = 0x82E8BE44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8BE44: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82E8BE48: 41820038  beq 0x82e8be80
	if ctx.cr[0].eq {
	pc = 0x82E8BE80; continue 'dispatch;
	}
	// 82E8BE4C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8BE50: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8BE54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8BE58: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82E8BE5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8BE60: 4E800421  bctrl
	ctx.lr = 0x82E8BE64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8BE64: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8BE68: 41820068  beq 0x82e8bed0
	if ctx.cr[0].eq {
	pc = 0x82E8BED0; continue 'dispatch;
	}
	// 82E8BE6C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8BE70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8BE74: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E8BE78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8BE7C: 4E800421  bctrl
	ctx.lr = 0x82E8BE80;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8BE80 => {
    //   block [0x82E8BE80..0x82E8BEA8)
	// 82E8BE80: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E8BE84: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8BE88: 4BFFFE51  bl 0x82e8bcd8
	ctx.lr = 0x82E8BE8C;
	sub_82E8BCD8(ctx, base);
	// 82E8BE8C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8BE90: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8BE94: 4BFF5FCD  bl 0x82e81e60
	ctx.lr = 0x82E8BE98;
	sub_82E81E60(ctx, base);
	// 82E8BE98: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82E8BE9C: 409A000C  bne cr6, 0x82e8bea8
	if !ctx.cr[6].eq {
	pc = 0x82E8BEA8; continue 'dispatch;
	}
	// 82E8BEA0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E8BEA4: 997F0010  stb r11, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u8 ) };
	pc = 0x82E8BEA8; continue 'dispatch;
            }
            0x82E8BEA8 => {
    //   block [0x82E8BEA8..0x82E8BEB4)
	// 82E8BEA8: 897F0010  lbz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E8BEAC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E8BEB0: 419A002C  beq cr6, 0x82e8bedc
	if ctx.cr[6].eq {
	pc = 0x82E8BEDC; continue 'dispatch;
	}
	pc = 0x82E8BEB4; continue 'dispatch;
            }
            0x82E8BEB4 => {
    //   block [0x82E8BEB4..0x82E8BED0)
	// 82E8BEB4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8BEB8: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8BEBC: 4BFF5AA5  bl 0x82e81960
	ctx.lr = 0x82E8BEC0;
	sub_82E81960(ctx, base);
	// 82E8BEC0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E8BEC4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E8BEC8: 419AFF5C  beq cr6, 0x82e8be24
	if ctx.cr[6].eq {
	pc = 0x82E8BE24; continue 'dispatch;
	}
	// 82E8BECC: 48000010  b 0x82e8bedc
	pc = 0x82E8BEDC; continue 'dispatch;
            }
            0x82E8BED0 => {
    //   block [0x82E8BED0..0x82E8BEDC)
	// 82E8BED0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8BED4: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8BED8: 4BFF5F89  bl 0x82e81e60
	ctx.lr = 0x82E8BEDC;
	sub_82E81E60(ctx, base);
	pc = 0x82E8BEDC; continue 'dispatch;
            }
            0x82E8BEDC => {
    //   block [0x82E8BEDC..0x82E8BEE4)
	// 82E8BEDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8BEE0: 4BE1D57C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8BEE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8BEE8 size=308
    let mut pc: u32 = 0x82E8BEE8;
    'dispatch: loop {
        match pc {
            0x82E8BEE8 => {
    //   block [0x82E8BEE8..0x82E8BF14)
	// 82E8BEE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8BEEC: 4BE1D51D  bl 0x82ca9408
	ctx.lr = 0x82E8BEF0;
	sub_82CA93D0(ctx, base);
	// 82E8BEF0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8BEF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8BEF8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8BEFC: 4B3D4ABD  bl 0x822609b8
	ctx.lr = 0x82E8BF00;
	sub_822609B8(ctx, base);
	// 82E8BF00: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8BF04: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8BF08: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E8BF0C: 4BFF5D2D  bl 0x82e81c38
	ctx.lr = 0x82E8BF10;
	sub_82E81C38(ctx, base);
	// 82E8BF10: 4800009C  b 0x82e8bfac
	pc = 0x82E8BFAC; continue 'dispatch;
            }
            0x82E8BF14 => {
    //   block [0x82E8BF14..0x82E8BF74)
	// 82E8BF14: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8BF18: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8BF1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8BF20: 4BFF5BD1  bl 0x82e81af0
	ctx.lr = 0x82E8BF24;
	sub_82E81AF0(ctx, base);
	// 82E8BF24: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8BF28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8BF2C: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82E8BF30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8BF34: 4E800421  bctrl
	ctx.lr = 0x82E8BF38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8BF38: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82E8BF3C: 41820038  beq 0x82e8bf74
	if ctx.cr[0].eq {
	pc = 0x82E8BF74; continue 'dispatch;
	}
	// 82E8BF40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8BF44: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E8BF48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8BF4C: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82E8BF50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8BF54: 4E800421  bctrl
	ctx.lr = 0x82E8BF58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8BF58: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8BF5C: 41820070  beq 0x82e8bfcc
	if ctx.cr[0].eq {
	pc = 0x82E8BFCC; continue 'dispatch;
	}
	// 82E8BF60: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8BF64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8BF68: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E8BF6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8BF70: 4E800421  bctrl
	ctx.lr = 0x82E8BF74;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8BF74 => {
    //   block [0x82E8BF74..0x82E8BFA0)
	// 82E8BF74: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E8BF78: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8BF7C: 4BFFFD5D  bl 0x82e8bcd8
	ctx.lr = 0x82E8BF80;
	sub_82E8BCD8(ctx, base);
	// 82E8BF80: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8BF84: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8BF88: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8BF8C: 4BFF5D5D  bl 0x82e81ce8
	ctx.lr = 0x82E8BF90;
	sub_82E81CE8(ctx, base);
	// 82E8BF90: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82E8BF94: 409A000C  bne cr6, 0x82e8bfa0
	if !ctx.cr[6].eq {
	pc = 0x82E8BFA0; continue 'dispatch;
	}
	// 82E8BF98: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E8BF9C: 997F0010  stb r11, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u8 ) };
	pc = 0x82E8BFA0; continue 'dispatch;
            }
            0x82E8BFA0 => {
    //   block [0x82E8BFA0..0x82E8BFAC)
	// 82E8BFA0: 897F0010  lbz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E8BFA4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E8BFA8: 419A0040  beq cr6, 0x82e8bfe8
	if ctx.cr[6].eq {
	pc = 0x82E8BFE8; continue 'dispatch;
	}
	pc = 0x82E8BFAC; continue 'dispatch;
            }
            0x82E8BFAC => {
    //   block [0x82E8BFAC..0x82E8BFCC)
	// 82E8BFAC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8BFB0: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8BFB4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8BFB8: 4BFF57A1  bl 0x82e81758
	ctx.lr = 0x82E8BFBC;
	sub_82E81758(ctx, base);
	// 82E8BFBC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E8BFC0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E8BFC4: 419AFF50  beq cr6, 0x82e8bf14
	if ctx.cr[6].eq {
	pc = 0x82E8BF14; continue 'dispatch;
	}
	// 82E8BFC8: 48000030  b 0x82e8bff8
	pc = 0x82E8BFF8; continue 'dispatch;
            }
            0x82E8BFCC => {
    //   block [0x82E8BFCC..0x82E8BFE8)
	// 82E8BFCC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8BFD0: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8BFD4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8BFD8: 4BFF5D11  bl 0x82e81ce8
	ctx.lr = 0x82E8BFDC;
	sub_82E81CE8(ctx, base);
	// 82E8BFDC: 897F0010  lbz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E8BFE0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E8BFE4: 409A0014  bne cr6, 0x82e8bff8
	if !ctx.cr[6].eq {
	pc = 0x82E8BFF8; continue 'dispatch;
	}
	pc = 0x82E8BFE8; continue 'dispatch;
            }
            0x82E8BFE8 => {
    //   block [0x82E8BFE8..0x82E8BFF8)
	// 82E8BFE8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8BFEC: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8BFF0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8BFF4: 4BFF5A7D  bl 0x82e81a70
	ctx.lr = 0x82E8BFF8;
	sub_82E81A70(ctx, base);
	pc = 0x82E8BFF8; continue 'dispatch;
            }
            0x82E8BFF8 => {
    //   block [0x82E8BFF8..0x82E8C014)
	// 82E8BFF8: 897F0010  lbz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E8BFFC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E8C000: 409A0014  bne cr6, 0x82e8c014
	if !ctx.cr[6].eq {
	pc = 0x82E8C014; continue 'dispatch;
	}
	// 82E8C004: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8C008: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8C00C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8C010: 4BFF5A61  bl 0x82e81a70
	ctx.lr = 0x82E8C014;
	sub_82E81A70(ctx, base);
	pc = 0x82E8C014; continue 'dispatch;
            }
            0x82E8C014 => {
    //   block [0x82E8C014..0x82E8C01C)
	// 82E8C014: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E8C018: 4BE1D440  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8C020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8C020 size=308
    let mut pc: u32 = 0x82E8C020;
    'dispatch: loop {
        match pc {
            0x82E8C020 => {
    //   block [0x82E8C020..0x82E8C04C)
	// 82E8C020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8C024: 4BE1D3E5  bl 0x82ca9408
	ctx.lr = 0x82E8C028;
	sub_82CA93D0(ctx, base);
	// 82E8C028: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8C02C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8C030: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8C034: 4B3D4985  bl 0x822609b8
	ctx.lr = 0x82E8C038;
	sub_822609B8(ctx, base);
	// 82E8C038: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8C03C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8C040: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E8C044: 4BFF6C5D  bl 0x82e82ca0
	ctx.lr = 0x82E8C048;
	sub_82E82CA0(ctx, base);
	// 82E8C048: 4800009C  b 0x82e8c0e4
	pc = 0x82E8C0E4; continue 'dispatch;
            }
            0x82E8C04C => {
    //   block [0x82E8C04C..0x82E8C0AC)
	// 82E8C04C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8C050: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8C054: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8C058: 4BFF6B59  bl 0x82e82bb0
	ctx.lr = 0x82E8C05C;
	sub_82E82BB0(ctx, base);
	// 82E8C05C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8C060: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8C064: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82E8C068: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8C06C: 4E800421  bctrl
	ctx.lr = 0x82E8C070;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8C070: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82E8C074: 41820038  beq 0x82e8c0ac
	if ctx.cr[0].eq {
	pc = 0x82E8C0AC; continue 'dispatch;
	}
	// 82E8C078: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8C07C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E8C080: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8C084: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82E8C088: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8C08C: 4E800421  bctrl
	ctx.lr = 0x82E8C090;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8C090: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8C094: 41820070  beq 0x82e8c104
	if ctx.cr[0].eq {
	pc = 0x82E8C104; continue 'dispatch;
	}
	// 82E8C098: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8C09C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8C0A0: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E8C0A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8C0A8: 4E800421  bctrl
	ctx.lr = 0x82E8C0AC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8C0AC => {
    //   block [0x82E8C0AC..0x82E8C0D8)
	// 82E8C0AC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E8C0B0: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8C0B4: 4BFFFC25  bl 0x82e8bcd8
	ctx.lr = 0x82E8C0B8;
	sub_82E8BCD8(ctx, base);
	// 82E8C0B8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8C0BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8C0C0: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8C0C4: 4BFF5CE5  bl 0x82e81da8
	ctx.lr = 0x82E8C0C8;
	sub_82E81DA8(ctx, base);
	// 82E8C0C8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82E8C0CC: 409A000C  bne cr6, 0x82e8c0d8
	if !ctx.cr[6].eq {
	pc = 0x82E8C0D8; continue 'dispatch;
	}
	// 82E8C0D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E8C0D4: 997F0010  stb r11, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u8 ) };
	pc = 0x82E8C0D8; continue 'dispatch;
            }
            0x82E8C0D8 => {
    //   block [0x82E8C0D8..0x82E8C0E4)
	// 82E8C0D8: 897F0010  lbz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E8C0DC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E8C0E0: 419A0040  beq cr6, 0x82e8c120
	if ctx.cr[6].eq {
	pc = 0x82E8C120; continue 'dispatch;
	}
	pc = 0x82E8C0E4; continue 'dispatch;
            }
            0x82E8C0E4 => {
    //   block [0x82E8C0E4..0x82E8C104)
	// 82E8C0E4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8C0E8: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8C0EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8C0F0: 4BFF5781  bl 0x82e81870
	ctx.lr = 0x82E8C0F4;
	sub_82E81870(ctx, base);
	// 82E8C0F4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E8C0F8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E8C0FC: 419AFF50  beq cr6, 0x82e8c04c
	if ctx.cr[6].eq {
	pc = 0x82E8C04C; continue 'dispatch;
	}
	// 82E8C100: 48000030  b 0x82e8c130
	pc = 0x82E8C130; continue 'dispatch;
            }
            0x82E8C104 => {
    //   block [0x82E8C104..0x82E8C120)
	// 82E8C104: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8C108: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8C10C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8C110: 4BFF5C99  bl 0x82e81da8
	ctx.lr = 0x82E8C114;
	sub_82E81DA8(ctx, base);
	// 82E8C114: 897F0010  lbz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E8C118: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E8C11C: 409A0014  bne cr6, 0x82e8c130
	if !ctx.cr[6].eq {
	pc = 0x82E8C130; continue 'dispatch;
	}
	pc = 0x82E8C120; continue 'dispatch;
            }
            0x82E8C120 => {
    //   block [0x82E8C120..0x82E8C130)
	// 82E8C120: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8C124: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8C128: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8C12C: 4BFF69E5  bl 0x82e82b10
	ctx.lr = 0x82E8C130;
	sub_82E82B10(ctx, base);
	pc = 0x82E8C130; continue 'dispatch;
            }
            0x82E8C130 => {
    //   block [0x82E8C130..0x82E8C14C)
	// 82E8C130: 897F0010  lbz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E8C134: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E8C138: 409A0014  bne cr6, 0x82e8c14c
	if !ctx.cr[6].eq {
	pc = 0x82E8C14C; continue 'dispatch;
	}
	// 82E8C13C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8C140: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8C144: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8C148: 4BFF69C9  bl 0x82e82b10
	ctx.lr = 0x82E8C14C;
	sub_82E82B10(ctx, base);
	pc = 0x82E8C14C; continue 'dispatch;
            }
            0x82E8C14C => {
    //   block [0x82E8C14C..0x82E8C154)
	// 82E8C14C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E8C150: 4BE1D308  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8C158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8C158 size=220
    let mut pc: u32 = 0x82E8C158;
    'dispatch: loop {
        match pc {
            0x82E8C158 => {
    //   block [0x82E8C158..0x82E8C174)
	// 82E8C158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8C15C: 4BE1D2B1  bl 0x82ca940c
	ctx.lr = 0x82E8C160;
	sub_82CA93D0(ctx, base);
	// 82E8C160: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8C164: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8C168: 4B3D4851  bl 0x822609b8
	ctx.lr = 0x82E8C16C;
	sub_822609B8(ctx, base);
	// 82E8C16C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E8C170: 48000094  b 0x82e8c204
	pc = 0x82E8C204; continue 'dispatch;
            }
            0x82E8C174 => {
    //   block [0x82E8C174..0x82E8C1D0)
	// 82E8C174: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8C178: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8C17C: 4BFF5A35  bl 0x82e81bb0
	ctx.lr = 0x82E8C180;
	sub_82E81BB0(ctx, base);
	// 82E8C180: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8C184: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8C188: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E8C18C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8C190: 4E800421  bctrl
	ctx.lr = 0x82E8C194;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8C194: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82E8C198: 41820038  beq 0x82e8c1d0
	if ctx.cr[0].eq {
	pc = 0x82E8C1D0; continue 'dispatch;
	}
	// 82E8C19C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8C1A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8C1A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8C1A8: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82E8C1AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8C1B0: 4E800421  bctrl
	ctx.lr = 0x82E8C1B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8C1B4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8C1B8: 41820068  beq 0x82e8c220
	if ctx.cr[0].eq {
	pc = 0x82E8C220; continue 'dispatch;
	}
	// 82E8C1BC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8C1C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8C1C4: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E8C1C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8C1CC: 4E800421  bctrl
	ctx.lr = 0x82E8C1D0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8C1D0 => {
    //   block [0x82E8C1D0..0x82E8C1F8)
	// 82E8C1D0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E8C1D4: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8C1D8: 4BFFFB01  bl 0x82e8bcd8
	ctx.lr = 0x82E8C1DC;
	sub_82E8BCD8(ctx, base);
	// 82E8C1DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8C1E0: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8C1E4: 4BFF5C7D  bl 0x82e81e60
	ctx.lr = 0x82E8C1E8;
	sub_82E81E60(ctx, base);
	// 82E8C1E8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82E8C1EC: 409A000C  bne cr6, 0x82e8c1f8
	if !ctx.cr[6].eq {
	pc = 0x82E8C1F8; continue 'dispatch;
	}
	// 82E8C1F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E8C1F4: 997F0010  stb r11, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u8 ) };
	pc = 0x82E8C1F8; continue 'dispatch;
            }
            0x82E8C1F8 => {
    //   block [0x82E8C1F8..0x82E8C204)
	// 82E8C1F8: 897F0010  lbz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E8C1FC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E8C200: 419A002C  beq cr6, 0x82e8c22c
	if ctx.cr[6].eq {
	pc = 0x82E8C22C; continue 'dispatch;
	}
	pc = 0x82E8C204; continue 'dispatch;
            }
            0x82E8C204 => {
    //   block [0x82E8C204..0x82E8C220)
	// 82E8C204: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8C208: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8C20C: 4BFF5755  bl 0x82e81960
	ctx.lr = 0x82E8C210;
	sub_82E81960(ctx, base);
	// 82E8C210: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E8C214: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E8C218: 419AFF5C  beq cr6, 0x82e8c174
	if ctx.cr[6].eq {
	pc = 0x82E8C174; continue 'dispatch;
	}
	// 82E8C21C: 48000010  b 0x82e8c22c
	pc = 0x82E8C22C; continue 'dispatch;
            }
            0x82E8C220 => {
    //   block [0x82E8C220..0x82E8C22C)
	// 82E8C220: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8C224: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8C228: 4BFF5C39  bl 0x82e81e60
	ctx.lr = 0x82E8C22C;
	sub_82E81E60(ctx, base);
	pc = 0x82E8C22C; continue 'dispatch;
            }
            0x82E8C22C => {
    //   block [0x82E8C22C..0x82E8C234)
	// 82E8C22C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8C230: 4BE1D22C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8C238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8C238 size=280
    let mut pc: u32 = 0x82E8C238;
    'dispatch: loop {
        match pc {
            0x82E8C238 => {
    //   block [0x82E8C238..0x82E8C264)
	// 82E8C238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8C23C: 4BE1D1CD  bl 0x82ca9408
	ctx.lr = 0x82E8C240;
	sub_82CA93D0(ctx, base);
	// 82E8C240: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8C244: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8C248: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8C24C: 4B3D476D  bl 0x822609b8
	ctx.lr = 0x82E8C250;
	sub_822609B8(ctx, base);
	// 82E8C250: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8C254: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8C258: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E8C25C: 4BFF59DD  bl 0x82e81c38
	ctx.lr = 0x82E8C260;
	sub_82E81C38(ctx, base);
	// 82E8C260: 4800009C  b 0x82e8c2fc
	pc = 0x82E8C2FC; continue 'dispatch;
            }
            0x82E8C264 => {
    //   block [0x82E8C264..0x82E8C2C4)
	// 82E8C264: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8C268: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8C26C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8C270: 4BFF5881  bl 0x82e81af0
	ctx.lr = 0x82E8C274;
	sub_82E81AF0(ctx, base);
	// 82E8C274: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8C278: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8C27C: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E8C280: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8C284: 4E800421  bctrl
	ctx.lr = 0x82E8C288;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8C288: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82E8C28C: 41820038  beq 0x82e8c2c4
	if ctx.cr[0].eq {
	pc = 0x82E8C2C4; continue 'dispatch;
	}
	// 82E8C290: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8C294: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E8C298: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8C29C: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82E8C2A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8C2A4: 4E800421  bctrl
	ctx.lr = 0x82E8C2A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8C2A8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8C2AC: 41820070  beq 0x82e8c31c
	if ctx.cr[0].eq {
	pc = 0x82E8C31C; continue 'dispatch;
	}
	// 82E8C2B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8C2B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8C2B8: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E8C2BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8C2C0: 4E800421  bctrl
	ctx.lr = 0x82E8C2C4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8C2C4 => {
    //   block [0x82E8C2C4..0x82E8C2F0)
	// 82E8C2C4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E8C2C8: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8C2CC: 4BFFFA0D  bl 0x82e8bcd8
	ctx.lr = 0x82E8C2D0;
	sub_82E8BCD8(ctx, base);
	// 82E8C2D0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8C2D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8C2D8: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8C2DC: 4BFF5A0D  bl 0x82e81ce8
	ctx.lr = 0x82E8C2E0;
	sub_82E81CE8(ctx, base);
	// 82E8C2E0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82E8C2E4: 409A000C  bne cr6, 0x82e8c2f0
	if !ctx.cr[6].eq {
	pc = 0x82E8C2F0; continue 'dispatch;
	}
	// 82E8C2E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E8C2EC: 997F0010  stb r11, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u8 ) };
	pc = 0x82E8C2F0; continue 'dispatch;
            }
            0x82E8C2F0 => {
    //   block [0x82E8C2F0..0x82E8C2FC)
	// 82E8C2F0: 897F0010  lbz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E8C2F4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E8C2F8: 419A0040  beq cr6, 0x82e8c338
	if ctx.cr[6].eq {
	pc = 0x82E8C338; continue 'dispatch;
	}
	pc = 0x82E8C2FC; continue 'dispatch;
            }
            0x82E8C2FC => {
    //   block [0x82E8C2FC..0x82E8C31C)
	// 82E8C2FC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8C300: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8C304: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8C308: 4BFF5451  bl 0x82e81758
	ctx.lr = 0x82E8C30C;
	sub_82E81758(ctx, base);
	// 82E8C30C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E8C310: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E8C314: 419AFF50  beq cr6, 0x82e8c264
	if ctx.cr[6].eq {
	pc = 0x82E8C264; continue 'dispatch;
	}
	// 82E8C318: 48000030  b 0x82e8c348
	pc = 0x82E8C348; continue 'dispatch;
            }
            0x82E8C31C => {
    //   block [0x82E8C31C..0x82E8C338)
	// 82E8C31C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8C320: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8C324: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8C328: 4BFF59C1  bl 0x82e81ce8
	ctx.lr = 0x82E8C32C;
	sub_82E81CE8(ctx, base);
	// 82E8C32C: 897F0010  lbz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E8C330: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E8C334: 409A0014  bne cr6, 0x82e8c348
	if !ctx.cr[6].eq {
	pc = 0x82E8C348; continue 'dispatch;
	}
	pc = 0x82E8C338; continue 'dispatch;
            }
            0x82E8C338 => {
    //   block [0x82E8C338..0x82E8C348)
	// 82E8C338: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8C33C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8C340: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8C344: 4BFF572D  bl 0x82e81a70
	ctx.lr = 0x82E8C348;
	sub_82E81A70(ctx, base);
	pc = 0x82E8C348; continue 'dispatch;
            }
            0x82E8C348 => {
    //   block [0x82E8C348..0x82E8C350)
	// 82E8C348: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E8C34C: 4BE1D10C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8C350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8C350 size=280
    let mut pc: u32 = 0x82E8C350;
    'dispatch: loop {
        match pc {
            0x82E8C350 => {
    //   block [0x82E8C350..0x82E8C37C)
	// 82E8C350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8C354: 4BE1D0B5  bl 0x82ca9408
	ctx.lr = 0x82E8C358;
	sub_82CA93D0(ctx, base);
	// 82E8C358: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8C35C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8C360: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8C364: 4B3D4655  bl 0x822609b8
	ctx.lr = 0x82E8C368;
	sub_822609B8(ctx, base);
	// 82E8C368: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8C36C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8C370: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E8C374: 4BFF692D  bl 0x82e82ca0
	ctx.lr = 0x82E8C378;
	sub_82E82CA0(ctx, base);
	// 82E8C378: 4800009C  b 0x82e8c414
	pc = 0x82E8C414; continue 'dispatch;
            }
            0x82E8C37C => {
    //   block [0x82E8C37C..0x82E8C3DC)
	// 82E8C37C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8C380: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8C384: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8C388: 4BFF6829  bl 0x82e82bb0
	ctx.lr = 0x82E8C38C;
	sub_82E82BB0(ctx, base);
	// 82E8C38C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8C390: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8C394: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E8C398: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8C39C: 4E800421  bctrl
	ctx.lr = 0x82E8C3A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8C3A0: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82E8C3A4: 41820038  beq 0x82e8c3dc
	if ctx.cr[0].eq {
	pc = 0x82E8C3DC; continue 'dispatch;
	}
	// 82E8C3A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8C3AC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E8C3B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8C3B4: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82E8C3B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8C3BC: 4E800421  bctrl
	ctx.lr = 0x82E8C3C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8C3C0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8C3C4: 41820070  beq 0x82e8c434
	if ctx.cr[0].eq {
	pc = 0x82E8C434; continue 'dispatch;
	}
	// 82E8C3C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8C3CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8C3D0: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E8C3D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8C3D8: 4E800421  bctrl
	ctx.lr = 0x82E8C3DC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8C3DC => {
    //   block [0x82E8C3DC..0x82E8C408)
	// 82E8C3DC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E8C3E0: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8C3E4: 4BFFF8F5  bl 0x82e8bcd8
	ctx.lr = 0x82E8C3E8;
	sub_82E8BCD8(ctx, base);
	// 82E8C3E8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8C3EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8C3F0: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8C3F4: 4BFF59B5  bl 0x82e81da8
	ctx.lr = 0x82E8C3F8;
	sub_82E81DA8(ctx, base);
	// 82E8C3F8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82E8C3FC: 409A000C  bne cr6, 0x82e8c408
	if !ctx.cr[6].eq {
	pc = 0x82E8C408; continue 'dispatch;
	}
	// 82E8C400: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E8C404: 997F0010  stb r11, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u8 ) };
	pc = 0x82E8C408; continue 'dispatch;
            }
            0x82E8C408 => {
    //   block [0x82E8C408..0x82E8C414)
	// 82E8C408: 897F0010  lbz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E8C40C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E8C410: 419A0040  beq cr6, 0x82e8c450
	if ctx.cr[6].eq {
	pc = 0x82E8C450; continue 'dispatch;
	}
	pc = 0x82E8C414; continue 'dispatch;
            }
            0x82E8C414 => {
    //   block [0x82E8C414..0x82E8C434)
	// 82E8C414: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8C418: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8C41C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8C420: 4BFF5451  bl 0x82e81870
	ctx.lr = 0x82E8C424;
	sub_82E81870(ctx, base);
	// 82E8C424: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E8C428: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E8C42C: 419AFF50  beq cr6, 0x82e8c37c
	if ctx.cr[6].eq {
	pc = 0x82E8C37C; continue 'dispatch;
	}
	// 82E8C430: 48000030  b 0x82e8c460
	pc = 0x82E8C460; continue 'dispatch;
            }
            0x82E8C434 => {
    //   block [0x82E8C434..0x82E8C450)
	// 82E8C434: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8C438: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8C43C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8C440: 4BFF5969  bl 0x82e81da8
	ctx.lr = 0x82E8C444;
	sub_82E81DA8(ctx, base);
	// 82E8C444: 897F0010  lbz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E8C448: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E8C44C: 409A0014  bne cr6, 0x82e8c460
	if !ctx.cr[6].eq {
	pc = 0x82E8C460; continue 'dispatch;
	}
	pc = 0x82E8C450; continue 'dispatch;
            }
            0x82E8C450 => {
    //   block [0x82E8C450..0x82E8C460)
	// 82E8C450: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8C454: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8C458: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8C45C: 4BFF66B5  bl 0x82e82b10
	ctx.lr = 0x82E8C460;
	sub_82E82B10(ctx, base);
	pc = 0x82E8C460; continue 'dispatch;
            }
            0x82E8C460 => {
    //   block [0x82E8C460..0x82E8C468)
	// 82E8C460: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E8C464: 4BE1CFF4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8C468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8C468 size=256
    let mut pc: u32 = 0x82E8C468;
    'dispatch: loop {
        match pc {
            0x82E8C468 => {
    //   block [0x82E8C468..0x82E8C4A8)
	// 82E8C468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8C46C: 4BE1CFA1  bl 0x82ca940c
	ctx.lr = 0x82E8C470;
	sub_82CA93D0(ctx, base);
	// 82E8C470: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8C474: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E8C478: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E8C47C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E8C480: 419A0030  beq cr6, 0x82e8c4b0
	if ctx.cr[6].eq {
	pc = 0x82E8C4B0; continue 'dispatch;
	}
	// 82E8C484: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8C488: 4832FBD9  bl 0x831bc060
	ctx.lr = 0x82E8C48C;
	sub_831BC060(ctx, base);
	// 82E8C48C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8C490: 41820020  beq 0x82e8c4b0
	if ctx.cr[0].eq {
	pc = 0x82E8C4B0; continue 'dispatch;
	}
	// 82E8C494: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8C498: 4832FBC9  bl 0x831bc060
	ctx.lr = 0x82E8C49C;
	sub_831BC060(ctx, base);
	// 82E8C49C: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8C4A0: 2B0B005F  cmplwi cr6, r11, 0x5f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 95 as u32, &mut ctx.xer);
	// 82E8C4A4: 409A000C  bne cr6, 0x82e8c4b0
	if !ctx.cr[6].eq {
	pc = 0x82E8C4B0; continue 'dispatch;
	}
	pc = 0x82E8C4A8; continue 'dispatch;
            }
            0x82E8C4A8 => {
    //   block [0x82E8C4A8..0x82E8C4B0)
	// 82E8C4A8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E8C4AC: 480000B4  b 0x82e8c560
	pc = 0x82E8C560; continue 'dispatch;
            }
            0x82E8C4B0 => {
    //   block [0x82E8C4B0..0x82E8C518)
	// 82E8C4B0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8C4B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8C4B8: 3BCB9820  addi r30, r11, -0x67e0
	ctx.r[30].s64 = ctx.r[11].s64 + -26592;
	// 82E8C4BC: 4832FBA5  bl 0x831bc060
	ctx.lr = 0x82E8C4C0;
	sub_831BC060(ctx, base);
	// 82E8C4C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8C4C4: 4BE2068D  bl 0x82cacb50
	ctx.lr = 0x82E8C4C8;
	sub_82CACB50(ctx, base);
	// 82E8C4C8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8C4CC: 4182FFDC  beq 0x82e8c4a8
	if ctx.cr[0].eq {
	pc = 0x82E8C4A8; continue 'dispatch;
	}
	// 82E8C4D0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8C4D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8C4D8: 3BCB9810  addi r30, r11, -0x67f0
	ctx.r[30].s64 = ctx.r[11].s64 + -26608;
	// 82E8C4DC: 4832FB85  bl 0x831bc060
	ctx.lr = 0x82E8C4E0;
	sub_831BC060(ctx, base);
	// 82E8C4E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8C4E4: 4BE2066D  bl 0x82cacb50
	ctx.lr = 0x82E8C4E8;
	sub_82CACB50(ctx, base);
	// 82E8C4E8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8C4EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8C4F0: 40820028  bne 0x82e8c518
	if !ctx.cr[0].eq {
	pc = 0x82E8C518; continue 'dispatch;
	}
	// 82E8C4F4: 4BA81815  bl 0x8290dd08
	ctx.lr = 0x82E8C4F8;
	sub_8290DD08(ctx, base);
	// 82E8C4F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8C4FC: 4B3D44BD  bl 0x822609b8
	ctx.lr = 0x82E8C500;
	sub_822609B8(ctx, base);
	// 82E8C500: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E8C504: 4BFF4C65  bl 0x82e81168
	ctx.lr = 0x82E8C508;
	sub_82E81168(ctx, base);
	// 82E8C508: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E8C50C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E8C510: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E8C514: 4800004C  b 0x82e8c560
	pc = 0x82E8C560; continue 'dispatch;
            }
            0x82E8C518 => {
    //   block [0x82E8C518..0x82E8C55C)
	// 82E8C518: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8C51C: 3BCB9800  addi r30, r11, -0x6800
	ctx.r[30].s64 = ctx.r[11].s64 + -26624;
	// 82E8C520: 4832FB41  bl 0x831bc060
	ctx.lr = 0x82E8C524;
	sub_831BC060(ctx, base);
	// 82E8C524: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8C528: 4BE20629  bl 0x82cacb50
	ctx.lr = 0x82E8C52C;
	sub_82CACB50(ctx, base);
	// 82E8C52C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8C530: 4082002C  bne 0x82e8c55c
	if !ctx.cr[0].eq {
	pc = 0x82E8C55C; continue 'dispatch;
	}
	// 82E8C534: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8C538: 4BA817D1  bl 0x8290dd08
	ctx.lr = 0x82E8C53C;
	sub_8290DD08(ctx, base);
	// 82E8C53C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8C540: 4B3D4479  bl 0x822609b8
	ctx.lr = 0x82E8C544;
	sub_822609B8(ctx, base);
	// 82E8C544: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E8C548: 4BFF4CF1  bl 0x82e81238
	ctx.lr = 0x82E8C54C;
	sub_82E81238(ctx, base);
	// 82E8C54C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E8C550: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E8C554: 917D000C  stw r11, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82E8C558: 48000008  b 0x82e8c560
	pc = 0x82E8C560; continue 'dispatch;
            }
            0x82E8C55C => {
    //   block [0x82E8C55C..0x82E8C560)
	// 82E8C55C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E8C560; continue 'dispatch;
            }
            0x82E8C560 => {
    //   block [0x82E8C560..0x82E8C568)
	// 82E8C560: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8C564: 4BE1CEF8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8C568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8C568 size=116
    let mut pc: u32 = 0x82E8C568;
    'dispatch: loop {
        match pc {
            0x82E8C568 => {
    //   block [0x82E8C568..0x82E8C5B0)
	// 82E8C568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8C56C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8C570: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8C574: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8C578: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82E8C57C: 816A2A2C  lwz r11, 0x2a2c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10796 as u32) ) } as u64;
	// 82E8C580: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82E8C584: 3D208334  lis r9, -0x7ccc
	ctx.r[9].s64 = -2093744128;
	// 82E8C588: 3BE92628  addi r31, r9, 0x2628
	ctx.r[31].s64 = ctx.r[9].s64 + 9768;
	// 82E8C58C: 40820038  bne 0x82e8c5c4
	if !ctx.cr[0].eq {
	pc = 0x82E8C5C4; continue 'dispatch;
	}
	// 82E8C590: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82E8C594: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82E8C598: 8909DCB8  lbz r8, -0x2348(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-9032 as u32) ) } as u64;
	// 82E8C59C: 916A2A2C  stw r11, 0x2a2c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(10796 as u32), ctx.r[11].u32 ) };
	// 82E8C5A0: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8C5A4: 4182000C  beq 0x82e8c5b0
	if ctx.cr[0].eq {
	pc = 0x82E8C5B0; continue 'dispatch;
	}
	// 82E8C5A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8C5AC: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	pc = 0x82E8C5B0; continue 'dispatch;
            }
            0x82E8C5B0 => {
    //   block [0x82E8C5B0..0x82E8C5C4)
	// 82E8C5B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8C5B4: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82E8C5B8: 386A84D8  addi r3, r10, -0x7b28
	ctx.r[3].s64 = ctx.r[10].s64 + -31528;
	// 82E8C5BC: 9969DCB8  stb r11, -0x2348(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-9032 as u32), ctx.r[11].u8 ) };
	// 82E8C5C0: 4BE1D961  bl 0x82ca9f20
	ctx.lr = 0x82E8C5C4;
	sub_82CA9F20(ctx, base);
	pc = 0x82E8C5C4; continue 'dispatch;
            }
            0x82E8C5C4 => {
    //   block [0x82E8C5C4..0x82E8C5DC)
	// 82E8C5C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8C5C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8C5CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8C5D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8C5D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8C5D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8C5E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8C5E0 size=200
    let mut pc: u32 = 0x82E8C5E0;
    'dispatch: loop {
        match pc {
            0x82E8C5E0 => {
    //   block [0x82E8C5E0..0x82E8C614)
	// 82E8C5E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8C5E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8C5E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8C5EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8C5F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8C5F4: 4BFFFF75  bl 0x82e8c568
	ctx.lr = 0x82E8C5F8;
	sub_82E8C568(ctx, base);
	// 82E8C5F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E8C5FC: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82E8C600: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E8C604: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E8C608: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8C60C: 40810054  ble 0x82e8c660
	if !ctx.cr[0].gt {
	pc = 0x82E8C660; continue 'dispatch;
	}
	// 82E8C610: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82E8C614; continue 'dispatch;
            }
            0x82E8C614 => {
    //   block [0x82E8C614..0x82E8C620)
	// 82E8C614: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8C618: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82E8C61C: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	pc = 0x82E8C620; continue 'dispatch;
            }
            0x82E8C620 => {
    //   block [0x82E8C620..0x82E8C644)
	// 82E8C620: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8C624: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8C628: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8C62C: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82E8C630: 41820014  beq 0x82e8c644
	if ctx.cr[0].eq {
	pc = 0x82E8C644; continue 'dispatch;
	}
	// 82E8C634: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E8C638: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82E8C63C: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82E8C640: 419AFFE0  beq cr6, 0x82e8c620
	if ctx.cr[6].eq {
	pc = 0x82E8C620; continue 'dispatch;
	}
	pc = 0x82E8C644; continue 'dispatch;
            }
            0x82E8C644 => {
    //   block [0x82E8C644..0x82E8C660)
	// 82E8C644: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8C648: 41820028  beq 0x82e8c670
	if ctx.cr[0].eq {
	pc = 0x82E8C670; continue 'dispatch;
	}
	// 82E8C64C: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E8C650: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82E8C654: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82E8C658: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82E8C65C: 4198FFB8  blt cr6, 0x82e8c614
	if ctx.cr[6].lt {
	pc = 0x82E8C614; continue 'dispatch;
	}
	pc = 0x82E8C660; continue 'dispatch;
            }
            0x82E8C660 => {
    //   block [0x82E8C660..0x82E8C670)
	// 82E8C660: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82E8C664: 409A0018  bne cr6, 0x82e8c67c
	if !ctx.cr[6].eq {
	pc = 0x82E8C67C; continue 'dispatch;
	}
	// 82E8C668: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8C66C: 48000028  b 0x82e8c694
	pc = 0x82E8C694; continue 'dispatch;
            }
            0x82E8C670 => {
    //   block [0x82E8C670..0x82E8C67C)
	// 82E8C670: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8C674: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82E8C678: 48000018  b 0x82e8c690
	pc = 0x82E8C690; continue 'dispatch;
            }
            0x82E8C67C => {
    //   block [0x82E8C67C..0x82E8C690)
	// 82E8C67C: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8C680: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82E8C684: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E8C688: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E8C68C: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	pc = 0x82E8C690; continue 'dispatch;
            }
            0x82E8C690 => {
    //   block [0x82E8C690..0x82E8C694)
	// 82E8C690: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82E8C694; continue 'dispatch;
            }
            0x82E8C694 => {
    //   block [0x82E8C694..0x82E8C6A8)
	// 82E8C694: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8C698: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8C69C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8C6A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8C6A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8C6A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8C6A8 size=196
    let mut pc: u32 = 0x82E8C6A8;
    'dispatch: loop {
        match pc {
            0x82E8C6A8 => {
    //   block [0x82E8C6A8..0x82E8C6E0)
	// 82E8C6A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8C6AC: 4BE1CD59  bl 0x82ca9404
	ctx.lr = 0x82E8C6B0;
	sub_82CA93D0(ctx, base);
	// 82E8C6B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8C6B4: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82E8C6B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8C6BC: 392B2390  addi r9, r11, 0x2390
	ctx.r[9].s64 = ctx.r[11].s64 + 9104;
	// 82E8C6C0: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82E8C6C4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82E8C6C8: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82E8C6CC: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82E8C6D0: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82E8C6D4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E8C6D8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82E8C6DC: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	pc = 0x82E8C6E0; continue 'dispatch;
            }
            0x82E8C6E0 => {
    //   block [0x82E8C6E0..0x82E8C70C)
	// 82E8C6E0: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8C6E4: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8C6E8: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82E8C6EC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E8C6F0: 4082FFF0  bne 0x82e8c6e0
	if !ctx.cr[0].eq {
	pc = 0x82E8C6E0; continue 'dispatch;
	}
	// 82E8C6F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8C6F8: 4BFFFEE9  bl 0x82e8c5e0
	ctx.lr = 0x82E8C6FC;
	sub_82E8C5E0(ctx, base);
	// 82E8C6FC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8C700: 4082000C  bne 0x82e8c70c
	if !ctx.cr[0].eq {
	pc = 0x82E8C70C; continue 'dispatch;
	}
	// 82E8C704: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82E8C708: 48000010  b 0x82e8c718
	pc = 0x82E8C718; continue 'dispatch;
            }
            0x82E8C70C => {
    //   block [0x82E8C70C..0x82E8C718)
	// 82E8C70C: 4BFFFE5D  bl 0x82e8c568
	ctx.lr = 0x82E8C710;
	sub_82E8C568(ctx, base);
	// 82E8C710: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E8C714: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82E8C718; continue 'dispatch;
            }
            0x82E8C718 => {
    //   block [0x82E8C718..0x82E8C73C)
	// 82E8C718: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E8C71C: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82E8C720: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82E8C724: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E8C728: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82E8C72C: 409A0010  bne cr6, 0x82e8c73c
	if !ctx.cr[6].eq {
	pc = 0x82E8C73C; continue 'dispatch;
	}
	// 82E8C730: 4BFF3329  bl 0x82e7fa58
	ctx.lr = 0x82E8C734;
	sub_82E7FA58(ctx, base);
	// 82E8C734: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82E8C738: 4800000C  b 0x82e8c744
	pc = 0x82E8C744; continue 'dispatch;
            }
            0x82E8C73C => {
    //   block [0x82E8C73C..0x82E8C744)
	// 82E8C73C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8C740: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	pc = 0x82E8C744; continue 'dispatch;
            }
            0x82E8C744 => {
    //   block [0x82E8C744..0x82E8C760)
	// 82E8C744: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8C748: 41820018  beq 0x82e8c760
	if ctx.cr[0].eq {
	pc = 0x82E8C760; continue 'dispatch;
	}
	// 82E8C74C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E8C750: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82E8C754: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82E8C758: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82E8C75C: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	pc = 0x82E8C760; continue 'dispatch;
            }
            0x82E8C760 => {
    //   block [0x82E8C760..0x82E8C76C)
	// 82E8C760: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8C764: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E8C768: 4BE1CCEC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8C770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8C770 size=68
    let mut pc: u32 = 0x82E8C770;
    'dispatch: loop {
        match pc {
            0x82E8C770 => {
    //   block [0x82E8C770..0x82E8C7B4)
	// 82E8C770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8C774: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8C778: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8C77C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8C780: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82E8C784: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82E8C788: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8C78C: 4BFFFF1D  bl 0x82e8c6a8
	ctx.lr = 0x82E8C790;
	sub_82E8C6A8(ctx, base);
	// 82E8C790: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8C794: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8C798: 396B9830  addi r11, r11, -0x67d0
	ctx.r[11].s64 = ctx.r[11].s64 + -26576;
	// 82E8C79C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E8C7A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8C7A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8C7A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8C7AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8C7B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8C7B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8C7B8 size=304
    let mut pc: u32 = 0x82E8C7B8;
    'dispatch: loop {
        match pc {
            0x82E8C7B8 => {
    //   block [0x82E8C7B8..0x82E8C7E0)
	// 82E8C7B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8C7BC: 4BE1CC4D  bl 0x82ca9408
	ctx.lr = 0x82E8C7C0;
	sub_82CA93D0(ctx, base);
	// 82E8C7C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8C7C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8C7C8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82E8C7CC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E8C7D0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8C7D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8C7D8: 40990038  ble cr6, 0x82e8c810
	if !ctx.cr[6].gt {
	pc = 0x82E8C810; continue 'dispatch;
	}
	// 82E8C7DC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82E8C7E0; continue 'dispatch;
            }
            0x82E8C7E0 => {
    //   block [0x82E8C7E0..0x82E8C810)
	// 82E8C7E0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8C7E4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E8C7E8: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82E8C7EC: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82E8C7F0: 4BE20361  bl 0x82cacb50
	ctx.lr = 0x82E8C7F4;
	sub_82CACB50(ctx, base);
	// 82E8C7F4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8C7F8: 41820024  beq 0x82e8c81c
	if ctx.cr[0].eq {
	pc = 0x82E8C81C; continue 'dispatch;
	}
	// 82E8C7FC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8C800: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82E8C804: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82E8C808: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8C80C: 4198FFD4  blt cr6, 0x82e8c7e0
	if ctx.cr[6].lt {
	pc = 0x82E8C7E0; continue 'dispatch;
	}
	pc = 0x82E8C810; continue 'dispatch;
            }
            0x82E8C810 => {
    //   block [0x82E8C810..0x82E8C814)
	// 82E8C810: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E8C814; continue 'dispatch;
            }
            0x82E8C814 => {
    //   block [0x82E8C814..0x82E8C81C)
	// 82E8C814: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E8C818: 4BE1CC40  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82E8C81C => {
    //   block [0x82E8C81C..0x82E8C874)
	// 82E8C81C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8C820: 57BE103A  slwi r30, r29, 2
	ctx.r[30].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82E8C824: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82E8C828: 896B0088  lbz r11, 0x88(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
	// 82E8C82C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8C830: 41820044  beq 0x82e8c874
	if ctx.cr[0].eq {
	pc = 0x82E8C874; continue 'dispatch;
	}
	// 82E8C834: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8C838: 388B5E98  addi r4, r11, 0x5e98
	ctx.r[4].s64 = ctx.r[11].s64 + 24216;
	// 82E8C83C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8C840: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E8C844: 4B3DB3DD  bl 0x82267c20
	ctx.lr = 0x82E8C848;
	sub_82267C20(ctx, base);
	// 82E8C848: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8C84C: 41820028  beq 0x82e8c874
	if ctx.cr[0].eq {
	pc = 0x82E8C874; continue 'dispatch;
	}
	// 82E8C850: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8C854: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82E8C858: 808B0084  lwz r4, 0x84(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 82E8C85C: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8C860: 41820014  beq 0x82e8c874
	if ctx.cr[0].eq {
	pc = 0x82E8C874; continue 'dispatch;
	}
	// 82E8C864: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8C868: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E8C86C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8C870: 4E800421  bctrl
	ctx.lr = 0x82E8C874;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8C874 => {
    //   block [0x82E8C874..0x82E8C8A4)
	// 82E8C874: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8C878: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82E8C87C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E8C880: 419A0024  beq cr6, 0x82e8c8a4
	if ctx.cr[6].eq {
	pc = 0x82E8C8A4; continue 'dispatch;
	}
	// 82E8C884: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82E8C888: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8C88C: 41820018  beq 0x82e8c8a4
	if ctx.cr[0].eq {
	pc = 0x82E8C8A4; continue 'dispatch;
	}
	// 82E8C890: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8C894: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E8C898: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8C89C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8C8A0: 4E800421  bctrl
	ctx.lr = 0x82E8C8A4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8C8A4 => {
    //   block [0x82E8C8A4..0x82E8C8BC)
	// 82E8C8A4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8C8A8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82E8C8AC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8C8B0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E8C8B4: 4098002C  bge cr6, 0x82e8c8e0
	if !ctx.cr[6].lt {
	pc = 0x82E8C8E0; continue 'dispatch;
	}
	// 82E8C8B8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82E8C8BC; continue 'dispatch;
            }
            0x82E8C8BC => {
    //   block [0x82E8C8BC..0x82E8C8E0)
	// 82E8C8BC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8C8C0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82E8C8C4: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E8C8C8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E8C8CC: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8C8D0: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E8C8D4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8C8D8: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E8C8DC: 4198FFE0  blt cr6, 0x82e8c8bc
	if ctx.cr[6].lt {
	pc = 0x82E8C8BC; continue 'dispatch;
	}
	pc = 0x82E8C8E0; continue 'dispatch;
            }
            0x82E8C8E0 => {
    //   block [0x82E8C8E0..0x82E8C8E8)
	// 82E8C8E0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E8C8E4: 4BFFFF30  b 0x82e8c814
	pc = 0x82E8C814; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8C8E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8C8E8 size=60
    let mut pc: u32 = 0x82E8C8E8;
    'dispatch: loop {
        match pc {
            0x82E8C8E8 => {
    //   block [0x82E8C8E8..0x82E8C8FC)
	// 82E8C8E8: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8C8EC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E8C8F0: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8C8F4: 41820028  beq 0x82e8c91c
	if ctx.cr[0].eq {
	pc = 0x82E8C91C; continue 'dispatch;
	}
	// 82E8C8F8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82E8C8FC; continue 'dispatch;
            }
            0x82E8C8FC => {
    //   block [0x82E8C8FC..0x82E8C91C)
	// 82E8C8FC: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8C900: 81080084  lwz r8, 0x84(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(132 as u32) ) } as u64;
	// 82E8C904: 7F082040  cmplw cr6, r8, r4
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82E8C908: 419A001C  beq cr6, 0x82e8c924
	if ctx.cr[6].eq {
		sub_82E8C924(ctx, base);
		return;
	}
	// 82E8C90C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E8C910: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E8C914: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E8C918: 4198FFE4  blt cr6, 0x82e8c8fc
	if ctx.cr[6].lt {
	pc = 0x82E8C8FC; continue 'dispatch;
	}
	pc = 0x82E8C91C; continue 'dispatch;
            }
            0x82E8C91C => {
    //   block [0x82E8C91C..0x82E8C924)
	// 82E8C91C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8C920: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8C924(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8C924 size=8
    let mut pc: u32 = 0x82E8C924;
    'dispatch: loop {
        match pc {
            0x82E8C924 => {
    //   block [0x82E8C924..0x82E8C92C)
	// 82E8C924: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E8C928: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8C930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8C930 size=104
    let mut pc: u32 = 0x82E8C930;
    'dispatch: loop {
        match pc {
            0x82E8C930 => {
    //   block [0x82E8C930..0x82E8C998)
	// 82E8C930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8C934: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8C938: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8C93C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8C940: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8C944: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82E8C948: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8C94C: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 82E8C950: 394A9838  addi r10, r10, -0x67c8
	ctx.r[10].s64 = ctx.r[10].s64 + -26568;
	// 82E8C954: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E8C958: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 82E8C95C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82E8C960: 98DF0088  stb r6, 0x88(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[6].u8 ) };
	// 82E8C964: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82E8C968: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E8C96C: 93DF010C  stw r30, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[30].u32 ) };
	// 82E8C970: 98FF0110  stb r7, 0x110(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[7].u8 ) };
	// 82E8C974: 4B440735  bl 0x822cd0a8
	ctx.lr = 0x82E8C978;
	sub_822CD0A8(ctx, base);
	// 82E8C978: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8C97C: 9BDF0083  stb r30, 0x83(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(131 as u32), ctx.r[30].u8 ) };
	// 82E8C980: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8C984: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8C988: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8C98C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8C990: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8C994: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8C998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8C998 size=172
    let mut pc: u32 = 0x82E8C998;
    'dispatch: loop {
        match pc {
            0x82E8C998 => {
    //   block [0x82E8C998..0x82E8C9D4)
	// 82E8C998: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8C99C: 4BE1CA71  bl 0x82ca940c
	ctx.lr = 0x82E8C9A0;
	sub_82CA93D0(ctx, base);
	// 82E8C9A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8C9A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8C9A8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8C9AC: 396B9838  addi r11, r11, -0x67c8
	ctx.r[11].s64 = ctx.r[11].s64 + -26568;
	// 82E8C9B0: 895F0110  lbz r10, 0x110(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82E8C9B4: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8C9B8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E8C9BC: 4182006C  beq 0x82e8ca28
	if ctx.cr[0].eq {
	pc = 0x82E8CA28; continue 'dispatch;
	}
	// 82E8C9C0: 817F010C  lwz r11, 0x10c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) } as u64;
	// 82E8C9C4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E8C9C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8C9CC: 4099003C  ble cr6, 0x82e8ca08
	if !ctx.cr[6].gt {
	pc = 0x82E8CA08; continue 'dispatch;
	}
	// 82E8C9D0: 3BDF008C  addi r30, r31, 0x8c
	ctx.r[30].s64 = ctx.r[31].s64 + 140;
	pc = 0x82E8C9D4; continue 'dispatch;
            }
            0x82E8C9D4 => {
    //   block [0x82E8C9D4..0x82E8C9F4)
	// 82E8C9D4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8C9D8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8C9DC: 41820018  beq 0x82e8c9f4
	if ctx.cr[0].eq {
	pc = 0x82E8C9F4; continue 'dispatch;
	}
	// 82E8C9E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8C9E4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E8C9E8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8C9EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8C9F0: 4E800421  bctrl
	ctx.lr = 0x82E8C9F4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8C9F4 => {
    //   block [0x82E8C9F4..0x82E8CA08)
	// 82E8C9F4: 817F010C  lwz r11, 0x10c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) } as u64;
	// 82E8C9F8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82E8C9FC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82E8CA00: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8CA04: 4198FFD0  blt cr6, 0x82e8c9d4
	if ctx.cr[6].lt {
	pc = 0x82E8C9D4; continue 'dispatch;
	}
	pc = 0x82E8CA08; continue 'dispatch;
            }
            0x82E8CA08 => {
    //   block [0x82E8CA08..0x82E8CA28)
	// 82E8CA08: 807F0084  lwz r3, 0x84(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82E8CA0C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8CA10: 41820018  beq 0x82e8ca28
	if ctx.cr[0].eq {
	pc = 0x82E8CA28; continue 'dispatch;
	}
	// 82E8CA14: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8CA18: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E8CA1C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8CA20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8CA24: 4E800421  bctrl
	ctx.lr = 0x82E8CA28;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8CA28 => {
    //   block [0x82E8CA28..0x82E8CA44)
	// 82E8CA28: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E8CA2C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E8CA30: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82E8CA34: 915F0084  stw r10, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 82E8CA38: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E8CA3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8CA40: 4BE1CA1C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8CA48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8CA48 size=316
    let mut pc: u32 = 0x82E8CA48;
    'dispatch: loop {
        match pc {
            0x82E8CA48 => {
    //   block [0x82E8CA48..0x82E8CA80)
	// 82E8CA48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8CA4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8CA50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8CA54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8CA58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8CA5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8CA60: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E8CA64: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8CA68: 41820018  beq 0x82e8ca80
	if ctx.cr[0].eq {
	pc = 0x82E8CA80; continue 'dispatch;
	}
	// 82E8CA6C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8CA70: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E8CA74: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8CA78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8CA7C: 4E800421  bctrl
	ctx.lr = 0x82E8CA80;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8CA80 => {
    //   block [0x82E8CA80..0x82E8CAA0)
	// 82E8CA80: 807F002C  lwz r3, 0x2c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E8CA84: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8CA88: 41820018  beq 0x82e8caa0
	if ctx.cr[0].eq {
	pc = 0x82E8CAA0; continue 'dispatch;
	}
	// 82E8CA8C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8CA90: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E8CA94: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8CA98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8CA9C: 4E800421  bctrl
	ctx.lr = 0x82E8CAA0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8CAA0 => {
    //   block [0x82E8CAA0..0x82E8CAD8)
	// 82E8CAA0: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E8CAA4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8CAA8: 41820034  beq 0x82e8cadc
	if ctx.cr[0].eq {
	pc = 0x82E8CADC; continue 'dispatch;
	}
	// 82E8CAAC: 814BFFFC  lwz r10, -4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82E8CAB0: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82E8CAB4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E8CAB8: 419A0020  beq cr6, 0x82e8cad8
	if ctx.cr[6].eq {
	pc = 0x82E8CAD8; continue 'dispatch;
	}
	// 82E8CABC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8CAC0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E8CAC4: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82E8CAC8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8CACC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8CAD0: 4E800421  bctrl
	ctx.lr = 0x82E8CAD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8CAD4: 48000008  b 0x82e8cadc
	pc = 0x82E8CADC; continue 'dispatch;
            }
            0x82E8CAD8 => {
    //   block [0x82E8CAD8..0x82E8CADC)
	// 82E8CAD8: 4B9B8CD9  bl 0x828457b0
	ctx.lr = 0x82E8CADC;
	sub_828457B0(ctx, base);
	pc = 0x82E8CADC; continue 'dispatch;
            }
            0x82E8CADC => {
    //   block [0x82E8CADC..0x82E8CB14)
	// 82E8CADC: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82E8CAE0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8CAE4: 41820034  beq 0x82e8cb18
	if ctx.cr[0].eq {
	pc = 0x82E8CB18; continue 'dispatch;
	}
	// 82E8CAE8: 814BFFFC  lwz r10, -4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82E8CAEC: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82E8CAF0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E8CAF4: 419A0020  beq cr6, 0x82e8cb14
	if ctx.cr[6].eq {
	pc = 0x82E8CB14; continue 'dispatch;
	}
	// 82E8CAF8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8CAFC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E8CB00: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82E8CB04: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8CB08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8CB0C: 4E800421  bctrl
	ctx.lr = 0x82E8CB10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8CB10: 48000008  b 0x82e8cb18
	pc = 0x82E8CB18; continue 'dispatch;
            }
            0x82E8CB14 => {
    //   block [0x82E8CB14..0x82E8CB18)
	// 82E8CB14: 4B9B8C9D  bl 0x828457b0
	ctx.lr = 0x82E8CB18;
	sub_828457B0(ctx, base);
	pc = 0x82E8CB18; continue 'dispatch;
            }
            0x82E8CB18 => {
    //   block [0x82E8CB18..0x82E8CB34)
	// 82E8CB18: 807F0038  lwz r3, 0x38(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E8CB1C: 3FC08330  lis r30, -0x7cd0
	ctx.r[30].s64 = -2094006272;
	// 82E8CB20: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8CB24: 41820010  beq 0x82e8cb34
	if ctx.cr[0].eq {
	pc = 0x82E8CB34; continue 'dispatch;
	}
	// 82E8CB28: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E8CB2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8CB30: 4E800421  bctrl
	ctx.lr = 0x82E8CB34;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8CB34 => {
    //   block [0x82E8CB34..0x82E8CB4C)
	// 82E8CB34: 807F003C  lwz r3, 0x3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82E8CB38: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8CB3C: 41820010  beq 0x82e8cb4c
	if ctx.cr[0].eq {
	pc = 0x82E8CB4C; continue 'dispatch;
	}
	// 82E8CB40: 817EDAB4  lwz r11, -0x254c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E8CB44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8CB48: 4E800421  bctrl
	ctx.lr = 0x82E8CB4C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8CB4C => {
    //   block [0x82E8CB4C..0x82E8CB84)
	// 82E8CB4C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8CB50: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82E8CB54: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82E8CB58: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82E8CB5C: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82E8CB60: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82E8CB64: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 82E8CB68: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82E8CB6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8CB70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8CB74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8CB78: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8CB7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8CB80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8CB88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8CB88 size=280
    let mut pc: u32 = 0x82E8CB88;
    'dispatch: loop {
        match pc {
            0x82E8CB88 => {
    //   block [0x82E8CB88..0x82E8CBBC)
	// 82E8CB88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8CB8C: 4BE1C87D  bl 0x82ca9408
	ctx.lr = 0x82E8CB90;
	sub_82CA93D0(ctx, base);
	// 82E8CB90: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8CB94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8CB98: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8CB9C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82E8CBA0: 396B272C  addi r11, r11, 0x272c
	ctx.r[11].s64 = ctx.r[11].s64 + 10028;
	// 82E8CBA4: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82E8CBA8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8CBAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E8CBB0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E8CBB4: 40990054  ble cr6, 0x82e8cc08
	if !ctx.cr[6].gt {
	pc = 0x82E8CC08; continue 'dispatch;
	}
	// 82E8CBB8: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	pc = 0x82E8CBBC; continue 'dispatch;
            }
            0x82E8CBBC => {
    //   block [0x82E8CBBC..0x82E8CBEC)
	// 82E8CBBC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8CBC0: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82E8CBC4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E8CBC8: 419A0024  beq cr6, 0x82e8cbec
	if ctx.cr[6].eq {
	pc = 0x82E8CBEC; continue 'dispatch;
	}
	// 82E8CBCC: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82E8CBD0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8CBD4: 41820018  beq 0x82e8cbec
	if ctx.cr[0].eq {
	pc = 0x82E8CBEC; continue 'dispatch;
	}
	// 82E8CBD8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8CBDC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E8CBE0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8CBE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8CBE8: 4E800421  bctrl
	ctx.lr = 0x82E8CBEC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8CBEC => {
    //   block [0x82E8CBEC..0x82E8CC08)
	// 82E8CBEC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8CBF0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82E8CBF4: 7F8BF12E  stwx r28, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[28].u32) };
	// 82E8CBF8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82E8CBFC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8CC00: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8CC04: 4198FFB8  blt cr6, 0x82e8cbbc
	if ctx.cr[6].lt {
	pc = 0x82E8CBBC; continue 'dispatch;
	}
	pc = 0x82E8CC08; continue 'dispatch;
            }
            0x82E8CC08 => {
    //   block [0x82E8CC08..0x82E8CC3C)
	// 82E8CC08: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E8CC0C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8CC10: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E8CC14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8CC18: 4E800421  bctrl
	ctx.lr = 0x82E8CC1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8CC1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8CC20: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82E8CC24: 4BFFFE25  bl 0x82e8ca48
	ctx.lr = 0x82E8CC28;
	sub_82E8CA48(ctx, base);
	// 82E8CC28: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E8CC2C: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82E8CC30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8CC34: 40990050  ble cr6, 0x82e8cc84
	if !ctx.cr[6].gt {
	pc = 0x82E8CC84; continue 'dispatch;
	}
	// 82E8CC38: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
            }
            0x82E8CC3C => {
    //   block [0x82E8CC3C..0x82E8CC70)
	// 82E8CC3C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E8CC40: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82E8CC44: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8CC48: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E8CC4C: 419A0024  beq cr6, 0x82e8cc70
	if ctx.cr[6].eq {
	pc = 0x82E8CC70; continue 'dispatch;
	}
	// 82E8CC50: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82E8CC54: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8CC58: 41820018  beq 0x82e8cc70
	if ctx.cr[0].eq {
	pc = 0x82E8CC70; continue 'dispatch;
	}
	// 82E8CC5C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8CC60: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E8CC64: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8CC68: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8CC6C: 4E800421  bctrl
	ctx.lr = 0x82E8CC70;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8CC70 => {
    //   block [0x82E8CC70..0x82E8CC84)
	// 82E8CC70: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E8CC74: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82E8CC78: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82E8CC7C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8CC80: 4198FFBC  blt cr6, 0x82e8cc3c
	if ctx.cr[6].lt {
	pc = 0x82E8CC3C; continue 'dispatch;
	}
	pc = 0x82E8CC84; continue 'dispatch;
            }
            0x82E8CC84 => {
    //   block [0x82E8CC84..0x82E8CCA0)
	// 82E8CC84: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 82E8CC88: 48006619  bl 0x82e932a0
	ctx.lr = 0x82E8CC8C;
	sub_82E932A0(ctx, base);
	// 82E8CC8C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E8CC90: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82E8CC94: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E8CC98: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E8CC9C: 4BE1C7BC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8CCA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8CCA0 size=384
    let mut pc: u32 = 0x82E8CCA0;
    'dispatch: loop {
        match pc {
            0x82E8CCA0 => {
    //   block [0x82E8CCA0..0x82E8CCC4)
	// 82E8CCA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8CCA4: 4BE1C761  bl 0x82ca9404
	ctx.lr = 0x82E8CCA8;
	sub_82CA93D0(ctx, base);
	// 82E8CCA8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8CCAC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82E8CCB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8CCB4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82E8CCB8: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82E8CCBC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82E8CCC0: 409A000C  bne cr6, 0x82e8cccc
	if !ctx.cr[6].eq {
	pc = 0x82E8CCCC; continue 'dispatch;
	}
	pc = 0x82E8CCC4; continue 'dispatch;
            }
            0x82E8CCC4 => {
    //   block [0x82E8CCC4..0x82E8CCCC)
	// 82E8CCC4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8CCC8: 48000150  b 0x82e8ce18
	pc = 0x82E8CE18; continue 'dispatch;
            }
            0x82E8CCCC => {
    //   block [0x82E8CCCC..0x82E8CCFC)
	// 82E8CCCC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E8CCD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8CCD4: 4BFEF5F5  bl 0x82e7c2c8
	ctx.lr = 0x82E8CCD8;
	sub_82E7C2C8(ctx, base);
	// 82E8CCD8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8CCDC: 4082FFE8  bne 0x82e8ccc4
	if !ctx.cr[0].eq {
	pc = 0x82E8CCC4; continue 'dispatch;
	}
	// 82E8CCE0: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 82E8CCE4: 4B789C45  bl 0x82616928
	ctx.lr = 0x82E8CCE8;
	sub_82616928(ctx, base);
	// 82E8CCE8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8CCEC: 41820010  beq 0x82e8ccfc
	if ctx.cr[0].eq {
	pc = 0x82E8CCFC; continue 'dispatch;
	}
	// 82E8CCF0: 48003FE1  bl 0x82e90cd0
	ctx.lr = 0x82E8CCF4;
	sub_82E90CD0(ctx, base);
	// 82E8CCF4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E8CCF8: 48000008  b 0x82e8cd00
	pc = 0x82E8CD00; continue 'dispatch;
            }
            0x82E8CCFC => {
    //   block [0x82E8CCFC..0x82E8CD00)
	// 82E8CCFC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82E8CD00; continue 'dispatch;
            }
            0x82E8CD00 => {
    //   block [0x82E8CD00..0x82E8CD3C)
	// 82E8CD00: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8CD04: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8CD08: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8CD0C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8CD10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8CD14: 4E800421  bctrl
	ctx.lr = 0x82E8CD18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8CD18: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8CD1C: 40820020  bne 0x82e8cd3c
	if !ctx.cr[0].eq {
	pc = 0x82E8CD3C; continue 'dispatch;
	}
	// 82E8CD20: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8CD24: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E8CD28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8CD2C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8CD30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8CD34: 4E800421  bctrl
	ctx.lr = 0x82E8CD38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8CD38: 4BFFFF8C  b 0x82e8ccc4
	pc = 0x82E8CCC4; continue 'dispatch;
            }
            0x82E8CD3C => {
    //   block [0x82E8CD3C..0x82E8CD6C)
	// 82E8CD3C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8CD40: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8CD44: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8CD48: 409A0078  bne cr6, 0x82e8cdc0
	if !ctx.cr[6].eq {
	pc = 0x82E8CDC0; continue 'dispatch;
	}
	// 82E8CD4C: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E8CD50: 3D403FFF  lis r10, 0x3fff
	ctx.r[10].s64 = 1073676288;
	// 82E8CD54: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82E8CD58: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 82E8CD5C: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82E8CD60: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E8CD64: 40990008  ble cr6, 0x82e8cd6c
	if !ctx.cr[6].gt {
	pc = 0x82E8CD6C; continue 'dispatch;
	}
	// 82E8CD68: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82E8CD6C; continue 'dispatch;
            }
            0x82E8CD6C => {
    //   block [0x82E8CD6C..0x82E8CD88)
	// 82E8CD6C: 4B789BBD  bl 0x82616928
	ctx.lr = 0x82E8CD70;
	sub_82616928(ctx, base);
	// 82E8CD70: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8CD74: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E8CD78: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E8CD7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8CD80: 40990028  ble cr6, 0x82e8cda8
	if !ctx.cr[6].gt {
	pc = 0x82E8CDA8; continue 'dispatch;
	}
	// 82E8CD84: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82E8CD88; continue 'dispatch;
            }
            0x82E8CD88 => {
    //   block [0x82E8CD88..0x82E8CDA8)
	// 82E8CD88: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8CD8C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E8CD90: 7D2B482E  lwzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82E8CD94: 7D2BF12E  stwx r9, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[9].u32) };
	// 82E8CD98: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E8CD9C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8CDA0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E8CDA4: 4198FFE4  blt cr6, 0x82e8cd88
	if ctx.cr[6].lt {
	pc = 0x82E8CD88; continue 'dispatch;
	}
	pc = 0x82E8CDA8; continue 'dispatch;
            }
            0x82E8CDA8 => {
    //   block [0x82E8CDA8..0x82E8CDC0)
	// 82E8CDA8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E8CDAC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8CDB0: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E8CDB4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8CDB8: 4E800421  bctrl
	ctx.lr = 0x82E8CDBC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8CDBC: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
            }
            0x82E8CDC0 => {
    //   block [0x82E8CDC0..0x82E8CDE8)
	// 82E8CDC0: 38600114  li r3, 0x114
	ctx.r[3].s64 = 276;
	// 82E8CDC4: 4B789B65  bl 0x82616928
	ctx.lr = 0x82E8CDC8;
	sub_82616928(ctx, base);
	// 82E8CDC8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8CDCC: 4182001C  beq 0x82e8cde8
	if ctx.cr[0].eq {
	pc = 0x82E8CDE8; continue 'dispatch;
	}
	// 82E8CDD0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82E8CDD4: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82E8CDD8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E8CDDC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E8CDE0: 4BFFFB51  bl 0x82e8c930
	ctx.lr = 0x82E8CDE4;
	sub_82E8C930(ctx, base);
	// 82E8CDE4: 48000008  b 0x82e8cdec
	pc = 0x82E8CDEC; continue 'dispatch;
            }
            0x82E8CDE8 => {
    //   block [0x82E8CDE8..0x82E8CDEC)
	// 82E8CDE8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E8CDEC; continue 'dispatch;
            }
            0x82E8CDEC => {
    //   block [0x82E8CDEC..0x82E8CE18)
	// 82E8CDEC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8CDF0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8CDF4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E8CDF8: 7C6B512E  stwx r3, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[3].u32) };
	// 82E8CDFC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8CE00: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8CE04: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E8CE08: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8CE0C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82E8CE10: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E8CE14: 806AFFFC  lwz r3, -4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) } as u64;
	pc = 0x82E8CE18; continue 'dispatch;
            }
            0x82E8CE18 => {
    //   block [0x82E8CE18..0x82E8CE20)
	// 82E8CE18: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E8CE1C: 4BE1C638  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8CE20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8CE20 size=368
    let mut pc: u32 = 0x82E8CE20;
    'dispatch: loop {
        match pc {
            0x82E8CE20 => {
    //   block [0x82E8CE20..0x82E8CE48)
	// 82E8CE20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8CE24: 4BE1C5DD  bl 0x82ca9400
	ctx.lr = 0x82E8CE28;
	sub_82CA93D0(ctx, base);
	// 82E8CE28: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8CE2C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E8CE30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8CE34: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82E8CE38: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82E8CE3C: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82E8CE40: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82E8CE44: 409A000C  bne cr6, 0x82e8ce50
	if !ctx.cr[6].eq {
	pc = 0x82E8CE50; continue 'dispatch;
	}
	pc = 0x82E8CE48; continue 'dispatch;
            }
            0x82E8CE48 => {
    //   block [0x82E8CE48..0x82E8CE50)
	// 82E8CE48: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8CE4C: 4800013C  b 0x82e8cf88
	pc = 0x82E8CF88; continue 'dispatch;
            }
            0x82E8CE50 => {
    //   block [0x82E8CE50..0x82E8CE9C)
	// 82E8CE50: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82E8CE54: 419AFFF4  beq cr6, 0x82e8ce48
	if ctx.cr[6].eq {
	pc = 0x82E8CE48; continue 'dispatch;
	}
	// 82E8CE58: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E8CE5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8CE60: 4BFEF469  bl 0x82e7c2c8
	ctx.lr = 0x82E8CE64;
	sub_82E7C2C8(ctx, base);
	// 82E8CE64: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8CE68: 4082FFE0  bne 0x82e8ce48
	if !ctx.cr[0].eq {
	pc = 0x82E8CE48; continue 'dispatch;
	}
	// 82E8CE6C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8CE70: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8CE74: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8CE78: 409A0078  bne cr6, 0x82e8cef0
	if !ctx.cr[6].eq {
	pc = 0x82E8CEF0; continue 'dispatch;
	}
	// 82E8CE7C: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E8CE80: 3D403FFF  lis r10, 0x3fff
	ctx.r[10].s64 = 1073676288;
	// 82E8CE84: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82E8CE88: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 82E8CE8C: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82E8CE90: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E8CE94: 40990008  ble cr6, 0x82e8ce9c
	if !ctx.cr[6].gt {
	pc = 0x82E8CE9C; continue 'dispatch;
	}
	// 82E8CE98: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82E8CE9C; continue 'dispatch;
            }
            0x82E8CE9C => {
    //   block [0x82E8CE9C..0x82E8CEB8)
	// 82E8CE9C: 4B789A8D  bl 0x82616928
	ctx.lr = 0x82E8CEA0;
	sub_82616928(ctx, base);
	// 82E8CEA0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8CEA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E8CEA8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E8CEAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8CEB0: 40990028  ble cr6, 0x82e8ced8
	if !ctx.cr[6].gt {
	pc = 0x82E8CED8; continue 'dispatch;
	}
	// 82E8CEB4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82E8CEB8; continue 'dispatch;
            }
            0x82E8CEB8 => {
    //   block [0x82E8CEB8..0x82E8CED8)
	// 82E8CEB8: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8CEBC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E8CEC0: 7D29582E  lwzx r9, r9, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82E8CEC4: 7D2BF12E  stwx r9, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[9].u32) };
	// 82E8CEC8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E8CECC: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8CED0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E8CED4: 4198FFE4  blt cr6, 0x82e8ceb8
	if ctx.cr[6].lt {
	pc = 0x82E8CEB8; continue 'dispatch;
	}
	pc = 0x82E8CED8; continue 'dispatch;
            }
            0x82E8CED8 => {
    //   block [0x82E8CED8..0x82E8CEF0)
	// 82E8CED8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E8CEDC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8CEE0: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E8CEE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8CEE8: 4E800421  bctrl
	ctx.lr = 0x82E8CEEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8CEEC: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
            }
            0x82E8CEF0 => {
    //   block [0x82E8CEF0..0x82E8CF18)
	// 82E8CEF0: 38600114  li r3, 0x114
	ctx.r[3].s64 = 276;
	// 82E8CEF4: 4B789A35  bl 0x82616928
	ctx.lr = 0x82E8CEF8;
	sub_82616928(ctx, base);
	// 82E8CEF8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8CEFC: 4182001C  beq 0x82e8cf18
	if ctx.cr[0].eq {
	pc = 0x82E8CF18; continue 'dispatch;
	}
	// 82E8CF00: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82E8CF04: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82E8CF08: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82E8CF0C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E8CF10: 4BFFFA21  bl 0x82e8c930
	ctx.lr = 0x82E8CF14;
	sub_82E8C930(ctx, base);
	// 82E8CF14: 48000008  b 0x82e8cf1c
	pc = 0x82E8CF1C; continue 'dispatch;
            }
            0x82E8CF18 => {
    //   block [0x82E8CF18..0x82E8CF1C)
	// 82E8CF18: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E8CF1C; continue 'dispatch;
            }
            0x82E8CF1C => {
    //   block [0x82E8CF1C..0x82E8CF84)
	// 82E8CF1C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8CF20: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8CF24: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E8CF28: 7C6B512E  stwx r3, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[3].u32) };
	// 82E8CF2C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8CF30: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8CF34: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E8CF38: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8CF3C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82E8CF40: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E8CF44: 816AFFFC  lwz r11, -4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82E8CF48: 896B0088  lbz r11, 0x88(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
	// 82E8CF4C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8CF50: 41820034  beq 0x82e8cf84
	if ctx.cr[0].eq {
	pc = 0x82E8CF84; continue 'dispatch;
	}
	// 82E8CF54: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8CF58: 388B5E98  addi r4, r11, 0x5e98
	ctx.r[4].s64 = ctx.r[11].s64 + 24216;
	// 82E8CF5C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8CF60: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E8CF64: 4B3DACBD  bl 0x82267c20
	ctx.lr = 0x82E8CF68;
	sub_82267C20(ctx, base);
	// 82E8CF68: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8CF6C: 41820018  beq 0x82e8cf84
	if ctx.cr[0].eq {
	pc = 0x82E8CF84; continue 'dispatch;
	}
	// 82E8CF70: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8CF74: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82E8CF78: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E8CF7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8CF80: 4E800421  bctrl
	ctx.lr = 0x82E8CF84;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8CF84 => {
    //   block [0x82E8CF84..0x82E8CF88)
	// 82E8CF84: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82E8CF88; continue 'dispatch;
            }
            0x82E8CF88 => {
    //   block [0x82E8CF88..0x82E8CF90)
	// 82E8CF88: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E8CF8C: 4BE1C4C4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8CF90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8CF90 size=252
    let mut pc: u32 = 0x82E8CF90;
    'dispatch: loop {
        match pc {
            0x82E8CF90 => {
    //   block [0x82E8CF90..0x82E8CFC4)
	// 82E8CF90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8CF94: 4BE1C46D  bl 0x82ca9400
	ctx.lr = 0x82E8CF98;
	sub_82CA93D0(ctx, base);
	// 82E8CF98: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8CF9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E8CFA0: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82E8CFA4: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82E8CFA8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82E8CFAC: 419A00CC  beq cr6, 0x82e8d078
	if ctx.cr[6].eq {
	pc = 0x82E8D078; continue 'dispatch;
	}
	// 82E8CFB0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8CFB4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E8CFB8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8CFBC: 41820030  beq 0x82e8cfec
	if ctx.cr[0].eq {
	pc = 0x82E8CFEC; continue 'dispatch;
	}
	// 82E8CFC0: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82E8CFC4; continue 'dispatch;
            }
            0x82E8CFC4 => {
    //   block [0x82E8CFC4..0x82E8CFE8)
	// 82E8CFC4: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8CFC8: 81080084  lwz r8, 0x84(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(132 as u32) ) } as u64;
	// 82E8CFCC: 7F082040  cmplw cr6, r8, r4
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82E8CFD0: 419A0018  beq cr6, 0x82e8cfe8
	if ctx.cr[6].eq {
	pc = 0x82E8CFE8; continue 'dispatch;
	}
	// 82E8CFD4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E8CFD8: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82E8CFDC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8CFE0: 4198FFE4  blt cr6, 0x82e8cfc4
	if ctx.cr[6].lt {
	pc = 0x82E8CFC4; continue 'dispatch;
	}
	// 82E8CFE4: 48000008  b 0x82e8cfec
	pc = 0x82E8CFEC; continue 'dispatch;
            }
            0x82E8CFE8 => {
    //   block [0x82E8CFE8..0x82E8CFEC)
	// 82E8CFE8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x82E8CFEC; continue 'dispatch;
            }
            0x82E8CFEC => {
    //   block [0x82E8CFEC..0x82E8D00C)
	// 82E8CFEC: 557F103A  slwi r31, r11, 2
	ctx.r[31].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82E8CFF0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8CFF4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82E8CFF8: 7D6BF82E  lwzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82E8CFFC: 816B010C  lwz r11, 0x10c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(268 as u32) ) } as u64;
	// 82E8D000: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8D004: 40990048  ble cr6, 0x82e8d04c
	if !ctx.cr[6].gt {
	pc = 0x82E8D04C; continue 'dispatch;
	}
	// 82E8D008: 3BA0008C  li r29, 0x8c
	ctx.r[29].s64 = 140;
	pc = 0x82E8D00C; continue 'dispatch;
            }
            0x82E8D00C => {
    //   block [0x82E8D00C..0x82E8D04C)
	// 82E8D00C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8D010: 7D6BF82E  lwzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82E8D014: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82E8D018: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8D01C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8D020: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8D024: 4E800421  bctrl
	ctx.lr = 0x82E8D028;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8D028: 7F1B1840  cmplw cr6, r27, r3
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82E8D02C: 419A0058  beq cr6, 0x82e8d084
	if ctx.cr[6].eq {
	pc = 0x82E8D084; continue 'dispatch;
	}
	// 82E8D030: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8D034: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82E8D038: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82E8D03C: 7D6BF82E  lwzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82E8D040: 816B010C  lwz r11, 0x10c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(268 as u32) ) } as u64;
	// 82E8D044: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8D048: 4198FFC4  blt cr6, 0x82e8d00c
	if ctx.cr[6].lt {
	pc = 0x82E8D00C; continue 'dispatch;
	}
            }
            0x82E8D04C => {
    //   block [0x82E8D04C..0x82E8D078)
	// 82E8D04C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8D050: 7D6BF82E  lwzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82E8D054: 814B010C  lwz r10, 0x10c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(268 as u32) ) } as u64;
	// 82E8D058: 394A0023  addi r10, r10, 0x23
	ctx.r[10].s64 = ctx.r[10].s64 + 35;
	// 82E8D05C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8D060: 7F4A592E  stwx r26, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[26].u32) };
	// 82E8D064: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8D068: 7D6BF82E  lwzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82E8D06C: 814B010C  lwz r10, 0x10c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(268 as u32) ) } as u64;
	// 82E8D070: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E8D074: 914B010C  stw r10, 0x10c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(268 as u32), ctx.r[10].u32 ) };
	pc = 0x82E8D078; continue 'dispatch;
            }
            0x82E8D078 => {
    //   block [0x82E8D078..0x82E8D07C)
	// 82E8D078: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82E8D07C; continue 'dispatch;
            }
            0x82E8D07C => {
    //   block [0x82E8D07C..0x82E8D084)
	// 82E8D07C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E8D080: 4BE1C3D0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82E8D084 => {
    //   block [0x82E8D084..0x82E8D08C)
	// 82E8D084: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8D088: 4BFFFFF4  b 0x82e8d07c
	pc = 0x82E8D07C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8D090 size=204
    let mut pc: u32 = 0x82E8D090;
    'dispatch: loop {
        match pc {
            0x82E8D090 => {
    //   block [0x82E8D090..0x82E8D0BC)
	// 82E8D090: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8D094: 4BE1C369  bl 0x82ca93fc
	ctx.lr = 0x82E8D098;
	sub_82CA93D0(ctx, base);
	// 82E8D098: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8D09C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8D0A0: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82E8D0A4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82E8D0A8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82E8D0AC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8D0B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8D0B4: 40990084  ble cr6, 0x82e8d138
	if !ctx.cr[6].gt {
	pc = 0x82E8D138; continue 'dispatch;
	}
	// 82E8D0B8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82E8D0BC; continue 'dispatch;
            }
            0x82E8D0BC => {
    //   block [0x82E8D0BC..0x82E8D0E4)
	// 82E8D0BC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8D0C0: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82E8D0C4: 814B0084  lwz r10, 0x84(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 82E8D0C8: 7F0AC840  cmplw cr6, r10, r25
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82E8D0CC: 409A0058  bne cr6, 0x82e8d124
	if !ctx.cr[6].eq {
	pc = 0x82E8D124; continue 'dispatch;
	}
	// 82E8D0D0: 816B010C  lwz r11, 0x10c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(268 as u32) ) } as u64;
	// 82E8D0D4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82E8D0D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8D0DC: 40990048  ble cr6, 0x82e8d124
	if !ctx.cr[6].gt {
	pc = 0x82E8D124; continue 'dispatch;
	}
	// 82E8D0E0: 3BA0008C  li r29, 0x8c
	ctx.r[29].s64 = 140;
	pc = 0x82E8D0E4; continue 'dispatch;
            }
            0x82E8D0E4 => {
    //   block [0x82E8D0E4..0x82E8D124)
	// 82E8D0E4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8D0E8: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82E8D0EC: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82E8D0F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8D0F4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8D0F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8D0FC: 4E800421  bctrl
	ctx.lr = 0x82E8D100;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8D100: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8D104: 7F1A1840  cmplw cr6, r26, r3
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82E8D108: 419A003C  beq cr6, 0x82e8d144
	if ctx.cr[6].eq {
	pc = 0x82E8D144; continue 'dispatch;
	}
	// 82E8D10C: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82E8D110: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82E8D114: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82E8D118: 816B010C  lwz r11, 0x10c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(268 as u32) ) } as u64;
	// 82E8D11C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8D120: 4198FFC4  blt cr6, 0x82e8d0e4
	if ctx.cr[6].lt {
	pc = 0x82E8D0E4; continue 'dispatch;
	}
            }
            0x82E8D124 => {
    //   block [0x82E8D124..0x82E8D138)
	// 82E8D124: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8D128: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82E8D12C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82E8D130: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8D134: 4198FF88  blt cr6, 0x82e8d0bc
	if ctx.cr[6].lt {
	pc = 0x82E8D0BC; continue 'dispatch;
	}
	pc = 0x82E8D138; continue 'dispatch;
            }
            0x82E8D138 => {
    //   block [0x82E8D138..0x82E8D13C)
	// 82E8D138: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E8D13C; continue 'dispatch;
            }
            0x82E8D13C => {
    //   block [0x82E8D13C..0x82E8D144)
	// 82E8D13C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E8D140: 4BE1C30C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82E8D144 => {
    //   block [0x82E8D144..0x82E8D15C)
	// 82E8D144: 576A103A  slwi r10, r27, 2
	ctx.r[10].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8D148: 393C0023  addi r9, r28, 0x23
	ctx.r[9].s64 = ctx.r[28].s64 + 35;
	// 82E8D14C: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82E8D150: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82E8D154: 7C6B482E  lwzx r3, r11, r9
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82E8D158: 4BFFFFE4  b 0x82e8d13c
	pc = 0x82E8D13C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8D160 size=88
    let mut pc: u32 = 0x82E8D160;
    'dispatch: loop {
        match pc {
            0x82E8D160 => {
    //   block [0x82E8D160..0x82E8D19C)
	// 82E8D160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8D164: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8D168: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8D16C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8D170: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8D174: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8D178: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8D17C: 4BFFF81D  bl 0x82e8c998
	ctx.lr = 0x82E8D180;
	sub_82E8C998(ctx, base);
	// 82E8D180: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8D184: 41820018  beq 0x82e8d19c
	if ctx.cr[0].eq {
	pc = 0x82E8D19C; continue 'dispatch;
	}
	// 82E8D188: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E8D18C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8D190: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E8D194: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8D198: 4E800421  bctrl
	ctx.lr = 0x82E8D19C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8D19C => {
    //   block [0x82E8D19C..0x82E8D1B8)
	// 82E8D19C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8D1A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8D1A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8D1A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8D1AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8D1B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8D1B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D1B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8D1B8 size=120
    let mut pc: u32 = 0x82E8D1B8;
    'dispatch: loop {
        match pc {
            0x82E8D1B8 => {
    //   block [0x82E8D1B8..0x82E8D1E8)
	// 82E8D1B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8D1BC: 4BE1C24D  bl 0x82ca9408
	ctx.lr = 0x82E8D1C0;
	sub_82CA93D0(ctx, base);
	// 82E8D1C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8D1C4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82E8D1C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E8D1CC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82E8D1D0: 419A004C  beq cr6, 0x82e8d21c
	if ctx.cr[6].eq {
	pc = 0x82E8D21C; continue 'dispatch;
	}
	// 82E8D1D4: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E8D1D8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E8D1DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8D1E0: 4099003C  ble cr6, 0x82e8d21c
	if !ctx.cr[6].gt {
	pc = 0x82E8D21C; continue 'dispatch;
	}
	// 82E8D1E4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82E8D1E8; continue 'dispatch;
            }
            0x82E8D1E8 => {
    //   block [0x82E8D1E8..0x82E8D21C)
	// 82E8D1E8: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E8D1EC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E8D1F0: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82E8D1F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8D1F8: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8D1FC: 4BE1F955  bl 0x82cacb50
	ctx.lr = 0x82E8D200;
	sub_82CACB50(ctx, base);
	// 82E8D200: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8D204: 41820024  beq 0x82e8d228
	if ctx.cr[0].eq {
	pc = 0x82E8D228; continue 'dispatch;
	}
	// 82E8D208: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E8D20C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82E8D210: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82E8D214: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8D218: 4198FFD0  blt cr6, 0x82e8d1e8
	if ctx.cr[6].lt {
	pc = 0x82E8D1E8; continue 'dispatch;
	}
	pc = 0x82E8D21C; continue 'dispatch;
            }
            0x82E8D21C => {
    //   block [0x82E8D21C..0x82E8D220)
	// 82E8D21C: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82E8D220; continue 'dispatch;
            }
            0x82E8D220 => {
    //   block [0x82E8D220..0x82E8D228)
	// 82E8D220: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E8D224: 4BE1C234  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82E8D228 => {
    //   block [0x82E8D228..0x82E8D230)
	// 82E8D228: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8D22C: 4BFFFFF4  b 0x82e8d220
	pc = 0x82E8D220; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8D230 size=308
    let mut pc: u32 = 0x82E8D230;
    'dispatch: loop {
        match pc {
            0x82E8D230 => {
    //   block [0x82E8D230..0x82E8D290)
	// 82E8D230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8D234: 4BE1C1D9  bl 0x82ca940c
	ctx.lr = 0x82E8D238;
	sub_82CA93D0(ctx, base);
	// 82E8D238: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8D23C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8D240: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8D244: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E8D248: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8D24C: 396BA2F0  addi r11, r11, -0x5d10
	ctx.r[11].s64 = ctx.r[11].s64 + -23824;
	// 82E8D250: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82E8D254: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82E8D258: 93BF0014  stw r29, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 82E8D25C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E8D260: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82E8D264: 93BF0010  stw r29, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 82E8D268: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82E8D26C: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82E8D270: 419A00E8  beq cr6, 0x82e8d358
	if ctx.cr[6].eq {
	pc = 0x82E8D358; continue 'dispatch;
	}
	// 82E8D274: 3D600CCC  lis r11, 0xccc
	ctx.r[11].s64 = 214695936;
	// 82E8D278: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82E8D27C: 616BCCCC  ori r11, r11, 0xcccc
	ctx.r[11].u64 = ctx.r[11].u64 | 52428;
	// 82E8D280: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8D284: 1D7E0014  mulli r11, r30, 0x14
	ctx.r[11].s32 = ((ctx.r[30].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82E8D288: 40990008  ble cr6, 0x82e8d290
	if !ctx.cr[6].gt {
	pc = 0x82E8D290; continue 'dispatch;
	}
	// 82E8D28C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x82E8D290; continue 'dispatch;
            }
            0x82E8D290 => {
    //   block [0x82E8D290..0x82E8D2A0)
	// 82E8D290: 3940FFFB  li r10, -5
	ctx.r[10].s64 = -5;
	// 82E8D294: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E8D298: 41990008  bgt cr6, 0x82e8d2a0
	if ctx.cr[6].gt {
	pc = 0x82E8D2A0; continue 'dispatch;
	}
	// 82E8D29C: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	pc = 0x82E8D2A0; continue 'dispatch;
            }
            0x82E8D2A0 => {
    //   block [0x82E8D2A0..0x82E8D2C8)
	// 82E8D2A0: 4B789689  bl 0x82616928
	ctx.lr = 0x82E8D2A4;
	sub_82616928(ctx, base);
	// 82E8D2A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8D2A8: 41820044  beq 0x82e8d2ec
	if ctx.cr[0].eq {
	pc = 0x82E8D2EC; continue 'dispatch;
	}
	// 82E8D2AC: 39030004  addi r8, r3, 4
	ctx.r[8].s64 = ctx.r[3].s64 + 4;
	// 82E8D2B0: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82E8D2B4: 355EFFFF  addic. r10, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E8D2B8: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 82E8D2BC: 41800028  blt 0x82e8d2e4
	if ctx.cr[0].lt {
	pc = 0x82E8D2E4; continue 'dispatch;
	}
	// 82E8D2C0: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82E8D2C4: 3929A3A8  addi r9, r9, -0x5c58
	ctx.r[9].s64 = ctx.r[9].s64 + -23640;
	pc = 0x82E8D2C8; continue 'dispatch;
            }
            0x82E8D2C8 => {
    //   block [0x82E8D2C8..0x82E8D2E4)
	// 82E8D2C8: 93AB0008  stw r29, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82E8D2CC: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E8D2D0: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E8D2D4: 93AB000C  stw r29, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82E8D2D8: 9BAB0010  stb r29, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[29].u8 ) };
	// 82E8D2DC: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 82E8D2E0: 4080FFE8  bge 0x82e8d2c8
	if !ctx.cr[0].lt {
	pc = 0x82E8D2C8; continue 'dispatch;
	}
	pc = 0x82E8D2E4; continue 'dispatch;
            }
            0x82E8D2E4 => {
    //   block [0x82E8D2E4..0x82E8D2EC)
	// 82E8D2E4: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 82E8D2E8: 48000008  b 0x82e8d2f0
	pc = 0x82E8D2F0; continue 'dispatch;
            }
            0x82E8D2EC => {
    //   block [0x82E8D2EC..0x82E8D2F0)
	// 82E8D2EC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82E8D2F0; continue 'dispatch;
            }
            0x82E8D2F0 => {
    //   block [0x82E8D2F0..0x82E8D310)
	// 82E8D2F0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E8D2F4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E8D2F8: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82E8D2FC: 93AB0008  stw r29, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82E8D300: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E8D304: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E8D308: 4099003C  ble cr6, 0x82e8d344
	if !ctx.cr[6].gt {
	pc = 0x82E8D344; continue 'dispatch;
	}
	// 82E8D30C: 39600014  li r11, 0x14
	ctx.r[11].s64 = 20;
	pc = 0x82E8D310; continue 'dispatch;
            }
            0x82E8D310 => {
    //   block [0x82E8D310..0x82E8D344)
	// 82E8D310: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8D314: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E8D318: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82E8D31C: 3909FFEC  addi r8, r9, -0x14
	ctx.r[8].s64 = ctx.r[9].s64 + -20;
	// 82E8D320: 91090008  stw r8, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82E8D324: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8D328: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82E8D32C: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 82E8D330: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8D334: 9128000C  stw r9, 0xc(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82E8D338: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E8D33C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E8D340: 4198FFD0  blt cr6, 0x82e8d310
	if ctx.cr[6].lt {
	pc = 0x82E8D310; continue 'dispatch;
	}
	pc = 0x82E8D344; continue 'dispatch;
            }
            0x82E8D344 => {
    //   block [0x82E8D344..0x82E8D358)
	// 82E8D344: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E8D348: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8D34C: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82E8D350: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E8D354: 93ABFFF8  stw r29, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[29].u32 ) };
	pc = 0x82E8D358; continue 'dispatch;
            }
            0x82E8D358 => {
    //   block [0x82E8D358..0x82E8D364)
	// 82E8D358: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8D35C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8D360: 4BE1C0FC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8D368 size=184
    let mut pc: u32 = 0x82E8D368;
    'dispatch: loop {
        match pc {
            0x82E8D368 => {
    //   block [0x82E8D368..0x82E8D3A8)
	// 82E8D368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8D36C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8D370: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8D374: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8D378: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8D37C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8D380: 548B07BD  rlwinm. r11, r4, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8D384: 41820058  beq 0x82e8d3dc
	if ctx.cr[0].eq {
	pc = 0x82E8D3DC; continue 'dispatch;
	}
	// 82E8D388: 817FFFFC  lwz r11, -4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82E8D38C: 3BDFFFFC  addi r30, r31, -4
	ctx.r[30].s64 = ctx.r[31].s64 + -4;
	// 82E8D390: 1D4B0014  mulli r10, r11, 0x14
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 20 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82E8D394: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8D398: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82E8D39C: 4180001C  blt 0x82e8d3b8
	if ctx.cr[0].lt {
	pc = 0x82E8D3B8; continue 'dispatch;
	}
	// 82E8D3A0: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82E8D3A4: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	pc = 0x82E8D3A8; continue 'dispatch;
            }
            0x82E8D3A8 => {
    //   block [0x82E8D3A8..0x82E8D3B8)
	// 82E8D3A8: 394AFFEC  addi r10, r10, -0x14
	ctx.r[10].s64 = ctx.r[10].s64 + -20;
	// 82E8D3AC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8D3B0: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E8D3B4: 4080FFF4  bge 0x82e8d3a8
	if !ctx.cr[0].lt {
	pc = 0x82E8D3A8; continue 'dispatch;
	}
	pc = 0x82E8D3B8; continue 'dispatch;
            }
            0x82E8D3B8 => {
    //   block [0x82E8D3B8..0x82E8D3D4)
	// 82E8D3B8: 548B07FF  clrlwi. r11, r4, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8D3BC: 41820018  beq 0x82e8d3d4
	if ctx.cr[0].eq {
	pc = 0x82E8D3D4; continue 'dispatch;
	}
	// 82E8D3C0: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E8D3C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8D3C8: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E8D3CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8D3D0: 4E800421  bctrl
	ctx.lr = 0x82E8D3D4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8D3D4 => {
    //   block [0x82E8D3D4..0x82E8D3DC)
	// 82E8D3D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8D3D8: 48000030  b 0x82e8d408
	pc = 0x82E8D408; continue 'dispatch;
            }
            0x82E8D3DC => {
    //   block [0x82E8D3DC..0x82E8D404)
	// 82E8D3DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E8D3E0: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E8D3E4: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82E8D3E8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E8D3EC: 41820018  beq 0x82e8d404
	if ctx.cr[0].eq {
	pc = 0x82E8D404; continue 'dispatch;
	}
	// 82E8D3F0: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E8D3F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8D3F8: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E8D3FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8D400: 4E800421  bctrl
	ctx.lr = 0x82E8D404;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8D404 => {
    //   block [0x82E8D404..0x82E8D408)
	// 82E8D404: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82E8D408; continue 'dispatch;
            }
            0x82E8D408 => {
    //   block [0x82E8D408..0x82E8D420)
	// 82E8D408: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8D40C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8D410: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8D414: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8D418: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8D41C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8D420 size=192
    let mut pc: u32 = 0x82E8D420;
    'dispatch: loop {
        match pc {
            0x82E8D420 => {
    //   block [0x82E8D420..0x82E8D4E0)
	// 82E8D420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8D424: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8D428: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8D42C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8D430: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8D434: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8D438: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82E8D43C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8D440: 396B272C  addi r11, r11, 0x272c
	ctx.r[11].s64 = ctx.r[11].s64 + 10028;
	// 82E8D444: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E8D448: 394A9B0C  addi r10, r10, -0x64f4
	ctx.r[10].s64 = ctx.r[10].s64 + -25844;
	// 82E8D44C: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 82E8D450: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E8D454: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82E8D458: 915F0014  stw r10, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82E8D45C: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 82E8D460: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82E8D464: 4B7894C5  bl 0x82616928
	ctx.lr = 0x82E8D468;
	sub_82616928(ctx, base);
	// 82E8D468: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 82E8D46C: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82E8D470: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82E8D474: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82E8D478: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82E8D47C: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 82E8D480: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 82E8D484: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8D488: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 82E8D48C: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82E8D490: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82E8D494: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 82E8D498: 93DF0034  stw r30, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	// 82E8D49C: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 82E8D4A0: 93DF003C  stw r30, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[30].u32 ) };
	// 82E8D4A4: 93DF0040  stw r30, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[30].u32 ) };
	// 82E8D4A8: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82E8D4AC: 915F0048  stw r10, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[10].u32 ) };
	// 82E8D4B0: 993F004C  stb r9, 0x4c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[9].u8 ) };
	// 82E8D4B4: 93DF0050  stw r30, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82E8D4B8: 93DF0054  stw r30, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82E8D4BC: 93DF0058  stw r30, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82E8D4C0: 93DF005C  stw r30, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82E8D4C4: 93DF0060  stw r30, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 82E8D4C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8D4CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8D4D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8D4D4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8D4D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8D4DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D4E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8D4E0 size=88
    let mut pc: u32 = 0x82E8D4E0;
    'dispatch: loop {
        match pc {
            0x82E8D4E0 => {
    //   block [0x82E8D4E0..0x82E8D51C)
	// 82E8D4E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8D4E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8D4E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8D4EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8D4F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8D4F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8D4F8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8D4FC: 4BFFF68D  bl 0x82e8cb88
	ctx.lr = 0x82E8D500;
	sub_82E8CB88(ctx, base);
	// 82E8D500: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8D504: 41820018  beq 0x82e8d51c
	if ctx.cr[0].eq {
	pc = 0x82E8D51C; continue 'dispatch;
	}
	// 82E8D508: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E8D50C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8D510: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82E8D514: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8D518: 4E800421  bctrl
	ctx.lr = 0x82E8D51C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8D51C => {
    //   block [0x82E8D51C..0x82E8D538)
	// 82E8D51C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8D520: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8D524: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8D528: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8D52C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8D530: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8D534: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8D538 size=120
    let mut pc: u32 = 0x82E8D538;
    'dispatch: loop {
        match pc {
            0x82E8D538 => {
    //   block [0x82E8D538..0x82E8D554)
	// 82E8D538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8D53C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8D540: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8D544: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8D548: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E8D54C: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8D550: 4099000C  ble cr6, 0x82e8d55c
	if !ctx.cr[6].gt {
	pc = 0x82E8D55C; continue 'dispatch;
	}
	pc = 0x82E8D554; continue 'dispatch;
            }
            0x82E8D554 => {
    //   block [0x82E8D554..0x82E8D55C)
	// 82E8D554: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8D558: 48000044  b 0x82e8d59c
	pc = 0x82E8D59C; continue 'dispatch;
            }
            0x82E8D55C => {
    //   block [0x82E8D55C..0x82E8D59C)
	// 82E8D55C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8D560: 81230018  lwz r9, 0x18(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E8D564: 548A1838  slwi r10, r4, 3
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8D568: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82E8D56C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82E8D570: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82E8D574: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8D578: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E8D57C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8D580: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82E8D584: 4182FFD0  beq 0x82e8d554
	if ctx.cr[0].eq {
	pc = 0x82E8D554; continue 'dispatch;
	}
	// 82E8D588: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E8D58C: 83EA0004  lwz r31, 4(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8D590: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82E8D594: 4BFF78ED  bl 0x82e84e80
	ctx.lr = 0x82E8D598;
	sub_82E84E80(ctx, base);
	// 82E8D598: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82E8D59C; continue 'dispatch;
            }
            0x82E8D59C => {
    //   block [0x82E8D59C..0x82E8D5B0)
	// 82E8D59C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8D5A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8D5A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8D5A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8D5AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D5B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8D5B0 size=104
    let mut pc: u32 = 0x82E8D5B0;
    'dispatch: loop {
        match pc {
            0x82E8D5B0 => {
    //   block [0x82E8D5B0..0x82E8D608)
	// 82E8D5B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8D5B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8D5B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8D5BC: 81640014  lwz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E8D5C0: 81430020  lwz r10, 0x20(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E8D5C4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E8D5C8: 41990040  bgt cr6, 0x82e8d608
	if ctx.cr[6].gt {
	pc = 0x82E8D608; continue 'dispatch;
	}
	// 82E8D5CC: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8D5D0: 81230018  lwz r9, 0x18(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E8D5D4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8D5D8: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 82E8D5DC: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82E8D5E0: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82E8D5E4: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82E8D5E8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E8D5EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E8D5F0: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8D5F4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82E8D5F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8D5FC: 388A0008  addi r4, r10, 8
	ctx.r[4].s64 = ctx.r[10].s64 + 8;
	// 82E8D600: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82E8D604: 4BFF256D  bl 0x82e7fb70
	ctx.lr = 0x82E8D608;
	sub_82E7FB70(ctx, base);
	pc = 0x82E8D608; continue 'dispatch;
            }
            0x82E8D608 => {
    //   block [0x82E8D608..0x82E8D618)
	// 82E8D608: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8D60C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8D610: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8D614: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8D618 size=520
    let mut pc: u32 = 0x82E8D618;
    'dispatch: loop {
        match pc {
            0x82E8D618 => {
    //   block [0x82E8D618..0x82E8D660)
	// 82E8D618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8D61C: 4BE1BDE1  bl 0x82ca93fc
	ctx.lr = 0x82E8D620;
	sub_82CA93D0(ctx, base);
	// 82E8D620: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8D624: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E8D628: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E8D62C: 4BFFF41D  bl 0x82e8ca48
	ctx.lr = 0x82E8D630;
	sub_82E8CA48(ctx, base);
	// 82E8D630: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E8D634: 93FE0024  stw r31, 0x24(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), ctx.r[31].u32 ) };
	// 82E8D638: 419A01A4  beq cr6, 0x82e8d7dc
	if ctx.cr[6].eq {
	pc = 0x82E8D7DC; continue 'dispatch;
	}
	// 82E8D63C: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82E8D640: 4B7892E9  bl 0x82616928
	ctx.lr = 0x82E8D644;
	sub_82616928(ctx, base);
	// 82E8D644: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82E8D648: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8D64C: 41820014  beq 0x82e8d660
	if ctx.cr[0].eq {
	pc = 0x82E8D660; continue 'dispatch;
	}
	// 82E8D650: 809E0024  lwz r4, 0x24(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E8D654: 4BFFFBDD  bl 0x82e8d230
	ctx.lr = 0x82E8D658;
	sub_82E8D230(ctx, base);
	// 82E8D658: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E8D65C: 48000008  b 0x82e8d664
	pc = 0x82E8D664; continue 'dispatch;
            }
            0x82E8D660 => {
    //   block [0x82E8D660..0x82E8D664)
	// 82E8D660: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x82E8D664; continue 'dispatch;
            }
            0x82E8D664 => {
    //   block [0x82E8D664..0x82E8D684)
	// 82E8D664: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82E8D668: 917E0028  stw r11, 0x28(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82E8D66C: 4B7892BD  bl 0x82616928
	ctx.lr = 0x82E8D670;
	sub_82616928(ctx, base);
	// 82E8D670: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8D674: 41820010  beq 0x82e8d684
	if ctx.cr[0].eq {
	pc = 0x82E8D684; continue 'dispatch;
	}
	// 82E8D678: 809E0024  lwz r4, 0x24(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E8D67C: 4BFFFBB5  bl 0x82e8d230
	ctx.lr = 0x82E8D680;
	sub_82E8D230(ctx, base);
	// 82E8D680: 48000008  b 0x82e8d688
	pc = 0x82E8D688; continue 'dispatch;
            }
            0x82E8D684 => {
    //   block [0x82E8D684..0x82E8D688)
	// 82E8D684: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	pc = 0x82E8D688; continue 'dispatch;
            }
            0x82E8D688 => {
    //   block [0x82E8D688..0x82E8D6B4)
	// 82E8D688: 83FE0024  lwz r31, 0x24(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E8D68C: 3D601FFF  lis r11, 0x1fff
	ctx.r[11].s64 = 536805376;
	// 82E8D690: 907E002C  stw r3, 0x2c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(44 as u32), ctx.r[3].u32 ) };
	// 82E8D694: 3B20FFFF  li r25, -1
	ctx.r[25].s64 = -1;
	// 82E8D698: 617CFFFF  ori r28, r11, 0xffff
	ctx.r[28].u64 = ctx.r[11].u64 | 65535;
	// 82E8D69C: 3B60FFFB  li r27, -5
	ctx.r[27].s64 = -5;
	// 82E8D6A0: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8D6A4: 40820010  bne 0x82e8d6b4
	if !ctx.cr[0].eq {
	pc = 0x82E8D6B4; continue 'dispatch;
	}
	// 82E8D6A8: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82E8D6AC: 4B45CB0D  bl 0x822ea1b8
	ctx.lr = 0x82E8D6B0;
	sub_822EA1B8(ctx, base);
	// 82E8D6B0: 48000028  b 0x82e8d6d8
	pc = 0x82E8D6D8; continue 'dispatch;
            }
            0x82E8D6B4 => {
    //   block [0x82E8D6B4..0x82E8D6C4)
	// 82E8D6B4: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82E8D6B8: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E8D6BC: 40990008  ble cr6, 0x82e8d6c4
	if !ctx.cr[6].gt {
	pc = 0x82E8D6C4; continue 'dispatch;
	}
	// 82E8D6C0: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82E8D6C4; continue 'dispatch;
            }
            0x82E8D6C4 => {
    //   block [0x82E8D6C4..0x82E8D6D4)
	// 82E8D6C4: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82E8D6C8: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82E8D6CC: 40990008  ble cr6, 0x82e8d6d4
	if !ctx.cr[6].gt {
	pc = 0x82E8D6D4; continue 'dispatch;
	}
	// 82E8D6D0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	pc = 0x82E8D6D4; continue 'dispatch;
            }
            0x82E8D6D4 => {
    //   block [0x82E8D6D4..0x82E8D6D8)
	// 82E8D6D4: 4B789255  bl 0x82616928
	ctx.lr = 0x82E8D6D8;
	sub_82616928(ctx, base);
	pc = 0x82E8D6D8; continue 'dispatch;
            }
            0x82E8D6D8 => {
    //   block [0x82E8D6D8..0x82E8D6FC)
	// 82E8D6D8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8D6DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8D6E0: 3BAB9B10  addi r29, r11, -0x64f0
	ctx.r[29].s64 = ctx.r[11].s64 + -25840;
	// 82E8D6E4: 419A0030  beq cr6, 0x82e8d714
	if ctx.cr[6].eq {
	pc = 0x82E8D714; continue 'dispatch;
	}
	// 82E8D6E8: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 82E8D6EC: 93E30000  stw r31, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82E8D6F0: 357FFFFF  addic. r11, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8D6F4: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82E8D6F8: 41800020  blt 0x82e8d718
	if ctx.cr[0].lt {
	pc = 0x82E8D718; continue 'dispatch;
	}
	pc = 0x82E8D6FC; continue 'dispatch;
            }
            0x82E8D6FC => {
    //   block [0x82E8D6FC..0x82E8D714)
	// 82E8D6FC: 934A0004  stw r26, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 82E8D700: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8D704: 93AA0000  stw r29, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82E8D708: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82E8D70C: 4080FFF0  bge 0x82e8d6fc
	if !ctx.cr[0].lt {
	pc = 0x82E8D6FC; continue 'dispatch;
	}
	// 82E8D710: 48000008  b 0x82e8d718
	pc = 0x82E8D718; continue 'dispatch;
            }
            0x82E8D714 => {
    //   block [0x82E8D714..0x82E8D718)
	// 82E8D714: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	pc = 0x82E8D718; continue 'dispatch;
            }
            0x82E8D718 => {
    //   block [0x82E8D718..0x82E8D734)
	// 82E8D718: 83FE0024  lwz r31, 0x24(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E8D71C: 913E0030  stw r9, 0x30(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[9].u32 ) };
	// 82E8D720: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8D724: 40820010  bne 0x82e8d734
	if !ctx.cr[0].eq {
	pc = 0x82E8D734; continue 'dispatch;
	}
	// 82E8D728: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82E8D72C: 4B45CA8D  bl 0x822ea1b8
	ctx.lr = 0x82E8D730;
	sub_822EA1B8(ctx, base);
	// 82E8D730: 48000028  b 0x82e8d758
	pc = 0x82E8D758; continue 'dispatch;
            }
            0x82E8D734 => {
    //   block [0x82E8D734..0x82E8D744)
	// 82E8D734: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82E8D738: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E8D73C: 40990008  ble cr6, 0x82e8d744
	if !ctx.cr[6].gt {
	pc = 0x82E8D744; continue 'dispatch;
	}
	// 82E8D740: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82E8D744; continue 'dispatch;
            }
            0x82E8D744 => {
    //   block [0x82E8D744..0x82E8D754)
	// 82E8D744: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82E8D748: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82E8D74C: 40990008  ble cr6, 0x82e8d754
	if !ctx.cr[6].gt {
	pc = 0x82E8D754; continue 'dispatch;
	}
	// 82E8D750: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	pc = 0x82E8D754; continue 'dispatch;
            }
            0x82E8D754 => {
    //   block [0x82E8D754..0x82E8D758)
	// 82E8D754: 4B7891D5  bl 0x82616928
	ctx.lr = 0x82E8D758;
	sub_82616928(ctx, base);
	pc = 0x82E8D758; continue 'dispatch;
            }
            0x82E8D758 => {
    //   block [0x82E8D758..0x82E8D774)
	// 82E8D758: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E8D75C: 419A0034  beq cr6, 0x82e8d790
	if ctx.cr[6].eq {
	pc = 0x82E8D790; continue 'dispatch;
	}
	// 82E8D760: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 82E8D764: 93E30000  stw r31, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82E8D768: 357FFFFF  addic. r11, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8D76C: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82E8D770: 41800018  blt 0x82e8d788
	if ctx.cr[0].lt {
	pc = 0x82E8D788; continue 'dispatch;
	}
	pc = 0x82E8D774; continue 'dispatch;
            }
            0x82E8D774 => {
    //   block [0x82E8D774..0x82E8D788)
	// 82E8D774: 934A0004  stw r26, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 82E8D778: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8D77C: 93AA0000  stw r29, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82E8D780: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82E8D784: 4080FFF0  bge 0x82e8d774
	if !ctx.cr[0].lt {
	pc = 0x82E8D774; continue 'dispatch;
	}
	pc = 0x82E8D788; continue 'dispatch;
            }
            0x82E8D788 => {
    //   block [0x82E8D788..0x82E8D790)
	// 82E8D788: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82E8D78C: 48000008  b 0x82e8d794
	pc = 0x82E8D794; continue 'dispatch;
            }
            0x82E8D790 => {
    //   block [0x82E8D790..0x82E8D794)
	// 82E8D790: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	pc = 0x82E8D794; continue 'dispatch;
            }
            0x82E8D794 => {
    //   block [0x82E8D794..0x82E8D7B4)
	// 82E8D794: 3D203FFF  lis r9, 0x3fff
	ctx.r[9].s64 = 1073676288;
	// 82E8D798: 817E0024  lwz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E8D79C: 915E0034  stw r10, 0x34(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	// 82E8D7A0: 613FFFFF  ori r31, r9, 0xffff
	ctx.r[31].u64 = ctx.r[9].u64 | 65535;
	// 82E8D7A4: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82E8D7A8: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82E8D7AC: 40990008  ble cr6, 0x82e8d7b4
	if !ctx.cr[6].gt {
	pc = 0x82E8D7B4; continue 'dispatch;
	}
	// 82E8D7B0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	pc = 0x82E8D7B4; continue 'dispatch;
            }
            0x82E8D7B4 => {
    //   block [0x82E8D7B4..0x82E8D7D0)
	// 82E8D7B4: 4B789175  bl 0x82616928
	ctx.lr = 0x82E8D7B8;
	sub_82616928(ctx, base);
	// 82E8D7B8: 817E0024  lwz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E8D7BC: 907E0038  stw r3, 0x38(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), ctx.r[3].u32 ) };
	// 82E8D7C0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82E8D7C4: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82E8D7C8: 40990008  ble cr6, 0x82e8d7d0
	if !ctx.cr[6].gt {
	pc = 0x82E8D7D0; continue 'dispatch;
	}
	// 82E8D7CC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	pc = 0x82E8D7D0; continue 'dispatch;
            }
            0x82E8D7D0 => {
    //   block [0x82E8D7D0..0x82E8D7DC)
	// 82E8D7D0: 4B789159  bl 0x82616928
	ctx.lr = 0x82E8D7D4;
	sub_82616928(ctx, base);
	// 82E8D7D4: 907E003C  stw r3, 0x3c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(60 as u32), ctx.r[3].u32 ) };
	// 82E8D7D8: 48000020  b 0x82e8d7f8
	pc = 0x82E8D7F8; continue 'dispatch;
            }
            0x82E8D7DC => {
    //   block [0x82E8D7DC..0x82E8D7F8)
	// 82E8D7DC: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82E8D7E0: 935E0028  stw r26, 0x28(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[26].u32 ) };
	// 82E8D7E4: 935E002C  stw r26, 0x2c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(44 as u32), ctx.r[26].u32 ) };
	// 82E8D7E8: 935E0030  stw r26, 0x30(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[26].u32 ) };
	// 82E8D7EC: 935E0034  stw r26, 0x34(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(52 as u32), ctx.r[26].u32 ) };
	// 82E8D7F0: 935E0038  stw r26, 0x38(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), ctx.r[26].u32 ) };
	// 82E8D7F4: 935E003C  stw r26, 0x3c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(60 as u32), ctx.r[26].u32 ) };
	pc = 0x82E8D7F8; continue 'dispatch;
            }
            0x82E8D7F8 => {
    //   block [0x82E8D7F8..0x82E8D820)
	// 82E8D7F8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8D7FC: 3BEB983C  addi r31, r11, -0x67c4
	ctx.r[31].s64 = ctx.r[11].s64 + -26564;
	// 82E8D800: 4B3D31B9  bl 0x822609b8
	ctx.lr = 0x82E8D804;
	sub_822609B8(ctx, base);
	// 82E8D804: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E8D808: 4BFF3A31  bl 0x82e81238
	ctx.lr = 0x82E8D80C;
	sub_82E81238(ctx, base);
	// 82E8D80C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E8D810: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E8D814: 917E0048  stw r11, 0x48(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82E8D818: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E8D81C: 4BE1BC30  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8D820 size=56
    let mut pc: u32 = 0x82E8D820;
    'dispatch: loop {
        match pc {
            0x82E8D820 => {
    //   block [0x82E8D820..0x82E8D844)
	// 82E8D820: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8D824: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8D828: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8D82C: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 82E8D830: 4B7890F9  bl 0x82616928
	ctx.lr = 0x82E8D834;
	sub_82616928(ctx, base);
	// 82E8D834: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8D838: 4182000C  beq 0x82e8d844
	if ctx.cr[0].eq {
	pc = 0x82E8D844; continue 'dispatch;
	}
	// 82E8D83C: 4BFFFBE5  bl 0x82e8d420
	ctx.lr = 0x82E8D840;
	sub_82E8D420(ctx, base);
	// 82E8D840: 48000008  b 0x82e8d848
	pc = 0x82E8D848; continue 'dispatch;
            }
            0x82E8D844 => {
    //   block [0x82E8D844..0x82E8D848)
	// 82E8D844: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E8D848; continue 'dispatch;
            }
            0x82E8D848 => {
    //   block [0x82E8D848..0x82E8D858)
	// 82E8D848: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8D84C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8D850: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8D854: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8D858 size=292
    let mut pc: u32 = 0x82E8D858;
    'dispatch: loop {
        match pc {
            0x82E8D858 => {
    //   block [0x82E8D858..0x82E8D874)
	// 82E8D858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8D85C: 4BE1BBA9  bl 0x82ca9404
	ctx.lr = 0x82E8D860;
	sub_82CA93D0(ctx, base);
	// 82E8D860: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8D864: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E8D868: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E8D86C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E8D870: 409A000C  bne cr6, 0x82e8d87c
	if !ctx.cr[6].eq {
	pc = 0x82E8D87C; continue 'dispatch;
	}
	pc = 0x82E8D874; continue 'dispatch;
            }
            0x82E8D874 => {
    //   block [0x82E8D874..0x82E8D87C)
	// 82E8D874: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8D878: 480000FC  b 0x82e8d974
	pc = 0x82E8D974; continue 'dispatch;
            }
            0x82E8D87C => {
    //   block [0x82E8D87C..0x82E8D8A0)
	// 82E8D87C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8D880: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82E8D884: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E8D888: 997D0010  stb r11, 0x10(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[11].u8 ) };
	// 82E8D88C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E8D890: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8D894: 40990048  ble cr6, 0x82e8d8dc
	if !ctx.cr[6].gt {
	pc = 0x82E8D8DC; continue 'dispatch;
	}
	// 82E8D898: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8D89C: 3B6B9848  addi r27, r11, -0x67b8
	ctx.r[27].s64 = ctx.r[11].s64 + -26552;
	pc = 0x82E8D8A0; continue 'dispatch;
            }
            0x82E8D8A0 => {
    //   block [0x82E8D8A0..0x82E8D8CC)
	// 82E8D8A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8D8A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8D8A8: 4BFF6781  bl 0x82e84028
	ctx.lr = 0x82E8D8AC;
	sub_82E84028(ctx, base);
	// 82E8D8AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8D8B0: 4182001C  beq 0x82e8d8cc
	if ctx.cr[0].eq {
	pc = 0x82E8D8CC; continue 'dispatch;
	}
	// 82E8D8B4: 4832E7AD  bl 0x831bc060
	ctx.lr = 0x82E8D8B8;
	sub_831BC060(ctx, base);
	// 82E8D8B8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E8D8BC: 4BE1F295  bl 0x82cacb50
	ctx.lr = 0x82E8D8C0;
	sub_82CACB50(ctx, base);
	// 82E8D8C0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8D8C4: 40820008  bne 0x82e8d8cc
	if !ctx.cr[0].eq {
	pc = 0x82E8D8CC; continue 'dispatch;
	}
	// 82E8D8C8: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	pc = 0x82E8D8CC; continue 'dispatch;
            }
            0x82E8D8CC => {
    //   block [0x82E8D8CC..0x82E8D8DC)
	// 82E8D8CC: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E8D8D0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82E8D8D4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8D8D8: 4198FFC8  blt cr6, 0x82e8d8a0
	if ctx.cr[6].lt {
	pc = 0x82E8D8A0; continue 'dispatch;
	}
	pc = 0x82E8D8DC; continue 'dispatch;
            }
            0x82E8D8DC => {
    //   block [0x82E8D8DC..0x82E8D920)
	// 82E8D8DC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E8D8E0: 387D0014  addi r3, r29, 0x14
	ctx.r[3].s64 = ctx.r[29].s64 + 20;
	// 82E8D8E4: 48043175  bl 0x82ed0a58
	ctx.lr = 0x82E8D8E8;
	sub_82ED0A58(ctx, base);
	// 82E8D8E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E8D8EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8D8F0: 4BFF7AB9  bl 0x82e853a8
	ctx.lr = 0x82E8D8F4;
	sub_82E853A8(ctx, base);
	// 82E8D8F4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8D8F8: 4182FF7C  beq 0x82e8d874
	if ctx.cr[0].eq {
	pc = 0x82E8D874; continue 'dispatch;
	}
	// 82E8D8FC: 897D0010  lbz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E8D900: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8D904: 4082006C  bne 0x82e8d970
	if !ctx.cr[0].eq {
	pc = 0x82E8D970; continue 'dispatch;
	}
	// 82E8D908: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8D90C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82E8D910: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8D914: 4099005C  ble cr6, 0x82e8d970
	if !ctx.cr[6].gt {
	pc = 0x82E8D970; continue 'dispatch;
	}
	// 82E8D918: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8D91C: 5568003E  slwi r8, r11, 0
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	pc = 0x82E8D920; continue 'dispatch;
            }
            0x82E8D920 => {
    //   block [0x82E8D920..0x82E8D948)
	// 82E8D920: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8D924: 816B0084  lwz r11, 0x84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 82E8D928: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8D92C: 554A07FE  clrlwi r10, r10, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82E8D930: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82E8D934: 409A0014  bne cr6, 0x82e8d948
	if !ctx.cr[6].eq {
	pc = 0x82E8D948; continue 'dispatch;
	}
	// 82E8D938: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E8D93C: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82E8D940: 40990008  ble cr6, 0x82e8d948
	if !ctx.cr[6].gt {
	pc = 0x82E8D948; continue 'dispatch;
	}
	// 82E8D944: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	pc = 0x82E8D948; continue 'dispatch;
            }
            0x82E8D948 => {
    //   block [0x82E8D948..0x82E8D970)
	// 82E8D948: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82E8D94C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82E8D950: 4082FFD0  bne 0x82e8d920
	if !ctx.cr[0].eq {
	pc = 0x82E8D920; continue 'dispatch;
	}
	// 82E8D954: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82E8D958: 419A0018  beq cr6, 0x82e8d970
	if ctx.cr[6].eq {
	pc = 0x82E8D970; continue 'dispatch;
	}
	// 82E8D95C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8D960: 4BFFFCB9  bl 0x82e8d618
	ctx.lr = 0x82E8D964;
	sub_82E8D618(ctx, base);
	// 82E8D964: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8D968: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8D96C: 41820008  beq 0x82e8d974
	if ctx.cr[0].eq {
	pc = 0x82E8D974; continue 'dispatch;
	}
	pc = 0x82E8D970; continue 'dispatch;
            }
            0x82E8D970 => {
    //   block [0x82E8D970..0x82E8D974)
	// 82E8D970: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82E8D974; continue 'dispatch;
            }
            0x82E8D974 => {
    //   block [0x82E8D974..0x82E8D97C)
	// 82E8D974: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E8D978: 4BE1BADC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8D980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8D980 size=160
    let mut pc: u32 = 0x82E8D980;
    'dispatch: loop {
        match pc {
            0x82E8D980 => {
    //   block [0x82E8D980..0x82E8D9B4)
	// 82E8D980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8D984: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8D988: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8D98C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8D990: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8D994: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E8D998: 419A0064  beq cr6, 0x82e8d9fc
	if ctx.cr[6].eq {
	pc = 0x82E8D9FC; continue 'dispatch;
	}
	// 82E8D99C: 4BFFEBCD  bl 0x82e8c568
	ctx.lr = 0x82E8D9A0;
	sub_82E8C568(ctx, base);
	// 82E8D9A0: 80A30400  lwz r5, 0x400(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E8D9A4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82E8D9A8: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8D9AC: 40810050  ble 0x82e8d9fc
	if !ctx.cr[0].gt {
	pc = 0x82E8D9FC; continue 'dispatch;
	}
	// 82E8D9B0: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x82E8D9B4; continue 'dispatch;
            }
            0x82E8D9B4 => {
    //   block [0x82E8D9B4..0x82E8D9C0)
	// 82E8D9B4: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8D9B8: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82E8D9BC: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	pc = 0x82E8D9C0; continue 'dispatch;
            }
            0x82E8D9C0 => {
    //   block [0x82E8D9C0..0x82E8D9E4)
	// 82E8D9C0: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8D9C4: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8D9C8: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8D9CC: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82E8D9D0: 41820014  beq 0x82e8d9e4
	if ctx.cr[0].eq {
	pc = 0x82E8D9E4; continue 'dispatch;
	}
	// 82E8D9D4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E8D9D8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E8D9DC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82E8D9E0: 419AFFE0  beq cr6, 0x82e8d9c0
	if ctx.cr[6].eq {
	pc = 0x82E8D9C0; continue 'dispatch;
	}
	pc = 0x82E8D9E4; continue 'dispatch;
            }
            0x82E8D9E4 => {
    //   block [0x82E8D9E4..0x82E8D9FC)
	// 82E8D9E4: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8D9E8: 4182002C  beq 0x82e8da14
	if ctx.cr[0].eq {
	pc = 0x82E8DA14; continue 'dispatch;
	}
	// 82E8D9EC: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82E8D9F0: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82E8D9F4: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82E8D9F8: 4198FFBC  blt cr6, 0x82e8d9b4
	if ctx.cr[6].lt {
	pc = 0x82E8D9B4; continue 'dispatch;
	}
	pc = 0x82E8D9FC; continue 'dispatch;
            }
            0x82E8D9FC => {
    //   block [0x82E8D9FC..0x82E8DA00)
	// 82E8D9FC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E8DA00; continue 'dispatch;
            }
            0x82E8DA00 => {
    //   block [0x82E8DA00..0x82E8DA14)
	// 82E8DA00: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8DA04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8DA08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8DA0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8DA10: 4E800020  blr
	return;
            }
            0x82E8DA14 => {
    //   block [0x82E8DA14..0x82E8DA20)
	// 82E8DA14: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E8DA18: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82E8DA1C: 4BFFFFE4  b 0x82e8da00
	pc = 0x82E8DA00; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8DA20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8DA20 size=116
    let mut pc: u32 = 0x82E8DA20;
    'dispatch: loop {
        match pc {
            0x82E8DA20 => {
    //   block [0x82E8DA20..0x82E8DA68)
	// 82E8DA20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8DA24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8DA28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8DA2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8DA30: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82E8DA34: 816A2E34  lwz r11, 0x2e34(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11828 as u32) ) } as u64;
	// 82E8DA38: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82E8DA3C: 3D208334  lis r9, -0x7ccc
	ctx.r[9].s64 = -2093744128;
	// 82E8DA40: 3BE92A30  addi r31, r9, 0x2a30
	ctx.r[31].s64 = ctx.r[9].s64 + 10800;
	// 82E8DA44: 40820038  bne 0x82e8da7c
	if !ctx.cr[0].eq {
	pc = 0x82E8DA7C; continue 'dispatch;
	}
	// 82E8DA48: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82E8DA4C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82E8DA50: 8909DCC8  lbz r8, -0x2338(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-9016 as u32) ) } as u64;
	// 82E8DA54: 916A2E34  stw r11, 0x2e34(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(11828 as u32), ctx.r[11].u32 ) };
	// 82E8DA58: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8DA5C: 4182000C  beq 0x82e8da68
	if ctx.cr[0].eq {
	pc = 0x82E8DA68; continue 'dispatch;
	}
	// 82E8DA60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8DA64: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	pc = 0x82E8DA68; continue 'dispatch;
            }
            0x82E8DA68 => {
    //   block [0x82E8DA68..0x82E8DA7C)
	// 82E8DA68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8DA6C: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82E8DA70: 386A8508  addi r3, r10, -0x7af8
	ctx.r[3].s64 = ctx.r[10].s64 + -31480;
	// 82E8DA74: 9969DCC8  stb r11, -0x2338(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-9016 as u32), ctx.r[11].u8 ) };
	// 82E8DA78: 4BE1C4A9  bl 0x82ca9f20
	ctx.lr = 0x82E8DA7C;
	sub_82CA9F20(ctx, base);
	pc = 0x82E8DA7C; continue 'dispatch;
            }
            0x82E8DA7C => {
    //   block [0x82E8DA7C..0x82E8DA94)
	// 82E8DA7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8DA80: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8DA84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8DA88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8DA8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8DA90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8DA98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8DA98 size=160
    let mut pc: u32 = 0x82E8DA98;
    'dispatch: loop {
        match pc {
            0x82E8DA98 => {
    //   block [0x82E8DA98..0x82E8DACC)
	// 82E8DA98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8DA9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8DAA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8DAA4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8DAA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8DAAC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E8DAB0: 419A0064  beq cr6, 0x82e8db14
	if ctx.cr[6].eq {
	pc = 0x82E8DB14; continue 'dispatch;
	}
	// 82E8DAB4: 4BFFFF6D  bl 0x82e8da20
	ctx.lr = 0x82E8DAB8;
	sub_82E8DA20(ctx, base);
	// 82E8DAB8: 80A30400  lwz r5, 0x400(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E8DABC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82E8DAC0: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8DAC4: 40810050  ble 0x82e8db14
	if !ctx.cr[0].gt {
	pc = 0x82E8DB14; continue 'dispatch;
	}
	// 82E8DAC8: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x82E8DACC; continue 'dispatch;
            }
            0x82E8DACC => {
    //   block [0x82E8DACC..0x82E8DAD8)
	// 82E8DACC: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8DAD0: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82E8DAD4: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	pc = 0x82E8DAD8; continue 'dispatch;
            }
            0x82E8DAD8 => {
    //   block [0x82E8DAD8..0x82E8DAFC)
	// 82E8DAD8: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8DADC: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8DAE0: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8DAE4: 7D084850  subf r8, r8, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82E8DAE8: 41820014  beq 0x82e8dafc
	if ctx.cr[0].eq {
	pc = 0x82E8DAFC; continue 'dispatch;
	}
	// 82E8DAEC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E8DAF0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E8DAF4: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82E8DAF8: 419AFFE0  beq cr6, 0x82e8dad8
	if ctx.cr[6].eq {
	pc = 0x82E8DAD8; continue 'dispatch;
	}
	pc = 0x82E8DAFC; continue 'dispatch;
            }
            0x82E8DAFC => {
    //   block [0x82E8DAFC..0x82E8DB14)
	// 82E8DAFC: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8DB00: 4182002C  beq 0x82e8db2c
	if ctx.cr[0].eq {
	pc = 0x82E8DB2C; continue 'dispatch;
	}
	// 82E8DB04: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82E8DB08: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82E8DB0C: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82E8DB10: 4198FFBC  blt cr6, 0x82e8dacc
	if ctx.cr[6].lt {
	pc = 0x82E8DACC; continue 'dispatch;
	}
	pc = 0x82E8DB14; continue 'dispatch;
            }
            0x82E8DB14 => {
    //   block [0x82E8DB14..0x82E8DB18)
	// 82E8DB14: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E8DB18; continue 'dispatch;
            }
            0x82E8DB18 => {
    //   block [0x82E8DB18..0x82E8DB2C)
	// 82E8DB18: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8DB1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8DB20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8DB24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8DB28: 4E800020  blr
	return;
            }
            0x82E8DB2C => {
    //   block [0x82E8DB2C..0x82E8DB38)
	// 82E8DB2C: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E8DB30: 7C6B182E  lwzx r3, r11, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82E8DB34: 4BFFFFE4  b 0x82e8db18
	pc = 0x82E8DB18; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8DB38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8DB38 size=884
    let mut pc: u32 = 0x82E8DB38;
    'dispatch: loop {
        match pc {
            0x82E8DB38 => {
    //   block [0x82E8DB38..0x82E8DB54)
	// 82E8DB38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8DB3C: 4BE1B8C1  bl 0x82ca93fc
	ctx.lr = 0x82E8DB40;
	sub_82CA93D0(ctx, base);
	// 82E8DB40: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8DB44: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E8DB48: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82E8DB4C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82E8DB50: 409A000C  bne cr6, 0x82e8db5c
	if !ctx.cr[6].eq {
	pc = 0x82E8DB5C; continue 'dispatch;
	}
	pc = 0x82E8DB54; continue 'dispatch;
            }
            0x82E8DB54 => {
    //   block [0x82E8DB54..0x82E8DB5C)
	// 82E8DB54: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8DB58: 4800034C  b 0x82e8dea4
	pc = 0x82E8DEA4; continue 'dispatch;
            }
            0x82E8DB5C => {
    //   block [0x82E8DB5C..0x82E8DBB4)
	// 82E8DB5C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8DB60: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8DB64: 3BEB88AC  addi r31, r11, -0x7754
	ctx.r[31].s64 = ctx.r[11].s64 + -30548;
	// 82E8DB68: 4832E4F9  bl 0x831bc060
	ctx.lr = 0x82E8DB6C;
	sub_831BC060(ctx, base);
	// 82E8DB6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E8DB70: 4BE1EFE1  bl 0x82cacb50
	ctx.lr = 0x82E8DB74;
	sub_82CACB50(ctx, base);
	// 82E8DB74: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8DB78: 40820194  bne 0x82e8dd0c
	if !ctx.cr[0].eq {
	pc = 0x82E8DD0C; continue 'dispatch;
	}
	// 82E8DB7C: 83DD000C  lwz r30, 0xc(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8DB80: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8DB84: 4182FFD0  beq 0x82e8db54
	if ctx.cr[0].eq {
	pc = 0x82E8DB54; continue 'dispatch;
	}
	// 82E8DB88: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8DB8C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8DB90: 388B9884  addi r4, r11, -0x677c
	ctx.r[4].s64 = ctx.r[11].s64 + -26492;
	// 82E8DB94: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82E8DB98: 4BFF6409  bl 0x82e83fa0
	ctx.lr = 0x82E8DB9C;
	sub_82E83FA0(ctx, base);
	// 82E8DB9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8DBA0: 41820014  beq 0x82e8dbb4
	if ctx.cr[0].eq {
	pc = 0x82E8DBB4; continue 'dispatch;
	}
	// 82E8DBA4: 4BE1C81D  bl 0x82caa3c0
	ctx.lr = 0x82E8DBA8;
	sub_82CAA3C0(ctx, base);
	// 82E8DBA8: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 82E8DBAC: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82E8DBB0: 697F0001  xori r31, r11, 1
	ctx.r[31].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x82E8DBB4; continue 'dispatch;
            }
            0x82E8DBB4 => {
    //   block [0x82E8DBB4..0x82E8DC28)
	// 82E8DBB4: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82E8DBB8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8DBBC: 388B4DAC  addi r4, r11, 0x4dac
	ctx.r[4].s64 = ctx.r[11].s64 + 19884;
	// 82E8DBC0: 4BFF6359  bl 0x82e83f18
	ctx.lr = 0x82E8DBC4;
	sub_82E83F18(ctx, base);
	// 82E8DBC4: 7C651B79  or. r5, r3, r3
	ctx.r[5].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82E8DBC8: 4182FF8C  beq 0x82e8db54
	if ctx.cr[0].eq {
	pc = 0x82E8DB54; continue 'dispatch;
	}
	// 82E8DBCC: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8DBD0: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82E8DBD4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8DBD8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82E8DBDC: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E8DBE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8DBE4: 4E800421  bctrl
	ctx.lr = 0x82E8DBE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8DBE8: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82E8DBEC: 4182FF68  beq 0x82e8db54
	if ctx.cr[0].eq {
	pc = 0x82E8DB54; continue 'dispatch;
	}
	// 82E8DBF0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8DBF4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8DBF8: 388B9870  addi r4, r11, -0x6790
	ctx.r[4].s64 = ctx.r[11].s64 + -26512;
	// 82E8DBFC: 4BFF63A5  bl 0x82e83fa0
	ctx.lr = 0x82E8DC00;
	sub_82E83FA0(ctx, base);
	// 82E8DC00: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8DC04: 41820024  beq 0x82e8dc28
	if ctx.cr[0].eq {
	pc = 0x82E8DC28; continue 'dispatch;
	}
	// 82E8DC08: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8DC0C: 83EB0718  lwz r31, 0x718(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E8DC10: 4BE1DFA1  bl 0x82cabbb0
	ctx.lr = 0x82E8DC14;
	sub_82CABBB0(ctx, base);
	// 82E8DC14: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8DC18: 817C0084  lwz r11, 0x84(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(132 as u32) ) } as u64;
	// 82E8DC1C: FC010032  fmul f0, f1, f0
	ctx.f[0].f64 = ctx.f[1].f64 * ctx.f[0].f64;
	// 82E8DC20: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82E8DC24: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
            }
            0x82E8DC28 => {
    //   block [0x82E8DC28..0x82E8DC48)
	// 82E8DC28: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E8DC2C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82E8DC30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8DC34: 4099025C  ble cr6, 0x82e8de90
	if !ctx.cr[6].gt {
	pc = 0x82E8DE90; continue 'dispatch;
	}
	// 82E8DC38: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8DC3C: 3B2B8FD8  addi r25, r11, -0x7028
	ctx.r[25].s64 = ctx.r[11].s64 + -28712;
	// 82E8DC40: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8DC44: 3B4B9860  addi r26, r11, -0x67a0
	ctx.r[26].s64 = ctx.r[11].s64 + -26528;
	pc = 0x82E8DC48; continue 'dispatch;
            }
            0x82E8DC48 => {
    //   block [0x82E8DC48..0x82E8DCDC)
	// 82E8DC48: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E8DC4C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8DC50: 4BFF63D9  bl 0x82e84028
	ctx.lr = 0x82E8DC54;
	sub_82E84028(ctx, base);
	// 82E8DC54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E8DC58: 4832E409  bl 0x831bc060
	ctx.lr = 0x82E8DC5C;
	sub_831BC060(ctx, base);
	// 82E8DC5C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82E8DC60: 4BE1EEF1  bl 0x82cacb50
	ctx.lr = 0x82E8DC64;
	sub_82CACB50(ctx, base);
	// 82E8DC64: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8DC68: 40820090  bne 0x82e8dcf8
	if !ctx.cr[0].eq {
	pc = 0x82E8DCF8; continue 'dispatch;
	}
	// 82E8DC6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8DC70: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82E8DC74: 4BFF62A5  bl 0x82e83f18
	ctx.lr = 0x82E8DC78;
	sub_82E83F18(ctx, base);
	// 82E8DC78: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8DC7C: 4182007C  beq 0x82e8dcf8
	if ctx.cr[0].eq {
	pc = 0x82E8DCF8; continue 'dispatch;
	}
	// 82E8DC80: 4BA80089  bl 0x8290dd08
	ctx.lr = 0x82E8DC84;
	sub_8290DD08(ctx, base);
	// 82E8DC84: 4BFFFE15  bl 0x82e8da98
	ctx.lr = 0x82E8DC88;
	sub_82E8DA98(ctx, base);
	// 82E8DC88: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8DC8C: 4182006C  beq 0x82e8dcf8
	if ctx.cr[0].eq {
	pc = 0x82E8DCF8; continue 'dispatch;
	}
	// 82E8DC90: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8DC94: 807C0084  lwz r3, 0x84(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(132 as u32) ) } as u64;
	// 82E8DC98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8DC9C: 4E800421  bctrl
	ctx.lr = 0x82E8DCA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8DCA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8DCA4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8DCA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8DCAC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8DCB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8DCB4: 4E800421  bctrl
	ctx.lr = 0x82E8DCB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8DCB8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8DCBC: 40820020  bne 0x82e8dcdc
	if !ctx.cr[0].eq {
	pc = 0x82E8DCDC; continue 'dispatch;
	}
	// 82E8DCC0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8DCC4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E8DCC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8DCCC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8DCD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8DCD4: 4E800421  bctrl
	ctx.lr = 0x82E8DCD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8DCD8: 48000020  b 0x82e8dcf8
	pc = 0x82E8DCF8; continue 'dispatch;
            }
            0x82E8DCDC => {
    //   block [0x82E8DCDC..0x82E8DCF8)
	// 82E8DCDC: 817C010C  lwz r11, 0x10c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(268 as u32) ) } as u64;
	// 82E8DCE0: 396B0023  addi r11, r11, 0x23
	ctx.r[11].s64 = ctx.r[11].s64 + 35;
	// 82E8DCE4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E8DCE8: 7FEBE12E  stwx r31, r11, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32), ctx.r[31].u32) };
	// 82E8DCEC: 817C010C  lwz r11, 0x10c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(268 as u32) ) } as u64;
	// 82E8DCF0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E8DCF4: 917C010C  stw r11, 0x10c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(268 as u32), ctx.r[11].u32 ) };
	pc = 0x82E8DCF8; continue 'dispatch;
            }
            0x82E8DCF8 => {
    //   block [0x82E8DCF8..0x82E8DD0C)
	// 82E8DCF8: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E8DCFC: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82E8DD00: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8DD04: 4198FF44  blt cr6, 0x82e8dc48
	if ctx.cr[6].lt {
	pc = 0x82E8DC48; continue 'dispatch;
	}
	// 82E8DD08: 48000188  b 0x82e8de90
	pc = 0x82E8DE90; continue 'dispatch;
            }
            0x82E8DD0C => {
    //   block [0x82E8DD0C..0x82E8DD50)
	// 82E8DD0C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8DD10: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8DD14: 3BEB9854  addi r31, r11, -0x67ac
	ctx.r[31].s64 = ctx.r[11].s64 + -26540;
	// 82E8DD18: 4832E349  bl 0x831bc060
	ctx.lr = 0x82E8DD1C;
	sub_831BC060(ctx, base);
	// 82E8DD1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E8DD20: 4BE1EE31  bl 0x82cacb50
	ctx.lr = 0x82E8DD24;
	sub_82CACB50(ctx, base);
	// 82E8DD24: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8DD28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8DD2C: 40820024  bne 0x82e8dd50
	if !ctx.cr[0].eq {
	pc = 0x82E8DD50; continue 'dispatch;
	}
	// 82E8DD30: 4BA7FFD9  bl 0x8290dd08
	ctx.lr = 0x82E8DD34;
	sub_8290DD08(ctx, base);
	// 82E8DD34: 4BE1C68D  bl 0x82caa3c0
	ctx.lr = 0x82E8DD38;
	sub_82CAA3C0(ctx, base);
	// 82E8DD38: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E8DD3C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82E8DD40: 4BFFF8D9  bl 0x82e8d618
	ctx.lr = 0x82E8DD44;
	sub_82E8D618(ctx, base);
	// 82E8DD44: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E8DD48: 99790010  stb r11, 0x10(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(16 as u32), ctx.r[11].u8 ) };
	// 82E8DD4C: 48000144  b 0x82e8de90
	pc = 0x82E8DE90; continue 'dispatch;
            }
            0x82E8DD50 => {
    //   block [0x82E8DD50..0x82E8DDB0)
	// 82E8DD50: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8DD54: 3BEB9848  addi r31, r11, -0x67b8
	ctx.r[31].s64 = ctx.r[11].s64 + -26552;
	// 82E8DD58: 4832E309  bl 0x831bc060
	ctx.lr = 0x82E8DD5C;
	sub_831BC060(ctx, base);
	// 82E8DD5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E8DD60: 4BE1EDF1  bl 0x82cacb50
	ctx.lr = 0x82E8DD64;
	sub_82CACB50(ctx, base);
	// 82E8DD64: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E8DD68: 40820130  bne 0x82e8de98
	if !ctx.cr[0].eq {
	pc = 0x82E8DE98; continue 'dispatch;
	}
	// 82E8DD6C: 83FD000C  lwz r31, 0xc(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8DD70: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8DD74: 4182FDE0  beq 0x82e8db54
	if ctx.cr[0].eq {
	pc = 0x82E8DB54; continue 'dispatch;
	}
	// 82E8DD78: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8DD7C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8DD80: 388B8FD8  addi r4, r11, -0x7028
	ctx.r[4].s64 = ctx.r[11].s64 + -28712;
	// 82E8DD84: 4BFF621D  bl 0x82e83fa0
	ctx.lr = 0x82E8DD88;
	sub_82E83FA0(ctx, base);
	// 82E8DD88: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8DD8C: 4182FDC8  beq 0x82e8db54
	if ctx.cr[0].eq {
	pc = 0x82E8DB54; continue 'dispatch;
	}
	// 82E8DD90: 4BFFFBF1  bl 0x82e8d980
	ctx.lr = 0x82E8DD94;
	sub_82E8D980(ctx, base);
	// 82E8DD94: 7C7A1B79  or. r26, r3, r3
	ctx.r[26].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82E8DD98: 40820030  bne 0x82e8ddc8
	if !ctx.cr[0].eq {
	pc = 0x82E8DDC8; continue 'dispatch;
	}
	// 82E8DD9C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82E8DDA0: 4BFFE7C9  bl 0x82e8c568
	ctx.lr = 0x82E8DDA4;
	sub_82E8C568(ctx, base);
	// 82E8DDA4: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E8DDA8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8DDAC: 4099FDA8  ble cr6, 0x82e8db54
	if !ctx.cr[6].gt {
	pc = 0x82E8DB54; continue 'dispatch;
	}
	pc = 0x82E8DDB0; continue 'dispatch;
            }
            0x82E8DDB0 => {
    //   block [0x82E8DDB0..0x82E8DDC8)
	// 82E8DDB0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82E8DDB4: 4BFFE7B5  bl 0x82e8c568
	ctx.lr = 0x82E8DDB8;
	sub_82E8C568(ctx, base);
	// 82E8DDB8: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E8DDBC: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82E8DDC0: 4198FFF0  blt cr6, 0x82e8ddb0
	if ctx.cr[6].lt {
	pc = 0x82E8DDB0; continue 'dispatch;
	}
	// 82E8DDC4: 4BFFFD90  b 0x82e8db54
	pc = 0x82E8DB54; continue 'dispatch;
            }
            0x82E8DDC8 => {
    //   block [0x82E8DDC8..0x82E8DDEC)
	// 82E8DDC8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8DDCC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8DDD0: 388B9820  addi r4, r11, -0x67e0
	ctx.r[4].s64 = ctx.r[11].s64 + -26592;
	// 82E8DDD4: 4BFF61CD  bl 0x82e83fa0
	ctx.lr = 0x82E8DDD8;
	sub_82E83FA0(ctx, base);
	// 82E8DDD8: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82E8DDDC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8DDE0: 4182000C  beq 0x82e8ddec
	if ctx.cr[0].eq {
	pc = 0x82E8DDEC; continue 'dispatch;
	}
	// 82E8DDE4: 4BE1C5DD  bl 0x82caa3c0
	ctx.lr = 0x82E8DDE8;
	sub_82CAA3C0(ctx, base);
	// 82E8DDE8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	pc = 0x82E8DDEC; continue 'dispatch;
            }
            0x82E8DDEC => {
    //   block [0x82E8DDEC..0x82E8DE0C)
	// 82E8DDEC: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 82E8DDF0: 4B788B39  bl 0x82616928
	ctx.lr = 0x82E8DDF4;
	sub_82616928(ctx, base);
	// 82E8DDF4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8DDF8: 41820014  beq 0x82e8de0c
	if ctx.cr[0].eq {
	pc = 0x82E8DE0C; continue 'dispatch;
	}
	// 82E8DDFC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E8DE00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E8DE04: 4804288D  bl 0x82ed0690
	ctx.lr = 0x82E8DE08;
	sub_82ED0690(ctx, base);
	// 82E8DE08: 48000008  b 0x82e8de10
	pc = 0x82E8DE10; continue 'dispatch;
            }
            0x82E8DE0C => {
    //   block [0x82E8DE0C..0x82E8DE10)
	// 82E8DE0C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E8DE10; continue 'dispatch;
            }
            0x82E8DE10 => {
    //   block [0x82E8DE10..0x82E8DE28)
	// 82E8DE10: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82E8DE14: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82E8DE18: 419A006C  beq cr6, 0x82e8de84
	if ctx.cr[6].eq {
	pc = 0x82E8DE84; continue 'dispatch;
	}
	// 82E8DE1C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8DE20: 3B630008  addi r27, r3, 8
	ctx.r[27].s64 = ctx.r[3].s64 + 8;
	// 82E8DE24: 3B8BAFB4  addi r28, r11, -0x504c
	ctx.r[28].s64 = ctx.r[11].s64 + -20556;
	pc = 0x82E8DE28; continue 'dispatch;
            }
            0x82E8DE28 => {
    //   block [0x82E8DE28..0x82E8DE84)
	// 82E8DE28: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8DE2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8DE30: 4E800421  bctrl
	ctx.lr = 0x82E8DE34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8DE34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8DE38: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82E8DE3C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E8DE40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8DE44: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82E8DE48: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8DE4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8DE50: 4E800421  bctrl
	ctx.lr = 0x82E8DE54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8DE54: 81790020  lwz r11, 0x20(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E8DE58: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82E8DE5C: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82E8DE60: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82E8DE64: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E8DE68: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E8DE6C: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82E8DE70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8DE74: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82E8DE78: 4BFF1CF9  bl 0x82e7fb70
	ctx.lr = 0x82E8DE7C;
	sub_82E7FB70(ctx, base);
	// 82E8DE7C: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82E8DE80: 4082FFA8  bne 0x82e8de28
	if !ctx.cr[0].eq {
	pc = 0x82E8DE28; continue 'dispatch;
	}
            }
            0x82E8DE84 => {
    //   block [0x82E8DE84..0x82E8DE90)
	// 82E8DE84: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E8DE88: 38790014  addi r3, r25, 0x14
	ctx.r[3].s64 = ctx.r[25].s64 + 20;
	// 82E8DE8C: 48042A45  bl 0x82ed08d0
	ctx.lr = 0x82E8DE90;
	sub_82ED08D0(ctx, base);
	pc = 0x82E8DE90; continue 'dispatch;
            }
            0x82E8DE90 => {
    //   block [0x82E8DE90..0x82E8DE98)
	// 82E8DE90: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E8DE94: 48000010  b 0x82e8dea4
	pc = 0x82E8DEA4; continue 'dispatch;
            }
            0x82E8DE98 => {
    //   block [0x82E8DE98..0x82E8DEA4)
	// 82E8DE98: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E8DE9C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82E8DEA0: 4B78B799  bl 0x82619638
	ctx.lr = 0x82E8DEA4;
	sub_82619638(ctx, base);
	pc = 0x82E8DEA4; continue 'dispatch;
            }
            0x82E8DEA4 => {
    //   block [0x82E8DEA4..0x82E8DEAC)
	// 82E8DEA4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82E8DEA8: 4BE1B5A4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8DEB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8DEB0 size=176
    let mut pc: u32 = 0x82E8DEB0;
    'dispatch: loop {
        match pc {
            0x82E8DEB0 => {
    //   block [0x82E8DEB0..0x82E8DEE8)
	// 82E8DEB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8DEB4: 4BE1B555  bl 0x82ca9408
	ctx.lr = 0x82E8DEB8;
	sub_82CA93D0(ctx, base);
	// 82E8DEB8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8DEBC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E8DEC0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E8DEC4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8DEC8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8DECC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8DED0: 4E800421  bctrl
	ctx.lr = 0x82E8DED4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8DED4: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E8DED8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E8DEDC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82E8DEE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8DEE4: 40990068  ble cr6, 0x82e8df4c
	if !ctx.cr[6].gt {
	pc = 0x82E8DF4C; continue 'dispatch;
	}
            }
            0x82E8DEE8 => {
    //   block [0x82E8DEE8..0x82E8DF3C)
	// 82E8DEE8: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 82E8DEEC: 419A0050  beq cr6, 0x82e8df3c
	if ctx.cr[6].eq {
	pc = 0x82E8DF3C; continue 'dispatch;
	}
	// 82E8DEF0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8DEF4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8DEF8: 40980044  bge cr6, 0x82e8df3c
	if !ctx.cr[6].lt {
	pc = 0x82E8DF3C; continue 'dispatch;
	}
	// 82E8DEFC: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E8DF00: 1D7E0014  mulli r11, r30, 0x14
	ctx.r[11].s32 = ((ctx.r[30].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82E8DF04: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E8DF08: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8DF0C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8DF10: 419A002C  beq cr6, 0x82e8df3c
	if ctx.cr[6].eq {
	pc = 0x82E8DF3C; continue 'dispatch;
	}
	// 82E8DF14: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8DF18: 41820024  beq 0x82e8df3c
	if ctx.cr[0].eq {
	pc = 0x82E8DF3C; continue 'dispatch;
	}
	// 82E8DF1C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8DF20: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82E8DF24: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8DF28: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8DF2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8DF30: 4E800421  bctrl
	ctx.lr = 0x82E8DF34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8DF34: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8DF38: 41820020  beq 0x82e8df58
	if ctx.cr[0].eq {
	pc = 0x82E8DF58; continue 'dispatch;
	}
            }
            0x82E8DF3C => {
    //   block [0x82E8DF3C..0x82E8DF4C)
	// 82E8DF3C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E8DF40: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82E8DF44: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8DF48: 4198FFA0  blt cr6, 0x82e8dee8
	if ctx.cr[6].lt {
	pc = 0x82E8DEE8; continue 'dispatch;
	}
	pc = 0x82E8DF4C; continue 'dispatch;
            }
            0x82E8DF4C => {
    //   block [0x82E8DF4C..0x82E8DF50)
	// 82E8DF4C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82E8DF50; continue 'dispatch;
            }
            0x82E8DF50 => {
    //   block [0x82E8DF50..0x82E8DF58)
	// 82E8DF50: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E8DF54: 4BE1B504  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82E8DF58 => {
    //   block [0x82E8DF58..0x82E8DF60)
	// 82E8DF58: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8DF5C: 4BFFFFF4  b 0x82e8df50
	pc = 0x82E8DF50; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8DF60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8DF60 size=176
    let mut pc: u32 = 0x82E8DF60;
    'dispatch: loop {
        match pc {
            0x82E8DF60 => {
    //   block [0x82E8DF60..0x82E8DF98)
	// 82E8DF60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8DF64: 4BE1B4A5  bl 0x82ca9408
	ctx.lr = 0x82E8DF68;
	sub_82CA93D0(ctx, base);
	// 82E8DF68: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8DF6C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E8DF70: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E8DF74: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8DF78: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8DF7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8DF80: 4E800421  bctrl
	ctx.lr = 0x82E8DF84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8DF84: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E8DF88: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E8DF8C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82E8DF90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8DF94: 40990068  ble cr6, 0x82e8dffc
	if !ctx.cr[6].gt {
	pc = 0x82E8DFFC; continue 'dispatch;
	}
            }
            0x82E8DF98 => {
    //   block [0x82E8DF98..0x82E8DFEC)
	// 82E8DF98: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 82E8DF9C: 419A0050  beq cr6, 0x82e8dfec
	if ctx.cr[6].eq {
	pc = 0x82E8DFEC; continue 'dispatch;
	}
	// 82E8DFA0: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E8DFA4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8DFA8: 40980044  bge cr6, 0x82e8dfec
	if !ctx.cr[6].lt {
	pc = 0x82E8DFEC; continue 'dispatch;
	}
	// 82E8DFAC: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82E8DFB0: 57CA1838  slwi r10, r30, 3
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8DFB4: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E8DFB8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8DFBC: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8DFC0: 419A002C  beq cr6, 0x82e8dfec
	if ctx.cr[6].eq {
	pc = 0x82E8DFEC; continue 'dispatch;
	}
	// 82E8DFC4: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8DFC8: 41820024  beq 0x82e8dfec
	if ctx.cr[0].eq {
	pc = 0x82E8DFEC; continue 'dispatch;
	}
	// 82E8DFCC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8DFD0: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82E8DFD4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8DFD8: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E8DFDC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8DFE0: 4E800421  bctrl
	ctx.lr = 0x82E8DFE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E8DFE4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8DFE8: 41820020  beq 0x82e8e008
	if ctx.cr[0].eq {
	pc = 0x82E8E008; continue 'dispatch;
	}
            }
            0x82E8DFEC => {
    //   block [0x82E8DFEC..0x82E8DFFC)
	// 82E8DFEC: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E8DFF0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82E8DFF4: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8DFF8: 4198FFA0  blt cr6, 0x82e8df98
	if ctx.cr[6].lt {
	pc = 0x82E8DF98; continue 'dispatch;
	}
	pc = 0x82E8DFFC; continue 'dispatch;
            }
            0x82E8DFFC => {
    //   block [0x82E8DFFC..0x82E8E000)
	// 82E8DFFC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82E8E000; continue 'dispatch;
            }
            0x82E8E000 => {
    //   block [0x82E8E000..0x82E8E008)
	// 82E8E000: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E8E004: 4BE1B454  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82E8E008 => {
    //   block [0x82E8E008..0x82E8E010)
	// 82E8E008: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8E00C: 4BFFFFF4  b 0x82e8e000
	pc = 0x82E8E000; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8E010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8E010 size=24
    let mut pc: u32 = 0x82E8E010;
    'dispatch: loop {
        match pc {
            0x82E8E010 => {
    //   block [0x82E8E010..0x82E8E028)
	// 82E8E010: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8E014: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E8E018: C00B0BEC  lfs f0, 0xbec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8E01C: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E8E020: 9143000C  stw r10, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82E8E024: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8E028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8E028 size=48
    let mut pc: u32 = 0x82E8E028;
    'dispatch: loop {
        match pc {
            0x82E8E028 => {
    //   block [0x82E8E028..0x82E8E058)
	// 82E8E028: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8E02C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8E030: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8E034: 396B3EF0  addi r11, r11, 0x3ef0
	ctx.r[11].s64 = ctx.r[11].s64 + 16112;
	// 82E8E038: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8E03C: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82E8E040: 7C0A5C2E  lfsx f0, r10, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8E044: 7DA95C2E  lfsx f13, r9, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8E048: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E8E04C: 4098000C  bge cr6, 0x82e8e058
	if !ctx.cr[6].lt {
		sub_82E8E058(ctx, base);
		return;
	}
	// 82E8E050: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82E8E054: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8E058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8E058 size=20
    let mut pc: u32 = 0x82E8E058;
    'dispatch: loop {
        match pc {
            0x82E8E058 => {
    //   block [0x82E8E058..0x82E8E06C)
	// 82E8E058: FF006800  fcmpu cr6, f0, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E8E05C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E8E060: 4D990020  bgtlr cr6
	if ctx.cr[6].gt { return; }
	// 82E8E064: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8E068: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8E070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8E070 size=276
    let mut pc: u32 = 0x82E8E070;
    'dispatch: loop {
        match pc {
            0x82E8E070 => {
    //   block [0x82E8E070..0x82E8E0A0)
	// 82E8E070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8E074: 4BE1B391  bl 0x82ca9404
	ctx.lr = 0x82E8E078;
	sub_82CA93D0(ctx, base);
	// 82E8E078: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8E07C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8E080: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8E084: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82E8E088: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E8E08C: 3BABDAC0  addi r29, r11, -0x2540
	ctx.r[29].s64 = ctx.r[11].s64 + -9536;
	// 82E8E090: 409900AC  ble cr6, 0x82e8e13c
	if !ctx.cr[6].gt {
	pc = 0x82E8E13C; continue 'dispatch;
	}
	// 82E8E094: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82E8E098: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E8E09C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	pc = 0x82E8E0A0; continue 'dispatch;
            }
            0x82E8E0A0 => {
    //   block [0x82E8E0A0..0x82E8E0CC)
	// 82E8E0A0: 817D004C  lwz r11, 0x4c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 82E8E0A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8E0A8: 419A0024  beq cr6, 0x82e8e0cc
	if ctx.cr[6].eq {
	pc = 0x82E8E0CC; continue 'dispatch;
	}
	// 82E8E0AC: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E8E0B0: 38C000FF  li r6, 0xff
	ctx.r[6].s64 = 255;
	// 82E8E0B4: 38A000FF  li r5, 0xff
	ctx.r[5].s64 = 255;
	// 82E8E0B8: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82E8E0BC: 817D004C  lwz r11, 0x4c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 82E8E0C0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82E8E0C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8E0C8: 4E800421  bctrl
	ctx.lr = 0x82E8E0CC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8E0CC => {
    //   block [0x82E8E0CC..0x82E8E0F8)
	// 82E8E0CC: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E8E0D0: 7D6BD82E  lwzx r11, r11, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82E8E0D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8E0D8: 817D0048  lwz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 82E8E0DC: 409A001C  bne cr6, 0x82e8e0f8
	if !ctx.cr[6].eq {
	pc = 0x82E8E0F8; continue 'dispatch;
	}
	// 82E8E0E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8E0E4: 419A0040  beq cr6, 0x82e8e124
	if ctx.cr[6].eq {
	pc = 0x82E8E124; continue 'dispatch;
	}
	// 82E8E0E8: 38E000FF  li r7, 0xff
	ctx.r[7].s64 = 255;
	// 82E8E0EC: 38C000FF  li r6, 0xff
	ctx.r[6].s64 = 255;
	// 82E8E0F0: 38A000FF  li r5, 0xff
	ctx.r[5].s64 = 255;
	// 82E8E0F4: 48000018  b 0x82e8e10c
	pc = 0x82E8E10C; continue 'dispatch;
            }
            0x82E8E0F8 => {
    //   block [0x82E8E0F8..0x82E8E10C)
	// 82E8E0F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8E0FC: 419A0028  beq cr6, 0x82e8e124
	if ctx.cr[6].eq {
	pc = 0x82E8E124; continue 'dispatch;
	}
	// 82E8E100: 38E00032  li r7, 0x32
	ctx.r[7].s64 = 50;
	// 82E8E104: 38C000AF  li r6, 0xaf
	ctx.r[6].s64 = 175;
	// 82E8E108: 38A00032  li r5, 0x32
	ctx.r[5].s64 = 50;
	pc = 0x82E8E10C; continue 'dispatch;
            }
            0x82E8E10C => {
    //   block [0x82E8E10C..0x82E8E124)
	// 82E8E10C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E8E110: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82E8E114: 817D0048  lwz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 82E8E118: 3883000C  addi r4, r3, 0xc
	ctx.r[4].s64 = ctx.r[3].s64 + 12;
	// 82E8E11C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8E120: 4E800421  bctrl
	ctx.lr = 0x82E8E124;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8E124 => {
    //   block [0x82E8E124..0x82E8E13C)
	// 82E8E124: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8E128: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82E8E12C: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82E8E130: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 82E8E134: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82E8E138: 4198FF68  blt cr6, 0x82e8e0a0
	if ctx.cr[6].lt {
	pc = 0x82E8E0A0; continue 'dispatch;
	}
	pc = 0x82E8E13C; continue 'dispatch;
            }
            0x82E8E13C => {
    //   block [0x82E8E13C..0x82E8E17C)
	// 82E8E13C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8E140: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8E144: 41820038  beq 0x82e8e17c
	if ctx.cr[0].eq {
	pc = 0x82E8E17C; continue 'dispatch;
	}
	// 82E8E148: 815D004C  lwz r10, 0x4c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 82E8E14C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E8E150: 419A002C  beq cr6, 0x82e8e17c
	if ctx.cr[6].eq {
	pc = 0x82E8E17C; continue 'dispatch;
	}
	// 82E8E154: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E8E158: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82E8E15C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E8E160: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82E8E164: 38A000FF  li r5, 0xff
	ctx.r[5].s64 = 255;
	// 82E8E168: 386BFFF4  addi r3, r11, -0xc
	ctx.r[3].s64 = ctx.r[11].s64 + -12;
	// 82E8E16C: 817D004C  lwz r11, 0x4c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 82E8E170: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82E8E174: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8E178: 4E800421  bctrl
	ctx.lr = 0x82E8E17C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8E17C => {
    //   block [0x82E8E17C..0x82E8E184)
	// 82E8E17C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E8E180: 4BE1B2D4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8E188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8E188 size=24
    let mut pc: u32 = 0x82E8E188;
    'dispatch: loop {
        match pc {
            0x82E8E188 => {
    //   block [0x82E8E188..0x82E8E1A0)
	// 82E8E188: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8E18C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E8E190: C00B0BEC  lfs f0, 0xbec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8E194: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E8E198: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82E8E19C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8E1A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8E1A0 size=200
    let mut pc: u32 = 0x82E8E1A0;
    'dispatch: loop {
        match pc {
            0x82E8E1A0 => {
    //   block [0x82E8E1A0..0x82E8E1D8)
	// 82E8E1A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8E1A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8E1A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8E1AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8E1B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8E1B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8E1B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8E1BC: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E8E1C0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8E1C4: 41820014  beq 0x82e8e1d8
	if ctx.cr[0].eq {
	pc = 0x82E8E1D8; continue 'dispatch;
	}
	// 82E8E1C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8E1CC: 4B796635  bl 0x82624800
	ctx.lr = 0x82E8E1D0;
	sub_82624800(ctx, base);
	// 82E8E1D0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8E1D4: 41820078  beq 0x82e8e24c
	if ctx.cr[0].eq {
	pc = 0x82E8E24C; continue 'dispatch;
	}
	pc = 0x82E8E1D8; continue 'dispatch;
            }
            0x82E8E1D8 => {
    //   block [0x82E8E1D8..0x82E8E1F4)
	// 82E8E1D8: 897F0019  lbz r11, 0x19(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(25 as u32) ) } as u64;
	// 82E8E1DC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8E1E0: 41820014  beq 0x82e8e1f4
	if ctx.cr[0].eq {
	pc = 0x82E8E1F4; continue 'dispatch;
	}
	// 82E8E1E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8E1E8: 4B796E19  bl 0x82625000
	ctx.lr = 0x82E8E1EC;
	sub_82625000(ctx, base);
	// 82E8E1EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8E1F0: 4182005C  beq 0x82e8e24c
	if ctx.cr[0].eq {
	pc = 0x82E8E24C; continue 'dispatch;
	}
	pc = 0x82E8E1F4; continue 'dispatch;
            }
            0x82E8E1F4 => {
    //   block [0x82E8E1F4..0x82E8E24C)
	// 82E8E1F4: C1BF000C  lfs f13, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8E1F8: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8E1FC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E8E200: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8E204: C1BF0010  lfs f13, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8E208: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E8E20C: C15F0014  lfs f10, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E8E210: C19E000C  lfs f12, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8E214: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82E8E218: C17F0004  lfs f11, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8E21C: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8E220: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8E224: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8E228: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82E8E22C: 40980020  bge cr6, 0x82e8e24c
	if !ctx.cr[6].lt {
	pc = 0x82E8E24C; continue 'dispatch;
	}
	// 82E8E230: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8E234: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E8E238: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82E8E23C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8E240: C1AB0C18  lfs f13, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8E244: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E8E248: 419A0008  beq cr6, 0x82e8e250
	if ctx.cr[6].eq {
	pc = 0x82E8E250; continue 'dispatch;
	}
	pc = 0x82E8E24C; continue 'dispatch;
            }
            0x82E8E24C => {
    //   block [0x82E8E24C..0x82E8E250)
	// 82E8E24C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82E8E250; continue 'dispatch;
            }
            0x82E8E250 => {
    //   block [0x82E8E250..0x82E8E268)
	// 82E8E250: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8E254: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8E258: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8E25C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8E260: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8E264: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8E268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8E268 size=276
    let mut pc: u32 = 0x82E8E268;
    'dispatch: loop {
        match pc {
            0x82E8E268 => {
    //   block [0x82E8E268..0x82E8E29C)
	// 82E8E268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8E26C: 4BE1B199  bl 0x82ca9404
	ctx.lr = 0x82E8E270;
	sub_82CA93D0(ctx, base);
	// 82E8E270: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82E8E274: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8E278: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8E27C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82E8E280: 8B7F0024  lbz r27, 0x24(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E8E284: 281B0000  cmplwi r27, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8E288: 41820014  beq 0x82e8e29c
	if ctx.cr[0].eq {
	pc = 0x82E8E29C; continue 'dispatch;
	}
	// 82E8E28C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E8E290: 4B796571  bl 0x82624800
	ctx.lr = 0x82E8E294;
	sub_82624800(ctx, base);
	// 82E8E294: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8E298: 418200D4  beq 0x82e8e36c
	if ctx.cr[0].eq {
	pc = 0x82E8E36C; continue 'dispatch;
	}
	pc = 0x82E8E29C; continue 'dispatch;
            }
            0x82E8E29C => {
    //   block [0x82E8E29C..0x82E8E2B8)
	// 82E8E29C: 897F0025  lbz r11, 0x25(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(37 as u32) ) } as u64;
	// 82E8E2A0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8E2A4: 41820014  beq 0x82e8e2b8
	if ctx.cr[0].eq {
	pc = 0x82E8E2B8; continue 'dispatch;
	}
	// 82E8E2A8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E8E2AC: 4B796D55  bl 0x82625000
	ctx.lr = 0x82E8E2B0;
	sub_82625000(ctx, base);
	// 82E8E2B0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8E2B4: 418200B8  beq 0x82e8e36c
	if ctx.cr[0].eq {
	pc = 0x82E8E36C; continue 'dispatch;
	}
	pc = 0x82E8E2B8; continue 'dispatch;
            }
            0x82E8E2B8 => {
    //   block [0x82E8E2B8..0x82E8E324)
	// 82E8E2B8: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 82E8E2BC: C17F0004  lfs f11, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8E2C0: 3BBF0010  addi r29, r31, 0x10
	ctx.r[29].s64 = ctx.r[31].s64 + 16;
	// 82E8E2C4: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8E2C8: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8E2CC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E8E2D0: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8E2D4: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8E2D8: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E8E2DC: C15D0008  lfs f10, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E8E2E0: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8E2E4: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82E8E2E8: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8E2EC: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8E2F0: EFEC033A  fmadds f31, f12, f12, f0
	ctx.f[31].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8E2F4: FF1F5800  fcmpu cr6, f31, f11
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[11].f64);
	// 82E8E2F8: 40980074  bge cr6, 0x82e8e36c
	if !ctx.cr[6].lt {
	pc = 0x82E8E36C; continue 'dispatch;
	}
	// 82E8E2FC: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82E8E300: 419A0024  beq cr6, 0x82e8e324
	if ctx.cr[6].eq {
	pc = 0x82E8E324; continue 'dispatch;
	}
	// 82E8E304: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82E8E308: 80FF0020  lwz r7, 0x20(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E8E30C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8E310: C03F001C  lfs f1, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E8E314: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8E318: 4B7A11F9  bl 0x8262f510
	ctx.lr = 0x82E8E31C;
	sub_8262F510(ctx, base);
	// 82E8E31C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8E320: 4082004C  bne 0x82e8e36c
	if !ctx.cr[0].eq {
	pc = 0x82E8E36C; continue 'dispatch;
	}
	pc = 0x82E8E324; continue 'dispatch;
            }
            0x82E8E324 => {
    //   block [0x82E8E324..0x82E8E350)
	// 82E8E324: 897F0025  lbz r11, 0x25(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(37 as u32) ) } as u64;
	// 82E8E328: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8E32C: 41820024  beq 0x82e8e350
	if ctx.cr[0].eq {
	pc = 0x82E8E350; continue 'dispatch;
	}
	// 82E8E330: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82E8E334: 80FF0020  lwz r7, 0x20(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E8E338: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E8E33C: C03F001C  lfs f1, 0x1c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E8E340: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8E344: 4B7A11CD  bl 0x8262f510
	ctx.lr = 0x82E8E348;
	sub_8262F510(ctx, base);
	// 82E8E348: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8E34C: 40820020  bne 0x82e8e36c
	if !ctx.cr[0].eq {
	pc = 0x82E8E36C; continue 'dispatch;
	}
	pc = 0x82E8E350; continue 'dispatch;
            }
            0x82E8E350 => {
    //   block [0x82E8E350..0x82E8E36C)
	// 82E8E350: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8E354: D3FF0004  stfs f31, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E8E358: 939F000C  stw r28, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82E8E35C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8E360: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8E364: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82E8E368: 419A0008  beq cr6, 0x82e8e370
	if ctx.cr[6].eq {
	pc = 0x82E8E370; continue 'dispatch;
	}
	pc = 0x82E8E36C; continue 'dispatch;
            }
            0x82E8E36C => {
    //   block [0x82E8E36C..0x82E8E370)
	// 82E8E36C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82E8E370; continue 'dispatch;
            }
            0x82E8E370 => {
    //   block [0x82E8E370..0x82E8E37C)
	// 82E8E370: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E8E374: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82E8E378: 4BE1B0DC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8E380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8E380 size=156
    let mut pc: u32 = 0x82E8E380;
    'dispatch: loop {
        match pc {
            0x82E8E380 => {
    //   block [0x82E8E380..0x82E8E3EC)
	// 82E8E380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8E384: 4BE1B085  bl 0x82ca9408
	ctx.lr = 0x82E8E388;
	sub_82CA93D0(ctx, base);
	// 82E8E388: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8E38C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8E390: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8E394: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82E8E398: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82E8E39C: 396B98B0  addi r11, r11, -0x6750
	ctx.r[11].s64 = ctx.r[11].s64 + -26448;
	// 82E8E3A0: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8E3A4: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82E8E3A8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E8E3AC: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8E3B0: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82E8E3B4: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82E8E3B8: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82E8E3BC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E8E3C0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82E8E3C4: 419A0028  beq cr6, 0x82e8e3ec
	if ctx.cr[6].eq {
	pc = 0x82E8E3EC; continue 'dispatch;
	}
	// 82E8E3C8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8E3CC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E8E3D0: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82E8E3D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8E3D8: 4B35A2A1  bl 0x821e8678
	ctx.lr = 0x82E8E3DC;
	sub_821E8678(ctx, base);
	// 82E8E3DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8E3E0: 4182000C  beq 0x82e8e3ec
	if ctx.cr[0].eq {
	pc = 0x82E8E3EC; continue 'dispatch;
	}
	// 82E8E3E4: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8E3E8: 4800000C  b 0x82e8e3f4
	pc = 0x82E8E3F4; continue 'dispatch;
            }
            0x82E8E3EC => {
    //   block [0x82E8E3EC..0x82E8E3F4)
	// 82E8E3EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8E3F0: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82E8E3F4; continue 'dispatch;
            }
            0x82E8E3F4 => {
    //   block [0x82E8E3F4..0x82E8E41C)
	// 82E8E3F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8E3F8: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82E8E3FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E8E400: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 82E8E404: 9BA10074  stb r29, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[29].u8 ) };
	// 82E8E408: 9B810075  stb r28, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[28].u8 ) };
	// 82E8E40C: 4BFFFAA5  bl 0x82e8deb0
	ctx.lr = 0x82E8E410;
	sub_82E8DEB0(ctx, base);
	// 82E8E410: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E8E414: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E8E418: 4BE1B040  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8E420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8E420 size=356
    let mut pc: u32 = 0x82E8E420;
    'dispatch: loop {
        match pc {
            0x82E8E420 => {
    //   block [0x82E8E420..0x82E8E48C)
	// 82E8E420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8E424: 4BE1AFE1  bl 0x82ca9404
	ctx.lr = 0x82E8E428;
	sub_82CA93D0(ctx, base);
	// 82E8E428: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82E8E42C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8E430: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8E434: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82E8E438: 3BBF0010  addi r29, r31, 0x10
	ctx.r[29].s64 = ctx.r[31].s64 + 16;
	// 82E8E43C: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 82E8E440: 897F0024  lbz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E8E444: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8E448: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8E44C: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8E450: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E8E454: C19D0008  lfs f12, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8E458: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8E45C: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E8E460: C17E0004  lfs f11, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8E464: C19D0004  lfs f12, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8E468: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E8E46C: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8E470: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8E474: EFEC033A  fmadds f31, f12, f12, f0
	ctx.f[31].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8E478: C01F0028  lfs f0, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8E47C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82E8E480: 4182000C  beq 0x82e8e48c
	if ctx.cr[0].eq {
	pc = 0x82E8E48C; continue 'dispatch;
	}
	// 82E8E484: 4198000C  blt cr6, 0x82e8e490
	if ctx.cr[6].lt {
	pc = 0x82E8E490; continue 'dispatch;
	}
	// 82E8E488: 480000EC  b 0x82e8e574
	pc = 0x82E8E574; continue 'dispatch;
            }
            0x82E8E48C => {
    //   block [0x82E8E48C..0x82E8E490)
	// 82E8E48C: 419800E8  blt cr6, 0x82e8e574
	if ctx.cr[6].lt {
	pc = 0x82E8E574; continue 'dispatch;
	}
	pc = 0x82E8E490; continue 'dispatch;
            }
            0x82E8E490 => {
    //   block [0x82E8E490..0x82E8E4AC)
	// 82E8E490: 8B7F002C  lbz r27, 0x2c(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E8E494: 281B0000  cmplwi r27, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8E498: 41820014  beq 0x82e8e4ac
	if ctx.cr[0].eq {
	pc = 0x82E8E4AC; continue 'dispatch;
	}
	// 82E8E49C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E8E4A0: 4B796361  bl 0x82624800
	ctx.lr = 0x82E8E4A4;
	sub_82624800(ctx, base);
	// 82E8E4A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8E4A8: 418200CC  beq 0x82e8e574
	if ctx.cr[0].eq {
	pc = 0x82E8E574; continue 'dispatch;
	}
	pc = 0x82E8E4AC; continue 'dispatch;
            }
            0x82E8E4AC => {
    //   block [0x82E8E4AC..0x82E8E4C8)
	// 82E8E4AC: 897F002D  lbz r11, 0x2d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(45 as u32) ) } as u64;
	// 82E8E4B0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8E4B4: 41820014  beq 0x82e8e4c8
	if ctx.cr[0].eq {
	pc = 0x82E8E4C8; continue 'dispatch;
	}
	// 82E8E4B8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E8E4BC: 4B796B45  bl 0x82625000
	ctx.lr = 0x82E8E4C0;
	sub_82625000(ctx, base);
	// 82E8E4C0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8E4C4: 418200B0  beq 0x82e8e574
	if ctx.cr[0].eq {
	pc = 0x82E8E574; continue 'dispatch;
	}
	pc = 0x82E8E4C8; continue 'dispatch;
            }
            0x82E8E4C8 => {
    //   block [0x82E8E4C8..0x82E8E52C)
	// 82E8E4C8: C1BF0014  lfs f13, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8E4CC: C19C0008  lfs f12, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8E4D0: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E8E4D4: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8E4D8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E8E4DC: 41990098  bgt cr6, 0x82e8e574
	if ctx.cr[6].gt {
	pc = 0x82E8E574; continue 'dispatch;
	}
	// 82E8E4E0: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82E8E4E4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E8E4E8: 4198008C  blt cr6, 0x82e8e574
	if ctx.cr[6].lt {
	pc = 0x82E8E574; continue 'dispatch;
	}
	// 82E8E4EC: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8E4F0: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82E8E4F4: 40980080  bge cr6, 0x82e8e574
	if !ctx.cr[6].lt {
	pc = 0x82E8E574; continue 'dispatch;
	}
	// 82E8E4F8: 897F0025  lbz r11, 0x25(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(37 as u32) ) } as u64;
	// 82E8E4FC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8E500: 41820058  beq 0x82e8e558
	if ctx.cr[0].eq {
	pc = 0x82E8E558; continue 'dispatch;
	}
	// 82E8E504: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82E8E508: 419A0024  beq cr6, 0x82e8e52c
	if ctx.cr[6].eq {
	pc = 0x82E8E52C; continue 'dispatch;
	}
	// 82E8E50C: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82E8E510: 80FF0020  lwz r7, 0x20(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E8E514: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8E518: C03F001C  lfs f1, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E8E51C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E8E520: 4B7A0FF1  bl 0x8262f510
	ctx.lr = 0x82E8E524;
	sub_8262F510(ctx, base);
	// 82E8E524: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8E528: 4082004C  bne 0x82e8e574
	if !ctx.cr[0].eq {
	pc = 0x82E8E574; continue 'dispatch;
	}
	pc = 0x82E8E52C; continue 'dispatch;
            }
            0x82E8E52C => {
    //   block [0x82E8E52C..0x82E8E558)
	// 82E8E52C: 897F002D  lbz r11, 0x2d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(45 as u32) ) } as u64;
	// 82E8E530: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8E534: 41820024  beq 0x82e8e558
	if ctx.cr[0].eq {
	pc = 0x82E8E558; continue 'dispatch;
	}
	// 82E8E538: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82E8E53C: 80FF0020  lwz r7, 0x20(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E8E540: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E8E544: C03F001C  lfs f1, 0x1c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E8E548: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8E54C: 4B7A0FC5  bl 0x8262f510
	ctx.lr = 0x82E8E550;
	sub_8262F510(ctx, base);
	// 82E8E550: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8E554: 40820020  bne 0x82e8e574
	if !ctx.cr[0].eq {
	pc = 0x82E8E574; continue 'dispatch;
	}
	pc = 0x82E8E558; continue 'dispatch;
            }
            0x82E8E558 => {
    //   block [0x82E8E558..0x82E8E574)
	// 82E8E558: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8E55C: D3FF0004  stfs f31, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E8E560: 939F000C  stw r28, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82E8E564: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8E568: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8E56C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82E8E570: 419A0008  beq cr6, 0x82e8e578
	if ctx.cr[6].eq {
	pc = 0x82E8E578; continue 'dispatch;
	}
	pc = 0x82E8E574; continue 'dispatch;
            }
            0x82E8E574 => {
    //   block [0x82E8E574..0x82E8E578)
	// 82E8E574: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82E8E578; continue 'dispatch;
            }
            0x82E8E578 => {
    //   block [0x82E8E578..0x82E8E584)
	// 82E8E578: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E8E57C: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82E8E580: 4BE1AED4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8E588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8E588 size=220
    let mut pc: u32 = 0x82E8E588;
    'dispatch: loop {
        match pc {
            0x82E8E588 => {
    //   block [0x82E8E588..0x82E8E610)
	// 82E8E588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8E58C: 4BE1AE7D  bl 0x82ca9408
	ctx.lr = 0x82E8E590;
	sub_82CA93D0(ctx, base);
	// 82E8E590: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82E8E594: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8E598: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82E8E59C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82E8E5A0: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82E8E5A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8E5A8: 388AC5C8  addi r4, r10, -0x3a38
	ctx.r[4].s64 = ctx.r[10].s64 + -14904;
	// 82E8E5AC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82E8E5B0: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8E5B4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82E8E5B8: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82E8E5BC: 394A98C4  addi r10, r10, -0x673c
	ctx.r[10].s64 = ctx.r[10].s64 + -26428;
	// 82E8E5C0: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8E5C4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E8E5C8: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82E8E5CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8E5D0: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8E5D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E8E5D8: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8E5DC: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 82E8E5E0: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8E5E4: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82E8E5E8: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82E8E5EC: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 82E8E5F0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82E8E5F4: 99610074  stb r11, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u8 ) };
	// 82E8E5F8: 99610075  stb r11, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[11].u8 ) };
	// 82E8E5FC: 4B35A07D  bl 0x821e8678
	ctx.lr = 0x82E8E600;
	sub_821E8678(ctx, base);
	// 82E8E600: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8E604: 4182000C  beq 0x82e8e610
	if ctx.cr[0].eq {
	pc = 0x82E8E610; continue 'dispatch;
	}
	// 82E8E608: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8E60C: 4800000C  b 0x82e8e618
	pc = 0x82E8E618; continue 'dispatch;
            }
            0x82E8E610 => {
    //   block [0x82E8E610..0x82E8E618)
	// 82E8E610: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8E614: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82E8E618; continue 'dispatch;
            }
            0x82E8E618 => {
    //   block [0x82E8E618..0x82E8E654)
	// 82E8E618: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E8E61C: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82E8E620: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E8E624: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E8E628: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82E8E62C: 9BA1007C  stb r29, 0x7c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[29].u8 ) };
	// 82E8E630: 9B81007D  stb r28, 0x7d(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(125 as u32), ctx.r[28].u8 ) };
	// 82E8E634: 4BFFF87D  bl 0x82e8deb0
	ctx.lr = 0x82E8E638;
	sub_82E8DEB0(ctx, base);
	// 82E8E638: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E8E63C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8E640: 409A0014  bne cr6, 0x82e8e654
	if !ctx.cr[6].eq {
	pc = 0x82E8E654; continue 'dispatch;
	}
	// 82E8E644: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E8E648: 99610075  stb r11, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[11].u8 ) };
	// 82E8E64C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E8E650: 4BFFF861  bl 0x82e8deb0
	ctx.lr = 0x82E8E654;
	sub_82E8DEB0(ctx, base);
	pc = 0x82E8E654; continue 'dispatch;
            }
            0x82E8E654 => {
    //   block [0x82E8E654..0x82E8E664)
	// 82E8E654: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E8E658: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82E8E65C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82E8E660: 4BE1ADF8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8E668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8E668 size=708
    let mut pc: u32 = 0x82E8E668;
    'dispatch: loop {
        match pc {
            0x82E8E668 => {
    //   block [0x82E8E668..0x82E8E6AC)
	// 82E8E668: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8E66C: 4BE1AD81  bl 0x82ca93ec
	ctx.lr = 0x82E8E670;
	sub_82CA93D0(ctx, base);
	// 82E8E670: DBE1FF98  stfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 82E8E674: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8E678: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82E8E67C: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 82E8E680: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 82E8E684: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82E8E688: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82E8E68C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82E8E690: 7CF63B78  mr r22, r7
	ctx.r[22].u64 = ctx.r[7].u64;
	// 82E8E694: 7D154378  mr r21, r8
	ctx.r[21].u64 = ctx.r[8].u64;
	// 82E8E698: 48008F59  bl 0x82e975f0
	ctx.lr = 0x82E8E69C;
	sub_82E975F0(ctx, base);
	// 82E8E69C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82E8E6A0: 2B1903E8  cmplwi cr6, r25, 0x3e8
	ctx.cr[6].compare_u32(ctx.r[25].u32, 1000 as u32, &mut ctx.xer);
	// 82E8E6A4: 40990008  ble cr6, 0x82e8e6ac
	if !ctx.cr[6].gt {
	pc = 0x82E8E6AC; continue 'dispatch;
	}
	// 82E8E6A8: 3B2003E8  li r25, 0x3e8
	ctx.r[25].s64 = 1000;
	pc = 0x82E8E6AC; continue 'dispatch;
            }
            0x82E8E6AC => {
    //   block [0x82E8E6AC..0x82E8E6CC)
	// 82E8E6AC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8E6B0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82E8E6B4: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82E8E6B8: 3BCB2F50  addi r30, r11, 0x2f50
	ctx.r[30].s64 = ctx.r[11].s64 + 12112;
	// 82E8E6BC: 419A009C  beq cr6, 0x82e8e758
	if ctx.cr[6].eq {
	pc = 0x82E8E758; continue 'dispatch;
	}
	// 82E8E6C0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E8E6C4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E8E6C8: 7CDE5850  subf r6, r30, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	pc = 0x82E8E6CC; continue 'dispatch;
            }
            0x82E8E6CC => {
    //   block [0x82E8E6CC..0x82E8E704)
	// 82E8E6CC: 7CEAF214  add r7, r10, r30
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82E8E6D0: 81380004  lwz r9, 4(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8E6D4: 7D66382E  lwzx r11, r6, r7
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82E8E6D8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8E6DC: 419A0028  beq cr6, 0x82e8e704
	if ctx.cr[6].eq {
	pc = 0x82E8E704; continue 'dispatch;
	}
	// 82E8E6E0: 80A9000C  lwz r5, 0xc(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8E6E4: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82E8E6E8: 4098001C  bge cr6, 0x82e8e704
	if !ctx.cr[6].lt {
	pc = 0x82E8E704; continue 'dispatch;
	}
	// 82E8E6EC: 81290018  lwz r9, 0x18(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E8E6F0: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82E8E6F4: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82E8E6F8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8E6FC: 2F09FFFF  cmpwi cr6, r9, -1
	ctx.cr[6].compare_i32(ctx.r[9].s32, -1, &mut ctx.xer);
	// 82E8E700: 409A0008  bne cr6, 0x82e8e708
	if !ctx.cr[6].eq {
	pc = 0x82E8E708; continue 'dispatch;
	}
	pc = 0x82E8E704; continue 'dispatch;
            }
            0x82E8E704 => {
    //   block [0x82E8E704..0x82E8E708)
	// 82E8E704: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82E8E708; continue 'dispatch;
            }
            0x82E8E708 => {
    //   block [0x82E8E708..0x82E8E758)
	// 82E8E708: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 82E8E70C: 38BE0FA0  addi r5, r30, 0xfa0
	ctx.r[5].s64 = ctx.r[30].s64 + 4000;
	// 82E8E710: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82E8E714: 7F08C840  cmplw cr6, r8, r25
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82E8E718: 91270000  stw r9, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E8E71C: C16B0008  lfs f11, 8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8E720: C01A0004  lfs f0, 4(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8E724: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E8E728: C1BA0008  lfs f13, 8(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8E72C: C14B000C  lfs f10, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E8E730: EDAD5028  fsubs f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82E8E734: C19A0000  lfs f12, 0(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8E738: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8E73C: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E8E740: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8E744: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8E748: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8E74C: 7C0A2D2E  stfsx f0, r10, r5
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[5].u32), tmp.u32) };
	// 82E8E750: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82E8E754: 4198FF78  blt cr6, 0x82e8e6cc
	if ctx.cr[6].lt {
	pc = 0x82E8E6CC; continue 'dispatch;
	}
	pc = 0x82E8E758; continue 'dispatch;
            }
            0x82E8E758 => {
    //   block [0x82E8E758..0x82E8E794)
	// 82E8E758: 3D6082E9  lis r11, -0x7d17
	ctx.r[11].s64 = -2098659328;
	// 82E8E75C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82E8E760: 38CBE028  addi r6, r11, -0x1fd8
	ctx.r[6].s64 = ctx.r[11].s64 + -8152;
	// 82E8E764: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82E8E768: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8E76C: 4BE1D44D  bl 0x82cabbb8
	ctx.lr = 0x82E8E770;
	sub_82CABBB8(ctx, base);
	// 82E8E770: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8E774: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E8E778: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82E8E77C: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82E8E780: 4B359EF9  bl 0x821e8678
	ctx.lr = 0x82E8E784;
	sub_821E8678(ctx, base);
	// 82E8E784: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8E788: 4182000C  beq 0x82e8e794
	if ctx.cr[0].eq {
	pc = 0x82E8E794; continue 'dispatch;
	}
	// 82E8E78C: C3E30004  lfs f31, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E8E790: 4800000C  b 0x82e8e79c
	pc = 0x82E8E79C; continue 'dispatch;
            }
            0x82E8E794 => {
    //   block [0x82E8E794..0x82E8E79C)
	// 82E8E794: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8E798: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82E8E79C; continue 'dispatch;
            }
            0x82E8E79C => {
    //   block [0x82E8E79C..0x82E8E7B0)
	// 82E8E79C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82E8E7A0: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82E8E7A4: 419A00D0  beq cr6, 0x82e8e874
	if ctx.cr[6].eq {
	pc = 0x82E8E874; continue 'dispatch;
	}
	// 82E8E7A8: 56DB063E  clrlwi r27, r22, 0x18
	ctx.r[27].u64 = ctx.r[22].u32 as u64 & 0x000000FFu64;
	// 82E8E7AC: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	pc = 0x82E8E7B0; continue 'dispatch;
            }
            0x82E8E7B0 => {
    //   block [0x82E8E7B0..0x82E8E7F0)
	// 82E8E7B0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8E7B4: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E8E7B8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E8E7BC: 81580004  lwz r10, 4(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8E7C0: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82E8E7C4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8E7C8: 419A0028  beq cr6, 0x82e8e7f0
	if ctx.cr[6].eq {
	pc = 0x82E8E7F0; continue 'dispatch;
	}
	// 82E8E7CC: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8E7D0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E8E7D4: 4098001C  bge cr6, 0x82e8e7f0
	if !ctx.cr[6].lt {
	pc = 0x82E8E7F0; continue 'dispatch;
	}
	// 82E8E7D8: 814A0018  lwz r10, 0x18(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E8E7DC: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82E8E7E0: 7FEB5214  add r31, r11, r10
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E8E7E4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8E7E8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8E7EC: 409A0008  bne cr6, 0x82e8e7f4
	if !ctx.cr[6].eq {
	pc = 0x82E8E7F4; continue 'dispatch;
	}
	pc = 0x82E8E7F0; continue 'dispatch;
            }
            0x82E8E7F0 => {
    //   block [0x82E8E7F0..0x82E8E7F4)
	// 82E8E7F0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82E8E7F4; continue 'dispatch;
            }
            0x82E8E7F4 => {
    //   block [0x82E8E7F4..0x82E8E82C)
	// 82E8E7F4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82E8E7F8: 419A0034  beq cr6, 0x82e8e82c
	if ctx.cr[6].eq {
	pc = 0x82E8E82C; continue 'dispatch;
	}
	// 82E8E7FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8E800: 4B796001  bl 0x82624800
	ctx.lr = 0x82E8E804;
	sub_82624800(ctx, base);
	// 82E8E804: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8E808: 4182005C  beq 0x82e8e864
	if ctx.cr[0].eq {
	pc = 0x82E8E864; continue 'dispatch;
	}
	// 82E8E80C: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 82E8E810: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E8E814: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82E8E818: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 82E8E81C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82E8E820: 4B7A0CF1  bl 0x8262f510
	ctx.lr = 0x82E8E824;
	sub_8262F510(ctx, base);
	// 82E8E824: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8E828: 4082003C  bne 0x82e8e864
	if !ctx.cr[0].eq {
	pc = 0x82E8E864; continue 'dispatch;
	}
	pc = 0x82E8E82C; continue 'dispatch;
            }
            0x82E8E82C => {
    //   block [0x82E8E82C..0x82E8E864)
	// 82E8E82C: 56AB063F  clrlwi. r11, r21, 0x18
	ctx.r[11].u64 = ctx.r[21].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8E830: 41820078  beq 0x82e8e8a8
	if ctx.cr[0].eq {
	pc = 0x82E8E8A8; continue 'dispatch;
	}
	// 82E8E834: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8E838: 4B7967C9  bl 0x82625000
	ctx.lr = 0x82E8E83C;
	sub_82625000(ctx, base);
	// 82E8E83C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8E840: 41820024  beq 0x82e8e864
	if ctx.cr[0].eq {
	pc = 0x82E8E864; continue 'dispatch;
	}
	// 82E8E844: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 82E8E848: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E8E84C: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82E8E850: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82E8E854: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82E8E858: 4B7A0CB9  bl 0x8262f510
	ctx.lr = 0x82E8E85C;
	sub_8262F510(ctx, base);
	// 82E8E85C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8E860: 41820048  beq 0x82e8e8a8
	if ctx.cr[0].eq {
	pc = 0x82E8E8A8; continue 'dispatch;
	}
	pc = 0x82E8E864; continue 'dispatch;
            }
            0x82E8E864 => {
    //   block [0x82E8E864..0x82E8E874)
	// 82E8E864: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82E8E868: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82E8E86C: 7F1CC840  cmplw cr6, r28, r25
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82E8E870: 4198FF40  blt cr6, 0x82e8e7b0
	if ctx.cr[6].lt {
	pc = 0x82E8E7B0; continue 'dispatch;
	}
	pc = 0x82E8E874; continue 'dispatch;
            }
            0x82E8E874 => {
    //   block [0x82E8E874..0x82E8E888)
	// 82E8E874: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82E8E878: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82E8E87C: 419A00A0  beq cr6, 0x82e8e91c
	if ctx.cr[6].eq {
	pc = 0x82E8E91C; continue 'dispatch;
	}
	// 82E8E880: 83B80004  lwz r29, 4(r24)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8E884: 56DB063E  clrlwi r27, r22, 0x18
	ctx.r[27].u64 = ctx.r[22].u32 as u64 & 0x000000FFu64;
	pc = 0x82E8E888; continue 'dispatch;
            }
            0x82E8E888 => {
    //   block [0x82E8E888..0x82E8E8A0)
	// 82E8E888: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8E88C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E8E890: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E8E894: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E8E898: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8E89C: 409A0014  bne cr6, 0x82e8e8b0
	if !ctx.cr[6].eq {
	pc = 0x82E8E8B0; continue 'dispatch;
	}
	pc = 0x82E8E8A0; continue 'dispatch;
            }
            0x82E8E8A0 => {
    //   block [0x82E8E8A0..0x82E8E8A8)
	// 82E8E8A0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82E8E8A4: 48000038  b 0x82e8e8dc
	pc = 0x82E8E8DC; continue 'dispatch;
            }
            0x82E8E8A8 => {
    //   block [0x82E8E8A8..0x82E8E8B0)
	// 82E8E8A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8E8AC: 48000074  b 0x82e8e920
	pc = 0x82E8E920; continue 'dispatch;
            }
            0x82E8E8B0 => {
    //   block [0x82E8E8B0..0x82E8E8DC)
	// 82E8E8B0: 815D000C  lwz r10, 0xc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8E8B4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E8E8B8: 4098FFE8  bge cr6, 0x82e8e8a0
	if !ctx.cr[6].lt {
	pc = 0x82E8E8A0; continue 'dispatch;
	}
	// 82E8E8BC: 815D0018  lwz r10, 0x18(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E8E8C0: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82E8E8C4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E8E8C8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82E8E8CC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8E8D0: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82E8E8D4: 419A0008  beq cr6, 0x82e8e8dc
	if ctx.cr[6].eq {
	pc = 0x82E8E8DC; continue 'dispatch;
	}
	// 82E8E8D8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	pc = 0x82E8E8DC; continue 'dispatch;
            }
            0x82E8E8DC => {
    //   block [0x82E8E8DC..0x82E8E8F4)
	// 82E8E8DC: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82E8E8E0: 419A0014  beq cr6, 0x82e8e8f4
	if ctx.cr[6].eq {
	pc = 0x82E8E8F4; continue 'dispatch;
	}
	// 82E8E8E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8E8E8: 4B795F19  bl 0x82624800
	ctx.lr = 0x82E8E8EC;
	sub_82624800(ctx, base);
	// 82E8E8EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8E8F0: 4182001C  beq 0x82e8e90c
	if ctx.cr[0].eq {
	pc = 0x82E8E90C; continue 'dispatch;
	}
	pc = 0x82E8E8F4; continue 'dispatch;
            }
            0x82E8E8F4 => {
    //   block [0x82E8E8F4..0x82E8E90C)
	// 82E8E8F4: 56AB063F  clrlwi. r11, r21, 0x18
	ctx.r[11].u64 = ctx.r[21].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8E8F8: 4182FFB0  beq 0x82e8e8a8
	if ctx.cr[0].eq {
	pc = 0x82E8E8A8; continue 'dispatch;
	}
	// 82E8E8FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8E900: 4B796701  bl 0x82625000
	ctx.lr = 0x82E8E904;
	sub_82625000(ctx, base);
	// 82E8E904: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8E908: 4082FFA0  bne 0x82e8e8a8
	if !ctx.cr[0].eq {
	pc = 0x82E8E8A8; continue 'dispatch;
	}
	pc = 0x82E8E90C; continue 'dispatch;
            }
            0x82E8E90C => {
    //   block [0x82E8E90C..0x82E8E91C)
	// 82E8E90C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82E8E910: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82E8E914: 7F1CC840  cmplw cr6, r28, r25
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82E8E918: 4198FF70  blt cr6, 0x82e8e888
	if ctx.cr[6].lt {
	pc = 0x82E8E888; continue 'dispatch;
	}
	pc = 0x82E8E91C; continue 'dispatch;
            }
            0x82E8E91C => {
    //   block [0x82E8E91C..0x82E8E920)
	// 82E8E91C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E8E920; continue 'dispatch;
            }
            0x82E8E920 => {
    //   block [0x82E8E920..0x82E8E92C)
	// 82E8E920: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82E8E924: CBE1FF98  lfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 82E8E928: 4BE1AB14  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8E930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8E930 size=548
    let mut pc: u32 = 0x82E8E930;
    'dispatch: loop {
        match pc {
            0x82E8E930 => {
    //   block [0x82E8E930..0x82E8E974)
	// 82E8E930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8E934: 4BE1AAC1  bl 0x82ca93f4
	ctx.lr = 0x82E8E938;
	sub_82CA93D0(ctx, base);
	// 82E8E938: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 82E8E93C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8E940: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82E8E944: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 82E8E948: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 82E8E94C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82E8E950: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82E8E954: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82E8E958: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 82E8E95C: 7D174378  mr r23, r8
	ctx.r[23].u64 = ctx.r[8].u64;
	// 82E8E960: 48008C91  bl 0x82e975f0
	ctx.lr = 0x82E8E964;
	sub_82E975F0(ctx, base);
	// 82E8E964: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82E8E968: 2B1C03E8  cmplwi cr6, r28, 0x3e8
	ctx.cr[6].compare_u32(ctx.r[28].u32, 1000 as u32, &mut ctx.xer);
	// 82E8E96C: 40990008  ble cr6, 0x82e8e974
	if !ctx.cr[6].gt {
	pc = 0x82E8E974; continue 'dispatch;
	}
	// 82E8E970: 3B8003E8  li r28, 0x3e8
	ctx.r[28].s64 = 1000;
	pc = 0x82E8E974; continue 'dispatch;
            }
            0x82E8E974 => {
    //   block [0x82E8E974..0x82E8E994)
	// 82E8E974: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8E978: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82E8E97C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82E8E980: 3BEB2F50  addi r31, r11, 0x2f50
	ctx.r[31].s64 = ctx.r[11].s64 + 12112;
	// 82E8E984: 419A009C  beq cr6, 0x82e8ea20
	if ctx.cr[6].eq {
	pc = 0x82E8EA20; continue 'dispatch;
	}
	// 82E8E988: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E8E98C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E8E990: 7CDF5850  subf r6, r31, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	pc = 0x82E8E994; continue 'dispatch;
            }
            0x82E8E994 => {
    //   block [0x82E8E994..0x82E8E9CC)
	// 82E8E994: 7CEAFA14  add r7, r10, r31
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82E8E998: 81390004  lwz r9, 4(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8E99C: 7D66382E  lwzx r11, r6, r7
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82E8E9A0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8E9A4: 419A0028  beq cr6, 0x82e8e9cc
	if ctx.cr[6].eq {
	pc = 0x82E8E9CC; continue 'dispatch;
	}
	// 82E8E9A8: 80A9000C  lwz r5, 0xc(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8E9AC: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82E8E9B0: 4098001C  bge cr6, 0x82e8e9cc
	if !ctx.cr[6].lt {
	pc = 0x82E8E9CC; continue 'dispatch;
	}
	// 82E8E9B4: 81290018  lwz r9, 0x18(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E8E9B8: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82E8E9BC: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82E8E9C0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8E9C4: 2F09FFFF  cmpwi cr6, r9, -1
	ctx.cr[6].compare_i32(ctx.r[9].s32, -1, &mut ctx.xer);
	// 82E8E9C8: 409A0008  bne cr6, 0x82e8e9d0
	if !ctx.cr[6].eq {
	pc = 0x82E8E9D0; continue 'dispatch;
	}
	pc = 0x82E8E9CC; continue 'dispatch;
            }
            0x82E8E9CC => {
    //   block [0x82E8E9CC..0x82E8E9D0)
	// 82E8E9CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82E8E9D0; continue 'dispatch;
            }
            0x82E8E9D0 => {
    //   block [0x82E8E9D0..0x82E8EA20)
	// 82E8E9D0: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 82E8E9D4: 38BF0FA0  addi r5, r31, 0xfa0
	ctx.r[5].s64 = ctx.r[31].s64 + 4000;
	// 82E8E9D8: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82E8E9DC: 7F08E040  cmplw cr6, r8, r28
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82E8E9E0: 91270000  stw r9, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E8E9E4: C16B0004  lfs f11, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8E9E8: C01A0000  lfs f0, 0(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8E9EC: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E8E9F0: C1BA0008  lfs f13, 8(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8E9F4: C14B000C  lfs f10, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E8E9F8: EDAD5028  fsubs f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82E8E9FC: C19A0004  lfs f12, 4(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8EA00: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8EA04: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E8EA08: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8EA0C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8EA10: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8EA14: 7C0A2D2E  stfsx f0, r10, r5
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[5].u32), tmp.u32) };
	// 82E8EA18: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82E8EA1C: 4198FF78  blt cr6, 0x82e8e994
	if ctx.cr[6].lt {
	pc = 0x82E8E994; continue 'dispatch;
	}
	pc = 0x82E8EA20; continue 'dispatch;
            }
            0x82E8EA20 => {
    //   block [0x82E8EA20..0x82E8EA5C)
	// 82E8EA20: 3D6082E9  lis r11, -0x7d17
	ctx.r[11].s64 = -2098659328;
	// 82E8EA24: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82E8EA28: 38CBE028  addi r6, r11, -0x1fd8
	ctx.r[6].s64 = ctx.r[11].s64 + -8152;
	// 82E8EA2C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E8EA30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8EA34: 4BE1D185  bl 0x82cabbb8
	ctx.lr = 0x82E8EA38;
	sub_82CABBB8(ctx, base);
	// 82E8EA38: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8EA3C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E8EA40: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82E8EA44: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82E8EA48: 4B359C31  bl 0x821e8678
	ctx.lr = 0x82E8EA4C;
	sub_821E8678(ctx, base);
	// 82E8EA4C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8EA50: 4182000C  beq 0x82e8ea5c
	if ctx.cr[0].eq {
	pc = 0x82E8EA5C; continue 'dispatch;
	}
	// 82E8EA54: C3E30004  lfs f31, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E8EA58: 4800000C  b 0x82e8ea64
	pc = 0x82E8EA64; continue 'dispatch;
            }
            0x82E8EA5C => {
    //   block [0x82E8EA5C..0x82E8EA64)
	// 82E8EA5C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8EA60: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82E8EA64; continue 'dispatch;
            }
            0x82E8EA64 => {
    //   block [0x82E8EA64..0x82E8EA78)
	// 82E8EA64: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E8EA68: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82E8EA6C: 419A00D0  beq cr6, 0x82e8eb3c
	if ctx.cr[6].eq {
	pc = 0x82E8EB3C; continue 'dispatch;
	}
	// 82E8EA70: 57DB063E  clrlwi r27, r30, 0x18
	ctx.r[27].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 82E8EA74: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	pc = 0x82E8EA78; continue 'dispatch;
            }
            0x82E8EA78 => {
    //   block [0x82E8EA78..0x82E8EAB8)
	// 82E8EA78: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8EA7C: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E8EA80: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E8EA84: 81590004  lwz r10, 4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8EA88: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82E8EA8C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8EA90: 419A0028  beq cr6, 0x82e8eab8
	if ctx.cr[6].eq {
	pc = 0x82E8EAB8; continue 'dispatch;
	}
	// 82E8EA94: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8EA98: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E8EA9C: 4098001C  bge cr6, 0x82e8eab8
	if !ctx.cr[6].lt {
	pc = 0x82E8EAB8; continue 'dispatch;
	}
	// 82E8EAA0: 814A0018  lwz r10, 0x18(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E8EAA4: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82E8EAA8: 7FEB5214  add r31, r11, r10
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E8EAAC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8EAB0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8EAB4: 409A0008  bne cr6, 0x82e8eabc
	if !ctx.cr[6].eq {
	pc = 0x82E8EABC; continue 'dispatch;
	}
	pc = 0x82E8EAB8; continue 'dispatch;
            }
            0x82E8EAB8 => {
    //   block [0x82E8EAB8..0x82E8EABC)
	// 82E8EAB8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82E8EABC; continue 'dispatch;
            }
            0x82E8EABC => {
    //   block [0x82E8EABC..0x82E8EAF4)
	// 82E8EABC: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82E8EAC0: 419A0034  beq cr6, 0x82e8eaf4
	if ctx.cr[6].eq {
	pc = 0x82E8EAF4; continue 'dispatch;
	}
	// 82E8EAC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8EAC8: 4B795D39  bl 0x82624800
	ctx.lr = 0x82E8EACC;
	sub_82624800(ctx, base);
	// 82E8EACC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8EAD0: 4182005C  beq 0x82e8eb2c
	if ctx.cr[0].eq {
	pc = 0x82E8EB2C; continue 'dispatch;
	}
	// 82E8EAD4: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 82E8EAD8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E8EADC: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82E8EAE0: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 82E8EAE4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82E8EAE8: 4B7A0A29  bl 0x8262f510
	ctx.lr = 0x82E8EAEC;
	sub_8262F510(ctx, base);
	// 82E8EAEC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8EAF0: 4082003C  bne 0x82e8eb2c
	if !ctx.cr[0].eq {
	pc = 0x82E8EB2C; continue 'dispatch;
	}
	pc = 0x82E8EAF4; continue 'dispatch;
            }
            0x82E8EAF4 => {
    //   block [0x82E8EAF4..0x82E8EB2C)
	// 82E8EAF4: 56EB063F  clrlwi. r11, r23, 0x18
	ctx.r[11].u64 = ctx.r[23].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8EAF8: 41820054  beq 0x82e8eb4c
	if ctx.cr[0].eq {
	pc = 0x82E8EB4C; continue 'dispatch;
	}
	// 82E8EAFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8EB00: 4B796501  bl 0x82625000
	ctx.lr = 0x82E8EB04;
	sub_82625000(ctx, base);
	// 82E8EB04: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8EB08: 41820024  beq 0x82e8eb2c
	if ctx.cr[0].eq {
	pc = 0x82E8EB2C; continue 'dispatch;
	}
	// 82E8EB0C: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 82E8EB10: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E8EB14: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82E8EB18: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82E8EB1C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82E8EB20: 4B7A09F1  bl 0x8262f510
	ctx.lr = 0x82E8EB24;
	sub_8262F510(ctx, base);
	// 82E8EB24: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8EB28: 41820024  beq 0x82e8eb4c
	if ctx.cr[0].eq {
	pc = 0x82E8EB4C; continue 'dispatch;
	}
	pc = 0x82E8EB2C; continue 'dispatch;
            }
            0x82E8EB2C => {
    //   block [0x82E8EB2C..0x82E8EB3C)
	// 82E8EB2C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82E8EB30: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82E8EB34: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82E8EB38: 4198FF40  blt cr6, 0x82e8ea78
	if ctx.cr[6].lt {
	pc = 0x82E8EA78; continue 'dispatch;
	}
	pc = 0x82E8EB3C; continue 'dispatch;
            }
            0x82E8EB3C => {
    //   block [0x82E8EB3C..0x82E8EB40)
	// 82E8EB3C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E8EB40; continue 'dispatch;
            }
            0x82E8EB40 => {
    //   block [0x82E8EB40..0x82E8EB4C)
	// 82E8EB40: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82E8EB44: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 82E8EB48: 4BE1A8FC  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82E8EB4C => {
    //   block [0x82E8EB4C..0x82E8EB54)
	// 82E8EB4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8EB50: 4BFFFFF0  b 0x82e8eb40
	pc = 0x82E8EB40; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8EB58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8EB58 size=484
    let mut pc: u32 = 0x82E8EB58;
    'dispatch: loop {
        match pc {
            0x82E8EB58 => {
    //   block [0x82E8EB58..0x82E8EB9C)
	// 82E8EB58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8EB5C: 4BE1A8AD  bl 0x82ca9408
	ctx.lr = 0x82E8EB60;
	sub_82CA93D0(ctx, base);
	// 82E8EB60: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82E8EB64: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82E8EB68: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8EB6C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E8EB70: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E8EB74: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E8EB78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8EB7C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E8EB80: 3B8BDAC0  addi r28, r11, -0x2540
	ctx.r[28].s64 = ctx.r[11].s64 + -9536;
	// 82E8EB84: 40990130  ble cr6, 0x82e8ecb4
	if !ctx.cr[6].gt {
	pc = 0x82E8ECB4; continue 'dispatch;
	}
	// 82E8EB88: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8EB8C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E8EB90: 3FE08334  lis r31, -0x7ccc
	ctx.r[31].s64 = -2093744128;
	// 82E8EB94: C3EB0A78  lfs f31, 0xa78(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2680 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E8EB98: C3CA0C14  lfs f30, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	pc = 0x82E8EB9C; continue 'dispatch;
            }
            0x82E8EB9C => {
    //   block [0x82E8EB9C..0x82E8EBC8)
	// 82E8EB9C: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 82E8EBA0: 419A0028  beq cr6, 0x82e8ebc8
	if ctx.cr[6].eq {
	pc = 0x82E8EBC8; continue 'dispatch;
	}
	// 82E8EBA4: 817D0028  lwz r11, 0x28(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E8EBA8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8EBAC: 4098001C  bge cr6, 0x82e8ebc8
	if !ctx.cr[6].lt {
	pc = 0x82E8EBC8; continue 'dispatch;
	}
	// 82E8EBB0: 817D0034  lwz r11, 0x34(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 82E8EBB4: 57CA1838  slwi r10, r30, 3
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8EBB8: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E8EBBC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8EBC0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8EBC4: 409A0008  bne cr6, 0x82e8ebcc
	if !ctx.cr[6].eq {
	pc = 0x82E8EBCC; continue 'dispatch;
	}
	pc = 0x82E8EBC8; continue 'dispatch;
            }
            0x82E8EBC8 => {
    //   block [0x82E8EBC8..0x82E8EBCC)
	// 82E8EBC8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82E8EBCC; continue 'dispatch;
            }
            0x82E8EBCC => {
    //   block [0x82E8EBCC..0x82E8EC4C)
	// 82E8EBCC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8EBD0: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8EBD4: 813F0718  lwz r9, 0x718(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E8EBD8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8EBDC: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8EBE0: 80CB0038  lwz r6, 0x38(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E8EBE4: 80AB003C  lwz r5, 0x3c(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82E8EBE8: 80EB0018  lwz r7, 0x18(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E8EBEC: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 82E8EBF0: 7D66502E  lwzx r11, r6, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E8EBF4: 7D45502E  lwzx r10, r5, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E8EBF8: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82E8EBFC: 1D4A0014  mulli r10, r10, 0x14
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 20 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82E8EC00: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82E8EC04: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 82E8EC08: 388A0004  addi r4, r10, 4
	ctx.r[4].s64 = ctx.r[10].s64 + 4;
	// 82E8EC0C: C12B000C  lfs f9, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E8EC10: C1840008  lfs f12, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8EC14: ED8C4828  fsubs f12, f12, f9
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 82E8EC18: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8EC1C: C14B0008  lfs f10, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E8EC20: EDA05028  fsubs f13, f0, f10
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 82E8EC24: C10B0004  lfs f8, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82E8EC28: C1640000  lfs f11, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8EC2C: ED6B4028  fsubs f11, f11, f8
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[8].f64) as f32) as f64);
	// 82E8EC30: EC0C0332  fmuls f0, f12, f12
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82E8EC34: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8EC38: EC0B02FA  fmadds f0, f11, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8EC3C: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82E8EC40: 4182000C  beq 0x82e8ec4c
	if ctx.cr[0].eq {
	pc = 0x82E8EC4C; continue 'dispatch;
	}
	// 82E8EC44: C0E9000C  lfs f7, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82E8EC48: 48000008  b 0x82e8ec50
	pc = 0x82E8EC50; continue 'dispatch;
            }
            0x82E8EC4C => {
    //   block [0x82E8EC4C..0x82E8EC50)
	// 82E8EC4C: FCE0F090  fmr f7, f30
	ctx.f[7].f64 = ctx.f[30].f64;
	pc = 0x82E8EC50; continue 'dispatch;
            }
            0x82E8EC50 => {
    //   block [0x82E8EC50..0x82E8ECA4)
	// 82E8EC50: ECE707F2  fmuls f7, f7, f31
	ctx.f[7].f64 = (((ctx.f[7].f64 * ctx.f[31].f64) as f32) as f64);
	// 82E8EC54: 817C0048  lwz r11, 0x48(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 82E8EC58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8EC5C: EC070024  fdivs f0, f7, f0
	ctx.f[0].f64 = ((ctx.f[7].f64 / ctx.f[0].f64) as f32) as f64;
	// 82E8EC60: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8EC64: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8EC68: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8EC6C: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82E8EC70: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E8EC74: ED89602A  fadds f12, f9, f12
	ctx.f[12].f64 = ((ctx.f[9].f64 + ctx.f[12].f64) as f32) as f64;
	// 82E8EC78: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E8EC7C: EC08002A  fadds f0, f8, f0
	ctx.f[0].f64 = ((ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64;
	// 82E8EC80: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E8EC84: 419A0020  beq cr6, 0x82e8eca4
	if ctx.cr[6].eq {
	pc = 0x82E8ECA4; continue 'dispatch;
	}
	// 82E8EC88: 38E000FF  li r7, 0xff
	ctx.r[7].s64 = 255;
	// 82E8EC8C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82E8EC90: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E8EC94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E8EC98: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E8EC9C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8ECA0: 4E800421  bctrl
	ctx.lr = 0x82E8ECA4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8ECA4 => {
    //   block [0x82E8ECA4..0x82E8ECB4)
	// 82E8ECA4: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E8ECA8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82E8ECAC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8ECB0: 4198FEEC  blt cr6, 0x82e8eb9c
	if ctx.cr[6].lt {
	pc = 0x82E8EB9C; continue 'dispatch;
	}
	pc = 0x82E8ECB4; continue 'dispatch;
            }
            0x82E8ECB4 => {
    //   block [0x82E8ECB4..0x82E8ECC4)
	// 82E8ECB4: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E8ECB8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82E8ECBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8ECC0: 4099006C  ble cr6, 0x82e8ed2c
	if !ctx.cr[6].gt {
	pc = 0x82E8ED2C; continue 'dispatch;
	}
	pc = 0x82E8ECC4; continue 'dispatch;
            }
            0x82E8ECC4 => {
    //   block [0x82E8ECC4..0x82E8ECF0)
	// 82E8ECC4: 2F1FFFFF  cmpwi cr6, r31, -1
	ctx.cr[6].compare_i32(ctx.r[31].s32, -1, &mut ctx.xer);
	// 82E8ECC8: 419A0028  beq cr6, 0x82e8ecf0
	if ctx.cr[6].eq {
	pc = 0x82E8ECF0; continue 'dispatch;
	}
	// 82E8ECCC: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8ECD0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8ECD4: 4098001C  bge cr6, 0x82e8ecf0
	if !ctx.cr[6].lt {
	pc = 0x82E8ECF0; continue 'dispatch;
	}
	// 82E8ECD8: 815D0018  lwz r10, 0x18(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E8ECDC: 1D7F0014  mulli r11, r31, 0x14
	ctx.r[11].s32 = ((ctx.r[31].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82E8ECE0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E8ECE4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8ECE8: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82E8ECEC: 409A0008  bne cr6, 0x82e8ecf4
	if !ctx.cr[6].eq {
	pc = 0x82E8ECF4; continue 'dispatch;
	}
	pc = 0x82E8ECF0; continue 'dispatch;
            }
            0x82E8ECF0 => {
    //   block [0x82E8ECF0..0x82E8ECF4)
	// 82E8ECF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82E8ECF4; continue 'dispatch;
            }
            0x82E8ECF4 => {
    //   block [0x82E8ECF4..0x82E8ED1C)
	// 82E8ECF4: 815C004C  lwz r10, 0x4c(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(76 as u32) ) } as u64;
	// 82E8ECF8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E8ECFC: 419A0020  beq cr6, 0x82e8ed1c
	if ctx.cr[6].eq {
	pc = 0x82E8ED1C; continue 'dispatch;
	}
	// 82E8ED00: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82E8ED04: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82E8ED08: 38A000FF  li r5, 0xff
	ctx.r[5].s64 = 255;
	// 82E8ED0C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82E8ED10: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E8ED14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E8ED18: 4E800421  bctrl
	ctx.lr = 0x82E8ED1C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E8ED1C => {
    //   block [0x82E8ED1C..0x82E8ED2C)
	// 82E8ED1C: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E8ED20: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82E8ED24: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8ED28: 4198FF9C  blt cr6, 0x82e8ecc4
	if ctx.cr[6].lt {
	pc = 0x82E8ECC4; continue 'dispatch;
	}
	pc = 0x82E8ED2C; continue 'dispatch;
            }
            0x82E8ED2C => {
    //   block [0x82E8ED2C..0x82E8ED3C)
	// 82E8ED2C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E8ED30: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82E8ED34: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82E8ED38: 4BE1A720  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8ED40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8ED40 size=160
    let mut pc: u32 = 0x82E8ED40;
    'dispatch: loop {
        match pc {
            0x82E8ED40 => {
    //   block [0x82E8ED40..0x82E8EDA8)
	// 82E8ED40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8ED44: 4BE1A6C1  bl 0x82ca9404
	ctx.lr = 0x82E8ED48;
	sub_82CA93D0(ctx, base);
	// 82E8ED48: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8ED4C: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82E8ED50: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E8ED54: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8ED58: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82E8ED5C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82E8ED60: 816A4EAC  lwz r11, 0x4eac(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20140 as u32) ) } as u64;
	// 82E8ED64: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82E8ED68: 3D208334  lis r9, -0x7ccc
	ctx.r[9].s64 = -2093744128;
	// 82E8ED6C: 3BE94E90  addi r31, r9, 0x4e90
	ctx.r[31].s64 = ctx.r[9].s64 + 20112;
	// 82E8ED70: 40820038  bne 0x82e8eda8
	if !ctx.cr[0].eq {
	pc = 0x82E8EDA8; continue 'dispatch;
	}
	// 82E8ED74: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82E8ED78: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82E8ED7C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82E8ED80: 392998D8  addi r9, r9, -0x6728
	ctx.r[9].s64 = ctx.r[9].s64 + -26408;
	// 82E8ED84: 3D00832C  lis r8, -0x7cd4
	ctx.r[8].s64 = -2094268416;
	// 82E8ED88: C0070C18  lfs f0, 0xc18(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8ED8C: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E8ED90: 38688520  addi r3, r8, -0x7ae0
	ctx.r[3].s64 = ctx.r[8].s64 + -31456;
	// 82E8ED94: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82E8ED98: 916A4EAC  stw r11, 0x4eac(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20140 as u32), ctx.r[11].u32 ) };
	// 82E8ED9C: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82E8EDA0: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E8EDA4: 4BE1B17D  bl 0x82ca9f20
	ctx.lr = 0x82E8EDA8;
	sub_82CA9F20(ctx, base);
	pc = 0x82E8EDA8; continue 'dispatch;
            }
            0x82E8EDA8 => {
    //   block [0x82E8EDA8..0x82E8EDE0)
	// 82E8EDA8: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8EDAC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E8EDB0: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E8EDB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8EDB8: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8EDBC: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82E8EDC0: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8EDC4: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82E8EDC8: 9B9F0018  stb r28, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[28].u8 ) };
	// 82E8EDCC: 9B7F0019  stb r27, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[27].u8 ) };
	// 82E8EDD0: 4BFFF0E1  bl 0x82e8deb0
	ctx.lr = 0x82E8EDD4;
	sub_82E8DEB0(ctx, base);
	// 82E8EDD4: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8EDD8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E8EDDC: 4BE1A678  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8EDE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8EDE0 size=512
    let mut pc: u32 = 0x82E8EDE0;
    'dispatch: loop {
        match pc {
            0x82E8EDE0 => {
    //   block [0x82E8EDE0..0x82E8EFD8)
	// 82E8EDE0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8EDE4: 396B70AC  addi r11, r11, 0x70ac
	ctx.r[11].s64 = ctx.r[11].s64 + 28844;
	// 82E8EDE8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8EDEC: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8EDF0: 419A01E8  beq cr6, 0x82e8efd8
	if ctx.cr[6].eq {
	pc = 0x82E8EFD8; continue 'dispatch;
	}
	// 82E8EDF4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8EDF8: 396B6F98  addi r11, r11, 0x6f98
	ctx.r[11].s64 = ctx.r[11].s64 + 28568;
	// 82E8EDFC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8EE00: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8EE04: 419A01D4  beq cr6, 0x82e8efd8
	if ctx.cr[6].eq {
	pc = 0x82E8EFD8; continue 'dispatch;
	}
	// 82E8EE08: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8EE0C: 396B5D84  addi r11, r11, 0x5d84
	ctx.r[11].s64 = ctx.r[11].s64 + 23940;
	// 82E8EE10: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8EE14: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8EE18: 419A01C0  beq cr6, 0x82e8efd8
	if ctx.cr[6].eq {
	pc = 0x82E8EFD8; continue 'dispatch;
	}
	// 82E8EE1C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8EE20: 396B6E84  addi r11, r11, 0x6e84
	ctx.r[11].s64 = ctx.r[11].s64 + 28292;
	// 82E8EE24: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8EE28: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8EE2C: 419A01AC  beq cr6, 0x82e8efd8
	if ctx.cr[6].eq {
	pc = 0x82E8EFD8; continue 'dispatch;
	}
	// 82E8EE30: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8EE34: 396B55F4  addi r11, r11, 0x55f4
	ctx.r[11].s64 = ctx.r[11].s64 + 22004;
	// 82E8EE38: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8EE3C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8EE40: 419A0198  beq cr6, 0x82e8efd8
	if ctx.cr[6].eq {
	pc = 0x82E8EFD8; continue 'dispatch;
	}
	// 82E8EE44: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8EE48: 396B54E0  addi r11, r11, 0x54e0
	ctx.r[11].s64 = ctx.r[11].s64 + 21728;
	// 82E8EE4C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8EE50: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8EE54: 419A0184  beq cr6, 0x82e8efd8
	if ctx.cr[6].eq {
	pc = 0x82E8EFD8; continue 'dispatch;
	}
	// 82E8EE58: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8EE5C: 396B5A44  addi r11, r11, 0x5a44
	ctx.r[11].s64 = ctx.r[11].s64 + 23108;
	// 82E8EE60: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8EE64: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8EE68: 419A0170  beq cr6, 0x82e8efd8
	if ctx.cr[6].eq {
	pc = 0x82E8EFD8; continue 'dispatch;
	}
	// 82E8EE6C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8EE70: 396B581C  addi r11, r11, 0x581c
	ctx.r[11].s64 = ctx.r[11].s64 + 22556;
	// 82E8EE74: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8EE78: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8EE7C: 419A015C  beq cr6, 0x82e8efd8
	if ctx.cr[6].eq {
	pc = 0x82E8EFD8; continue 'dispatch;
	}
	// 82E8EE80: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8EE84: 396B53CC  addi r11, r11, 0x53cc
	ctx.r[11].s64 = ctx.r[11].s64 + 21452;
	// 82E8EE88: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8EE8C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8EE90: 419A0148  beq cr6, 0x82e8efd8
	if ctx.cr[6].eq {
	pc = 0x82E8EFD8; continue 'dispatch;
	}
	// 82E8EE94: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8EE98: 396B5B58  addi r11, r11, 0x5b58
	ctx.r[11].s64 = ctx.r[11].s64 + 23384;
	// 82E8EE9C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8EEA0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8EEA4: 419A0134  beq cr6, 0x82e8efd8
	if ctx.cr[6].eq {
	pc = 0x82E8EFD8; continue 'dispatch;
	}
	// 82E8EEA8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8EEAC: 396B52B8  addi r11, r11, 0x52b8
	ctx.r[11].s64 = ctx.r[11].s64 + 21176;
	// 82E8EEB0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8EEB4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8EEB8: 419A0120  beq cr6, 0x82e8efd8
	if ctx.cr[6].eq {
	pc = 0x82E8EFD8; continue 'dispatch;
	}
	// 82E8EEBC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8EEC0: 396B5708  addi r11, r11, 0x5708
	ctx.r[11].s64 = ctx.r[11].s64 + 22280;
	// 82E8EEC4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8EEC8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8EECC: 419A010C  beq cr6, 0x82e8efd8
	if ctx.cr[6].eq {
	pc = 0x82E8EFD8; continue 'dispatch;
	}
	// 82E8EED0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8EED4: 396B5C6C  addi r11, r11, 0x5c6c
	ctx.r[11].s64 = ctx.r[11].s64 + 23660;
	// 82E8EED8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8EEDC: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8EEE0: 419A00F8  beq cr6, 0x82e8efd8
	if ctx.cr[6].eq {
	pc = 0x82E8EFD8; continue 'dispatch;
	}
	// 82E8EEE4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8EEE8: 396B5FAC  addi r11, r11, 0x5fac
	ctx.r[11].s64 = ctx.r[11].s64 + 24492;
	// 82E8EEEC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8EEF0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8EEF4: 419A00E4  beq cr6, 0x82e8efd8
	if ctx.cr[6].eq {
	pc = 0x82E8EFD8; continue 'dispatch;
	}
	// 82E8EEF8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8EEFC: 396B5E98  addi r11, r11, 0x5e98
	ctx.r[11].s64 = ctx.r[11].s64 + 24216;
	// 82E8EF00: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8EF04: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8EF08: 419A00D0  beq cr6, 0x82e8efd8
	if ctx.cr[6].eq {
	pc = 0x82E8EFD8; continue 'dispatch;
	}
	// 82E8EF0C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8EF10: 396B2E38  addi r11, r11, 0x2e38
	ctx.r[11].s64 = ctx.r[11].s64 + 11832;
	// 82E8EF14: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8EF18: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8EF1C: 419A00BC  beq cr6, 0x82e8efd8
	if ctx.cr[6].eq {
	pc = 0x82E8EFD8; continue 'dispatch;
	}
	// 82E8EF20: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82E8EF24: 396BF090  addi r11, r11, -0xf70
	ctx.r[11].s64 = ctx.r[11].s64 + -3952;
	// 82E8EF28: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8EF2C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8EF30: 419A00A8  beq cr6, 0x82e8efd8
	if ctx.cr[6].eq {
	pc = 0x82E8EFD8; continue 'dispatch;
	}
	// 82E8EF34: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8EF38: 396B6D70  addi r11, r11, 0x6d70
	ctx.r[11].s64 = ctx.r[11].s64 + 28016;
	// 82E8EF3C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8EF40: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8EF44: 419A0094  beq cr6, 0x82e8efd8
	if ctx.cr[6].eq {
	pc = 0x82E8EFD8; continue 'dispatch;
	}
	// 82E8EF48: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8EF4C: 396B6C5C  addi r11, r11, 0x6c5c
	ctx.r[11].s64 = ctx.r[11].s64 + 27740;
	// 82E8EF50: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8EF54: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8EF58: 419A0080  beq cr6, 0x82e8efd8
	if ctx.cr[6].eq {
	pc = 0x82E8EFD8; continue 'dispatch;
	}
	// 82E8EF5C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8EF60: 396B6B48  addi r11, r11, 0x6b48
	ctx.r[11].s64 = ctx.r[11].s64 + 27464;
	// 82E8EF64: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8EF68: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8EF6C: 419A006C  beq cr6, 0x82e8efd8
	if ctx.cr[6].eq {
	pc = 0x82E8EFD8; continue 'dispatch;
	}
	// 82E8EF70: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8EF74: 396B6A34  addi r11, r11, 0x6a34
	ctx.r[11].s64 = ctx.r[11].s64 + 27188;
	// 82E8EF78: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8EF7C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8EF80: 419A0058  beq cr6, 0x82e8efd8
	if ctx.cr[6].eq {
	pc = 0x82E8EFD8; continue 'dispatch;
	}
	// 82E8EF84: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8EF88: 396B6920  addi r11, r11, 0x6920
	ctx.r[11].s64 = ctx.r[11].s64 + 26912;
	// 82E8EF8C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8EF90: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8EF94: 419A0044  beq cr6, 0x82e8efd8
	if ctx.cr[6].eq {
	pc = 0x82E8EFD8; continue 'dispatch;
	}
	// 82E8EF98: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8EF9C: 396B6404  addi r11, r11, 0x6404
	ctx.r[11].s64 = ctx.r[11].s64 + 25604;
	// 82E8EFA0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8EFA4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8EFA8: 419A0030  beq cr6, 0x82e8efd8
	if ctx.cr[6].eq {
	pc = 0x82E8EFD8; continue 'dispatch;
	}
	// 82E8EFAC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8EFB0: 396B62EC  addi r11, r11, 0x62ec
	ctx.r[11].s64 = ctx.r[11].s64 + 25324;
	// 82E8EFB4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8EFB8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8EFBC: 419A001C  beq cr6, 0x82e8efd8
	if ctx.cr[6].eq {
	pc = 0x82E8EFD8; continue 'dispatch;
	}
	// 82E8EFC0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8EFC4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E8EFC8: 396B61D4  addi r11, r11, 0x61d4
	ctx.r[11].s64 = ctx.r[11].s64 + 25044;
	// 82E8EFCC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8EFD0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82E8EFD4: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	pc = 0x82E8EFD8; continue 'dispatch;
            }
            0x82E8EFD8 => {
    //   block [0x82E8EFD8..0x82E8EFE0)
	// 82E8EFD8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8EFDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8EFE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8EFE0 size=12
    let mut pc: u32 = 0x82E8EFE0;
    'dispatch: loop {
        match pc {
            0x82E8EFE0 => {
    //   block [0x82E8EFE0..0x82E8EFEC)
	// 82E8EFE0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8EFE4: 386B5930  addi r3, r11, 0x5930
	ctx.r[3].s64 = ctx.r[11].s64 + 22832;
	// 82E8EFE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8EFF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8EFF0 size=12
    let mut pc: u32 = 0x82E8EFF0;
    'dispatch: loop {
        match pc {
            0x82E8EFF0 => {
    //   block [0x82E8EFF0..0x82E8EFFC)
	// 82E8EFF0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8EFF4: 386B55F4  addi r3, r11, 0x55f4
	ctx.r[3].s64 = ctx.r[11].s64 + 22004;
	// 82E8EFF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8F000 size=64
    let mut pc: u32 = 0x82E8F000;
    'dispatch: loop {
        match pc {
            0x82E8F000 => {
    //   block [0x82E8F000..0x82E8F040)
	// 82E8F000: C1A60004  lfs f13, 4(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8F004: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E8F008: C0050004  lfs f0, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8F00C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E8F010: C1850008  lfs f12, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8F014: C1A60008  lfs f13, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8F018: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E8F01C: C166000C  lfs f11, 0xc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8F020: C185000C  lfs f12, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8F024: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E8F028: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8F02C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8F030: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8F034: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82E8F038: D0070000  stfs f0, 0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E8F03C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8F040 size=12
    let mut pc: u32 = 0x82E8F040;
    'dispatch: loop {
        match pc {
            0x82E8F040 => {
    //   block [0x82E8F040..0x82E8F04C)
	// 82E8F040: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8F044: 386B5A44  addi r3, r11, 0x5a44
	ctx.r[3].s64 = ctx.r[11].s64 + 23108;
	// 82E8F048: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8F050 size=20
    let mut pc: u32 = 0x82E8F050;
    'dispatch: loop {
        match pc {
            0x82E8F050 => {
    //   block [0x82E8F050..0x82E8F064)
	// 82E8F050: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8F054: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E8F058: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8F05C: D0070000  stfs f0, 0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E8F060: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8F068 size=12
    let mut pc: u32 = 0x82E8F068;
    'dispatch: loop {
        match pc {
            0x82E8F068 => {
    //   block [0x82E8F068..0x82E8F074)
	// 82E8F068: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8F06C: 386B54E0  addi r3, r11, 0x54e0
	ctx.r[3].s64 = ctx.r[11].s64 + 21728;
	// 82E8F070: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8F078 size=72
    let mut pc: u32 = 0x82E8F078;
    'dispatch: loop {
        match pc {
            0x82E8F078 => {
    //   block [0x82E8F078..0x82E8F0AC)
	// 82E8F078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8F07C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8F080: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8F084: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82E8F088: 4B7878A1  bl 0x82616928
	ctx.lr = 0x82E8F08C;
	sub_82616928(ctx, base);
	// 82E8F08C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8F090: 4182001C  beq 0x82e8f0ac
	if ctx.cr[0].eq {
	pc = 0x82E8F0AC; continue 'dispatch;
	}
	// 82E8F094: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8F098: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E8F09C: 396B8704  addi r11, r11, -0x78fc
	ctx.r[11].s64 = ctx.r[11].s64 + -30972;
	// 82E8F0A0: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82E8F0A4: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E8F0A8: 48000008  b 0x82e8f0b0
	pc = 0x82E8F0B0; continue 'dispatch;
            }
            0x82E8F0AC => {
    //   block [0x82E8F0AC..0x82E8F0B0)
	// 82E8F0AC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E8F0B0; continue 'dispatch;
            }
            0x82E8F0B0 => {
    //   block [0x82E8F0B0..0x82E8F0C0)
	// 82E8F0B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8F0B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8F0B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8F0BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F0C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8F0C0 size=64
    let mut pc: u32 = 0x82E8F0C0;
    'dispatch: loop {
        match pc {
            0x82E8F0C0 => {
    //   block [0x82E8F0C0..0x82E8F100)
	// 82E8F0C0: C1A50000  lfs f13, 0(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8F0C4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E8F0C8: C0060000  lfs f0, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8F0CC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E8F0D0: C1860004  lfs f12, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8F0D4: C1A50004  lfs f13, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8F0D8: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E8F0DC: C1650008  lfs f11, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8F0E0: C1860008  lfs f12, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8F0E4: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E8F0E8: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8F0EC: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8F0F0: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8F0F4: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82E8F0F8: D0070000  stfs f0, 0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E8F0FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8F100 size=112
    let mut pc: u32 = 0x82E8F100;
    'dispatch: loop {
        match pc {
            0x82E8F100 => {
    //   block [0x82E8F100..0x82E8F138)
	// 82E8F100: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8F104: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E8F108: 396B993C  addi r11, r11, -0x66c4
	ctx.r[11].s64 = ctx.r[11].s64 + -26308;
	// 82E8F10C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82E8F110: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82E8F114: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E8F118: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8F11C: 91430058  stw r10, 0x58(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82E8F120: C0090C14  lfs f0, 0xc14(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8F124: 814B0718  lwz r10, 0x718(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E8F128: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8F12C: 4182000C  beq 0x82e8f138
	if ctx.cr[0].eq {
	pc = 0x82E8F138; continue 'dispatch;
	}
	// 82E8F130: C1AA000C  lfs f13, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8F134: 48000008  b 0x82e8f13c
	pc = 0x82E8F13C; continue 'dispatch;
            }
            0x82E8F138 => {
    //   block [0x82E8F138..0x82E8F13C)
	// 82E8F138: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	pc = 0x82E8F13C; continue 'dispatch;
            }
            0x82E8F13C => {
    //   block [0x82E8F13C..0x82E8F15C)
	// 82E8F13C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E8F140: C18A0AA4  lfs f12, 0xaa4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2724 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8F144: EDAD0332  fmuls f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 82E8F148: D1A3005C  stfs f13, 0x5c(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82E8F14C: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E8F150: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8F154: 41820008  beq 0x82e8f15c
	if ctx.cr[0].eq {
	pc = 0x82E8F15C; continue 'dispatch;
	}
	// 82E8F158: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82E8F15C; continue 'dispatch;
            }
            0x82E8F15C => {
    //   block [0x82E8F15C..0x82E8F170)
	// 82E8F15C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8F160: C1AB0AC8  lfs f13, 0xac8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2760 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8F164: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82E8F168: D0030060  stfs f0, 0x60(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82E8F16C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8F170 size=12
    let mut pc: u32 = 0x82E8F170;
    'dispatch: loop {
        match pc {
            0x82E8F170 => {
    //   block [0x82E8F170..0x82E8F17C)
	// 82E8F170: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8F174: 386B53CC  addi r3, r11, 0x53cc
	ctx.r[3].s64 = ctx.r[11].s64 + 21452;
	// 82E8F178: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8F180 size=124
    let mut pc: u32 = 0x82E8F180;
    'dispatch: loop {
        match pc {
            0x82E8F180 => {
    //   block [0x82E8F180..0x82E8F1A4)
	// 82E8F180: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8F184: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E8F188: 392B1BD4  addi r9, r11, 0x1bd4
	ctx.r[9].s64 = ctx.r[11].s64 + 7124;
	// 82E8F18C: 39630008  addi r11, r3, 8
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	// 82E8F190: 39000013  li r8, 0x13
	ctx.r[8].s64 = 19;
	// 82E8F194: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82E8F198: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E8F19C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82E8F1A0: C0090C18  lfs f0, 0xc18(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82E8F1A4; continue 'dispatch;
            }
            0x82E8F1A4 => {
    //   block [0x82E8F1A4..0x82E8F1E8)
	// 82E8F1A4: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E8F1A8: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82E8F1AC: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E8F1B0: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E8F1B4: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82E8F1B8: 4080FFEC  bge 0x82e8f1a4
	if !ctx.cr[0].lt {
	pc = 0x82E8F1A4; continue 'dispatch;
	}
	// 82E8F1BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8F1C0: 91430148  stw r10, 0x148(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(328 as u32), ctx.r[10].u32 ) };
	// 82E8F1C4: 9143014C  stw r10, 0x14c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(332 as u32), ctx.r[10].u32 ) };
	// 82E8F1C8: C1AB0AC8  lfs f13, 0xac8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2760 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8F1CC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8F1D0: D1A30150  stfs f13, 0x150(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(336 as u32), tmp.u32 ) };
	// 82E8F1D4: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E8F1D8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8F1DC: 4182000C  beq 0x82e8f1e8
	if ctx.cr[0].eq {
	pc = 0x82E8F1E8; continue 'dispatch;
	}
	// 82E8F1E0: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8F1E4: 4800000C  b 0x82e8f1f0
	pc = 0x82E8F1F0; continue 'dispatch;
            }
            0x82E8F1E8 => {
    //   block [0x82E8F1E8..0x82E8F1F0)
	// 82E8F1E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8F1EC: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82E8F1F0; continue 'dispatch;
            }
            0x82E8F1F0 => {
    //   block [0x82E8F1F0..0x82E8F1FC)
	// 82E8F1F0: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82E8F1F4: D0030154  stfs f0, 0x154(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(340 as u32), tmp.u32 ) };
	// 82E8F1F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8F200 size=24
    let mut pc: u32 = 0x82E8F200;
    'dispatch: loop {
        match pc {
            0x82E8F200 => {
    //   block [0x82E8F200..0x82E8F218)
	// 82E8F200: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82E8F204: 816A0148  lwz r11, 0x148(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(328 as u32) ) } as u64;
	// 82E8F208: 2B0B0014  cmplwi cr6, r11, 0x14
	ctx.cr[6].compare_u32(ctx.r[11].u32, 20 as u32, &mut ctx.xer);
	// 82E8F20C: 4198000C  blt cr6, 0x82e8f218
	if ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x82E8F218);
		return;
	}
	// 82E8F210: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8F214: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8F250 size=24
    let mut pc: u32 = 0x82E8F250;
    'dispatch: loop {
        match pc {
            0x82E8F250 => {
    //   block [0x82E8F250..0x82E8F268)
	// 82E8F250: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E8F254: 814B014C  lwz r10, 0x14c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(332 as u32) ) } as u64;
	// 82E8F258: 2B0A0014  cmplwi cr6, r10, 0x14
	ctx.cr[6].compare_u32(ctx.r[10].u32, 20 as u32, &mut ctx.xer);
	// 82E8F25C: 4198000C  blt cr6, 0x82e8f268
	if ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x82E8F268);
		return;
	}
	// 82E8F260: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8F264: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8F288 size=216
    let mut pc: u32 = 0x82E8F288;
    'dispatch: loop {
        match pc {
            0x82E8F288 => {
    //   block [0x82E8F288..0x82E8F2F4)
	// 82E8F288: DBE1FFF8  stfd f31, -8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.f[31].u64 ) };
	// 82E8F28C: C1270004  lfs f9, 4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E8F290: FDA00890  fmr f13, f1
	ctx.f[13].f64 = ctx.f[1].f64;
	// 82E8F294: C1050004  lfs f8, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82E8F298: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8F29C: EC494028  fsubs f2, f9, f8
	ctx.f[2].f64 = (((ctx.f[9].f64 - ctx.f[8].f64) as f32) as f64);
	// 82E8F2A0: C1870000  lfs f12, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8F2A4: C1450000  lfs f10, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E8F2A8: C0A80004  lfs f5, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82E8F2AC: EC0C5028  fsubs f0, f12, f10
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82E8F2B0: C0E70008  lfs f7, 8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82E8F2B4: C0C50008  lfs f6, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82E8F2B8: C0880000  lfs f4, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82E8F2BC: EFE73028  fsubs f31, f7, f6
	ctx.f[31].f64 = (((ctx.f[7].f64 - ctx.f[6].f64) as f32) as f64);
	// 82E8F2C0: C02B0C14  lfs f1, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82E8F2C4: C0680008  lfs f3, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82E8F2C8: ED616824  fdivs f11, f1, f13
	ctx.f[11].f64 = ((ctx.f[1].f64 / ctx.f[13].f64) as f32) as f64;
	// 82E8F2CC: EC4500B2  fmuls f2, f5, f2
	ctx.f[2].f64 = (((ctx.f[5].f64 * ctx.f[2].f64) as f32) as f64);
	// 82E8F2D0: EC04103A  fmadds f0, f4, f0, f2
	ctx.f[0].f64 = (((ctx.f[4].f64 * ctx.f[0].f64 + ctx.f[2].f64) as f32) as f64);
	// 82E8F2D4: EC0307FA  fmadds f0, f3, f31, f0
	ctx.f[0].f64 = (((ctx.f[3].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8F2D8: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82E8F2DC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E8F2E0: 41990014  bgt cr6, 0x82e8f2f4
	if ctx.cr[6].gt {
	pc = 0x82E8F2F4; continue 'dispatch;
	}
	// 82E8F2E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8F2E8: C1AB0C18  lfs f13, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8F2EC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E8F2F0: 40980008  bge cr6, 0x82e8f2f8
	if !ctx.cr[6].lt {
	pc = 0x82E8F2F8; continue 'dispatch;
	}
	pc = 0x82E8F2F4; continue 'dispatch;
            }
            0x82E8F2F4 => {
    //   block [0x82E8F2F4..0x82E8F2F8)
	// 82E8F2F4: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82E8F2F8; continue 'dispatch;
            }
            0x82E8F2F8 => {
    //   block [0x82E8F2F8..0x82E8F358)
	// 82E8F2F8: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8F2FC: C0430154  lfs f2, 0x154(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(340 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82E8F300: EDA40032  fmuls f13, f4, f0
	ctx.f[13].f64 = (((ctx.f[4].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8F304: ED650032  fmuls f11, f5, f0
	ctx.f[11].f64 = (((ctx.f[5].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8F308: EC030032  fmuls f0, f3, f0
	ctx.f[0].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8F30C: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82E8F310: ED68582A  fadds f11, f8, f11
	ctx.f[11].f64 = ((ctx.f[8].f64 + ctx.f[11].f64) as f32) as f64;
	// 82E8F314: ED46002A  fadds f10, f6, f0
	ctx.f[10].f64 = ((ctx.f[6].f64 + ctx.f[0].f64) as f32) as f64;
	// 82E8F318: EC0C6828  fsubs f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E8F31C: EDA95828  fsubs f13, f9, f11
	ctx.f[13].f64 = (((ctx.f[9].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E8F320: ED875028  fsubs f12, f7, f10
	ctx.f[12].f64 = (((ctx.f[7].f64 - ctx.f[10].f64) as f32) as f64);
	// 82E8F324: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8F328: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8F32C: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8F330: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82E8F334: FF001000  fcmpu cr6, f0, f2
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[2].f64);
	// 82E8F338: 41990020  bgt cr6, 0x82e8f358
	if ctx.cr[6].gt {
	pc = 0x82E8F358; continue 'dispatch;
	}
	// 82E8F33C: FDA01090  fmr f13, f2
	ctx.f[13].f64 = ctx.f[2].f64;
	// 82E8F340: C1830150  lfs f12, 0x150(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(336 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8F344: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E8F348: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82E8F34C: EDA00032  fmuls f13, f0, f0
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8F350: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8F354: EC200B3A  fmadds f1, f0, f12, f1
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[1].f64) as f32) as f64);
	pc = 0x82E8F358; continue 'dispatch;
            }
            0x82E8F358 => {
    //   block [0x82E8F358..0x82E8F360)
	// 82E8F358: CBE1FFF8  lfd f31, -8(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82E8F35C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8F360 size=96
    let mut pc: u32 = 0x82E8F360;
    'dispatch: loop {
        match pc {
            0x82E8F360 => {
    //   block [0x82E8F360..0x82E8F3AC)
	// 82E8F360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8F364: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8F368: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8F36C: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82E8F370: 4B7875B9  bl 0x82616928
	ctx.lr = 0x82E8F374;
	sub_82616928(ctx, base);
	// 82E8F374: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8F378: 41820034  beq 0x82e8f3ac
	if ctx.cr[0].eq {
	pc = 0x82E8F3AC; continue 'dispatch;
	}
	// 82E8F37C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E8F380: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8F384: 396B98F4  addi r11, r11, -0x670c
	ctx.r[11].s64 = ctx.r[11].s64 + -26380;
	// 82E8F388: C00A0C18  lfs f0, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8F38C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E8F390: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E8F394: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82E8F398: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E8F39C: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82E8F3A0: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82E8F3A4: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82E8F3A8: 48000008  b 0x82e8f3b0
	pc = 0x82E8F3B0; continue 'dispatch;
            }
            0x82E8F3AC => {
    //   block [0x82E8F3AC..0x82E8F3B0)
	// 82E8F3AC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E8F3B0; continue 'dispatch;
            }
            0x82E8F3B0 => {
    //   block [0x82E8F3B0..0x82E8F3C0)
	// 82E8F3B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8F3B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8F3B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8F3BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F3C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8F3C0 size=28
    let mut pc: u32 = 0x82E8F3C0;
    'dispatch: loop {
        match pc {
            0x82E8F3C0 => {
    //   block [0x82E8F3C0..0x82E8F3DC)
	// 82E8F3C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8F3C4: C1A30014  lfs f13, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8F3C8: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8F3CC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E8F3D0: 409A000C  bne cr6, 0x82e8f3dc
	if !ctx.cr[6].eq {
		sub_82E8F3DC(ctx, base);
		return;
	}
	// 82E8F3D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8F3D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F3DC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8F3DC size=116
    let mut pc: u32 = 0x82E8F3DC;
    'dispatch: loop {
        match pc {
            0x82E8F3DC => {
    //   block [0x82E8F3DC..0x82E8F450)
	// 82E8F3DC: C1260008  lfs f9, 8(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E8F3E0: C1830010  lfs f12, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8F3E4: ED896028  fsubs f12, f9, f12
	ctx.f[12].f64 = (((ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E8F3E8: C1460000  lfs f10, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E8F3EC: C1A30008  lfs f13, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8F3F0: EDAA6828  fsubs f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E8F3F4: C1060004  lfs f8, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82E8F3F8: C163000C  lfs f11, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8F3FC: ED685828  fsubs f11, f8, f11
	ctx.f[11].f64 = (((ctx.f[8].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E8F400: C0030014  lfs f0, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8F404: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8F408: ED8C0332  fmuls f12, f12, f12
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82E8F40C: EDAD637A  fmadds f13, f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 82E8F410: EDAB6AFA  fmadds f13, f11, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 82E8F414: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E8F418: 4199FFBC  bgt cr6, 0x82e8f3d4
	if ctx.cr[6].gt {
		sub_82E8F3C0(ctx, base);
		return;
	}
	// 82E8F41C: C0050000  lfs f0, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8F420: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E8F424: EC0A0028  fsubs f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E8F428: C1A50004  lfs f13, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8F42C: EDA86828  fsubs f13, f8, f13
	ctx.f[13].f64 = (((ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E8F430: C1850008  lfs f12, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8F434: ED896028  fsubs f12, f9, f12
	ctx.f[12].f64 = (((ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E8F438: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8F43C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8F440: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8F444: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82E8F448: D0070000  stfs f0, 0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E8F44C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8F450 size=72
    let mut pc: u32 = 0x82E8F450;
    'dispatch: loop {
        match pc {
            0x82E8F450 => {
    //   block [0x82E8F450..0x82E8F484)
	// 82E8F450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8F454: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8F458: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8F45C: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82E8F460: 4B7874C9  bl 0x82616928
	ctx.lr = 0x82E8F464;
	sub_82616928(ctx, base);
	// 82E8F464: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8F468: 4182001C  beq 0x82e8f484
	if ctx.cr[0].eq {
	pc = 0x82E8F484; continue 'dispatch;
	}
	// 82E8F46C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8F470: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E8F474: 396B990C  addi r11, r11, -0x66f4
	ctx.r[11].s64 = ctx.r[11].s64 + -26356;
	// 82E8F478: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82E8F47C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E8F480: 48000008  b 0x82e8f488
	pc = 0x82E8F488; continue 'dispatch;
            }
            0x82E8F484 => {
    //   block [0x82E8F484..0x82E8F488)
	// 82E8F484: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E8F488; continue 'dispatch;
            }
            0x82E8F488 => {
    //   block [0x82E8F488..0x82E8F498)
	// 82E8F488: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8F48C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8F490: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8F494: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8F498 size=72
    let mut pc: u32 = 0x82E8F498;
    'dispatch: loop {
        match pc {
            0x82E8F498 => {
    //   block [0x82E8F498..0x82E8F4CC)
	// 82E8F498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8F49C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8F4A0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8F4A4: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82E8F4A8: 4B787481  bl 0x82616928
	ctx.lr = 0x82E8F4AC;
	sub_82616928(ctx, base);
	// 82E8F4AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8F4B0: 4182001C  beq 0x82e8f4cc
	if ctx.cr[0].eq {
	pc = 0x82E8F4CC; continue 'dispatch;
	}
	// 82E8F4B4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8F4B8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E8F4BC: 396B991C  addi r11, r11, -0x66e4
	ctx.r[11].s64 = ctx.r[11].s64 + -26340;
	// 82E8F4C0: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82E8F4C4: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E8F4C8: 48000008  b 0x82e8f4d0
	pc = 0x82E8F4D0; continue 'dispatch;
            }
            0x82E8F4CC => {
    //   block [0x82E8F4CC..0x82E8F4D0)
	// 82E8F4CC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E8F4D0; continue 'dispatch;
            }
            0x82E8F4D0 => {
    //   block [0x82E8F4D0..0x82E8F4E0)
	// 82E8F4D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8F4D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8F4D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8F4DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F4E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8F4E0 size=76
    let mut pc: u32 = 0x82E8F4E0;
    'dispatch: loop {
        match pc {
            0x82E8F4E0 => {
    //   block [0x82E8F4E0..0x82E8F518)
	// 82E8F4E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8F4E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8F4E8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8F4EC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82E8F4F0: 4B787439  bl 0x82616928
	ctx.lr = 0x82E8F4F4;
	sub_82616928(ctx, base);
	// 82E8F4F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8F4F8: 41820020  beq 0x82e8f518
	if ctx.cr[0].eq {
	pc = 0x82E8F518; continue 'dispatch;
	}
	// 82E8F4FC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8F500: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E8F504: 396B992C  addi r11, r11, -0x66d4
	ctx.r[11].s64 = ctx.r[11].s64 + -26324;
	// 82E8F508: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82E8F50C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E8F510: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82E8F514: 48000008  b 0x82e8f51c
	pc = 0x82E8F51C; continue 'dispatch;
            }
            0x82E8F518 => {
    //   block [0x82E8F518..0x82E8F51C)
	// 82E8F518: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E8F51C; continue 'dispatch;
            }
            0x82E8F51C => {
    //   block [0x82E8F51C..0x82E8F52C)
	// 82E8F51C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8F520: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8F524: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8F528: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8F530 size=112
    let mut pc: u32 = 0x82E8F530;
    'dispatch: loop {
        match pc {
            0x82E8F530 => {
    //   block [0x82E8F530..0x82E8F54C)
	// 82E8F530: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8F534: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8F538: 40820014  bne 0x82e8f54c
	if !ctx.cr[0].eq {
	pc = 0x82E8F54C; continue 'dispatch;
	}
	// 82E8F53C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8F540: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8F544: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8F548: 48000050  b 0x82e8f598
	pc = 0x82E8F598; continue 'dispatch;
            }
            0x82E8F54C => {
    //   block [0x82E8F54C..0x82E8F578)
	// 82E8F54C: 81060000  lwz r8, 0(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8F550: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8F554: 80CB000C  lwz r6, 0xc(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E8F558: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E8F55C: 7D4651D6  mullw r10, r6, r10
	ctx.r[10].s32 = ((ctx.r[6].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82E8F560: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82E8F564: 7D4A40AE  lbzx r10, r10, r8
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82E8F568: 2B0A00FF  cmplwi cr6, r10, 0xff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 255 as u32, &mut ctx.xer);
	// 82E8F56C: 409A000C  bne cr6, 0x82e8f578
	if !ctx.cr[6].eq {
	pc = 0x82E8F578; continue 'dispatch;
	}
	// 82E8F570: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E8F574: 4E800020  blr
	return;
            }
            0x82E8F578 => {
    //   block [0x82E8F578..0x82E8F598)
	// 82E8F578: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82E8F57C: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8F580: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E8F584: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 82E8F588: C9A1FFF0  lfd f13, -0x10(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8F58C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82E8F590: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82E8F594: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	pc = 0x82E8F598; continue 'dispatch;
            }
            0x82E8F598 => {
    //   block [0x82E8F598..0x82E8F5A0)
	// 82E8F598: D0070000  stfs f0, 0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E8F59C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F5A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8F5A0 size=128
    let mut pc: u32 = 0x82E8F5A0;
    'dispatch: loop {
        match pc {
            0x82E8F5A0 => {
    //   block [0x82E8F5A0..0x82E8F600)
	// 82E8F5A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8F5A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8F5A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E8F5AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8F5B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8F5B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8F5B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E8F5BC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8F5C0: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82E8F5C4: 419A0044  beq cr6, 0x82e8f608
	if ctx.cr[6].eq {
	pc = 0x82E8F608; continue 'dispatch;
	}
	// 82E8F5C8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8F5CC: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82E8F5D0: 388B2E38  addi r4, r11, 0x2e38
	ctx.r[4].s64 = ctx.r[11].s64 + 11832;
	// 82E8F5D4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8F5D8: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E8F5DC: 4B3D8645  bl 0x82267c20
	ctx.lr = 0x82E8F5E0;
	sub_82267C20(ctx, base);
	// 82E8F5E0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8F5E4: 4182001C  beq 0x82e8f600
	if ctx.cr[0].eq {
	pc = 0x82E8F600; continue 'dispatch;
	}
	// 82E8F5E8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8F5EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8F5F0: 38AB6E84  addi r5, r11, 0x6e84
	ctx.r[5].s64 = ctx.r[11].s64 + 28292;
	// 82E8F5F4: 4BFFDA9D  bl 0x82e8d090
	ctx.lr = 0x82E8F5F8;
	sub_82E8D090(ctx, base);
	// 82E8F5F8: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82E8F5FC: 4800000C  b 0x82e8f608
	pc = 0x82E8F608; continue 'dispatch;
            }
            0x82E8F600 => {
    //   block [0x82E8F600..0x82E8F608)
	// 82E8F600: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E8F604: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82E8F608; continue 'dispatch;
            }
            0x82E8F608 => {
    //   block [0x82E8F608..0x82E8F620)
	// 82E8F608: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E8F60C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8F610: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8F614: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E8F618: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8F61C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8F620 size=124
    let mut pc: u32 = 0x82E8F620;
    'dispatch: loop {
        match pc {
            0x82E8F620 => {
    //   block [0x82E8F620..0x82E8F69C)
	// 82E8F620: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8F624: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8F628: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8F62C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82E8F630: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8F634: 40820068  bne 0x82e8f69c
	if !ctx.cr[0].eq {
		crate::recompiler::externs::call(ctx, base, 0x82E8F69C);
		return;
	}
	// 82E8F638: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8F63C: 80EB003C  lwz r7, 0x3c(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82E8F640: 80CB0038  lwz r6, 0x38(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E8F644: 810B0018  lwz r8, 0x18(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E8F648: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 82E8F64C: 7D67502E  lwzx r11, r7, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E8F650: 7D46502E  lwzx r10, r6, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E8F654: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82E8F658: 1D4A0014  mulli r10, r10, 0x14
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 20 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82E8F65C: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82E8F660: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82E8F664: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8F668: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8F66C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E8F670: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8F674: C1AA0008  lfs f13, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8F678: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E8F67C: C16A000C  lfs f11, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8F680: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8F684: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E8F688: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8F68C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8F690: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8F694: EC20002C  fsqrts f1, f0
	ctx.f[1].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82E8F698: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F6A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8F6A8 size=56
    let mut pc: u32 = 0x82E8F6A8;
    'dispatch: loop {
        match pc {
            0x82E8F6A8 => {
    //   block [0x82E8F6A8..0x82E8F6E0)
	// 82E8F6A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8F6AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8F6B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8F6B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8F6B8: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82E8F6BC: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82E8F6C0: 4BFFFF61  bl 0x82e8f620
	ctx.lr = 0x82E8F6C4;
	sub_82E8F620(ctx, base);
	// 82E8F6C4: D03F0000  stfs f1, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E8F6C8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E8F6CC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8F6D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8F6D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8F6D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E8F6DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F6E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E8F6E0 size=144
    let mut pc: u32 = 0x82E8F6E0;
    'dispatch: loop {
        match pc {
            0x82E8F6E0 => {
    //   block [0x82E8F6E0..0x82E8F704)
	// 82E8F6E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E8F6E4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82E8F6E8: 394B9954  addi r10, r11, -0x66ac
	ctx.r[10].s64 = ctx.r[11].s64 + -26284;
	// 82E8F6EC: 39630008  addi r11, r3, 8
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	// 82E8F6F0: 39200013  li r9, 0x13
	ctx.r[9].s64 = 19;
	// 82E8F6F4: 91030004  stw r8, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82E8F6F8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E8F6FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E8F700: C00A0C18  lfs f0, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82E8F704; continue 'dispatch;
            }
            0x82E8F704 => {
    //   block [0x82E8F704..0x82E8F73C)
	// 82E8F704: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E8F708: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82E8F70C: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82E8F710: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82E8F714: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82E8F718: 4080FFEC  bge 0x82e8f704
	if !ctx.cr[0].lt {
	pc = 0x82E8F704; continue 'dispatch;
	}
	// 82E8F71C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8F720: 91030148  stw r8, 0x148(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(328 as u32), ctx.r[8].u32 ) };
	// 82E8F724: 9103014C  stw r8, 0x14c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(332 as u32), ctx.r[8].u32 ) };
	// 82E8F728: 814B0718  lwz r10, 0x718(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E8F72C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8F730: 4182000C  beq 0x82e8f73c
	if ctx.cr[0].eq {
	pc = 0x82E8F73C; continue 'dispatch;
	}
	// 82E8F734: C1AA000C  lfs f13, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8F738: 4800000C  b 0x82e8f744
	pc = 0x82E8F744; continue 'dispatch;
            }
            0x82E8F73C => {
    //   block [0x82E8F73C..0x82E8F744)
	// 82E8F73C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E8F740: C1AA0C14  lfs f13, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82E8F744; continue 'dispatch;
            }
            0x82E8F744 => {
    //   block [0x82E8F744..0x82E8F770)
	// 82E8F744: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E8F748: C00A0AA4  lfs f0, 0xaa4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2724 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8F74C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8F750: D0030150  stfs f0, 0x150(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(336 as u32), tmp.u32 ) };
	// 82E8F754: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E8F758: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8F75C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8F760: C00B0AC8  lfs f0, 0xac8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2760 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8F764: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8F768: D0030154  stfs f0, 0x154(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(340 as u32), tmp.u32 ) };
	// 82E8F76C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E8F770 size=12
    let mut pc: u32 = 0x82E8F770;
    'dispatch: loop {
        match pc {
            0x82E8F770 => {
    //   block [0x82E8F770..0x82E8F77C)
	// 82E8F770: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E8F774: 386B5708  addi r3, r11, 0x5708
	ctx.r[3].s64 = ctx.r[11].s64 + 22280;
	// 82E8F778: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8F780 size=436
    let mut pc: u32 = 0x82E8F780;
    'dispatch: loop {
        match pc {
            0x82E8F780 => {
    //   block [0x82E8F780..0x82E8F7F4)
	// 82E8F780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8F784: 4BE19C7D  bl 0x82ca9400
	ctx.lr = 0x82E8F788;
	sub_82CA93D0(ctx, base);
	// 82E8F788: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 82E8F78C: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82E8F790: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8F794: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82E8F798: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E8F79C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8F7A0: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82E8F7A4: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82E8F7A8: 4BFFFE79  bl 0x82e8f620
	ctx.lr = 0x82E8F7AC;
	sub_82E8F620(ctx, base);
	// 82E8F7AC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8F7B0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E8F7B4: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8F7B8: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82E8F7BC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E8F7C0: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82E8F7C4: 810B003C  lwz r8, 0x3c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82E8F7C8: C3EA0C18  lfs f31, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E8F7CC: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E8F7D0: 7D69402E  lwzx r11, r9, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82E8F7D4: D3FB0000  stfs f31, 0(r27)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E8F7D8: 813E014C  lwz r9, 0x14c(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(332 as u32) ) } as u64;
	// 82E8F7DC: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82E8F7E0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E8F7E4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E8F7E8: 3BEB0004  addi r31, r11, 4
	ctx.r[31].s64 = ctx.r[11].s64 + 4;
	// 82E8F7EC: 40990090  ble cr6, 0x82e8f87c
	if !ctx.cr[6].gt {
	pc = 0x82E8F87C; continue 'dispatch;
	}
	// 82E8F7F0: 3B9E00F8  addi r28, r30, 0xf8
	ctx.r[28].s64 = ctx.r[30].s64 + 248;
	pc = 0x82E8F7F4; continue 'dispatch;
            }
            0x82E8F7F4 => {
    //   block [0x82E8F7F4..0x82E8F868)
	// 82E8F7F4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8F7F8: C1BF0000  lfs f13, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8F7FC: C19F0004  lfs f12, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8F800: 388B0034  addi r4, r11, 0x34
	ctx.r[4].s64 = ctx.r[11].s64 + 52;
	// 82E8F804: C17F0008  lfs f11, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8F808: C01E0154  lfs f0, 0x154(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8F80C: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8F810: C1440000  lfs f10, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E8F814: EDAD5028  fsubs f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82E8F818: C1240004  lfs f9, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E8F81C: ED8C4828  fsubs f12, f12, f9
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 82E8F820: C1440008  lfs f10, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E8F824: ED6B5028  fsubs f11, f11, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 82E8F828: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82E8F82C: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82E8F830: EDAB6AFA  fmadds f13, f11, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 82E8F834: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E8F838: 41980030  blt cr6, 0x82e8f868
	if ctx.cr[6].lt {
	pc = 0x82E8F868; continue 'dispatch;
	}
	// 82E8F83C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82E8F840: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E8F844: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E8F848: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8F84C: 4B79FCC5  bl 0x8262f510
	ctx.lr = 0x82E8F850;
	sub_8262F510(ctx, base);
	// 82E8F850: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8F854: 40820014  bne 0x82e8f868
	if !ctx.cr[0].eq {
	pc = 0x82E8F868; continue 'dispatch;
	}
	// 82E8F858: C01E0150  lfs f0, 0x150(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(336 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8F85C: C1BB0000  lfs f13, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8F860: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82E8F864: D01B0000  stfs f0, 0(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x82E8F868; continue 'dispatch;
            }
            0x82E8F868 => {
    //   block [0x82E8F868..0x82E8F87C)
	// 82E8F868: 817E014C  lwz r11, 0x14c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(332 as u32) ) } as u64;
	// 82E8F86C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82E8F870: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82E8F874: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8F878: 4198FF7C  blt cr6, 0x82e8f7f4
	if ctx.cr[6].lt {
	pc = 0x82E8F7F4; continue 'dispatch;
	}
	pc = 0x82E8F87C; continue 'dispatch;
            }
            0x82E8F87C => {
    //   block [0x82E8F87C..0x82E8F890)
	// 82E8F87C: 817E0148  lwz r11, 0x148(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(328 as u32) ) } as u64;
	// 82E8F880: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82E8F884: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8F888: 4099008C  ble cr6, 0x82e8f914
	if !ctx.cr[6].gt {
	pc = 0x82E8F914; continue 'dispatch;
	}
	// 82E8F88C: 3BBE0008  addi r29, r30, 8
	ctx.r[29].s64 = ctx.r[30].s64 + 8;
	pc = 0x82E8F890; continue 'dispatch;
            }
            0x82E8F890 => {
    //   block [0x82E8F890..0x82E8F900)
	// 82E8F890: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8F894: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8F898: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E8F89C: C19F0004  lfs f12, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8F8A0: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8F8A4: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E8F8A8: C17D0008  lfs f11, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8F8AC: C19F0008  lfs f12, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8F8B0: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E8F8B4: C17E0154  lfs f11, 0x154(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(340 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8F8B8: ED6B02F2  fmuls f11, f11, f11
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 82E8F8BC: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8F8C0: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8F8C4: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8F8C8: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 82E8F8CC: 41980034  blt cr6, 0x82e8f900
	if ctx.cr[6].lt {
	pc = 0x82E8F900; continue 'dispatch;
	}
	// 82E8F8D0: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82E8F8D4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E8F8D8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E8F8DC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E8F8E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8F8E4: 4B79FC2D  bl 0x8262f510
	ctx.lr = 0x82E8F8E8;
	sub_8262F510(ctx, base);
	// 82E8F8E8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8F8EC: 40820014  bne 0x82e8f900
	if !ctx.cr[0].eq {
	pc = 0x82E8F900; continue 'dispatch;
	}
	// 82E8F8F0: C01E0150  lfs f0, 0x150(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(336 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8F8F4: C1BB0000  lfs f13, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8F8F8: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82E8F8FC: D01B0000  stfs f0, 0(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x82E8F900; continue 'dispatch;
            }
            0x82E8F900 => {
    //   block [0x82E8F900..0x82E8F914)
	// 82E8F900: 817E0148  lwz r11, 0x148(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(328 as u32) ) } as u64;
	// 82E8F904: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82E8F908: 3BBD000C  addi r29, r29, 0xc
	ctx.r[29].s64 = ctx.r[29].s64 + 12;
	// 82E8F90C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8F910: 4198FF80  blt cr6, 0x82e8f890
	if ctx.cr[6].lt {
	pc = 0x82E8F890; continue 'dispatch;
	}
	pc = 0x82E8F914; continue 'dispatch;
            }
            0x82E8F914 => {
    //   block [0x82E8F914..0x82E8F934)
	// 82E8F914: C01B0000  lfs f0, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8F918: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E8F91C: EC00F02A  fadds f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82E8F920: D01B0000  stfs f0, 0(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E8F924: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E8F928: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82E8F92C: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82E8F930: 4BE19B20  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8F938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8F938 size=440
    let mut pc: u32 = 0x82E8F938;
    'dispatch: loop {
        match pc {
            0x82E8F938 => {
    //   block [0x82E8F938..0x82E8F9B0)
	// 82E8F938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8F93C: 4BE19AC5  bl 0x82ca9400
	ctx.lr = 0x82E8F940;
	sub_82CA93D0(ctx, base);
	// 82E8F940: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 82E8F944: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82E8F948: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8F94C: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82E8F950: C1A50000  lfs f13, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8F954: C1650008  lfs f11, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8F958: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8F95C: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82E8F960: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E8F964: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82E8F968: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8F96C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82E8F970: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E8F974: C19F0004  lfs f12, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8F978: C1A50004  lfs f13, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8F97C: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E8F980: C19F0008  lfs f12, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8F984: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E8F988: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E8F98C: D3FB0000  stfs f31, 0(r27)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E8F990: 817E014C  lwz r11, 0x14c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(332 as u32) ) } as u64;
	// 82E8F994: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8F998: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8F99C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8F9A0: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8F9A4: EFC0002C  fsqrts f30, f0
	ctx.f[30].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82E8F9A8: 40990090  ble cr6, 0x82e8fa38
	if !ctx.cr[6].gt {
	pc = 0x82E8FA38; continue 'dispatch;
	}
	// 82E8F9AC: 3BBE00F8  addi r29, r30, 0xf8
	ctx.r[29].s64 = ctx.r[30].s64 + 248;
	pc = 0x82E8F9B0; continue 'dispatch;
            }
            0x82E8F9B0 => {
    //   block [0x82E8F9B0..0x82E8FA24)
	// 82E8F9B0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8F9B4: C1BF0000  lfs f13, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8F9B8: C19F0004  lfs f12, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8F9BC: 388B0034  addi r4, r11, 0x34
	ctx.r[4].s64 = ctx.r[11].s64 + 52;
	// 82E8F9C0: C17F0008  lfs f11, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8F9C4: C01E0154  lfs f0, 0x154(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8F9C8: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8F9CC: C1440000  lfs f10, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E8F9D0: EDAD5028  fsubs f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82E8F9D4: C1240004  lfs f9, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E8F9D8: ED8C4828  fsubs f12, f12, f9
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 82E8F9DC: C1440008  lfs f10, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E8F9E0: ED6B5028  fsubs f11, f11, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[10].f64) as f32) as f64);
	// 82E8F9E4: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82E8F9E8: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82E8F9EC: EDAB6AFA  fmadds f13, f11, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 82E8F9F0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82E8F9F4: 41980030  blt cr6, 0x82e8fa24
	if ctx.cr[6].lt {
	pc = 0x82E8FA24; continue 'dispatch;
	}
	// 82E8F9F8: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82E8F9FC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E8FA00: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E8FA04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8FA08: 4B79FB09  bl 0x8262f510
	ctx.lr = 0x82E8FA0C;
	sub_8262F510(ctx, base);
	// 82E8FA0C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8FA10: 40820014  bne 0x82e8fa24
	if !ctx.cr[0].eq {
	pc = 0x82E8FA24; continue 'dispatch;
	}
	// 82E8FA14: C01E0150  lfs f0, 0x150(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(336 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8FA18: C1BB0000  lfs f13, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8FA1C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82E8FA20: D01B0000  stfs f0, 0(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x82E8FA24; continue 'dispatch;
            }
            0x82E8FA24 => {
    //   block [0x82E8FA24..0x82E8FA38)
	// 82E8FA24: 817E014C  lwz r11, 0x14c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(332 as u32) ) } as u64;
	// 82E8FA28: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82E8FA2C: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82E8FA30: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8FA34: 4198FF7C  blt cr6, 0x82e8f9b0
	if ctx.cr[6].lt {
	pc = 0x82E8F9B0; continue 'dispatch;
	}
	pc = 0x82E8FA38; continue 'dispatch;
            }
            0x82E8FA38 => {
    //   block [0x82E8FA38..0x82E8FA4C)
	// 82E8FA38: 817E0148  lwz r11, 0x148(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(328 as u32) ) } as u64;
	// 82E8FA3C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82E8FA40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8FA44: 4099008C  ble cr6, 0x82e8fad0
	if !ctx.cr[6].gt {
	pc = 0x82E8FAD0; continue 'dispatch;
	}
	// 82E8FA48: 3BBE0008  addi r29, r30, 8
	ctx.r[29].s64 = ctx.r[30].s64 + 8;
	pc = 0x82E8FA4C; continue 'dispatch;
            }
            0x82E8FA4C => {
    //   block [0x82E8FA4C..0x82E8FABC)
	// 82E8FA4C: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8FA50: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8FA54: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E8FA58: C19F0004  lfs f12, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8FA5C: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8FA60: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E8FA64: C17D0008  lfs f11, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8FA68: C19F0008  lfs f12, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8FA6C: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E8FA70: C17E0154  lfs f11, 0x154(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(340 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8FA74: ED6B02F2  fmuls f11, f11, f11
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 82E8FA78: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8FA7C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8FA80: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8FA84: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 82E8FA88: 41980034  blt cr6, 0x82e8fabc
	if ctx.cr[6].lt {
	pc = 0x82E8FABC; continue 'dispatch;
	}
	// 82E8FA8C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82E8FA90: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E8FA94: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E8FA98: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E8FA9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8FAA0: 4B79FA71  bl 0x8262f510
	ctx.lr = 0x82E8FAA4;
	sub_8262F510(ctx, base);
	// 82E8FAA4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8FAA8: 40820014  bne 0x82e8fabc
	if !ctx.cr[0].eq {
	pc = 0x82E8FABC; continue 'dispatch;
	}
	// 82E8FAAC: C01E0150  lfs f0, 0x150(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(336 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8FAB0: C1BB0000  lfs f13, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8FAB4: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82E8FAB8: D01B0000  stfs f0, 0(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x82E8FABC; continue 'dispatch;
            }
            0x82E8FABC => {
    //   block [0x82E8FABC..0x82E8FAD0)
	// 82E8FABC: 817E0148  lwz r11, 0x148(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(328 as u32) ) } as u64;
	// 82E8FAC0: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82E8FAC4: 3BBD000C  addi r29, r29, 0xc
	ctx.r[29].s64 = ctx.r[29].s64 + 12;
	// 82E8FAC8: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8FACC: 4198FF80  blt cr6, 0x82e8fa4c
	if ctx.cr[6].lt {
	pc = 0x82E8FA4C; continue 'dispatch;
	}
	pc = 0x82E8FAD0; continue 'dispatch;
            }
            0x82E8FAD0 => {
    //   block [0x82E8FAD0..0x82E8FAF0)
	// 82E8FAD0: C01B0000  lfs f0, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8FAD4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E8FAD8: EC00F02A  fadds f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82E8FADC: D01B0000  stfs f0, 0(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E8FAE0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E8FAE4: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82E8FAE8: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82E8FAEC: 4BE19964  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8FAF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8FAF0 size=56
    let mut pc: u32 = 0x82E8FAF0;
    'dispatch: loop {
        match pc {
            0x82E8FAF0 => {
    //   block [0x82E8FAF0..0x82E8FB14)
	// 82E8FAF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8FAF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8FAF8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8FAFC: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 82E8FB00: 4B786E29  bl 0x82616928
	ctx.lr = 0x82E8FB04;
	sub_82616928(ctx, base);
	// 82E8FB04: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8FB08: 4182000C  beq 0x82e8fb14
	if ctx.cr[0].eq {
	pc = 0x82E8FB14; continue 'dispatch;
	}
	// 82E8FB0C: 4BFFF5F5  bl 0x82e8f100
	ctx.lr = 0x82E8FB10;
	sub_82E8F100(ctx, base);
	// 82E8FB10: 48000008  b 0x82e8fb18
	pc = 0x82E8FB18; continue 'dispatch;
            }
            0x82E8FB14 => {
    //   block [0x82E8FB14..0x82E8FB18)
	// 82E8FB14: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E8FB18; continue 'dispatch;
            }
            0x82E8FB18 => {
    //   block [0x82E8FB18..0x82E8FB28)
	// 82E8FB18: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8FB1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8FB20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8FB24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8FB28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8FB28 size=324
    let mut pc: u32 = 0x82E8FB28;
    'dispatch: loop {
        match pc {
            0x82E8FB28 => {
    //   block [0x82E8FB28..0x82E8FBB0)
	// 82E8FB28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8FB2C: 4BE198D5  bl 0x82ca9400
	ctx.lr = 0x82E8FB30;
	sub_82CA93D0(ctx, base);
	// 82E8FB30: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 82E8FB34: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82E8FB38: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8FB3C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82E8FB40: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E8FB44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8FB48: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82E8FB4C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82E8FB50: 4BFFFAD1  bl 0x82e8f620
	ctx.lr = 0x82E8FB54;
	sub_82E8F620(ctx, base);
	// 82E8FB54: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8FB58: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E8FB5C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8FB60: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82E8FB64: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82E8FB68: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82E8FB6C: 810B003C  lwz r8, 0x3c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82E8FB70: C3EA0C18  lfs f31, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E8FB74: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E8FB78: 7D69402E  lwzx r11, r9, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82E8FB7C: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82E8FB80: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E8FB84: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8FB88: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E8FB8C: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8FB90: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E8FB94: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8FB98: D3FD0000  stfs f31, 0(r29)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E8FB9C: 817E0058  lwz r11, 0x58(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) } as u64;
	// 82E8FBA0: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E8FBA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8FBA8: 409900A4  ble cr6, 0x82e8fc4c
	if !ctx.cr[6].gt {
	pc = 0x82E8FC4C; continue 'dispatch;
	}
	// 82E8FBAC: 3B7E0008  addi r27, r30, 8
	ctx.r[27].s64 = ctx.r[30].s64 + 8;
	pc = 0x82E8FBB0; continue 'dispatch;
            }
            0x82E8FBB0 => {
    //   block [0x82E8FBB0..0x82E8FC38)
	// 82E8FBB0: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8FBB4: C01E0060  lfs f0, 0x60(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8FBB8: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8FBBC: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8FBC0: 3BE40034  addi r31, r4, 0x34
	ctx.r[31].s64 = ctx.r[4].s64 + 52;
	// 82E8FBC4: C1410058  lfs f10, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E8FBC8: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8FBCC: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E8FBD0: C1810054  lfs f12, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8FBD4: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8FBD8: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E8FBDC: C19F0008  lfs f12, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8FBE0: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E8FBE4: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8FBE8: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8FBEC: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8FBF0: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 82E8FBF4: 41980044  blt cr6, 0x82e8fc38
	if ctx.cr[6].lt {
	pc = 0x82E8FC38; continue 'dispatch;
	}
	// 82E8FBF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E8FBFC: 4BFE916D  bl 0x82e78d68
	ctx.lr = 0x82E8FC00;
	sub_82E78D68(ctx, base);
	// 82E8FC00: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8FC04: 41820034  beq 0x82e8fc38
	if ctx.cr[0].eq {
	pc = 0x82E8FC38; continue 'dispatch;
	}
	// 82E8FC08: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82E8FC0C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E8FC10: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E8FC14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E8FC18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E8FC1C: 4B79F8F5  bl 0x8262f510
	ctx.lr = 0x82E8FC20;
	sub_8262F510(ctx, base);
	// 82E8FC20: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8FC24: 40820014  bne 0x82e8fc38
	if !ctx.cr[0].eq {
	pc = 0x82E8FC38; continue 'dispatch;
	}
	// 82E8FC28: C01E005C  lfs f0, 0x5c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8FC2C: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8FC30: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82E8FC34: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x82E8FC38; continue 'dispatch;
            }
            0x82E8FC38 => {
    //   block [0x82E8FC38..0x82E8FC4C)
	// 82E8FC38: 817E0058  lwz r11, 0x58(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) } as u64;
	// 82E8FC3C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82E8FC40: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82E8FC44: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8FC48: 4198FF68  blt cr6, 0x82e8fbb0
	if ctx.cr[6].lt {
	pc = 0x82E8FBB0; continue 'dispatch;
	}
	pc = 0x82E8FC4C; continue 'dispatch;
            }
            0x82E8FC4C => {
    //   block [0x82E8FC4C..0x82E8FC6C)
	// 82E8FC4C: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8FC50: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E8FC54: EC00F02A  fadds f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82E8FC58: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E8FC5C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82E8FC60: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82E8FC64: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82E8FC68: 4BE197E8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8FC70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8FC70 size=316
    let mut pc: u32 = 0x82E8FC70;
    'dispatch: loop {
        match pc {
            0x82E8FC70 => {
    //   block [0x82E8FC70..0x82E8FCF0)
	// 82E8FC70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8FC74: 4BE1978D  bl 0x82ca9400
	ctx.lr = 0x82E8FC78;
	sub_82CA93D0(ctx, base);
	// 82E8FC78: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 82E8FC7C: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82E8FC80: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8FC84: C0060000  lfs f0, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8FC88: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E8FC8C: C1650000  lfs f11, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8FC90: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 82E8FC94: ED605828  fsubs f11, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E8FC98: C1A60004  lfs f13, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8FC9C: C1450004  lfs f10, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E8FCA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E8FCA4: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E8FCA8: ED4D5028  fsubs f10, f13, f10
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82E8FCAC: C1860008  lfs f12, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8FCB0: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82E8FCB4: C1250008  lfs f9, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E8FCB8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82E8FCBC: ED2C4828  fsubs f9, f12, f9
	ctx.f[9].f64 = (((ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 82E8FCC0: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82E8FCC4: D3FD0000  stfs f31, 0(r29)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E8FCC8: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82E8FCCC: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E8FCD0: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E8FCD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8FCD8: EC0B02F2  fmuls f0, f11, f11
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 82E8FCDC: EC0A02BA  fmadds f0, f10, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8FCE0: EC09027A  fmadds f0, f9, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8FCE4: EFC0002C  fsqrts f30, f0
	ctx.f[30].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82E8FCE8: 409900A4  ble cr6, 0x82e8fd8c
	if !ctx.cr[6].gt {
	pc = 0x82E8FD8C; continue 'dispatch;
	}
	// 82E8FCEC: 3B9F0008  addi r28, r31, 8
	ctx.r[28].s64 = ctx.r[31].s64 + 8;
	pc = 0x82E8FCF0; continue 'dispatch;
            }
            0x82E8FCF0 => {
    //   block [0x82E8FCF0..0x82E8FD78)
	// 82E8FCF0: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8FCF4: C01F0060  lfs f0, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8FCF8: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8FCFC: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8FD00: 3BC40034  addi r30, r4, 0x34
	ctx.r[30].s64 = ctx.r[4].s64 + 52;
	// 82E8FD04: C1410058  lfs f10, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82E8FD08: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8FD0C: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E8FD10: C1810054  lfs f12, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8FD14: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8FD18: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E8FD1C: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8FD20: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E8FD24: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8FD28: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8FD2C: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8FD30: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 82E8FD34: 41980044  blt cr6, 0x82e8fd78
	if ctx.cr[6].lt {
	pc = 0x82E8FD78; continue 'dispatch;
	}
	// 82E8FD38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E8FD3C: 4BFE902D  bl 0x82e78d68
	ctx.lr = 0x82E8FD40;
	sub_82E78D68(ctx, base);
	// 82E8FD40: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8FD44: 41820034  beq 0x82e8fd78
	if ctx.cr[0].eq {
	pc = 0x82E8FD78; continue 'dispatch;
	}
	// 82E8FD48: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82E8FD4C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E8FD50: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E8FD54: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E8FD58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E8FD5C: 4B79F7B5  bl 0x8262f510
	ctx.lr = 0x82E8FD60;
	sub_8262F510(ctx, base);
	// 82E8FD60: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E8FD64: 40820014  bne 0x82e8fd78
	if !ctx.cr[0].eq {
	pc = 0x82E8FD78; continue 'dispatch;
	}
	// 82E8FD68: C01F005C  lfs f0, 0x5c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8FD6C: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8FD70: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82E8FD74: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x82E8FD78; continue 'dispatch;
            }
            0x82E8FD78 => {
    //   block [0x82E8FD78..0x82E8FD8C)
	// 82E8FD78: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82E8FD7C: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82E8FD80: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82E8FD84: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8FD88: 4198FF68  blt cr6, 0x82e8fcf0
	if ctx.cr[6].lt {
	pc = 0x82E8FCF0; continue 'dispatch;
	}
	pc = 0x82E8FD8C; continue 'dispatch;
            }
            0x82E8FD8C => {
    //   block [0x82E8FD8C..0x82E8FDAC)
	// 82E8FD8C: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8FD90: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E8FD94: EC00F02A  fadds f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82E8FD98: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E8FD9C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82E8FDA0: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82E8FDA4: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82E8FDA8: 4BE196A8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8FDB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E8FDB0 size=56
    let mut pc: u32 = 0x82E8FDB0;
    'dispatch: loop {
        match pc {
            0x82E8FDB0 => {
    //   block [0x82E8FDB0..0x82E8FDD4)
	// 82E8FDB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8FDB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8FDB8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8FDBC: 38600158  li r3, 0x158
	ctx.r[3].s64 = 344;
	// 82E8FDC0: 4B786B69  bl 0x82616928
	ctx.lr = 0x82E8FDC4;
	sub_82616928(ctx, base);
	// 82E8FDC4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E8FDC8: 4182000C  beq 0x82e8fdd4
	if ctx.cr[0].eq {
	pc = 0x82E8FDD4; continue 'dispatch;
	}
	// 82E8FDCC: 4BFFF3B5  bl 0x82e8f180
	ctx.lr = 0x82E8FDD0;
	sub_82E8F180(ctx, base);
	// 82E8FDD0: 48000008  b 0x82e8fdd8
	pc = 0x82E8FDD8; continue 'dispatch;
            }
            0x82E8FDD4 => {
    //   block [0x82E8FDD4..0x82E8FDD8)
	// 82E8FDD4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E8FDD8; continue 'dispatch;
            }
            0x82E8FDD8 => {
    //   block [0x82E8FDD8..0x82E8FDE8)
	// 82E8FDD8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E8FDDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E8FDE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E8FDE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8FDE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8FDE8 size=448
    let mut pc: u32 = 0x82E8FDE8;
    'dispatch: loop {
        match pc {
            0x82E8FDE8 => {
    //   block [0x82E8FDE8..0x82E8FE9C)
	// 82E8FDE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8FDEC: 4BE19611  bl 0x82ca93fc
	ctx.lr = 0x82E8FDF0;
	sub_82CA93D0(ctx, base);
	// 82E8FDF0: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82E8FDF4: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8FDF8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82E8FDFC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E8FE00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E8FE04: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82E8FE08: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82E8FE0C: 4BFFF815  bl 0x82e8f620
	ctx.lr = 0x82E8FE10;
	sub_82E8F620(ctx, base);
	// 82E8FE10: D03D0000  stfs f1, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E8FE14: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8FE18: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8FE1C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82E8FE20: 811E0148  lwz r8, 0x148(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(328 as u32) ) } as u64;
	// 82E8FE24: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8FE28: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82E8FE2C: 80CB0038  lwz r6, 0x38(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E8FE30: 80AB003C  lwz r5, 0x3c(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82E8FE34: 80EB0018  lwz r7, 0x18(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E8FE38: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 82E8FE3C: 7D66502E  lwzx r11, r6, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E8FE40: 7D45502E  lwzx r10, r5, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E8FE44: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82E8FE48: 1D4A0014  mulli r10, r10, 0x14
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 20 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82E8FE4C: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 82E8FE50: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82E8FE54: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8FE58: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8FE5C: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82E8FE60: C18A000C  lfs f12, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8FE64: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8FE68: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E8FE6C: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8FE70: EC0C6828  fsubs f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E8FE74: C1AA0008  lfs f13, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8FE78: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8FE7C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E8FE80: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E8FE84: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E8FE88: EC00583A  fmadds f0, f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82E8FE8C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8FE90: EFE0002C  fsqrts f31, f0
	ctx.f[31].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82E8FE94: 40990078  ble cr6, 0x82e8ff0c
	if !ctx.cr[6].gt {
	pc = 0x82E8FF0C; continue 'dispatch;
	}
	// 82E8FE98: 38FE0008  addi r7, r30, 8
	ctx.r[7].s64 = ctx.r[30].s64 + 8;
	pc = 0x82E8FE9C; continue 'dispatch;
            }
            0x82E8FE9C => {
    //   block [0x82E8FE9C..0x82E8FF0C)
	// 82E8FE9C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8FEA0: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82E8FEA4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8FEA8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E8FEAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8FEB0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E8FEB4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E8FEB8: 836B003C  lwz r27, 0x3c(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82E8FEBC: 834B0038  lwz r26, 0x38(r11)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E8FEC0: 80AB0018  lwz r5, 0x18(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E8FEC4: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82E8FEC8: 7D7B502E  lwzx r11, r27, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E8FECC: 7F7A502E  lwzx r27, r26, r10
	ctx.r[27].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E8FED0: 1D4B0014  mulli r10, r11, 0x14
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 20 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82E8FED4: 1D7B0014  mulli r11, r27, 0x14
	ctx.r[11].s32 = ((ctx.r[27].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82E8FED8: 7D6B3214  add r11, r11, r6
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 82E8FEDC: 7D4A2A14  add r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[5].u64;
	// 82E8FEE0: 38AB0004  addi r5, r11, 4
	ctx.r[5].s64 = ctx.r[11].s64 + 4;
	// 82E8FEE4: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82E8FEE8: 4BFFF3A1  bl 0x82e8f288
	ctx.lr = 0x82E8FEEC;
	sub_82E8F288(ctx, base);
	// 82E8FEEC: C01D0000  lfs f0, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8FEF0: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8FEF4: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E8FEF8: 817E0148  lwz r11, 0x148(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(328 as u32) ) } as u64;
	// 82E8FEFC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82E8FF00: 38E7000C  addi r7, r7, 0xc
	ctx.r[7].s64 = ctx.r[7].s64 + 12;
	// 82E8FF04: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8FF08: 4198FF94  blt cr6, 0x82e8fe9c
	if ctx.cr[6].lt {
	pc = 0x82E8FE9C; continue 'dispatch;
	}
	pc = 0x82E8FF0C; continue 'dispatch;
            }
            0x82E8FF0C => {
    //   block [0x82E8FF0C..0x82E8FF20)
	// 82E8FF0C: 817E014C  lwz r11, 0x14c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(332 as u32) ) } as u64;
	// 82E8FF10: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82E8FF14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E8FF18: 40990080  ble cr6, 0x82e8ff98
	if !ctx.cr[6].gt {
	pc = 0x82E8FF98; continue 'dispatch;
	}
	// 82E8FF1C: 395E00F8  addi r10, r30, 0xf8
	ctx.r[10].s64 = ctx.r[30].s64 + 248;
	pc = 0x82E8FF20; continue 'dispatch;
            }
            0x82E8FF20 => {
    //   block [0x82E8FF20..0x82E8FF98)
	// 82E8FF20: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E8FF24: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82E8FF28: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8FF2C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E8FF30: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E8FF34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E8FF38: 54C6103A  slwi r6, r6, 2
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82E8FF3C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E8FF40: 38E70034  addi r7, r7, 0x34
	ctx.r[7].s64 = ctx.r[7].s64 + 52;
	// 82E8FF44: 834B003C  lwz r26, 0x3c(r11)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82E8FF48: 832B0038  lwz r25, 0x38(r11)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E8FF4C: 836B0018  lwz r27, 0x18(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E8FF50: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82E8FF54: 7D7A302E  lwzx r11, r26, r6
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 82E8FF58: 7F59302E  lwzx r26, r25, r6
	ctx.r[26].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 82E8FF5C: 1CCB0014  mulli r6, r11, 0x14
	ctx.r[6].s32 = ((ctx.r[11].s32 as i64 * 20 as i64) as i32);
	ctx.r[6].s64 = ctx.r[6].s32 as i64;
	// 82E8FF60: 1D7A0014  mulli r11, r26, 0x14
	ctx.r[11].s32 = ((ctx.r[26].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82E8FF64: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 82E8FF68: 7CC6DA14  add r6, r6, r27
	ctx.r[6].u64 = ctx.r[6].u64 + ctx.r[27].u64;
	// 82E8FF6C: 38AB0004  addi r5, r11, 4
	ctx.r[5].s64 = ctx.r[11].s64 + 4;
	// 82E8FF70: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82E8FF74: 4BFFF315  bl 0x82e8f288
	ctx.lr = 0x82E8FF78;
	sub_82E8F288(ctx, base);
	// 82E8FF78: C01D0000  lfs f0, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8FF7C: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8FF80: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E8FF84: 817E014C  lwz r11, 0x14c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(332 as u32) ) } as u64;
	// 82E8FF88: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82E8FF8C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82E8FF90: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E8FF94: 4198FF8C  blt cr6, 0x82e8ff20
	if ctx.cr[6].lt {
	pc = 0x82E8FF20; continue 'dispatch;
	}
	pc = 0x82E8FF98; continue 'dispatch;
            }
            0x82E8FF98 => {
    //   block [0x82E8FF98..0x82E8FFA8)
	// 82E8FF98: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E8FF9C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82E8FFA0: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82E8FFA4: 4BE194A8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E8FFA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E8FFA8 size=308
    let mut pc: u32 = 0x82E8FFA8;
    'dispatch: loop {
        match pc {
            0x82E8FFA8 => {
    //   block [0x82E8FFA8..0x82E9004C)
	// 82E8FFA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E8FFAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E8FFB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E8FFB4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82E8FFB8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E8FFBC: C1A50000  lfs f13, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8FFC0: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 82E8FFC4: C0060000  lfs f0, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E8FFC8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82E8FFCC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E8FFD0: C1860004  lfs f12, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8FFD4: C1A50004  lfs f13, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E8FFD8: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E8FFDC: C1650008  lfs f11, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E8FFE0: C1860008  lfs f12, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E8FFE4: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E8FFE8: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E8FFEC: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8FFF0: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E8FFF4: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82E8FFF8: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E8FFFC: C1A50000  lfs f13, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E90000: 81630148  lwz r11, 0x148(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(328 as u32) ) } as u64;
	// 82E90004: C0060000  lfs f0, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E90008: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E9000C: C1850008  lfs f12, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E90010: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E90014: C1A60008  lfs f13, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E90018: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E9001C: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E90020: C1860004  lfs f12, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E90024: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E90028: ED6D0372  fmuls f11, f13, f13
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82E9002C: C1A50004  lfs f13, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E90030: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E90034: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E90038: EC00583A  fmadds f0, f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82E9003C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E90040: EFE0002C  fsqrts f31, f0
	ctx.f[31].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82E90044: 40990034  ble cr6, 0x82e90078
	if !ctx.cr[6].gt {
	pc = 0x82E90078; continue 'dispatch;
	}
	// 82E90048: 38E30008  addi r7, r3, 8
	ctx.r[7].s64 = ctx.r[3].s64 + 8;
	pc = 0x82E9004C; continue 'dispatch;
            }
            0x82E9004C => {
    //   block [0x82E9004C..0x82E90078)
	// 82E9004C: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82E90050: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E90054: 4BFFF235  bl 0x82e8f288
	ctx.lr = 0x82E90058;
	sub_82E8F288(ctx, base);
	// 82E90058: C00A0000  lfs f0, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E9005C: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E90060: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E90064: 81630148  lwz r11, 0x148(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(328 as u32) ) } as u64;
	// 82E90068: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82E9006C: 38E7000C  addi r7, r7, 0xc
	ctx.r[7].s64 = ctx.r[7].s64 + 12;
	// 82E90070: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E90074: 4198FFD8  blt cr6, 0x82e9004c
	if ctx.cr[6].lt {
	pc = 0x82E9004C; continue 'dispatch;
	}
	pc = 0x82E90078; continue 'dispatch;
            }
            0x82E90078 => {
    //   block [0x82E90078..0x82E9008C)
	// 82E90078: 8163014C  lwz r11, 0x14c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(332 as u32) ) } as u64;
	// 82E9007C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82E90080: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E90084: 4099003C  ble cr6, 0x82e900c0
	if !ctx.cr[6].gt {
	pc = 0x82E900C0; continue 'dispatch;
	}
	// 82E90088: 392300F8  addi r9, r3, 0xf8
	ctx.r[9].s64 = ctx.r[3].s64 + 248;
	pc = 0x82E9008C; continue 'dispatch;
            }
            0x82E9008C => {
    //   block [0x82E9008C..0x82E900C0)
	// 82E9008C: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E90090: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82E90094: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E90098: 38EB0034  addi r7, r11, 0x34
	ctx.r[7].s64 = ctx.r[11].s64 + 52;
	// 82E9009C: 4BFFF1ED  bl 0x82e8f288
	ctx.lr = 0x82E900A0;
	sub_82E8F288(ctx, base);
	// 82E900A0: C00A0000  lfs f0, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E900A4: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E900A8: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E900AC: 8163014C  lwz r11, 0x14c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(332 as u32) ) } as u64;
	// 82E900B0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82E900B4: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82E900B8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E900BC: 4198FFD0  blt cr6, 0x82e9008c
	if ctx.cr[6].lt {
	pc = 0x82E9008C; continue 'dispatch;
	}
	pc = 0x82E900C0; continue 'dispatch;
            }
            0x82E900C0 => {
    //   block [0x82E900C0..0x82E900DC)
	// 82E900C0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E900C4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E900C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E900CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E900D0: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E900D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E900D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E900E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E900E0 size=184
    let mut pc: u32 = 0x82E900E0;
    'dispatch: loop {
        match pc {
            0x82E900E0 => {
    //   block [0x82E900E0..0x82E9010C)
	// 82E900E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E900E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E900E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E900EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E900F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E900F4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E900F8: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82E900FC: C1AB0014  lfs f13, 0x14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E90100: C00A0C18  lfs f0, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E90104: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82E90108: 409A000C  bne cr6, 0x82e90114
	if !ctx.cr[6].eq {
	pc = 0x82E90114; continue 'dispatch;
	}
	pc = 0x82E9010C; continue 'dispatch;
            }
            0x82E9010C => {
    //   block [0x82E9010C..0x82E90114)
	// 82E9010C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E90110: 48000074  b 0x82e90184
	pc = 0x82E90184; continue 'dispatch;
            }
            0x82E90114 => {
    //   block [0x82E90114..0x82E90184)
	// 82E90114: 81450004  lwz r10, 4(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E90118: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E9011C: 81250000  lwz r9, 0(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E90120: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82E90124: C18B0010  lfs f12, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E90128: ED400032  fmuls f10, f0, f0
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E9012C: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82E90130: C16B000C  lfs f11, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82E90134: 810A003C  lwz r8, 0x3c(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) } as u64;
	// 82E90138: 814A0018  lwz r10, 0x18(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E9013C: 7D69402E  lwzx r11, r9, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82E90140: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82E90144: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E90148: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E9014C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82E90150: C12B000C  lfs f9, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82E90154: EDA96028  fsubs f13, f9, f12
	ctx.f[13].f64 = (((ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 82E90158: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82E9015C: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82E90160: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82E90164: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E90168: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82E9016C: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82E90170: 4199FF9C  bgt cr6, 0x82e9010c
	if ctx.cr[6].gt {
	pc = 0x82E9010C; continue 'dispatch;
	}
	// 82E90174: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82E90178: 4BFFF4A9  bl 0x82e8f620
	ctx.lr = 0x82E9017C;
	sub_82E8F620(ctx, base);
	// 82E9017C: D03F0000  stfs f1, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82E90180: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82E90184; continue 'dispatch;
            }
            0x82E90184 => {
    //   block [0x82E90184..0x82E90198)
	// 82E90184: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E90188: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E9018C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E90190: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E90194: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E90198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E90198 size=56
    let mut pc: u32 = 0x82E90198;
    'dispatch: loop {
        match pc {
            0x82E90198 => {
    //   block [0x82E90198..0x82E901BC)
	// 82E90198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E9019C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E901A0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E901A4: 38600158  li r3, 0x158
	ctx.r[3].s64 = 344;
	// 82E901A8: 4B786781  bl 0x82616928
	ctx.lr = 0x82E901AC;
	sub_82616928(ctx, base);
	// 82E901AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E901B0: 4182000C  beq 0x82e901bc
	if ctx.cr[0].eq {
	pc = 0x82E901BC; continue 'dispatch;
	}
	// 82E901B4: 4BFFF52D  bl 0x82e8f6e0
	ctx.lr = 0x82E901B8;
	sub_82E8F6E0(ctx, base);
	// 82E901B8: 48000008  b 0x82e901c0
	pc = 0x82E901C0; continue 'dispatch;
            }
            0x82E901BC => {
    //   block [0x82E901BC..0x82E901C0)
	// 82E901BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E901C0; continue 'dispatch;
            }
            0x82E901C0 => {
    //   block [0x82E901C0..0x82E901D0)
	// 82E901C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E901C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E901C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E901CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E901D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E901D0 size=116
    let mut pc: u32 = 0x82E901D0;
    'dispatch: loop {
        match pc {
            0x82E901D0 => {
    //   block [0x82E901D0..0x82E90218)
	// 82E901D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E901D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E901D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E901DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E901E0: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82E901E4: 816A52B4  lwz r11, 0x52b4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(21172 as u32) ) } as u64;
	// 82E901E8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82E901EC: 3D208334  lis r9, -0x7ccc
	ctx.r[9].s64 = -2093744128;
	// 82E901F0: 3BE94EB0  addi r31, r9, 0x4eb0
	ctx.r[31].s64 = ctx.r[9].s64 + 20144;
	// 82E901F4: 40820038  bne 0x82e9022c
	if !ctx.cr[0].eq {
	pc = 0x82E9022C; continue 'dispatch;
	}
	// 82E901F8: 3D208330  lis r9, -0x7cd0
	ctx.r[9].s64 = -2094006272;
	// 82E901FC: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82E90200: 8909DCF0  lbz r8, -0x2310(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-8976 as u32) ) } as u64;
	// 82E90204: 916A52B4  stw r11, 0x52b4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(21172 as u32), ctx.r[11].u32 ) };
	// 82E90208: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E9020C: 4182000C  beq 0x82e90218
	if ctx.cr[0].eq {
	pc = 0x82E90218; continue 'dispatch;
	}
	// 82E90210: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E90214: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	pc = 0x82E90218; continue 'dispatch;
            }
            0x82E90218 => {
    //   block [0x82E90218..0x82E9022C)
	// 82E90218: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E9021C: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 82E90220: 386A8610  addi r3, r10, -0x79f0
	ctx.r[3].s64 = ctx.r[10].s64 + -31216;
	// 82E90224: 9969DCF0  stb r11, -0x2310(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(-8976 as u32), ctx.r[11].u8 ) };
	// 82E90228: 4BE19CF9  bl 0x82ca9f20
	ctx.lr = 0x82E9022C;
	sub_82CA9F20(ctx, base);
	pc = 0x82E9022C; continue 'dispatch;
            }
            0x82E9022C => {
    //   block [0x82E9022C..0x82E90244)
	// 82E9022C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E90230: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E90234: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E90238: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E9023C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E90240: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E90248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E90248 size=200
    let mut pc: u32 = 0x82E90248;
    'dispatch: loop {
        match pc {
            0x82E90248 => {
    //   block [0x82E90248..0x82E9027C)
	// 82E90248: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E9024C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E90250: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E90254: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E90258: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E9025C: 4BFFFF75  bl 0x82e901d0
	ctx.lr = 0x82E90260;
	sub_82E901D0(ctx, base);
	// 82E90260: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E90264: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82E90268: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E9026C: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E90270: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E90274: 40810054  ble 0x82e902c8
	if !ctx.cr[0].gt {
	pc = 0x82E902C8; continue 'dispatch;
	}
	// 82E90278: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82E9027C; continue 'dispatch;
            }
            0x82E9027C => {
    //   block [0x82E9027C..0x82E90288)
	// 82E9027C: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E90280: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82E90284: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	pc = 0x82E90288; continue 'dispatch;
            }
            0x82E90288 => {
    //   block [0x82E90288..0x82E902AC)
	// 82E90288: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E9028C: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E90290: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E90294: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82E90298: 41820014  beq 0x82e902ac
	if ctx.cr[0].eq {
	pc = 0x82E902AC; continue 'dispatch;
	}
	// 82E9029C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E902A0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82E902A4: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82E902A8: 419AFFE0  beq cr6, 0x82e90288
	if ctx.cr[6].eq {
	pc = 0x82E90288; continue 'dispatch;
	}
	pc = 0x82E902AC; continue 'dispatch;
            }
            0x82E902AC => {
    //   block [0x82E902AC..0x82E902C8)
	// 82E902AC: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E902B0: 41820028  beq 0x82e902d8
	if ctx.cr[0].eq {
	pc = 0x82E902D8; continue 'dispatch;
	}
	// 82E902B4: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E902B8: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82E902BC: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82E902C0: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82E902C4: 4198FFB8  blt cr6, 0x82e9027c
	if ctx.cr[6].lt {
	pc = 0x82E9027C; continue 'dispatch;
	}
	pc = 0x82E902C8; continue 'dispatch;
            }
            0x82E902C8 => {
    //   block [0x82E902C8..0x82E902D8)
	// 82E902C8: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82E902CC: 409A0018  bne cr6, 0x82e902e4
	if !ctx.cr[6].eq {
	pc = 0x82E902E4; continue 'dispatch;
	}
	// 82E902D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E902D4: 48000028  b 0x82e902fc
	pc = 0x82E902FC; continue 'dispatch;
            }
            0x82E902D8 => {
    //   block [0x82E902D8..0x82E902E4)
	// 82E902D8: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E902DC: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82E902E0: 48000018  b 0x82e902f8
	pc = 0x82E902F8; continue 'dispatch;
            }
            0x82E902E4 => {
    //   block [0x82E902E4..0x82E902F8)
	// 82E902E4: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E902E8: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82E902EC: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E902F0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E902F4: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	pc = 0x82E902F8; continue 'dispatch;
            }
            0x82E902F8 => {
    //   block [0x82E902F8..0x82E902FC)
	// 82E902F8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82E902FC; continue 'dispatch;
            }
            0x82E902FC => {
    //   block [0x82E902FC..0x82E90310)
	// 82E902FC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E90300: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E90304: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E90308: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E9030C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E90310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E90310 size=196
    let mut pc: u32 = 0x82E90310;
    'dispatch: loop {
        match pc {
            0x82E90310 => {
    //   block [0x82E90310..0x82E90348)
	// 82E90310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E90314: 4BE190F1  bl 0x82ca9404
	ctx.lr = 0x82E90318;
	sub_82CA93D0(ctx, base);
	// 82E90318: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E9031C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E90320: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E90324: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82E90328: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82E9032C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82E90330: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82E90334: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82E90338: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82E9033C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E90340: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82E90344: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	pc = 0x82E90348; continue 'dispatch;
            }
            0x82E90348 => {
    //   block [0x82E90348..0x82E90374)
	// 82E90348: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E9034C: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E90350: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82E90354: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E90358: 4082FFF0  bne 0x82e90348
	if !ctx.cr[0].eq {
	pc = 0x82E90348; continue 'dispatch;
	}
	// 82E9035C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E90360: 4BFFFEE9  bl 0x82e90248
	ctx.lr = 0x82E90364;
	sub_82E90248(ctx, base);
	// 82E90364: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E90368: 4082000C  bne 0x82e90374
	if !ctx.cr[0].eq {
	pc = 0x82E90374; continue 'dispatch;
	}
	// 82E9036C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82E90370: 48000010  b 0x82e90380
	pc = 0x82E90380; continue 'dispatch;
            }
            0x82E90374 => {
    //   block [0x82E90374..0x82E90380)
	// 82E90374: 4BFFFE5D  bl 0x82e901d0
	ctx.lr = 0x82E90378;
	sub_82E901D0(ctx, base);
	// 82E90378: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82E9037C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82E90380; continue 'dispatch;
            }
            0x82E90380 => {
    //   block [0x82E90380..0x82E903A4)
	// 82E90380: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E90384: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82E90388: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82E9038C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E90390: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82E90394: 409A0010  bne cr6, 0x82e903a4
	if !ctx.cr[6].eq {
	pc = 0x82E903A4; continue 'dispatch;
	}
	// 82E90398: 4BFEF6C1  bl 0x82e7fa58
	ctx.lr = 0x82E9039C;
	sub_82E7FA58(ctx, base);
	// 82E9039C: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82E903A0: 4800000C  b 0x82e903ac
	pc = 0x82E903AC; continue 'dispatch;
            }
            0x82E903A4 => {
    //   block [0x82E903A4..0x82E903AC)
	// 82E903A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E903A8: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	pc = 0x82E903AC; continue 'dispatch;
            }
            0x82E903AC => {
    //   block [0x82E903AC..0x82E903C8)
	// 82E903AC: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E903B0: 41820018  beq 0x82e903c8
	if ctx.cr[0].eq {
	pc = 0x82E903C8; continue 'dispatch;
	}
	// 82E903B4: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82E903B8: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82E903BC: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82E903C0: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82E903C4: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	pc = 0x82E903C8; continue 'dispatch;
            }
            0x82E903C8 => {
    //   block [0x82E903C8..0x82E903D4)
	// 82E903C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E903CC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E903D0: 4BE19084  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E903D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E903D8 size=84
    let mut pc: u32 = 0x82E903D8;
    'dispatch: loop {
        match pc {
            0x82E903D8 => {
    //   block [0x82E903D8..0x82E9042C)
	// 82E903D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E903DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E903E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E903E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E903E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E903EC: 4BFEEE3D  bl 0x82e7f228
	ctx.lr = 0x82E903F0;
	sub_82E7F228(ctx, base);
	// 82E903F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E903F4: 39200019  li r9, 0x19
	ctx.r[9].s64 = 25;
	// 82E903F8: 394B9A48  addi r10, r11, -0x65b8
	ctx.r[10].s64 = ctx.r[11].s64 + -26040;
	// 82E903FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E90400: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E90404: 913F007C  stw r9, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[9].u32 ) };
	// 82E90408: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E9040C: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82E90410: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82E90414: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82E90418: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E9041C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E90420: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E90424: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E90428: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E90430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E90430 size=120
    let mut pc: u32 = 0x82E90430;
    'dispatch: loop {
        match pc {
            0x82E90430 => {
    //   block [0x82E90430..0x82E90488)
	// 82E90430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E90434: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E90438: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E9043C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E90440: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E90444: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82E90448: 394A9A48  addi r10, r10, -0x65b8
	ctx.r[10].s64 = ctx.r[10].s64 + -26040;
	// 82E9044C: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82E90450: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E90454: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E90458: 41820034  beq 0x82e9048c
	if ctx.cr[0].eq {
	pc = 0x82E9048C; continue 'dispatch;
	}
	// 82E9045C: 814BFFFC  lwz r10, -4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82E90460: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82E90464: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E90468: 419A0020  beq cr6, 0x82e90488
	if ctx.cr[6].eq {
	pc = 0x82E90488; continue 'dispatch;
	}
	// 82E9046C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E90470: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E90474: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82E90478: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E9047C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E90480: 4E800421  bctrl
	ctx.lr = 0x82E90484;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E90484: 48000008  b 0x82e9048c
	pc = 0x82E9048C; continue 'dispatch;
            }
            0x82E90488 => {
    //   block [0x82E90488..0x82E9048C)
	// 82E90488: 4B9B5329  bl 0x828457b0
	ctx.lr = 0x82E9048C;
	sub_828457B0(ctx, base);
	pc = 0x82E9048C; continue 'dispatch;
            }
            0x82E9048C => {
    //   block [0x82E9048C..0x82E904A8)
	// 82E9048C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E90490: 4BFEE791  bl 0x82e7ec20
	ctx.lr = 0x82E90494;
	sub_82E7EC20(ctx, base);
	// 82E90494: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E90498: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E9049C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E904A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E904A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E904A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E904A8 size=124
    let mut pc: u32 = 0x82E904A8;
    'dispatch: loop {
        match pc {
            0x82E904A8 => {
    //   block [0x82E904A8..0x82E904CC)
	// 82E904A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E904AC: 4BE18F61  bl 0x82ca940c
	ctx.lr = 0x82E904B0;
	sub_82CA93D0(ctx, base);
	// 82E904B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E904B4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E904B8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E904BC: 4BFEE89D  bl 0x82e7ed58
	ctx.lr = 0x82E904C0;
	sub_82E7ED58(ctx, base);
	// 82E904C0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82E904C4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82E904C8: 409A000C  bne cr6, 0x82e904d4
	if !ctx.cr[6].eq {
	pc = 0x82E904D4; continue 'dispatch;
	}
	pc = 0x82E904CC; continue 'dispatch;
            }
            0x82E904CC => {
    //   block [0x82E904CC..0x82E904D4)
	// 82E904CC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E904D0: 4800004C  b 0x82e9051c
	pc = 0x82E9051C; continue 'dispatch;
            }
            0x82E904D4 => {
    //   block [0x82E904D4..0x82E90518)
	// 82E904D4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E904D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E904DC: 3BCB9AA8  addi r30, r11, -0x6558
	ctx.r[30].s64 = ctx.r[11].s64 + -25944;
	// 82E904E0: 4832BB81  bl 0x831bc060
	ctx.lr = 0x82E904E4;
	sub_831BC060(ctx, base);
	// 82E904E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E904E8: 4BE1C669  bl 0x82cacb50
	ctx.lr = 0x82E904EC;
	sub_82CACB50(ctx, base);
	// 82E904EC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E904F0: 40820028  bne 0x82e90518
	if !ctx.cr[0].eq {
	pc = 0x82E90518; continue 'dispatch;
	}
	// 82E904F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E904F8: 4BA7D811  bl 0x8290dd08
	ctx.lr = 0x82E904FC;
	sub_8290DD08(ctx, base);
	// 82E904FC: 4BE19EC5  bl 0x82caa3c0
	ctx.lr = 0x82E90500;
	sub_82CAA3C0(ctx, base);
	// 82E90500: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E90504: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E90508: 917D007C  stw r11, 0x7c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82E9050C: 4182FFC0  beq 0x82e904cc
	if ctx.cr[0].eq {
	pc = 0x82E904CC; continue 'dispatch;
	}
	// 82E90510: 907D007C  stw r3, 0x7c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(124 as u32), ctx.r[3].u32 ) };
	// 82E90514: 4BFFFFB8  b 0x82e904cc
	pc = 0x82E904CC; continue 'dispatch;
            }
            0x82E90518 => {
    //   block [0x82E90518..0x82E9051C)
	// 82E90518: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82E9051C; continue 'dispatch;
            }
            0x82E9051C => {
    //   block [0x82E9051C..0x82E90524)
	// 82E9051C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E90520: 4BE18F3C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E90528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E90528 size=24
    let mut pc: u32 = 0x82E90528;
    'dispatch: loop {
        match pc {
            0x82E90528 => {
    //   block [0x82E90528..0x82E90540)
	// 82E90528: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E9052C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E90530: C00B0BEC  lfs f0, 0xbec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E90534: D0030080  stfs f0, 0x80(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82E90538: 91430084  stw r10, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 82E9053C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E90540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E90540 size=272
    let mut pc: u32 = 0x82E90540;
    'dispatch: loop {
        match pc {
            0x82E90540 => {
    //   block [0x82E90540..0x82E9058C)
	// 82E90540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E90544: 4BE18EC1  bl 0x82ca9404
	ctx.lr = 0x82E90548;
	sub_82CA93D0(ctx, base);
	// 82E90548: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E9054C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82E90550: 817B0074  lwz r11, 0x74(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(116 as u32) ) } as u64;
	// 82E90554: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E90558: 419A00F0  beq cr6, 0x82e90648
	if ctx.cr[6].eq {
	pc = 0x82E90648; continue 'dispatch;
	}
	// 82E9055C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E90560: 388B2E38  addi r4, r11, 0x2e38
	ctx.r[4].s64 = ctx.r[11].s64 + 11832;
	// 82E90564: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82E90568: 806B0718  lwz r3, 0x718(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82E9056C: 4B3D76B5  bl 0x82267c20
	ctx.lr = 0x82E90570;
	sub_82267C20(ctx, base);
	// 82E90570: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82E90574: 418200D4  beq 0x82e90648
	if ctx.cr[0].eq {
	pc = 0x82E90648; continue 'dispatch;
	}
	// 82E90578: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E9057C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82E90580: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E90584: 409900B8  ble cr6, 0x82e9063c
	if !ctx.cr[6].gt {
	pc = 0x82E9063C; continue 'dispatch;
	}
	// 82E90588: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82E9058C; continue 'dispatch;
            }
            0x82E9058C => {
    //   block [0x82E9058C..0x82E905E4)
	// 82E9058C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E90590: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E90594: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E90598: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82E9059C: 814A0028  lwz r10, 0x28(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E905A0: 83AB0084  lwz r29, 0x84(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 82E905A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E905A8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E905AC: 4E800421  bctrl
	ctx.lr = 0x82E905B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E905B0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E905B4: 41820030  beq 0x82e905e4
	if ctx.cr[0].eq {
	pc = 0x82E905E4; continue 'dispatch;
	}
	// 82E905B8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E905BC: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82E905C0: 896B0088  lbz r11, 0x88(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
	// 82E905C4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E905C8: 4182001C  beq 0x82e905e4
	if ctx.cr[0].eq {
	pc = 0x82E905E4; continue 'dispatch;
	}
	// 82E905CC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E905D0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E905D4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82E905D8: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E905DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E905E0: 4E800421  bctrl
	ctx.lr = 0x82E905E4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E905E4 => {
    //   block [0x82E905E4..0x82E905FC)
	// 82E905E4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E905E8: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82E905EC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82E905F0: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E905F4: 4198FF98  blt cr6, 0x82e9058c
	if ctx.cr[6].lt {
	pc = 0x82E9058C; continue 'dispatch;
	}
	// 82E905F8: 48000044  b 0x82e9063c
	pc = 0x82E9063C; continue 'dispatch;
            }
            0x82E905FC => {
    //   block [0x82E905FC..0x82E9063C)
	// 82E905FC: 83DB0070  lwz r30, 0x70(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(112 as u32) ) } as u64;
	// 82E90600: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E90604: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E90608: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E9060C: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E90610: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E90614: 4E800421  bctrl
	ctx.lr = 0x82E90618;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E90618: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E9061C: 41820020  beq 0x82e9063c
	if ctx.cr[0].eq {
	pc = 0x82E9063C; continue 'dispatch;
	}
	// 82E90620: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E90624: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82E90628: 80BE0008  lwz r5, 8(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E9062C: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E90630: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82E90634: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E90638: 4E800421  bctrl
	ctx.lr = 0x82E9063C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82E9063C => {
    //   block [0x82E9063C..0x82E90648)
	// 82E9063C: 817B0074  lwz r11, 0x74(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(116 as u32) ) } as u64;
	// 82E90640: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E90644: 409AFFB8  bne cr6, 0x82e905fc
	if !ctx.cr[6].eq {
	pc = 0x82E905FC; continue 'dispatch;
	}
	pc = 0x82E90648; continue 'dispatch;
            }
            0x82E90648 => {
    //   block [0x82E90648..0x82E90650)
	// 82E90648: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E9064C: 4BE18E08  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


