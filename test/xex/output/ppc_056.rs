pub fn sub_824AAAD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AAAD8 size=492
    let mut pc: u32 = 0x824AAAD8;
    'dispatch: loop {
        match pc {
            0x824AAAD8 => {
    //   block [0x824AAAD8..0x824AACC4)
	// 824AAAD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AAADC: 4808A5D1  bl 0x825350ac
	ctx.lr = 0x824AAAE0;
	sub_82535080(ctx, base);
	// 824AAAE0: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AACC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AACC8 size=120
    let mut pc: u32 = 0x824AACC8;
    'dispatch: loop {
        match pc {
            0x824AACC8 => {
    //   block [0x824AACC8..0x824AACFC)
	// 824AACC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AACCC: 4808A3F1  bl 0x825350bc
	ctx.lr = 0x824AACD0;
	sub_82535080(ctx, base);
	// 824AACD0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AACD4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 824AACD8: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 824AACDC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824AACE0: 817D0084  lwz r11, 0x84(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(132 as u32) ) } as u64;
	// 824AACE4: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 824AACE8: 3BCBFFFF  addi r30, r11, -1
	ctx.r[30].s64 = ctx.r[11].s64 + -1;
	// 824AACEC: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 824AACF0: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 824AACF4: 41980044  blt cr6, 0x824aad38
	if ctx.cr[6].lt {
	pc = 0x824AAD38; continue 'dispatch;
	}
	// 824AACF8: 57DF103A  slwi r31, r30, 2
	ctx.r[31].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	pc = 0x824AACFC; continue 'dispatch;
            }
            0x824AACFC => {
    //   block [0x824AACFC..0x824AAD24)
	// 824AACFC: 817D0080  lwz r11, 0x80(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(128 as u32) ) } as u64;
	// 824AAD00: 7D4BF82E  lwzx r10, r11, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 824AAD04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824AAD08: 419A001C  beq cr6, 0x824aad24
	if ctx.cr[6].eq {
	pc = 0x824AAD24; continue 'dispatch;
	}
	// 824AAD0C: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 824AAD10: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824AAD14: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AAD18: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AAD1C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AAD20: 4E800421  bctrl
	ctx.lr = 0x824AAD24;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824AAD24 => {
    //   block [0x824AAD24..0x824AAD38)
	// 824AAD24: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 824AAD28: 3BFFFFFC  addi r31, r31, -4
	ctx.r[31].s64 = ctx.r[31].s64 + -4;
	// 824AAD2C: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 824AAD30: 4098FFCC  bge cr6, 0x824aacfc
	if !ctx.cr[6].lt {
	pc = 0x824AACFC; continue 'dispatch;
	}
	// 824AAD34: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	pc = 0x824AAD38; continue 'dispatch;
            }
            0x824AAD38 => {
    //   block [0x824AAD38..0x824AAD40)
	// 824AAD38: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 824AAD3C: 4808A3D0  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AAD40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AAD40 size=112
    let mut pc: u32 = 0x824AAD40;
    'dispatch: loop {
        match pc {
            0x824AAD40 => {
    //   block [0x824AAD40..0x824AAD70)
	// 824AAD40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AAD44: 4808A379  bl 0x825350bc
	ctx.lr = 0x824AAD48;
	sub_82535080(ctx, base);
	// 824AAD48: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AAD4C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 824AAD50: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 824AAD54: 98A10058  stb r5, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[5].u8 ) };
	// 824AAD58: 817D0084  lwz r11, 0x84(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(132 as u32) ) } as u64;
	// 824AAD5C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 824AAD60: 3BCBFFFF  addi r30, r11, -1
	ctx.r[30].s64 = ctx.r[11].s64 + -1;
	// 824AAD64: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 824AAD68: 41980040  blt cr6, 0x824aada8
	if ctx.cr[6].lt {
	pc = 0x824AADA8; continue 'dispatch;
	}
	// 824AAD6C: 57DF103A  slwi r31, r30, 2
	ctx.r[31].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	pc = 0x824AAD70; continue 'dispatch;
            }
            0x824AAD70 => {
    //   block [0x824AAD70..0x824AAD98)
	// 824AAD70: 817D0080  lwz r11, 0x80(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(128 as u32) ) } as u64;
	// 824AAD74: 7D4BF82E  lwzx r10, r11, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 824AAD78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824AAD7C: 419A001C  beq cr6, 0x824aad98
	if ctx.cr[6].eq {
	pc = 0x824AAD98; continue 'dispatch;
	}
	// 824AAD80: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 824AAD84: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824AAD88: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AAD8C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AAD90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AAD94: 4E800421  bctrl
	ctx.lr = 0x824AAD98;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824AAD98 => {
    //   block [0x824AAD98..0x824AADA8)
	// 824AAD98: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 824AAD9C: 3BFFFFFC  addi r31, r31, -4
	ctx.r[31].s64 = ctx.r[31].s64 + -4;
	// 824AADA0: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 824AADA4: 4098FFCC  bge cr6, 0x824aad70
	if !ctx.cr[6].lt {
	pc = 0x824AAD70; continue 'dispatch;
	}
	pc = 0x824AADA8; continue 'dispatch;
            }
            0x824AADA8 => {
    //   block [0x824AADA8..0x824AADB0)
	// 824AADA8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 824AADAC: 4808A360  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AADB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824AADB0 size=100
    let mut pc: u32 = 0x824AADB0;
    'dispatch: loop {
        match pc {
            0x824AADB0 => {
    //   block [0x824AADB0..0x824AAE14)
	// 824AADB0: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 824AADB4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824AADB8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 824AADBC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 824AADC0: 396BE914  addi r11, r11, -0x16ec
	ctx.r[11].s64 = ctx.r[11].s64 + -5868;
	// 824AADC4: C1AA0858  lfs f13, 0x858(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824AADC8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 824AADCC: B1230006  sth r9, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 824AADD0: 99030008  stb r8, 8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u8 ) };
	// 824AADD4: D1A3000C  stfs f13, 0xc(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 824AADD8: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824AADDC: C18A24B0  lfs f12, 0x24b0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9392 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 824AADE0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 824AADE4: D1830010  stfs f12, 0x10(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 824AADE8: 99230008  stb r9, 8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u8 ) };
	// 824AADEC: C16A207C  lfs f11, 0x207c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8316 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 824AADF0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 824AADF4: D1630014  stfs f11, 0x14(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 824AADF8: C00A1850  lfs f0, 0x1850(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824AADFC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 824AAE00: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 824AAE04: D0030020  stfs f0, 0x20(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 824AAE08: C14A2068  lfs f10, 0x2068(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8296 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 824AAE0C: D143001C  stfs f10, 0x1c(r3)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 824AAE10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AAE18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824AAE18 size=172
    let mut pc: u32 = 0x824AAE18;
    'dispatch: loop {
        match pc {
            0x824AAE18 => {
    //   block [0x824AAE18..0x824AAEC4)
	// 824AAE18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AAE1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AAE20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AAE24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AAE28: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AAE2C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 824AAE30: 38A0002C  li r5, 0x2c
	ctx.r[5].s64 = 44;
	// 824AAE34: 38800024  li r4, 0x24
	ctx.r[4].s64 = 36;
	// 824AAE38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824AAE3C: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824AAE40: 4BFB91F9  bl 0x82464038
	ctx.lr = 0x824AAE44;
	sub_82464038(ctx, base);
	// 824AAE44: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824AAE48: 39000024  li r8, 0x24
	ctx.r[8].s64 = 36;
	// 824AAE4C: 396BE2F8  addi r11, r11, -0x1d08
	ctx.r[11].s64 = ctx.r[11].s64 + -7432;
	// 824AAE50: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 824AAE54: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 824AAE58: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824AAE5C: B1030004  sth r8, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[8].u16 ) };
	// 824AAE60: 394AE30C  addi r10, r10, -0x1cf4
	ctx.r[10].s64 = ctx.r[10].s64 + -7412;
	// 824AAE64: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824AAE68: 3929E914  addi r9, r9, -0x16ec
	ctx.r[9].s64 = ctx.r[9].s64 + -5868;
	// 824AAE6C: B0E30006  sth r7, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[7].u16 ) };
	// 824AAE70: 897F0008  lbz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AAE74: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824AAE78: 99630008  stb r11, 8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u8 ) };
	// 824AAE7C: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824AAE80: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 824AAE84: C01F0010  lfs f0, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824AAE88: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824AAE8C: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 824AAE90: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824AAE94: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 824AAE98: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824AAE9C: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 824AAEA0: C01F001C  lfs f0, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824AAEA4: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 824AAEA8: C01F0020  lfs f0, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824AAEAC: D0030020  stfs f0, 0x20(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 824AAEB0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824AAEB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824AAEB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824AAEBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824AAEC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AAEC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AAEC8 size=32
    let mut pc: u32 = 0x824AAEC8;
    'dispatch: loop {
        match pc {
            0x824AAEC8 => {
    //   block [0x824AAEC8..0x824AAEE8)
	// 824AAEC8: 7C8B0774  extsb r11, r4
	ctx.r[11].s64 = ctx.r[4].s8 as i64;
	// 824AAECC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824AAED0: 419A0018  beq cr6, 0x824aaee8
	if ctx.cr[6].eq {
		sub_824AAEE8(ctx, base);
		return;
	}
	// 824AAED4: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 824AAED8: 39400028  li r10, 0x28
	ctx.r[10].s64 = 40;
	// 824AAEDC: 91650004  stw r11, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824AAEE0: 91450000  stw r10, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824AAEE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AAEE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AAEE8 size=16
    let mut pc: u32 = 0x824AAEE8;
    'dispatch: loop {
        match pc {
            0x824AAEE8 => {
    //   block [0x824AAEE8..0x824AAEF8)
	// 824AAEE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824AAEEC: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824AAEF0: 91650004  stw r11, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824AAEF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AAEF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AAEF8 size=16
    let mut pc: u32 = 0x824AAEF8;
    'dispatch: loop {
        match pc {
            0x824AAEF8 => {
    //   block [0x824AAEF8..0x824AAF08)
	// 824AAEF8: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 824AAEFC: 38800096  li r4, 0x96
	ctx.r[4].s64 = 150;
	// 824AAF00: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 824AAF04: 4BFF7AAC  b 0x824a29b0
	sub_824A29B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AAF08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824AAF08 size=140
    let mut pc: u32 = 0x824AAF08;
    'dispatch: loop {
        match pc {
            0x824AAF08 => {
    //   block [0x824AAF08..0x824AAF6C)
	// 824AAF08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AAF0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AAF10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824AAF14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AAF18: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 824AAF1C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AAF20: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824AAF24: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824AAF28: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824AAF2C: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 824AAF30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 824AAF34: C3EB2238  lfs f31, 0x2238(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8760 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 824AAF38: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 824AAF3C: 48100825  bl 0x825ab760
	ctx.lr = 0x824AAF40;
	sub_825AB760(ctx, base);
	// 824AAF40: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AAF44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824AAF48: 419A0024  beq cr6, 0x824aaf6c
	if ctx.cr[6].eq {
	pc = 0x824AAF6C; continue 'dispatch;
	}
	// 824AAF4C: 389F0060  addi r4, r31, 0x60
	ctx.r[4].s64 = ctx.r[31].s64 + 96;
	// 824AAF50: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 824AAF54: 38610051  addi r3, r1, 0x51
	ctx.r[3].s64 = ctx.r[1].s64 + 81;
	// 824AAF58: 48100809  bl 0x825ab760
	ctx.lr = 0x824AAF5C;
	sub_825AB760(ctx, base);
	// 824AAF5C: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AAF60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824AAF64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824AAF68: 409A0008  bne cr6, 0x824aaf70
	if !ctx.cr[6].eq {
	pc = 0x824AAF70; continue 'dispatch;
	}
	pc = 0x824AAF6C; continue 'dispatch;
            }
            0x824AAF6C => {
    //   block [0x824AAF6C..0x824AAF70)
	// 824AAF6C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x824AAF70; continue 'dispatch;
            }
            0x824AAF70 => {
    //   block [0x824AAF70..0x824AAF94)
	// 824AAF70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824AAF74: 997E0000  stb r11, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824AAF78: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 824AAF7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824AAF80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824AAF84: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 824AAF88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824AAF8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824AAF90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AAF98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AAF98 size=8
    let mut pc: u32 = 0x824AAF98;
    'dispatch: loop {
        match pc {
            0x824AAF98 => {
    //   block [0x824AAF98..0x824AAFA0)
	// 824AAF98: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 824AAF9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AAFA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AAFA0 size=628
    let mut pc: u32 = 0x824AAFA0;
    'dispatch: loop {
        match pc {
            0x824AAFA0 => {
    //   block [0x824AAFA0..0x824AB214)
	// 824AAFA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AAFA4: 4808A10D  bl 0x825350b0
	ctx.lr = 0x824AAFA8;
	sub_82535080(ctx, base);
	// 824AAFA8: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AB218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AB218 size=568
    let mut pc: u32 = 0x824AB218;
    'dispatch: loop {
        match pc {
            0x824AB218 => {
    //   block [0x824AB218..0x824AB450)
	// 824AB218: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 824AB21C: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 824AB220: 39400050  li r10, 0x50
	ctx.r[10].s64 = 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AB450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AB450 size=196
    let mut pc: u32 = 0x824AB450;
    'dispatch: loop {
        match pc {
            0x824AB450 => {
    //   block [0x824AB450..0x824AB514)
	// 824AB450: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 824AB454: 3921FFE0  addi r9, r1, -0x20
	ctx.r[9].s64 = ctx.r[1].s64 + -32;
	// 824AB458: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 824AB45C: 3941FFE0  addi r10, r1, -0x20
	ctx.r[10].s64 = ctx.r[1].s64 + -32;
	// 824AB460: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 824AB464: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AB518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824AB518 size=28
    let mut pc: u32 = 0x824AB518;
    'dispatch: loop {
        match pc {
            0x824AB518 => {
    //   block [0x824AB518..0x824AB534)
	// 824AB518: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824AB51C: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 824AB520: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824AB524: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 824AB528: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	// 824AB52C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824AB530: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AB538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AB538 size=8
    let mut pc: u32 = 0x824AB538;
    'dispatch: loop {
        match pc {
            0x824AB538 => {
    //   block [0x824AB538..0x824AB540)
	// 824AB538: 38600066  li r3, 0x66
	ctx.r[3].s64 = 102;
	// 824AB53C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AB540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AB540 size=160
    let mut pc: u32 = 0x824AB540;
    'dispatch: loop {
        match pc {
            0x824AB540 => {
    //   block [0x824AB540..0x824AB5E0)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AB5E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AB5E0 size=88
    let mut pc: u32 = 0x824AB5E0;
    'dispatch: loop {
        match pc {
            0x824AB5E0 => {
    //   block [0x824AB5E0..0x824AB638)
	// 824AB5E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824AB5E4: 3943000C  addi r10, r3, 0xc
	ctx.r[10].s64 = ctx.r[3].s64 + 12;
	// 824AB5E8: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 824AB5EC: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 824AB5F0: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 824AB5F4: 91440010  stw r10, 0x10(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 824AB5F8: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 824AB5FC: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824AB600: 91040004  stw r8, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 824AB604: 91240014  stw r9, 0x14(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 824AB608: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 824AB60C: 1D4B0534  mulli r10, r11, 0x534
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 1332 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 824AB610: 394A0053  addi r10, r10, 0x53
	ctx.r[10].s64 = ctx.r[10].s64 + 83;
	// 824AB614: 554A0036  rlwinm r10, r10, 0, 0, 0x1b
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 824AB618: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 824AB61C: 91440004  stw r10, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 824AB620: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824AB624: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824AB628: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824AB62C: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 824AB630: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 824AB634: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AB638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AB638 size=52
    let mut pc: u32 = 0x824AB638;
    'dispatch: loop {
        match pc {
            0x824AB638 => {
    //   block [0x824AB638..0x824AB66C)
	// 824AB638: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 824AB63C: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 824AB640: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824AB644: 392B0003  addi r9, r11, 3
	ctx.r[9].s64 = ctx.r[11].s64 + 3;
	// 824AB648: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 824AB64C: 5529003A  rlwinm r9, r9, 0, 0, 0x1d
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 824AB650: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824AB654: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 824AB658: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824AB65C: 91650004  stw r11, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824AB660: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 824AB664: 91450000  stw r10, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824AB668: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AB670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AB670 size=72
    let mut pc: u32 = 0x824AB670;
    'dispatch: loop {
        match pc {
            0x824AB670 => {
    //   block [0x824AB670..0x824AB6B8)
	// 824AB670: 54AB083C  slwi r11, r5, 1
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824AB674: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 824AB678: 39000003  li r8, 3
	ctx.r[8].s64 = 3;
	// 824AB67C: 81230028  lwz r9, 0x28(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 824AB680: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 824AB684: 814A001C  lwz r10, 0x1c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 824AB688: 8129001C  lwz r9, 0x1c(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 824AB68C: 7D085830  slw r8, r8, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = ((ctx.r[8].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 824AB690: 7CE75830  slw r7, r7, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = ((ctx.r[7].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 824AB694: 554B083C  slwi r11, r10, 1
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824AB698: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 824AB69C: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824AB6A0: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 824AB6A4: 7D4B20AE  lbzx r10, r11, r4
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 824AB6A8: 7D4A4078  andc r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 & !ctx.r[8].u64;
	// 824AB6AC: 7D4A3B78  or r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[7].u64;
	// 824AB6B0: 7D4B21AE  stbx r10, r11, r4
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32), ctx.r[10].u8) };
	// 824AB6B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AB6B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AB6B8 size=72
    let mut pc: u32 = 0x824AB6B8;
    'dispatch: loop {
        match pc {
            0x824AB6B8 => {
    //   block [0x824AB6B8..0x824AB700)
	// 824AB6B8: 54AB083C  slwi r11, r5, 1
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824AB6BC: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 824AB6C0: 39000003  li r8, 3
	ctx.r[8].s64 = 3;
	// 824AB6C4: 81230028  lwz r9, 0x28(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 824AB6C8: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 824AB6CC: 814A001C  lwz r10, 0x1c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 824AB6D0: 8129001C  lwz r9, 0x1c(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 824AB6D4: 7D085830  slw r8, r8, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = ((ctx.r[8].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 824AB6D8: 7CE75830  slw r7, r7, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = ((ctx.r[7].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 824AB6DC: 554B083C  slwi r11, r10, 1
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824AB6E0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 824AB6E4: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824AB6E8: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 824AB6EC: 7D4B20AE  lbzx r10, r11, r4
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 824AB6F0: 7D4A4078  andc r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 & !ctx.r[8].u64;
	// 824AB6F4: 7D4A3B78  or r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[7].u64;
	// 824AB6F8: 7D4B21AE  stbx r10, r11, r4
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32), ctx.r[10].u8) };
	// 824AB6FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AB700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824AB700 size=164
    let mut pc: u32 = 0x824AB700;
    'dispatch: loop {
        match pc {
            0x824AB700 => {
    //   block [0x824AB700..0x824AB7A4)
	// 824AB700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AB704: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AB708: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AB70C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AB710: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824AB714: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 824AB718: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824AB71C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 824AB720: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 824AB724: C18B2984  lfs f12, 0x2984(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10628 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 824AB728: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824AB72C: C1698E30  lfs f11, -0x71d0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-29136 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 824AB730: 3D208000  lis r9, -0x8000
	ctx.r[9].s64 = -2147483648;
	// 824AB734: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824AB738: B11F0006  sth r8, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[8].u16 ) };
	// 824AB73C: C00B1850  lfs f0, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824AB740: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824AB744: 394B0908  addi r10, r11, 0x908
	ctx.r[10].s64 = ctx.r[11].s64 + 2312;
	// 824AB748: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824AB74C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824AB750: C1AB0900  lfs f13, 0x900(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2304 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824AB754: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824AB758: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 824AB75C: B11F000C  sth r8, 0xc(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[8].u16 ) };
	// 824AB760: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 824AB764: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 824AB768: 913F0020  stw r9, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 824AB76C: D19F0024  stfs f12, 0x24(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 824AB770: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 824AB774: D1BF002C  stfs f13, 0x2c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 824AB778: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 824AB77C: D1BF0034  stfs f13, 0x34(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 824AB780: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 824AB784: D17F003C  stfs f11, 0x3c(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 824AB788: 4BFF7731  bl 0x824a2eb8
	ctx.lr = 0x824AB78C;
	sub_824A2EB8(ctx, base);
	// 824AB78C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AB790: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824AB794: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824AB798: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824AB79C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824AB7A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AB7A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AB7A8 size=104
    let mut pc: u32 = 0x824AB7A8;
    'dispatch: loop {
        match pc {
            0x824AB7A8 => {
    //   block [0x824AB7A8..0x824AB810)
	// 824AB7A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AB7AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AB7B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824AB7B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AB7B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AB7BC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824AB7C0: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 824AB7C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824AB7C8: 396B0908  addi r11, r11, 0x908
	ctx.r[11].s64 = ctx.r[11].s64 + 2312;
	// 824AB7CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 824AB7D0: 3BDF000C  addi r30, r31, 0xc
	ctx.r[30].s64 = ctx.r[31].s64 + 12;
	// 824AB7D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824AB7D8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824AB7DC: B15F0006  sth r10, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 824AB7E0: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AB7E4: 4BFF76D5  bl 0x824a2eb8
	ctx.lr = 0x824AB7E8;
	sub_824A2EB8(ctx, base);
	// 824AB7E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824AB7EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824AB7F0: 4BFF76C9  bl 0x824a2eb8
	ctx.lr = 0x824AB7F4;
	sub_824A2EB8(ctx, base);
	// 824AB7F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AB7F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824AB7FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824AB800: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824AB804: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824AB808: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824AB80C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AB810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AB810 size=244
    let mut pc: u32 = 0x824AB810;
    'dispatch: loop {
        match pc {
            0x824AB810 => {
    //   block [0x824AB810..0x824AB840)
	// 824AB810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AB814: 480898A1  bl 0x825350b4
	ctx.lr = 0x824AB818;
	sub_82535080(ctx, base);
	// 824AB818: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AB81C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824AB820: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824AB824: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 824AB828: 396B0908  addi r11, r11, 0x908
	ctx.r[11].s64 = ctx.r[11].s64 + 2312;
	// 824AB82C: 815E001C  lwz r10, 0x1c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 824AB830: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AB834: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824AB838: 40990080  ble cr6, 0x824ab8b8
	if !ctx.cr[6].gt {
	pc = 0x824AB8B8; continue 'dispatch;
	}
	// 824AB83C: 3B800040  li r28, 0x40
	ctx.r[28].s64 = 64;
	pc = 0x824AB840; continue 'dispatch;
            }
            0x824AB840 => {
    //   block [0x824AB840..0x824AB848)
	// 824AB840: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 824AB844: 3BA00003  li r29, 3
	ctx.r[29].s64 = 3;
	pc = 0x824AB848; continue 'dispatch;
            }
            0x824AB848 => {
    //   block [0x824AB848..0x824AB894)
	// 824AB848: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 824AB84C: 7D4BF82E  lwzx r10, r11, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 824AB850: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824AB854: 419A0040  beq cr6, 0x824ab894
	if ctx.cr[6].eq {
	pc = 0x824AB894; continue 'dispatch;
	}
	// 824AB858: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 824AB85C: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AB860: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824AB864: 419A0030  beq cr6, 0x824ab894
	if ctx.cr[6].eq {
	pc = 0x824AB894; continue 'dispatch;
	}
	// 824AB868: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 824AB86C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824AB870: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824AB874: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824AB878: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824AB87C: 409A0018  bne cr6, 0x824ab894
	if !ctx.cr[6].eq {
	pc = 0x824AB894; continue 'dispatch;
	}
	// 824AB880: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AB884: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824AB888: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AB88C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AB890: 4E800421  bctrl
	ctx.lr = 0x824AB894;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824AB894 => {
    //   block [0x824AB894..0x824AB8B8)
	// 824AB894: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 824AB898: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 824AB89C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 824AB8A0: 409AFFA8  bne cr6, 0x824ab848
	if !ctx.cr[6].eq {
	pc = 0x824AB848; continue 'dispatch;
	}
	// 824AB8A4: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 824AB8A8: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 824AB8AC: 3B9C0050  addi r28, r28, 0x50
	ctx.r[28].s64 = ctx.r[28].s64 + 80;
	// 824AB8B0: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824AB8B4: 4198FF8C  blt cr6, 0x824ab840
	if ctx.cr[6].lt {
	pc = 0x824AB840; continue 'dispatch;
	}
	pc = 0x824AB8B8; continue 'dispatch;
            }
            0x824AB8B8 => {
    //   block [0x824AB8B8..0x824AB8F0)
	// 824AB8B8: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 824AB8BC: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824AB8C0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AB8C4: 409A002C  bne cr6, 0x824ab8f0
	if !ctx.cr[6].eq {
	pc = 0x824AB8F0; continue 'dispatch;
	}
	// 824AB8C8: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AB8CC: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824AB8D0: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824AB8D4: 809E0018  lwz r4, 0x18(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 824AB8D8: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824AB8DC: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824AB8E0: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824AB8E4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824AB8E8: 55652036  slwi r5, r11, 4
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824AB8EC: 4BFB87CD  bl 0x824640b8
	ctx.lr = 0x824AB8F0;
	sub_824640B8(ctx, base);
	pc = 0x824AB8F0; continue 'dispatch;
            }
            0x824AB8F0 => {
    //   block [0x824AB8F0..0x824AB904)
	// 824AB8F0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824AB8F4: 396B6DD0  addi r11, r11, 0x6dd0
	ctx.r[11].s64 = ctx.r[11].s64 + 28112;
	// 824AB8F8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824AB8FC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 824AB900: 48089804  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AB908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AB908 size=256
    let mut pc: u32 = 0x824AB908;
    'dispatch: loop {
        match pc {
            0x824AB908 => {
    //   block [0x824AB908..0x824AB950)
	// 824AB908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AB90C: 480897A1  bl 0x825350ac
	ctx.lr = 0x824AB910;
	sub_82535080(ctx, base);
	// 824AB910: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AB914: 3BE30018  addi r31, r3, 0x18
	ctx.r[31].s64 = ctx.r[3].s64 + 24;
	// 824AB918: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 824AB91C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 824AB920: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 824AB924: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 824AB928: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AB92C: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 824AB930: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AB934: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 824AB938: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824AB93C: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824AB940: 409A0010  bne cr6, 0x824ab950
	if !ctx.cr[6].eq {
	pc = 0x824AB950; continue 'dispatch;
	}
	// 824AB944: 38800050  li r4, 0x50
	ctx.r[4].s64 = 80;
	// 824AB948: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AB94C: 4BFC2A05  bl 0x8246e350
	ctx.lr = 0x824AB950;
	sub_8246E350(ctx, base);
	pc = 0x824AB950; continue 'dispatch;
            }
            0x824AB950 => {
    //   block [0x824AB950..0x824ABA08)
	// 824AB950: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AB954: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 824AB958: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AB95C: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 824AB960: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 824AB964: 38CB0001  addi r6, r11, 1
	ctx.r[6].s64 = ctx.r[11].s64 + 1;
	// 824AB968: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 824AB96C: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824AB970: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824AB974: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824ABA08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824ABA08 size=76
    let mut pc: u32 = 0x824ABA08;
    'dispatch: loop {
        match pc {
            0x824ABA08 => {
    //   block [0x824ABA08..0x824ABA54)
	// 824ABA08: C1A40004  lfs f13, 4(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824ABA0C: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824ABA10: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 824ABA14: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 824ABA18: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824ABA1C: C003000C  lfs f0, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824ABA20: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 824ABA24: D0060004  stfs f0, 4(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 824ABA28: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824ABA2C: D0060008  stfs f0, 8(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 824ABA30: C0030010  lfs f0, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824ABA34: D006000C  stfs f0, 0xc(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 824ABA38: C0030014  lfs f0, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824ABA3C: D0060010  stfs f0, 0x10(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 824ABA40: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824ABA44: C1A30000  lfs f13, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824ABA48: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 824ABA4C: D005001C  stfs f0, 0x1c(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 824ABA50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824ABA58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824ABA58 size=1948
    let mut pc: u32 = 0x824ABA58;
    'dispatch: loop {
        match pc {
            0x824ABA58 => {
    //   block [0x824ABA58..0x824ABAA0)
	// 824ABA58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824ABA5C: 48089625  bl 0x82535080
	ctx.lr = 0x824ABA60;
	sub_82535080(ctx, base);
	// 824ABA60: DBE1FF60  stfd f31, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 824ABA64: 9421F490  stwu r1, -0xb70(r1)
	ea = ctx.r[1].u32.wrapping_add(-2928 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824ABA68: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 824ABA6C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 824ABA70: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 824ABA74: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 824ABA78: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 824ABA7C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 824ABA80: 80BB004C  lwz r5, 0x4c(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(76 as u32) ) } as u64;
	// 824ABA84: 93610B8C  stw r27, 0xb8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(2956 as u32), ctx.r[27].u32 ) };
	// 824ABA88: 93810B94  stw r28, 0xb94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(2964 as u32), ctx.r[28].u32 ) };
	// 824ABA8C: 480461E5  bl 0x824f1c70
	ctx.lr = 0x824ABA90;
	sub_824F1C70(ctx, base);
	// 824ABA90: 39410140  addi r10, r1, 0x140
	ctx.r[10].s64 = ctx.r[1].s64 + 320;
	// 824ABA94: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 824ABA98: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 824ABA9C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x824ABAA0; continue 'dispatch;
            }
            0x824ABAA0 => {
    //   block [0x824ABAA0..0x824ABB28)
	// 824ABAA0: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 824ABAA4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 824ABAA8: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 824ABAAC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 824ABAB0: 4200FFF0  bdnz 0x824abaa0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x824ABAA0; continue 'dispatch;
	}
	// 824ABAB4: 396101AC  addi r11, r1, 0x1ac
	ctx.r[11].s64 = ctx.r[1].s64 + 428;
	// 824ABAB8: 83FB0048  lwz r31, 0x48(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 824ABABC: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 824ABAC0: 815B0030  lwz r10, 0x30(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(48 as u32) ) } as u64;
	// 824ABAC4: 3BBF002C  addi r29, r31, 0x2c
	ctx.r[29].s64 = ctx.r[31].s64 + 44;
	// 824ABAC8: 916101A0  stw r11, 0x1a0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(416 as u32), ctx.r[11].u32 ) };
	// 824ABACC: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 824ABAD0: 93210188  stw r25, 0x188(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), ctx.r[25].u32 ) };
	// 824ABAD4: 616B0020  ori r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 | 32;
	// 824ABAD8: 9321018C  stw r25, 0x18c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(396 as u32), ctx.r[25].u32 ) };
	// 824ABADC: 932101A4  stw r25, 0x1a4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(420 as u32), ctx.r[25].u32 ) };
	// 824ABAE0: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 824ABAE4: 916101A8  stw r11, 0x1a8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(424 as u32), ctx.r[11].u32 ) };
	// 824ABAE8: 813F0014  lwz r9, 0x14(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 824ABAEC: 81290090  lwz r9, 0x90(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(144 as u32) ) } as u64;
	// 824ABAF0: 7FC95050  subf r30, r9, r10
	ctx.r[30].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 824ABAF4: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824ABAF8: 392102CC  addi r9, r1, 0x2cc
	ctx.r[9].s64 = ctx.r[1].s64 + 716;
	// 824ABAFC: 932102C4  stw r25, 0x2c4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(708 as u32), ctx.r[25].u32 ) };
	// 824ABB00: 39EAFFFF  addi r15, r10, -1
	ctx.r[15].s64 = ctx.r[10].s64 + -1;
	// 824ABB04: 916102C8  stw r11, 0x2c8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(712 as u32), ctx.r[11].u32 ) };
	// 824ABB08: 2F0F0020  cmpwi cr6, r15, 0x20
	ctx.cr[6].compare_i32(ctx.r[15].s32, 32, &mut ctx.xer);
	// 824ABB0C: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 824ABB10: 912102C0  stw r9, 0x2c0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(704 as u32), ctx.r[9].u32 ) };
	// 824ABB14: 40990020  ble cr6, 0x824abb34
	if !ctx.cr[6].gt {
	pc = 0x824ABB34; continue 'dispatch;
	}
	// 824ABB18: 2F0F0040  cmpwi cr6, r15, 0x40
	ctx.cr[6].compare_i32(ctx.r[15].s32, 64, &mut ctx.xer);
	// 824ABB1C: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 824ABB20: 41980008  blt cr6, 0x824abb28
	if ctx.cr[6].lt {
	pc = 0x824ABB28; continue 'dispatch;
	}
	// 824ABB24: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	pc = 0x824ABB28; continue 'dispatch;
            }
            0x824ABB28 => {
    //   block [0x824ABB28..0x824ABB34)
	// 824ABB28: 38A00040  li r5, 0x40
	ctx.r[5].s64 = 64;
	// 824ABB2C: 386102C0  addi r3, r1, 0x2c0
	ctx.r[3].s64 = ctx.r[1].s64 + 704;
	// 824ABB30: 4BFC2799  bl 0x8246e2c8
	ctx.lr = 0x824ABB34;
	sub_8246E2C8(ctx, base);
	pc = 0x824ABB34; continue 'dispatch;
            }
            0x824ABB34 => {
    //   block [0x824ABB34..0x824ABC48)
	// 824ABB34: 91E102C4  stw r15, 0x2c4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(708 as u32), ctx.r[15].u32 ) };
	// 824ABB38: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 824ABB3C: 814101A4  lwz r10, 0x1a4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(420 as u32) ) } as u64;
	// 824ABB40: 810101A0  lwz r8, 0x1a0(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(416 as u32) ) } as u64;
	// 824ABB44: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 824ABB48: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824ABB4C: 814B0090  lwz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 824ABB50: 396B00E0  addi r11, r11, 0xe0
	ctx.r[11].s64 = ctx.r[11].s64 + 224;
	// 824ABB54: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 824ABB58: 91410174  stw r10, 0x174(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(372 as u32), ctx.r[10].u32 ) };
	// 824ABB5C: 7D5E5050  subf r10, r30, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[30].s64;
	// 824ABB60: 7D49412E  stwx r10, r9, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), ctx.r[10].u32) };
	// 824ABB64: 9161017C  stw r11, 0x17c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(380 as u32), ctx.r[11].u32 ) };
	// 824ABB68: 81610148  lwz r11, 0x148(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(328 as u32) ) } as u64;
	// 824ABB6C: 814101A4  lwz r10, 0x1a4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(420 as u32) ) } as u64;
	// 824ABB70: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824ABB74: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824ABB78: 9161015C  stw r11, 0x15c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(348 as u32), ctx.r[11].u32 ) };
	// 824ABB7C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824ABB80: 914101A4  stw r10, 0x1a4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(420 as u32), ctx.r[10].u32 ) };
	// 824ABB84: C00B1850  lfs f0, 0x1850(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824ABB88: D0010160  stfs f0, 0x160(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 824ABB8C: 4804A3D5  bl 0x824f5f60
	ctx.lr = 0x824ABB90;
	sub_824F5F60(ctx, base);
	// 824ABB90: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824ABB94: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 824ABB98: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 824ABB9C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 824ABBA0: 4804A3C9  bl 0x824f5f68
	ctx.lr = 0x824ABBA4;
	sub_824F5F68(ctx, base);
	// 824ABBA4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824ABBA8: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 824ABBAC: 7F35CB78  mr r21, r25
	ctx.r[21].u64 = ctx.r[25].u64;
	// 824ABBB0: 2F0F0000  cmpwi cr6, r15, 0
	ctx.cr[6].compare_i32(ctx.r[15].s32, 0, &mut ctx.xer);
	// 824ABBB4: C3EB1FF8  lfs f31, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 824ABBB8: 4099052C  ble cr6, 0x824ac0e4
	if !ctx.cr[6].gt {
	pc = 0x824AC0E4; continue 'dispatch;
	}
	// 824ABBBC: 39600018  li r11, 0x18
	ctx.r[11].s64 = 24;
	// 824ABBC0: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 824ABBC4: 39D6001C  addi r14, r22, 0x1c
	ctx.r[14].s64 = ctx.r[22].s64 + 28;
	// 824ABBC8: 3A7F0028  addi r19, r31, 0x28
	ctx.r[19].s64 = ctx.r[31].s64 + 40;
	// 824ABBCC: 3B560018  addi r26, r22, 0x18
	ctx.r[26].s64 = ctx.r[22].s64 + 24;
	// 824ABBD0: 7F38CB78  mr r24, r25
	ctx.r[24].u64 = ctx.r[25].u64;
	// 824ABBD4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 824ABBD8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824ABBDC: 3A000010  li r16, 0x10
	ctx.r[16].s64 = 16;
	// 824ABBE0: 396B08F0  addi r11, r11, 0x8f0
	ctx.r[11].s64 = ctx.r[11].s64 + 2288;
	// 824ABBE4: 3A200020  li r17, 0x20
	ctx.r[17].s64 = 32;
	// 824ABBE8: 3A400030  li r18, 0x30
	ctx.r[18].s64 = 48;
	// 824ABBEC: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 824ABBF0: 81610174  lwz r11, 0x174(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 824ABBF4: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824ABBF8: 814101A8  lwz r10, 0x1a8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(424 as u32) ) } as u64;
	// 824ABBFC: 554A00BE  clrlwi r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 824ABC00: 91610170  stw r11, 0x170(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(368 as u32), ctx.r[11].u32 ) };
	// 824ABC04: 8161017C  lwz r11, 0x17c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(380 as u32) ) } as u64;
	// 824ABC08: 91610178  stw r11, 0x178(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), ctx.r[11].u32 ) };
	// 824ABC0C: 397F002C  addi r11, r31, 0x2c
	ctx.r[11].s64 = ctx.r[31].s64 + 44;
	// 824ABC10: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824ABC14: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 824ABC18: 812101A4  lwz r9, 0x1a4(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(420 as u32) ) } as u64;
	// 824ABC1C: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 824ABC20: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824ABC24: 3BEB00D0  addi r31, r11, 0xd0
	ctx.r[31].s64 = ctx.r[11].s64 + 208;
	// 824ABC28: 814B0090  lwz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 824ABC2C: 7D6AF214  add r11, r10, r30
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 824ABC30: 7FDE5850  subf r30, r30, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 824ABC34: 91610174  stw r11, 0x174(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(372 as u32), ctx.r[11].u32 ) };
	// 824ABC38: 409A0010  bne cr6, 0x824abc48
	if !ctx.cr[6].eq {
	pc = 0x824ABC48; continue 'dispatch;
	}
	// 824ABC3C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 824ABC40: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 824ABC44: 4BFC270D  bl 0x8246e350
	ctx.lr = 0x824ABC48;
	sub_8246E350(ctx, base);
	pc = 0x824ABC48; continue 'dispatch;
            }
            0x824ABC48 => {
    //   block [0x824ABC48..0x824AC0E4)
	// 824ABC48: 816101A4  lwz r11, 0x1a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(420 as u32) ) } as u64;
	// 824ABC4C: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 824ABC50: 814101A0  lwz r10, 0x1a0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(416 as u32) ) } as u64;
	// 824ABC54: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824ABC58: 7FCB512E  stwx r30, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[30].u32) };
	// 824ABC5C: 816101A4  lwz r11, 0x1a4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(420 as u32) ) } as u64;
	// 824ABC60: 813A0000  lwz r9, 0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 824ABC64: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824ABC68: 81410178  lwz r10, 0x178(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(376 as u32) ) } as u64;
	// 824ABC6C: 7D384A14  add r9, r24, r9
	ctx.r[9].u64 = ctx.r[24].u64 + ctx.r[9].u64;
	// 824ABC70: 916101A4  stw r11, 0x1a4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(420 as u32), ctx.r[11].u32 ) };
	// 824ABC74: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 824ABC78: 9161017C  stw r11, 0x17c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(380 as u32), ctx.r[11].u32 ) };
	pc = 0x824AC0E4; continue 'dispatch;
            }
            0x824AC0E4 => {
    //   block [0x824AC0E4..0x824AC1F4)
	// 824AC0E4: 8156001C  lwz r10, 0x1c(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(28 as u32) ) } as u64;
	// 824AC0E8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 824AC0EC: 813F0028  lwz r9, 0x28(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 824AC0F0: 2F0F0000  cmpwi cr6, r15, 0
	ctx.cr[6].compare_i32(ctx.r[15].s32, 0, &mut ctx.xer);
	// 824AC0F4: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 824AC0F8: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 824AC0FC: 8129001C  lwz r9, 0x1c(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 824AC100: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824AC104: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 824AC108: 40990024  ble cr6, 0x824ac12c
	if !ctx.cr[6].gt {
	pc = 0x824AC12C; continue 'dispatch;
	}
	// 824AC10C: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 824AC110: 7D0B48AE  lbzx r8, r11, r9
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 824AC114: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824AC118: 80E102C0  lwz r7, 0x2c0(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(704 as u32) ) } as u64;
	// 824AC11C: 7F0B7800  cmpw cr6, r11, r15
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[15].s32, &mut ctx.xer);
	// 824AC120: 7D0A39AE  stbx r8, r10, r7
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[7].u32), ctx.r[8].u8) };
	// 824AC124: 394A0040  addi r10, r10, 0x40
	ctx.r[10].s64 = ctx.r[10].s64 + 64;
	// 824AC128: 4198FFE8  blt cr6, 0x824ac110
	if ctx.cr[6].lt {
	pc = 0x824AC110; continue 'dispatch;
	}
	// 824AC12C: 816101A0  lwz r11, 0x1a0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(416 as u32) ) } as u64;
	// 824AC130: C0160024  lfs f0, 0x24(r22)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824AC134: D00100E4  stfs f0, 0xe4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 824AC138: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 824AC13C: C0160028  lfs f0, 0x28(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824AC140: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824AC144: D00100E8  stfs f0, 0xe8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 824AC148: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 824AC14C: C016002C  lfs f0, 0x2c(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824AC150: 91E100E0  stw r15, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[15].u32 ) };
	// 824AC154: 916100FC  stw r11, 0xfc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 824AC158: D00100EC  stfs f0, 0xec(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 824AC15C: 816102C0  lwz r11, 0x2c0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(704 as u32) ) } as u64;
	// 824AC160: C0160030  lfs f0, 0x30(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824AC164: D00100F0  stfs f0, 0xf0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 824AC168: 93C10100  stw r30, 0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[30].u32 ) };
	// 824AC16C: C0160034  lfs f0, 0x34(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824AC170: 9121010C  stw r9, 0x10c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), ctx.r[9].u32 ) };
	// 824AC174: D00100F4  stfs f0, 0xf4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 824AC178: 92E10110  stw r23, 0x110(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[23].u32 ) };
	// 824AC17C: C0160038  lfs f0, 0x38(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824AC180: D00100F8  stfs f0, 0xf8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 824AC184: 91610104  stw r11, 0x104(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 824AC188: D3E10108  stfs f31, 0x108(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 824AC18C: 480498CD  bl 0x824f5a58
	ctx.lr = 0x824AC190;
	sub_824F5A58(ctx, base);
	// 824AC190: 816102C8  lwz r11, 0x2c8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(712 as u32) ) } as u64;
	// 824AC194: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824AC198: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AC19C: 409A0020  bne cr6, 0x824ac1bc
	if !ctx.cr[6].eq {
	pc = 0x824AC1BC; continue 'dispatch;
	}
	// 824AC1A0: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AC1A4: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824AC1A8: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824AC1AC: 808102C0  lwz r4, 0x2c0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(704 as u32) ) } as u64;
	// 824AC1B0: 55653032  slwi r5, r11, 6
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824AC1B4: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824AC1B8: 4BFB7F01  bl 0x824640b8
	ctx.lr = 0x824AC1BC;
	sub_824640B8(ctx, base);
	// 824AC1BC: 816101A8  lwz r11, 0x1a8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(424 as u32) ) } as u64;
	// 824AC1C0: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824AC1C4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AC1C8: 409A0020  bne cr6, 0x824ac1e8
	if !ctx.cr[6].eq {
	pc = 0x824AC1E8; continue 'dispatch;
	}
	// 824AC1CC: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AC1D0: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824AC1D4: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824AC1D8: 808101A0  lwz r4, 0x1a0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(416 as u32) ) } as u64;
	// 824AC1DC: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824AC1E0: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824AC1E4: 4BFB7ED5  bl 0x824640b8
	ctx.lr = 0x824AC1E8;
	sub_824640B8(ctx, base);
	// 824AC1E8: 38210B70  addi r1, r1, 0xb70
	ctx.r[1].s64 = ctx.r[1].s64 + 2928;
	// 824AC1EC: CBE1FF60  lfd f31, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 824AC1F0: 48088EE0  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AC1F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AC1F8 size=100
    let mut pc: u32 = 0x824AC1F8;
    'dispatch: loop {
        match pc {
            0x824AC1F8 => {
    //   block [0x824AC1F8..0x824AC240)
	// 824AC1F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AC1FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AC200: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824AC204: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AC208: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AC20C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824AC210: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 824AC214: 4BFFF5FD  bl 0x824ab810
	ctx.lr = 0x824AC218;
	sub_824AB810(ctx, base);
	// 824AC218: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 824AC21C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824AC220: 419A0020  beq cr6, 0x824ac240
	if ctx.cr[6].eq {
	pc = 0x824AC240; continue 'dispatch;
	}
	// 824AC224: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AC228: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 824AC22C: 38C0002C  li r6, 0x2c
	ctx.r[6].s64 = 44;
	// 824AC230: A0BF0004  lhz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AC234: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824AC238: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824AC23C: 4BFB7E7D  bl 0x824640b8
	ctx.lr = 0x824AC240;
	sub_824640B8(ctx, base);
	pc = 0x824AC240; continue 'dispatch;
            }
            0x824AC240 => {
    //   block [0x824AC240..0x824AC25C)
	// 824AC240: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AC244: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824AC248: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824AC24C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824AC250: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824AC254: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824AC258: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AC260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AC260 size=8
    let mut pc: u32 = 0x824AC260;
    'dispatch: loop {
        match pc {
            0x824AC260 => {
    //   block [0x824AC260..0x824AC268)
	// 824AC260: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 824AC264: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AC268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AC268 size=60
    let mut pc: u32 = 0x824AC268;
    'dispatch: loop {
        match pc {
            0x824AC268 => {
    //   block [0x824AC268..0x824AC27C)
	// 824AC268: 81240154  lwz r9, 0x154(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(340 as u32) ) } as u64;
	// 824AC26C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824AC270: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 824AC274: 40990024  ble cr6, 0x824ac298
	if !ctx.cr[6].gt {
	pc = 0x824AC298; continue 'dispatch;
	}
	// 824AC278: 81440150  lwz r10, 0x150(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(336 as u32) ) } as u64;
	pc = 0x824AC27C; continue 'dispatch;
            }
            0x824AC27C => {
    //   block [0x824AC27C..0x824AC298)
	// 824AC27C: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AC280: 7F082840  cmplw cr6, r8, r5
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[5].u32, &mut ctx.xer);
	// 824AC284: 419A0020  beq cr6, 0x824ac2a4
	if ctx.cr[6].eq {
		sub_824AC2A4(ctx, base);
		return;
	}
	// 824AC288: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824AC28C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 824AC290: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824AC294: 4198FFE8  blt cr6, 0x824ac27c
	if ctx.cr[6].lt {
	pc = 0x824AC27C; continue 'dispatch;
	}
	pc = 0x824AC298; continue 'dispatch;
            }
            0x824AC298 => {
    //   block [0x824AC298..0x824AC2A4)
	// 824AC298: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824AC29C: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824AC2A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AC2A4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AC2A4 size=12
    let mut pc: u32 = 0x824AC2A4;
    'dispatch: loop {
        match pc {
            0x824AC2A4 => {
    //   block [0x824AC2A4..0x824AC2B0)
	// 824AC2A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824AC2A8: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824AC2AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AC2B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AC2B0 size=200
    let mut pc: u32 = 0x824AC2B0;
    'dispatch: loop {
        match pc {
            0x824AC2B0 => {
    //   block [0x824AC2B0..0x824AC2F0)
	// 824AC2B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AC2B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AC2B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824AC2BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AC2C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AC2C4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AC2C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824AC2CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824AC2D0: 419A0054  beq cr6, 0x824ac324
	if ctx.cr[6].eq {
	pc = 0x824AC324; continue 'dispatch;
	}
	// 824AC2D4: 817F0154  lwz r11, 0x154(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 824AC2D8: 3BCBFFFF  addi r30, r11, -1
	ctx.r[30].s64 = ctx.r[11].s64 + -1;
	// 824AC2DC: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 824AC2E0: 4198002C  blt cr6, 0x824ac30c
	if ctx.cr[6].lt {
	pc = 0x824AC30C; continue 'dispatch;
	}
	// 824AC2E4: 815F0150  lwz r10, 0x150(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 824AC2E8: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824AC2EC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	pc = 0x824AC2F0; continue 'dispatch;
            }
            0x824AC2F0 => {
    //   block [0x824AC2F0..0x824AC30C)
	// 824AC2F0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AC2F4: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 824AC2F8: 419A0044  beq cr6, 0x824ac33c
	if ctx.cr[6].eq {
	pc = 0x824AC33C; continue 'dispatch;
	}
	// 824AC2FC: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 824AC300: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 824AC304: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 824AC308: 4098FFE8  bge cr6, 0x824ac2f0
	if !ctx.cr[6].lt {
	pc = 0x824AC2F0; continue 'dispatch;
	}
	pc = 0x824AC30C; continue 'dispatch;
            }
            0x824AC30C => {
    //   block [0x824AC30C..0x824AC324)
	// 824AC30C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 824AC310: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 824AC314: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AC318: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 824AC31C: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AC320: 4BFFEA21  bl 0x824aad40
	ctx.lr = 0x824AC324;
	sub_824AAD40(ctx, base);
	pc = 0x824AC324; continue 'dispatch;
            }
            0x824AC324 => {
    //   block [0x824AC324..0x824AC33C)
	// 824AC324: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824AC328: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824AC32C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824AC330: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824AC334: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824AC338: 4E800020  blr
	return;
            }
            0x824AC33C => {
    //   block [0x824AC33C..0x824AC378)
	// 824AC33C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 824AC340: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 824AC344: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AC348: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 824AC34C: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AC350: 4BFFE9F1  bl 0x824aad40
	ctx.lr = 0x824AC354;
	sub_824AAD40(ctx, base);
	// 824AC354: 815F0154  lwz r10, 0x154(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 824AC358: 57C9103A  slwi r9, r30, 2
	ctx.r[9].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 824AC35C: 817F0150  lwz r11, 0x150(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 824AC360: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 824AC364: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 824AC368: 915F0154  stw r10, 0x154(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), ctx.r[10].u32 ) };
	// 824AC36C: 7D48582E  lwzx r10, r8, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824AC370: 7D49592E  stwx r10, r9, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u32) };
	// 824AC374: 4BFFFFB0  b 0x824ac324
	pc = 0x824AC324; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AC378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AC378 size=96
    let mut pc: u32 = 0x824AC378;
    'dispatch: loop {
        match pc {
            0x824AC378 => {
    //   block [0x824AC378..0x824AC3D8)
	// 824AC378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AC37C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AC380: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824AC384: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AC388: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AC38C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824AC390: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 824AC394: 4BFFDE2D  bl 0x824aa1c0
	ctx.lr = 0x824AC398;
	sub_824AA1C0(ctx, base);
	// 824AC398: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824AC39C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 824AC3A0: 396BEDCC  addi r11, r11, -0x1234
	ctx.r[11].s64 = ctx.r[11].s64 + -4660;
	// 824AC3A4: 3D208000  lis r9, -0x8000
	ctx.r[9].s64 = -2147483648;
	// 824AC3A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AC3AC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824AC3B0: 915F0150  stw r10, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[10].u32 ) };
	// 824AC3B4: 915F0154  stw r10, 0x154(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), ctx.r[10].u32 ) };
	// 824AC3B8: 913F0158  stw r9, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[9].u32 ) };
	// 824AC3BC: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 824AC3C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824AC3C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824AC3C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824AC3CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824AC3D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824AC3D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AC3D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AC3D8 size=104
    let mut pc: u32 = 0x824AC3D8;
    'dispatch: loop {
        match pc {
            0x824AC3D8 => {
    //   block [0x824AC3D8..0x824AC424)
	// 824AC3D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AC3DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AC3E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AC3E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AC3E8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824AC3EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824AC3F0: 396BEDCC  addi r11, r11, -0x1234
	ctx.r[11].s64 = ctx.r[11].s64 + -4660;
	// 824AC3F4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824AC3F8: 817F0158  lwz r11, 0x158(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) } as u64;
	// 824AC3FC: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824AC400: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AC404: 409A0020  bne cr6, 0x824ac424
	if !ctx.cr[6].eq {
	pc = 0x824AC424; continue 'dispatch;
	}
	// 824AC408: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AC40C: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824AC410: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824AC414: 809F0150  lwz r4, 0x150(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 824AC418: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824AC41C: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824AC420: 4BFB7C99  bl 0x824640b8
	ctx.lr = 0x824AC424;
	sub_824640B8(ctx, base);
	pc = 0x824AC424; continue 'dispatch;
            }
            0x824AC424 => {
    //   block [0x824AC424..0x824AC440)
	// 824AC424: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AC428: 4BFFD779  bl 0x824a9ba0
	ctx.lr = 0x824AC42C;
	sub_824A9BA0(ctx, base);
	// 824AC42C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824AC430: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824AC434: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824AC438: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824AC43C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AC440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AC440 size=440
    let mut pc: u32 = 0x824AC440;
    'dispatch: loop {
        match pc {
            0x824AC440 => {
    //   block [0x824AC440..0x824AC4E4)
	// 824AC440: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AC444: 48088C69  bl 0x825350ac
	ctx.lr = 0x824AC448;
	sub_82535080(ctx, base);
	// 824AC448: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AC44C: 832D0000  lwz r25, 0(r13)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AC450: 3B400010  li r26, 0x10
	ctx.r[26].s64 = 16;
	// 824AC454: 38A00031  li r5, 0x31
	ctx.r[5].s64 = 49;
	// 824AC458: 38800160  li r4, 0x160
	ctx.r[4].s64 = 352;
	// 824AC45C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 824AC460: 7C7AC82E  lwzx r3, r26, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 824AC464: 4BFB7BD5  bl 0x82464038
	ctx.lr = 0x824AC468;
	sub_82464038(ctx, base);
	// 824AC468: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824AC46C: 39600160  li r11, 0x160
	ctx.r[11].s64 = 352;
	// 824AC470: 38BB00A0  addi r5, r27, 0xa0
	ctx.r[5].s64 = ctx.r[27].s64 + 160;
	// 824AC474: B17F0004  sth r11, 4(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 824AC478: 839B002C  lwz r28, 0x2c(r27)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(44 as u32) ) } as u64;
	// 824AC47C: 809B0010  lwz r4, 0x10(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 824AC480: 4BFFDD41  bl 0x824aa1c0
	ctx.lr = 0x824AC484;
	sub_824AA1C0(ctx, base);
	// 824AC484: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824AC488: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 824AC48C: 396BEDCC  addi r11, r11, -0x1234
	ctx.r[11].s64 = ctx.r[11].s64 + -4660;
	// 824AC490: 3D208000  lis r9, -0x8000
	ctx.r[9].s64 = -2147483648;
	// 824AC494: 3BDF0080  addi r30, r31, 0x80
	ctx.r[30].s64 = ctx.r[31].s64 + 128;
	// 824AC498: 3BBB0080  addi r29, r27, 0x80
	ctx.r[29].s64 = ctx.r[27].s64 + 128;
	// 824AC49C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824AC4A0: 915F0150  stw r10, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[10].u32 ) };
	// 824AC4A4: 915F0154  stw r10, 0x154(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), ctx.r[10].u32 ) };
	// 824AC4A8: 913F0158  stw r9, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[9].u32 ) };
	// 824AC4AC: 939F002C  stw r28, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[28].u32 ) };
	// 824AC4B0: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AC4B4: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AC4B8: 554B00BE  clrlwi r11, r10, 2
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 824AC4BC: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824AC4C0: 40980050  bge cr6, 0x824ac510
	if !ctx.cr[6].lt {
	pc = 0x824AC510; continue 'dispatch;
	}
	// 824AC4C4: 554A0000  rlwinm r10, r10, 0, 0, 0
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 824AC4C8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AC4CC: 409A0018  bne cr6, 0x824ac4e4
	if !ctx.cr[6].eq {
	pc = 0x824AC4E4; continue 'dispatch;
	}
	// 824AC4D0: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824AC4D4: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AC4D8: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824AC4DC: 7C7AC82E  lwzx r3, r26, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 824AC4E0: 4BFB7BD9  bl 0x824640b8
	ctx.lr = 0x824AC4E4;
	sub_824640B8(ctx, base);
	pc = 0x824AC4E4; continue 'dispatch;
            }
            0x824AC4E4 => {
    //   block [0x824AC4E4..0x824AC510)
	// 824AC4E4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AC4E8: 38A00017  li r5, 0x17
	ctx.r[5].s64 = 23;
	// 824AC4EC: 7C7AC82E  lwzx r3, r26, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 824AC4F0: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 824AC4F4: 4BFB7B45  bl 0x82464038
	ctx.lr = 0x824AC4F8;
	sub_82464038(ctx, base);
	// 824AC4F8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AC4FC: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 824AC500: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AC504: 556B0042  rlwinm r11, r11, 0, 1, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824AC508: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 824AC50C: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x824AC510; continue 'dispatch;
            }
            0x824AC510 => {
    //   block [0x824AC510..0x824AC52C)
	// 824AC510: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AC514: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AC518: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AC51C: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 824AC520: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AC524: 40990020  ble cr6, 0x824ac544
	if !ctx.cr[6].gt {
	pc = 0x824AC544; continue 'dispatch;
	}
	// 824AC528: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	pc = 0x824AC52C; continue 'dispatch;
            }
            0x824AC52C => {
    //   block [0x824AC52C..0x824AC544)
	// 824AC52C: 7D09582E  lwzx r8, r9, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824AC530: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 824AC534: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824AC538: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 824AC53C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824AC540: 409AFFEC  bne cr6, 0x824ac52c
	if !ctx.cr[6].eq {
	pc = 0x824AC52C; continue 'dispatch;
	}
	pc = 0x824AC544; continue 'dispatch;
            }
            0x824AC544 => {
    //   block [0x824AC544..0x824AC580)
	// 824AC544: 3BDF008C  addi r30, r31, 0x8c
	ctx.r[30].s64 = ctx.r[31].s64 + 140;
	// 824AC548: 3BBB008C  addi r29, r27, 0x8c
	ctx.r[29].s64 = ctx.r[27].s64 + 140;
	// 824AC54C: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AC550: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AC554: 554B00BE  clrlwi r11, r10, 2
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 824AC558: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824AC55C: 40980050  bge cr6, 0x824ac5ac
	if !ctx.cr[6].lt {
	pc = 0x824AC5AC; continue 'dispatch;
	}
	// 824AC560: 554A0000  rlwinm r10, r10, 0, 0, 0
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 824AC564: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AC568: 409A0018  bne cr6, 0x824ac580
	if !ctx.cr[6].eq {
	pc = 0x824AC580; continue 'dispatch;
	}
	// 824AC56C: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824AC570: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AC574: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824AC578: 7C7AC82E  lwzx r3, r26, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 824AC57C: 4BFB7B3D  bl 0x824640b8
	ctx.lr = 0x824AC580;
	sub_824640B8(ctx, base);
	pc = 0x824AC580; continue 'dispatch;
            }
            0x824AC580 => {
    //   block [0x824AC580..0x824AC5AC)
	// 824AC580: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AC584: 38A00017  li r5, 0x17
	ctx.r[5].s64 = 23;
	// 824AC588: 7C7AC82E  lwzx r3, r26, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 824AC58C: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 824AC590: 4BFB7AA9  bl 0x82464038
	ctx.lr = 0x824AC594;
	sub_82464038(ctx, base);
	// 824AC594: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AC598: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 824AC59C: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AC5A0: 556B0042  rlwinm r11, r11, 0, 1, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824AC5A4: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 824AC5A8: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x824AC5AC; continue 'dispatch;
            }
            0x824AC5AC => {
    //   block [0x824AC5AC..0x824AC5C8)
	// 824AC5AC: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AC5B0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AC5B4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AC5B8: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 824AC5BC: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AC5C0: 40990020  ble cr6, 0x824ac5e0
	if !ctx.cr[6].gt {
	pc = 0x824AC5E0; continue 'dispatch;
	}
	// 824AC5C4: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	pc = 0x824AC5C8; continue 'dispatch;
            }
            0x824AC5C8 => {
    //   block [0x824AC5C8..0x824AC5E0)
	// 824AC5C8: 7D09582E  lwzx r8, r9, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824AC5CC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 824AC5D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824AC5D4: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 824AC5D8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824AC5DC: 409AFFEC  bne cr6, 0x824ac5c8
	if !ctx.cr[6].eq {
	pc = 0x824AC5C8; continue 'dispatch;
	}
	pc = 0x824AC5E0; continue 'dispatch;
            }
            0x824AC5E0 => {
    //   block [0x824AC5E0..0x824AC5F8)
	// 824AC5E0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824AC5E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AC5E8: 4BFE4A09  bl 0x82490ff0
	ctx.lr = 0x824AC5EC;
	sub_82490FF0(ctx, base);
	// 824AC5EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AC5F0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 824AC5F4: 48088B08  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AC5F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AC5F8 size=172
    let mut pc: u32 = 0x824AC5F8;
    'dispatch: loop {
        match pc {
            0x824AC5F8 => {
    //   block [0x824AC5F8..0x824AC620)
	// 824AC5F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AC5FC: 48088AB1  bl 0x825350ac
	ctx.lr = 0x824AC600;
	sub_82535080(ctx, base);
	// 824AC600: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AC604: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 824AC608: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 824AC60C: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 824AC610: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 824AC614: 409A000C  bne cr6, 0x824ac620
	if !ctx.cr[6].eq {
	pc = 0x824AC620; continue 'dispatch;
	}
	// 824AC618: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AC61C: 834B006C  lwz r26, 0x6c(r11)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	pc = 0x824AC620; continue 'dispatch;
            }
            0x824AC620 => {
    //   block [0x824AC620..0x824AC63C)
	// 824AC620: 817B0154  lwz r11, 0x154(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(340 as u32) ) } as u64;
	// 824AC624: 839A0000  lwz r28, 0(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AC628: 3BEBFFFF  addi r31, r11, -1
	ctx.r[31].s64 = ctx.r[11].s64 + -1;
	// 824AC62C: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824AC630: 4198006C  blt cr6, 0x824ac69c
	if ctx.cr[6].lt {
	pc = 0x824AC69C; continue 'dispatch;
	}
	// 824AC634: 3BBB0010  addi r29, r27, 0x10
	ctx.r[29].s64 = ctx.r[27].s64 + 16;
	// 824AC638: 57FE103A  slwi r30, r31, 2
	ctx.r[30].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	pc = 0x824AC63C; continue 'dispatch;
            }
            0x824AC63C => {
    //   block [0x824AC63C..0x824AC69C)
	// 824AC63C: 815B0150  lwz r10, 0x150(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(336 as u32) ) } as u64;
	// 824AC640: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 824AC644: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AC648: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 824AC64C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 824AC650: 7C8AF02E  lwzx r4, r10, r30
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824AC654: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824AC658: 396B000D  addi r11, r11, 0xd
	ctx.r[11].s64 = ctx.r[11].s64 + 13;
	// 824AC65C: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AC660: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824AC664: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824AC668: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824AC66C: 7D6BE0AE  lbzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 824AC670: 556A103E  rotlwi r10, r11, 2
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 824AC674: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824AC678: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824AC67C: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 824AC680: 816B09A8  lwz r11, 0x9a8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2472 as u32) ) } as u64;
	// 824AC684: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AC688: 4E800421  bctrl
	ctx.lr = 0x824AC68C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824AC68C: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 824AC690: 3BDEFFFC  addi r30, r30, -4
	ctx.r[30].s64 = ctx.r[30].s64 + -4;
	// 824AC694: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824AC698: 4098FFA4  bge cr6, 0x824ac63c
	if !ctx.cr[6].lt {
	pc = 0x824AC63C; continue 'dispatch;
	}
            }
            0x824AC69C => {
    //   block [0x824AC69C..0x824AC6A4)
	// 824AC69C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 824AC6A0: 48088A5C  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AC6A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AC6A8 size=184
    let mut pc: u32 = 0x824AC6A8;
    'dispatch: loop {
        match pc {
            0x824AC6A8 => {
    //   block [0x824AC6A8..0x824AC6D0)
	// 824AC6A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AC6AC: 48088A01  bl 0x825350ac
	ctx.lr = 0x824AC6B0;
	sub_82535080(ctx, base);
	// 824AC6B0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AC6B4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 824AC6B8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 824AC6BC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 824AC6C0: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 824AC6C4: 409A000C  bne cr6, 0x824ac6d0
	if !ctx.cr[6].eq {
	pc = 0x824AC6D0; continue 'dispatch;
	}
	// 824AC6C8: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AC6CC: 834B006C  lwz r26, 0x6c(r11)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	pc = 0x824AC6D0; continue 'dispatch;
            }
            0x824AC6D0 => {
    //   block [0x824AC6D0..0x824AC6EC)
	// 824AC6D0: 817B0154  lwz r11, 0x154(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(340 as u32) ) } as u64;
	// 824AC6D4: 83DA0000  lwz r30, 0(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AC6D8: 3B2BFFFF  addi r25, r11, -1
	ctx.r[25].s64 = ctx.r[11].s64 + -1;
	// 824AC6DC: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 824AC6E0: 41980078  blt cr6, 0x824ac758
	if ctx.cr[6].lt {
	pc = 0x824AC758; continue 'dispatch;
	}
	// 824AC6E4: 3BFB0010  addi r31, r27, 0x10
	ctx.r[31].s64 = ctx.r[27].s64 + 16;
	// 824AC6E8: 573C103A  slwi r28, r25, 2
	ctx.r[28].u32 = ctx.r[25].u32.wrapping_shl(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	pc = 0x824AC6EC; continue 'dispatch;
            }
            0x824AC6EC => {
    //   block [0x824AC6EC..0x824AC758)
	// 824AC6EC: 815B0150  lwz r10, 0x150(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(336 as u32) ) } as u64;
	// 824AC6F0: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 824AC6F4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AC6F8: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 824AC6FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AC700: 7C8AE02E  lwzx r4, r10, r28
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 824AC704: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824AC708: 396B000D  addi r11, r11, 0xd
	ctx.r[11].s64 = ctx.r[11].s64 + 13;
	// 824AC70C: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AC710: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824AC714: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824AC718: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824AC71C: 7D6BF0AE  lbzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824AC720: 556A103E  rotlwi r10, r11, 2
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 824AC724: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824AC728: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824AC72C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 824AC730: 816B09A4  lwz r11, 0x9a4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2468 as u32) ) } as u64;
	// 824AC734: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AC738: 4E800421  bctrl
	ctx.lr = 0x824AC73C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824AC73C: 897D0004  lbz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AC740: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824AC744: 409A0014  bne cr6, 0x824ac758
	if !ctx.cr[6].eq {
	pc = 0x824AC758; continue 'dispatch;
	}
	// 824AC748: 3B39FFFF  addi r25, r25, -1
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	// 824AC74C: 3B9CFFFC  addi r28, r28, -4
	ctx.r[28].s64 = ctx.r[28].s64 + -4;
	// 824AC750: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 824AC754: 4098FF98  bge cr6, 0x824ac6ec
	if !ctx.cr[6].lt {
	pc = 0x824AC6EC; continue 'dispatch;
	}
            }
            0x824AC758 => {
    //   block [0x824AC758..0x824AC760)
	// 824AC758: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 824AC75C: 480889A0  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AC760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AC760 size=136
    let mut pc: u32 = 0x824AC760;
    'dispatch: loop {
        match pc {
            0x824AC760 => {
    //   block [0x824AC760..0x824AC7B8)
	// 824AC760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AC764: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AC768: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824AC76C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AC770: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AC774: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 824AC778: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824AC77C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AC780: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824AC784: 419A004C  beq cr6, 0x824ac7d0
	if ctx.cr[6].eq {
	pc = 0x824AC7D0; continue 'dispatch;
	}
	// 824AC788: 4BFFE541  bl 0x824aacc8
	ctx.lr = 0x824AC78C;
	sub_824AACC8(ctx, base);
	// 824AC78C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 824AC790: 409A0040  bne cr6, 0x824ac7d0
	if !ctx.cr[6].eq {
	pc = 0x824AC7D0; continue 'dispatch;
	}
	// 824AC794: 3BFF0150  addi r31, r31, 0x150
	ctx.r[31].s64 = ctx.r[31].s64 + 336;
	// 824AC798: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AC79C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AC7A0: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824AC7A4: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824AC7A8: 409A0010  bne cr6, 0x824ac7b8
	if !ctx.cr[6].eq {
	pc = 0x824AC7B8; continue 'dispatch;
	}
	// 824AC7AC: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 824AC7B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AC7B4: 4BFC1B9D  bl 0x8246e350
	ctx.lr = 0x824AC7B8;
	sub_8246E350(ctx, base);
	pc = 0x824AC7B8; continue 'dispatch;
            }
            0x824AC7B8 => {
    //   block [0x824AC7B8..0x824AC7D0)
	// 824AC7B8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AC7BC: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AC7C0: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824AC7C4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824AC7C8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824AC7CC: 7FCA492E  stwx r30, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[30].u32) };
	pc = 0x824AC7D0; continue 'dispatch;
            }
            0x824AC7D0 => {
    //   block [0x824AC7D0..0x824AC7E8)
	// 824AC7D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824AC7D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824AC7D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824AC7DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824AC7E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824AC7E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AC7E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AC7E8 size=184
    let mut pc: u32 = 0x824AC7E8;
    'dispatch: loop {
        match pc {
            0x824AC7E8 => {
    //   block [0x824AC7E8..0x824AC874)
	// 824AC7E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AC7EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AC7F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824AC7F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AC7F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AC7FC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824AC800: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824AC804: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824AC808: 388B0948  addi r4, r11, 0x948
	ctx.r[4].s64 = ctx.r[11].s64 + 2376;
	// 824AC80C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 824AC810: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AC814: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 824AC818: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AC81C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AC820: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AC824: 4E800421  bctrl
	ctx.lr = 0x824AC828;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824AC828: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824AC82C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824AC830: 4BFFD1F9  bl 0x824a9a28
	ctx.lr = 0x824AC834;
	sub_824A9A28(ctx, base);
	// 824AC834: 817E0158  lwz r11, 0x158(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(344 as u32) ) } as u64;
	// 824AC838: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824AC83C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AC840: 409A0034  bne cr6, 0x824ac874
	if !ctx.cr[6].eq {
	pc = 0x824AC874; continue 'dispatch;
	}
	// 824AC844: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AC848: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 824AC84C: 80FE0154  lwz r7, 0x154(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(340 as u32) ) } as u64;
	// 824AC850: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 824AC854: 80DE0150  lwz r6, 0x150(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(336 as u32) ) } as u64;
	// 824AC858: 388A093C  addi r4, r10, 0x93c
	ctx.r[4].s64 = ctx.r[10].s64 + 2364;
	// 824AC85C: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 824AC860: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 824AC864: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AC868: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AC86C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AC870: 4E800421  bctrl
	ctx.lr = 0x824AC874;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824AC874 => {
    //   block [0x824AC874..0x824AC8A0)
	// 824AC874: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AC878: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AC87C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824AC880: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AC884: 4E800421  bctrl
	ctx.lr = 0x824AC888;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824AC888: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824AC88C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824AC890: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824AC894: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824AC898: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824AC89C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AC8A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AC8A0 size=144
    let mut pc: u32 = 0x824AC8A0;
    'dispatch: loop {
        match pc {
            0x824AC8A0 => {
    //   block [0x824AC8A0..0x824AC8F4)
	// 824AC8A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AC8A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AC8A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824AC8AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AC8B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AC8B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824AC8B8: 817E0154  lwz r11, 0x154(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(340 as u32) ) } as u64;
	// 824AC8BC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824AC8C0: 409A0050  bne cr6, 0x824ac910
	if !ctx.cr[6].eq {
	pc = 0x824AC910; continue 'dispatch;
	}
	// 824AC8C4: 3BFE0150  addi r31, r30, 0x150
	ctx.r[31].s64 = ctx.r[30].s64 + 336;
	// 824AC8C8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AC8CC: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824AC8D0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AC8D4: 409A0020  bne cr6, 0x824ac8f4
	if !ctx.cr[6].eq {
	pc = 0x824AC8F4; continue 'dispatch;
	}
	// 824AC8D8: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AC8DC: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824AC8E0: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824AC8E4: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AC8E8: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824AC8EC: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824AC8F0: 4BFB77C9  bl 0x824640b8
	ctx.lr = 0x824AC8F4;
	sub_824640B8(ctx, base);
	pc = 0x824AC8F4; continue 'dispatch;
            }
            0x824AC8F4 => {
    //   block [0x824AC8F4..0x824AC910)
	// 824AC8F4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AC8F8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 824AC8FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824AC900: 512AF880  rlwimi r10, r9, 0x1f, 2, 0
	ctx.r[10].u64 = (((ctx.r[9].u32).rotate_left(31) as u64) & 0xFFFFFFFFBFFFFFFF) | (ctx.r[10].u64 & 0x0000000040000000);
	// 824AC904: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824AC908: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824AC90C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x824AC910; continue 'dispatch;
            }
            0x824AC910 => {
    //   block [0x824AC910..0x824AC930)
	// 824AC910: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824AC914: 4BFFD5FD  bl 0x824a9f10
	ctx.lr = 0x824AC918;
	sub_824A9F10(ctx, base);
	// 824AC918: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824AC91C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824AC920: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824AC924: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824AC928: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824AC92C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AC930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AC930 size=532
    let mut pc: u32 = 0x824AC930;
    'dispatch: loop {
        match pc {
            0x824AC930 => {
    //   block [0x824AC930..0x824ACB44)
	// 824AC930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AC934: 48088779  bl 0x825350ac
	ctx.lr = 0x824AC938;
	sub_82535080(ctx, base);
	// 824AC938: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824ACB48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824ACB48 size=8
    let mut pc: u32 = 0x824ACB48;
    'dispatch: loop {
        match pc {
            0x824ACB48 => {
    //   block [0x824ACB48..0x824ACB50)
	// 824ACB48: 38600065  li r3, 0x65
	ctx.r[3].s64 = 101;
	// 824ACB4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824ACB50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824ACB50 size=84
    let mut pc: u32 = 0x824ACB50;
    'dispatch: loop {
        match pc {
            0x824ACB50 => {
    //   block [0x824ACB50..0x824ACBA4)
	// 824ACB50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824ACB54: 3943000C  addi r10, r3, 0xc
	ctx.r[10].s64 = ctx.r[3].s64 + 12;
	// 824ACB58: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 824ACB5C: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 824ACB60: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 824ACB64: 91440010  stw r10, 0x10(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 824ACB68: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 824ACB6C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824ACB70: 91040004  stw r8, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 824ACB74: 91240014  stw r9, 0x14(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 824ACB78: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 824ACB7C: 1D4B0134  mulli r10, r11, 0x134
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 308 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 824ACB80: 394A0033  addi r10, r10, 0x33
	ctx.r[10].s64 = ctx.r[10].s64 + 51;
	// 824ACB84: 554A0036  rlwinm r10, r10, 0, 0, 0x1b
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 824ACB88: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 824ACB8C: 91440004  stw r10, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 824ACB90: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824ACB94: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824ACB98: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 824ACB9C: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 824ACBA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824ACBA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824ACBA8 size=40
    let mut pc: u32 = 0x824ACBA8;
    'dispatch: loop {
        match pc {
            0x824ACBA8 => {
    //   block [0x824ACBA8..0x824ACBD0)
	// 824ACBA8: 7C8B0774  extsb r11, r4
	ctx.r[11].s64 = ctx.r[4].s8 as i64;
	// 824ACBAC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824ACBB0: 419A0020  beq cr6, 0x824acbd0
	if ctx.cr[6].eq {
		sub_824ACBD0(ctx, base);
		return;
	}
	// 824ACBB4: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 824ACBB8: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824ACBBC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824ACBC0: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824ACBC4: 91650004  stw r11, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824ACBC8: 91450000  stw r10, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824ACBCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824ACBD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824ACBD0 size=16
    let mut pc: u32 = 0x824ACBD0;
    'dispatch: loop {
        match pc {
            0x824ACBD0 => {
    //   block [0x824ACBD0..0x824ACBE0)
	// 824ACBD0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824ACBD4: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824ACBD8: 91650004  stw r11, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824ACBDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824ACBE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824ACBE0 size=152
    let mut pc: u32 = 0x824ACBE0;
    'dispatch: loop {
        match pc {
            0x824ACBE0 => {
    //   block [0x824ACBE0..0x824ACC78)
	// 824ACBE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824ACBE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824ACBE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824ACBEC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824ACBF0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824ACBF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824ACBF8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 824ACBFC: 3D008000  lis r8, -0x8000
	ctx.r[8].s64 = -2147483648;
	// 824ACC00: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 824ACC04: C00B2984  lfs f0, 0x2984(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10628 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824ACC08: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824ACC0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824ACC10: B13F0006  sth r9, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 824ACC14: C1AB1850  lfs f13, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824ACC18: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824ACC1C: 394B095C  addi r10, r11, 0x95c
	ctx.r[10].s64 = ctx.r[11].s64 + 2396;
	// 824ACC20: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824ACC24: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824ACC28: C18B0900  lfs f12, 0x900(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2304 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 824ACC2C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824ACC30: C16B8E30  lfs f11, -0x71d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29136 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 824ACC34: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824ACC38: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 824ACC3C: B13F000C  sth r9, 0xc(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u16 ) };
	// 824ACC40: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 824ACC44: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 824ACC48: 911F0020  stw r8, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[8].u32 ) };
	// 824ACC4C: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 824ACC50: D1BF0028  stfs f13, 0x28(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 824ACC54: D19F002C  stfs f12, 0x2c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 824ACC58: D17F0030  stfs f11, 0x30(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 824ACC5C: 4BFF625D  bl 0x824a2eb8
	ctx.lr = 0x824ACC60;
	sub_824A2EB8(ctx, base);
	// 824ACC60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824ACC64: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824ACC68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824ACC6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824ACC70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824ACC74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824ACC78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824ACC78 size=104
    let mut pc: u32 = 0x824ACC78;
    'dispatch: loop {
        match pc {
            0x824ACC78 => {
    //   block [0x824ACC78..0x824ACCE0)
	// 824ACC78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824ACC7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824ACC80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824ACC84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824ACC88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824ACC8C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824ACC90: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 824ACC94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824ACC98: 396B095C  addi r11, r11, 0x95c
	ctx.r[11].s64 = ctx.r[11].s64 + 2396;
	// 824ACC9C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 824ACCA0: 3BDF000C  addi r30, r31, 0xc
	ctx.r[30].s64 = ctx.r[31].s64 + 12;
	// 824ACCA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824ACCA8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824ACCAC: B15F0006  sth r10, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 824ACCB0: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 824ACCB4: 4BFF6205  bl 0x824a2eb8
	ctx.lr = 0x824ACCB8;
	sub_824A2EB8(ctx, base);
	// 824ACCB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824ACCBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824ACCC0: 4BFF61F9  bl 0x824a2eb8
	ctx.lr = 0x824ACCC4;
	sub_824A2EB8(ctx, base);
	// 824ACCC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824ACCC8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824ACCCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824ACCD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824ACCD4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824ACCD8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824ACCDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824ACCE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824ACCE0 size=108
    let mut pc: u32 = 0x824ACCE0;
    'dispatch: loop {
        match pc {
            0x824ACCE0 => {
    //   block [0x824ACCE0..0x824ACD2C)
	// 824ACCE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824ACCE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824ACCE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824ACCEC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824ACCF0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824ACCF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824ACCF8: 396B095C  addi r11, r11, 0x95c
	ctx.r[11].s64 = ctx.r[11].s64 + 2396;
	// 824ACCFC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824ACD00: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 824ACD04: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824ACD08: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824ACD0C: 409A0020  bne cr6, 0x824acd2c
	if !ctx.cr[6].eq {
	pc = 0x824ACD2C; continue 'dispatch;
	}
	// 824ACD10: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824ACD14: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824ACD18: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824ACD1C: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 824ACD20: 55652834  slwi r5, r11, 5
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824ACD24: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824ACD28: 4BFB7391  bl 0x824640b8
	ctx.lr = 0x824ACD2C;
	sub_824640B8(ctx, base);
	pc = 0x824ACD2C; continue 'dispatch;
            }
            0x824ACD2C => {
    //   block [0x824ACD2C..0x824ACD4C)
	// 824ACD2C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824ACD30: 396B6DD0  addi r11, r11, 0x6dd0
	ctx.r[11].s64 = ctx.r[11].s64 + 28112;
	// 824ACD34: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824ACD38: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824ACD3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824ACD40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824ACD44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824ACD48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824ACD50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824ACD50 size=108
    let mut pc: u32 = 0x824ACD50;
    'dispatch: loop {
        match pc {
            0x824ACD50 => {
    //   block [0x824ACD50..0x824ACD88)
	// 824ACD50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824ACD54: 48088369  bl 0x825350bc
	ctx.lr = 0x824ACD58;
	sub_82535080(ctx, base);
	// 824ACD58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824ACD5C: 3BE30018  addi r31, r3, 0x18
	ctx.r[31].s64 = ctx.r[3].s64 + 24;
	// 824ACD60: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 824ACD64: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 824ACD68: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824ACD6C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824ACD70: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824ACD74: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824ACD78: 409A0010  bne cr6, 0x824acd88
	if !ctx.cr[6].eq {
	pc = 0x824ACD88; continue 'dispatch;
	}
	// 824ACD7C: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 824ACD80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824ACD84: 4BFC15CD  bl 0x8246e350
	ctx.lr = 0x824ACD88;
	sub_8246E350(ctx, base);
	pc = 0x824ACD88; continue 'dispatch;
            }
            0x824ACD88 => {
    //   block [0x824ACD88..0x824ACDBC)
	// 824ACD88: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824ACD8C: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 824ACD90: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824ACD94: 556A2834  slwi r10, r11, 5
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824ACD98: 38EB0001  addi r7, r11, 1
	ctx.r[7].s64 = ctx.r[11].s64 + 1;
	// 824ACD9C: 7D6A4A14  add r11, r10, r9
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 824ACDA0: 90FF0004  stw r7, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824ACDC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824ACDC0 size=640
    let mut pc: u32 = 0x824ACDC0;
    'dispatch: loop {
        match pc {
            0x824ACDC0 => {
    //   block [0x824ACDC0..0x824ACDFC)
	// 824ACDC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824ACDC4: 480882C9  bl 0x8253508c
	ctx.lr = 0x824ACDC8;
	sub_82535080(ctx, base);
	// 824ACDC8: 9421FE10  stwu r1, -0x1f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-496 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824ACDCC: 7C932378  mr r19, r4
	ctx.r[19].u64 = ctx.r[4].u64;
	// 824ACDD0: 7CB12B78  mr r17, r5
	ctx.r[17].u64 = ctx.r[5].u64;
	// 824ACDD4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 824ACDD8: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 824ACDDC: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 824ACDE0: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 824ACDE4: 80B3004C  lwz r5, 0x4c(r19)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(76 as u32) ) } as u64;
	// 824ACDE8: 48044E89  bl 0x824f1c70
	ctx.lr = 0x824ACDEC;
	sub_824F1C70(ctx, base);
	// 824ACDEC: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 824ACDF0: 7E6B9B78  mr r11, r19
	ctx.r[11].u64 = ctx.r[19].u64;
	// 824ACDF4: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 824ACDF8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x824ACDFC; continue 'dispatch;
            }
            0x824ACDFC => {
    //   block [0x824ACDFC..0x824ACF08)
	// 824ACDFC: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 824ACE00: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 824ACE04: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 824ACE08: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 824ACE0C: 4200FFF0  bdnz 0x824acdfc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x824ACDFC; continue 'dispatch;
	}
	// 824ACE10: 394100EC  addi r10, r1, 0xec
	ctx.r[10].s64 = ctx.r[1].s64 + 236;
	// 824ACE14: 82930048  lwz r20, 0x48(r19)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(72 as u32) ) } as u64;
	// 824ACE18: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 824ACE1C: 81730030  lwz r11, 0x30(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(48 as u32) ) } as u64;
	// 824ACE20: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 824ACE24: 80710000  lwz r3, 0(r17)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(0 as u32) ) } as u64;
	// 824ACE28: 914100E0  stw r10, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[10].u32 ) };
	// 824ACE2C: 3D408000  lis r10, -0x8000
	ctx.r[10].s64 = -2147483648;
	// 824ACE30: 93C100E4  stw r30, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[30].u32 ) };
	// 824ACE34: 614A0020  ori r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 | 32;
	// 824ACE38: 93C100A8  stw r30, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[30].u32 ) };
	// 824ACE3C: 93C100AC  stw r30, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[30].u32 ) };
	// 824ACE40: 914100E8  stw r10, 0xe8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[10].u32 ) };
	// 824ACE44: 81540014  lwz r10, 0x14(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(20 as u32) ) } as u64;
	// 824ACE48: 814A0090  lwz r10, 0x90(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(144 as u32) ) } as u64;
	// 824ACE4C: 7EAA5850  subf r21, r10, r11
	ctx.r[21].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 824ACE50: 8154002C  lwz r10, 0x2c(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(44 as u32) ) } as u64;
	// 824ACE54: 81740030  lwz r11, 0x30(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(48 as u32) ) } as u64;
	// 824ACE58: 3A4BFFFF  addi r18, r11, -1
	ctx.r[18].s64 = ctx.r[11].s64 + -1;
	// 824ACE5C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 824ACE60: 814B0090  lwz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 824ACE64: 396B00E0  addi r11, r11, 0xe0
	ctx.r[11].s64 = ctx.r[11].s64 + 224;
	// 824ACE68: 912100E4  stw r9, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 824ACE6C: 9161009C  stw r11, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 824ACE70: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824ACE74: C00B1850  lfs f0, 0x1850(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824ACE78: 7D6AAA14  add r11, r10, r21
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[21].u64;
	// 824ACE7C: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 824ACE80: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 824ACE84: 7D755850  subf r11, r21, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[21].s64;
	// 824ACE88: 916100EC  stw r11, 0xec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 824ACE8C: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 824ACE90: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 824ACE94: 480490C5  bl 0x824f5f58
	ctx.lr = 0x824ACE98;
	sub_824F5F58(ctx, base);
	// 824ACE98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824ACE9C: 2F120000  cmpwi cr6, r18, 0
	ctx.cr[6].compare_i32(ctx.r[18].s32, 0, &mut ctx.xer);
	// 824ACEA0: 40990144  ble cr6, 0x824acfe4
	if !ctx.cr[6].gt {
	pc = 0x824ACFE4; continue 'dispatch;
	}
	// 824ACEA4: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 824ACEA8: 7E5D9378  mr r29, r18
	ctx.r[29].u64 = ctx.r[18].u64;
	// 824ACEAC: 3AC00010  li r22, 0x10
	ctx.r[22].s64 = 16;
	// 824ACEB0: 3AE00020  li r23, 0x20
	ctx.r[23].s64 = 32;
	// 824ACEB4: 3B000030  li r24, 0x30
	ctx.r[24].s64 = 48;
	// 824ACEB8: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 824ACEBC: 814100E8  lwz r10, 0xe8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(232 as u32) ) } as u64;
	// 824ACEC0: 812100E4  lwz r9, 0xe4(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 824ACEC4: 554A00BE  clrlwi r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 824ACEC8: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 824ACECC: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 824ACED0: 8161009C  lwz r11, 0x9c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 824ACED4: 91610098  stw r11, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 824ACED8: 8174002C  lwz r11, 0x2c(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(44 as u32) ) } as u64;
	// 824ACEDC: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 824ACEE0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824ACEE4: 3B6B00D0  addi r27, r11, 0xd0
	ctx.r[27].s64 = ctx.r[11].s64 + 208;
	// 824ACEE8: 814B0090  lwz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 824ACEEC: 7D6AAA14  add r11, r10, r21
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[21].u64;
	// 824ACEF0: 7F555850  subf r26, r21, r11
	ctx.r[26].s64 = ctx.r[11].s64 - ctx.r[21].s64;
	// 824ACEF4: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 824ACEF8: 409A0010  bne cr6, 0x824acf08
	if !ctx.cr[6].eq {
	pc = 0x824ACF08; continue 'dispatch;
	}
	// 824ACEFC: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 824ACF00: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 824ACF04: 4BFC144D  bl 0x8246e350
	ctx.lr = 0x824ACF08;
	sub_8246E350(ctx, base);
	pc = 0x824ACF08; continue 'dispatch;
            }
            0x824ACF08 => {
    //   block [0x824ACF08..0x824ACFE4)
	// 824ACF08: 816100E4  lwz r11, 0xe4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 824ACF0C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 824ACF10: 814100E0  lwz r10, 0xe0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) } as u64;
	// 824ACF14: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824ACF18: 7F4B512E  stwx r26, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[26].u32) };
	// 824ACF1C: 816100E4  lwz r11, 0xe4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 824ACF20: 81390018  lwz r9, 0x18(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(24 as u32) ) } as u64;
	// 824ACF24: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824ACF28: 81410098  lwz r10, 0x98(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 824ACF2C: 7D3C4A14  add r9, r28, r9
	ctx.r[9].u64 = ctx.r[28].u64 + ctx.r[9].u64;
	// 824ACF30: 916100E4  stw r11, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 824ACF34: 397B0010  addi r11, r27, 0x10
	ctx.r[11].s64 = ctx.r[27].s64 + 16;
	// 824ACF38: 9161009C  stw r11, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	pc = 0x824ACFE4; continue 'dispatch;
            }
            0x824ACFE4 => {
    //   block [0x824ACFE4..0x824AD040)
	// 824ACFE4: 7E6A9B78  mr r10, r19
	ctx.r[10].u64 = ctx.r[19].u64;
	// 824ACFE8: C079002C  lfs f3, 0x2c(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(44 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 824ACFEC: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 824ACFF0: C0590028  lfs f2, 0x28(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(40 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 824ACFF4: 7EA8AB78  mr r8, r21
	ctx.r[8].u64 = ctx.r[21].u64;
	// 824ACFF8: C0390024  lfs f1, 0x24(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(36 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 824ACFFC: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 824AD000: 80E100E0  lwz r7, 0xe0(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) } as u64;
	// 824AD004: 92210054  stw r17, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[17].u32 ) };
	// 824AD008: 48049389  bl 0x824f6390
	ctx.lr = 0x824AD00C;
	sub_824F6390(ctx, base);
	// 824AD00C: 816100E8  lwz r11, 0xe8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(232 as u32) ) } as u64;
	// 824AD010: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824AD014: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AD018: 409A0020  bne cr6, 0x824ad038
	if !ctx.cr[6].eq {
	pc = 0x824AD038; continue 'dispatch;
	}
	// 824AD01C: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AD020: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824AD024: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824AD028: 808100E0  lwz r4, 0xe0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) } as u64;
	// 824AD02C: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824AD030: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824AD034: 4BFB7085  bl 0x824640b8
	ctx.lr = 0x824AD038;
	sub_824640B8(ctx, base);
	// 824AD038: 382101F0  addi r1, r1, 0x1f0
	ctx.r[1].s64 = ctx.r[1].s64 + 496;
	// 824AD03C: 480880A0  b 0x825350dc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AD040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AD040 size=164
    let mut pc: u32 = 0x824AD040;
    'dispatch: loop {
        match pc {
            0x824AD040 => {
    //   block [0x824AD040..0x824AD094)
	// 824AD040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AD044: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AD048: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824AD04C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AD050: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AD054: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824AD058: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824AD05C: 396B095C  addi r11, r11, 0x95c
	ctx.r[11].s64 = ctx.r[11].s64 + 2396;
	// 824AD060: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 824AD064: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824AD068: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 824AD06C: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824AD070: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AD074: 409A0020  bne cr6, 0x824ad094
	if !ctx.cr[6].eq {
	pc = 0x824AD094; continue 'dispatch;
	}
	// 824AD078: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AD07C: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824AD080: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824AD084: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 824AD088: 55652834  slwi r5, r11, 5
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824AD08C: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824AD090: 4BFB7029  bl 0x824640b8
	ctx.lr = 0x824AD094;
	sub_824640B8(ctx, base);
	pc = 0x824AD094; continue 'dispatch;
            }
            0x824AD094 => {
    //   block [0x824AD094..0x824AD0C8)
	// 824AD094: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824AD098: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 824AD09C: 396B6DD0  addi r11, r11, 0x6dd0
	ctx.r[11].s64 = ctx.r[11].s64 + 28112;
	// 824AD0A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824AD0A4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824AD0A8: 419A0020  beq cr6, 0x824ad0c8
	if ctx.cr[6].eq {
	pc = 0x824AD0C8; continue 'dispatch;
	}
	// 824AD0AC: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AD0B0: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 824AD0B4: 38C0002C  li r6, 0x2c
	ctx.r[6].s64 = 44;
	// 824AD0B8: A0BF0004  lhz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AD0BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824AD0C0: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824AD0C4: 4BFB6FF5  bl 0x824640b8
	ctx.lr = 0x824AD0C8;
	sub_824640B8(ctx, base);
	pc = 0x824AD0C8; continue 'dispatch;
            }
            0x824AD0C8 => {
    //   block [0x824AD0C8..0x824AD0E4)
	// 824AD0C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AD0CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824AD0D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824AD0D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824AD0D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824AD0DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824AD0E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AD0E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AD0E8 size=8
    let mut pc: u32 = 0x824AD0E8;
    'dispatch: loop {
        match pc {
            0x824AD0E8 => {
    //   block [0x824AD0E8..0x824AD0F0)
	// 824AD0E8: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 824AD0EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AD0F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AD0F0 size=84
    let mut pc: u32 = 0x824AD0F0;
    'dispatch: loop {
        match pc {
            0x824AD0F0 => {
    //   block [0x824AD0F0..0x824AD144)
	// 824AD0F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824AD0F4: 3943000C  addi r10, r3, 0xc
	ctx.r[10].s64 = ctx.r[3].s64 + 12;
	// 824AD0F8: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 824AD0FC: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 824AD100: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 824AD104: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 824AD108: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824AD10C: 91440010  stw r10, 0x10(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 824AD110: 91040004  stw r8, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 824AD114: 91240014  stw r9, 0x14(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 824AD118: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 824AD11C: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824AD120: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 824AD124: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 824AD128: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824AD12C: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824AD130: 396B0033  addi r11, r11, 0x33
	ctx.r[11].s64 = ctx.r[11].s64 + 51;
	// 824AD134: 556B0036  rlwinm r11, r11, 0, 0, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824AD138: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 824AD13C: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824AD140: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AD148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AD148 size=32
    let mut pc: u32 = 0x824AD148;
    'dispatch: loop {
        match pc {
            0x824AD148 => {
    //   block [0x824AD148..0x824AD168)
	// 824AD148: 7C8B0774  extsb r11, r4
	ctx.r[11].s64 = ctx.r[4].s8 as i64;
	// 824AD14C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824AD150: 419A0018  beq cr6, 0x824ad168
	if ctx.cr[6].eq {
		sub_824AD168(ctx, base);
		return;
	}
	// 824AD154: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 824AD158: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824AD15C: 91650004  stw r11, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824AD160: 91450000  stw r10, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824AD164: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AD168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AD168 size=16
    let mut pc: u32 = 0x824AD168;
    'dispatch: loop {
        match pc {
            0x824AD168 => {
    //   block [0x824AD168..0x824AD178)
	// 824AD168: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824AD16C: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824AD170: 91650004  stw r11, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824AD174: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AD178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824AD178 size=140
    let mut pc: u32 = 0x824AD178;
    'dispatch: loop {
        match pc {
            0x824AD178 => {
    //   block [0x824AD178..0x824AD204)
	// 824AD178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AD17C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AD180: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AD184: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AD188: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824AD18C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824AD190: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 824AD194: 3D008000  lis r8, -0x8000
	ctx.r[8].s64 = -2147483648;
	// 824AD198: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 824AD19C: C00B2984  lfs f0, 0x2984(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10628 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824AD1A0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824AD1A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824AD1A8: B13F0006  sth r9, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 824AD1AC: C1AB1850  lfs f13, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824AD1B0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824AD1B4: 394B0994  addi r10, r11, 0x994
	ctx.r[10].s64 = ctx.r[11].s64 + 2452;
	// 824AD1B8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824AD1BC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824AD1C0: C18B0900  lfs f12, 0x900(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2304 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 824AD1C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824AD1C8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 824AD1CC: B13F000C  sth r9, 0xc(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u16 ) };
	// 824AD1D0: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 824AD1D4: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 824AD1D8: 911F0020  stw r8, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[8].u32 ) };
	// 824AD1DC: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 824AD1E0: D1BF0028  stfs f13, 0x28(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 824AD1E4: D19F002C  stfs f12, 0x2c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 824AD1E8: 4BFF5CD1  bl 0x824a2eb8
	ctx.lr = 0x824AD1EC;
	sub_824A2EB8(ctx, base);
	// 824AD1EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AD1F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824AD1F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824AD1F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824AD1FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824AD200: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AD208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AD208 size=124
    let mut pc: u32 = 0x824AD208;
    'dispatch: loop {
        match pc {
            0x824AD208 => {
    //   block [0x824AD208..0x824AD284)
	// 824AD208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AD20C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AD210: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824AD214: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AD218: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AD21C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824AD220: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 824AD224: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824AD228: 396B0994  addi r11, r11, 0x994
	ctx.r[11].s64 = ctx.r[11].s64 + 2452;
	// 824AD22C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 824AD230: 3BDF000C  addi r30, r31, 0xc
	ctx.r[30].s64 = ctx.r[31].s64 + 12;
	// 824AD234: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824AD238: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824AD23C: B15F0006  sth r10, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 824AD240: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AD244: 4BFF5C75  bl 0x824a2eb8
	ctx.lr = 0x824AD248;
	sub_824A2EB8(ctx, base);
	// 824AD248: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824AD24C: 3D408000  lis r10, -0x8000
	ctx.r[10].s64 = -2147483648;
	// 824AD250: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824AD254: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824AD258: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 824AD25C: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 824AD260: 915F0020  stw r10, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 824AD264: 4BFF5C55  bl 0x824a2eb8
	ctx.lr = 0x824AD268;
	sub_824A2EB8(ctx, base);
	// 824AD268: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AD26C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824AD270: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824AD274: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824AD278: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824AD27C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824AD280: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AD288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AD288 size=120
    let mut pc: u32 = 0x824AD288;
    'dispatch: loop {
        match pc {
            0x824AD288 => {
    //   block [0x824AD288..0x824AD2E0)
	// 824AD288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AD28C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AD290: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AD294: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AD298: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824AD29C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824AD2A0: 396B0994  addi r11, r11, 0x994
	ctx.r[11].s64 = ctx.r[11].s64 + 2452;
	// 824AD2A4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824AD2A8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 824AD2AC: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824AD2B0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AD2B4: 409A002C  bne cr6, 0x824ad2e0
	if !ctx.cr[6].eq {
	pc = 0x824AD2E0; continue 'dispatch;
	}
	// 824AD2B8: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AD2BC: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824AD2C0: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824AD2C4: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 824AD2C8: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824AD2CC: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824AD2D0: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824AD2D4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824AD2D8: 55652036  slwi r5, r11, 4
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824AD2DC: 4BFB6DDD  bl 0x824640b8
	ctx.lr = 0x824AD2E0;
	sub_824640B8(ctx, base);
	pc = 0x824AD2E0; continue 'dispatch;
            }
            0x824AD2E0 => {
    //   block [0x824AD2E0..0x824AD300)
	// 824AD2E0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824AD2E4: 396B6DD0  addi r11, r11, 0x6dd0
	ctx.r[11].s64 = ctx.r[11].s64 + 28112;
	// 824AD2E8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824AD2EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824AD2F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824AD2F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824AD2F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824AD2FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AD300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AD300 size=132
    let mut pc: u32 = 0x824AD300;
    'dispatch: loop {
        match pc {
            0x824AD300 => {
    //   block [0x824AD300..0x824AD340)
	// 824AD300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AD304: 48087DB9  bl 0x825350bc
	ctx.lr = 0x824AD308;
	sub_82535080(ctx, base);
	// 824AD308: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 824AD30C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AD310: 3BE30018  addi r31, r3, 0x18
	ctx.r[31].s64 = ctx.r[3].s64 + 24;
	// 824AD314: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 824AD318: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 824AD31C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 824AD320: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AD324: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AD328: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824AD32C: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824AD330: 409A0010  bne cr6, 0x824ad340
	if !ctx.cr[6].eq {
	pc = 0x824AD340; continue 'dispatch;
	}
	// 824AD334: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 824AD338: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AD33C: 4BFC1015  bl 0x8246e350
	ctx.lr = 0x824AD340;
	sub_8246E350(ctx, base);
	pc = 0x824AD340; continue 'dispatch;
            }
            0x824AD340 => {
    //   block [0x824AD340..0x824AD384)
	// 824AD340: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AD344: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 824AD348: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AD34C: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 824AD350: 38EB0001  addi r7, r11, 1
	ctx.r[7].s64 = ctx.r[11].s64 + 1;
	// 824AD354: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 824AD358: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824AD35C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824AD360: 90FF0004  stw r7, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AD388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824AD388 size=720
    let mut pc: u32 = 0x824AD388;
    'dispatch: loop {
        match pc {
            0x824AD388 => {
    //   block [0x824AD388..0x824AD3D0)
	// 824AD388: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AD38C: 48087D05  bl 0x82535090
	ctx.lr = 0x824AD390;
	sub_82535080(ctx, base);
	// 824AD390: DBA1FF70  stfd f29, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[29].u64 ) };
	// 824AD394: DBC1FF78  stfd f30, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[30].u64 ) };
	// 824AD398: DBE1FF80  stfd f31, -0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[31].u64 ) };
	// 824AD39C: 9421FDC0  stwu r1, -0x240(r1)
	ea = ctx.r[1].u32.wrapping_add(-576 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AD3A0: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 824AD3A4: 7CB42B78  mr r20, r5
	ctx.r[20].u64 = ctx.r[5].u64;
	// 824AD3A8: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 824AD3AC: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 824AD3B0: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 824AD3B4: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 824AD3B8: 80B6004C  lwz r5, 0x4c(r22)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(76 as u32) ) } as u64;
	// 824AD3BC: 480448B5  bl 0x824f1c70
	ctx.lr = 0x824AD3C0;
	sub_824F1C70(ctx, base);
	// 824AD3C0: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 824AD3C4: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 824AD3C8: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 824AD3CC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x824AD3D0; continue 'dispatch;
            }
            0x824AD3D0 => {
    //   block [0x824AD3D0..0x824AD4E8)
	// 824AD3D0: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 824AD3D4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 824AD3D8: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 824AD3DC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 824AD3E0: 4200FFF0  bdnz 0x824ad3d0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x824AD3D0; continue 'dispatch;
	}
	// 824AD3E4: 3921012C  addi r9, r1, 0x12c
	ctx.r[9].s64 = ctx.r[1].s64 + 300;
	// 824AD3E8: 81760048  lwz r11, 0x48(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(72 as u32) ) } as u64;
	// 824AD3EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 824AD3F0: 81560030  lwz r10, 0x30(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(48 as u32) ) } as u64;
	// 824AD3F4: 3B2B002C  addi r25, r11, 0x2c
	ctx.r[25].s64 = ctx.r[11].s64 + 44;
	// 824AD3F8: 80740000  lwz r3, 0(r20)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AD3FC: 91210120  stw r9, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[9].u32 ) };
	// 824AD400: 3D208000  lis r9, -0x8000
	ctx.r[9].s64 = -2147483648;
	// 824AD404: 93E10124  stw r31, 0x124(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), ctx.r[31].u32 ) };
	// 824AD408: 61290020  ori r9, r9, 0x20
	ctx.r[9].u64 = ctx.r[9].u64 | 32;
	// 824AD40C: 93E100C8  stw r31, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[31].u32 ) };
	// 824AD410: 93E100CC  stw r31, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[31].u32 ) };
	// 824AD414: 91210128  stw r9, 0x128(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), ctx.r[9].u32 ) };
	// 824AD418: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 824AD41C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 824AD420: 816B0090  lwz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 824AD424: 7FCB5050  subf r30, r11, r10
	ctx.r[30].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 824AD428: 81590000  lwz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AD42C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AD430: 3AABFFFF  addi r21, r11, -1
	ctx.r[21].s64 = ctx.r[11].s64 + -1;
	// 824AD434: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AD438: 814B0090  lwz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 824AD43C: 396B00E0  addi r11, r11, 0xe0
	ctx.r[11].s64 = ctx.r[11].s64 + 224;
	// 824AD440: 91210124  stw r9, 0x124(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), ctx.r[9].u32 ) };
	// 824AD444: 916100BC  stw r11, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[11].u32 ) };
	// 824AD448: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824AD44C: C3AB1850  lfs f29, 0x1850(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 824AD450: 7D6AF214  add r11, r10, r30
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 824AD454: D3A100A0  stfs f29, 0xa0(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 824AD458: 916100B4  stw r11, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[11].u32 ) };
	// 824AD45C: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 824AD460: 9161012C  stw r11, 0x12c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(300 as u32), ctx.r[11].u32 ) };
	// 824AD464: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 824AD468: 9161009C  stw r11, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 824AD46C: 48048AE5  bl 0x824f5f50
	ctx.lr = 0x824AD470;
	sub_824F5F50(ctx, base);
	// 824AD470: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 824AD474: 2F150000  cmpwi cr6, r21, 0
	ctx.cr[6].compare_i32(ctx.r[21].s32, 0, &mut ctx.xer);
	// 824AD478: 40990178  ble cr6, 0x824ad5f0
	if !ctx.cr[6].gt {
	pc = 0x824AD5F0; continue 'dispatch;
	}
	// 824AD47C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 824AD480: 3D608283  lis r11, -0x7d7d
	ctx.r[11].s64 = -2105344000;
	// 824AD484: 3B730018  addi r27, r19, 0x18
	ctx.r[27].s64 = ctx.r[19].s64 + 24;
	// 824AD488: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 824AD48C: 7EB7AB78  mr r23, r21
	ctx.r[23].u64 = ctx.r[21].u64;
	// 824AD490: C3CA1FF8  lfs f30, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 824AD494: 3A4B2690  addi r18, r11, 0x2690
	ctx.r[18].s64 = ctx.r[11].s64 + 9872;
	// 824AD498: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 824AD49C: 81410128  lwz r10, 0x128(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(296 as u32) ) } as u64;
	// 824AD4A0: 81210124  lwz r9, 0x124(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(292 as u32) ) } as u64;
	// 824AD4A4: 554A00BE  clrlwi r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 824AD4A8: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 824AD4AC: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 824AD4B0: 816100BC  lwz r11, 0xbc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 824AD4B4: 916100B8  stw r11, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 824AD4B8: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AD4BC: 7D7A5A14  add r11, r26, r11
	ctx.r[11].u64 = ctx.r[26].u64 + ctx.r[11].u64;
	// 824AD4C0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AD4C4: 3BAB00D0  addi r29, r11, 0xd0
	ctx.r[29].s64 = ctx.r[11].s64 + 208;
	// 824AD4C8: 814B0090  lwz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 824AD4CC: 7D6AF214  add r11, r10, r30
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 824AD4D0: 7F9E5850  subf r28, r30, r11
	ctx.r[28].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 824AD4D4: 916100B4  stw r11, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[11].u32 ) };
	// 824AD4D8: 409A0010  bne cr6, 0x824ad4e8
	if !ctx.cr[6].eq {
	pc = 0x824AD4E8; continue 'dispatch;
	}
	// 824AD4DC: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 824AD4E0: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 824AD4E4: 4BFC0E6D  bl 0x8246e350
	ctx.lr = 0x824AD4E8;
	sub_8246E350(ctx, base);
	pc = 0x824AD4E8; continue 'dispatch;
            }
            0x824AD4E8 => {
    //   block [0x824AD4E8..0x824AD5F0)
	// 824AD4E8: 81610124  lwz r11, 0x124(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(292 as u32) ) } as u64;
	// 824AD4EC: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 824AD4F0: 81410120  lwz r10, 0x120(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(288 as u32) ) } as u64;
	// 824AD4F4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824AD4F8: 7F8B512E  stwx r28, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[28].u32) };
	// 824AD4FC: 81410124  lwz r10, 0x124(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(292 as u32) ) } as u64;
	// 824AD500: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AD504: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824AD508: 808100B8  lwz r4, 0xb8(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 824AD50C: 7CBF5A14  add r5, r31, r11
	ctx.r[5].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 824AD510: 91410124  stw r10, 0x124(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), ctx.r[10].u32 ) };
	// 824AD514: 395D0010  addi r10, r29, 0x10
	ctx.r[10].s64 = ctx.r[29].s64 + 16;
	// 824AD518: 914100BC  stw r10, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[10].u32 ) };
	// 824AD51C: 480FE5ED  bl 0x825abb08
	ctx.lr = 0x824AD520;
	sub_825ABB08(ctx, base);
	// 824AD520: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AD524: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 824AD528: 808100BC  lwz r4, 0xbc(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 824AD52C: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 824AD530: 38AB0010  addi r5, r11, 0x10
	ctx.r[5].s64 = ctx.r[11].s64 + 16;
	// 824AD534: 480FE5D5  bl 0x825abb08
	ctx.lr = 0x824AD538;
	sub_825ABB08(ctx, base);
	// 824AD538: 396100F0  addi r11, r1, 0xf0
	ctx.r[11].s64 = ctx.r[1].s64 + 240;
	// 824AD53C: 39410110  addi r10, r1, 0x110
	ctx.r[10].s64 = ctx.r[1].s64 + 272;
	pc = 0x824AD5F0; continue 'dispatch;
            }
            0x824AD5F0 => {
    //   block [0x824AD5F0..0x824AD658)
	// 824AD5F0: 7ECAB378  mr r10, r22
	ctx.r[10].u64 = ctx.r[22].u64;
	// 824AD5F4: C073002C  lfs f3, 0x2c(r19)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(44 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 824AD5F8: 7F09C378  mr r9, r24
	ctx.r[9].u64 = ctx.r[24].u64;
	// 824AD5FC: C0530028  lfs f2, 0x28(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(40 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 824AD600: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 824AD604: C0330024  lfs f1, 0x24(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(36 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 824AD608: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 824AD60C: 80E10120  lwz r7, 0x120(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(288 as u32) ) } as u64;
	// 824AD610: 92810054  stw r20, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[20].u32 ) };
	// 824AD614: 48049365  bl 0x824f6978
	ctx.lr = 0x824AD618;
	sub_824F6978(ctx, base);
	// 824AD618: 81610128  lwz r11, 0x128(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(296 as u32) ) } as u64;
	// 824AD61C: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824AD620: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AD624: 409A0020  bne cr6, 0x824ad644
	if !ctx.cr[6].eq {
	pc = 0x824AD644; continue 'dispatch;
	}
	// 824AD628: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AD62C: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824AD630: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824AD634: 80810120  lwz r4, 0x120(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(288 as u32) ) } as u64;
	// 824AD638: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824AD63C: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824AD640: 4BFB6A79  bl 0x824640b8
	ctx.lr = 0x824AD644;
	sub_824640B8(ctx, base);
	// 824AD644: 38210240  addi r1, r1, 0x240
	ctx.r[1].s64 = ctx.r[1].s64 + 576;
	// 824AD648: CBA1FF70  lfd f29, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 824AD64C: CBC1FF78  lfd f30, -0x88(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 824AD650: CBE1FF80  lfd f31, -0x80(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 824AD654: 48087A8C  b 0x825350e0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AD658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AD658 size=100
    let mut pc: u32 = 0x824AD658;
    'dispatch: loop {
        match pc {
            0x824AD658 => {
    //   block [0x824AD658..0x824AD6A0)
	// 824AD658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AD65C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AD660: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824AD664: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AD668: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AD66C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824AD670: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 824AD674: 4BFFFC15  bl 0x824ad288
	ctx.lr = 0x824AD678;
	sub_824AD288(ctx, base);
	// 824AD678: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 824AD67C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824AD680: 419A0020  beq cr6, 0x824ad6a0
	if ctx.cr[6].eq {
	pc = 0x824AD6A0; continue 'dispatch;
	}
	// 824AD684: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AD688: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 824AD68C: 38C0002C  li r6, 0x2c
	ctx.r[6].s64 = 44;
	// 824AD690: A0BF0004  lhz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AD694: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824AD698: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824AD69C: 4BFB6A1D  bl 0x824640b8
	ctx.lr = 0x824AD6A0;
	sub_824640B8(ctx, base);
	pc = 0x824AD6A0; continue 'dispatch;
            }
            0x824AD6A0 => {
    //   block [0x824AD6A0..0x824AD6BC)
	// 824AD6A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AD6A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824AD6A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824AD6AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824AD6B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824AD6B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824AD6B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AD6C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824AD6C0 size=164
    let mut pc: u32 = 0x824AD6C0;
    'dispatch: loop {
        match pc {
            0x824AD6C0 => {
    //   block [0x824AD6C0..0x824AD764)
	// 824AD6C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AD6C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AD6C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AD6CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AD6D0: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AD6D4: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 824AD6D8: 38A0002C  li r5, 0x2c
	ctx.r[5].s64 = 44;
	// 824AD6DC: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 824AD6E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824AD6E4: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824AD6E8: 4BFB6951  bl 0x82464038
	ctx.lr = 0x824AD6EC;
	sub_82464038(ctx, base);
	// 824AD6EC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824AD6F0: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 824AD6F4: 396BE2F8  addi r11, r11, -0x1d08
	ctx.r[11].s64 = ctx.r[11].s64 + -7432;
	// 824AD6F8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 824AD6FC: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 824AD700: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824AD704: B1030004  sth r8, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[8].u16 ) };
	// 824AD708: 394AE30C  addi r10, r10, -0x1cf4
	ctx.r[10].s64 = ctx.r[10].s64 + -7412;
	// 824AD70C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824AD710: 3929F0E4  addi r9, r9, -0xf1c
	ctx.r[9].s64 = ctx.r[9].s64 + -3868;
	// 824AD714: B0E30006  sth r7, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[7].u16 ) };
	// 824AD718: 897F0008  lbz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AD71C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824AD720: 99630008  stb r11, 8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u8 ) };
	// 824AD724: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824AD728: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 824AD72C: C01F0010  lfs f0, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824AD730: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824AD734: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 824AD738: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824AD73C: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 824AD740: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824AD744: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 824AD748: 897F001C  lbz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 824AD74C: 9963001C  stb r11, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 824AD750: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824AD754: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824AD758: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824AD75C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824AD760: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AD768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AD768 size=88
    let mut pc: u32 = 0x824AD768;
    'dispatch: loop {
        match pc {
            0x824AD768 => {
    //   block [0x824AD768..0x824AD7C0)
	// 824AD768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AD76C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AD770: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824AD774: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AD778: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AD77C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824AD780: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824AD784: 807E000C  lwz r3, 0xc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 824AD788: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AD78C: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 824AD790: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AD794: 4E800421  bctrl
	ctx.lr = 0x824AD798;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824AD798: 397E0010  addi r11, r30, 0x10
	ctx.r[11].s64 = ctx.r[30].s64 + 16;
	// 824AD79C: 3940000C  li r10, 0xc
	ctx.r[10].s64 = 12;
	// 824AD7A0: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 824AD7A4: 915F0014  stw r10, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 824AD7A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824AD7AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824AD7B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824AD7B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824AD7B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824AD7BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AD7C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AD7C0 size=20
    let mut pc: u32 = 0x824AD7C0;
    'dispatch: loop {
        match pc {
            0x824AD7C0 => {
    //   block [0x824AD7C0..0x824AD7D4)
	// 824AD7C0: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 824AD7C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AD7C8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 824AD7CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AD7D0: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AD7E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AD7E8 size=64
    let mut pc: u32 = 0x824AD7E8;
    'dispatch: loop {
        match pc {
            0x824AD7E8 => {
    //   block [0x824AD7E8..0x824AD828)
	// 824AD7E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AD7EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AD7F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AD7F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AD7F8: 8084000C  lwz r4, 0xc(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 824AD7FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824AD800: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AD804: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824AD808: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AD80C: 4E800421  bctrl
	ctx.lr = 0x824AD810;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824AD810: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AD814: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824AD818: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824AD81C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824AD820: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824AD824: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AD828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AD828 size=8
    let mut pc: u32 = 0x824AD828;
    'dispatch: loop {
        match pc {
            0x824AD828 => {
    //   block [0x824AD828..0x824AD830)
	// 824AD828: 3860000D  li r3, 0xd
	ctx.r[3].s64 = 13;
	// 824AD82C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AD840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824AD840 size=132
    let mut pc: u32 = 0x824AD840;
    'dispatch: loop {
        match pc {
            0x824AD840 => {
    //   block [0x824AD840..0x824AD8A4)
	// 824AD840: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AD844: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AD848: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AD84C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AD850: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 824AD854: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824AD858: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824AD85C: 396B09CC  addi r11, r11, 0x9cc
	ctx.r[11].s64 = ctx.r[11].s64 + 2508;
	// 824AD860: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 824AD864: C00A20B0  lfs f0, 0x20b0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8368 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824AD868: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 824AD86C: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 824AD870: 909F000C  stw r4, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	// 824AD874: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824AD878: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 824AD87C: B15F0006  sth r10, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 824AD880: B15F0010  sth r10, 0x10(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u16 ) };
	// 824AD884: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 824AD888: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824AD88C: A14B0004  lhz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AD890: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824AD894: 419A0010  beq cr6, 0x824ad8a4
	if ctx.cr[6].eq {
	pc = 0x824AD8A4; continue 'dispatch;
	}
	// 824AD898: A14B0006  lhz r10, 6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 824AD89C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824AD8A0: B14B0006  sth r10, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	pc = 0x824AD8A4; continue 'dispatch;
            }
            0x824AD8A4 => {
    //   block [0x824AD8A4..0x824AD8C4)
	// 824AD8A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824AD8A8: 4BFF5611  bl 0x824a2eb8
	ctx.lr = 0x824AD8AC;
	sub_824A2EB8(ctx, base);
	// 824AD8AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AD8B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824AD8B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824AD8B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824AD8BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824AD8C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AD8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AD8C8 size=104
    let mut pc: u32 = 0x824AD8C8;
    'dispatch: loop {
        match pc {
            0x824AD8C8 => {
    //   block [0x824AD8C8..0x824AD930)
	// 824AD8C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AD8CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AD8D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824AD8D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AD8D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AD8DC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824AD8E0: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 824AD8E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824AD8E8: 396B09CC  addi r11, r11, 0x9cc
	ctx.r[11].s64 = ctx.r[11].s64 + 2508;
	// 824AD8EC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 824AD8F0: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 824AD8F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824AD8F8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824AD8FC: B15F0006  sth r10, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 824AD900: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AD904: 4BFF55B5  bl 0x824a2eb8
	ctx.lr = 0x824AD908;
	sub_824A2EB8(ctx, base);
	// 824AD908: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824AD90C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824AD910: 4BFF55A9  bl 0x824a2eb8
	ctx.lr = 0x824AD914;
	sub_824A2EB8(ctx, base);
	// 824AD914: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AD918: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824AD91C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824AD920: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824AD924: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824AD928: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824AD92C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AD930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AD930 size=124
    let mut pc: u32 = 0x824AD930;
    'dispatch: loop {
        match pc {
            0x824AD930 => {
    //   block [0x824AD930..0x824AD98C)
	// 824AD930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AD934: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AD938: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AD93C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AD940: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824AD944: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824AD948: 396B09CC  addi r11, r11, 0x9cc
	ctx.r[11].s64 = ctx.r[11].s64 + 2508;
	// 824AD94C: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824AD950: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824AD954: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AD958: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824AD95C: 419A0030  beq cr6, 0x824ad98c
	if ctx.cr[6].eq {
	pc = 0x824AD98C; continue 'dispatch;
	}
	// 824AD960: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 824AD964: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824AD968: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824AD96C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824AD970: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824AD974: 409A0018  bne cr6, 0x824ad98c
	if !ctx.cr[6].eq {
	pc = 0x824AD98C; continue 'dispatch;
	}
	// 824AD978: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AD97C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824AD980: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AD984: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AD988: 4E800421  bctrl
	ctx.lr = 0x824AD98C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824AD98C => {
    //   block [0x824AD98C..0x824AD9AC)
	// 824AD98C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824AD990: 396B6DD0  addi r11, r11, 0x6dd0
	ctx.r[11].s64 = ctx.r[11].s64 + 28112;
	// 824AD994: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824AD998: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824AD99C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824AD9A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824AD9A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824AD9A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AD9B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824AD9B0 size=184
    let mut pc: u32 = 0x824AD9B0;
    'dispatch: loop {
        match pc {
            0x824AD9B0 => {
    //   block [0x824AD9B0..0x824AD9D4)
	// 824AD9B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AD9B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AD9B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AD9BC: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AD9C0: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 824AD9C4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 824AD9C8: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 824AD9CC: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 824AD9D0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x824AD9D4; continue 'dispatch;
            }
            0x824AD9D4 => {
    //   block [0x824AD9D4..0x824ADA48)
	// 824AD9D4: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 824AD9D8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 824AD9DC: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 824AD9E0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 824AD9E4: 4200FFF0  bdnz 0x824ad9d4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x824AD9D4; continue 'dispatch;
	}
	// 824AD9E8: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 824AD9EC: C003001C  lfs f0, 0x1c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824AD9F0: C1A10090  lfs f13, 0x90(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824AD9F4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824AD9F8: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 824AD9FC: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 824ADA00: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 824ADA04: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824ADA08: 816A002C  lwz r11, 0x2c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 824ADA0C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824ADA10: 4E800421  bctrl
	ctx.lr = 0x824ADA14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824ADA14: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 824ADA18: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 824ADA1C: A1630000  lhz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824ADA20: 2B0B0016  cmplwi cr6, r11, 0x16
	ctx.cr[6].compare_u32(ctx.r[11].u32, 22 as u32, &mut ctx.xer);
	// 824ADA24: 409A0024  bne cr6, 0x824ada48
	if !ctx.cr[6].eq {
	pc = 0x824ADA48; continue 'dispatch;
	}
	// 824ADA28: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 824ADA2C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 824ADA30: 480491B1  bl 0x824f6be0
	ctx.lr = 0x824ADA34;
	sub_824F6BE0(ctx, base);
	// 824ADA34: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 824ADA38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824ADA3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824ADA40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824ADA44: 4E800020  blr
	return;
            }
            0x824ADA48 => {
    //   block [0x824ADA48..0x824ADA68)
	// 824ADA48: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 824ADA4C: 80810064  lwz r4, 0x64(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 824ADA50: 480443C9  bl 0x824f1e18
	ctx.lr = 0x824ADA54;
	sub_824F1E18(ctx, base);
	// 824ADA54: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 824ADA58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824ADA5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824ADA60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824ADA64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824ADA68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824ADA68 size=100
    let mut pc: u32 = 0x824ADA68;
    'dispatch: loop {
        match pc {
            0x824ADA68 => {
    //   block [0x824ADA68..0x824ADAB0)
	// 824ADA68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824ADA6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824ADA70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824ADA74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824ADA78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824ADA7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824ADA80: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 824ADA84: 4BFFFEAD  bl 0x824ad930
	ctx.lr = 0x824ADA88;
	sub_824AD930(ctx, base);
	// 824ADA88: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 824ADA8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824ADA90: 419A0020  beq cr6, 0x824adab0
	if ctx.cr[6].eq {
	pc = 0x824ADAB0; continue 'dispatch;
	}
	// 824ADA94: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824ADA98: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 824ADA9C: 38C0002C  li r6, 0x2c
	ctx.r[6].s64 = 44;
	// 824ADAA0: A0BF0004  lhz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824ADAA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824ADAA8: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824ADAAC: 4BFB660D  bl 0x824640b8
	ctx.lr = 0x824ADAB0;
	sub_824640B8(ctx, base);
	pc = 0x824ADAB0; continue 'dispatch;
            }
            0x824ADAB0 => {
    //   block [0x824ADAB0..0x824ADACC)
	// 824ADAB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824ADAB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824ADAB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824ADABC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824ADAC0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824ADAC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824ADAC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824ADAD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824ADAD0 size=72
    let mut pc: u32 = 0x824ADAD0;
    'dispatch: loop {
        match pc {
            0x824ADAD0 => {
    //   block [0x824ADAD0..0x824ADB18)
	// 824ADAD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824ADAD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824ADAD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824ADADC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824ADAE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824ADAE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824ADAE8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 824ADAEC: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 824ADAF0: 480FDB11  bl 0x825ab600
	ctx.lr = 0x824ADAF4;
	sub_825AB600(ctx, base);
	// 824ADAF4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 824ADAF8: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 824ADAFC: 480FDB05  bl 0x825ab600
	ctx.lr = 0x824ADB00;
	sub_825AB600(ctx, base);
	// 824ADB00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824ADB04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824ADB08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824ADB0C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824ADB10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824ADB14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824ADB18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824ADB18 size=16
    let mut pc: u32 = 0x824ADB18;
    'dispatch: loop {
        match pc {
            0x824ADB18 => {
    //   block [0x824ADB18..0x824ADB28)
	// 824ADB18: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 824ADB1C: 38800074  li r4, 0x74
	ctx.r[4].s64 = 116;
	// 824ADB20: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 824ADB24: 4BFF4E8C  b 0x824a29b0
	sub_824A29B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824ADB28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824ADB28 size=32
    let mut pc: u32 = 0x824ADB28;
    'dispatch: loop {
        match pc {
            0x824ADB28 => {
    //   block [0x824ADB28..0x824ADB48)
	// 824ADB28: 7C8B0774  extsb r11, r4
	ctx.r[11].s64 = ctx.r[4].s8 as i64;
	// 824ADB2C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824ADB30: 419A0018  beq cr6, 0x824adb48
	if ctx.cr[6].eq {
		sub_824ADB48(ctx, base);
		return;
	}
	// 824ADB34: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 824ADB38: 39400018  li r10, 0x18
	ctx.r[10].s64 = 24;
	// 824ADB3C: 91650004  stw r11, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824ADB40: 91450000  stw r10, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824ADB44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824ADB48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824ADB48 size=16
    let mut pc: u32 = 0x824ADB48;
    'dispatch: loop {
        match pc {
            0x824ADB48 => {
    //   block [0x824ADB48..0x824ADB58)
	// 824ADB48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824ADB4C: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824ADB50: 91650004  stw r11, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824ADB54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824ADB58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824ADB58 size=140
    let mut pc: u32 = 0x824ADB58;
    'dispatch: loop {
        match pc {
            0x824ADB58 => {
    //   block [0x824ADB58..0x824ADBBC)
	// 824ADB58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824ADB5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824ADB60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824ADB64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824ADB68: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 824ADB6C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824ADB70: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824ADB74: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824ADB78: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824ADB7C: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 824ADB80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 824ADB84: C3EB2238  lfs f31, 0x2238(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8760 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 824ADB88: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 824ADB8C: 480FDBD5  bl 0x825ab760
	ctx.lr = 0x824ADB90;
	sub_825AB760(ctx, base);
	// 824ADB90: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824ADB94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824ADB98: 419A0024  beq cr6, 0x824adbbc
	if ctx.cr[6].eq {
	pc = 0x824ADBBC; continue 'dispatch;
	}
	// 824ADB9C: 389F0050  addi r4, r31, 0x50
	ctx.r[4].s64 = ctx.r[31].s64 + 80;
	// 824ADBA0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 824ADBA4: 38610051  addi r3, r1, 0x51
	ctx.r[3].s64 = ctx.r[1].s64 + 81;
	// 824ADBA8: 480FDBB9  bl 0x825ab760
	ctx.lr = 0x824ADBAC;
	sub_825AB760(ctx, base);
	// 824ADBAC: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824ADBB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824ADBB4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824ADBB8: 409A0008  bne cr6, 0x824adbc0
	if !ctx.cr[6].eq {
	pc = 0x824ADBC0; continue 'dispatch;
	}
	pc = 0x824ADBBC; continue 'dispatch;
            }
            0x824ADBBC => {
    //   block [0x824ADBBC..0x824ADBC0)
	// 824ADBBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x824ADBC0; continue 'dispatch;
            }
            0x824ADBC0 => {
    //   block [0x824ADBC0..0x824ADBE4)
	// 824ADBC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824ADBC4: 997E0000  stb r11, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824ADBC8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 824ADBCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824ADBD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824ADBD4: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 824ADBD8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824ADBDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824ADBE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824ADBE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824ADBE8 size=8
    let mut pc: u32 = 0x824ADBE8;
    'dispatch: loop {
        match pc {
            0x824ADBE8 => {
    //   block [0x824ADBE8..0x824ADBF0)
	// 824ADBE8: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 824ADBEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824ADBF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824ADBF0 size=164
    let mut pc: u32 = 0x824ADBF0;
    'dispatch: loop {
        match pc {
            0x824ADBF0 => {
    //   block [0x824ADBF0..0x824ADC94)
	// 824ADBF0: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 824ADBF4: 3961FFE0  addi r11, r1, -0x20
	ctx.r[11].s64 = ctx.r[1].s64 + -32;
	// 824ADBF8: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 824ADBFC: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824ADC00: 3941FFE0  addi r10, r1, -0x20
	ctx.r[10].s64 = ctx.r[1].s64 + -32;
	// 824ADC04: 3929F1A4  addi r9, r9, -0xe5c
	ctx.r[9].s64 = ctx.r[9].s64 + -3676;
	// 824ADC08: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824ADC98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824ADC98 size=92
    let mut pc: u32 = 0x824ADC98;
    'dispatch: loop {
        match pc {
            0x824ADC98 => {
    //   block [0x824ADC98..0x824ADCF4)
	// 824ADC98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824ADC9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824ADCA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824ADCA4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 824ADCA8: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824ADCAC: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 824ADCB0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824ADCF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824ADCF8 size=72
    let mut pc: u32 = 0x824ADCF8;
    'dispatch: loop {
        match pc {
            0x824ADCF8 => {
    //   block [0x824ADCF8..0x824ADD40)
	// 824ADCF8: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 824ADCFC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824ADD00: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 824ADD04: 396BF214  addi r11, r11, -0xdec
	ctx.r[11].s64 = ctx.r[11].s64 + -3564;
	// 824ADD08: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 824ADD0C: C00A0858  lfs f0, 0x858(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824ADD10: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 824ADD14: B1230006  sth r9, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 824ADD18: C1AA24B0  lfs f13, 0x24b0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9392 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824ADD1C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 824ADD20: 99430008  stb r10, 8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 824ADD24: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824ADD28: 90830018  stw r4, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[4].u32 ) };
	// 824ADD2C: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 824ADD30: D1A30010  stfs f13, 0x10(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 824ADD34: 99030008  stb r8, 8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u8 ) };
	// 824ADD38: 90A30014  stw r5, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[5].u32 ) };
	// 824ADD3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824ADD40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824ADD40 size=180
    let mut pc: u32 = 0x824ADD40;
    'dispatch: loop {
        match pc {
            0x824ADD40 => {
    //   block [0x824ADD40..0x824ADDF4)
	// 824ADD40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824ADD44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824ADD48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824ADD4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824ADD50: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824ADD54: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 824ADD58: 38A0002C  li r5, 0x2c
	ctx.r[5].s64 = 44;
	// 824ADD5C: 38800028  li r4, 0x28
	ctx.r[4].s64 = 40;
	// 824ADD60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824ADD64: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824ADD68: 4BFB62D1  bl 0x82464038
	ctx.lr = 0x824ADD6C;
	sub_82464038(ctx, base);
	// 824ADD6C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824ADD70: 39000028  li r8, 0x28
	ctx.r[8].s64 = 40;
	// 824ADD74: 396BE2F8  addi r11, r11, -0x1d08
	ctx.r[11].s64 = ctx.r[11].s64 + -7432;
	// 824ADD78: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 824ADD7C: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 824ADD80: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824ADD84: B1030004  sth r8, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[8].u16 ) };
	// 824ADD88: 394AE30C  addi r10, r10, -0x1cf4
	ctx.r[10].s64 = ctx.r[10].s64 + -7412;
	// 824ADD8C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824ADD90: 3929F214  addi r9, r9, -0xdec
	ctx.r[9].s64 = ctx.r[9].s64 + -3564;
	// 824ADD94: B0E30006  sth r7, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[7].u16 ) };
	// 824ADD98: 897F0008  lbz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824ADD9C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824ADDA0: 99630008  stb r11, 8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u8 ) };
	// 824ADDA4: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824ADDA8: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 824ADDAC: C01F0010  lfs f0, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824ADDB0: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824ADDB4: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 824ADDB8: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 824ADDBC: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 824ADDC0: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 824ADDC4: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 824ADDC8: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 824ADDCC: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 824ADDD0: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 824ADDD4: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 824ADDD8: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 824ADDDC: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 824ADDE0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824ADDE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824ADDE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824ADDEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824ADDF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824ADDF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824ADDF8 size=92
    let mut pc: u32 = 0x824ADDF8;
    'dispatch: loop {
        match pc {
            0x824ADDF8 => {
    //   block [0x824ADDF8..0x824ADE54)
	// 824ADDF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824ADDFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824ADE00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824ADE04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824ADE08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824ADE0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824ADE10: 549E103A  slwi r30, r4, 2
	ctx.r[30].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 824ADE14: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824ADE18: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824ADE1C: 4BFEDC35  bl 0x8249ba50
	ctx.lr = 0x824ADE20;
	sub_8249BA50(ctx, base);
	// 824ADE20: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824ADE24: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824ADE28: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 824ADE2C: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 824ADE30: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 824ADE34: 7D49582E  lwzx r10, r9, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824ADE38: 7D4BF12E  stwx r10, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[10].u32) };
	// 824ADE3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824ADE40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824ADE44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824ADE48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824ADE4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824ADE50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824ADE58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824ADE58 size=92
    let mut pc: u32 = 0x824ADE58;
    'dispatch: loop {
        match pc {
            0x824ADE58 => {
    //   block [0x824ADE58..0x824ADEB4)
	// 824ADE58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824ADE5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824ADE60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824ADE64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824ADE68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824ADE6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824ADE70: 549E103A  slwi r30, r4, 2
	ctx.r[30].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 824ADE74: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 824ADE78: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824ADE7C: 4BFEDBD5  bl 0x8249ba50
	ctx.lr = 0x824ADE80;
	sub_8249BA50(ctx, base);
	// 824ADE80: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 824ADE84: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 824ADE88: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 824ADE8C: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 824ADE90: 915F0030  stw r10, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 824ADE94: 7D49582E  lwzx r10, r9, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824ADE98: 7D4BF12E  stwx r10, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[10].u32) };
	// 824ADE9C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824ADEA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824ADEA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824ADEA8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824ADEAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824ADEB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824ADEB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824ADEB8 size=144
    let mut pc: u32 = 0x824ADEB8;
    'dispatch: loop {
        match pc {
            0x824ADEB8 => {
    //   block [0x824ADEB8..0x824ADF14)
	// 824ADEB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824ADEBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824ADEC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824ADEC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824ADEC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824ADECC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824ADED0: 549E103A  slwi r30, r4, 2
	ctx.r[30].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 824ADED4: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 824ADED8: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824ADEDC: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824ADEE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824ADEE4: 419A0030  beq cr6, 0x824adf14
	if ctx.cr[6].eq {
	pc = 0x824ADF14; continue 'dispatch;
	}
	// 824ADEE8: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 824ADEEC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824ADEF0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824ADEF4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824ADEF8: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824ADEFC: 409A0018  bne cr6, 0x824adf14
	if !ctx.cr[6].eq {
	pc = 0x824ADF14; continue 'dispatch;
	}
	// 824ADF00: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824ADF04: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824ADF08: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824ADF0C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824ADF10: 4E800421  bctrl
	ctx.lr = 0x824ADF14;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824ADF14 => {
    //   block [0x824ADF14..0x824ADF48)
	// 824ADF14: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 824ADF18: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 824ADF1C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 824ADF20: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 824ADF24: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 824ADF28: 7D49582E  lwzx r10, r9, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824ADF2C: 7D4BF12E  stwx r10, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[10].u32) };
	// 824ADF30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824ADF34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824ADF38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824ADF3C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824ADF40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824ADF44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824ADF48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824ADF48 size=144
    let mut pc: u32 = 0x824ADF48;
    'dispatch: loop {
        match pc {
            0x824ADF48 => {
    //   block [0x824ADF48..0x824ADFA4)
	// 824ADF48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824ADF4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824ADF50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824ADF54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824ADF58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824ADF5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824ADF60: 549E103A  slwi r30, r4, 2
	ctx.r[30].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 824ADF64: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 824ADF68: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824ADF6C: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824ADF70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824ADF74: 419A0030  beq cr6, 0x824adfa4
	if ctx.cr[6].eq {
	pc = 0x824ADFA4; continue 'dispatch;
	}
	// 824ADF78: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 824ADF7C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824ADF80: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824ADF84: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824ADF88: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824ADF8C: 409A0018  bne cr6, 0x824adfa4
	if !ctx.cr[6].eq {
	pc = 0x824ADFA4; continue 'dispatch;
	}
	// 824ADF90: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824ADF94: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824ADF98: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824ADF9C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824ADFA0: 4E800421  bctrl
	ctx.lr = 0x824ADFA4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824ADFA4 => {
    //   block [0x824ADFA4..0x824ADFD8)
	// 824ADFA4: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 824ADFA8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 824ADFAC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 824ADFB0: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 824ADFB4: 915F0024  stw r10, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 824ADFB8: 7D49582E  lwzx r10, r9, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824ADFBC: 7D4BF12E  stwx r10, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[10].u32) };
	// 824ADFC0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824ADFC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824ADFC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824ADFCC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824ADFD0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824ADFD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824ADFD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824ADFD8 size=92
    let mut pc: u32 = 0x824ADFD8;
    'dispatch: loop {
        match pc {
            0x824ADFD8 => {
    //   block [0x824ADFD8..0x824AE034)
	// 824ADFD8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824ADFDC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 824ADFE0: 392BF2F4  addi r9, r11, -0xd0c
	ctx.r[9].s64 = ctx.r[11].s64 + -3340;
	// 824ADFE4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824ADFE8: 3D408000  lis r10, -0x8000
	ctx.r[10].s64 = -2147483648;
	// 824ADFEC: B1030006  sth r8, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[8].u16 ) };
	// 824ADFF0: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824ADFF4: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 824ADFF8: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 824ADFFC: 91430010  stw r10, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 824AE000: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 824AE004: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 824AE008: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 824AE00C: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 824AE010: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 824AE014: 91430028  stw r10, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 824AE018: 9163002C  stw r11, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 824AE01C: 91630030  stw r11, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 824AE020: 91430034  stw r10, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	// 824AE024: 91630038  stw r11, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 824AE028: 9163003C  stw r11, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 824AE02C: 99030040  stb r8, 0x40(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[8].u8 ) };
	// 824AE030: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AE038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AE038 size=568
    let mut pc: u32 = 0x824AE038;
    'dispatch: loop {
        match pc {
            0x824AE038 => {
    //   block [0x824AE038..0x824AE068)
	// 824AE038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AE03C: 48087081  bl 0x825350bc
	ctx.lr = 0x824AE040;
	sub_82535080(ctx, base);
	// 824AE040: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AE044: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 824AE048: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 824AE04C: 394AF2F4  addi r10, r10, -0xd0c
	ctx.r[10].s64 = ctx.r[10].s64 + -3340;
	// 824AE050: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 824AE054: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824AE058: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824AE05C: 40990034  ble cr6, 0x824ae090
	if !ctx.cr[6].gt {
	pc = 0x824AE090; continue 'dispatch;
	}
	// 824AE060: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 824AE064: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	pc = 0x824AE068; continue 'dispatch;
            }
            0x824AE068 => {
    //   block [0x824AE068..0x824AE080)
	// 824AE068: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AE06C: 7D5F582E  lwzx r10, r31, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824AE070: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824AE074: 419A000C  beq cr6, 0x824ae080
	if ctx.cr[6].eq {
	pc = 0x824AE080; continue 'dispatch;
	}
	// 824AE078: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 824AE07C: 4BFED9D5  bl 0x8249ba50
	ctx.lr = 0x824AE080;
	sub_8249BA50(ctx, base);
	pc = 0x824AE080; continue 'dispatch;
            }
            0x824AE080 => {
    //   block [0x824AE080..0x824AE090)
	// 824AE080: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 824AE084: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 824AE088: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 824AE08C: 409AFFDC  bne cr6, 0x824ae068
	if !ctx.cr[6].eq {
	pc = 0x824AE068; continue 'dispatch;
	}
	pc = 0x824AE090; continue 'dispatch;
            }
            0x824AE090 => {
    //   block [0x824AE090..0x824AE0A4)
	// 824AE090: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 824AE094: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824AE098: 40990034  ble cr6, 0x824ae0cc
	if !ctx.cr[6].gt {
	pc = 0x824AE0CC; continue 'dispatch;
	}
	// 824AE09C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 824AE0A0: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	pc = 0x824AE0A4; continue 'dispatch;
            }
            0x824AE0A4 => {
    //   block [0x824AE0A4..0x824AE0BC)
	// 824AE0A4: 817D002C  lwz r11, 0x2c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 824AE0A8: 7D5F582E  lwzx r10, r31, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824AE0AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824AE0B0: 419A000C  beq cr6, 0x824ae0bc
	if ctx.cr[6].eq {
	pc = 0x824AE0BC; continue 'dispatch;
	}
	// 824AE0B4: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 824AE0B8: 4BFED999  bl 0x8249ba50
	ctx.lr = 0x824AE0BC;
	sub_8249BA50(ctx, base);
	pc = 0x824AE0BC; continue 'dispatch;
            }
            0x824AE0BC => {
    //   block [0x824AE0BC..0x824AE0CC)
	// 824AE0BC: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 824AE0C0: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 824AE0C4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 824AE0C8: 409AFFDC  bne cr6, 0x824ae0a4
	if !ctx.cr[6].eq {
	pc = 0x824AE0A4; continue 'dispatch;
	}
	pc = 0x824AE0CC; continue 'dispatch;
            }
            0x824AE0CC => {
    //   block [0x824AE0CC..0x824AE0E0)
	// 824AE0CC: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 824AE0D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824AE0D4: 40990068  ble cr6, 0x824ae13c
	if !ctx.cr[6].gt {
	pc = 0x824AE13C; continue 'dispatch;
	}
	// 824AE0D8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 824AE0DC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	pc = 0x824AE0E0; continue 'dispatch;
            }
            0x824AE0E0 => {
    //   block [0x824AE0E0..0x824AE12C)
	// 824AE0E0: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 824AE0E4: 7D5F582E  lwzx r10, r31, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824AE0E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824AE0EC: 419A0040  beq cr6, 0x824ae12c
	if ctx.cr[6].eq {
	pc = 0x824AE12C; continue 'dispatch;
	}
	// 824AE0F0: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 824AE0F4: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AE0F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824AE0FC: 419A0030  beq cr6, 0x824ae12c
	if ctx.cr[6].eq {
	pc = 0x824AE12C; continue 'dispatch;
	}
	// 824AE100: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 824AE104: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824AE108: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824AE10C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824AE110: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824AE114: 409A0018  bne cr6, 0x824ae12c
	if !ctx.cr[6].eq {
	pc = 0x824AE12C; continue 'dispatch;
	}
	// 824AE118: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE11C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824AE120: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE124: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AE128: 4E800421  bctrl
	ctx.lr = 0x824AE12C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824AE12C => {
    //   block [0x824AE12C..0x824AE13C)
	// 824AE12C: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 824AE130: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 824AE134: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 824AE138: 409AFFA8  bne cr6, 0x824ae0e0
	if !ctx.cr[6].eq {
	pc = 0x824AE0E0; continue 'dispatch;
	}
	pc = 0x824AE13C; continue 'dispatch;
            }
            0x824AE13C => {
    //   block [0x824AE13C..0x824AE150)
	// 824AE13C: 817D0024  lwz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 824AE140: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824AE144: 40990068  ble cr6, 0x824ae1ac
	if !ctx.cr[6].gt {
	pc = 0x824AE1AC; continue 'dispatch;
	}
	// 824AE148: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 824AE14C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	pc = 0x824AE150; continue 'dispatch;
            }
            0x824AE150 => {
    //   block [0x824AE150..0x824AE19C)
	// 824AE150: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 824AE154: 7D4BF82E  lwzx r10, r11, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 824AE158: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824AE15C: 419A0040  beq cr6, 0x824ae19c
	if ctx.cr[6].eq {
	pc = 0x824AE19C; continue 'dispatch;
	}
	// 824AE160: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 824AE164: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AE168: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824AE16C: 419A0030  beq cr6, 0x824ae19c
	if ctx.cr[6].eq {
	pc = 0x824AE19C; continue 'dispatch;
	}
	// 824AE170: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 824AE174: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824AE178: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824AE17C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824AE180: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824AE184: 409A0018  bne cr6, 0x824ae19c
	if !ctx.cr[6].eq {
	pc = 0x824AE19C; continue 'dispatch;
	}
	// 824AE188: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE18C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824AE190: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE194: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AE198: 4E800421  bctrl
	ctx.lr = 0x824AE19C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824AE19C => {
    //   block [0x824AE19C..0x824AE1AC)
	// 824AE19C: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 824AE1A0: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 824AE1A4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 824AE1A8: 409AFFA8  bne cr6, 0x824ae150
	if !ctx.cr[6].eq {
	pc = 0x824AE150; continue 'dispatch;
	}
	pc = 0x824AE1AC; continue 'dispatch;
            }
            0x824AE1AC => {
    //   block [0x824AE1AC..0x824AE1D8)
	// 824AE1AC: 817D0034  lwz r11, 0x34(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 824AE1B0: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824AE1B4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AE1B8: 409A0020  bne cr6, 0x824ae1d8
	if !ctx.cr[6].eq {
	pc = 0x824AE1D8; continue 'dispatch;
	}
	// 824AE1BC: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE1C0: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824AE1C4: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824AE1C8: 809D002C  lwz r4, 0x2c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 824AE1CC: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824AE1D0: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824AE1D4: 4BFB5EE5  bl 0x824640b8
	ctx.lr = 0x824AE1D8;
	sub_824640B8(ctx, base);
	pc = 0x824AE1D8; continue 'dispatch;
            }
            0x824AE1D8 => {
    //   block [0x824AE1D8..0x824AE204)
	// 824AE1D8: 817D0028  lwz r11, 0x28(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 824AE1DC: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824AE1E0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AE1E4: 409A0020  bne cr6, 0x824ae204
	if !ctx.cr[6].eq {
	pc = 0x824AE204; continue 'dispatch;
	}
	// 824AE1E8: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE1EC: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824AE1F0: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824AE1F4: 809D0020  lwz r4, 0x20(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 824AE1F8: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824AE1FC: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824AE200: 4BFB5EB9  bl 0x824640b8
	ctx.lr = 0x824AE204;
	sub_824640B8(ctx, base);
	pc = 0x824AE204; continue 'dispatch;
            }
            0x824AE204 => {
    //   block [0x824AE204..0x824AE230)
	// 824AE204: 817D001C  lwz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 824AE208: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824AE20C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AE210: 409A0020  bne cr6, 0x824ae230
	if !ctx.cr[6].eq {
	pc = 0x824AE230; continue 'dispatch;
	}
	// 824AE214: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE218: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824AE21C: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824AE220: 809D0014  lwz r4, 0x14(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 824AE224: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824AE228: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824AE22C: 4BFB5E8D  bl 0x824640b8
	ctx.lr = 0x824AE230;
	sub_824640B8(ctx, base);
	pc = 0x824AE230; continue 'dispatch;
            }
            0x824AE230 => {
    //   block [0x824AE230..0x824AE25C)
	// 824AE230: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 824AE234: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824AE238: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AE23C: 409A0020  bne cr6, 0x824ae25c
	if !ctx.cr[6].eq {
	pc = 0x824AE25C; continue 'dispatch;
	}
	// 824AE240: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE244: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824AE248: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824AE24C: 809D0008  lwz r4, 8(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AE250: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824AE254: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824AE258: 4BFB5E61  bl 0x824640b8
	ctx.lr = 0x824AE25C;
	sub_824640B8(ctx, base);
	pc = 0x824AE25C; continue 'dispatch;
            }
            0x824AE25C => {
    //   block [0x824AE25C..0x824AE270)
	// 824AE25C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824AE260: 396B6DD0  addi r11, r11, 0x6dd0
	ctx.r[11].s64 = ctx.r[11].s64 + 28112;
	// 824AE264: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824AE268: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824AE26C: 48086EA0  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AE270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AE270 size=740
    let mut pc: u32 = 0x824AE270;
    'dispatch: loop {
        match pc {
            0x824AE270 => {
    //   block [0x824AE270..0x824AE2C8)
	// 824AE270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AE274: 48086E45  bl 0x825350b8
	ctx.lr = 0x824AE278;
	sub_82535080(ctx, base);
	// 824AE278: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AE27C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 824AE280: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 824AE284: 3BFD0008  addi r31, r29, 8
	ctx.r[31].s64 = ctx.r[29].s64 + 8;
	// 824AE288: 3BDC0008  addi r30, r28, 8
	ctx.r[30].s64 = ctx.r[28].s64 + 8;
	// 824AE28C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AE290: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AE294: 556A00BE  clrlwi r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824AE298: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824AE29C: 40980060  bge cr6, 0x824ae2fc
	if !ctx.cr[6].lt {
	pc = 0x824AE2FC; continue 'dispatch;
	}
	// 824AE2A0: 556B0000  rlwinm r11, r11, 0, 0, 0
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824AE2A4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824AE2A8: 409A0020  bne cr6, 0x824ae2c8
	if !ctx.cr[6].eq {
	pc = 0x824AE2C8; continue 'dispatch;
	}
	// 824AE2AC: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE2B0: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824AE2B4: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824AE2B8: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE2BC: 5545103A  slwi r5, r10, 2
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824AE2C0: 7C69582E  lwzx r3, r9, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824AE2C4: 4BFB5DF5  bl 0x824640b8
	ctx.lr = 0x824AE2C8;
	sub_824640B8(ctx, base);
	pc = 0x824AE2C8; continue 'dispatch;
            }
            0x824AE2C8 => {
    //   block [0x824AE2C8..0x824AE2FC)
	// 824AE2C8: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE2CC: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 824AE2D0: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AE2D4: 38A00017  li r5, 0x17
	ctx.r[5].s64 = 23;
	// 824AE2D8: 5524103A  slwi r4, r9, 2
	ctx.r[4].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 824AE2DC: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824AE2E0: 4BFB5D59  bl 0x82464038
	ctx.lr = 0x824AE2E4;
	sub_82464038(ctx, base);
	// 824AE2E4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AE2E8: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 824AE2EC: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AE2F0: 556B0042  rlwinm r11, r11, 0, 1, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824AE2F4: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 824AE2F8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x824AE2FC; continue 'dispatch;
            }
            0x824AE2FC => {
    //   block [0x824AE2FC..0x824AE318)
	// 824AE2FC: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AE300: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE304: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AE308: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 824AE30C: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE310: 40990020  ble cr6, 0x824ae330
	if !ctx.cr[6].gt {
	pc = 0x824AE330; continue 'dispatch;
	}
	// 824AE314: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	pc = 0x824AE318; continue 'dispatch;
            }
            0x824AE318 => {
    //   block [0x824AE318..0x824AE330)
	// 824AE318: 7D09582E  lwzx r8, r9, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824AE31C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 824AE320: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824AE324: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 824AE328: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824AE32C: 409AFFEC  bne cr6, 0x824ae318
	if !ctx.cr[6].eq {
	pc = 0x824AE318; continue 'dispatch;
	}
	pc = 0x824AE330; continue 'dispatch;
            }
            0x824AE330 => {
    //   block [0x824AE330..0x824AE374)
	// 824AE330: 3BFD002C  addi r31, r29, 0x2c
	ctx.r[31].s64 = ctx.r[29].s64 + 44;
	// 824AE334: 3BDC002C  addi r30, r28, 0x2c
	ctx.r[30].s64 = ctx.r[28].s64 + 44;
	// 824AE338: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AE33C: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AE340: 556A00BE  clrlwi r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824AE344: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824AE348: 40980060  bge cr6, 0x824ae3a8
	if !ctx.cr[6].lt {
	pc = 0x824AE3A8; continue 'dispatch;
	}
	// 824AE34C: 556B0000  rlwinm r11, r11, 0, 0, 0
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824AE350: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824AE354: 409A0020  bne cr6, 0x824ae374
	if !ctx.cr[6].eq {
	pc = 0x824AE374; continue 'dispatch;
	}
	// 824AE358: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE35C: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824AE360: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824AE364: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE368: 5545103A  slwi r5, r10, 2
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824AE36C: 7C69582E  lwzx r3, r9, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824AE370: 4BFB5D49  bl 0x824640b8
	ctx.lr = 0x824AE374;
	sub_824640B8(ctx, base);
	pc = 0x824AE374; continue 'dispatch;
            }
            0x824AE374 => {
    //   block [0x824AE374..0x824AE3A8)
	// 824AE374: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE378: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 824AE37C: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AE380: 38A00017  li r5, 0x17
	ctx.r[5].s64 = 23;
	// 824AE384: 5524103A  slwi r4, r9, 2
	ctx.r[4].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 824AE388: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824AE38C: 4BFB5CAD  bl 0x82464038
	ctx.lr = 0x824AE390;
	sub_82464038(ctx, base);
	// 824AE390: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AE394: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 824AE398: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AE39C: 556B0042  rlwinm r11, r11, 0, 1, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824AE3A0: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 824AE3A4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x824AE3A8; continue 'dispatch;
            }
            0x824AE3A8 => {
    //   block [0x824AE3A8..0x824AE3C4)
	// 824AE3A8: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AE3AC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE3B0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AE3B4: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 824AE3B8: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE3BC: 40990020  ble cr6, 0x824ae3dc
	if !ctx.cr[6].gt {
	pc = 0x824AE3DC; continue 'dispatch;
	}
	// 824AE3C0: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	pc = 0x824AE3C4; continue 'dispatch;
            }
            0x824AE3C4 => {
    //   block [0x824AE3C4..0x824AE3DC)
	// 824AE3C4: 7D09582E  lwzx r8, r9, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824AE3C8: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 824AE3CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824AE3D0: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 824AE3D4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824AE3D8: 409AFFEC  bne cr6, 0x824ae3c4
	if !ctx.cr[6].eq {
	pc = 0x824AE3C4; continue 'dispatch;
	}
	pc = 0x824AE3DC; continue 'dispatch;
            }
            0x824AE3DC => {
    //   block [0x824AE3DC..0x824AE420)
	// 824AE3DC: 3BFD0014  addi r31, r29, 0x14
	ctx.r[31].s64 = ctx.r[29].s64 + 20;
	// 824AE3E0: 3BDC0014  addi r30, r28, 0x14
	ctx.r[30].s64 = ctx.r[28].s64 + 20;
	// 824AE3E4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AE3E8: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AE3EC: 556A00BE  clrlwi r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824AE3F0: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824AE3F4: 40980060  bge cr6, 0x824ae454
	if !ctx.cr[6].lt {
	pc = 0x824AE454; continue 'dispatch;
	}
	// 824AE3F8: 556B0000  rlwinm r11, r11, 0, 0, 0
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824AE3FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824AE400: 409A0020  bne cr6, 0x824ae420
	if !ctx.cr[6].eq {
	pc = 0x824AE420; continue 'dispatch;
	}
	// 824AE404: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE408: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824AE40C: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824AE410: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE414: 5545103A  slwi r5, r10, 2
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824AE418: 7C69582E  lwzx r3, r9, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824AE41C: 4BFB5C9D  bl 0x824640b8
	ctx.lr = 0x824AE420;
	sub_824640B8(ctx, base);
	pc = 0x824AE420; continue 'dispatch;
            }
            0x824AE420 => {
    //   block [0x824AE420..0x824AE454)
	// 824AE420: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE424: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 824AE428: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AE42C: 38A00017  li r5, 0x17
	ctx.r[5].s64 = 23;
	// 824AE430: 5524103A  slwi r4, r9, 2
	ctx.r[4].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 824AE434: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824AE438: 4BFB5C01  bl 0x82464038
	ctx.lr = 0x824AE43C;
	sub_82464038(ctx, base);
	// 824AE43C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AE440: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 824AE444: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AE448: 556B0042  rlwinm r11, r11, 0, 1, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824AE44C: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 824AE450: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x824AE454; continue 'dispatch;
            }
            0x824AE454 => {
    //   block [0x824AE454..0x824AE470)
	// 824AE454: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AE458: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE45C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AE460: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 824AE464: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE468: 40990020  ble cr6, 0x824ae488
	if !ctx.cr[6].gt {
	pc = 0x824AE488; continue 'dispatch;
	}
	// 824AE46C: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	pc = 0x824AE470; continue 'dispatch;
            }
            0x824AE470 => {
    //   block [0x824AE470..0x824AE488)
	// 824AE470: 7D09582E  lwzx r8, r9, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824AE474: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 824AE478: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824AE47C: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 824AE480: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824AE484: 409AFFEC  bne cr6, 0x824ae470
	if !ctx.cr[6].eq {
	pc = 0x824AE470; continue 'dispatch;
	}
	pc = 0x824AE488; continue 'dispatch;
            }
            0x824AE488 => {
    //   block [0x824AE488..0x824AE4CC)
	// 824AE488: 3BFD0020  addi r31, r29, 0x20
	ctx.r[31].s64 = ctx.r[29].s64 + 32;
	// 824AE48C: 3BDC0020  addi r30, r28, 0x20
	ctx.r[30].s64 = ctx.r[28].s64 + 32;
	// 824AE490: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AE494: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AE498: 556A00BE  clrlwi r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824AE49C: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824AE4A0: 40980060  bge cr6, 0x824ae500
	if !ctx.cr[6].lt {
	pc = 0x824AE500; continue 'dispatch;
	}
	// 824AE4A4: 556B0000  rlwinm r11, r11, 0, 0, 0
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824AE4A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824AE4AC: 409A0020  bne cr6, 0x824ae4cc
	if !ctx.cr[6].eq {
	pc = 0x824AE4CC; continue 'dispatch;
	}
	// 824AE4B0: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE4B4: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824AE4B8: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824AE4BC: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE4C0: 5545103A  slwi r5, r10, 2
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824AE4C4: 7C69582E  lwzx r3, r9, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824AE4C8: 4BFB5BF1  bl 0x824640b8
	ctx.lr = 0x824AE4CC;
	sub_824640B8(ctx, base);
	pc = 0x824AE4CC; continue 'dispatch;
            }
            0x824AE4CC => {
    //   block [0x824AE4CC..0x824AE500)
	// 824AE4CC: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE4D0: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 824AE4D4: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AE4D8: 38A00017  li r5, 0x17
	ctx.r[5].s64 = 23;
	// 824AE4DC: 5524103A  slwi r4, r9, 2
	ctx.r[4].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 824AE4E0: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824AE4E4: 4BFB5B55  bl 0x82464038
	ctx.lr = 0x824AE4E8;
	sub_82464038(ctx, base);
	// 824AE4E8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AE4EC: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 824AE4F0: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AE4F4: 556B0042  rlwinm r11, r11, 0, 1, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824AE4F8: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 824AE4FC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x824AE500; continue 'dispatch;
            }
            0x824AE500 => {
    //   block [0x824AE500..0x824AE51C)
	// 824AE500: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AE504: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE508: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AE50C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 824AE510: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE514: 40990020  ble cr6, 0x824ae534
	if !ctx.cr[6].gt {
	pc = 0x824AE534; continue 'dispatch;
	}
	// 824AE518: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	pc = 0x824AE51C; continue 'dispatch;
            }
            0x824AE51C => {
    //   block [0x824AE51C..0x824AE534)
	// 824AE51C: 7D09582E  lwzx r8, r9, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824AE520: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 824AE524: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824AE528: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 824AE52C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824AE530: 409AFFEC  bne cr6, 0x824ae51c
	if !ctx.cr[6].eq {
	pc = 0x824AE51C; continue 'dispatch;
	}
	pc = 0x824AE534; continue 'dispatch;
            }
            0x824AE534 => {
    //   block [0x824AE534..0x824AE554)
	// 824AE534: 817C0038  lwz r11, 0x38(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) } as u64;
	// 824AE538: 917D0038  stw r11, 0x38(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 824AE53C: 817C003C  lwz r11, 0x3c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(60 as u32) ) } as u64;
	// 824AE540: 917D003C  stw r11, 0x3c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 824AE544: 897C0040  lbz r11, 0x40(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) } as u64;
	// 824AE548: 997D0040  stb r11, 0x40(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(64 as u32), ctx.r[11].u8 ) };
	// 824AE54C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 824AE550: 48086BB8  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AE558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AE558 size=132
    let mut pc: u32 = 0x824AE558;
    'dispatch: loop {
        match pc {
            0x824AE558 => {
    //   block [0x824AE558..0x824AE5A8)
	// 824AE558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AE55C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AE560: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824AE564: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AE568: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AE56C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 824AE570: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824AE574: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 824AE578: 419A004C  beq cr6, 0x824ae5c4
	if ctx.cr[6].eq {
	pc = 0x824AE5C4; continue 'dispatch;
	}
	// 824AE57C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824AE580: 4BFED4B1  bl 0x8249ba30
	ctx.lr = 0x824AE584;
	sub_8249BA30(ctx, base);
	// 824AE584: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 824AE588: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AE58C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AE590: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824AE594: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824AE598: 409A0010  bne cr6, 0x824ae5a8
	if !ctx.cr[6].eq {
	pc = 0x824AE5A8; continue 'dispatch;
	}
	// 824AE59C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 824AE5A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AE5A4: 4BFBFDAD  bl 0x8246e350
	ctx.lr = 0x824AE5A8;
	sub_8246E350(ctx, base);
	pc = 0x824AE5A8; continue 'dispatch;
            }
            0x824AE5A8 => {
    //   block [0x824AE5A8..0x824AE5C4)
	// 824AE5A8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AE5AC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE5B0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824AE5B4: 7FCB512E  stwx r30, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[30].u32) };
	// 824AE5B8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AE5BC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824AE5C0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x824AE5C4; continue 'dispatch;
            }
            0x824AE5C4 => {
    //   block [0x824AE5C4..0x824AE5DC)
	// 824AE5C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824AE5C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824AE5CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824AE5D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824AE5D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824AE5D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AE5E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AE5E0 size=132
    let mut pc: u32 = 0x824AE5E0;
    'dispatch: loop {
        match pc {
            0x824AE5E0 => {
    //   block [0x824AE5E0..0x824AE630)
	// 824AE5E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AE5E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AE5E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824AE5EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AE5F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AE5F4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 824AE5F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824AE5FC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 824AE600: 419A004C  beq cr6, 0x824ae64c
	if ctx.cr[6].eq {
	pc = 0x824AE64C; continue 'dispatch;
	}
	// 824AE604: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824AE608: 4BFED429  bl 0x8249ba30
	ctx.lr = 0x824AE60C;
	sub_8249BA30(ctx, base);
	// 824AE60C: 3BFF002C  addi r31, r31, 0x2c
	ctx.r[31].s64 = ctx.r[31].s64 + 44;
	// 824AE610: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AE614: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AE618: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824AE61C: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824AE620: 409A0010  bne cr6, 0x824ae630
	if !ctx.cr[6].eq {
	pc = 0x824AE630; continue 'dispatch;
	}
	// 824AE624: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 824AE628: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AE62C: 4BFBFD25  bl 0x8246e350
	ctx.lr = 0x824AE630;
	sub_8246E350(ctx, base);
	pc = 0x824AE630; continue 'dispatch;
            }
            0x824AE630 => {
    //   block [0x824AE630..0x824AE64C)
	// 824AE630: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AE634: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE638: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824AE63C: 7FCB512E  stwx r30, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[30].u32) };
	// 824AE640: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AE644: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824AE648: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x824AE64C; continue 'dispatch;
            }
            0x824AE64C => {
    //   block [0x824AE64C..0x824AE664)
	// 824AE64C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824AE650: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824AE654: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824AE658: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824AE65C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824AE660: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AE668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AE668 size=144
    let mut pc: u32 = 0x824AE668;
    'dispatch: loop {
        match pc {
            0x824AE668 => {
    //   block [0x824AE668..0x824AE6A0)
	// 824AE668: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AE66C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AE670: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824AE674: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AE678: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AE67C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 824AE680: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 824AE684: 419A005C  beq cr6, 0x824ae6e0
	if ctx.cr[6].eq {
	pc = 0x824AE6E0; continue 'dispatch;
	}
	// 824AE688: A17E0004  lhz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AE68C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824AE690: 419A0010  beq cr6, 0x824ae6a0
	if ctx.cr[6].eq {
	pc = 0x824AE6A0; continue 'dispatch;
	}
	// 824AE694: A17E0006  lhz r11, 6(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) } as u64;
	// 824AE698: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824AE69C: B17E0006  sth r11, 6(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	pc = 0x824AE6A0; continue 'dispatch;
            }
            0x824AE6A0 => {
    //   block [0x824AE6A0..0x824AE6C4)
	// 824AE6A0: 3BE30014  addi r31, r3, 0x14
	ctx.r[31].s64 = ctx.r[3].s64 + 20;
	// 824AE6A4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AE6A8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AE6AC: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824AE6B0: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824AE6B4: 409A0010  bne cr6, 0x824ae6c4
	if !ctx.cr[6].eq {
	pc = 0x824AE6C4; continue 'dispatch;
	}
	// 824AE6B8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 824AE6BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AE6C0: 4BFBFC91  bl 0x8246e350
	ctx.lr = 0x824AE6C4;
	sub_8246E350(ctx, base);
	pc = 0x824AE6C4; continue 'dispatch;
            }
            0x824AE6C4 => {
    //   block [0x824AE6C4..0x824AE6E0)
	// 824AE6C4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AE6C8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE6CC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824AE6D0: 7FCB512E  stwx r30, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[30].u32) };
	// 824AE6D4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AE6D8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824AE6DC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x824AE6E0; continue 'dispatch;
            }
            0x824AE6E0 => {
    //   block [0x824AE6E0..0x824AE6F8)
	// 824AE6E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824AE6E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824AE6E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824AE6EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824AE6F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824AE6F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AE6F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AE6F8 size=144
    let mut pc: u32 = 0x824AE6F8;
    'dispatch: loop {
        match pc {
            0x824AE6F8 => {
    //   block [0x824AE6F8..0x824AE730)
	// 824AE6F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AE6FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AE700: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824AE704: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AE708: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AE70C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 824AE710: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 824AE714: 419A005C  beq cr6, 0x824ae770
	if ctx.cr[6].eq {
	pc = 0x824AE770; continue 'dispatch;
	}
	// 824AE718: A17E0004  lhz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AE71C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824AE720: 419A0010  beq cr6, 0x824ae730
	if ctx.cr[6].eq {
	pc = 0x824AE730; continue 'dispatch;
	}
	// 824AE724: A17E0006  lhz r11, 6(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) } as u64;
	// 824AE728: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824AE72C: B17E0006  sth r11, 6(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	pc = 0x824AE730; continue 'dispatch;
            }
            0x824AE730 => {
    //   block [0x824AE730..0x824AE754)
	// 824AE730: 3BE30020  addi r31, r3, 0x20
	ctx.r[31].s64 = ctx.r[3].s64 + 32;
	// 824AE734: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AE738: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AE73C: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824AE740: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824AE744: 409A0010  bne cr6, 0x824ae754
	if !ctx.cr[6].eq {
	pc = 0x824AE754; continue 'dispatch;
	}
	// 824AE748: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 824AE74C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824AE750: 4BFBFC01  bl 0x8246e350
	ctx.lr = 0x824AE754;
	sub_8246E350(ctx, base);
	pc = 0x824AE754; continue 'dispatch;
            }
            0x824AE754 => {
    //   block [0x824AE754..0x824AE770)
	// 824AE754: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AE758: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE75C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824AE760: 7FCB512E  stwx r30, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[30].u32) };
	// 824AE764: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AE768: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824AE76C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x824AE770; continue 'dispatch;
            }
            0x824AE770 => {
    //   block [0x824AE770..0x824AE788)
	// 824AE770: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824AE774: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824AE778: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824AE77C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824AE780: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824AE784: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AE788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AE788 size=1440
    let mut pc: u32 = 0x824AE788;
    'dispatch: loop {
        match pc {
            0x824AE788 => {
    //   block [0x824AE788..0x824AE860)
	// 824AE788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AE78C: 48086909  bl 0x82535094
	ctx.lr = 0x824AE790;
	sub_82535080(ctx, base);
	// 824AE790: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AE794: 826D0000  lwz r19, 0(r13)
	ctx.r[19].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE798: 3A800010  li r20, 0x10
	ctx.r[20].s64 = 16;
	// 824AE79C: 38A0002F  li r5, 0x2f
	ctx.r[5].s64 = 47;
	// 824AE7A0: 38800044  li r4, 0x44
	ctx.r[4].s64 = 68;
	// 824AE7A4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 824AE7A8: 7C74982E  lwzx r3, r20, r19
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[20].u32.wrapping_add(ctx.r[19].u32)) } as u64;
	// 824AE7AC: 4BFB588D  bl 0x82464038
	ctx.lr = 0x824AE7B0;
	sub_82464038(ctx, base);
	// 824AE7B0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824AE7B4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 824AE7B8: 396BF2F4  addi r11, r11, -0xd0c
	ctx.r[11].s64 = ctx.r[11].s64 + -3340;
	// 824AE7BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 824AE7C0: 39200044  li r9, 0x44
	ctx.r[9].s64 = 68;
	// 824AE7C4: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 824AE7C8: 3EC08000  lis r22, -0x8000
	ctx.r[22].s64 = -2147483648;
	// 824AE7CC: 3B190008  addi r24, r25, 8
	ctx.r[24].s64 = ctx.r[25].s64 + 8;
	// 824AE7D0: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824AE7D4: 3B990014  addi r28, r25, 0x14
	ctx.r[28].s64 = ctx.r[25].s64 + 20;
	// 824AE7D8: B1590006  sth r10, 6(r25)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[25].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 824AE7DC: 3AB90020  addi r21, r25, 0x20
	ctx.r[21].s64 = ctx.r[25].s64 + 32;
	// 824AE7E0: B1390004  sth r9, 4(r25)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[9].u16 ) };
	// 824AE7E4: 3AF9002C  addi r23, r25, 0x2c
	ctx.r[23].s64 = ctx.r[25].s64 + 44;
	// 824AE7E8: 93580000  stw r26, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 824AE7EC: 93580004  stw r26, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 824AE7F0: 92D80008  stw r22, 8(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(8 as u32), ctx.r[22].u32 ) };
	// 824AE7F4: 935C0000  stw r26, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 824AE7F8: 935C0004  stw r26, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 824AE7FC: 92DC0008  stw r22, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[22].u32 ) };
	// 824AE800: 93550000  stw r26, 0(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 824AE804: 93550004  stw r26, 4(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 824AE808: 92D50008  stw r22, 8(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(8 as u32), ctx.r[22].u32 ) };
	// 824AE80C: 93570000  stw r26, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 824AE810: 93570004  stw r26, 4(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 824AE814: 92D70008  stw r22, 8(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(8 as u32), ctx.r[22].u32 ) };
	// 824AE818: 93590038  stw r26, 0x38(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(56 as u32), ctx.r[26].u32 ) };
	// 824AE81C: 9359003C  stw r26, 0x3c(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(60 as u32), ctx.r[26].u32 ) };
	// 824AE820: 99590040  stb r10, 0x40(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(64 as u32), ctx.r[10].u8 ) };
	// 824AE824: 817B0038  lwz r11, 0x38(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(56 as u32) ) } as u64;
	// 824AE828: 91790038  stw r11, 0x38(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 824AE82C: 817B003C  lwz r11, 0x3c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(60 as u32) ) } as u64;
	// 824AE830: 9179003C  stw r11, 0x3c(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 824AE834: 897B0040  lbz r11, 0x40(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(64 as u32) ) } as u64;
	// 824AE838: 99790040  stb r11, 0x40(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(64 as u32), ctx.r[11].u8 ) };
	// 824AE83C: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AE840: 83FB000C  lwz r31, 0xc(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 824AE844: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824AE848: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 824AE84C: 40980024  bge cr6, 0x824ae870
	if !ctx.cr[6].lt {
	pc = 0x824AE870; continue 'dispatch;
	}
	// 824AE850: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824AE854: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824AE858: 41980008  blt cr6, 0x824ae860
	if ctx.cr[6].lt {
	pc = 0x824AE860; continue 'dispatch;
	}
	// 824AE85C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x824AE860; continue 'dispatch;
            }
            0x824AE860 => {
    //   block [0x824AE860..0x824AE870)
	// 824AE860: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 824AE864: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 824AE868: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 824AE86C: 4BFBFA5D  bl 0x8246e2c8
	ctx.lr = 0x824AE870;
	sub_8246E2C8(ctx, base);
	pc = 0x824AE870; continue 'dispatch;
            }
            0x824AE870 => {
    //   block [0x824AE870..0x824AE898)
	// 824AE870: 93F80004  stw r31, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 824AE874: 81770008  lwz r11, 8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AE878: 83FB0030  lwz r31, 0x30(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(48 as u32) ) } as u64;
	// 824AE87C: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824AE880: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 824AE884: 40980024  bge cr6, 0x824ae8a8
	if !ctx.cr[6].lt {
	pc = 0x824AE8A8; continue 'dispatch;
	}
	// 824AE888: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824AE88C: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824AE890: 41980008  blt cr6, 0x824ae898
	if ctx.cr[6].lt {
	pc = 0x824AE898; continue 'dispatch;
	}
	// 824AE894: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x824AE898; continue 'dispatch;
            }
            0x824AE898 => {
    //   block [0x824AE898..0x824AE8A8)
	// 824AE898: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 824AE89C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 824AE8A0: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 824AE8A4: 4BFBFA25  bl 0x8246e2c8
	ctx.lr = 0x824AE8A8;
	sub_8246E2C8(ctx, base);
	pc = 0x824AE8A8; continue 'dispatch;
            }
            0x824AE8A8 => {
    //   block [0x824AE8A8..0x824AE8D0)
	// 824AE8A8: 93F70004  stw r31, 4(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 824AE8AC: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AE8B0: 83FB0018  lwz r31, 0x18(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 824AE8B4: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824AE8B8: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 824AE8BC: 40980024  bge cr6, 0x824ae8e0
	if !ctx.cr[6].lt {
	pc = 0x824AE8E0; continue 'dispatch;
	}
	// 824AE8C0: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824AE8C4: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824AE8C8: 41980008  blt cr6, 0x824ae8d0
	if ctx.cr[6].lt {
	pc = 0x824AE8D0; continue 'dispatch;
	}
	// 824AE8CC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x824AE8D0; continue 'dispatch;
            }
            0x824AE8D0 => {
    //   block [0x824AE8D0..0x824AE8E0)
	// 824AE8D0: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 824AE8D4: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 824AE8D8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824AE8DC: 4BFBF9ED  bl 0x8246e2c8
	ctx.lr = 0x824AE8E0;
	sub_8246E2C8(ctx, base);
	pc = 0x824AE8E0; continue 'dispatch;
            }
            0x824AE8E0 => {
    //   block [0x824AE8E0..0x824AE908)
	// 824AE8E0: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 824AE8E4: 81750008  lwz r11, 8(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AE8E8: 83FB0024  lwz r31, 0x24(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(36 as u32) ) } as u64;
	// 824AE8EC: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824AE8F0: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 824AE8F4: 40980024  bge cr6, 0x824ae918
	if !ctx.cr[6].lt {
	pc = 0x824AE918; continue 'dispatch;
	}
	// 824AE8F8: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824AE8FC: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824AE900: 41980008  blt cr6, 0x824ae908
	if ctx.cr[6].lt {
	pc = 0x824AE908; continue 'dispatch;
	}
	// 824AE904: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x824AE908; continue 'dispatch;
            }
            0x824AE908 => {
    //   block [0x824AE908..0x824AE918)
	// 824AE908: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 824AE90C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 824AE910: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 824AE914: 4BFBF9B5  bl 0x8246e2c8
	ctx.lr = 0x824AE918;
	sub_8246E2C8(ctx, base);
	pc = 0x824AE918; continue 'dispatch;
            }
            0x824AE918 => {
    //   block [0x824AE918..0x824AE930)
	// 824AE918: 93F50004  stw r31, 4(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 824AE91C: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 824AE920: 817B000C  lwz r11, 0xc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 824AE924: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824AE928: 40990040  ble cr6, 0x824ae968
	if !ctx.cr[6].gt {
	pc = 0x824AE968; continue 'dispatch;
	}
	// 824AE92C: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	pc = 0x824AE930; continue 'dispatch;
            }
            0x824AE930 => {
    //   block [0x824AE930..0x824AE968)
	// 824AE930: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AE934: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE938: 7FABFA14  add r29, r11, r31
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 824AE93C: 7C6AF82E  lwzx r3, r10, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 824AE940: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE944: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824AE948: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AE94C: 4E800421  bctrl
	ctx.lr = 0x824AE950;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824AE950: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 824AE954: 817B000C  lwz r11, 0xc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 824AE958: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 824AE95C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 824AE960: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824AE964: 4198FFCC  blt cr6, 0x824ae930
	if ctx.cr[6].lt {
	pc = 0x824AE930; continue 'dispatch;
	}
            }
            0x824AE968 => {
    //   block [0x824AE968..0x824AE97C)
	// 824AE968: 817B0030  lwz r11, 0x30(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(48 as u32) ) } as u64;
	// 824AE96C: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 824AE970: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824AE974: 40990040  ble cr6, 0x824ae9b4
	if !ctx.cr[6].gt {
	pc = 0x824AE9B4; continue 'dispatch;
	}
	// 824AE978: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	pc = 0x824AE97C; continue 'dispatch;
            }
            0x824AE97C => {
    //   block [0x824AE97C..0x824AE9B4)
	// 824AE97C: 815B002C  lwz r10, 0x2c(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(44 as u32) ) } as u64;
	// 824AE980: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE984: 7FBF5A14  add r29, r31, r11
	ctx.r[29].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 824AE988: 7C6AF82E  lwzx r3, r10, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 824AE98C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE990: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 824AE994: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AE998: 4E800421  bctrl
	ctx.lr = 0x824AE99C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824AE99C: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 824AE9A0: 817B0030  lwz r11, 0x30(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(48 as u32) ) } as u64;
	// 824AE9A4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 824AE9A8: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 824AE9AC: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824AE9B0: 4198FFCC  blt cr6, 0x824ae97c
	if ctx.cr[6].lt {
	pc = 0x824AE97C; continue 'dispatch;
	}
            }
            0x824AE9B4 => {
    //   block [0x824AE9B4..0x824AE9C8)
	// 824AE9B4: 817B0018  lwz r11, 0x18(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 824AE9B8: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 824AE9BC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824AE9C0: 409900BC  ble cr6, 0x824aea7c
	if !ctx.cr[6].gt {
	pc = 0x824AEA7C; continue 'dispatch;
	}
	// 824AE9C4: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	pc = 0x824AE9C8; continue 'dispatch;
            }
            0x824AE9C8 => {
    //   block [0x824AE9C8..0x824AE9E8)
	// 824AE9C8: 815B0014  lwz r10, 0x14(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 824AE9CC: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 824AE9D0: 813B000C  lwz r9, 0xc(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 824AE9D4: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 824AE9D8: 7C7E502E  lwzx r3, r30, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824AE9DC: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 824AE9E0: 40990024  ble cr6, 0x824aea04
	if !ctx.cr[6].gt {
	pc = 0x824AEA04; continue 'dispatch;
	}
	// 824AE9E4: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x824AE9E8; continue 'dispatch;
            }
            0x824AE9E8 => {
    //   block [0x824AE9E8..0x824AEA04)
	// 824AE9E8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AE9EC: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 824AE9F0: 419A00BC  beq cr6, 0x824aeaac
	if ctx.cr[6].eq {
	pc = 0x824AEAAC; continue 'dispatch;
	}
	// 824AE9F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824AE9F8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 824AE9FC: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824AEA00: 4198FFE8  blt cr6, 0x824ae9e8
	if ctx.cr[6].lt {
	pc = 0x824AE9E8; continue 'dispatch;
	}
	pc = 0x824AEA04; continue 'dispatch;
            }
            0x824AEA04 => {
    //   block [0x824AEA04..0x824AEA08)
	// 824AEA04: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	pc = 0x824AEA08; continue 'dispatch;
            }
            0x824AEA08 => {
    //   block [0x824AEA08..0x824AEA20)
	// 824AEA08: 813B000C  lwz r9, 0xc(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 824AEA0C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 824AEA10: 81030018  lwz r8, 0x18(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 824AEA14: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 824AEA18: 40990024  ble cr6, 0x824aea3c
	if !ctx.cr[6].gt {
	pc = 0x824AEA3C; continue 'dispatch;
	}
	// 824AEA1C: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x824AEA20; continue 'dispatch;
            }
            0x824AEA20 => {
    //   block [0x824AEA20..0x824AEA3C)
	// 824AEA20: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AEA24: 7F064040  cmplw cr6, r6, r8
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[8].u32, &mut ctx.xer);
	// 824AEA28: 419A008C  beq cr6, 0x824aeab4
	if ctx.cr[6].eq {
	pc = 0x824AEAB4; continue 'dispatch;
	}
	// 824AEA2C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824AEA30: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 824AEA34: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824AEA38: 4198FFE8  blt cr6, 0x824aea20
	if ctx.cr[6].lt {
	pc = 0x824AEA20; continue 'dispatch;
	}
	pc = 0x824AEA3C; continue 'dispatch;
            }
            0x824AEA3C => {
    //   block [0x824AEA3C..0x824AEA40)
	// 824AEA3C: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	pc = 0x824AEA40; continue 'dispatch;
            }
            0x824AEA40 => {
    //   block [0x824AEA40..0x824AEA7C)
	// 824AEA40: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AEA44: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 824AEA48: 54E9103A  slwi r9, r7, 2
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 824AEA4C: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AEA50: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 824AEA54: 7FEAF214  add r31, r10, r30
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 824AEA58: 7CA8582E  lwzx r5, r8, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824AEA5C: 7C89582E  lwzx r4, r9, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824AEA60: 4BFE3781  bl 0x824921e0
	ctx.lr = 0x824AEA64;
	sub_824921E0(ctx, base);
	// 824AEA64: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 824AEA68: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 824AEA6C: 817B0018  lwz r11, 0x18(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 824AEA70: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 824AEA74: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824AEA78: 4198FF50  blt cr6, 0x824ae9c8
	if ctx.cr[6].lt {
	pc = 0x824AE9C8; continue 'dispatch;
	}
	pc = 0x824AEA7C; continue 'dispatch;
            }
            0x824AEA7C => {
    //   block [0x824AEA7C..0x824AEA90)
	// 824AEA7C: 817B0024  lwz r11, 0x24(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(36 as u32) ) } as u64;
	// 824AEA80: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 824AEA84: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824AEA88: 40990294  ble cr6, 0x824aed1c
	if !ctx.cr[6].gt {
	pc = 0x824AED1C; continue 'dispatch;
	}
	// 824AEA8C: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	pc = 0x824AEA90; continue 'dispatch;
            }
            0x824AEA90 => {
    //   block [0x824AEA90..0x824AEAAC)
	// 824AEA90: 817B0020  lwz r11, 0x20(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 824AEA94: 7FDD582E  lwzx r30, r29, r11
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824AEA98: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 824AEA9C: 409A0020  bne cr6, 0x824aeabc
	if !ctx.cr[6].eq {
	pc = 0x824AEABC; continue 'dispatch;
	}
	// 824AEAA0: 81750000  lwz r11, 0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AEAA4: 7F5D592E  stwx r26, r29, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32), ctx.r[26].u32) };
	// 824AEAA8: 48000260  b 0x824aed08
	pc = 0x824AED08; continue 'dispatch;
            }
            0x824AEAAC => {
    //   block [0x824AEAAC..0x824AEAB4)
	// 824AEAAC: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 824AEAB0: 4BFFFF58  b 0x824aea08
	pc = 0x824AEA08; continue 'dispatch;
            }
            0x824AEAB4 => {
    //   block [0x824AEAB4..0x824AEABC)
	// 824AEAB4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 824AEAB8: 4BFFFF88  b 0x824aea40
	pc = 0x824AEA40; continue 'dispatch;
            }
            0x824AEABC => {
    //   block [0x824AEABC..0x824AEB04)
	// 824AEABC: 93410080  stw r26, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[26].u32 ) };
	// 824AEAC0: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 824AEAC4: 93410084  stw r26, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[26].u32 ) };
	// 824AEAC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824AEACC: 92C10088  stw r22, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[22].u32 ) };
	// 824AEAD0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AEAD4: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824AEAD8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AEADC: 4E800421  bctrl
	ctx.lr = 0x824AEAE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824AEAE0: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 824AEAE4: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 824AEAE8: 93410064  stw r26, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[26].u32 ) };
	// 824AEAEC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 824AEAF0: 92C10068  stw r22, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[22].u32 ) };
	// 824AEAF4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824AEAF8: 4099001C  ble cr6, 0x824aeb14
	if !ctx.cr[6].gt {
	pc = 0x824AEB14; continue 'dispatch;
	}
	// 824AEAFC: 40980008  bge cr6, 0x824aeb04
	if !ctx.cr[6].lt {
	pc = 0x824AEB04; continue 'dispatch;
	}
	// 824AEB00: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
            }
            0x824AEB04 => {
    //   block [0x824AEB04..0x824AEB14)
	// 824AEB04: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 824AEB08: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 824AEB0C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 824AEB10: 4BFBF7B9  bl 0x8246e2c8
	ctx.lr = 0x824AEB14;
	sub_8246E2C8(ctx, base);
	pc = 0x824AEB14; continue 'dispatch;
            }
            0x824AEB14 => {
    //   block [0x824AEB14..0x824AEB28)
	// 824AEB14: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 824AEB18: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824AEB1C: 4099006C  ble cr6, 0x824aeb88
	if !ctx.cr[6].gt {
	pc = 0x824AEB88; continue 'dispatch;
	}
	// 824AEB20: 38DB0008  addi r6, r27, 8
	ctx.r[6].s64 = ctx.r[27].s64 + 8;
	// 824AEB24: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	pc = 0x824AEB28; continue 'dispatch;
            }
            0x824AEB28 => {
    //   block [0x824AEB28..0x824AEB44)
	// 824AEB28: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 824AEB2C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 824AEB30: 81260004  lwz r9, 4(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AEB34: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 824AEB38: 7CE8502E  lwzx r7, r8, r10
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824AEB3C: 40990024  ble cr6, 0x824aeb60
	if !ctx.cr[6].gt {
	pc = 0x824AEB60; continue 'dispatch;
	}
	// 824AEB40: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x824AEB44; continue 'dispatch;
            }
            0x824AEB44 => {
    //   block [0x824AEB44..0x824AEB60)
	// 824AEB44: 80AA0000  lwz r5, 0(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AEB48: 7F053840  cmplw cr6, r5, r7
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[7].u32, &mut ctx.xer);
	// 824AEB4C: 419A0018  beq cr6, 0x824aeb64
	if ctx.cr[6].eq {
	pc = 0x824AEB64; continue 'dispatch;
	}
	// 824AEB50: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824AEB54: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 824AEB58: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824AEB5C: 4198FFE8  blt cr6, 0x824aeb44
	if ctx.cr[6].lt {
	pc = 0x824AEB44; continue 'dispatch;
	}
	pc = 0x824AEB60; continue 'dispatch;
            }
            0x824AEB60 => {
    //   block [0x824AEB60..0x824AEB64)
	// 824AEB60: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	pc = 0x824AEB64; continue 'dispatch;
            }
            0x824AEB64 => {
    //   block [0x824AEB64..0x824AEB88)
	// 824AEB64: 81580000  lwz r10, 0(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AEB68: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824AEB6C: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 824AEB70: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 824AEB74: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824AEB78: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 824AEB7C: 7D68512E  stwx r11, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 824AEB80: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 824AEB84: 409AFFA4  bne cr6, 0x824aeb28
	if !ctx.cr[6].eq {
	pc = 0x824AEB28; continue 'dispatch;
	}
	pc = 0x824AEB88; continue 'dispatch;
            }
            0x824AEB88 => {
    //   block [0x824AEB88..0x824AEBD0)
	// 824AEB88: 93410070  stw r26, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[26].u32 ) };
	// 824AEB8C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 824AEB90: 93410074  stw r26, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[26].u32 ) };
	// 824AEB94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824AEB98: 92C10078  stw r22, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[22].u32 ) };
	// 824AEB9C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AEBA0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 824AEBA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AEBA8: 4E800421  bctrl
	ctx.lr = 0x824AEBAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824AEBAC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 824AEBB0: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 824AEBB4: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 824AEBB8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 824AEBBC: 92C10058  stw r22, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[22].u32 ) };
	// 824AEBC0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824AEBC4: 4099001C  ble cr6, 0x824aebe0
	if !ctx.cr[6].gt {
	pc = 0x824AEBE0; continue 'dispatch;
	}
	// 824AEBC8: 40980008  bge cr6, 0x824aebd0
	if !ctx.cr[6].lt {
	pc = 0x824AEBD0; continue 'dispatch;
	}
	// 824AEBCC: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
            }
            0x824AEBD0 => {
    //   block [0x824AEBD0..0x824AEBE0)
	// 824AEBD0: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 824AEBD4: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 824AEBD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 824AEBDC: 4BFBF6ED  bl 0x8246e2c8
	ctx.lr = 0x824AEBE0;
	sub_8246E2C8(ctx, base);
	pc = 0x824AEBE0; continue 'dispatch;
            }
            0x824AEBE0 => {
    //   block [0x824AEBE0..0x824AEBF4)
	// 824AEBE0: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 824AEBE4: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 824AEBE8: 4099006C  ble cr6, 0x824aec54
	if !ctx.cr[6].gt {
	pc = 0x824AEC54; continue 'dispatch;
	}
	// 824AEBEC: 38DB002C  addi r6, r27, 0x2c
	ctx.r[6].s64 = ctx.r[27].s64 + 44;
	// 824AEBF0: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	pc = 0x824AEBF4; continue 'dispatch;
            }
            0x824AEBF4 => {
    //   block [0x824AEBF4..0x824AEC10)
	// 824AEBF4: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 824AEBF8: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 824AEBFC: 81260004  lwz r9, 4(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AEC00: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 824AEC04: 7CE8502E  lwzx r7, r8, r10
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824AEC08: 40990024  ble cr6, 0x824aec2c
	if !ctx.cr[6].gt {
	pc = 0x824AEC2C; continue 'dispatch;
	}
	// 824AEC0C: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x824AEC10; continue 'dispatch;
            }
            0x824AEC10 => {
    //   block [0x824AEC10..0x824AEC2C)
	// 824AEC10: 80AA0000  lwz r5, 0(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AEC14: 7F053840  cmplw cr6, r5, r7
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[7].u32, &mut ctx.xer);
	// 824AEC18: 419A0018  beq cr6, 0x824aec30
	if ctx.cr[6].eq {
	pc = 0x824AEC30; continue 'dispatch;
	}
	// 824AEC1C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824AEC20: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 824AEC24: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824AEC28: 4198FFE8  blt cr6, 0x824aec10
	if ctx.cr[6].lt {
	pc = 0x824AEC10; continue 'dispatch;
	}
	pc = 0x824AEC2C; continue 'dispatch;
            }
            0x824AEC2C => {
    //   block [0x824AEC2C..0x824AEC30)
	// 824AEC2C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	pc = 0x824AEC30; continue 'dispatch;
            }
            0x824AEC30 => {
    //   block [0x824AEC30..0x824AEC54)
	// 824AEC30: 81570000  lwz r10, 0(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AEC34: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824AEC38: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 824AEC3C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 824AEC40: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824AEC44: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824AEC48: 7D68512E  stwx r11, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 824AEC4C: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 824AEC50: 409AFFA4  bne cr6, 0x824aebf4
	if !ctx.cr[6].eq {
	pc = 0x824AEBF4; continue 'dispatch;
	}
	pc = 0x824AEC54; continue 'dispatch;
            }
            0x824AEC54 => {
    //   block [0x824AEC54..0x824AEC9C)
	// 824AEC54: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AEC58: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824AEC5C: 83F50000  lwz r31, 0(r21)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AEC60: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 824AEC64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824AEC68: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 824AEC6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AEC70: 4E800421  bctrl
	ctx.lr = 0x824AEC74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824AEC74: 7C7DF92E  stwx r3, r29, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32), ctx.r[3].u32) };
	// 824AEC78: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 824AEC7C: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824AEC80: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AEC84: 409A0018  bne cr6, 0x824aec9c
	if !ctx.cr[6].eq {
	pc = 0x824AEC9C; continue 'dispatch;
	}
	// 824AEC88: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824AEC8C: 7C74982E  lwzx r3, r20, r19
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[20].u32.wrapping_add(ctx.r[19].u32)) } as u64;
	// 824AEC90: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824AEC94: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824AEC98: 4BFB5421  bl 0x824640b8
	ctx.lr = 0x824AEC9C;
	sub_824640B8(ctx, base);
            }
            0x824AEC9C => {
    //   block [0x824AEC9C..0x824AECC0)
	// 824AEC9C: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 824AECA0: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824AECA4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AECA8: 409A0018  bne cr6, 0x824aecc0
	if !ctx.cr[6].eq {
	pc = 0x824AECC0; continue 'dispatch;
	}
	// 824AECAC: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824AECB0: 7C74982E  lwzx r3, r20, r19
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[20].u32.wrapping_add(ctx.r[19].u32)) } as u64;
	// 824AECB4: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824AECB8: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 824AECBC: 4BFB53FD  bl 0x824640b8
	ctx.lr = 0x824AECC0;
	sub_824640B8(ctx, base);
	pc = 0x824AECC0; continue 'dispatch;
            }
            0x824AECC0 => {
    //   block [0x824AECC0..0x824AECE4)
	// 824AECC0: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 824AECC4: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824AECC8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AECCC: 409A0018  bne cr6, 0x824aece4
	if !ctx.cr[6].eq {
	pc = 0x824AECE4; continue 'dispatch;
	}
	// 824AECD0: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824AECD4: 7C74982E  lwzx r3, r20, r19
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[20].u32.wrapping_add(ctx.r[19].u32)) } as u64;
	// 824AECD8: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824AECDC: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 824AECE0: 4BFB53D9  bl 0x824640b8
	ctx.lr = 0x824AECE4;
	sub_824640B8(ctx, base);
	pc = 0x824AECE4; continue 'dispatch;
            }
            0x824AECE4 => {
    //   block [0x824AECE4..0x824AED08)
	// 824AECE4: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 824AECE8: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824AECEC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AECF0: 409A0018  bne cr6, 0x824aed08
	if !ctx.cr[6].eq {
	pc = 0x824AED08; continue 'dispatch;
	}
	// 824AECF4: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824AECF8: 7C74982E  lwzx r3, r20, r19
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[20].u32.wrapping_add(ctx.r[19].u32)) } as u64;
	// 824AECFC: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824AED00: 80810080  lwz r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 824AED04: 4BFB53B5  bl 0x824640b8
	ctx.lr = 0x824AED08;
	sub_824640B8(ctx, base);
	pc = 0x824AED08; continue 'dispatch;
            }
            0x824AED08 => {
    //   block [0x824AED08..0x824AED1C)
	// 824AED08: 817B0024  lwz r11, 0x24(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(36 as u32) ) } as u64;
	// 824AED0C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 824AED10: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 824AED14: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824AED18: 4198FD78  blt cr6, 0x824aea90
	if ctx.cr[6].lt {
	pc = 0x824AEA90; continue 'dispatch;
	}
	pc = 0x824AED1C; continue 'dispatch;
            }
            0x824AED1C => {
    //   block [0x824AED1C..0x824AED28)
	// 824AED1C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 824AED20: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 824AED24: 480863C0  b 0x825350e4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AED28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AED28 size=16
    let mut pc: u32 = 0x824AED28;
    'dispatch: loop {
        match pc {
            0x824AED28 => {
    //   block [0x824AED28..0x824AED38)
	// 824AED28: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 824AED2C: 38800038  li r4, 0x38
	ctx.r[4].s64 = 56;
	// 824AED30: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 824AED34: 4BFF3C7C  b 0x824a29b0
	sub_824A29B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AED38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AED38 size=32
    let mut pc: u32 = 0x824AED38;
    'dispatch: loop {
        match pc {
            0x824AED38 => {
    //   block [0x824AED38..0x824AED58)
	// 824AED38: 7C8B0774  extsb r11, r4
	ctx.r[11].s64 = ctx.r[4].s8 as i64;
	// 824AED3C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824AED40: 419A0018  beq cr6, 0x824aed58
	if ctx.cr[6].eq {
		sub_824AED58(ctx, base);
		return;
	}
	// 824AED44: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824AED48: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 824AED4C: 91650004  stw r11, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824AED50: 91450000  stw r10, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824AED54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AED58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AED58 size=16
    let mut pc: u32 = 0x824AED58;
    'dispatch: loop {
        match pc {
            0x824AED58 => {
    //   block [0x824AED58..0x824AED68)
	// 824AED58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824AED5C: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824AED60: 91650004  stw r11, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824AED64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AED68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824AED68 size=36
    let mut pc: u32 = 0x824AED68;
    'dispatch: loop {
        match pc {
            0x824AED68 => {
    //   block [0x824AED68..0x824AED84)
	// 824AED68: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824AED6C: C1A40044  lfs f13, 0x44(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824AED70: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824AED74: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824AED78: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 824AED7C: 41990008  bgt cr6, 0x824aed84
	if ctx.cr[6].gt {
	pc = 0x824AED84; continue 'dispatch;
	}
	// 824AED80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x824AED84; continue 'dispatch;
            }
            0x824AED84 => {
    //   block [0x824AED84..0x824AED8C)
	// 824AED84: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824AED88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AED90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AED90 size=8
    let mut pc: u32 = 0x824AED90;
    'dispatch: loop {
        match pc {
            0x824AED90 => {
    //   block [0x824AED90..0x824AED98)
	// 824AED90: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 824AED94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AED98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824AED98 size=92
    let mut pc: u32 = 0x824AED98;
    'dispatch: loop {
        match pc {
            0x824AED98 => {
    //   block [0x824AED98..0x824AEDF4)
	// 824AED98: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824AED9C: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 824AEDA0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 824AEDA4: 392AF384  addi r9, r10, -0xc7c
	ctx.r[9].s64 = ctx.r[10].s64 + -3196;
	// 824AEDA8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 824AEDAC: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 824AEDB0: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824AEDB4: 38C00006  li r6, 6
	ctx.r[6].s64 = 6;
	// 824AEDB8: 39630020  addi r11, r3, 0x20
	ctx.r[11].s64 = ctx.r[3].s64 + 32;
	// 824AEDBC: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 824AEDC0: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824AEDC4: B1430006  sth r10, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 824AEDC8: 39430030  addi r10, r3, 0x30
	ctx.r[10].s64 = ctx.r[3].s64 + 48;
	// 824AEDCC: B0E30010  sth r7, 0x10(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[7].u16 ) };
	// 824AEDD0: B0C30040  sth r6, 0x40(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[6].u16 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AEDF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AEDF8 size=8
    let mut pc: u32 = 0x824AEDF8;
    'dispatch: loop {
        match pc {
            0x824AEDF8 => {
    //   block [0x824AEDF8..0x824AEE00)
	// 824AEDF8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 824AEDFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AEE00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AEE00 size=12
    let mut pc: u32 = 0x824AEE00;
    'dispatch: loop {
        match pc {
            0x824AEE00 => {
    //   block [0x824AEE00..0x824AEE0C)
	// 824AEE00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824AEE04: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824AEE08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AEE10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AEE10 size=12
    let mut pc: u32 = 0x824AEE10;
    'dispatch: loop {
        match pc {
            0x824AEE10 => {
    //   block [0x824AEE10..0x824AEE1C)
	// 824AEE10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824AEE14: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824AEE18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AEE20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AEE20 size=252
    let mut pc: u32 = 0x824AEE20;
    'dispatch: loop {
        match pc {
            0x824AEE20 => {
    //   block [0x824AEE20..0x824AEF1C)
	// 824AEE20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AEE24: 48086299  bl 0x825350bc
	ctx.lr = 0x824AEE28;
	sub_82535080(ctx, base);
	// 824AEE28: A0E40000  lhz r7, 0(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AEE2C: 39640010  addi r11, r4, 0x10
	ctx.r[11].s64 = ctx.r[4].s64 + 16;
	// 824AEE30: 39430010  addi r10, r3, 0x10
	ctx.r[10].s64 = ctx.r[3].s64 + 16;
	// 824AEE34: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 824AEE38: 38C00020  li r6, 0x20
	ctx.r[6].s64 = 32;
	// 824AEE3C: 39240050  addi r9, r4, 0x50
	ctx.r[9].s64 = ctx.r[4].s64 + 80;
	// 824AEE40: B0E30000  sth r7, 0(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AEF20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AEF20 size=288
    let mut pc: u32 = 0x824AEF20;
    'dispatch: loop {
        match pc {
            0x824AEF20 => {
    //   block [0x824AEF20..0x824AF040)
	// 824AEF20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AEF24: 48086179  bl 0x8253509c
	ctx.lr = 0x824AEF28;
	sub_82535080(ctx, base);
	// 824AEF28: A0E40000  lhz r7, 0(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AEF2C: 39640010  addi r11, r4, 0x10
	ctx.r[11].s64 = ctx.r[4].s64 + 16;
	// 824AEF30: 39430010  addi r10, r3, 0x10
	ctx.r[10].s64 = ctx.r[3].s64 + 16;
	// 824AEF34: 38C40090  addi r6, r4, 0x90
	ctx.r[6].s64 = ctx.r[4].s64 + 144;
	// 824AEF38: 3BC00010  li r30, 0x10
	ctx.r[30].s64 = 16;
	// 824AEF3C: 38A30090  addi r5, r3, 0x90
	ctx.r[5].s64 = ctx.r[3].s64 + 144;
	// 824AEF40: B0E30000  sth r7, 0(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u16 ) };
	// 824AEF44: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 824AEF48: 3BE00020  li r31, 0x20
	ctx.r[31].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AF040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AF040 size=356
    let mut pc: u32 = 0x824AF040;
    'dispatch: loop {
        match pc {
            0x824AF040 => {
    //   block [0x824AF040..0x824AF1A4)
	// 824AF040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AF044: 48086061  bl 0x825350a4
	ctx.lr = 0x824AF048;
	sub_82535080(ctx, base);
	// 824AF048: A1240000  lhz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AF04C: 38E40010  addi r7, r4, 0x10
	ctx.r[7].s64 = ctx.r[4].s64 + 16;
	// 824AF050: 38C30010  addi r6, r3, 0x10
	ctx.r[6].s64 = ctx.r[3].s64 + 16;
	// 824AF054: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 824AF058: 3B800030  li r28, 0x30
	ctx.r[28].s64 = 48;
	// 824AF05C: 38A40050  addi r5, r4, 0x50
	ctx.r[5].s64 = ctx.r[4].s64 + 80;
	// 824AF060: B1230000  sth r9, 0(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u16 ) };
	// 824AF064: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AF1A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AF1A8 size=408
    let mut pc: u32 = 0x824AF1A8;
    'dispatch: loop {
        match pc {
            0x824AF1A8 => {
    //   block [0x824AF1A8..0x824AF1EC)
	// 824AF1A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AF1AC: 48085F11  bl 0x825350bc
	ctx.lr = 0x824AF1B0;
	sub_82535080(ctx, base);
	// 824AF1B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AF1B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824AF1B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AF1BC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824AF1C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AF1C4: 4E800421  bctrl
	ctx.lr = 0x824AF1C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824AF1C8: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 824AF1CC: 419A010C  beq cr6, 0x824af2d8
	if ctx.cr[6].eq {
	pc = 0x824AF2D8; continue 'dispatch;
	}
	// 824AF1D0: 2F030006  cmpwi cr6, r3, 6
	ctx.cr[6].compare_i32(ctx.r[3].s32, 6, &mut ctx.xer);
	// 824AF1D4: 419A009C  beq cr6, 0x824af270
	if ctx.cr[6].eq {
	pc = 0x824AF270; continue 'dispatch;
	}
	// 824AF1D8: 2F030007  cmpwi cr6, r3, 7
	ctx.cr[6].compare_i32(ctx.r[3].s32, 7, &mut ctx.xer);
	// 824AF1DC: 419A0010  beq cr6, 0x824af1ec
	if ctx.cr[6].eq {
	pc = 0x824AF1EC; continue 'dispatch;
	}
	// 824AF1E0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824AF1E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824AF1E8: 48085F24  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x824AF1EC => {
    //   block [0x824AF1EC..0x824AF234)
	// 824AF1EC: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AF1F0: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 824AF1F4: 38A0002C  li r5, 0x2c
	ctx.r[5].s64 = 44;
	// 824AF1F8: 38800140  li r4, 0x140
	ctx.r[4].s64 = 320;
	// 824AF1FC: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824AF200: 4BFB4E39  bl 0x82464038
	ctx.lr = 0x824AF204;
	sub_82464038(ctx, base);
	// 824AF204: 39600140  li r11, 0x140
	ctx.r[11].s64 = 320;
	// 824AF208: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 824AF20C: 480013AD  bl 0x824b05b8
	ctx.lr = 0x824AF210;
	sub_824B05B8(ctx, base);
	// 824AF210: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824AF214: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 824AF218: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 824AF21C: 4BFFFE25  bl 0x824af040
	ctx.lr = 0x824AF220;
	sub_824AF040(ctx, base);
	// 824AF220: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AF224: 397E00E0  addi r11, r30, 0xe0
	ctx.r[11].s64 = ctx.r[30].s64 + 224;
	// 824AF228: 3BA00003  li r29, 3
	ctx.r[29].s64 = 3;
	// 824AF22C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 824AF230: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x824AF234; continue 'dispatch;
            }
            0x824AF234 => {
    //   block [0x824AF234..0x824AF254)
	// 824AF234: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AF238: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 824AF23C: 419A0018  beq cr6, 0x824af254
	if ctx.cr[6].eq {
	pc = 0x824AF254; continue 'dispatch;
	}
	// 824AF240: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AF244: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824AF248: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AF24C: 4E800421  bctrl
	ctx.lr = 0x824AF250;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824AF250: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
            }
            0x824AF254 => {
    //   block [0x824AF254..0x824AF270)
	// 824AF254: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 824AF258: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 824AF25C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 824AF260: 409AFFD4  bne cr6, 0x824af234
	if !ctx.cr[6].eq {
	pc = 0x824AF234; continue 'dispatch;
	}
	// 824AF264: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824AF268: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824AF26C: 48085EA0  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x824AF270 => {
    //   block [0x824AF270..0x824AF2D8)
	// 824AF270: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AF274: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 824AF278: 38A0002C  li r5, 0x2c
	ctx.r[5].s64 = 44;
	// 824AF27C: 388000D0  li r4, 0xd0
	ctx.r[4].s64 = 208;
	// 824AF280: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824AF284: 4BFB4DB5  bl 0x82464038
	ctx.lr = 0x824AF288;
	sub_82464038(ctx, base);
	// 824AF288: 396000D0  li r11, 0xd0
	ctx.r[11].s64 = 208;
	// 824AF28C: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 824AF290: 4800A851  bl 0x824b9ae0
	ctx.lr = 0x824AF294;
	sub_824B9AE0(ctx, base);
	// 824AF294: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824AF298: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 824AF29C: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 824AF2A0: 4BFFFC81  bl 0x824aef20
	ctx.lr = 0x824AF2A4;
	sub_824AEF20(ctx, base);
	// 824AF2A4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AF2A8: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 824AF2AC: 807E00AC  lwz r3, 0xac(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(172 as u32) ) } as u64;
	// 824AF2B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 824AF2B4: 419A0080  beq cr6, 0x824af334
	if ctx.cr[6].eq {
	pc = 0x824AF334; continue 'dispatch;
	}
	// 824AF2B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AF2BC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824AF2C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AF2C4: 4E800421  bctrl
	ctx.lr = 0x824AF2C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824AF2C8: 907E00AC  stw r3, 0xac(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(172 as u32), ctx.r[3].u32 ) };
	// 824AF2CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824AF2D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824AF2D4: 48085E38  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x824AF2D8 => {
    //   block [0x824AF2D8..0x824AF334)
	// 824AF2D8: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AF2DC: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 824AF2E0: 38A0002C  li r5, 0x2c
	ctx.r[5].s64 = 44;
	// 824AF2E4: 388000E0  li r4, 0xe0
	ctx.r[4].s64 = 224;
	// 824AF2E8: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824AF2EC: 4BFB4D4D  bl 0x82464038
	ctx.lr = 0x824AF2F0;
	sub_82464038(ctx, base);
	// 824AF2F0: 396000E0  li r11, 0xe0
	ctx.r[11].s64 = 224;
	// 824AF2F4: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 824AF2F8: 480008E1  bl 0x824afbd8
	ctx.lr = 0x824AF2FC;
	sub_824AFBD8(ctx, base);
	// 824AF2FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824AF300: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 824AF304: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 824AF308: 4BFFFB19  bl 0x824aee20
	ctx.lr = 0x824AF30C;
	sub_824AEE20(ctx, base);
	// 824AF30C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824AF310: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 824AF314: 807E00B0  lwz r3, 0xb0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 824AF318: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 824AF31C: 419A0018  beq cr6, 0x824af334
	if ctx.cr[6].eq {
	pc = 0x824AF334; continue 'dispatch;
	}
	// 824AF320: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AF324: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824AF328: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AF32C: 4E800421  bctrl
	ctx.lr = 0x824AF330;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824AF330: 907E00B0  stw r3, 0xb0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(176 as u32), ctx.r[3].u32 ) };
            }
            0x824AF334 => {
    //   block [0x824AF334..0x824AF340)
	// 824AF334: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824AF338: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824AF33C: 48085DD0  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AF340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AF340 size=8
    let mut pc: u32 = 0x824AF340;
    'dispatch: loop {
        match pc {
            0x824AF340 => {
    //   block [0x824AF340..0x824AF348)
	// 824AF340: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 824AF344: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AF348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824AF348 size=164
    let mut pc: u32 = 0x824AF348;
    'dispatch: loop {
        match pc {
            0x824AF348 => {
    //   block [0x824AF348..0x824AF3EC)
	// 824AF348: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 824AF34C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 824AF350: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 824AF354: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 824AF358: 39630010  addi r11, r3, 0x10
	ctx.r[11].s64 = ctx.r[3].s64 + 16;
	// 824AF35C: C1882090  lfs f12, 0x2090(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8336 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 824AF360: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 824AF364: C1A920B0  lfs f13, 0x20b0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8368 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824AF368: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824AF36C: C00A2074  lfs f0, 0x2074(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824AF370: 39430030  addi r10, r3, 0x30
	ctx.r[10].s64 = ctx.r[3].s64 + 48;
	// 824AF374: 3929F4B4  addi r9, r9, -0xb4c
	ctx.r[9].s64 = ctx.r[9].s64 + -2892;
	// 824AF378: D0030050  stfs f0, 0x50(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 824AF37C: D1A30054  stfs f13, 0x54(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 824AF380: B0E30006  sth r7, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[7].u16 ) };
	// 824AF384: C1688E30  lfs f11, -0x71d0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-29136 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 824AF388: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 824AF38C: D1830058  stfs f12, 0x58(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 824AF390: D163005C  stfs f11, 0x5c(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 824AF394: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824AF398: 39200040  li r9, 0x40
	ctx.r[9].s64 = 64;
	// 824AF39C: C148D6C8  lfs f10, -0x2938(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 824AF3A0: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 824AF3A4: D1430060  stfs f10, 0x60(r3)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 824AF3A8: C0088CB4  lfs f0, -0x734c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-29516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824AF3AC: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 824AF3B0: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AF3F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AF3F0 size=32
    let mut pc: u32 = 0x824AF3F0;
    'dispatch: loop {
        match pc {
            0x824AF3F0 => {
    //   block [0x824AF3F0..0x824AF410)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AF410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824AF410 size=136
    let mut pc: u32 = 0x824AF410;
    'dispatch: loop {
        match pc {
            0x824AF410 => {
    //   block [0x824AF410..0x824AF498)
	// 824AF410: 396500E0  addi r11, r5, 0xe0
	ctx.r[11].s64 = ctx.r[5].s64 + 224;
	// 824AF414: 39240010  addi r9, r4, 0x10
	ctx.r[9].s64 = ctx.r[4].s64 + 16;
	// 824AF418: 394B0040  addi r10, r11, 0x40
	ctx.r[10].s64 = ctx.r[11].s64 + 64;
	// 824AF41C: 38C1FFF0  addi r6, r1, -0x10
	ctx.r[6].s64 = ctx.r[1].s64 + -16;
	// 824AF420: 38EA0010  addi r7, r10, 0x10
	ctx.r[7].s64 = ctx.r[10].s64 + 16;
	// 824AF424: C1AB00A0  lfs f13, 0xa0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824AF428: 39040020  addi r8, r4, 0x20
	ctx.r[8].s64 = ctx.r[4].s64 + 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AF498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AF498 size=24
    let mut pc: u32 = 0x824AF498;
    'dispatch: loop {
        match pc {
            0x824AF498 => {
    //   block [0x824AF498..0x824AF4B0)
	// 824AF498: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AF4B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824AF4B0 size=136
    let mut pc: u32 = 0x824AF4B0;
    'dispatch: loop {
        match pc {
            0x824AF4B0 => {
    //   block [0x824AF4B0..0x824AF538)
	// 824AF4B0: 396500E0  addi r11, r5, 0xe0
	ctx.r[11].s64 = ctx.r[5].s64 + 224;
	// 824AF4B4: 39240030  addi r9, r4, 0x30
	ctx.r[9].s64 = ctx.r[4].s64 + 48;
	// 824AF4B8: 394B0040  addi r10, r11, 0x40
	ctx.r[10].s64 = ctx.r[11].s64 + 64;
	// 824AF4BC: 38C1FFF0  addi r6, r1, -0x10
	ctx.r[6].s64 = ctx.r[1].s64 + -16;
	// 824AF4C0: 38EA0010  addi r7, r10, 0x10
	ctx.r[7].s64 = ctx.r[10].s64 + 16;
	// 824AF4C4: C1AB00A0  lfs f13, 0xa0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824AF4C8: 39040040  addi r8, r4, 0x40
	ctx.r[8].s64 = ctx.r[4].s64 + 64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AF538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AF538 size=24
    let mut pc: u32 = 0x824AF538;
    'dispatch: loop {
        match pc {
            0x824AF538 => {
    //   block [0x824AF538..0x824AF550)
	// 824AF538: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AF550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AF550 size=356
    let mut pc: u32 = 0x824AF550;
    'dispatch: loop {
        match pc {
            0x824AF550 => {
    //   block [0x824AF550..0x824AF6B4)
	// 824AF550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AF554: 48085B69  bl 0x825350bc
	ctx.lr = 0x824AF558;
	sub_82535080(ctx, base);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AF6B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AF6B8 size=156
    let mut pc: u32 = 0x824AF6B8;
    'dispatch: loop {
        match pc {
            0x824AF6B8 => {
    //   block [0x824AF6B8..0x824AF6F4)
	// 824AF6B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AF6BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AF6C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824AF6C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AF6C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AF6CC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824AF6D0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824AF6D4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 824AF6D8: 419A001C  beq cr6, 0x824af6f4
	if ctx.cr[6].eq {
	pc = 0x824AF6F4; continue 'dispatch;
	}
	// 824AF6DC: A17F0004  lhz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AF6E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824AF6E4: 419A0010  beq cr6, 0x824af6f4
	if ctx.cr[6].eq {
	pc = 0x824AF6F4; continue 'dispatch;
	}
	// 824AF6E8: A17F0006  lhz r11, 6(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 824AF6EC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824AF6F0: B17F0006  sth r11, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	pc = 0x824AF6F4; continue 'dispatch;
            }
            0x824AF6F4 => {
    //   block [0x824AF6F4..0x824AF738)
	// 824AF6F4: 807E00B0  lwz r3, 0xb0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 824AF6F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 824AF6FC: 419A003C  beq cr6, 0x824af738
	if ctx.cr[6].eq {
	pc = 0x824AF738; continue 'dispatch;
	}
	// 824AF700: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AF704: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824AF708: 419A0030  beq cr6, 0x824af738
	if ctx.cr[6].eq {
	pc = 0x824AF738; continue 'dispatch;
	}
	// 824AF70C: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 824AF710: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824AF714: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824AF718: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824AF71C: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824AF720: 409A0018  bne cr6, 0x824af738
	if !ctx.cr[6].eq {
	pc = 0x824AF738; continue 'dispatch;
	}
	// 824AF724: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AF728: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824AF72C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AF730: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AF734: 4E800421  bctrl
	ctx.lr = 0x824AF738;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824AF738 => {
    //   block [0x824AF738..0x824AF754)
	// 824AF738: 93FE00B0  stw r31, 0xb0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(176 as u32), ctx.r[31].u32 ) };
	// 824AF73C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824AF740: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824AF744: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824AF748: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824AF74C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824AF750: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AF758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AF758 size=16
    let mut pc: u32 = 0x824AF758;
    'dispatch: loop {
        match pc {
            0x824AF758 => {
    //   block [0x824AF758..0x824AF768)
	// 824AF758: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 824AF75C: 388000C6  li r4, 0xc6
	ctx.r[4].s64 = 198;
	// 824AF760: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 824AF764: 4BFF324C  b 0x824a29b0
	sub_824A29B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AF768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AF768 size=20
    let mut pc: u32 = 0x824AF768;
    'dispatch: loop {
        match pc {
            0x824AF768 => {
    //   block [0x824AF768..0x824AF77C)
	// 824AF768: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 824AF76C: 39400050  li r10, 0x50
	ctx.r[10].s64 = 80;
	// 824AF770: 91650004  stw r11, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824AF774: 91450000  stw r10, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824AF778: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AF780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824AF780 size=168
    let mut pc: u32 = 0x824AF780;
    'dispatch: loop {
        match pc {
            0x824AF780 => {
    //   block [0x824AF780..0x824AF7F8)
	// 824AF780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AF784: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AF788: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824AF78C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AF790: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 824AF794: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AF798: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824AF79C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824AF7A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824AF7A4: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 824AF7A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 824AF7AC: C3EB2238  lfs f31, 0x2238(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8760 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 824AF7B0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 824AF7B4: 480FBFAD  bl 0x825ab760
	ctx.lr = 0x824AF7B8;
	sub_825AB760(ctx, base);
	// 824AF7B8: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AF7BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824AF7C0: 419A0040  beq cr6, 0x824af800
	if ctx.cr[6].eq {
	pc = 0x824AF800; continue 'dispatch;
	}
	// 824AF7C4: 389F0060  addi r4, r31, 0x60
	ctx.r[4].s64 = ctx.r[31].s64 + 96;
	// 824AF7C8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 824AF7CC: 38610051  addi r3, r1, 0x51
	ctx.r[3].s64 = ctx.r[1].s64 + 81;
	// 824AF7D0: 480FBF91  bl 0x825ab760
	ctx.lr = 0x824AF7D4;
	sub_825AB760(ctx, base);
	// 824AF7D4: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AF7D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824AF7DC: 419A0024  beq cr6, 0x824af800
	if ctx.cr[6].eq {
	pc = 0x824AF800; continue 'dispatch;
	}
	// 824AF7E0: 897F00A2  lbz r11, 0xa2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(162 as u32) ) } as u64;
	// 824AF7E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824AF7E8: 419A0010  beq cr6, 0x824af7f8
	if ctx.cr[6].eq {
	pc = 0x824AF7F8; continue 'dispatch;
	}
	// 824AF7EC: 897F00C2  lbz r11, 0xc2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(194 as u32) ) } as u64;
	// 824AF7F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824AF7F4: 419A000C  beq cr6, 0x824af800
	if ctx.cr[6].eq {
	pc = 0x824AF800; continue 'dispatch;
	}
	pc = 0x824AF7F8; continue 'dispatch;
            }
            0x824AF7F8 => {
    //   block [0x824AF7F8..0x824AF800)
	// 824AF7F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824AF7FC: 48000008  b 0x824af804
	pc = 0x824AF804; continue 'dispatch;
            }
            0x824AF800 => {
    //   block [0x824AF800..0x824AF804)
	// 824AF800: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x824AF804; continue 'dispatch;
            }
            0x824AF804 => {
    //   block [0x824AF804..0x824AF828)
	// 824AF804: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824AF808: 997E0000  stb r11, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824AF80C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 824AF810: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824AF814: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824AF818: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 824AF81C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824AF820: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824AF824: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AF828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AF828 size=8
    let mut pc: u32 = 0x824AF828;
    'dispatch: loop {
        match pc {
            0x824AF828 => {
    //   block [0x824AF828..0x824AF830)
	// 824AF828: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 824AF82C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AF830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824AF830 size=132
    let mut pc: u32 = 0x824AF830;
    'dispatch: loop {
        match pc {
            0x824AF830 => {
    //   block [0x824AF830..0x824AF894)
	// 824AF830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AF834: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AF838: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AF83C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AF840: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824AF844: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824AF848: 396BF5AC  addi r11, r11, -0xa54
	ctx.r[11].s64 = ctx.r[11].s64 + -2644;
	// 824AF84C: 807F00B0  lwz r3, 0xb0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 824AF850: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 824AF854: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824AF858: 419A003C  beq cr6, 0x824af894
	if ctx.cr[6].eq {
	pc = 0x824AF894; continue 'dispatch;
	}
	// 824AF85C: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824AF860: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824AF864: 419A0030  beq cr6, 0x824af894
	if ctx.cr[6].eq {
	pc = 0x824AF894; continue 'dispatch;
	}
	// 824AF868: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 824AF86C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824AF870: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824AF874: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824AF878: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824AF87C: 409A0018  bne cr6, 0x824af894
	if !ctx.cr[6].eq {
	pc = 0x824AF894; continue 'dispatch;
	}
	// 824AF880: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AF884: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824AF888: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AF88C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824AF890: 4E800421  bctrl
	ctx.lr = 0x824AF894;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824AF894 => {
    //   block [0x824AF894..0x824AF8B4)
	// 824AF894: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824AF898: 396B6DD0  addi r11, r11, 0x6dd0
	ctx.r[11].s64 = ctx.r[11].s64 + 28112;
	// 824AF89C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824AF8A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824AF8A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824AF8A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824AF8AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824AF8B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AF8B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AF8B8 size=720
    let mut pc: u32 = 0x824AF8B8;
    'dispatch: loop {
        match pc {
            0x824AF8B8 => {
    //   block [0x824AF8B8..0x824AFB88)
	// 824AF8B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AF8BC: 480857F5  bl 0x825350b0
	ctx.lr = 0x824AF8C0;
	sub_82535080(ctx, base);
	// 824AF8C0: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AFB88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824AFB88 size=80
    let mut pc: u32 = 0x824AFB88;
    'dispatch: loop {
        match pc {
            0x824AFB88 => {
    //   block [0x824AFB88..0x824AFBD8)
	// 824AFB88: 7CAB0774  extsb r11, r5
	ctx.r[11].s64 = ctx.r[5].s8 as i64;
	// 824AFB8C: 98A300A2  stb r5, 0xa2(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(162 as u32), ctx.r[5].u8 ) };
	// 824AFB90: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 824AFB94: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 824AFB98: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 824AFB9C: 996300B6  stb r11, 0xb6(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(182 as u32), ctx.r[11].u8 ) };
	// 824AFBA0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 824AFBA4: 81640028  lwz r11, 0x28(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 824AFBA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824AFBAC: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 824AFBB0: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 824AFBB4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824AFBB8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 824AFBBC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 824AFBC0: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824AFBC4: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 824AFBC8: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 824AFBCC: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 824AFBD0: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 824AFBD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AFBD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AFBD8 size=336
    let mut pc: u32 = 0x824AFBD8;
    'dispatch: loop {
        match pc {
            0x824AFBD8 => {
    //   block [0x824AFBD8..0x824AFD28)
	// 824AFBD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AFBDC: 480854D5  bl 0x825350b0
	ctx.lr = 0x824AFBE0;
	sub_82535080(ctx, base);
	// 824AFBE0: 3941FFB0  addi r10, r1, -0x50
	ctx.r[10].s64 = ctx.r[1].s64 + -80;
	// 824AFBE4: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 824AFBE8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 824AFBEC: 39630010  addi r11, r3, 0x10
	ctx.r[11].s64 = ctx.r[3].s64 + 16;
	// 824AFBF0: 3BC00012  li r30, 0x12
	ctx.r[30].s64 = 18;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AFD28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AFD28 size=388
    let mut pc: u32 = 0x824AFD28;
    'dispatch: loop {
        match pc {
            0x824AFD28 => {
    //   block [0x824AFD28..0x824AFEAC)
	// 824AFD28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AFD2C: 4808538D  bl 0x825350b8
	ctx.lr = 0x824AFD30;
	sub_82535080(ctx, base);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AFEB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AFEB0 size=16
    let mut pc: u32 = 0x824AFEB0;
    'dispatch: loop {
        match pc {
            0x824AFEB0 => {
    //   block [0x824AFEB0..0x824AFEC0)
	// 824AFEB0: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 824AFEB4: 3880012A  li r4, 0x12a
	ctx.r[4].s64 = 298;
	// 824AFEB8: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 824AFEBC: 4BFF2AF4  b 0x824a29b0
	sub_824A29B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AFEC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AFEC0 size=20
    let mut pc: u32 = 0x824AFEC0;
    'dispatch: loop {
        match pc {
            0x824AFEC0 => {
    //   block [0x824AFEC0..0x824AFED4)
	// 824AFEC0: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 824AFEC4: 39400080  li r10, 0x80
	ctx.r[10].s64 = 128;
	// 824AFEC8: 91650004  stw r11, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824AFECC: 91450000  stw r10, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824AFED0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AFEE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824AFEE0 size=28
    let mut pc: u32 = 0x824AFEE0;
    'dispatch: loop {
        match pc {
            0x824AFEE0 => {
    //   block [0x824AFEE0..0x824AFEFC)
	// 824AFEE0: 7C8B0774  extsb r11, r4
	ctx.r[11].s64 = ctx.r[4].s8 as i64;
	// 824AFEE4: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 824AFEE8: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 824AFEEC: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 824AFEF0: 1D6B0038  mulli r11, r11, 0x38
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 56 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 824AFEF4: 99630116  stb r11, 0x116(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(278 as u32), ctx.r[11].u8 ) };
	// 824AFEF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824AFF00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824AFF00 size=384
    let mut pc: u32 = 0x824AFF00;
    'dispatch: loop {
        match pc {
            0x824AFF00 => {
    //   block [0x824AFF00..0x824AFF84)
	// 824AFF00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824AFF04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824AFF08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824AFF0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824AFF10: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 824AFF14: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824AFF18: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824AFF1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824AFF20: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 824AFF24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 824AFF28: 389E0020  addi r4, r30, 0x20
	ctx.r[4].s64 = ctx.r[30].s64 + 32;
	// 824AFF2C: C3EB2238  lfs f31, 0x2238(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8760 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 824AFF30: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824AFF34: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 824AFF38: 997F0000  stb r11, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824AFF3C: 480FB825  bl 0x825ab760
	ctx.lr = 0x824AFF40;
	sub_825AB760(ctx, base);
	// 824AFF40: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AFF44: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824AFF48: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 824AFF4C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 824AFF50: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 824AFF54: 7D6A0774  extsb r10, r11
	ctx.r[10].s64 = ctx.r[11].s8 as i64;
	// 824AFF58: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AFF5C: 997F0000  stb r11, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824AFF60: 419A0024  beq cr6, 0x824aff84
	if ctx.cr[6].eq {
	pc = 0x824AFF84; continue 'dispatch;
	}
	// 824AFF64: 389E0060  addi r4, r30, 0x60
	ctx.r[4].s64 = ctx.r[30].s64 + 96;
	// 824AFF68: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 824AFF6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 824AFF70: 480FB7F1  bl 0x825ab760
	ctx.lr = 0x824AFF74;
	sub_825AB760(ctx, base);
	// 824AFF74: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824AFF78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824AFF7C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824AFF80: 409A0008  bne cr6, 0x824aff88
	if !ctx.cr[6].eq {
	pc = 0x824AFF88; continue 'dispatch;
	}
	pc = 0x824AFF84; continue 'dispatch;
            }
            0x824AFF84 => {
    //   block [0x824AFF84..0x824AFF88)
	// 824AFF84: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x824AFF88; continue 'dispatch;
            }
            0x824AFF88 => {
    //   block [0x824AFF88..0x824AFFB0)
	// 824AFF88: 7D6A0774  extsb r10, r11
	ctx.r[10].s64 = ctx.r[11].s8 as i64;
	// 824AFF8C: 997F0000  stb r11, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824AFF90: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AFF94: 419A001C  beq cr6, 0x824affb0
	if ctx.cr[6].eq {
	pc = 0x824AFFB0; continue 'dispatch;
	}
	// 824AFF98: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824AFF9C: C1BE0118  lfs f13, 0x118(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(280 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824AFFA0: C00B233C  lfs f0, 0x233c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9020 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824AFFA4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824AFFA8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 824AFFAC: 419A0008  beq cr6, 0x824affb4
	if ctx.cr[6].eq {
	pc = 0x824AFFB4; continue 'dispatch;
	}
	pc = 0x824AFFB0; continue 'dispatch;
            }
            0x824AFFB0 => {
    //   block [0x824AFFB0..0x824AFFB4)
	// 824AFFB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x824AFFB4; continue 'dispatch;
            }
            0x824AFFB4 => {
    //   block [0x824AFFB4..0x824AFFDC)
	// 824AFFB4: 7D6A0774  extsb r10, r11
	ctx.r[10].s64 = ctx.r[11].s8 as i64;
	// 824AFFB8: 997F0000  stb r11, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824AFFBC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AFFC0: 419A001C  beq cr6, 0x824affdc
	if ctx.cr[6].eq {
	pc = 0x824AFFDC; continue 'dispatch;
	}
	// 824AFFC4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824AFFC8: C1BE011C  lfs f13, 0x11c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(284 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824AFFCC: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824AFFD0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824AFFD4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 824AFFD8: 40980008  bge cr6, 0x824affe0
	if !ctx.cr[6].lt {
	pc = 0x824AFFE0; continue 'dispatch;
	}
	pc = 0x824AFFDC; continue 'dispatch;
            }
            0x824AFFDC => {
    //   block [0x824AFFDC..0x824AFFE0)
	// 824AFFDC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x824AFFE0; continue 'dispatch;
            }
            0x824AFFE0 => {
    //   block [0x824AFFE0..0x824B0008)
	// 824AFFE0: 7D6A0774  extsb r10, r11
	ctx.r[10].s64 = ctx.r[11].s8 as i64;
	// 824AFFE4: 997F0000  stb r11, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824AFFE8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824AFFEC: 419A001C  beq cr6, 0x824b0008
	if ctx.cr[6].eq {
	pc = 0x824B0008; continue 'dispatch;
	}
	// 824AFFF0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824AFFF4: C1BE011C  lfs f13, 0x11c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(284 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824AFFF8: C00B2930  lfs f0, 0x2930(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10544 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824AFFFC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824B0000: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 824B0004: 41980008  blt cr6, 0x824b000c
	if ctx.cr[6].lt {
	pc = 0x824B000C; continue 'dispatch;
	}
	pc = 0x824B0008; continue 'dispatch;
            }
            0x824B0008 => {
    //   block [0x824B0008..0x824B000C)
	// 824B0008: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x824B000C; continue 'dispatch;
            }
            0x824B000C => {
    //   block [0x824B000C..0x824B0030)
	// 824B000C: 7D6A0774  extsb r10, r11
	ctx.r[10].s64 = ctx.r[11].s8 as i64;
	// 824B0010: 997F0000  stb r11, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824B0014: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824B0018: 419A0018  beq cr6, 0x824b0030
	if ctx.cr[6].eq {
	pc = 0x824B0030; continue 'dispatch;
	}
	// 824B001C: C01E012C  lfs f0, 0x12c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(300 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B0020: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824B0024: C1BE0130  lfs f13, 0x130(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(304 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824B0028: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 824B002C: 40990008  ble cr6, 0x824b0034
	if !ctx.cr[6].gt {
	pc = 0x824B0034; continue 'dispatch;
	}
	pc = 0x824B0030; continue 'dispatch;
            }
            0x824B0030 => {
    //   block [0x824B0030..0x824B0034)
	// 824B0030: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x824B0034; continue 'dispatch;
            }
            0x824B0034 => {
    //   block [0x824B0034..0x824B0058)
	// 824B0034: 7D6A0774  extsb r10, r11
	ctx.r[10].s64 = ctx.r[11].s8 as i64;
	// 824B0038: 997F0000  stb r11, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824B003C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824B0040: 419A0018  beq cr6, 0x824b0058
	if ctx.cr[6].eq {
	pc = 0x824B0058; continue 'dispatch;
	}
	// 824B0044: C01E0104  lfs f0, 0x104(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(260 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B0048: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824B004C: C1BE0108  lfs f13, 0x108(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824B0050: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 824B0054: 40990008  ble cr6, 0x824b005c
	if !ctx.cr[6].gt {
	pc = 0x824B005C; continue 'dispatch;
	}
	pc = 0x824B0058; continue 'dispatch;
            }
            0x824B0058 => {
    //   block [0x824B0058..0x824B005C)
	// 824B0058: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x824B005C; continue 'dispatch;
            }
            0x824B005C => {
    //   block [0x824B005C..0x824B0080)
	// 824B005C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B0060: 997F0000  stb r11, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824B0064: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 824B0068: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824B006C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824B0070: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 824B0074: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824B0078: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824B007C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B0080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B0080 size=40
    let mut pc: u32 = 0x824B0080;
    'dispatch: loop {
        match pc {
            0x824B0080 => {
    //   block [0x824B0080..0x824B00A8)
	// 824B0080: 39630020  addi r11, r3, 0x20
	ctx.r[11].s64 = ctx.r[3].s64 + 32;
	// 824B0084: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824B0088: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B00A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B00A8 size=40
    let mut pc: u32 = 0x824B00A8;
    'dispatch: loop {
        match pc {
            0x824B00A8 => {
    //   block [0x824B00A8..0x824B00D0)
	// 824B00A8: 39630060  addi r11, r3, 0x60
	ctx.r[11].s64 = ctx.r[3].s64 + 96;
	// 824B00AC: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824B00B0: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B00D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B00D0 size=40
    let mut pc: u32 = 0x824B00D0;
    'dispatch: loop {
        match pc {
            0x824B00D0 => {
    //   block [0x824B00D0..0x824B00F8)
	// 824B00D0: 396300B0  addi r11, r3, 0xb0
	ctx.r[11].s64 = ctx.r[3].s64 + 176;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B00F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B00F8 size=12
    let mut pc: u32 = 0x824B00F8;
    'dispatch: loop {
        match pc {
            0x824B00F8 => {
    //   block [0x824B00F8..0x824B0104)
	// 824B00F8: 38A30020  addi r5, r3, 0x20
	ctx.r[5].s64 = ctx.r[3].s64 + 32;
	// 824B00FC: 386300B0  addi r3, r3, 0xb0
	ctx.r[3].s64 = ctx.r[3].s64 + 176;
	// 824B0100: 480F7120  b 0x825a7220
	sub_825A7220(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B0108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B0108 size=40
    let mut pc: u32 = 0x824B0108;
    'dispatch: loop {
        match pc {
            0x824B0108 => {
    //   block [0x824B0108..0x824B0130)
	// 824B0108: 396300B0  addi r11, r3, 0xb0
	ctx.r[11].s64 = ctx.r[3].s64 + 176;
	// 824B010C: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824B0110: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B0130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B0130 size=8
    let mut pc: u32 = 0x824B0130;
    'dispatch: loop {
        match pc {
            0x824B0130 => {
    //   block [0x824B0130..0x824B0138)
	// 824B0130: 806300E0  lwz r3, 0xe0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(224 as u32) ) } as u64;
	// 824B0134: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B0138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B0138 size=140
    let mut pc: u32 = 0x824B0138;
    'dispatch: loop {
        match pc {
            0x824B0138 => {
    //   block [0x824B0138..0x824B016C)
	// 824B0138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B013C: 48084F81  bl 0x825350bc
	ctx.lr = 0x824B0140;
	sub_82535080(ctx, base);
	// 824B0140: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B0144: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 824B0148: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 824B014C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 824B0150: 419A001C  beq cr6, 0x824b016c
	if ctx.cr[6].eq {
	pc = 0x824B016C; continue 'dispatch;
	}
	// 824B0154: A17E0004  lhz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B0158: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B015C: 419A0010  beq cr6, 0x824b016c
	if ctx.cr[6].eq {
	pc = 0x824B016C; continue 'dispatch;
	}
	// 824B0160: A17E0006  lhz r11, 6(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) } as u64;
	// 824B0164: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824B0168: B17E0006  sth r11, 6(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	pc = 0x824B016C; continue 'dispatch;
            }
            0x824B016C => {
    //   block [0x824B016C..0x824B01B8)
	// 824B016C: 39640038  addi r11, r4, 0x38
	ctx.r[11].s64 = ctx.r[4].s64 + 56;
	// 824B0170: 557F103A  slwi r31, r11, 2
	ctx.r[31].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 824B0174: 7C7FE82E  lwzx r3, r31, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824B0178: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 824B017C: 419A003C  beq cr6, 0x824b01b8
	if ctx.cr[6].eq {
	pc = 0x824B01B8; continue 'dispatch;
	}
	// 824B0180: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B0184: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B0188: 419A0030  beq cr6, 0x824b01b8
	if ctx.cr[6].eq {
	pc = 0x824B01B8; continue 'dispatch;
	}
	// 824B018C: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 824B0190: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824B0194: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824B0198: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B019C: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824B01A0: 409A0018  bne cr6, 0x824b01b8
	if !ctx.cr[6].eq {
	pc = 0x824B01B8; continue 'dispatch;
	}
	// 824B01A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B01A8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824B01AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B01B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B01B4: 4E800421  bctrl
	ctx.lr = 0x824B01B8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824B01B8 => {
    //   block [0x824B01B8..0x824B01C4)
	// 824B01B8: 7FDFE92E  stwx r30, r31, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[29].u32), ctx.r[30].u32) };
	// 824B01BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824B01C0: 48084F4C  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B01C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B01C8 size=12
    let mut pc: u32 = 0x824B01C8;
    'dispatch: loop {
        match pc {
            0x824B01C8 => {
    //   block [0x824B01C8..0x824B01D4)
	// 824B01C8: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 824B01CC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 824B01D0: 4BFFFF68  b 0x824b0138
	sub_824B0138(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B01D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B01D8 size=8
    let mut pc: u32 = 0x824B01D8;
    'dispatch: loop {
        match pc {
            0x824B01D8 => {
    //   block [0x824B01D8..0x824B01E0)
	// 824B01D8: 806300E8  lwz r3, 0xe8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(232 as u32) ) } as u64;
	// 824B01DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B01E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B01E0 size=12
    let mut pc: u32 = 0x824B01E0;
    'dispatch: loop {
        match pc {
            0x824B01E0 => {
    //   block [0x824B01E0..0x824B01EC)
	// 824B01E0: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 824B01E4: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 824B01E8: 4BFFFF50  b 0x824b0138
	sub_824B0138(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B01F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B01F0 size=8
    let mut pc: u32 = 0x824B01F0;
    'dispatch: loop {
        match pc {
            0x824B01F0 => {
    //   block [0x824B01F0..0x824B01F8)
	// 824B01F0: 806300E4  lwz r3, 0xe4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(228 as u32) ) } as u64;
	// 824B01F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B01F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B01F8 size=12
    let mut pc: u32 = 0x824B01F8;
    'dispatch: loop {
        match pc {
            0x824B01F8 => {
    //   block [0x824B01F8..0x824B0204)
	// 824B01F8: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 824B01FC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824B0200: 4BFFFF38  b 0x824b0138
	sub_824B0138(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B0218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B0218 size=8
    let mut pc: u32 = 0x824B0218;
    'dispatch: loop {
        match pc {
            0x824B0218 => {
    //   block [0x824B0218..0x824B0220)
	// 824B0218: 38600007  li r3, 7
	ctx.r[3].s64 = 7;
	// 824B021C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B0220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B0220 size=424
    let mut pc: u32 = 0x824B0220;
    'dispatch: loop {
        match pc {
            0x824B0220 => {
    //   block [0x824B0220..0x824B03C8)
	// 824B0220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B0224: 48084E91  bl 0x825350b4
	ctx.lr = 0x824B0228;
	sub_82535080(ctx, base);
	// 824B0228: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B03C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824B03C8 size=240
    let mut pc: u32 = 0x824B03C8;
    'dispatch: loop {
        match pc {
            0x824B03C8 => {
    //   block [0x824B03C8..0x824B04B8)
	// 824B03C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B03CC: 48084CF1  bl 0x825350bc
	ctx.lr = 0x824B03D0;
	sub_82535080(ctx, base);
	// 824B03D0: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 824B03D4: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 824B03D8: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 824B03DC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B03E0: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 824B03E4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824B03E8: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 824B03EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824B03F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 824B03F4: 3BFE0060  addi r31, r30, 0x60
	ctx.r[31].s64 = ctx.r[30].s64 + 96;
	// 824B03F8: C3ABBFFC  lfs f29, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 824B03FC: 3BBF0010  addi r29, r31, 0x10
	ctx.r[29].s64 = ctx.r[31].s64 + 16;
	// 824B0400: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824B0404: EC1FF02A  fadds f0, f31, f30
	ctx.f[0].f64 = ((ctx.f[31].f64 + ctx.f[30].f64) as f32) as f64;
	// 824B0408: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 824B040C: FC200050  fneg f1, f0
	ctx.f[1].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 824B0410: 480F8039  bl 0x825a8448
	ctx.lr = 0x824B0414;
	sub_825A8448(ctx, base);
	// 824B0414: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B04B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B04B8 size=140
    let mut pc: u32 = 0x824B04B8;
    'dispatch: loop {
        match pc {
            0x824B04B8 => {
    //   block [0x824B04B8..0x824B04DC)
	// 824B04B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B04BC: 48084C01  bl 0x825350bc
	ctx.lr = 0x824B04C0;
	sub_82535080(ctx, base);
	// 824B04C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B04C4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824B04C8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 824B04CC: 396BF6FC  addi r11, r11, -0x904
	ctx.r[11].s64 = ctx.r[11].s64 + -2308;
	// 824B04D0: 3BFD00E0  addi r31, r29, 0xe0
	ctx.r[31].s64 = ctx.r[29].s64 + 224;
	// 824B04D4: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 824B04D8: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x824B04DC; continue 'dispatch;
            }
            0x824B04DC => {
    //   block [0x824B04DC..0x824B0520)
	// 824B04DC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B04E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 824B04E4: 419A003C  beq cr6, 0x824b0520
	if ctx.cr[6].eq {
	pc = 0x824B0520; continue 'dispatch;
	}
	// 824B04E8: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B04EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B04F0: 419A0030  beq cr6, 0x824b0520
	if ctx.cr[6].eq {
	pc = 0x824B0520; continue 'dispatch;
	}
	// 824B04F4: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 824B04F8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824B04FC: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824B0500: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B0504: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824B0508: 409A0018  bne cr6, 0x824b0520
	if !ctx.cr[6].eq {
	pc = 0x824B0520; continue 'dispatch;
	}
	// 824B050C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B0510: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824B0514: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B0518: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B051C: 4E800421  bctrl
	ctx.lr = 0x824B0520;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824B0520 => {
    //   block [0x824B0520..0x824B0544)
	// 824B0520: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 824B0524: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 824B0528: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 824B052C: 409AFFB0  bne cr6, 0x824b04dc
	if !ctx.cr[6].eq {
	pc = 0x824B04DC; continue 'dispatch;
	}
	// 824B0530: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824B0534: 396B6DD0  addi r11, r11, 0x6dd0
	ctx.r[11].s64 = ctx.r[11].s64 + 28112;
	// 824B0538: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824B053C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824B0540: 48084BCC  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B0548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824B0548 size=112
    let mut pc: u32 = 0x824B0548;
    'dispatch: loop {
        match pc {
            0x824B0548 => {
    //   block [0x824B0548..0x824B05B8)
	// 824B0548: 7CAB0774  extsb r11, r5
	ctx.r[11].s64 = ctx.r[5].s8 as i64;
	// 824B054C: 98A300A2  stb r5, 0xa2(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(162 as u32), ctx.r[5].u8 ) };
	// 824B0550: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 824B0554: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 824B0558: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 824B055C: 996300F2  stb r11, 0xf2(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(242 as u32), ctx.r[11].u8 ) };
	// 824B0560: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 824B0564: 81640028  lwz r11, 0x28(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 824B0568: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B056C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 824B0570: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 824B0574: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B0578: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 824B057C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 824B0580: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B0584: D00B0018  stfs f0, 0x18(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 824B0588: D00B001C  stfs f0, 0x1c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 824B058C: D00B0020  stfs f0, 0x20(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 824B0590: D00B0024  stfs f0, 0x24(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 824B0594: D00B0028  stfs f0, 0x28(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 824B0598: D00B002C  stfs f0, 0x2c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 824B059C: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 824B05A0: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 824B05A4: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 824B05A8: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 824B05AC: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 824B05B0: D00B0014  stfs f0, 0x14(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 824B05B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B05B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B05B8 size=480
    let mut pc: u32 = 0x824B05B8;
    'dispatch: loop {
        match pc {
            0x824B05B8 => {
    //   block [0x824B05B8..0x824B0798)
	// 824B05B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B05BC: 48084AFD  bl 0x825350b8
	ctx.lr = 0x824B05C0;
	sub_82535080(ctx, base);
	// 824B05C0: 3941FFC0  addi r10, r1, -0x40
	ctx.r[10].s64 = ctx.r[1].s64 + -64;
	// 824B05C4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 824B05C8: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 824B05CC: 39630010  addi r11, r3, 0x10
	ctx.r[11].s64 = ctx.r[3].s64 + 16;
	// 824B05D0: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B0798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B0798 size=96
    let mut pc: u32 = 0x824B0798;
    'dispatch: loop {
        match pc {
            0x824B0798 => {
    //   block [0x824B0798..0x824B07E0)
	// 824B0798: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B079C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824B07A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824B07A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B07A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824B07AC: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 824B07B0: 419A0030  beq cr6, 0x824b07e0
	if ctx.cr[6].eq {
	pc = 0x824B07E0; continue 'dispatch;
	}
	// 824B07B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824B07B8: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 824B07BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824B07C0: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 824B07C4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824B07C8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 824B07CC: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 824B07D0: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 824B07D4: 4800F435  bl 0x824bfc08
	ctx.lr = 0x824B07D8;
	sub_824BFC08(ctx, base);
	// 824B07D8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B07DC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x824B07E0; continue 'dispatch;
            }
            0x824B07E0 => {
    //   block [0x824B07E0..0x824B07F8)
	// 824B07E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B07E4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824B07E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824B07EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824B07F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824B07F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B0800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B0800 size=12
    let mut pc: u32 = 0x824B0800;
    'dispatch: loop {
        match pc {
            0x824B0800 => {
    //   block [0x824B0800..0x824B080C)
	// 824B0800: 8964000C  lbz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B0804: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824B0808: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B0810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824B0810 size=12
    let mut pc: u32 = 0x824B0810;
    'dispatch: loop {
        match pc {
            0x824B0810 => {
    //   block [0x824B0810..0x824B081C)
	// 824B0810: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824B0814: C02B1FF8  lfs f1, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 824B0818: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B0830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824B0830 size=216
    let mut pc: u32 = 0x824B0830;
    'dispatch: loop {
        match pc {
            0x824B0830 => {
    //   block [0x824B0830..0x824B086C)
	// 824B0830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B0834: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824B0838: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824B083C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824B0840: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 824B0844: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B0848: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 824B084C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824B0850: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824B0854: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 824B0858: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B085C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 824B0860: 4098000C  bge cr6, 0x824b086c
	if !ctx.cr[6].lt {
	pc = 0x824B086C; continue 'dispatch;
	}
	// 824B0864: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824B0868: 4800000C  b 0x824b0874
	pc = 0x824B0874; continue 'dispatch;
            }
            0x824B086C => {
    //   block [0x824B086C..0x824B0874)
	// 824B086C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 824B0870: 480FB629  bl 0x825abe98
	ctx.lr = 0x824B0874;
	sub_825ABE98(ctx, base);
	pc = 0x824B0874; continue 'dispatch;
            }
            0x824B0874 => {
    //   block [0x824B0874..0x824B08E0)
	// 824B0874: 7C6B07B4  extsw r11, r3
	ctx.r[11].s64 = ctx.r[3].s32 as i64;
	// 824B0878: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 824B087C: 39230001  addi r9, r3, 1
	ctx.r[9].s64 = ctx.r[3].s64 + 1;
	// 824B0880: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 824B0884: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 824B0888: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 824B088C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 824B0890: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 824B0894: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 824B0898: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 824B089C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 824B08A0: 40980040  bge cr6, 0x824b08e0
	if !ctx.cr[6].lt {
	pc = 0x824B08E0; continue 'dispatch;
	}
	// 824B08A4: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 824B08A8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 824B08AC: 55292036  slwi r9, r9, 4
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 824B08B0: 394A9F60  addi r10, r10, -0x60a0
	ctx.r[10].s64 = ctx.r[10].s64 + -24736;
	pc = 0x824B08E0; continue 'dispatch;
            }
            0x824B08E0 => {
    //   block [0x824B08E0..0x824B0908)
	// 824B08E0: 546A2036  slwi r10, r3, 4
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B0908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824B0908 size=724
    let mut pc: u32 = 0x824B0908;
    'dispatch: loop {
        match pc {
            0x824B0908 => {
    //   block [0x824B0908..0x824B0938)
	// 824B0908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B090C: 48084799  bl 0x825350a4
	ctx.lr = 0x824B0910;
	sub_82535080(ctx, base);
	// 824B0910: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 824B0914: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B0918: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824B091C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824B0920: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 824B0924: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 824B0928: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 824B092C: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 824B0930: 40980008  bge cr6, 0x824b0938
	if !ctx.cr[6].lt {
	pc = 0x824B0938; continue 'dispatch;
	}
	// 824B0934: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	pc = 0x824B0938; continue 'dispatch;
            }
            0x824B0938 => {
    //   block [0x824B0938..0x824B0958)
	// 824B0938: 480FB561  bl 0x825abe98
	ctx.lr = 0x824B093C;
	sub_825ABE98(ctx, base);
	// 824B093C: 839F0024  lwz r28, 0x24(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 824B0940: 39430001  addi r10, r3, 1
	ctx.r[10].s64 = ctx.r[3].s64 + 1;
	// 824B0944: 3B3F0024  addi r25, r31, 0x24
	ctx.r[25].s64 = ctx.r[31].s64 + 36;
	// 824B0948: 7F0AE000  cmpw cr6, r10, r28
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[28].s32, &mut ctx.xer);
	// 824B094C: 4198000C  blt cr6, 0x824b0958
	if ctx.cr[6].lt {
	pc = 0x824B0958; continue 'dispatch;
	}
	// 824B0950: 395CFFFF  addi r10, r28, -1
	ctx.r[10].s64 = ctx.r[28].s64 + -1;
	// 824B0954: 386AFFFF  addi r3, r10, -1
	ctx.r[3].s64 = ctx.r[10].s64 + -1;
	pc = 0x824B0958; continue 'dispatch;
            }
            0x824B0958 => {
    //   block [0x824B0958..0x824B0BDC)
	// 824B0958: 80BF0020  lwz r5, 0x20(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 824B095C: 54682036  slwi r8, r3, 4
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B0BE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824B0BE0 size=660
    let mut pc: u32 = 0x824B0BE0;
    'dispatch: loop {
        match pc {
            0x824B0BE0 => {
    //   block [0x824B0BE0..0x824B0C38)
	// 824B0BE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B0BE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824B0BE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824B0BEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824B0BF0: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 824B0BF4: 480853F5  bl 0x82535fe8
	ctx.lr = 0x824B0BF8;
	sub_82535FB0(ctx, base);
	// 824B0BF8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B0BFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824B0C00: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 824B0C04: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824B0C08: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 824B0C0C: C3DF0008  lfs f30, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 824B0C10: C3EB1850  lfs f31, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 824B0C14: EF9FF024  fdivs f28, f31, f30
	ctx.f[28].f64 = ((ctx.f[31].f64 / ctx.f[30].f64) as f32) as f64;
	// 824B0C18: 480FB281  bl 0x825abe98
	ctx.lr = 0x824B0C1C;
	sub_825ABE98(ctx, base);
	// 824B0C1C: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 824B0C20: 39630001  addi r11, r3, 1
	ctx.r[11].s64 = ctx.r[3].s64 + 1;
	// 824B0C24: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 824B0C28: 41980010  blt cr6, 0x824b0c38
	if ctx.cr[6].lt {
	pc = 0x824B0C38; continue 'dispatch;
	}
	// 824B0C2C: 396AFFFF  addi r11, r10, -1
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	// 824B0C30: 386BFFFF  addi r3, r11, -1
	ctx.r[3].s64 = ctx.r[11].s64 + -1;
	// 824B0C34: 48000014  b 0x824b0c48
	pc = 0x824B0C48; continue 'dispatch;
            }
            0x824B0C38 => {
    //   block [0x824B0C38..0x824B0C48)
	// 824B0C38: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 824B0C3C: 4098000C  bge cr6, 0x824b0c48
	if !ctx.cr[6].lt {
	pc = 0x824B0C48; continue 'dispatch;
	}
	// 824B0C40: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824B0C44: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x824B0C48; continue 'dispatch;
            }
            0x824B0C48 => {
    //   block [0x824B0C48..0x824B0E74)
	// 824B0C48: 811F0020  lwz r8, 0x20(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 824B0C4C: 546A2036  slwi r10, r3, 4
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824B0C50: 55692036  slwi r9, r11, 4
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 824B0C54: 7C6707B4  extsw r7, r3
	ctx.r[7].s64 = ctx.r[3].s32 as i64;
	// 824B0C58: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B0E78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B0E78 size=32
    let mut pc: u32 = 0x824B0E78;
    'dispatch: loop {
        match pc {
            0x824B0E78 => {
    //   block [0x824B0E78..0x824B0E98)
	// 824B0E78: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 824B0E7C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824B0E80: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 824B0E84: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 824B0E88: C801FFF0  lfd f0, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824B0E8C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 824B0E90: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 824B0E94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B0E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824B0E98 size=172
    let mut pc: u32 = 0x824B0E98;
    'dispatch: loop {
        match pc {
            0x824B0E98 => {
    //   block [0x824B0E98..0x824B0EE4)
	// 824B0E98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B0E9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824B0EA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824B0EA4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 824B0EA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B0EAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824B0EB0: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 824B0EB4: 480FAFE5  bl 0x825abe98
	ctx.lr = 0x824B0EB8;
	sub_825ABE98(ctx, base);
	// 824B0EB8: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 824B0EBC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824B0EC0: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824B0EC4: 41980020  blt cr6, 0x824b0ee4
	if ctx.cr[6].lt {
	pc = 0x824B0EE4; continue 'dispatch;
	}
	// 824B0EC8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 824B0ECC: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 824B0ED0: 546B103A  slwi r11, r3, 2
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824B0ED4: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 824B0ED8: C00A0000  lfs f0, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B0EDC: C1AAFFFC  lfs f13, -4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824B0EE0: 48000024  b 0x824b0f04
	pc = 0x824B0F04; continue 'dispatch;
            }
            0x824B0EE4 => {
    //   block [0x824B0EE4..0x824B0EF0)
	// 824B0EE4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 824B0EE8: 40980008  bge cr6, 0x824b0ef0
	if !ctx.cr[6].lt {
	pc = 0x824B0EF0; continue 'dispatch;
	}
	// 824B0EEC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x824B0EF0; continue 'dispatch;
            }
            0x824B0EF0 => {
    //   block [0x824B0EF0..0x824B0F04)
	// 824B0EF0: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 824B0EF4: 546B103A  slwi r11, r3, 2
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824B0EF8: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 824B0EFC: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B0F00: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x824B0F04; continue 'dispatch;
            }
            0x824B0F04 => {
    //   block [0x824B0F04..0x824B0F44)
	// 824B0F04: 7C6A07B4  extsw r10, r3
	ctx.r[10].s64 = ctx.r[3].s32 as i64;
	// 824B0F08: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 824B0F0C: 813F002C  lwz r9, 0x2c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 824B0F10: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 824B0F14: 7DA95C2E  lfsx f13, r9, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824B0F18: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 824B0F1C: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 824B0F20: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 824B0F24: ED9F6028  fsubs f12, f31, f12
	ctx.f[12].f64 = (((ctx.f[31].f64 - ctx.f[12].f64) as f32) as f64);
	// 824B0F28: EC2C683A  fmadds f1, f12, f0, f13
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 824B0F2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824B0F30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824B0F34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824B0F38: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824B0F3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824B0F40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B0F48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B0F48 size=348
    let mut pc: u32 = 0x824B0F48;
    'dispatch: loop {
        match pc {
            0x824B0F48 => {
    //   block [0x824B0F48..0x824B10A4)
	// 824B0F48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B0F4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824B0F50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824B0F54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824B0F58: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B0F5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824B0F60: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 824B0F64: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 824B0F68: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B0F6C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 824B0F70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B0F74: 4E800421  bctrl
	ctx.lr = 0x824B0F78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824B0F78: 3D608283  lis r11, -0x7d7d
	ctx.r[11].s64 = -2105344000;
	// 824B0F7C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 824B0F80: 396B2690  addi r11, r11, 0x2690
	ctx.r[11].s64 = ctx.r[11].s64 + 9872;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B10A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824B10A8 size=120
    let mut pc: u32 = 0x824B10A8;
    'dispatch: loop {
        match pc {
            0x824B10A8 => {
    //   block [0x824B10A8..0x824B1120)
	// 824B10A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824B10AC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 824B10B0: 3D208000  lis r9, -0x8000
	ctx.r[9].s64 = -2147483648;
	// 824B10B4: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B10B8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824B10BC: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 824B10C0: B1030006  sth r8, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[8].u16 ) };
	// 824B10C4: D001FFF8  stfs f0, -8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 824B10C8: D001FFFC  stfs f0, -4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 824B10CC: C1AB1850  lfs f13, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824B10D0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824B10D4: D1A1FFF4  stfs f13, -0xc(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 824B10D8: 3901FFF0  addi r8, r1, -0x10
	ctx.r[8].s64 = ctx.r[1].s64 + -16;
	// 824B10DC: 394BF99C  addi r10, r11, -0x664
	ctx.r[10].s64 = ctx.r[11].s64 + -1636;
	// 824B10E0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B1120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B1120 size=388
    let mut pc: u32 = 0x824B1120;
    'dispatch: loop {
        match pc {
            0x824B1120 => {
    //   block [0x824B1120..0x824B1158)
	// 824B1120: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B1124: 48083F99  bl 0x825350bc
	ctx.lr = 0x824B1128;
	sub_82535080(ctx, base);
	// 824B1128: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B112C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824B1130: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 824B1134: 3BFE0020  addi r31, r30, 0x20
	ctx.r[31].s64 = ctx.r[30].s64 + 32;
	// 824B1138: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B113C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1140: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824B1144: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824B1148: 409A0010  bne cr6, 0x824b1158
	if !ctx.cr[6].eq {
	pc = 0x824B1158; continue 'dispatch;
	}
	// 824B114C: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 824B1150: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B1154: 4BFBD1FD  bl 0x8246e350
	ctx.lr = 0x824B1158;
	sub_8246E350(ctx, base);
	pc = 0x824B1158; continue 'dispatch;
            }
            0x824B1158 => {
    //   block [0x824B1158..0x824B12A4)
	// 824B1158: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B115C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B1160: 556A2036  slwi r10, r11, 4
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824B1164: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 824B1168: 7D6A4A14  add r11, r10, r9
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 824B116C: 911F0004  stw r8, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B12A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B12A8 size=216
    let mut pc: u32 = 0x824B12A8;
    'dispatch: loop {
        match pc {
            0x824B12A8 => {
    //   block [0x824B12A8..0x824B1300)
	// 824B12A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B12AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824B12B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824B12B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824B12B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B12BC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824B12C0: 3BC30020  addi r30, r3, 0x20
	ctx.r[30].s64 = ctx.r[3].s64 + 32;
	// 824B12C4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B12C8: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B12CC: 556A00BE  clrlwi r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824B12D0: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824B12D4: 40980060  bge cr6, 0x824b1334
	if !ctx.cr[6].lt {
	pc = 0x824B1334; continue 'dispatch;
	}
	// 824B12D8: 556B0000  rlwinm r11, r11, 0, 0, 0
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824B12DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B12E0: 409A0020  bne cr6, 0x824b1300
	if !ctx.cr[6].eq {
	pc = 0x824B1300; continue 'dispatch;
	}
	// 824B12E4: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B12E8: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824B12EC: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824B12F0: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B12F4: 55452036  slwi r5, r10, 4
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824B12F8: 7C69582E  lwzx r3, r9, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824B12FC: 4BFB2DBD  bl 0x824640b8
	ctx.lr = 0x824B1300;
	sub_824640B8(ctx, base);
	pc = 0x824B1300; continue 'dispatch;
            }
            0x824B1300 => {
    //   block [0x824B1300..0x824B1334)
	// 824B1300: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B1304: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 824B1308: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B130C: 38A00017  li r5, 0x17
	ctx.r[5].s64 = 23;
	// 824B1310: 55242036  slwi r4, r9, 4
	ctx.r[4].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 824B1314: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824B1318: 4BFB2D21  bl 0x82464038
	ctx.lr = 0x824B131C;
	sub_82464038(ctx, base);
	// 824B131C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B1320: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 824B1324: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1328: 556B0042  rlwinm r11, r11, 0, 1, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824B132C: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 824B1330: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x824B1334; continue 'dispatch;
            }
            0x824B1334 => {
    //   block [0x824B1334..0x824B1368)
	// 824B1334: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1338: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B133C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824B1340: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 824B1344: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B1348: 40990020  ble cr6, 0x824b1368
	if !ctx.cr[6].gt {
	pc = 0x824B1368; continue 'dispatch;
	}
	// 824B134C: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 824B1350: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	pc = 0x824B1368; continue 'dispatch;
            }
            0x824B1368 => {
    //   block [0x824B1368..0x824B1380)
	// 824B1368: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824B136C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824B1370: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824B1374: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824B1378: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824B137C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B1380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B1380 size=60
    let mut pc: u32 = 0x824B1380;
    'dispatch: loop {
        match pc {
            0x824B1380 => {
    //   block [0x824B1380..0x824B13BC)
	// 824B1380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B1384: 48083D39  bl 0x825350bc
	ctx.lr = 0x824B1388;
	sub_82535080(ctx, base);
	// 824B1388: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B138C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824B1390: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 824B1394: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 824B1398: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 824B139C: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 824B13A0: 480FA7B1  bl 0x825abb50
	ctx.lr = 0x824B13A4;
	sub_825ABB50(ctx, base);
	// 824B13A4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 824B13A8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824B13AC: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 824B13B0: 480FA7A1  bl 0x825abb50
	ctx.lr = 0x824B13B4;
	sub_825ABB50(ctx, base);
	// 824B13B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824B13B8: 48083D54  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B13C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B13C0 size=28
    let mut pc: u32 = 0x824B13C0;
    'dispatch: loop {
        match pc {
            0x824B13C0 => {
    //   block [0x824B13C0..0x824B13DC)
	// 824B13C0: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B13E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B13E0 size=16
    let mut pc: u32 = 0x824B13E0;
    'dispatch: loop {
        match pc {
            0x824B13E0 => {
    //   block [0x824B13E0..0x824B13F0)
	// 824B13E0: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 824B13E4: 38800032  li r4, 0x32
	ctx.r[4].s64 = 50;
	// 824B13E8: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 824B13EC: 4BFF15C4  b 0x824a29b0
	sub_824A29B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B13F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B13F0 size=32
    let mut pc: u32 = 0x824B13F0;
    'dispatch: loop {
        match pc {
            0x824B13F0 => {
    //   block [0x824B13F0..0x824B1410)
	// 824B13F0: 7C8B0774  extsb r11, r4
	ctx.r[11].s64 = ctx.r[4].s8 as i64;
	// 824B13F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B13F8: 419A0018  beq cr6, 0x824b1410
	if ctx.cr[6].eq {
		sub_824B1410(ctx, base);
		return;
	}
	// 824B13FC: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 824B1400: 39400018  li r10, 0x18
	ctx.r[10].s64 = 24;
	// 824B1404: 91650004  stw r11, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824B1408: 91450000  stw r10, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824B140C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B1410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B1410 size=16
    let mut pc: u32 = 0x824B1410;
    'dispatch: loop {
        match pc {
            0x824B1410 => {
    //   block [0x824B1410..0x824B1420)
	// 824B1410: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824B1414: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824B1418: 91650004  stw r11, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824B141C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B1420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B1420 size=12
    let mut pc: u32 = 0x824B1420;
    'dispatch: loop {
        match pc {
            0x824B1420 => {
    //   block [0x824B1420..0x824B142C)
	// 824B1420: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824B1424: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824B1428: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B1430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B1430 size=8
    let mut pc: u32 = 0x824B1430;
    'dispatch: loop {
        match pc {
            0x824B1430 => {
    //   block [0x824B1430..0x824B1438)
	// 824B1430: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824B1434: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B1438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B1438 size=80
    let mut pc: u32 = 0x824B1438;
    'dispatch: loop {
        match pc {
            0x824B1438 => {
    //   block [0x824B1438..0x824B1488)
	// 824B1438: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 824B143C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 824B1440: 392AFA18  addi r9, r10, -0x5e8
	ctx.r[9].s64 = ctx.r[10].s64 + -1512;
	// 824B1444: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 824B1448: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 824B144C: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 824B1450: 39630020  addi r11, r3, 0x20
	ctx.r[11].s64 = ctx.r[3].s64 + 32;
	// 824B1454: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 824B1458: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824B145C: B1430006  sth r10, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 824B1460: 39430030  addi r10, r3, 0x30
	ctx.r[10].s64 = ctx.r[3].s64 + 48;
	// 824B1464: B0E30010  sth r7, 0x10(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[7].u16 ) };
	// 824B1468: B0C30040  sth r6, 0x40(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[6].u16 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B1488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B1488 size=184
    let mut pc: u32 = 0x824B1488;
    'dispatch: loop {
        match pc {
            0x824B1488 => {
    //   block [0x824B1488..0x824B14E4)
	// 824B1488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B148C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824B1490: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824B1494: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B1498: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824B149C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B14A0: 896A0004  lbz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B14A4: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 824B14A8: 409A003C  bne cr6, 0x824b14e4
	if !ctx.cr[6].eq {
	pc = 0x824B14E4; continue 'dispatch;
	}
	// 824B14AC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B14B0: 892A0005  lbz r9, 5(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B14B4: 7D280774  extsb r8, r9
	ctx.r[8].s64 = ctx.r[9].s8 as i64;
	// 824B14B8: 88EB0005  lbz r7, 5(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B14BC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 824B14C0: 7CE90774  extsb r9, r7
	ctx.r[9].s64 = ctx.r[7].s8 as i64;
	// 824B14C4: 7C895A14  add r4, r9, r11
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 824B14C8: 896A0010  lbz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B14CC: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824B14D0: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824B14D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B14D8: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 824B14DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B14E0: 4E800421  bctrl
	ctx.lr = 0x824B14E4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824B14E4 => {
    //   block [0x824B14E4..0x824B152C)
	// 824B14E4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B14E8: 896A0004  lbz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B14EC: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 824B14F0: 409A003C  bne cr6, 0x824b152c
	if !ctx.cr[6].eq {
	pc = 0x824B152C; continue 'dispatch;
	}
	// 824B14F4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B14F8: 892A0005  lbz r9, 5(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B14FC: 7D280774  extsb r8, r9
	ctx.r[8].s64 = ctx.r[9].s8 as i64;
	// 824B1500: 88EB0005  lbz r7, 5(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B1504: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 824B1508: 7CE90774  extsb r9, r7
	ctx.r[9].s64 = ctx.r[7].s8 as i64;
	// 824B150C: 7C895A14  add r4, r9, r11
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 824B1510: 896A0010  lbz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B1514: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824B1518: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824B151C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B1520: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 824B1524: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B1528: 4E800421  bctrl
	ctx.lr = 0x824B152C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824B152C => {
    //   block [0x824B152C..0x824B1540)
	// 824B152C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824B1530: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824B1534: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824B1538: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824B153C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B1540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B1540 size=184
    let mut pc: u32 = 0x824B1540;
    'dispatch: loop {
        match pc {
            0x824B1540 => {
    //   block [0x824B1540..0x824B159C)
	// 824B1540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B1544: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824B1548: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824B154C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B1550: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824B1554: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B1558: 896A0004  lbz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B155C: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 824B1560: 409A003C  bne cr6, 0x824b159c
	if !ctx.cr[6].eq {
	pc = 0x824B159C; continue 'dispatch;
	}
	// 824B1564: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1568: 892A0005  lbz r9, 5(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B156C: 7D280774  extsb r8, r9
	ctx.r[8].s64 = ctx.r[9].s8 as i64;
	// 824B1570: 88EB0005  lbz r7, 5(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B1574: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 824B1578: 7CE90774  extsb r9, r7
	ctx.r[9].s64 = ctx.r[7].s8 as i64;
	// 824B157C: 7C895A14  add r4, r9, r11
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 824B1580: 896A0010  lbz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B1584: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824B1588: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824B158C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B1590: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 824B1594: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B1598: 4E800421  bctrl
	ctx.lr = 0x824B159C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824B159C => {
    //   block [0x824B159C..0x824B15E4)
	// 824B159C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B15A0: 896A0004  lbz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B15A4: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 824B15A8: 409A003C  bne cr6, 0x824b15e4
	if !ctx.cr[6].eq {
	pc = 0x824B15E4; continue 'dispatch;
	}
	// 824B15AC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B15B0: 892A0005  lbz r9, 5(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B15B4: 7D280774  extsb r8, r9
	ctx.r[8].s64 = ctx.r[9].s8 as i64;
	// 824B15B8: 88EB0005  lbz r7, 5(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B15BC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 824B15C0: 7CE90774  extsb r9, r7
	ctx.r[9].s64 = ctx.r[7].s8 as i64;
	// 824B15C4: 7C895A14  add r4, r9, r11
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 824B15C8: 896A0010  lbz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B15CC: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824B15D0: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824B15D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B15D8: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 824B15DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B15E0: 4E800421  bctrl
	ctx.lr = 0x824B15E4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824B15E4 => {
    //   block [0x824B15E4..0x824B15F8)
	// 824B15E4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824B15E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824B15EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824B15F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824B15F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B15F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B15F8 size=212
    let mut pc: u32 = 0x824B15F8;
    'dispatch: loop {
        match pc {
            0x824B15F8 => {
    //   block [0x824B15F8..0x824B1670)
	// 824B15F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B15FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824B1600: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824B1604: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B1608: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824B160C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B1610: 896A0004  lbz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1614: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824B1618: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 824B161C: 409A0054  bne cr6, 0x824b1670
	if !ctx.cr[6].eq {
	pc = 0x824B1670; continue 'dispatch;
	}
	// 824B1620: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1624: 89290004  lbz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1628: 2B090003  cmplwi cr6, r9, 3
	ctx.cr[6].compare_u32(ctx.r[9].u32, 3 as u32, &mut ctx.xer);
	// 824B162C: 419A008C  beq cr6, 0x824b16b8
	if ctx.cr[6].eq {
	pc = 0x824B16B8; continue 'dispatch;
	}
	// 824B1630: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 824B1634: 409A003C  bne cr6, 0x824b1670
	if !ctx.cr[6].eq {
	pc = 0x824B1670; continue 'dispatch;
	}
	// 824B1638: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B163C: 892A0005  lbz r9, 5(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B1640: 7D280774  extsb r8, r9
	ctx.r[8].s64 = ctx.r[9].s8 as i64;
	// 824B1644: 88EB0005  lbz r7, 5(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B1648: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 824B164C: 7CE90774  extsb r9, r7
	ctx.r[9].s64 = ctx.r[7].s8 as i64;
	// 824B1650: 7C895A14  add r4, r9, r11
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 824B1654: 896A0010  lbz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B1658: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824B165C: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824B1660: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B1664: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 824B1668: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B166C: 4E800421  bctrl
	ctx.lr = 0x824B1670;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824B1670 => {
    //   block [0x824B1670..0x824B16B8)
	// 824B1670: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1674: 896A0004  lbz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1678: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 824B167C: 409A003C  bne cr6, 0x824b16b8
	if !ctx.cr[6].eq {
	pc = 0x824B16B8; continue 'dispatch;
	}
	// 824B1680: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B1684: 892A0005  lbz r9, 5(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B1688: 7D280774  extsb r8, r9
	ctx.r[8].s64 = ctx.r[9].s8 as i64;
	// 824B168C: 88EB0005  lbz r7, 5(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B1690: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 824B1694: 7CE90774  extsb r9, r7
	ctx.r[9].s64 = ctx.r[7].s8 as i64;
	// 824B1698: 7C895A14  add r4, r9, r11
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 824B169C: 896A0010  lbz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B16A0: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824B16A4: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824B16A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B16AC: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 824B16B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B16B4: 4E800421  bctrl
	ctx.lr = 0x824B16B8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824B16B8 => {
    //   block [0x824B16B8..0x824B16CC)
	// 824B16B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824B16BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824B16C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824B16C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824B16C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B16D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B16D0 size=212
    let mut pc: u32 = 0x824B16D0;
    'dispatch: loop {
        match pc {
            0x824B16D0 => {
    //   block [0x824B16D0..0x824B1748)
	// 824B16D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B16D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824B16D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824B16DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B16E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824B16E4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B16E8: 896A0004  lbz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B16EC: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824B16F0: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 824B16F4: 409A0054  bne cr6, 0x824b1748
	if !ctx.cr[6].eq {
	pc = 0x824B1748; continue 'dispatch;
	}
	// 824B16F8: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B16FC: 89290004  lbz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1700: 2B090003  cmplwi cr6, r9, 3
	ctx.cr[6].compare_u32(ctx.r[9].u32, 3 as u32, &mut ctx.xer);
	// 824B1704: 419A008C  beq cr6, 0x824b1790
	if ctx.cr[6].eq {
	pc = 0x824B1790; continue 'dispatch;
	}
	// 824B1708: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 824B170C: 409A003C  bne cr6, 0x824b1748
	if !ctx.cr[6].eq {
	pc = 0x824B1748; continue 'dispatch;
	}
	// 824B1710: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1714: 892A0005  lbz r9, 5(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B1718: 7D280774  extsb r8, r9
	ctx.r[8].s64 = ctx.r[9].s8 as i64;
	// 824B171C: 88EB0005  lbz r7, 5(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B1720: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 824B1724: 7CE90774  extsb r9, r7
	ctx.r[9].s64 = ctx.r[7].s8 as i64;
	// 824B1728: 7C895A14  add r4, r9, r11
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 824B172C: 896A0010  lbz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B1730: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824B1734: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824B1738: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B173C: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 824B1740: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B1744: 4E800421  bctrl
	ctx.lr = 0x824B1748;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824B1748 => {
    //   block [0x824B1748..0x824B1790)
	// 824B1748: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B174C: 896A0004  lbz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1750: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 824B1754: 409A003C  bne cr6, 0x824b1790
	if !ctx.cr[6].eq {
	pc = 0x824B1790; continue 'dispatch;
	}
	// 824B1758: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B175C: 892A0005  lbz r9, 5(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B1760: 7D280774  extsb r8, r9
	ctx.r[8].s64 = ctx.r[9].s8 as i64;
	// 824B1764: 88EB0005  lbz r7, 5(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B1768: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 824B176C: 7CE90774  extsb r9, r7
	ctx.r[9].s64 = ctx.r[7].s8 as i64;
	// 824B1770: 7C895A14  add r4, r9, r11
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 824B1774: 896A0010  lbz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B1778: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824B177C: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824B1780: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B1784: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 824B1788: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B178C: 4E800421  bctrl
	ctx.lr = 0x824B1790;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824B1790 => {
    //   block [0x824B1790..0x824B17A4)
	// 824B1790: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824B1794: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824B1798: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824B179C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824B17A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B17A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B17A8 size=28
    let mut pc: u32 = 0x824B17A8;
    'dispatch: loop {
        match pc {
            0x824B17A8 => {
    //   block [0x824B17A8..0x824B17C4)
	// 824B17A8: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B17AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B17B0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 824B17B4: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 824B17B8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824B17BC: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824B17C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B17C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B17C8 size=56
    let mut pc: u32 = 0x824B17C8;
    'dispatch: loop {
        match pc {
            0x824B17C8 => {
    //   block [0x824B17C8..0x824B1800)
	// 824B17C8: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B17CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B17D0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 824B17D4: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 824B17D8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824B17DC: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824B17E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B17E4: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824B17E8: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 824B17EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B17F0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824B17F4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B17F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B17FC: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B1800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B1800 size=4
    let mut pc: u32 = 0x824B1800;
    'dispatch: loop {
        match pc {
            0x824B1800 => {
    //   block [0x824B1800..0x824B1804)
	// 824B1800: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B1808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B1808 size=80
    let mut pc: u32 = 0x824B1808;
    'dispatch: loop {
        match pc {
            0x824B1808 => {
    //   block [0x824B1808..0x824B184C)
	// 824B1808: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B180C: 81450004  lwz r10, 4(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1810: 816B00B8  lwz r11, 0xb8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) } as u64;
	// 824B1814: 814A00B8  lwz r10, 0xb8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(184 as u32) ) } as u64;
	// 824B1818: A16B0020  lhz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 824B181C: A14A0020  lhz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 824B1820: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 824B1824: 41980034  blt cr6, 0x824b1858
	if ctx.cr[6].lt {
		sub_824B1858(ctx, base);
		return;
	}
	// 824B1828: 409A0024  bne cr6, 0x824b184c
	if !ctx.cr[6].eq {
	pc = 0x824B184C; continue 'dispatch;
	}
	// 824B182C: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B1830: 81450008  lwz r10, 8(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B1834: 816B00B8  lwz r11, 0xb8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) } as u64;
	// 824B1838: 814A00B8  lwz r10, 0xb8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(184 as u32) ) } as u64;
	// 824B183C: A16B0020  lhz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 824B1840: A14A0020  lhz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 824B1844: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 824B1848: 41980010  blt cr6, 0x824b1858
	if ctx.cr[6].lt {
		sub_824B1858(ctx, base);
		return;
	}
	pc = 0x824B184C; continue 'dispatch;
            }
            0x824B184C => {
    //   block [0x824B184C..0x824B1858)
	// 824B184C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824B1850: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824B1854: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B1858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B1858 size=12
    let mut pc: u32 = 0x824B1858;
    'dispatch: loop {
        match pc {
            0x824B1858 => {
    //   block [0x824B1858..0x824B1864)
	// 824B1858: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824B185C: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 824B1860: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B1868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B1868 size=184
    let mut pc: u32 = 0x824B1868;
    'dispatch: loop {
        match pc {
            0x824B1868 => {
    //   block [0x824B1868..0x824B18E0)
	// 824B1868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B186C: 48083845  bl 0x825350b0
	ctx.lr = 0x824B1870;
	sub_82535080(ctx, base);
	// 824B1870: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B1874: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824B1878: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 824B187C: 3B7F0020  addi r27, r31, 0x20
	ctx.r[27].s64 = ctx.r[31].s64 + 32;
	// 824B1880: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 824B1884: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 824B1888: 3BDB0028  addi r30, r27, 0x28
	ctx.r[30].s64 = ctx.r[27].s64 + 40;
	// 824B188C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 824B1890: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 824B1894: 39200FA0  li r9, 0xfa0
	ctx.r[9].s64 = 4000;
	// 824B1898: 3B8B9198  addi r28, r11, -0x6e68
	ctx.r[28].s64 = ctx.r[11].s64 + -28264;
	// 824B189C: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 824B18A0: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 824B18A4: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 824B18A8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824B18AC: 93BF0010  stw r29, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 824B18B0: 93BF0014  stw r29, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 824B18B4: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 824B18B8: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824B18BC: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 824B18C0: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 824B18C4: 4BFB48B5  bl 0x82466178
	ctx.lr = 0x824B18C8;
	sub_82466178(ctx, base);
	// 824B18C8: 817C0030  lwz r11, 0x30(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) } as u64;
	// 824B18CC: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 824B18D0: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824B18D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B18D8: 419A0008  beq cr6, 0x824b18e0
	if ctx.cr[6].eq {
	pc = 0x824B18E0; continue 'dispatch;
	}
	// 824B18DC: 936B002C  stw r27, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[27].u32 ) };
	pc = 0x824B18E0; continue 'dispatch;
            }
            0x824B18E0 => {
    //   block [0x824B18E0..0x824B1920)
	// 824B18E0: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 824B18E4: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 824B18E8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824B18EC: 937C0030  stw r27, 0x30(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(48 as u32), ctx.r[27].u32 ) };
	// 824B18F0: F97C0020  std r11, 0x20(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(32 as u32), ctx.r[11].u64 ) };
	// 824B18F4: 4825B979  bl 0x8270d26c
	ctx.lr = 0x824B18F8;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 824B18F8: 38800FA0  li r4, 0xfa0
	ctx.r[4].s64 = 4000;
	// 824B18FC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 824B1900: 4825C41D  bl 0x8270dd1c
	ctx.lr = 0x824B1904;
	// extern call 0x8270DD1C  crate::xboxkrnl::RtlInitializeCriticalSectionAndSpinCount
	crate::xboxkrnl::RtlInitializeCriticalSectionAndSpinCount(ctx, base);
	// 824B1904: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 824B1908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B190C: F97B0020  std r11, 0x20(r27)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[27].u32.wrapping_add(32 as u32), ctx.r[11].u64 ) };
	// 824B1910: 935F000C  stw r26, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 824B1914: 9BBF001C  stb r29, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[29].u8 ) };
	// 824B1918: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 824B191C: 480837E4  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B1920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B1920 size=160
    let mut pc: u32 = 0x824B1920;
    'dispatch: loop {
        match pc {
            0x824B1920 => {
    //   block [0x824B1920..0x824B1974)
	// 824B1920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B1924: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824B1928: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824B192C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B1930: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824B1934: 387F0048  addi r3, r31, 0x48
	ctx.r[3].s64 = ctx.r[31].s64 + 72;
	// 824B1938: 4BFB49E9  bl 0x82466320
	ctx.lr = 0x824B193C;
	sub_82466320(ctx, base);
	// 824B193C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 824B1940: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824B1944: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824B1948: 409A002C  bne cr6, 0x824b1974
	if !ctx.cr[6].eq {
	pc = 0x824B1974; continue 'dispatch;
	}
	// 824B194C: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B1950: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824B1954: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824B1958: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B195C: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824B1960: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824B1964: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824B1968: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824B196C: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824B1970: 4BFB2749  bl 0x824640b8
	ctx.lr = 0x824B1974;
	sub_824640B8(ctx, base);
	pc = 0x824B1974; continue 'dispatch;
            }
            0x824B1974 => {
    //   block [0x824B1974..0x824B19AC)
	// 824B1974: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B1978: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824B197C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824B1980: 409A002C  bne cr6, 0x824b19ac
	if !ctx.cr[6].eq {
	pc = 0x824B19AC; continue 'dispatch;
	}
	// 824B1984: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B1988: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824B198C: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824B1990: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B1994: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824B1998: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824B199C: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824B19A0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824B19A4: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824B19A8: 4BFB2711  bl 0x824640b8
	ctx.lr = 0x824B19AC;
	sub_824640B8(ctx, base);
	pc = 0x824B19AC; continue 'dispatch;
            }
            0x824B19AC => {
    //   block [0x824B19AC..0x824B19C0)
	// 824B19AC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824B19B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824B19B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824B19B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824B19BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B19C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B19C0 size=1520
    let mut pc: u32 = 0x824B19C0;
    'dispatch: loop {
        match pc {
            0x824B19C0 => {
    //   block [0x824B19C0..0x824B1A00)
	// 824B19C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B19C4: 480836F5  bl 0x825350b8
	ctx.lr = 0x824B19C8;
	sub_82535080(ctx, base);
	// 824B19C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B19CC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 824B19D0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 824B19D4: 3B9D0020  addi r28, r29, 0x20
	ctx.r[28].s64 = ctx.r[29].s64 + 32;
	// 824B19D8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824B19DC: 4BFB479D  bl 0x82466178
	ctx.lr = 0x824B19E0;
	sub_82466178(ctx, base);
	// 824B19E0: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B19E4: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B19E8: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824B19EC: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824B19F0: 409A0010  bne cr6, 0x824b1a00
	if !ctx.cr[6].eq {
	pc = 0x824B1A00; continue 'dispatch;
	}
	// 824B19F4: 38800014  li r4, 0x14
	ctx.r[4].s64 = 20;
	// 824B19F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 824B19FC: 4BFBC955  bl 0x8246e350
	ctx.lr = 0x824B1A00;
	sub_8246E350(ctx, base);
	pc = 0x824B1A00; continue 'dispatch;
            }
            0x824B1A00 => {
    //   block [0x824B1A00..0x824B1B08)
	// 824B1A00: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1A04: 815D000C  lwz r10, 0xc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B1A08: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 824B1A0C: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B1A10: 38EB0001  addi r7, r11, 1
	ctx.r[7].s64 = ctx.r[11].s64 + 1;
	// 824B1A14: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 824B1A18: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824B1A1C: 7FEB4A14  add r31, r11, r9
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 824B1A20: 90FD0004  stw r7, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 824B1A24: 816A0080  lwz r11, 0x80(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 824B1A28: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824B1A2C: 916A0080  stw r11, 0x80(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 824B1A30: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B1A34: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824B1A38: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1A3C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824B1A40: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B1A44: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 824B1A48: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B1A4C: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 824B1A50: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B1A54: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 824B1A58: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B1A5C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824B1A60: 2B0B0021  cmplwi cr6, r11, 0x21
	ctx.cr[6].compare_u32(ctx.r[11].u32, 33 as u32, &mut ctx.xer);
	// 824B1A64: 41990534  bgt cr6, 0x824b1f98
	if ctx.cr[6].gt {
	pc = 0x824B1F98; continue 'dispatch;
	}
	// 824B1A68: 3D80824B  lis r12, -0x7db5
	ctx.r[12].s64 = -2109014016;
	// 824B1A6C: 398C1A80  addi r12, r12, 0x1a80
	ctx.r[12].s64 = ctx.r[12].s64 + 6784;
	// 824B1A70: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 824B1A74: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 824B1A78: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 824B1A7C: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x824B1F7C; continue 'dispatch;
		},
		1 => {
	pc = 0x824B1F7C; continue 'dispatch;
		},
		2 => {
	pc = 0x824B1F7C; continue 'dispatch;
		},
		3 => {
	pc = 0x824B1F7C; continue 'dispatch;
		},
		4 => {
	pc = 0x824B1B08; continue 'dispatch;
		},
		5 => {
	pc = 0x824B1B2C; continue 'dispatch;
		},
		6 => {
	pc = 0x824B1BA0; continue 'dispatch;
		},
		7 => {
	pc = 0x824B1F7C; continue 'dispatch;
		},
		8 => {
	pc = 0x824B1F7C; continue 'dispatch;
		},
		9 => {
	pc = 0x824B1F7C; continue 'dispatch;
		},
		10 => {
	pc = 0x824B1F7C; continue 'dispatch;
		},
		11 => {
	pc = 0x824B1C14; continue 'dispatch;
		},
		12 => {
	pc = 0x824B1F7C; continue 'dispatch;
		},
		13 => {
	pc = 0x824B1F7C; continue 'dispatch;
		},
		14 => {
	pc = 0x824B1CCC; continue 'dispatch;
		},
		15 => {
	pc = 0x824B1D40; continue 'dispatch;
		},
		16 => {
	pc = 0x824B1DB4; continue 'dispatch;
		},
		17 => {
	pc = 0x824B1F7C; continue 'dispatch;
		},
		18 => {
	pc = 0x824B1F7C; continue 'dispatch;
		},
		19 => {
	pc = 0x824B1F98; continue 'dispatch;
		},
		20 => {
	pc = 0x824B1F7C; continue 'dispatch;
		},
		21 => {
	pc = 0x824B1E70; continue 'dispatch;
		},
		22 => {
	pc = 0x824B1F7C; continue 'dispatch;
		},
		23 => {
	pc = 0x824B1F7C; continue 'dispatch;
		},
		24 => {
	pc = 0x824B1F7C; continue 'dispatch;
		},
		25 => {
	pc = 0x824B1F7C; continue 'dispatch;
		},
		26 => {
	pc = 0x824B1F7C; continue 'dispatch;
		},
		27 => {
	pc = 0x824B1F7C; continue 'dispatch;
		},
		28 => {
	pc = 0x824B1EE4; continue 'dispatch;
		},
		29 => {
	pc = 0x824B1F20; continue 'dispatch;
		},
		30 => {
	pc = 0x824B1F98; continue 'dispatch;
		},
		31 => {
	pc = 0x824B1F7C; continue 'dispatch;
		},
		32 => {
	pc = 0x824B1F7C; continue 'dispatch;
		},
		33 => {
	pc = 0x824B1F7C; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 824B1A80: 824B1F7C  lwz r18, 0x1f7c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8060 as u32) ) } as u64;
	// 824B1A84: 824B1F7C  lwz r18, 0x1f7c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8060 as u32) ) } as u64;
	// 824B1A88: 824B1F7C  lwz r18, 0x1f7c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8060 as u32) ) } as u64;
	// 824B1A8C: 824B1F7C  lwz r18, 0x1f7c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8060 as u32) ) } as u64;
	// 824B1A90: 824B1B08  lwz r18, 0x1b08(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6920 as u32) ) } as u64;
	// 824B1A94: 824B1B2C  lwz r18, 0x1b2c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6956 as u32) ) } as u64;
	// 824B1A98: 824B1BA0  lwz r18, 0x1ba0(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7072 as u32) ) } as u64;
	// 824B1A9C: 824B1F7C  lwz r18, 0x1f7c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8060 as u32) ) } as u64;
	// 824B1AA0: 824B1F7C  lwz r18, 0x1f7c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8060 as u32) ) } as u64;
	// 824B1AA4: 824B1F7C  lwz r18, 0x1f7c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8060 as u32) ) } as u64;
	// 824B1AA8: 824B1F7C  lwz r18, 0x1f7c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8060 as u32) ) } as u64;
	// 824B1AAC: 824B1C14  lwz r18, 0x1c14(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7188 as u32) ) } as u64;
	// 824B1AB0: 824B1F7C  lwz r18, 0x1f7c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8060 as u32) ) } as u64;
	// 824B1AB4: 824B1F7C  lwz r18, 0x1f7c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8060 as u32) ) } as u64;
	// 824B1AB8: 824B1CCC  lwz r18, 0x1ccc(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7372 as u32) ) } as u64;
	// 824B1ABC: 824B1D40  lwz r18, 0x1d40(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7488 as u32) ) } as u64;
	// 824B1AC0: 824B1DB4  lwz r18, 0x1db4(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7604 as u32) ) } as u64;
	// 824B1AC4: 824B1F7C  lwz r18, 0x1f7c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8060 as u32) ) } as u64;
	// 824B1AC8: 824B1F7C  lwz r18, 0x1f7c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8060 as u32) ) } as u64;
	// 824B1ACC: 824B1F98  lwz r18, 0x1f98(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8088 as u32) ) } as u64;
	// 824B1AD0: 824B1F7C  lwz r18, 0x1f7c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8060 as u32) ) } as u64;
	// 824B1AD4: 824B1E70  lwz r18, 0x1e70(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7792 as u32) ) } as u64;
	// 824B1AD8: 824B1F7C  lwz r18, 0x1f7c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8060 as u32) ) } as u64;
	// 824B1ADC: 824B1F7C  lwz r18, 0x1f7c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8060 as u32) ) } as u64;
	// 824B1AE0: 824B1F7C  lwz r18, 0x1f7c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8060 as u32) ) } as u64;
	// 824B1AE4: 824B1F7C  lwz r18, 0x1f7c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8060 as u32) ) } as u64;
	// 824B1AE8: 824B1F7C  lwz r18, 0x1f7c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8060 as u32) ) } as u64;
	// 824B1AEC: 824B1F7C  lwz r18, 0x1f7c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8060 as u32) ) } as u64;
	// 824B1AF0: 824B1EE4  lwz r18, 0x1ee4(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7908 as u32) ) } as u64;
	// 824B1AF4: 824B1F20  lwz r18, 0x1f20(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7968 as u32) ) } as u64;
	// 824B1AF8: 824B1F98  lwz r18, 0x1f98(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8088 as u32) ) } as u64;
	// 824B1AFC: 824B1F7C  lwz r18, 0x1f7c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8060 as u32) ) } as u64;
	// 824B1B00: 824B1F7C  lwz r18, 0x1f7c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8060 as u32) ) } as u64;
	// 824B1B04: 824B1F7C  lwz r18, 0x1f7c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8060 as u32) ) } as u64;
            }
            0x824B1B08 => {
    //   block [0x824B1B08..0x824B1B24)
	// 824B1B08: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1B0C: A14B0004  lhz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1B10: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824B1B14: 419A0010  beq cr6, 0x824b1b24
	if ctx.cr[6].eq {
	pc = 0x824B1B24; continue 'dispatch;
	}
	// 824B1B18: A14B0006  lhz r10, 6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 824B1B1C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824B1B20: B14B0006  sth r10, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	pc = 0x824B1B24; continue 'dispatch;
            }
            0x824B1B24 => {
    //   block [0x824B1B24..0x824B1B2C)
	// 824B1B24: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B1B28: 48000458  b 0x824b1f80
	pc = 0x824B1F80; continue 'dispatch;
            }
            0x824B1B2C => {
    //   block [0x824B1B2C..0x824B1B74)
	// 824B1B2C: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B1B30: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824B1B34: A17F0008  lhz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B1B38: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 824B1B3C: 5564103E  rotlwi r4, r11, 2
	ctx.r[4].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 824B1B40: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824B1B44: 4BFB24F5  bl 0x82464038
	ctx.lr = 0x824B1B48;
	sub_82464038(ctx, base);
	// 824B1B48: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 824B1B4C: A17E0008  lhz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B1B50: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1B54: 5565103E  rotlwi r5, r11, 2
	ctx.r[5].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 824B1B58: 4BFB87D1  bl 0x8246a328
	ctx.lr = 0x824B1B5C;
	sub_8246A328(ctx, base);
	// 824B1B5C: A15F0008  lhz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B1B60: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1B64: 554A103E  rotlwi r10, r10, 2
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 824B1B68: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 824B1B6C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824B1B70: 40980428  bge cr6, 0x824b1f98
	if !ctx.cr[6].lt {
	pc = 0x824B1F98; continue 'dispatch;
	}
	pc = 0x824B1B74; continue 'dispatch;
            }
            0x824B1B74 => {
    //   block [0x824B1B74..0x824B1B90)
	// 824B1B74: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B1B78: A10A0004  lhz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1B7C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 824B1B80: 419A0010  beq cr6, 0x824b1b90
	if ctx.cr[6].eq {
	pc = 0x824B1B90; continue 'dispatch;
	}
	// 824B1B84: A10A0006  lhz r8, 6(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 824B1B88: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 824B1B8C: B10A0006  sth r8, 6(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(6 as u32), ctx.r[8].u16 ) };
	pc = 0x824B1B90; continue 'dispatch;
            }
            0x824B1B90 => {
    //   block [0x824B1B90..0x824B1BA0)
	// 824B1B90: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824B1B94: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824B1B98: 4198FFDC  blt cr6, 0x824b1b74
	if ctx.cr[6].lt {
	pc = 0x824B1B74; continue 'dispatch;
	}
	// 824B1B9C: 480003FC  b 0x824b1f98
	pc = 0x824B1F98; continue 'dispatch;
            }
            0x824B1BA0 => {
    //   block [0x824B1BA0..0x824B1BE8)
	// 824B1BA0: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B1BA4: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824B1BA8: A17F0008  lhz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B1BAC: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 824B1BB0: 5564103E  rotlwi r4, r11, 2
	ctx.r[4].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 824B1BB4: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824B1BB8: 4BFB2481  bl 0x82464038
	ctx.lr = 0x824B1BBC;
	sub_82464038(ctx, base);
	// 824B1BBC: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 824B1BC0: A17E0008  lhz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B1BC4: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1BC8: 5565103E  rotlwi r5, r11, 2
	ctx.r[5].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 824B1BCC: 4BFB875D  bl 0x8246a328
	ctx.lr = 0x824B1BD0;
	sub_8246A328(ctx, base);
	// 824B1BD0: A15F0008  lhz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B1BD4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1BD8: 554A103E  rotlwi r10, r10, 2
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 824B1BDC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 824B1BE0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824B1BE4: 409803B4  bge cr6, 0x824b1f98
	if !ctx.cr[6].lt {
	pc = 0x824B1F98; continue 'dispatch;
	}
	pc = 0x824B1BE8; continue 'dispatch;
            }
            0x824B1BE8 => {
    //   block [0x824B1BE8..0x824B1C04)
	// 824B1BE8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B1BEC: A10A0004  lhz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1BF0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 824B1BF4: 419A0010  beq cr6, 0x824b1c04
	if ctx.cr[6].eq {
	pc = 0x824B1C04; continue 'dispatch;
	}
	// 824B1BF8: A10A0006  lhz r8, 6(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 824B1BFC: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 824B1C00: B10A0006  sth r8, 6(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(6 as u32), ctx.r[8].u16 ) };
	pc = 0x824B1C04; continue 'dispatch;
            }
            0x824B1C04 => {
    //   block [0x824B1C04..0x824B1C14)
	// 824B1C04: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824B1C08: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824B1C0C: 4198FFDC  blt cr6, 0x824b1be8
	if ctx.cr[6].lt {
	pc = 0x824B1BE8; continue 'dispatch;
	}
	// 824B1C10: 48000388  b 0x824b1f98
	pc = 0x824B1F98; continue 'dispatch;
            }
            0x824B1C14 => {
    //   block [0x824B1C14..0x824B1C30)
	// 824B1C14: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1C18: A14B0004  lhz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1C1C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824B1C20: 419A0010  beq cr6, 0x824b1c30
	if ctx.cr[6].eq {
	pc = 0x824B1C30; continue 'dispatch;
	}
	// 824B1C24: A14B0006  lhz r10, 6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 824B1C28: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824B1C2C: B14B0006  sth r10, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	pc = 0x824B1C30; continue 'dispatch;
            }
            0x824B1C30 => {
    //   block [0x824B1C30..0x824B1C4C)
	// 824B1C30: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B1C34: A14B0004  lhz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1C38: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824B1C3C: 419A0010  beq cr6, 0x824b1c4c
	if ctx.cr[6].eq {
	pc = 0x824B1C4C; continue 'dispatch;
	}
	// 824B1C40: A14B0006  lhz r10, 6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 824B1C44: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824B1C48: B14B0006  sth r10, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	pc = 0x824B1C4C; continue 'dispatch;
            }
            0x824B1C4C => {
    //   block [0x824B1C4C..0x824B1C7C)
	// 824B1C4C: 897D001C  lbz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 824B1C50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B1C54: 419A0344  beq cr6, 0x824b1f98
	if ctx.cr[6].eq {
	pc = 0x824B1F98; continue 'dispatch;
	}
	// 824B1C58: 3BDD0010  addi r30, r29, 0x10
	ctx.r[30].s64 = ctx.r[29].s64 + 16;
	// 824B1C5C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B1C60: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1C64: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824B1C68: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824B1C6C: 409A0010  bne cr6, 0x824b1c7c
	if !ctx.cr[6].eq {
	pc = 0x824B1C7C; continue 'dispatch;
	}
	// 824B1C70: 38800014  li r4, 0x14
	ctx.r[4].s64 = 20;
	// 824B1C74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824B1C78: 4BFBC6D9  bl 0x8246e350
	ctx.lr = 0x824B1C7C;
	sub_8246E350(ctx, base);
	pc = 0x824B1C7C; continue 'dispatch;
            }
            0x824B1C7C => {
    //   block [0x824B1C7C..0x824B1C9C)
	// 824B1C7C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1C80: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 824B1C84: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B1C88: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 824B1C8C: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 824B1C90: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824B1C94: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 824B1C98: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x824B1C9C; continue 'dispatch;
            }
            0x824B1C9C => {
    //   block [0x824B1C9C..0x824B1CCC)
	// 824B1C9C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B1CA0: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 824B1CA4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824B1CA8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824B1CAC: 4200FFF0  bdnz 0x824b1c9c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x824B1C9C; continue 'dispatch;
	}
	// 824B1CB0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1CB4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824B1CB8: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824B1CBC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1CC0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824B1CC4: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824B1CC8: 480002D0  b 0x824b1f98
	pc = 0x824B1F98; continue 'dispatch;
            }
            0x824B1CCC => {
    //   block [0x824B1CCC..0x824B1D14)
	// 824B1CCC: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B1CD0: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824B1CD4: A17F0008  lhz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B1CD8: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 824B1CDC: 5564103E  rotlwi r4, r11, 2
	ctx.r[4].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 824B1CE0: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824B1CE4: 4BFB2355  bl 0x82464038
	ctx.lr = 0x824B1CE8;
	sub_82464038(ctx, base);
	// 824B1CE8: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 824B1CEC: A17E0008  lhz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B1CF0: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1CF4: 5565103E  rotlwi r5, r11, 2
	ctx.r[5].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 824B1CF8: 4BFB8631  bl 0x8246a328
	ctx.lr = 0x824B1CFC;
	sub_8246A328(ctx, base);
	// 824B1CFC: A15F0008  lhz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B1D00: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1D04: 554A103E  rotlwi r10, r10, 2
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 824B1D08: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 824B1D0C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824B1D10: 40980288  bge cr6, 0x824b1f98
	if !ctx.cr[6].lt {
	pc = 0x824B1F98; continue 'dispatch;
	}
	pc = 0x824B1D14; continue 'dispatch;
            }
            0x824B1D14 => {
    //   block [0x824B1D14..0x824B1D30)
	// 824B1D14: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B1D18: A10A0004  lhz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1D1C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 824B1D20: 419A0010  beq cr6, 0x824b1d30
	if ctx.cr[6].eq {
	pc = 0x824B1D30; continue 'dispatch;
	}
	// 824B1D24: A10A0006  lhz r8, 6(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 824B1D28: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 824B1D2C: B10A0006  sth r8, 6(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(6 as u32), ctx.r[8].u16 ) };
	pc = 0x824B1D30; continue 'dispatch;
            }
            0x824B1D30 => {
    //   block [0x824B1D30..0x824B1D40)
	// 824B1D30: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824B1D34: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824B1D38: 4198FFDC  blt cr6, 0x824b1d14
	if ctx.cr[6].lt {
	pc = 0x824B1D14; continue 'dispatch;
	}
	// 824B1D3C: 4800025C  b 0x824b1f98
	pc = 0x824B1F98; continue 'dispatch;
            }
            0x824B1D40 => {
    //   block [0x824B1D40..0x824B1D88)
	// 824B1D40: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B1D44: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824B1D48: A17F0008  lhz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B1D4C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 824B1D50: 5564103E  rotlwi r4, r11, 2
	ctx.r[4].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 824B1D54: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824B1D58: 4BFB22E1  bl 0x82464038
	ctx.lr = 0x824B1D5C;
	sub_82464038(ctx, base);
	// 824B1D5C: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 824B1D60: A17E0008  lhz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B1D64: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1D68: 5565103E  rotlwi r5, r11, 2
	ctx.r[5].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 824B1D6C: 4BFB85BD  bl 0x8246a328
	ctx.lr = 0x824B1D70;
	sub_8246A328(ctx, base);
	// 824B1D70: A15F0008  lhz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B1D74: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1D78: 554A103E  rotlwi r10, r10, 2
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 824B1D7C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 824B1D80: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824B1D84: 40980214  bge cr6, 0x824b1f98
	if !ctx.cr[6].lt {
	pc = 0x824B1F98; continue 'dispatch;
	}
	pc = 0x824B1D88; continue 'dispatch;
            }
            0x824B1D88 => {
    //   block [0x824B1D88..0x824B1DA4)
	// 824B1D88: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B1D8C: A10A0004  lhz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1D90: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 824B1D94: 419A0010  beq cr6, 0x824b1da4
	if ctx.cr[6].eq {
	pc = 0x824B1DA4; continue 'dispatch;
	}
	// 824B1D98: A10A0006  lhz r8, 6(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 824B1D9C: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 824B1DA0: B10A0006  sth r8, 6(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(6 as u32), ctx.r[8].u16 ) };
	pc = 0x824B1DA4; continue 'dispatch;
            }
            0x824B1DA4 => {
    //   block [0x824B1DA4..0x824B1DB4)
	// 824B1DA4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824B1DA8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824B1DAC: 4198FFDC  blt cr6, 0x824b1d88
	if ctx.cr[6].lt {
	pc = 0x824B1D88; continue 'dispatch;
	}
	// 824B1DB0: 480001E8  b 0x824b1f98
	pc = 0x824B1F98; continue 'dispatch;
            }
            0x824B1DB4 => {
    //   block [0x824B1DB4..0x824B1DD0)
	// 824B1DB4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1DB8: A14B0004  lhz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1DBC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824B1DC0: 419A0010  beq cr6, 0x824b1dd0
	if ctx.cr[6].eq {
	pc = 0x824B1DD0; continue 'dispatch;
	}
	// 824B1DC4: A14B0006  lhz r10, 6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 824B1DC8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824B1DCC: B14B0006  sth r10, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	pc = 0x824B1DD0; continue 'dispatch;
            }
            0x824B1DD0 => {
    //   block [0x824B1DD0..0x824B1E00)
	// 824B1DD0: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B1DD4: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 824B1DD8: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824B1DDC: 81430050  lwz r10, 0x50(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) } as u64;
	// 824B1DE0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824B1DE4: 419A001C  beq cr6, 0x824b1e00
	if ctx.cr[6].eq {
	pc = 0x824B1E00; continue 'dispatch;
	}
	// 824B1DE8: 81630054  lwz r11, 0x54(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(84 as u32) ) } as u64;
	// 824B1DEC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824B1DF0: 91630054  stw r11, 0x54(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 824B1DF4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B1DF8: 91630050  stw r11, 0x50(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 824B1DFC: 48000010  b 0x824b1e0c
	pc = 0x824B1E0C; continue 'dispatch;
            }
            0x824B1E00 => {
    //   block [0x824B1E00..0x824B1E0C)
	// 824B1E00: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 824B1E04: 4BFB203D  bl 0x82463e40
	ctx.lr = 0x824B1E08;
	sub_82463E40(ctx, base);
	// 824B1E08: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	pc = 0x824B1E0C; continue 'dispatch;
            }
            0x824B1E0C => {
    //   block [0x824B1E0C..0x824B1E64)
	// 824B1E0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824B1E10: 419A0054  beq cr6, 0x824b1e64
	if ctx.cr[6].eq {
	pc = 0x824B1E64; continue 'dispatch;
	}
	// 824B1E14: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B1E18: 392A0010  addi r9, r10, 0x10
	ctx.r[9].s64 = ctx.r[10].s64 + 16;
	// 824B1E1C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B1E20: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 824B1E24: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1E28: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 824B1E2C: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B1E30: 910A0008  stw r8, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 824B1E34: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B1E38: 910A000C  stw r8, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 824B1E3C: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B1E40: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 824B1E44: 810B0014  lwz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 824B1E48: 91090004  stw r8, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 824B1E4C: 810B0018  lwz r8, 0x18(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824B1E50: 91090008  stw r8, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 824B1E54: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 824B1E58: 9169000C  stw r11, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 824B1E5C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 824B1E60: 48000138  b 0x824b1f98
	pc = 0x824B1F98; continue 'dispatch;
            }
            0x824B1E64 => {
    //   block [0x824B1E64..0x824B1E70)
	// 824B1E64: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 824B1E68: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 824B1E6C: 4800012C  b 0x824b1f98
	pc = 0x824B1F98; continue 'dispatch;
            }
            0x824B1E70 => {
    //   block [0x824B1E70..0x824B1EB8)
	// 824B1E70: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B1E74: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824B1E78: A17F0008  lhz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B1E7C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 824B1E80: 5564103E  rotlwi r4, r11, 2
	ctx.r[4].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 824B1E84: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824B1E88: 4BFB21B1  bl 0x82464038
	ctx.lr = 0x824B1E8C;
	sub_82464038(ctx, base);
	// 824B1E8C: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 824B1E90: A17E0008  lhz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B1E94: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1E98: 5565103E  rotlwi r5, r11, 2
	ctx.r[5].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 824B1E9C: 4BFB848D  bl 0x8246a328
	ctx.lr = 0x824B1EA0;
	sub_8246A328(ctx, base);
	// 824B1EA0: A15F0008  lhz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B1EA4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1EA8: 554A103E  rotlwi r10, r10, 2
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 824B1EAC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 824B1EB0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824B1EB4: 409800E4  bge cr6, 0x824b1f98
	if !ctx.cr[6].lt {
	pc = 0x824B1F98; continue 'dispatch;
	}
	pc = 0x824B1EB8; continue 'dispatch;
            }
            0x824B1EB8 => {
    //   block [0x824B1EB8..0x824B1ED4)
	// 824B1EB8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B1EBC: A10A0004  lhz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1EC0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 824B1EC4: 419A0010  beq cr6, 0x824b1ed4
	if ctx.cr[6].eq {
	pc = 0x824B1ED4; continue 'dispatch;
	}
	// 824B1EC8: A10A0006  lhz r8, 6(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 824B1ECC: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 824B1ED0: B10A0006  sth r8, 6(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(6 as u32), ctx.r[8].u16 ) };
	pc = 0x824B1ED4; continue 'dispatch;
            }
            0x824B1ED4 => {
    //   block [0x824B1ED4..0x824B1EE4)
	// 824B1ED4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824B1ED8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824B1EDC: 4198FFDC  blt cr6, 0x824b1eb8
	if ctx.cr[6].lt {
	pc = 0x824B1EB8; continue 'dispatch;
	}
	// 824B1EE0: 480000B8  b 0x824b1f98
	pc = 0x824B1F98; continue 'dispatch;
            }
            0x824B1EE4 => {
    //   block [0x824B1EE4..0x824B1F00)
	// 824B1EE4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1EE8: A14B0004  lhz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1EEC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824B1EF0: 419A0010  beq cr6, 0x824b1f00
	if ctx.cr[6].eq {
	pc = 0x824B1F00; continue 'dispatch;
	}
	// 824B1EF4: A14B0006  lhz r10, 6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 824B1EF8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824B1EFC: B14B0006  sth r10, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	pc = 0x824B1F00; continue 'dispatch;
            }
            0x824B1F00 => {
    //   block [0x824B1F00..0x824B1F20)
	// 824B1F00: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1F04: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B1F08: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 824B1F0C: 915D0004  stw r10, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 824B1F10: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 824B1F14: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 824B1F18: 914B0080  stw r10, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 824B1F1C: 4800007C  b 0x824b1f98
	pc = 0x824B1F98; continue 'dispatch;
            }
            0x824B1F20 => {
    //   block [0x824B1F20..0x824B1F5C)
	// 824B1F20: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1F24: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1F28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B1F2C: 419A0030  beq cr6, 0x824b1f5c
	if ctx.cr[6].eq {
	pc = 0x824B1F5C; continue 'dispatch;
	}
	// 824B1F30: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 824B1F34: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824B1F38: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824B1F3C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B1F40: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824B1F44: 409A0018  bne cr6, 0x824b1f5c
	if !ctx.cr[6].eq {
	pc = 0x824B1F5C; continue 'dispatch;
	}
	// 824B1F48: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B1F4C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824B1F50: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B1F54: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B1F58: 4E800421  bctrl
	ctx.lr = 0x824B1F5C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824B1F5C => {
    //   block [0x824B1F5C..0x824B1F7C)
	// 824B1F5C: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1F60: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B1F64: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 824B1F68: 915D0004  stw r10, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 824B1F6C: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 824B1F70: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 824B1F74: 914B0080  stw r10, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 824B1F78: 48000020  b 0x824b1f98
	pc = 0x824B1F98; continue 'dispatch;
            }
            0x824B1F7C => {
    //   block [0x824B1F7C..0x824B1F80)
	// 824B1F7C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x824B1F80; continue 'dispatch;
            }
            0x824B1F80 => {
    //   block [0x824B1F80..0x824B1F98)
	// 824B1F80: A14B0004  lhz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B1F84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824B1F88: 419A0010  beq cr6, 0x824b1f98
	if ctx.cr[6].eq {
	pc = 0x824B1F98; continue 'dispatch;
	}
	// 824B1F8C: A14B0006  lhz r10, 6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 824B1F90: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824B1F94: B14B0006  sth r10, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	pc = 0x824B1F98; continue 'dispatch;
            }
            0x824B1F98 => {
    //   block [0x824B1F98..0x824B1FB0)
	// 824B1F98: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 824B1F9C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824B1FA0: F97C0020  std r11, 0x20(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(32 as u32), ctx.r[11].u64 ) };
	// 824B1FA4: 4825B2C9  bl 0x8270d26c
	ctx.lr = 0x824B1FA8;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 824B1FA8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 824B1FAC: 4808315C  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B1FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824B1FB0 size=2788
    let mut pc: u32 = 0x824B1FB0;
    'dispatch: loop {
        match pc {
            0x824B1FB0 => {
    //   block [0x824B1FB0..0x824B1FF4)
	// 824B1FB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B1FB4: 480830E9  bl 0x8253509c
	ctx.lr = 0x824B1FB8;
	sub_82535080(ctx, base);
	// 824B1FB8: DBE1FF98  stfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 824B1FBC: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B1FC0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 824B1FC4: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 824B1FC8: 817B0014  lwz r11, 0x14(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 824B1FCC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B1FD0: 419A003C  beq cr6, 0x824b200c
	if ctx.cr[6].eq {
	pc = 0x824B200C; continue 'dispatch;
	}
	// 824B1FD4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 824B1FD8: 4099001C  ble cr6, 0x824b1ff4
	if !ctx.cr[6].gt {
	pc = 0x824B1FF4; continue 'dispatch;
	}
	// 824B1FDC: 3D40824B  lis r10, -0x7db5
	ctx.r[10].s64 = -2109014016;
	// 824B1FE0: 807B0010  lwz r3, 0x10(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B1FE4: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 824B1FE8: 38CA1808  addi r6, r10, 0x1808
	ctx.r[6].s64 = ctx.r[10].s64 + 6152;
	// 824B1FEC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 824B1FF0: 48000BE9  bl 0x824b2bd8
	ctx.lr = 0x824B1FF4;
	sub_824B2BD8(ctx, base);
	pc = 0x824B1FF4; continue 'dispatch;
            }
            0x824B1FF4 => {
    //   block [0x824B1FF4..0x824B200C)
	// 824B1FF4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 824B1FF8: 80DB0014  lwz r6, 0x14(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 824B1FFC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 824B2000: 80BB0010  lwz r5, 0x10(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B2004: 48000A95  bl 0x824b2a98
	ctx.lr = 0x824B2008;
	sub_824B2A98(ctx, base);
	// 824B2008: 935B0014  stw r26, 0x14(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(20 as u32), ctx.r[26].u32 ) };
	pc = 0x824B200C; continue 'dispatch;
            }
            0x824B200C => {
    //   block [0x824B200C..0x824B210C)
	// 824B200C: 3EE08000  lis r23, -0x8000
	ctx.r[23].s64 = -2147483648;
	// 824B2010: 817B000C  lwz r11, 0xc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B2014: 82DB0004  lwz r22, 4(r27)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2018: 7F59D378  mr r25, r26
	ctx.r[25].u64 = ctx.r[26].u64;
	// 824B201C: 831B0000  lwz r24, 0(r27)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2020: 82BB0008  lwz r21, 8(r27)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B2024: 2F160000  cmpwi cr6, r22, 0
	ctx.cr[6].compare_i32(ctx.r[22].s32, 0, &mut ctx.xer);
	// 824B2028: 935B0000  stw r26, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 824B202C: 935B0004  stw r26, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 824B2030: 92FB0008  stw r23, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[23].u32 ) };
	// 824B2034: 814B0094  lwz r10, 0x94(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(148 as u32) ) } as u64;
	// 824B2038: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824B203C: 914B0094  stw r10, 0x94(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(148 as u32), ctx.r[10].u32 ) };
	// 824B2040: 409909EC  ble cr6, 0x824b2a2c
	if !ctx.cr[6].gt {
	pc = 0x824B2A2C; continue 'dispatch;
	}
	// 824B2044: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824B2048: C3EB1FF8  lfs f31, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 824B204C: 572B103A  slwi r11, r25, 2
	ctx.r[11].u32 = ctx.r[25].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824B2050: 7D795A14  add r11, r25, r11
	ctx.r[11].u64 = ctx.r[25].u64 + ctx.r[11].u64;
	// 824B2054: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824B2058: 7FEBC214  add r31, r11, r24
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 824B205C: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2060: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824B2064: 2B0B0021  cmplwi cr6, r11, 0x21
	ctx.cr[6].compare_u32(ctx.r[11].u32, 33 as u32, &mut ctx.xer);
	// 824B2068: 419909A4  bgt cr6, 0x824b2a0c
	if ctx.cr[6].gt {
	pc = 0x824B2A0C; continue 'dispatch;
	}
	// 824B206C: 3D80824B  lis r12, -0x7db5
	ctx.r[12].s64 = -2109014016;
	// 824B2070: 398C2084  addi r12, r12, 0x2084
	ctx.r[12].s64 = ctx.r[12].s64 + 8324;
	// 824B2074: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 824B2078: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 824B207C: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 824B2080: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x824B210C; continue 'dispatch;
		},
		1 => {
	pc = 0x824B212C; continue 'dispatch;
		},
		2 => {
	pc = 0x824B261C; continue 'dispatch;
		},
		3 => {
	pc = 0x824B214C; continue 'dispatch;
		},
		4 => {
	pc = 0x824B2164; continue 'dispatch;
		},
		5 => {
	pc = 0x824B21C0; continue 'dispatch;
		},
		6 => {
	pc = 0x824B2258; continue 'dispatch;
		},
		7 => {
	pc = 0x824B22EC; continue 'dispatch;
		},
		8 => {
	pc = 0x824B2328; continue 'dispatch;
		},
		9 => {
	pc = 0x824B2348; continue 'dispatch;
		},
		10 => {
	pc = 0x824B2408; continue 'dispatch;
		},
		11 => {
	pc = 0x824B2424; continue 'dispatch;
		},
		12 => {
	pc = 0x824B24BC; continue 'dispatch;
		},
		13 => {
	pc = 0x824B24D8; continue 'dispatch;
		},
		14 => {
	pc = 0x824B24F4; continue 'dispatch;
		},
		15 => {
	pc = 0x824B2588; continue 'dispatch;
		},
		16 => {
	pc = 0x824B2640; continue 'dispatch;
		},
		17 => {
	pc = 0x824B26E8; continue 'dispatch;
		},
		18 => {
	pc = 0x824B270C; continue 'dispatch;
		},
		19 => {
	pc = 0x824B272C; continue 'dispatch;
		},
		20 => {
	pc = 0x824B2740; continue 'dispatch;
		},
		21 => {
	pc = 0x824B2910; continue 'dispatch;
		},
		22 => {
	pc = 0x824B274C; continue 'dispatch;
		},
		23 => {
	pc = 0x824B277C; continue 'dispatch;
		},
		24 => {
	pc = 0x824B27B8; continue 'dispatch;
		},
		25 => {
	pc = 0x824B27F4; continue 'dispatch;
		},
		26 => {
	pc = 0x824B2830; continue 'dispatch;
		},
		27 => {
	pc = 0x824B2880; continue 'dispatch;
		},
		28 => {
	pc = 0x824B2A0C; continue 'dispatch;
		},
		29 => {
	pc = 0x824B2A0C; continue 'dispatch;
		},
		30 => {
	pc = 0x824B28BC; continue 'dispatch;
		},
		31 => {
	pc = 0x824B28E8; continue 'dispatch;
		},
		32 => {
	pc = 0x824B28F4; continue 'dispatch;
		},
		33 => {
	pc = 0x824B29B8; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 824B2084: 824B210C  lwz r18, 0x210c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8460 as u32) ) } as u64;
	// 824B2088: 824B212C  lwz r18, 0x212c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8492 as u32) ) } as u64;
	// 824B208C: 824B261C  lwz r18, 0x261c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9756 as u32) ) } as u64;
	// 824B2090: 824B214C  lwz r18, 0x214c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8524 as u32) ) } as u64;
	// 824B2094: 824B2164  lwz r18, 0x2164(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8548 as u32) ) } as u64;
	// 824B2098: 824B21C0  lwz r18, 0x21c0(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8640 as u32) ) } as u64;
	// 824B209C: 824B2258  lwz r18, 0x2258(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8792 as u32) ) } as u64;
	// 824B20A0: 824B22EC  lwz r18, 0x22ec(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8940 as u32) ) } as u64;
	// 824B20A4: 824B2328  lwz r18, 0x2328(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9000 as u32) ) } as u64;
	// 824B20A8: 824B2348  lwz r18, 0x2348(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9032 as u32) ) } as u64;
	// 824B20AC: 824B2408  lwz r18, 0x2408(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9224 as u32) ) } as u64;
	// 824B20B0: 824B2424  lwz r18, 0x2424(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9252 as u32) ) } as u64;
	// 824B20B4: 824B24BC  lwz r18, 0x24bc(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9404 as u32) ) } as u64;
	// 824B20B8: 824B24D8  lwz r18, 0x24d8(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9432 as u32) ) } as u64;
	// 824B20BC: 824B24F4  lwz r18, 0x24f4(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9460 as u32) ) } as u64;
	// 824B20C0: 824B2588  lwz r18, 0x2588(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9608 as u32) ) } as u64;
	// 824B20C4: 824B2640  lwz r18, 0x2640(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9792 as u32) ) } as u64;
	// 824B20C8: 824B26E8  lwz r18, 0x26e8(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9960 as u32) ) } as u64;
	// 824B20CC: 824B270C  lwz r18, 0x270c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9996 as u32) ) } as u64;
	// 824B20D0: 824B272C  lwz r18, 0x272c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10028 as u32) ) } as u64;
	// 824B20D4: 824B2740  lwz r18, 0x2740(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10048 as u32) ) } as u64;
	// 824B20D8: 824B2910  lwz r18, 0x2910(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10512 as u32) ) } as u64;
	// 824B20DC: 824B274C  lwz r18, 0x274c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10060 as u32) ) } as u64;
	// 824B20E0: 824B277C  lwz r18, 0x277c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10108 as u32) ) } as u64;
	// 824B20E4: 824B27B8  lwz r18, 0x27b8(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10168 as u32) ) } as u64;
	// 824B20E8: 824B27F4  lwz r18, 0x27f4(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10228 as u32) ) } as u64;
	// 824B20EC: 824B2830  lwz r18, 0x2830(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10288 as u32) ) } as u64;
	// 824B20F0: 824B2880  lwz r18, 0x2880(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10368 as u32) ) } as u64;
	// 824B20F4: 824B2A0C  lwz r18, 0x2a0c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10764 as u32) ) } as u64;
	// 824B20F8: 824B2A0C  lwz r18, 0x2a0c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10764 as u32) ) } as u64;
	// 824B20FC: 824B28BC  lwz r18, 0x28bc(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10428 as u32) ) } as u64;
	// 824B2100: 824B28E8  lwz r18, 0x28e8(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10472 as u32) ) } as u64;
	// 824B2104: 824B28F4  lwz r18, 0x28f4(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10484 as u32) ) } as u64;
	// 824B2108: 824B29B8  lwz r18, 0x29b8(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10680 as u32) ) } as u64;
            }
            0x824B210C => {
    //   block [0x824B210C..0x824B212C)
	// 824B210C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2110: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B2114: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B2118: 409A08B8  bne cr6, 0x824b29d0
	if !ctx.cr[6].eq {
	pc = 0x824B29D0; continue 'dispatch;
	}
	// 824B211C: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B2120: 807B000C  lwz r3, 0xc(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B2124: 4BFE133D  bl 0x82493460
	ctx.lr = 0x824B2128;
	sub_82493460(ctx, base);
	// 824B2128: 480008A8  b 0x824b29d0
	pc = 0x824B29D0; continue 'dispatch;
            }
            0x824B212C => {
    //   block [0x824B212C..0x824B214C)
	// 824B212C: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2130: 809B000C  lwz r4, 0xc(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B2134: 81650008  lwz r11, 8(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B2138: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 824B213C: 409A0894  bne cr6, 0x824b29d0
	if !ctx.cr[6].eq {
	pc = 0x824B29D0; continue 'dispatch;
	}
	// 824B2140: 38610051  addi r3, r1, 0x51
	ctx.r[3].s64 = ctx.r[1].s64 + 81;
	// 824B2144: 4BFE14BD  bl 0x82493600
	ctx.lr = 0x824B2148;
	sub_82493600(ctx, base);
	// 824B2148: 48000888  b 0x824b29d0
	pc = 0x824B29D0; continue 'dispatch;
            }
            0x824B214C => {
    //   block [0x824B214C..0x824B2164)
	// 824B214C: 88DF000A  lbz r6, 0xa(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10 as u32) ) } as u64;
	// 824B2150: 88BF0009  lbz r5, 9(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(9 as u32) ) } as u64;
	// 824B2154: 889F0008  lbz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B2158: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B215C: 4BFDE16D  bl 0x824902c8
	ctx.lr = 0x824B2160;
	sub_824902C8(ctx, base);
	// 824B2160: 48000870  b 0x824b29d0
	pc = 0x824B29D0; continue 'dispatch;
            }
            0x824B2164 => {
    //   block [0x824B2164..0x824B21B8)
	// 824B2164: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2168: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B216C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2170: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B2174: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B2178: 4E800421  bctrl
	ctx.lr = 0x824B217C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824B217C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2180: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2184: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B2188: 419A0030  beq cr6, 0x824b21b8
	if ctx.cr[6].eq {
	pc = 0x824B21B8; continue 'dispatch;
	}
	// 824B218C: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 824B2190: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824B2194: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824B2198: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B219C: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824B21A0: 409A0018  bne cr6, 0x824b21b8
	if !ctx.cr[6].eq {
	pc = 0x824B21B8; continue 'dispatch;
	}
	// 824B21A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B21A8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824B21AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B21B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B21B4: 4E800421  bctrl
	ctx.lr = 0x824B21B8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824B21B8 => {
    //   block [0x824B21B8..0x824B21C0)
	// 824B21B8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B21BC: 48000818  b 0x824b29d4
	pc = 0x824B29D4; continue 'dispatch;
            }
            0x824B21C0 => {
    //   block [0x824B21C0..0x824B21EC)
	// 824B21C0: 88DF000A  lbz r6, 0xa(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10 as u32) ) } as u64;
	// 824B21C4: A0BF0008  lhz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B21C8: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B21CC: 807B000C  lwz r3, 0xc(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B21D0: 4BFE6E91  bl 0x82499060
	ctx.lr = 0x824B21D4;
	sub_82499060(ctx, base);
	// 824B21D4: A17F0008  lhz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B21D8: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B21DC: 556B103E  rotlwi r11, r11, 2
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 824B21E0: 7FABF214  add r29, r11, r30
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 824B21E4: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 824B21E8: 4098004C  bge cr6, 0x824b2234
	if !ctx.cr[6].lt {
	pc = 0x824B2234; continue 'dispatch;
	}
	pc = 0x824B21EC; continue 'dispatch;
            }
            0x824B21EC => {
    //   block [0x824B21EC..0x824B2228)
	// 824B21EC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B21F0: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B21F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B21F8: 419A0030  beq cr6, 0x824b2228
	if ctx.cr[6].eq {
	pc = 0x824B2228; continue 'dispatch;
	}
	// 824B21FC: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 824B2200: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824B2204: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824B2208: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B220C: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824B2210: 409A0018  bne cr6, 0x824b2228
	if !ctx.cr[6].eq {
	pc = 0x824B2228; continue 'dispatch;
	}
	// 824B2214: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2218: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824B221C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2220: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B2224: 4E800421  bctrl
	ctx.lr = 0x824B2228;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824B2228 => {
    //   block [0x824B2228..0x824B2234)
	// 824B2228: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 824B222C: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 824B2230: 4198FFBC  blt cr6, 0x824b21ec
	if ctx.cr[6].lt {
	pc = 0x824B21EC; continue 'dispatch;
	}
	pc = 0x824B2234; continue 'dispatch;
            }
            0x824B2234 => {
    //   block [0x824B2234..0x824B2258)
	// 824B2234: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2238: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 824B223C: A13F0008  lhz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B2240: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 824B2244: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2248: 5525103E  rotlwi r5, r9, 2
	ctx.r[5].u64 = ((ctx.r[9].u32).rotate_left(2)) as u64;
	// 824B224C: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824B2250: 4BFB1E69  bl 0x824640b8
	ctx.lr = 0x824B2254;
	sub_824640B8(ctx, base);
	// 824B2254: 480007B8  b 0x824b2a0c
	pc = 0x824B2A0C; continue 'dispatch;
            }
            0x824B2258 => {
    //   block [0x824B2258..0x824B2280)
	// 824B2258: A0BF0008  lhz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B225C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2260: 807B000C  lwz r3, 0xc(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B2264: 4BFE7525  bl 0x82499788
	ctx.lr = 0x824B2268;
	sub_82499788(ctx, base);
	// 824B2268: A17F0008  lhz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B226C: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2270: 556B103E  rotlwi r11, r11, 2
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 824B2274: 7FABF214  add r29, r11, r30
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 824B2278: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 824B227C: 4098004C  bge cr6, 0x824b22c8
	if !ctx.cr[6].lt {
	pc = 0x824B22C8; continue 'dispatch;
	}
	pc = 0x824B2280; continue 'dispatch;
            }
            0x824B2280 => {
    //   block [0x824B2280..0x824B22BC)
	// 824B2280: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2284: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2288: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B228C: 419A0030  beq cr6, 0x824b22bc
	if ctx.cr[6].eq {
	pc = 0x824B22BC; continue 'dispatch;
	}
	// 824B2290: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 824B2294: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824B2298: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824B229C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B22A0: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824B22A4: 409A0018  bne cr6, 0x824b22bc
	if !ctx.cr[6].eq {
	pc = 0x824B22BC; continue 'dispatch;
	}
	// 824B22A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B22AC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824B22B0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B22B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B22B8: 4E800421  bctrl
	ctx.lr = 0x824B22BC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824B22BC => {
    //   block [0x824B22BC..0x824B22C8)
	// 824B22BC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 824B22C0: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 824B22C4: 4198FFBC  blt cr6, 0x824b2280
	if ctx.cr[6].lt {
	pc = 0x824B2280; continue 'dispatch;
	}
	pc = 0x824B22C8; continue 'dispatch;
            }
            0x824B22C8 => {
    //   block [0x824B22C8..0x824B22EC)
	// 824B22C8: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B22CC: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 824B22D0: A13F0008  lhz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B22D4: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 824B22D8: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B22DC: 5525103E  rotlwi r5, r9, 2
	ctx.r[5].u64 = ((ctx.r[9].u32).rotate_left(2)) as u64;
	// 824B22E0: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824B22E4: 4BFB1DD5  bl 0x824640b8
	ctx.lr = 0x824B22E8;
	sub_824640B8(ctx, base);
	// 824B22E8: 48000724  b 0x824b2a0c
	pc = 0x824B2A0C; continue 'dispatch;
            }
            0x824B22EC => {
    //   block [0x824B22EC..0x824B2328)
	// 824B22EC: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B22F0: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B22F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B22F8: 409A06D8  bne cr6, 0x824b29d0
	if !ctx.cr[6].eq {
	pc = 0x824B29D0; continue 'dispatch;
	}
	// 824B22FC: 81640014  lwz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 824B2300: 807B000C  lwz r3, 0xc(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B2304: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B2308: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 824B230C: 409A06C4  bne cr6, 0x824b29d0
	if !ctx.cr[6].eq {
	pc = 0x824B29D0; continue 'dispatch;
	}
	// 824B2310: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 824B2314: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B2318: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 824B231C: 409A06B4  bne cr6, 0x824b29d0
	if !ctx.cr[6].eq {
	pc = 0x824B29D0; continue 'dispatch;
	}
	// 824B2320: 4BFE78A1  bl 0x82499bc0
	ctx.lr = 0x824B2324;
	sub_82499BC0(ctx, base);
	// 824B2324: 480006AC  b 0x824b29d0
	pc = 0x824B29D0; continue 'dispatch;
            }
            0x824B2328 => {
    //   block [0x824B2328..0x824B2348)
	// 824B2328: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B232C: 81650008  lwz r11, 8(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B2330: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B2334: 419A069C  beq cr6, 0x824b29d0
	if ctx.cr[6].eq {
	pc = 0x824B29D0; continue 'dispatch;
	}
	// 824B2338: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 824B233C: 809B000C  lwz r4, 0xc(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B2340: 4BFE7A41  bl 0x82499d80
	ctx.lr = 0x824B2344;
	sub_82499D80(ctx, base);
	// 824B2344: 4800068C  b 0x824b29d0
	pc = 0x824B29D0; continue 'dispatch;
            }
            0x824B2348 => {
    //   block [0x824B2348..0x824B2398)
	// 824B2348: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B234C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B2350: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B2354: 409A067C  bne cr6, 0x824b29d0
	if !ctx.cr[6].eq {
	pc = 0x824B29D0; continue 'dispatch;
	}
	// 824B2358: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 824B235C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 824B2360: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 824B2364: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 824B2368: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 824B236C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2370: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2374: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B2378: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B237C: 4E800421  bctrl
	ctx.lr = 0x824B2380;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824B2380: 8121005C  lwz r9, 0x5c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 824B2384: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 824B2388: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 824B238C: 40990034  ble cr6, 0x824b23c0
	if !ctx.cr[6].gt {
	pc = 0x824B23C0; continue 'dispatch;
	}
	// 824B2390: 811B000C  lwz r8, 0xc(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B2394: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
            }
            0x824B2398 => {
    //   block [0x824B2398..0x824B23BC)
	// 824B2398: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B239C: 80E70008  lwz r7, 8(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B23A0: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 824B23A4: 409A0018  bne cr6, 0x824b23bc
	if !ctx.cr[6].eq {
	pc = 0x824B23BC; continue 'dispatch;
	}
	// 824B23A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824B23AC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824B23B0: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824B23B4: 4198FFE4  blt cr6, 0x824b2398
	if ctx.cr[6].lt {
	pc = 0x824B2398; continue 'dispatch;
	}
	// 824B23B8: 48000008  b 0x824b23c0
	pc = 0x824B23C0; continue 'dispatch;
            }
            0x824B23BC => {
    //   block [0x824B23BC..0x824B23C0)
	// 824B23BC: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	pc = 0x824B23C0; continue 'dispatch;
            }
            0x824B23C0 => {
    //   block [0x824B23C0..0x824B23D8)
	// 824B23C0: 7FCB0774  extsb r11, r30
	ctx.r[11].s64 = ctx.r[30].s8 as i64;
	// 824B23C4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B23C8: 419A0010  beq cr6, 0x824b23d8
	if ctx.cr[6].eq {
	pc = 0x824B23D8; continue 'dispatch;
	}
	// 824B23CC: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B23D0: 807B000C  lwz r3, 0xc(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B23D4: 4BFE5E5D  bl 0x82498230
	ctx.lr = 0x824B23D8;
	sub_82498230(ctx, base);
	pc = 0x824B23D8; continue 'dispatch;
            }
            0x824B23D8 => {
    //   block [0x824B23D8..0x824B2408)
	// 824B23D8: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 824B23DC: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824B23E0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824B23E4: 409A05EC  bne cr6, 0x824b29d0
	if !ctx.cr[6].eq {
	pc = 0x824B29D0; continue 'dispatch;
	}
	// 824B23E8: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B23EC: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824B23F0: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824B23F4: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 824B23F8: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824B23FC: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824B2400: 4BFB1CB9  bl 0x824640b8
	ctx.lr = 0x824B2404;
	sub_824640B8(ctx, base);
	// 824B2404: 480005CC  b 0x824b29d0
	pc = 0x824B29D0; continue 'dispatch;
            }
            0x824B2408 => {
    //   block [0x824B2408..0x824B2424)
	// 824B2408: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B240C: 8164000C  lwz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B2410: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B2414: 419A05BC  beq cr6, 0x824b29d0
	if ctx.cr[6].eq {
	pc = 0x824B29D0; continue 'dispatch;
	}
	// 824B2418: 807B000C  lwz r3, 0xc(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B241C: 4BFE7A55  bl 0x82499e70
	ctx.lr = 0x824B2420;
	sub_82499E70(ctx, base);
	// 824B2420: 480005B0  b 0x824b29d0
	pc = 0x824B29D0; continue 'dispatch;
            }
            0x824B2424 => {
    //   block [0x824B2424..0x824B2478)
	// 824B2424: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2428: 817B000C  lwz r11, 0xc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B242C: 81440008  lwz r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B2430: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824B2434: 409A0044  bne cr6, 0x824b2478
	if !ctx.cr[6].eq {
	pc = 0x824B2478; continue 'dispatch;
	}
	// 824B2438: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B243C: 81450008  lwz r10, 8(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B2440: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824B2444: 409A0034  bne cr6, 0x824b2478
	if !ctx.cr[6].eq {
	pc = 0x824B2478; continue 'dispatch;
	}
	// 824B2448: 896400D8  lbz r11, 0xd8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(216 as u32) ) } as u64;
	// 824B244C: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 824B2450: 419A0028  beq cr6, 0x824b2478
	if ctx.cr[6].eq {
	pc = 0x824B2478; continue 'dispatch;
	}
	// 824B2454: 896500D8  lbz r11, 0xd8(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(216 as u32) ) } as u64;
	// 824B2458: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 824B245C: 419A001C  beq cr6, 0x824b2478
	if ctx.cr[6].eq {
	pc = 0x824B2478; continue 'dispatch;
	}
	// 824B2460: 816400B8  lwz r11, 0xb8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(184 as u32) ) } as u64;
	// 824B2464: 814500B8  lwz r10, 0xb8(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(184 as u32) ) } as u64;
	// 824B2468: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 824B246C: 419A000C  beq cr6, 0x824b2478
	if ctx.cr[6].eq {
	pc = 0x824B2478; continue 'dispatch;
	}
	// 824B2470: 80640008  lwz r3, 8(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B2474: 4BFEF395  bl 0x824a1808
	ctx.lr = 0x824B2478;
	sub_824A1808(ctx, base);
	pc = 0x824B2478; continue 'dispatch;
            }
            0x824B2478 => {
    //   block [0x824B2478..0x824B24BC)
	// 824B2478: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B247C: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2480: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B2484: 419AFD34  beq cr6, 0x824b21b8
	if ctx.cr[6].eq {
	pc = 0x824B21B8; continue 'dispatch;
	}
	// 824B2488: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 824B248C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824B2490: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824B2494: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B2498: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824B249C: 409AFD1C  bne cr6, 0x824b21b8
	if !ctx.cr[6].eq {
	pc = 0x824B21B8; continue 'dispatch;
	}
	// 824B24A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B24A4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824B24A8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B24AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B24B0: 4E800421  bctrl
	ctx.lr = 0x824B24B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824B24B4: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B24B8: 4800051C  b 0x824b29d4
	pc = 0x824B29D4; continue 'dispatch;
            }
            0x824B24BC => {
    //   block [0x824B24BC..0x824B24D8)
	// 824B24BC: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B24C0: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B24C4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B24C8: 409A0508  bne cr6, 0x824b29d0
	if !ctx.cr[6].eq {
	pc = 0x824B29D0; continue 'dispatch;
	}
	// 824B24CC: 807B000C  lwz r3, 0xc(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B24D0: 4BFE2709  bl 0x82494bd8
	ctx.lr = 0x824B24D4;
	sub_82494BD8(ctx, base);
	// 824B24D4: 480004FC  b 0x824b29d0
	pc = 0x824B29D0; continue 'dispatch;
            }
            0x824B24D8 => {
    //   block [0x824B24D8..0x824B24F4)
	// 824B24D8: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B24DC: 807B000C  lwz r3, 0xc(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B24E0: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B24E4: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 824B24E8: 409A04E8  bne cr6, 0x824b29d0
	if !ctx.cr[6].eq {
	pc = 0x824B29D0; continue 'dispatch;
	}
	// 824B24EC: 4BFE1245  bl 0x82493730
	ctx.lr = 0x824B24F0;
	sub_82493730(ctx, base);
	// 824B24F0: 480004E0  b 0x824b29d0
	pc = 0x824B29D0; continue 'dispatch;
            }
            0x824B24F4 => {
    //   block [0x824B24F4..0x824B251C)
	// 824B24F4: A0BF0008  lhz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B24F8: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B24FC: 807B000C  lwz r3, 0xc(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B2500: 4BFE79D1  bl 0x82499ed0
	ctx.lr = 0x824B2504;
	sub_82499ED0(ctx, base);
	// 824B2504: A17F0008  lhz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B2508: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B250C: 556B103E  rotlwi r11, r11, 2
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 824B2510: 7FABF214  add r29, r11, r30
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 824B2514: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 824B2518: 4098004C  bge cr6, 0x824b2564
	if !ctx.cr[6].lt {
	pc = 0x824B2564; continue 'dispatch;
	}
	pc = 0x824B251C; continue 'dispatch;
            }
            0x824B251C => {
    //   block [0x824B251C..0x824B2558)
	// 824B251C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2520: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2524: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B2528: 419A0030  beq cr6, 0x824b2558
	if ctx.cr[6].eq {
	pc = 0x824B2558; continue 'dispatch;
	}
	// 824B252C: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 824B2530: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824B2534: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824B2538: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B253C: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824B2540: 409A0018  bne cr6, 0x824b2558
	if !ctx.cr[6].eq {
	pc = 0x824B2558; continue 'dispatch;
	}
	// 824B2544: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2548: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824B254C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2550: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B2554: 4E800421  bctrl
	ctx.lr = 0x824B2558;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824B2558 => {
    //   block [0x824B2558..0x824B2564)
	// 824B2558: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 824B255C: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 824B2560: 4198FFBC  blt cr6, 0x824b251c
	if ctx.cr[6].lt {
	pc = 0x824B251C; continue 'dispatch;
	}
	pc = 0x824B2564; continue 'dispatch;
            }
            0x824B2564 => {
    //   block [0x824B2564..0x824B2588)
	// 824B2564: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2568: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 824B256C: A13F0008  lhz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B2570: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 824B2574: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2578: 5525103E  rotlwi r5, r9, 2
	ctx.r[5].u64 = ((ctx.r[9].u32).rotate_left(2)) as u64;
	// 824B257C: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824B2580: 4BFB1B39  bl 0x824640b8
	ctx.lr = 0x824B2584;
	sub_824640B8(ctx, base);
	// 824B2584: 48000488  b 0x824b2a0c
	pc = 0x824B2A0C; continue 'dispatch;
            }
            0x824B2588 => {
    //   block [0x824B2588..0x824B25B0)
	// 824B2588: A0BF0008  lhz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B258C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2590: 807B000C  lwz r3, 0xc(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B2594: 4BFE7CFD  bl 0x8249a290
	ctx.lr = 0x824B2598;
	sub_8249A290(ctx, base);
	// 824B2598: A17F0008  lhz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B259C: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B25A0: 556B103E  rotlwi r11, r11, 2
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 824B25A4: 7FABF214  add r29, r11, r30
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 824B25A8: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 824B25AC: 4098004C  bge cr6, 0x824b25f8
	if !ctx.cr[6].lt {
	pc = 0x824B25F8; continue 'dispatch;
	}
	pc = 0x824B25B0; continue 'dispatch;
            }
            0x824B25B0 => {
    //   block [0x824B25B0..0x824B25EC)
	// 824B25B0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B25B4: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B25B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B25BC: 419A0030  beq cr6, 0x824b25ec
	if ctx.cr[6].eq {
	pc = 0x824B25EC; continue 'dispatch;
	}
	// 824B25C0: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 824B25C4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824B25C8: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824B25CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B25D0: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824B25D4: 409A0018  bne cr6, 0x824b25ec
	if !ctx.cr[6].eq {
	pc = 0x824B25EC; continue 'dispatch;
	}
	// 824B25D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B25DC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824B25E0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B25E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B25E8: 4E800421  bctrl
	ctx.lr = 0x824B25EC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824B25EC => {
    //   block [0x824B25EC..0x824B25F8)
	// 824B25EC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 824B25F0: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 824B25F4: 4198FFBC  blt cr6, 0x824b25b0
	if ctx.cr[6].lt {
	pc = 0x824B25B0; continue 'dispatch;
	}
	pc = 0x824B25F8; continue 'dispatch;
            }
            0x824B25F8 => {
    //   block [0x824B25F8..0x824B261C)
	// 824B25F8: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B25FC: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 824B2600: A13F0008  lhz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B2604: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 824B2608: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B260C: 5525103E  rotlwi r5, r9, 2
	ctx.r[5].u64 = ((ctx.r[9].u32).rotate_left(2)) as u64;
	// 824B2610: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824B2614: 4BFB1AA5  bl 0x824640b8
	ctx.lr = 0x824B2618;
	sub_824640B8(ctx, base);
	// 824B2618: 480003F4  b 0x824b2a0c
	pc = 0x824B2A0C; continue 'dispatch;
            }
            0x824B261C => {
    //   block [0x824B261C..0x824B2634)
	// 824B261C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2620: 807B000C  lwz r3, 0xc(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B2624: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B2628: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 824B262C: 409A0008  bne cr6, 0x824b2634
	if !ctx.cr[6].eq {
	pc = 0x824B2634; continue 'dispatch;
	}
	// 824B2630: 4BFED9D1  bl 0x824a0000
	ctx.lr = 0x824B2634;
	sub_824A0000(ctx, base);
	pc = 0x824B2634; continue 'dispatch;
            }
            0x824B2634 => {
    //   block [0x824B2634..0x824B2640)
	// 824B2634: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2638: 4BFE9419  bl 0x8249ba50
	ctx.lr = 0x824B263C;
	sub_8249BA50(ctx, base);
	// 824B263C: 480003D0  b 0x824b2a0c
	pc = 0x824B2A0C; continue 'dispatch;
            }
            0x824B2640 => {
    //   block [0x824B2640..0x824B265C)
	// 824B2640: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2644: 817B000C  lwz r11, 0xc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B2648: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B264C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824B2650: 409A000C  bne cr6, 0x824b265c
	if !ctx.cr[6].eq {
	pc = 0x824B265C; continue 'dispatch;
	}
	// 824B2654: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B2658: 4BFF75E1  bl 0x824a9c38
	ctx.lr = 0x824B265C;
	sub_824A9C38(ctx, base);
	pc = 0x824B265C; continue 'dispatch;
            }
            0x824B265C => {
    //   block [0x824B265C..0x824B2698)
	// 824B265C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2660: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2664: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B2668: 419A0030  beq cr6, 0x824b2698
	if ctx.cr[6].eq {
	pc = 0x824B2698; continue 'dispatch;
	}
	// 824B266C: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 824B2670: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824B2674: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824B2678: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B267C: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824B2680: 409A0018  bne cr6, 0x824b2698
	if !ctx.cr[6].eq {
	pc = 0x824B2698; continue 'dispatch;
	}
	// 824B2684: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2688: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824B268C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2690: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B2694: 4E800421  bctrl
	ctx.lr = 0x824B2698;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824B2698 => {
    //   block [0x824B2698..0x824B26CC)
	// 824B2698: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B269C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 824B26A0: 419A036C  beq cr6, 0x824b2a0c
	if ctx.cr[6].eq {
	pc = 0x824B2A0C; continue 'dispatch;
	}
	// 824B26A4: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B26A8: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 824B26AC: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824B26B0: 81630054  lwz r11, 0x54(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(84 as u32) ) } as u64;
	// 824B26B4: 81430034  lwz r10, 0x34(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 824B26B8: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 824B26BC: 41980010  blt cr6, 0x824b26cc
	if ctx.cr[6].lt {
	pc = 0x824B26CC; continue 'dispatch;
	}
	// 824B26C0: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 824B26C4: 4BFB1855  bl 0x82463f18
	ctx.lr = 0x824B26C8;
	sub_82463F18(ctx, base);
	// 824B26C8: 48000344  b 0x824b2a0c
	pc = 0x824B2A0C; continue 'dispatch;
            }
            0x824B26CC => {
    //   block [0x824B26CC..0x824B26E8)
	// 824B26CC: 81630054  lwz r11, 0x54(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(84 as u32) ) } as u64;
	// 824B26D0: 81430050  lwz r10, 0x50(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) } as u64;
	// 824B26D4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824B26D8: 91630054  stw r11, 0x54(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 824B26DC: 91450000  stw r10, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824B26E0: 90A30050  stw r5, 0x50(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), ctx.r[5].u32 ) };
	// 824B26E4: 48000328  b 0x824b2a0c
	pc = 0x824B2A0C; continue 'dispatch;
            }
            0x824B26E8 => {
    //   block [0x824B26E8..0x824B270C)
	// 824B26E8: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B26EC: 807B000C  lwz r3, 0xc(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B26F0: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B26F4: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 824B26F8: 409A02D8  bne cr6, 0x824b29d0
	if !ctx.cr[6].eq {
	pc = 0x824B29D0; continue 'dispatch;
	}
	// 824B26FC: 88DF0009  lbz r6, 9(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(9 as u32) ) } as u64;
	// 824B2700: 88BF0008  lbz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B2704: 4BFE563D  bl 0x82497d40
	ctx.lr = 0x824B2708;
	sub_82497D40(ctx, base);
	// 824B2708: 480002C8  b 0x824b29d0
	pc = 0x824B29D0; continue 'dispatch;
            }
            0x824B270C => {
    //   block [0x824B270C..0x824B272C)
	// 824B270C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2710: 807B000C  lwz r3, 0xc(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B2714: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B2718: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 824B271C: 409A02B4  bne cr6, 0x824b29d0
	if !ctx.cr[6].eq {
	pc = 0x824B29D0; continue 'dispatch;
	}
	// 824B2720: 88BF0008  lbz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B2724: 4BFE536D  bl 0x82497a90
	ctx.lr = 0x824B2728;
	sub_82497A90(ctx, base);
	// 824B2728: 480002A8  b 0x824b29d0
	pc = 0x824B29D0; continue 'dispatch;
            }
            0x824B272C => {
    //   block [0x824B272C..0x824B2740)
	// 824B272C: 88BF0002  lbz r5, 2(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 824B2730: 889F0001  lbz r4, 1(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 824B2734: 807B000C  lwz r3, 0xc(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B2738: 4BFE64E9  bl 0x82498c20
	ctx.lr = 0x824B273C;
	sub_82498C20(ctx, base);
	// 824B273C: 480002D0  b 0x824b2a0c
	pc = 0x824B2A0C; continue 'dispatch;
            }
            0x824B2740 => {
    //   block [0x824B2740..0x824B274C)
	// 824B2740: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2744: 4BFDDE8D  bl 0x824905d0
	ctx.lr = 0x824B2748;
	sub_824905D0(ctx, base);
	// 824B2748: 48000288  b 0x824b29d0
	pc = 0x824B29D0; continue 'dispatch;
            }
            0x824B274C => {
    //   block [0x824B274C..0x824B277C)
	// 824B274C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B2750: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2754: 38A40010  addi r5, r4, 0x10
	ctx.r[5].s64 = ctx.r[4].s64 + 16;
	// 824B2758: 4BFDE039  bl 0x82490790
	ctx.lr = 0x824B275C;
	sub_82490790(ctx, base);
	// 824B275C: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2760: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 824B2764: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B2768: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 824B276C: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 824B2770: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824B2774: 4BFB1945  bl 0x824640b8
	ctx.lr = 0x824B2778;
	sub_824640B8(ctx, base);
	// 824B2778: 48000258  b 0x824b29d0
	pc = 0x824B29D0; continue 'dispatch;
            }
            0x824B277C => {
    //   block [0x824B277C..0x824B27B8)
	// 824B277C: C01F0008  lfs f0, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B2780: 396100B0  addi r11, r1, 0xb0
	ctx.r[11].s64 = ctx.r[1].s64 + 176;
	// 824B2784: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 824B2788: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 824B278C: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B2790: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 824B2794: C01F0010  lfs f0, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B2798: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 824B279C: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 824B27A0: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	pc = 0x824B27B8; continue 'dispatch;
            }
            0x824B27B8 => {
    //   block [0x824B27B8..0x824B27F4)
	// 824B27B8: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B27BC: 396100D0  addi r11, r1, 0xd0
	ctx.r[11].s64 = ctx.r[1].s64 + 208;
	// 824B27C0: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 824B27C4: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 824B27C8: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B27CC: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 824B27D0: C01F0010  lfs f0, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B27D4: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 824B27D8: D3E1009C  stfs f31, 0x9c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 824B27DC: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	pc = 0x824B27F4; continue 'dispatch;
            }
            0x824B27F4 => {
    //   block [0x824B27F4..0x824B2830)
	// 824B27F4: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B27F8: 396100C0  addi r11, r1, 0xc0
	ctx.r[11].s64 = ctx.r[1].s64 + 192;
	// 824B27FC: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 824B2800: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 824B2804: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B2808: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 824B280C: C01F0010  lfs f0, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B2810: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 824B2814: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 824B2818: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	pc = 0x824B2830; continue 'dispatch;
            }
            0x824B2830 => {
    //   block [0x824B2830..0x824B2880)
	// 824B2830: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2834: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B2838: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824B283C: 3B9D0010  addi r28, r29, 0x10
	ctx.r[28].s64 = ctx.r[29].s64 + 16;
	// 824B2840: 4BFDB9C1  bl 0x8248e200
	ctx.lr = 0x824B2844;
	sub_8248E200(ctx, base);
	// 824B2844: 817E00D0  lwz r11, 0xd0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(208 as u32) ) } as u64;
	// 824B2848: 387E00D0  addi r3, r30, 0xd0
	ctx.r[3].s64 = ctx.r[30].s64 + 208;
	// 824B284C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 824B2850: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 824B2854: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 824B2858: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B285C: 4E800421  bctrl
	ctx.lr = 0x824B2860;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824B2860: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2864: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 824B2868: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B286C: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 824B2870: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 824B2874: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824B2878: 4BFB1841  bl 0x824640b8
	ctx.lr = 0x824B287C;
	sub_824640B8(ctx, base);
	// 824B287C: 48000154  b 0x824b29d0
	pc = 0x824B29D0; continue 'dispatch;
            }
            0x824B2880 => {
    //   block [0x824B2880..0x824B28BC)
	// 824B2880: C01F0008  lfs f0, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B2884: 396100E0  addi r11, r1, 0xe0
	ctx.r[11].s64 = ctx.r[1].s64 + 224;
	// 824B2888: D00100A0  stfs f0, 0xa0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 824B288C: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 824B2890: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B2894: D00100A4  stfs f0, 0xa4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 824B2898: C01F0010  lfs f0, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B289C: D00100A8  stfs f0, 0xa8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 824B28A0: D3E100AC  stfs f31, 0xac(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 824B28A4: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	pc = 0x824B28BC; continue 'dispatch;
            }
            0x824B28BC => {
    //   block [0x824B28BC..0x824B28E8)
	// 824B28BC: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B28C0: 807B000C  lwz r3, 0xc(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B28C4: 4BFE210D  bl 0x824949d0
	ctx.lr = 0x824B28C8;
	sub_824949D0(ctx, base);
	// 824B28C8: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B28CC: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 824B28D0: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 824B28D4: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B28D8: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 824B28DC: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824B28E0: 4BFB17D9  bl 0x824640b8
	ctx.lr = 0x824B28E4;
	sub_824640B8(ctx, base);
	// 824B28E4: 48000128  b 0x824b2a0c
	pc = 0x824B2A0C; continue 'dispatch;
            }
            0x824B28E8 => {
    //   block [0x824B28E8..0x824B28F4)
	// 824B28E8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B28EC: 4BFDB915  bl 0x8248e200
	ctx.lr = 0x824B28F0;
	sub_8248E200(ctx, base);
	// 824B28F0: 480000E0  b 0x824b29d0
	pc = 0x824B29D0; continue 'dispatch;
            }
            0x824B28F4 => {
    //   block [0x824B28F4..0x824B2910)
	// 824B28F4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B28F8: 817B000C  lwz r11, 0xc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B28FC: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B2900: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824B2904: 409A00CC  bne cr6, 0x824b29d0
	if !ctx.cr[6].eq {
	pc = 0x824B29D0; continue 'dispatch;
	}
	// 824B2908: 4BFDB989  bl 0x8248e290
	ctx.lr = 0x824B290C;
	sub_8248E290(ctx, base);
	// 824B290C: 480000C4  b 0x824b29d0
	pc = 0x824B29D0; continue 'dispatch;
            }
            0x824B2910 => {
    //   block [0x824B2910..0x824B29B8)
	// 824B2910: 80DB000C  lwz r6, 0xc(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B2914: 88FF000A  lbz r7, 0xa(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10 as u32) ) } as u64;
	// 824B2918: A0BF0008  lhz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B291C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2920: 80660008  lwz r3, 8(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B2924: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2928: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 824B292C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B2930: 4E800421  bctrl
	ctx.lr = 0x824B2934;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824B2934: A17F0008  lhz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B2938: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B293C: 556B103E  rotlwi r11, r11, 2
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 824B2940: 7FABF214  add r29, r11, r30
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 824B2944: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 824B2948: 4098004C  bge cr6, 0x824b2994
	if !ctx.cr[6].lt {
	pc = 0x824B2994; continue 'dispatch;
	}
	// 824B294C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2950: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2954: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B2958: 419A0030  beq cr6, 0x824b2988
	if ctx.cr[6].eq {
	pc = 0x824B2988; continue 'dispatch;
	}
	// 824B295C: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 824B2960: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824B2964: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824B2968: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B296C: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824B2970: 409A0018  bne cr6, 0x824b2988
	if !ctx.cr[6].eq {
	pc = 0x824B2988; continue 'dispatch;
	}
	// 824B2974: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2978: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824B297C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2980: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B2984: 4E800421  bctrl
	ctx.lr = 0x824B2988;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824B2988: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 824B298C: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 824B2990: 4198FFBC  blt cr6, 0x824b294c
	if ctx.cr[6].lt {
	pc = 0x824B294C; continue 'dispatch;
	}
	// 824B2994: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2998: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 824B299C: A13F0008  lhz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B29A0: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 824B29A4: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B29A8: 5525103E  rotlwi r5, r9, 2
	ctx.r[5].u64 = ((ctx.r[9].u32).rotate_left(2)) as u64;
	// 824B29AC: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824B29B0: 4BFB1709  bl 0x824640b8
	ctx.lr = 0x824B29B4;
	sub_824640B8(ctx, base);
	// 824B29B4: 48000058  b 0x824b2a0c
	pc = 0x824B2A0C; continue 'dispatch;
            }
            0x824B29B8 => {
    //   block [0x824B29B8..0x824B29D0)
	// 824B29B8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B29BC: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B29C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B29C4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B29C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B29CC: 4E800421  bctrl
	ctx.lr = 0x824B29D0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824B29D0 => {
    //   block [0x824B29D0..0x824B29D4)
	// 824B29D0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x824B29D4; continue 'dispatch;
            }
            0x824B29D4 => {
    //   block [0x824B29D4..0x824B2A0C)
	// 824B29D4: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B29D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B29DC: 419A0030  beq cr6, 0x824b2a0c
	if ctx.cr[6].eq {
	pc = 0x824B2A0C; continue 'dispatch;
	}
	// 824B29E0: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 824B29E4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824B29E8: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824B29EC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B29F0: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824B29F4: 409A0018  bne cr6, 0x824b2a0c
	if !ctx.cr[6].eq {
	pc = 0x824B2A0C; continue 'dispatch;
	}
	// 824B29F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B29FC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824B2A00: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2A04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B2A08: 4E800421  bctrl
	ctx.lr = 0x824B2A0C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824B2A0C => {
    //   block [0x824B2A0C..0x824B2A2C)
	// 824B2A0C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2A10: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B2A14: 419A000C  beq cr6, 0x824b2a20
	if ctx.cr[6].eq {
	pc = 0x824B2A20; continue 'dispatch;
	}
	// 824B2A18: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 824B2A1C: 4BFFF595  bl 0x824b1fb0
	ctx.lr = 0x824B2A20;
	sub_824B1FB0(ctx, base);
	// 824B2A20: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 824B2A24: 7F19B000  cmpw cr6, r25, r22
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[22].s32, &mut ctx.xer);
	// 824B2A28: 4198F624  blt cr6, 0x824b204c
	if ctx.cr[6].lt {
	pc = 0x824B204C; continue 'dispatch;
	}
	pc = 0x824B2A2C; continue 'dispatch;
            }
            0x824B2A2C => {
    //   block [0x824B2A2C..0x824B2A94)
	// 824B2A2C: 7F09C378  mr r9, r24
	ctx.r[9].u64 = ctx.r[24].u64;
	// 824B2A30: 817B000C  lwz r11, 0xc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B2A34: 7EA8AB78  mr r8, r21
	ctx.r[8].u64 = ctx.r[21].u64;
	// 824B2A38: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B2A3C: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2A40: 935B0004  stw r26, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 824B2A44: 55470000  rlwinm r7, r10, 0, 0, 0
	ctx.r[7].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 824B2A48: 913B0000  stw r9, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824B2A4C: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 824B2A50: 911B0008  stw r8, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 824B2A54: 812B0094  lwz r9, 0x94(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(148 as u32) ) } as u64;
	// 824B2A58: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 824B2A5C: 912B0094  stw r9, 0x94(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(148 as u32), ctx.r[9].u32 ) };
	// 824B2A60: 409A0028  bne cr6, 0x824b2a88
	if !ctx.cr[6].eq {
	pc = 0x824B2A88; continue 'dispatch;
	}
	// 824B2A64: 554B00BE  clrlwi r11, r10, 2
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 824B2A68: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2A6C: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824B2A70: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824B2A74: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824B2A78: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824B2A7C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824B2A80: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824B2A84: 4BFB1635  bl 0x824640b8
	ctx.lr = 0x824B2A88;
	sub_824640B8(ctx, base);
	// 824B2A88: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 824B2A8C: CBE1FF98  lfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 824B2A90: 4808265C  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B2A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B2A98 size=316
    let mut pc: u32 = 0x824B2A98;
    'dispatch: loop {
        match pc {
            0x824B2A98 => {
    //   block [0x824B2A98..0x824B2AE0)
	// 824B2A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B2A9C: 48082615  bl 0x825350b0
	ctx.lr = 0x824B2AA0;
	sub_82535080(ctx, base);
	// 824B2AA0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B2AA4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 824B2AA8: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 824B2AAC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824B2AB0: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 824B2AB4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2AB8: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B2ABC: 7F4BEA14  add r26, r11, r29
	ctx.r[26].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 824B2AC0: 554A00BE  clrlwi r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 824B2AC4: 7FDF5850  subf r30, r31, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 824B2AC8: 7F0AD000  cmpw cr6, r10, r26
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[26].s32, &mut ctx.xer);
	// 824B2ACC: 40980024  bge cr6, 0x824b2af0
	if !ctx.cr[6].lt {
	pc = 0x824B2AF0; continue 'dispatch;
	}
	// 824B2AD0: 554B083C  slwi r11, r10, 1
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824B2AD4: 7F1A5800  cmpw cr6, r26, r11
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824B2AD8: 41980008  blt cr6, 0x824b2ae0
	if ctx.cr[6].lt {
	pc = 0x824B2AE0; continue 'dispatch;
	}
	// 824B2ADC: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x824B2AE0; continue 'dispatch;
            }
            0x824B2AE0 => {
    //   block [0x824B2AE0..0x824B2AF0)
	// 824B2AE0: 38A00014  li r5, 0x14
	ctx.r[5].s64 = 20;
	// 824B2AE4: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 824B2AE8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824B2AEC: 4BFBB7DD  bl 0x8246e2c8
	ctx.lr = 0x824B2AF0;
	sub_8246E2C8(ctx, base);
	pc = 0x824B2AF0; continue 'dispatch;
            }
            0x824B2AF0 => {
    //   block [0x824B2AF0..0x824B2B38)
	// 824B2AF0: 57E8103A  slwi r8, r31, 2
	ctx.r[8].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 824B2AF4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2AF8: 7D5FEA14  add r10, r31, r29
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[29].u64;
	// 824B2AFC: 7CFF4214  add r7, r31, r8
	ctx.r[7].u64 = ctx.r[31].u64 + ctx.r[8].u64;
	// 824B2B00: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 824B2B04: 393EFFFF  addi r9, r30, -1
	ctx.r[9].s64 = ctx.r[30].s64 + -1;
	// 824B2B08: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 824B2B0C: 54E5103A  slwi r5, r7, 2
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824B2B10: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824B2B14: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 824B2B18: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 824B2B1C: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 824B2B20: 4198004C  blt cr6, 0x824b2b6c
	if ctx.cr[6].lt {
	pc = 0x824B2B6C; continue 'dispatch;
	}
	// 824B2B24: 7CCA5850  subf r6, r10, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 824B2B28: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824B2B2C: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 824B2B30: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824B2B34: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	pc = 0x824B2B38; continue 'dispatch;
            }
            0x824B2B38 => {
    //   block [0x824B2B38..0x824B2B48)
	// 824B2B38: 7D664214  add r11, r6, r8
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[8].u64;
	// 824B2B3C: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 824B2B40: 38E00005  li r7, 5
	ctx.r[7].s64 = 5;
	// 824B2B44: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	pc = 0x824B2B48; continue 'dispatch;
            }
            0x824B2B48 => {
    //   block [0x824B2B48..0x824B2B6C)
	// 824B2B48: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2B4C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824B2B50: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 824B2B54: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 824B2B58: 4200FFF0  bdnz 0x824b2b48
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x824B2B48; continue 'dispatch;
	}
	// 824B2B5C: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 824B2B60: 3908FFEC  addi r8, r8, -0x14
	ctx.r[8].s64 = ctx.r[8].s64 + -20;
	// 824B2B64: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 824B2B68: 4098FFD0  bge cr6, 0x824b2b38
	if !ctx.cr[6].lt {
	pc = 0x824B2B38; continue 'dispatch;
	}
	pc = 0x824B2B6C; continue 'dispatch;
            }
            0x824B2B6C => {
    //   block [0x824B2B6C..0x824B2B94)
	// 824B2B6C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2B70: 38FDFFFF  addi r7, r29, -1
	ctx.r[7].s64 = ctx.r[29].s64 + -1;
	// 824B2B74: 7D655A14  add r11, r5, r11
	ctx.r[11].u64 = ctx.r[5].u64 + ctx.r[11].u64;
	// 824B2B78: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 824B2B7C: 4198004C  blt cr6, 0x824b2bc8
	if ctx.cr[6].lt {
	pc = 0x824B2BC8; continue 'dispatch;
	}
	// 824B2B80: 54EA103A  slwi r10, r7, 2
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824B2B84: 7CCBD850  subf r6, r11, r27
	ctx.r[6].s64 = ctx.r[27].s64 - ctx.r[11].s64;
	// 824B2B88: 7D475214  add r10, r7, r10
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[10].u64;
	// 824B2B8C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824B2B90: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x824B2B94; continue 'dispatch;
            }
            0x824B2B94 => {
    //   block [0x824B2B94..0x824B2BA4)
	// 824B2B94: 7D664A14  add r11, r6, r9
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[9].u64;
	// 824B2B98: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 824B2B9C: 39000005  li r8, 5
	ctx.r[8].s64 = 5;
	// 824B2BA0: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x824B2BA4; continue 'dispatch;
            }
            0x824B2BA4 => {
    //   block [0x824B2BA4..0x824B2BC8)
	// 824B2BA4: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2BA8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824B2BAC: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 824B2BB0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 824B2BB4: 4200FFF0  bdnz 0x824b2ba4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x824B2BA4; continue 'dispatch;
	}
	// 824B2BB8: 38E7FFFF  addi r7, r7, -1
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	// 824B2BBC: 3929FFEC  addi r9, r9, -0x14
	ctx.r[9].s64 = ctx.r[9].s64 + -20;
	// 824B2BC0: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 824B2BC4: 4098FFD0  bge cr6, 0x824b2b94
	if !ctx.cr[6].lt {
	pc = 0x824B2B94; continue 'dispatch;
	}
	pc = 0x824B2BC8; continue 'dispatch;
            }
            0x824B2BC8 => {
    //   block [0x824B2BC8..0x824B2BD4)
	// 824B2BC8: 935C0004  stw r26, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 824B2BCC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 824B2BD0: 48082530  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B2BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B2BD8 size=484
    let mut pc: u32 = 0x824B2BD8;
    'dispatch: loop {
        match pc {
            0x824B2BD8 => {
    //   block [0x824B2BD8..0x824B2BF4)
	// 824B2BD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B2BDC: 480824D1  bl 0x825350ac
	ctx.lr = 0x824B2BE0;
	sub_82535080(ctx, base);
	// 824B2BE0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B2BE4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 824B2BE8: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 824B2BEC: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 824B2BF0: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	pc = 0x824B2BF4; continue 'dispatch;
            }
            0x824B2BF4 => {
    //   block [0x824B2BF4..0x824B2C20)
	// 824B2BF4: 7D7ACA14  add r11, r26, r25
	ctx.r[11].u64 = ctx.r[26].u64 + ctx.r[25].u64;
	// 824B2BF8: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 824B2BFC: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 824B2C00: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 824B2C04: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 824B2C08: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 824B2C0C: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 824B2C10: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 824B2C14: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824B2C18: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 824B2C1C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x824B2C20; continue 'dispatch;
            }
            0x824B2C20 => {
    //   block [0x824B2C20..0x824B2C34)
	// 824B2C20: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2C24: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824B2C28: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824B2C2C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 824B2C30: 4200FFF0  bdnz 0x824b2c20
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x824B2C20; continue 'dispatch;
	}
	pc = 0x824B2C34; continue 'dispatch;
            }
            0x824B2C34 => {
    //   block [0x824B2C34..0x824B2C64)
	// 824B2C34: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824B2C38: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 824B2C3C: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 824B2C40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 824B2C44: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824B2C48: 7FABE214  add r29, r11, r28
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 824B2C4C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824B2C50: 7F6903A6  mtctr r27
	ctx.ctr.u64 = ctx.r[27].u64;
	// 824B2C54: 4E800421  bctrl
	ctx.lr = 0x824B2C58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824B2C58: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2C5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B2C60: 419A002C  beq cr6, 0x824b2c8c
	if ctx.cr[6].eq {
	pc = 0x824B2C8C; continue 'dispatch;
	}
            }
            0x824B2C64 => {
    //   block [0x824B2C64..0x824B2C8C)
	// 824B2C64: 3BBD0014  addi r29, r29, 0x14
	ctx.r[29].s64 = ctx.r[29].s64 + 20;
	// 824B2C68: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 824B2C6C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 824B2C70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 824B2C74: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824B2C78: 7F6903A6  mtctr r27
	ctx.ctr.u64 = ctx.r[27].u64;
	// 824B2C7C: 4E800421  bctrl
	ctx.lr = 0x824B2C80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824B2C80: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2C84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B2C88: 409AFFDC  bne cr6, 0x824b2c64
	if !ctx.cr[6].eq {
	pc = 0x824B2C64; continue 'dispatch;
	}
            }
            0x824B2C8C => {
    //   block [0x824B2C8C..0x824B2CBC)
	// 824B2C8C: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824B2C90: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 824B2C94: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 824B2C98: 38610051  addi r3, r1, 0x51
	ctx.r[3].s64 = ctx.r[1].s64 + 81;
	// 824B2C9C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824B2CA0: 7FABE214  add r29, r11, r28
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 824B2CA4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 824B2CA8: 7F6903A6  mtctr r27
	ctx.ctr.u64 = ctx.r[27].u64;
	// 824B2CAC: 4E800421  bctrl
	ctx.lr = 0x824B2CB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824B2CB0: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2CB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B2CB8: 419A002C  beq cr6, 0x824b2ce4
	if ctx.cr[6].eq {
	pc = 0x824B2CE4; continue 'dispatch;
	}
            }
            0x824B2CBC => {
    //   block [0x824B2CBC..0x824B2CE4)
	// 824B2CBC: 3BBDFFEC  addi r29, r29, -0x14
	ctx.r[29].s64 = ctx.r[29].s64 + -20;
	// 824B2CC0: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 824B2CC4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 824B2CC8: 38610051  addi r3, r1, 0x51
	ctx.r[3].s64 = ctx.r[1].s64 + 81;
	// 824B2CCC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 824B2CD0: 7F6903A6  mtctr r27
	ctx.ctr.u64 = ctx.r[27].u64;
	// 824B2CD4: 4E800421  bctrl
	ctx.lr = 0x824B2CD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824B2CD8: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2CDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B2CE0: 409AFFDC  bne cr6, 0x824b2cbc
	if !ctx.cr[6].eq {
	pc = 0x824B2CBC; continue 'dispatch;
	}
            }
            0x824B2CE4 => {
    //   block [0x824B2CE4..0x824B2D20)
	// 824B2CE4: 7F1FF000  cmpw cr6, r31, r30
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[30].s32, &mut ctx.xer);
	// 824B2CE8: 419800A0  blt cr6, 0x824b2d88
	if ctx.cr[6].lt {
	pc = 0x824B2D88; continue 'dispatch;
	}
	// 824B2CEC: 419A008C  beq cr6, 0x824b2d78
	if ctx.cr[6].eq {
	pc = 0x824B2D78; continue 'dispatch;
	}
	// 824B2CF0: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824B2CF4: 57C9103A  slwi r9, r30, 2
	ctx.r[9].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 824B2CF8: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 824B2CFC: 7D3E4A14  add r9, r30, r9
	ctx.r[9].u64 = ctx.r[30].u64 + ctx.r[9].u64;
	// 824B2D00: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824B2D04: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 824B2D08: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 824B2D0C: 7CE9E214  add r7, r9, r28
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[28].u64;
	// 824B2D10: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 824B2D14: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 824B2D18: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 824B2D1C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x824B2D20; continue 'dispatch;
            }
            0x824B2D20 => {
    //   block [0x824B2D20..0x824B2D40)
	// 824B2D20: 81490000  lwz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2D24: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 824B2D28: 91480000  stw r10, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824B2D2C: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 824B2D30: 4200FFF0  bdnz 0x824b2d20
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x824B2D20; continue 'dispatch;
	}
	// 824B2D34: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 824B2D38: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 824B2D3C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x824B2D40; continue 'dispatch;
            }
            0x824B2D40 => {
    //   block [0x824B2D40..0x824B2D64)
	// 824B2D40: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2D44: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 824B2D48: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824B2D4C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824B2D50: 4200FFF0  bdnz 0x824b2d40
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x824B2D40; continue 'dispatch;
	}
	// 824B2D54: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 824B2D58: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 824B2D5C: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 824B2D60: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x824B2D64; continue 'dispatch;
            }
            0x824B2D64 => {
    //   block [0x824B2D64..0x824B2D78)
	// 824B2D64: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2D68: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824B2D6C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824B2D70: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 824B2D74: 4200FFF0  bdnz 0x824b2d64
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x824B2D64; continue 'dispatch;
	}
	pc = 0x824B2D78; continue 'dispatch;
            }
            0x824B2D78 => {
    //   block [0x824B2D78..0x824B2D88)
	// 824B2D78: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 824B2D7C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 824B2D80: 7F1EF800  cmpw cr6, r30, r31
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[31].s32, &mut ctx.xer);
	// 824B2D84: 4099FEB0  ble cr6, 0x824b2c34
	if !ctx.cr[6].gt {
	pc = 0x824B2C34; continue 'dispatch;
	}
	pc = 0x824B2D88; continue 'dispatch;
            }
            0x824B2D88 => {
    //   block [0x824B2D88..0x824B2DA4)
	// 824B2D88: 7F1AF800  cmpw cr6, r26, r31
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[31].s32, &mut ctx.xer);
	// 824B2D8C: 40980018  bge cr6, 0x824b2da4
	if !ctx.cr[6].lt {
	pc = 0x824B2DA4; continue 'dispatch;
	}
	// 824B2D90: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 824B2D94: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 824B2D98: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 824B2D9C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824B2DA0: 4BFFFE39  bl 0x824b2bd8
	ctx.lr = 0x824B2DA4;
	sub_824B2BD8(ctx, base);
	pc = 0x824B2DA4; continue 'dispatch;
            }
            0x824B2DA4 => {
    //   block [0x824B2DA4..0x824B2DB4)
	// 824B2DA4: 7F1EC800  cmpw cr6, r30, r25
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[25].s32, &mut ctx.xer);
	// 824B2DA8: 4098000C  bge cr6, 0x824b2db4
	if !ctx.cr[6].lt {
	pc = 0x824B2DB4; continue 'dispatch;
	}
	// 824B2DAC: 7FDAF378  mr r26, r30
	ctx.r[26].u64 = ctx.r[30].u64;
	// 824B2DB0: 4BFFFE44  b 0x824b2bf4
	pc = 0x824B2BF4; continue 'dispatch;
            }
            0x824B2DB4 => {
    //   block [0x824B2DB4..0x824B2DBC)
	// 824B2DB4: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 824B2DB8: 48082344  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B2DC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B2DC0 size=184
    let mut pc: u32 = 0x824B2DC0;
    'dispatch: loop {
        match pc {
            0x824B2DC0 => {
    //   block [0x824B2DC0..0x824B2E1C)
	// 824B2DC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B2DC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824B2DC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824B2DCC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B2DD0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824B2DD4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2DD8: 896A0004  lbz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2DDC: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 824B2DE0: 409A003C  bne cr6, 0x824b2e1c
	if !ctx.cr[6].eq {
	pc = 0x824B2E1C; continue 'dispatch;
	}
	// 824B2DE4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2DE8: 892A0005  lbz r9, 5(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B2DEC: 7D280774  extsb r8, r9
	ctx.r[8].s64 = ctx.r[9].s8 as i64;
	// 824B2DF0: 88EB0005  lbz r7, 5(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B2DF4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 824B2DF8: 7CE90774  extsb r9, r7
	ctx.r[9].s64 = ctx.r[7].s8 as i64;
	// 824B2DFC: 7C895A14  add r4, r9, r11
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 824B2E00: 896A0010  lbz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B2E04: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824B2E08: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824B2E0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2E10: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 824B2E14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B2E18: 4E800421  bctrl
	ctx.lr = 0x824B2E1C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824B2E1C => {
    //   block [0x824B2E1C..0x824B2E64)
	// 824B2E1C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2E20: 896A0004  lbz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2E24: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 824B2E28: 409A003C  bne cr6, 0x824b2e64
	if !ctx.cr[6].eq {
	pc = 0x824B2E64; continue 'dispatch;
	}
	// 824B2E2C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2E30: 892A0005  lbz r9, 5(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B2E34: 7D280774  extsb r8, r9
	ctx.r[8].s64 = ctx.r[9].s8 as i64;
	// 824B2E38: 88EB0005  lbz r7, 5(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B2E3C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 824B2E40: 7CE90774  extsb r9, r7
	ctx.r[9].s64 = ctx.r[7].s8 as i64;
	// 824B2E44: 7C895A14  add r4, r9, r11
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 824B2E48: 896A0010  lbz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B2E4C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824B2E50: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824B2E54: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2E58: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 824B2E5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B2E60: 4E800421  bctrl
	ctx.lr = 0x824B2E64;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824B2E64 => {
    //   block [0x824B2E64..0x824B2E78)
	// 824B2E64: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824B2E68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824B2E6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824B2E70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824B2E74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B2E78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B2E78 size=184
    let mut pc: u32 = 0x824B2E78;
    'dispatch: loop {
        match pc {
            0x824B2E78 => {
    //   block [0x824B2E78..0x824B2ED4)
	// 824B2E78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B2E7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824B2E80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824B2E84: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B2E88: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824B2E8C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2E90: 896A0004  lbz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2E94: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 824B2E98: 409A003C  bne cr6, 0x824b2ed4
	if !ctx.cr[6].eq {
	pc = 0x824B2ED4; continue 'dispatch;
	}
	// 824B2E9C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2EA0: 892A0005  lbz r9, 5(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B2EA4: 7D280774  extsb r8, r9
	ctx.r[8].s64 = ctx.r[9].s8 as i64;
	// 824B2EA8: 88EB0005  lbz r7, 5(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B2EAC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 824B2EB0: 7CE90774  extsb r9, r7
	ctx.r[9].s64 = ctx.r[7].s8 as i64;
	// 824B2EB4: 7C895A14  add r4, r9, r11
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 824B2EB8: 896A0010  lbz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B2EBC: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824B2EC0: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824B2EC4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2EC8: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 824B2ECC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B2ED0: 4E800421  bctrl
	ctx.lr = 0x824B2ED4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824B2ED4 => {
    //   block [0x824B2ED4..0x824B2F1C)
	// 824B2ED4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2ED8: 896A0004  lbz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2EDC: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 824B2EE0: 409A003C  bne cr6, 0x824b2f1c
	if !ctx.cr[6].eq {
	pc = 0x824B2F1C; continue 'dispatch;
	}
	// 824B2EE4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2EE8: 892A0005  lbz r9, 5(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B2EEC: 7D280774  extsb r8, r9
	ctx.r[8].s64 = ctx.r[9].s8 as i64;
	// 824B2EF0: 88EB0005  lbz r7, 5(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B2EF4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 824B2EF8: 7CE90774  extsb r9, r7
	ctx.r[9].s64 = ctx.r[7].s8 as i64;
	// 824B2EFC: 7C895A14  add r4, r9, r11
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 824B2F00: 896A0010  lbz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B2F04: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824B2F08: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824B2F0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2F10: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 824B2F14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B2F18: 4E800421  bctrl
	ctx.lr = 0x824B2F1C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824B2F1C => {
    //   block [0x824B2F1C..0x824B2F30)
	// 824B2F1C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824B2F20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824B2F24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824B2F28: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824B2F2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B2F30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B2F30 size=212
    let mut pc: u32 = 0x824B2F30;
    'dispatch: loop {
        match pc {
            0x824B2F30 => {
    //   block [0x824B2F30..0x824B2FA8)
	// 824B2F30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B2F34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824B2F38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824B2F3C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B2F40: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824B2F44: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2F48: 896A0004  lbz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2F4C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824B2F50: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 824B2F54: 409A0054  bne cr6, 0x824b2fa8
	if !ctx.cr[6].eq {
	pc = 0x824B2FA8; continue 'dispatch;
	}
	// 824B2F58: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2F5C: 89290004  lbz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2F60: 2B090003  cmplwi cr6, r9, 3
	ctx.cr[6].compare_u32(ctx.r[9].u32, 3 as u32, &mut ctx.xer);
	// 824B2F64: 419A008C  beq cr6, 0x824b2ff0
	if ctx.cr[6].eq {
	pc = 0x824B2FF0; continue 'dispatch;
	}
	// 824B2F68: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 824B2F6C: 409A003C  bne cr6, 0x824b2fa8
	if !ctx.cr[6].eq {
	pc = 0x824B2FA8; continue 'dispatch;
	}
	// 824B2F70: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2F74: 892A0005  lbz r9, 5(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B2F78: 7D280774  extsb r8, r9
	ctx.r[8].s64 = ctx.r[9].s8 as i64;
	// 824B2F7C: 88EB0005  lbz r7, 5(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B2F80: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 824B2F84: 7CE90774  extsb r9, r7
	ctx.r[9].s64 = ctx.r[7].s8 as i64;
	// 824B2F88: 7C895A14  add r4, r9, r11
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 824B2F8C: 896A0010  lbz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B2F90: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824B2F94: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824B2F98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2F9C: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 824B2FA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B2FA4: 4E800421  bctrl
	ctx.lr = 0x824B2FA8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824B2FA8 => {
    //   block [0x824B2FA8..0x824B2FF0)
	// 824B2FA8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2FAC: 896A0004  lbz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B2FB0: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 824B2FB4: 409A003C  bne cr6, 0x824b2ff0
	if !ctx.cr[6].eq {
	pc = 0x824B2FF0; continue 'dispatch;
	}
	// 824B2FB8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2FBC: 892A0005  lbz r9, 5(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B2FC0: 7D280774  extsb r8, r9
	ctx.r[8].s64 = ctx.r[9].s8 as i64;
	// 824B2FC4: 88EB0005  lbz r7, 5(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B2FC8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 824B2FCC: 7CE90774  extsb r9, r7
	ctx.r[9].s64 = ctx.r[7].s8 as i64;
	// 824B2FD0: 7C895A14  add r4, r9, r11
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 824B2FD4: 896A0010  lbz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B2FD8: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824B2FDC: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824B2FE0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B2FE4: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 824B2FE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B2FEC: 4E800421  bctrl
	ctx.lr = 0x824B2FF0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824B2FF0 => {
    //   block [0x824B2FF0..0x824B3004)
	// 824B2FF0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824B2FF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824B2FF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824B2FFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824B3000: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B3008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B3008 size=212
    let mut pc: u32 = 0x824B3008;
    'dispatch: loop {
        match pc {
            0x824B3008 => {
    //   block [0x824B3008..0x824B3080)
	// 824B3008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B300C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824B3010: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824B3014: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B3018: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824B301C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B3020: 896A0004  lbz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B3024: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824B3028: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 824B302C: 409A0054  bne cr6, 0x824b3080
	if !ctx.cr[6].eq {
	pc = 0x824B3080; continue 'dispatch;
	}
	// 824B3030: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B3034: 89290004  lbz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B3038: 2B090003  cmplwi cr6, r9, 3
	ctx.cr[6].compare_u32(ctx.r[9].u32, 3 as u32, &mut ctx.xer);
	// 824B303C: 419A008C  beq cr6, 0x824b30c8
	if ctx.cr[6].eq {
	pc = 0x824B30C8; continue 'dispatch;
	}
	// 824B3040: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 824B3044: 409A003C  bne cr6, 0x824b3080
	if !ctx.cr[6].eq {
	pc = 0x824B3080; continue 'dispatch;
	}
	// 824B3048: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B304C: 892A0005  lbz r9, 5(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B3050: 7D280774  extsb r8, r9
	ctx.r[8].s64 = ctx.r[9].s8 as i64;
	// 824B3054: 88EB0005  lbz r7, 5(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B3058: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 824B305C: 7CE90774  extsb r9, r7
	ctx.r[9].s64 = ctx.r[7].s8 as i64;
	// 824B3060: 7C895A14  add r4, r9, r11
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 824B3064: 896A0010  lbz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B3068: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824B306C: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824B3070: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B3074: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 824B3078: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B307C: 4E800421  bctrl
	ctx.lr = 0x824B3080;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824B3080 => {
    //   block [0x824B3080..0x824B30C8)
	// 824B3080: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B3084: 896A0004  lbz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B3088: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 824B308C: 409A003C  bne cr6, 0x824b30c8
	if !ctx.cr[6].eq {
	pc = 0x824B30C8; continue 'dispatch;
	}
	// 824B3090: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B3094: 892A0005  lbz r9, 5(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B3098: 7D280774  extsb r8, r9
	ctx.r[8].s64 = ctx.r[9].s8 as i64;
	// 824B309C: 88EB0005  lbz r7, 5(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B30A0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 824B30A4: 7CE90774  extsb r9, r7
	ctx.r[9].s64 = ctx.r[7].s8 as i64;
	// 824B30A8: 7C895A14  add r4, r9, r11
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 824B30AC: 896A0010  lbz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B30B0: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824B30B4: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824B30B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B30BC: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 824B30C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B30C4: 4E800421  bctrl
	ctx.lr = 0x824B30C8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824B30C8 => {
    //   block [0x824B30C8..0x824B30DC)
	// 824B30C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824B30CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824B30D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824B30D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824B30D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B30E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B30E0 size=220
    let mut pc: u32 = 0x824B30E0;
    'dispatch: loop {
        match pc {
            0x824B30E0 => {
    //   block [0x824B30E0..0x824B313C)
	// 824B30E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B30E4: 81040004  lwz r8, 4(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B30E8: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B30EC: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B30F0: 88EB0005  lbz r7, 5(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B30F4: 88680005  lbz r3, 5(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B30F8: 7CE70774  extsb r7, r7
	ctx.r[7].s64 = ctx.r[7].s8 as i64;
	// 824B30FC: 88CA0005  lbz r6, 5(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B3100: 88890005  lbz r4, 5(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B3104: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 824B3108: 7C670774  extsb r7, r3
	ctx.r[7].s64 = ctx.r[3].s8 as i64;
	// 824B310C: 7CC50774  extsb r5, r6
	ctx.r[5].s64 = ctx.r[6].s8 as i64;
	// 824B3110: 7CE74214  add r7, r7, r8
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 824B3114: 7C860774  extsb r6, r4
	ctx.r[6].s64 = ctx.r[4].s8 as i64;
	// 824B3118: 890B0018  lbz r8, 0x18(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824B311C: 7D455214  add r10, r5, r10
	ctx.r[10].u64 = ctx.r[5].u64 + ctx.r[10].u64;
	// 824B3120: 7D264A14  add r9, r6, r9
	ctx.r[9].u64 = ctx.r[6].u64 + ctx.r[9].u64;
	// 824B3124: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 824B3128: 409A0014  bne cr6, 0x824b313c
	if !ctx.cr[6].eq {
	pc = 0x824B313C; continue 'dispatch;
	}
	// 824B312C: 890B0010  lbz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B3130: 7D080774  extsb r8, r8
	ctx.r[8].s64 = ctx.r[8].s8 as i64;
	// 824B3134: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 824B3138: 48000008  b 0x824b3140
	pc = 0x824B3140; continue 'dispatch;
            }
            0x824B313C => {
    //   block [0x824B313C..0x824B3140)
	// 824B313C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x824B3140; continue 'dispatch;
            }
            0x824B3140 => {
    //   block [0x824B3140..0x824B3160)
	// 824B3140: 890A0018  lbz r8, 0x18(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 824B3144: 80CB00C0  lwz r6, 0xc0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) } as u64;
	// 824B3148: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 824B314C: 409A0014  bne cr6, 0x824b3160
	if !ctx.cr[6].eq {
	pc = 0x824B3160; continue 'dispatch;
	}
	// 824B3150: 896A0010  lbz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B3154: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824B3158: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824B315C: 48000008  b 0x824b3164
	pc = 0x824B3164; continue 'dispatch;
            }
            0x824B3160 => {
    //   block [0x824B3160..0x824B3164)
	// 824B3160: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x824B3164; continue 'dispatch;
            }
            0x824B3164 => {
    //   block [0x824B3164..0x824B3184)
	// 824B3164: 89490018  lbz r10, 0x18(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 824B3168: 810B00C0  lwz r8, 0xc0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) } as u64;
	// 824B316C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 824B3170: 409A0014  bne cr6, 0x824b3184
	if !ctx.cr[6].eq {
	pc = 0x824B3184; continue 'dispatch;
	}
	// 824B3174: 89690010  lbz r11, 0x10(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B3178: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824B317C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 824B3180: 48000008  b 0x824b3188
	pc = 0x824B3188; continue 'dispatch;
            }
            0x824B3184 => {
    //   block [0x824B3184..0x824B3188)
	// 824B3184: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x824B3188; continue 'dispatch;
            }
            0x824B3188 => {
    //   block [0x824B3188..0x824B31A8)
	// 824B3188: 89270018  lbz r9, 0x18(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 824B318C: 814B00C0  lwz r10, 0xc0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) } as u64;
	// 824B3190: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 824B3194: 409A0014  bne cr6, 0x824b31a8
	if !ctx.cr[6].eq {
	pc = 0x824B31A8; continue 'dispatch;
	}
	// 824B3198: 89670010  lbz r11, 0x10(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B319C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824B31A0: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 824B31A4: 48000008  b 0x824b31ac
	pc = 0x824B31AC; continue 'dispatch;
            }
            0x824B31A8 => {
    //   block [0x824B31A8..0x824B31AC)
	// 824B31A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x824B31AC; continue 'dispatch;
            }
            0x824B31AC => {
    //   block [0x824B31AC..0x824B31BC)
	// 824B31AC: 7F065000  cmpw cr6, r6, r10
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[10].s32, &mut ctx.xer);
	// 824B31B0: 4098000C  bge cr6, 0x824b31bc
	if !ctx.cr[6].lt {
		sub_824B31BC(ctx, base);
		return;
	}
	// 824B31B4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 824B31B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B31BC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B31BC size=32
    let mut pc: u32 = 0x824B31BC;
    'dispatch: loop {
        match pc {
            0x824B31BC => {
    //   block [0x824B31BC..0x824B31D4)
	// 824B31BC: 409A0020  bne cr6, 0x824b31dc
	if !ctx.cr[6].eq {
		sub_824B31DC(ctx, base);
		return;
	}
	// 824B31C0: 816B00C0  lwz r11, 0xc0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) } as u64;
	// 824B31C4: 7F085800  cmpw cr6, r8, r11
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824B31C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824B31CC: 41980008  blt cr6, 0x824b31d4
	if ctx.cr[6].lt {
	pc = 0x824B31D4; continue 'dispatch;
	}
	// 824B31D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x824B31D4; continue 'dispatch;
            }
            0x824B31D4 => {
    //   block [0x824B31D4..0x824B31DC)
	// 824B31D4: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 824B31D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B31DC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B31DC size=8
    let mut pc: u32 = 0x824B31DC;
    'dispatch: loop {
        match pc {
            0x824B31DC => {
    //   block [0x824B31DC..0x824B31E4)
	// 824B31DC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824B31E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B31E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B31E8 size=12
    let mut pc: u32 = 0x824B31E8;
    'dispatch: loop {
        match pc {
            0x824B31E8 => {
    //   block [0x824B31E8..0x824B31F4)
	// 824B31E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824B31EC: 916300FC  stw r11, 0xfc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 824B31F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B31F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B31F8 size=12
    let mut pc: u32 = 0x824B31F8;
    'dispatch: loop {
        match pc {
            0x824B31F8 => {
    //   block [0x824B31F8..0x824B3204)
	// 824B31F8: 816300F8  lwz r11, 0xf8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(248 as u32) ) } as u64;
	// 824B31FC: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824B3200: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B3208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B3208 size=12
    let mut pc: u32 = 0x824B3208;
    'dispatch: loop {
        match pc {
            0x824B3208 => {
    //   block [0x824B3208..0x824B3214)
	// 824B3208: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B320C: 916300F8  stw r11, 0xf8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 824B3210: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B3218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B3218 size=20
    let mut pc: u32 = 0x824B3218;
    'dispatch: loop {
        match pc {
            0x824B3218 => {
    //   block [0x824B3218..0x824B322C)
	// 824B3218: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 824B321C: 38630180  addi r3, r3, 0x180
	ctx.r[3].s64 = ctx.r[3].s64 + 384;
	// 824B3220: 409A000C  bne cr6, 0x824b322c
	if !ctx.cr[6].eq {
		sub_824B322C(ctx, base);
		return;
	}
	// 824B3224: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 824B3228: 480F8EC8  b 0x825ac0f0
	crate::recompiler::externs::call(ctx, base, 0x825AC0F0);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B322C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B322C size=8
    let mut pc: u32 = 0x824B322C;
    'dispatch: loop {
        match pc {
            0x824B322C => {
    //   block [0x824B322C..0x824B3234)
	// 824B322C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 824B3230: 480F8EC0  b 0x825ac0f0
	crate::recompiler::externs::call(ctx, base, 0x825AC0F0);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B3238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B3238 size=4
    let mut pc: u32 = 0x824B3238;
    'dispatch: loop {
        match pc {
            0x824B3238 => {
    //   block [0x824B3238..0x824B323C)
	// 824B3238: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B3240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B3240 size=4
    let mut pc: u32 = 0x824B3240;
    'dispatch: loop {
        match pc {
            0x824B3240 => {
    //   block [0x824B3240..0x824B3244)
	// 824B3240: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B3248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B3248 size=676
    let mut pc: u32 = 0x824B3248;
    'dispatch: loop {
        match pc {
            0x824B3248 => {
    //   block [0x824B3248..0x824B32B0)
	// 824B3248: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B324C: 48081E65  bl 0x825350b0
	ctx.lr = 0x824B3250;
	sub_82535080(ctx, base);
	// 824B3250: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B3254: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824B3258: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 824B325C: 3BBF0180  addi r29, r31, 0x180
	ctx.r[29].s64 = ctx.r[31].s64 + 384;
	// 824B3260: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824B3264: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 824B3268: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 824B326C: 480F9C25  bl 0x825ace90
	ctx.lr = 0x824B3270;
	sub_825ACE90(ctx, base);
	// 824B3270: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 824B3274: 409A0270  bne cr6, 0x824b34e4
	if !ctx.cr[6].eq {
	pc = 0x824B34E4; continue 'dispatch;
	}
	// 824B3278: 834D0000  lwz r26, 0(r13)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B327C: 3B600010  li r27, 0x10
	ctx.r[27].s64 = 16;
	// 824B3280: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 824B3284: 7D7BD02E  lwzx r11, r27, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 824B3288: 814B0088  lwz r10, 0x88(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
	// 824B328C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824B3290: 419A0020  beq cr6, 0x824b32b0
	if ctx.cr[6].eq {
	pc = 0x824B32B0; continue 'dispatch;
	}
	// 824B3294: 812B008C  lwz r9, 0x8c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 824B3298: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 824B329C: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 824B32A0: 912B008C  stw r9, 0x8c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), ctx.r[9].u32 ) };
	// 824B32A4: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B32A8: 914B0088  stw r10, 0x88(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 824B32AC: 48000010  b 0x824b32bc
	pc = 0x824B32BC; continue 'dispatch;
            }
            0x824B32B0 => {
    //   block [0x824B32B0..0x824B32BC)
	// 824B32B0: 3880000A  li r4, 0xa
	ctx.r[4].s64 = 10;
	// 824B32B4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 824B32B8: 4BFB0B89  bl 0x82463e40
	ctx.lr = 0x824B32BC;
	sub_82463E40(ctx, base);
	pc = 0x824B32BC; continue 'dispatch;
            }
            0x824B32BC => {
    //   block [0x824B32BC..0x824B32DC)
	// 824B32BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 824B32C0: 419A001C  beq cr6, 0x824b32dc
	if ctx.cr[6].eq {
	pc = 0x824B32DC; continue 'dispatch;
	}
	// 824B32C4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 824B32C8: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B32CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 824B32D0: 48011BD1  bl 0x824c4ea0
	ctx.lr = 0x824B32D4;
	sub_824C4EA0(ctx, base);
	// 824B32D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824B32D8: 48000008  b 0x824b32e0
	pc = 0x824B32E0; continue 'dispatch;
            }
            0x824B32DC => {
    //   block [0x824B32DC..0x824B32E0)
	// 824B32DC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x824B32E0; continue 'dispatch;
            }
            0x824B32E0 => {
    //   block [0x824B32E0..0x824B3344)
	// 824B32E0: A1610050  lhz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824B32E4: 2B0B000F  cmplwi cr6, r11, 0xf
	ctx.cr[6].compare_u32(ctx.r[11].u32, 15 as u32, &mut ctx.xer);
	// 824B32E8: 419901AC  bgt cr6, 0x824b3494
	if ctx.cr[6].gt {
	pc = 0x824B3494; continue 'dispatch;
	}
	// 824B32EC: 3D80824B  lis r12, -0x7db5
	ctx.r[12].s64 = -2109014016;
	// 824B32F0: 398C3304  addi r12, r12, 0x3304
	ctx.r[12].s64 = ctx.r[12].s64 + 13060;
	// 824B32F4: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 824B32F8: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 824B32FC: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 824B3300: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x824B3344; continue 'dispatch;
		},
		1 => {
	pc = 0x824B335C; continue 'dispatch;
		},
		2 => {
	pc = 0x824B3494; continue 'dispatch;
		},
		3 => {
	pc = 0x824B3374; continue 'dispatch;
		},
		4 => {
	pc = 0x824B338C; continue 'dispatch;
		},
		5 => {
	pc = 0x824B3434; continue 'dispatch;
		},
		6 => {
	pc = 0x824B33A4; continue 'dispatch;
		},
		7 => {
	pc = 0x824B33BC; continue 'dispatch;
		},
		8 => {
	pc = 0x824B33D4; continue 'dispatch;
		},
		9 => {
	pc = 0x824B33EC; continue 'dispatch;
		},
		10 => {
	pc = 0x824B3404; continue 'dispatch;
		},
		11 => {
	pc = 0x824B341C; continue 'dispatch;
		},
		12 => {
	pc = 0x824B344C; continue 'dispatch;
		},
		13 => {
	pc = 0x824B3464; continue 'dispatch;
		},
		14 => {
	pc = 0x824B347C; continue 'dispatch;
		},
		15 => {
	pc = 0x824B3464; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 824B3304: 824B3344  lwz r18, 0x3344(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13124 as u32) ) } as u64;
	// 824B3308: 824B335C  lwz r18, 0x335c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13148 as u32) ) } as u64;
	// 824B330C: 824B3494  lwz r18, 0x3494(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13460 as u32) ) } as u64;
	// 824B3310: 824B3374  lwz r18, 0x3374(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13172 as u32) ) } as u64;
	// 824B3314: 824B338C  lwz r18, 0x338c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13196 as u32) ) } as u64;
	// 824B3318: 824B3434  lwz r18, 0x3434(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13364 as u32) ) } as u64;
	// 824B331C: 824B33A4  lwz r18, 0x33a4(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13220 as u32) ) } as u64;
	// 824B3320: 824B33BC  lwz r18, 0x33bc(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13244 as u32) ) } as u64;
	// 824B3324: 824B33D4  lwz r18, 0x33d4(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13268 as u32) ) } as u64;
	// 824B3328: 824B33EC  lwz r18, 0x33ec(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13292 as u32) ) } as u64;
	// 824B332C: 824B3404  lwz r18, 0x3404(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13316 as u32) ) } as u64;
	// 824B3330: 824B341C  lwz r18, 0x341c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13340 as u32) ) } as u64;
	// 824B3334: 824B344C  lwz r18, 0x344c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13388 as u32) ) } as u64;
	// 824B3338: 824B3464  lwz r18, 0x3464(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13412 as u32) ) } as u64;
	// 824B333C: 824B347C  lwz r18, 0x347c(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13436 as u32) ) } as u64;
	// 824B3340: 824B3464  lwz r18, 0x3464(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13412 as u32) ) } as u64;
            }
            0x824B3344 => {
    //   block [0x824B3344..0x824B335C)
	// 824B3344: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824B3348: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824B334C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B3350: 48011129  bl 0x824c4478
	ctx.lr = 0x824B3354;
	sub_824C4478(ctx, base);
	// 824B3354: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824B3358: 4800013C  b 0x824b3494
	pc = 0x824B3494; continue 'dispatch;
            }
            0x824B335C => {
    //   block [0x824B335C..0x824B3374)
	// 824B335C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824B3360: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824B3364: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B3368: 4800FE51  bl 0x824c31b8
	ctx.lr = 0x824B336C;
	sub_824C31B8(ctx, base);
	// 824B336C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824B3370: 48000124  b 0x824b3494
	pc = 0x824B3494; continue 'dispatch;
            }
            0x824B3374 => {
    //   block [0x824B3374..0x824B338C)
	// 824B3374: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824B3378: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824B337C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B3380: 4800FC61  bl 0x824c2fe0
	ctx.lr = 0x824B3384;
	sub_824C2FE0(ctx, base);
	// 824B3384: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824B3388: 4800010C  b 0x824b3494
	pc = 0x824B3494; continue 'dispatch;
            }
            0x824B338C => {
    //   block [0x824B338C..0x824B33A4)
	// 824B338C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824B3390: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824B3394: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B3398: 4800FA41  bl 0x824c2dd8
	ctx.lr = 0x824B339C;
	sub_824C2DD8(ctx, base);
	// 824B339C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824B33A0: 480000F4  b 0x824b3494
	pc = 0x824B3494; continue 'dispatch;
            }
            0x824B33A4 => {
    //   block [0x824B33A4..0x824B33BC)
	// 824B33A4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824B33A8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824B33AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B33B0: 4800F731  bl 0x824c2ae0
	ctx.lr = 0x824B33B4;
	sub_824C2AE0(ctx, base);
	// 824B33B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824B33B8: 480000DC  b 0x824b3494
	pc = 0x824B3494; continue 'dispatch;
            }
            0x824B33BC => {
    //   block [0x824B33BC..0x824B33D4)
	// 824B33BC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824B33C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824B33C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B33C8: 4800F379  bl 0x824c2740
	ctx.lr = 0x824B33CC;
	sub_824C2740(ctx, base);
	// 824B33CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824B33D0: 480000C4  b 0x824b3494
	pc = 0x824B3494; continue 'dispatch;
            }
            0x824B33D4 => {
    //   block [0x824B33D4..0x824B33EC)
	// 824B33D4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824B33D8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824B33DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B33E0: 4800F429  bl 0x824c2808
	ctx.lr = 0x824B33E4;
	sub_824C2808(ctx, base);
	// 824B33E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824B33E8: 480000AC  b 0x824b3494
	pc = 0x824B3494; continue 'dispatch;
            }
            0x824B33EC => {
    //   block [0x824B33EC..0x824B3404)
	// 824B33EC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824B33F0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824B33F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B33F8: 4800F539  bl 0x824c2930
	ctx.lr = 0x824B33FC;
	sub_824C2930(ctx, base);
	// 824B33FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824B3400: 48000094  b 0x824b3494
	pc = 0x824B3494; continue 'dispatch;
            }
            0x824B3404 => {
    //   block [0x824B3404..0x824B341C)
	// 824B3404: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824B3408: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824B340C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B3410: 4800F601  bl 0x824c2a10
	ctx.lr = 0x824B3414;
	sub_824C2A10(ctx, base);
	// 824B3414: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824B3418: 4800007C  b 0x824b3494
	pc = 0x824B3494; continue 'dispatch;
            }
            0x824B341C => {
    //   block [0x824B341C..0x824B3434)
	// 824B341C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824B3420: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824B3424: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B3428: 4800F209  bl 0x824c2630
	ctx.lr = 0x824B342C;
	sub_824C2630(ctx, base);
	// 824B342C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824B3430: 48000064  b 0x824b3494
	pc = 0x824B3494; continue 'dispatch;
            }
            0x824B3434 => {
    //   block [0x824B3434..0x824B344C)
	// 824B3434: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824B3438: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824B343C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B3440: 4800F101  bl 0x824c2540
	ctx.lr = 0x824B3444;
	sub_824C2540(ctx, base);
	// 824B3444: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824B3448: 4800004C  b 0x824b3494
	pc = 0x824B3494; continue 'dispatch;
            }
            0x824B344C => {
    //   block [0x824B344C..0x824B3464)
	// 824B344C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824B3450: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824B3454: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B3458: 4800EB99  bl 0x824c1ff0
	ctx.lr = 0x824B345C;
	sub_824C1FF0(ctx, base);
	// 824B345C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824B3460: 48000034  b 0x824b3494
	pc = 0x824B3494; continue 'dispatch;
            }
            0x824B3464 => {
    //   block [0x824B3464..0x824B347C)
	// 824B3464: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824B3468: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824B346C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B3470: 4800E189  bl 0x824c15f8
	ctx.lr = 0x824B3474;
	sub_824C15F8(ctx, base);
	// 824B3474: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824B3478: 4800001C  b 0x824b3494
	pc = 0x824B3494; continue 'dispatch;
            }
            0x824B347C => {
    //   block [0x824B347C..0x824B3494)
	// 824B347C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 824B3480: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824B3484: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B3488: 4800DEB9  bl 0x824c1340
	ctx.lr = 0x824B348C;
	sub_824C1340(ctx, base);
	// 824B348C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 824B3490: 409A000C  bne cr6, 0x824b349c
	if !ctx.cr[6].eq {
	pc = 0x824B349C; continue 'dispatch;
	}
	pc = 0x824B3494; continue 'dispatch;
            }
            0x824B3494 => {
    //   block [0x824B3494..0x824B349C)
	// 824B3494: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 824B3498: 419AFE48  beq cr6, 0x824b32e0
	if ctx.cr[6].eq {
	pc = 0x824B32E0; continue 'dispatch;
	}
	pc = 0x824B349C; continue 'dispatch;
            }
            0x824B349C => {
    //   block [0x824B349C..0x824B34CC)
	// 824B349C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 824B34A0: 419A0044  beq cr6, 0x824b34e4
	if ctx.cr[6].eq {
	pc = 0x824B34E4; continue 'dispatch;
	}
	// 824B34A4: 7C7BD02E  lwzx r3, r27, r26
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 824B34A8: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 824B34AC: 81430034  lwz r10, 0x34(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 824B34B0: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 824B34B4: 41980018  blt cr6, 0x824b34cc
	if ctx.cr[6].lt {
	pc = 0x824B34CC; continue 'dispatch;
	}
	// 824B34B8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 824B34BC: 3880000A  li r4, 0xa
	ctx.r[4].s64 = 10;
	// 824B34C0: 4BFB0A59  bl 0x82463f18
	ctx.lr = 0x824B34C4;
	sub_82463F18(ctx, base);
	// 824B34C4: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 824B34C8: 48081C38  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x824B34CC => {
    //   block [0x824B34CC..0x824B34E4)
	// 824B34CC: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 824B34D0: 81430088  lwz r10, 0x88(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) } as u64;
	// 824B34D4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824B34D8: 9163008C  stw r11, 0x8c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 824B34DC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824B34E0: 93E30088  stw r31, 0x88(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[31].u32 ) };
	pc = 0x824B34E4; continue 'dispatch;
            }
            0x824B34E4 => {
    //   block [0x824B34E4..0x824B34EC)
	// 824B34E4: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 824B34E8: 48081C18  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B34F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B34F0 size=68
    let mut pc: u32 = 0x824B34F0;
    'dispatch: loop {
        match pc {
            0x824B34F0 => {
    //   block [0x824B34F0..0x824B3534)
	// 824B34F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B34F4: 48081BC9  bl 0x825350bc
	ctx.lr = 0x824B34F8;
	sub_82535080(ctx, base);
	// 824B34F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B34FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824B3500: 3BDF0140  addi r30, r31, 0x140
	ctx.r[30].s64 = ctx.r[31].s64 + 320;
	// 824B3504: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824B3508: 4BFB2C71  bl 0x82466178
	ctx.lr = 0x824B350C;
	sub_82466178(ctx, base);
	// 824B350C: 83BF00FC  lwz r29, 0xfc(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 824B3510: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 824B3514: 395D0001  addi r10, r29, 1
	ctx.r[10].s64 = ctx.r[29].s64 + 1;
	// 824B3518: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824B351C: 915F00FC  stw r10, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[10].u32 ) };
	// 824B3520: F97E0020  std r11, 0x20(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[11].u64 ) };
	// 824B3524: 48259D49  bl 0x8270d26c
	ctx.lr = 0x824B3528;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 824B3528: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 824B352C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824B3530: 48081BDC  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B3538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B3538 size=188
    let mut pc: u32 = 0x824B3538;
    'dispatch: loop {
        match pc {
            0x824B3538 => {
    //   block [0x824B3538..0x824B3584)
	// 824B3538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B353C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824B3540: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824B3544: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824B3548: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B354C: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B3550: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824B3554: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824B3558: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B355C: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B3560: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824B3564: 40980020  bge cr6, 0x824b3584
	if !ctx.cr[6].lt {
	pc = 0x824B3584; continue 'dispatch;
	}
	// 824B3568: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824B356C: 39290728  addi r9, r9, 0x728
	ctx.r[9].s64 = ctx.r[9].s64 + 1832;
	// 824B3570: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824B3574: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824B3578: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824B357C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824B3580: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824B3584; continue 'dispatch;
            }
            0x824B3584 => {
    //   block [0x824B3584..0x824B3598)
	// 824B3584: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B3588: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B358C: 409A000C  bne cr6, 0x824b3598
	if !ctx.cr[6].eq {
	pc = 0x824B3598; continue 'dispatch;
	}
	// 824B3590: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 824B3594: 48000014  b 0x824b35a8
	pc = 0x824B35A8; continue 'dispatch;
            }
            0x824B3598 => {
    //   block [0x824B3598..0x824B35A8)
	// 824B3598: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 824B359C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824B35A0: 419A0008  beq cr6, 0x824b35a8
	if ctx.cr[6].eq {
	pc = 0x824B35A8; continue 'dispatch;
	}
	// 824B35A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x824B35A8; continue 'dispatch;
            }
            0x824B35A8 => {
    //   block [0x824B35A8..0x824B35DC)
	// 824B35A8: 4BFFFCA1  bl 0x824b3248
	ctx.lr = 0x824B35AC;
	sub_824B3248(ctx, base);
	// 824B35AC: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824B35B0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B35B4: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B35B8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824B35BC: 40980020  bge cr6, 0x824b35dc
	if !ctx.cr[6].lt {
	pc = 0x824B35DC; continue 'dispatch;
	}
	// 824B35C0: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 824B35C4: 392974DC  addi r9, r9, 0x74dc
	ctx.r[9].s64 = ctx.r[9].s64 + 29916;
	// 824B35C8: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824B35CC: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824B35D0: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824B35D4: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824B35D8: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824B35DC; continue 'dispatch;
            }
            0x824B35DC => {
    //   block [0x824B35DC..0x824B35F4)
	// 824B35DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824B35E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824B35E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824B35E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824B35EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824B35F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B3628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B3628 size=336
    let mut pc: u32 = 0x824B3628;
    'dispatch: loop {
        match pc {
            0x824B3628 => {
    //   block [0x824B3628..0x824B36F8)
	// 824B3628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B362C: 48081A91  bl 0x825350bc
	ctx.lr = 0x824B3630;
	sub_82535080(ctx, base);
	// 824B3630: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B3634: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824B3638: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824B363C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 824B3640: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B3644: 894B00D0  lbz r10, 0xd0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 824B3648: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824B364C: 419A0114  beq cr6, 0x824b3760
	if ctx.cr[6].eq {
	pc = 0x824B3760; continue 'dispatch;
	}
	// 824B3650: 815E01B8  lwz r10, 0x1b8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(440 as u32) ) } as u64;
	// 824B3654: 894A0010  lbz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B3658: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824B365C: 419A0104  beq cr6, 0x824b3760
	if ctx.cr[6].eq {
	pc = 0x824B3760; continue 'dispatch;
	}
	// 824B3660: 808B00D8  lwz r4, 0xd8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(216 as u32) ) } as u64;
	// 824B3664: 3960000F  li r11, 0xf
	ctx.r[11].s64 = 15;
	// 824B3668: 39050050  addi r8, r5, 0x50
	ctx.r[8].s64 = ctx.r[5].s64 + 80;
	// 824B366C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B3670: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 824B3674: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824B3678: B1610050  sth r11, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u16 ) };
	// 824B367C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824B3680: E8C80000  ld r6, 0(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	// 824B3684: E9080008  ld r8, 8(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	// 824B3688: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 824B368C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 824B3690: F8C90000  std r6, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 824B3694: F9090008  std r8, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[8].u64 ) };
	// 824B3698: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B369C: B1610052  sth r11, 0x52(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u16 ) };
	// 824B36A0: B1610064  sth r11, 0x64(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u16 ) };
	// 824B36A4: B1410068  sth r10, 0x68(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u16 ) };
	// 824B36A8: B081006A  sth r4, 0x6a(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(106 as u32), ctx.r[4].u16 ) };
	// 824B36AC: 9121006C  stw r9, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 824B36B0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 824B36B4: 98E10080  stb r7, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[7].u8 ) };
	// 824B36B8: 40990040  ble cr6, 0x824b36f8
	if !ctx.cr[6].gt {
	pc = 0x824B36F8; continue 'dispatch;
	}
	// 824B36BC: 396AFFFF  addi r11, r10, -1
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	// 824B36C0: 0CC40000  twi 6, r4, 0
	// 824B36C4: 556A083E  rotlwi r10, r11, 1
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 824B36C8: 7D6B23D6  divw r11, r11, r4
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[4].s32;
	// 824B36CC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 824B36D0: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 824B36D4: 7C8B5078  andc r11, r4, r10
	ctx.r[11].u64 = ctx.r[4].u64 & !ctx.r[10].u64;
	// 824B36D8: 0CABFFFF  twi 5, r11, -1
	// 824B36DC: 480112DD  bl 0x824c49b8
	ctx.lr = 0x824B36E0;
	sub_824C49B8(ctx, base);
	// 824B36E0: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 824B36E4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 824B36E8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 824B36EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B36F0: 387E0180  addi r3, r30, 0x180
	ctx.r[3].s64 = ctx.r[30].s64 + 384;
	// 824B36F4: 480F8D35  bl 0x825ac428
	ctx.lr = 0x824B36F8;
	sub_825AC428(ctx, base);
	pc = 0x824B36F8; continue 'dispatch;
            }
            0x824B36F8 => {
    //   block [0x824B36F8..0x824B3760)
	// 824B36F8: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 824B36FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824B3700: 4BFFFB49  bl 0x824b3248
	ctx.lr = 0x824B3704;
	sub_824B3248(ctx, base);
	// 824B3704: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B3708: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B370C: 40990064  ble cr6, 0x824b3770
	if !ctx.cr[6].gt {
	pc = 0x824B3770; continue 'dispatch;
	}
	// 824B3710: 3960000E  li r11, 0xe
	ctx.r[11].s64 = 14;
	// 824B3714: 809E000C  lwz r4, 0xc(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B3718: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 824B371C: 93A10094  stw r29, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[29].u32 ) };
	// 824B3720: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 824B3724: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 824B3728: B1610090  sth r11, 0x90(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u16 ) };
	// 824B372C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 824B3730: 91610098  stw r11, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 824B3734: A1610052  lhz r11, 0x52(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 824B3738: B1610092  sth r11, 0x92(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(146 as u32), ctx.r[11].u16 ) };
	// 824B373C: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 824B3740: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 824B3744: 4801175D  bl 0x824c4ea0
	ctx.lr = 0x824B3748;
	sub_824C4EA0(ctx, base);
	// 824B3748: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 824B374C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 824B3750: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 824B3754: 4800DBED  bl 0x824c1340
	ctx.lr = 0x824B3758;
	sub_824C1340(ctx, base);
	// 824B3758: 382101B0  addi r1, r1, 0x1b0
	ctx.r[1].s64 = ctx.r[1].s64 + 432;
	// 824B375C: 480819B0  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x824B3760 => {
    //   block [0x824B3760..0x824B3770)
	// 824B3760: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 824B3764: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824B3768: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824B376C: 48015B5D  bl 0x824c92c8
	ctx.lr = 0x824B3770;
	sub_824C92C8(ctx, base);
	pc = 0x824B3770; continue 'dispatch;
            }
            0x824B3770 => {
    //   block [0x824B3770..0x824B3778)
	// 824B3770: 382101B0  addi r1, r1, 0x1b0
	ctx.r[1].s64 = ctx.r[1].s64 + 432;
	// 824B3774: 48081998  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B3778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B3778 size=320
    let mut pc: u32 = 0x824B3778;
    'dispatch: loop {
        match pc {
            0x824B3778 => {
    //   block [0x824B3778..0x824B3824)
	// 824B3778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B377C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824B3780: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824B3784: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824B3788: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B378C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824B3790: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B3794: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B3798: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B379C: 88A90068  lbz r5, 0x68(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(104 as u32) ) } as u64;
	// 824B37A0: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 824B37A4: 890B0005  lbz r8, 5(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B37A8: 88CA0005  lbz r6, 5(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B37AC: 7D070774  extsb r7, r8
	ctx.r[7].s64 = ctx.r[8].s8 as i64;
	// 824B37B0: 7CC80774  extsb r8, r6
	ctx.r[8].s64 = ctx.r[6].s8 as i64;
	// 824B37B4: 7C675A14  add r3, r7, r11
	ctx.r[3].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 824B37B8: 7C885214  add r4, r8, r10
	ctx.r[4].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 824B37BC: 89630010  lbz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B37C0: 89040010  lbz r8, 0x10(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B37C4: 7D6A0774  extsb r10, r11
	ctx.r[10].s64 = ctx.r[11].s8 as i64;
	// 824B37C8: 7D0B0774  extsb r11, r8
	ctx.r[11].s64 = ctx.r[8].s8 as i64;
	// 824B37CC: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 824B37D0: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 824B37D4: 419A0080  beq cr6, 0x824b3854
	if ctx.cr[6].eq {
	pc = 0x824B3854; continue 'dispatch;
	}
	// 824B37D8: 890A00D8  lbz r8, 0xd8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(216 as u32) ) } as u64;
	// 824B37DC: 2B080007  cmplwi cr6, r8, 7
	ctx.cr[6].compare_u32(ctx.r[8].u32, 7 as u32, &mut ctx.xer);
	// 824B37E0: 419A0074  beq cr6, 0x824b3854
	if ctx.cr[6].eq {
	pc = 0x824B3854; continue 'dispatch;
	}
	// 824B37E4: 890B00D8  lbz r8, 0xd8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(216 as u32) ) } as u64;
	// 824B37E8: 2B080007  cmplwi cr6, r8, 7
	ctx.cr[6].compare_u32(ctx.r[8].u32, 7 as u32, &mut ctx.xer);
	// 824B37EC: 419A0068  beq cr6, 0x824b3854
	if ctx.cr[6].eq {
	pc = 0x824B3854; continue 'dispatch;
	}
	// 824B37F0: 814A00B8  lwz r10, 0xb8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(184 as u32) ) } as u64;
	// 824B37F4: 816B00B8  lwz r11, 0xb8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) } as u64;
	// 824B37F8: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824B37FC: 419A0058  beq cr6, 0x824b3854
	if ctx.cr[6].eq {
	pc = 0x824B3854; continue 'dispatch;
	}
	// 824B3800: 3BC9006C  addi r30, r9, 0x6c
	ctx.r[30].s64 = ctx.r[9].s64 + 108;
	// 824B3804: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B3808: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B380C: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824B3810: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824B3814: 409A0010  bne cr6, 0x824b3824
	if !ctx.cr[6].eq {
	pc = 0x824B3824; continue 'dispatch;
	}
	// 824B3818: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 824B381C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824B3820: 4BFBAB31  bl 0x8246e350
	ctx.lr = 0x824B3824;
	sub_8246E350(ctx, base);
	pc = 0x824B3824; continue 'dispatch;
            }
            0x824B3824 => {
    //   block [0x824B3824..0x824B3854)
	// 824B3824: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B3828: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B382C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824B3830: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B3834: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824B3838: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824B383C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B3840: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 824B3844: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B3848: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824B384C: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824B3850: 48000050  b 0x824b38a0
	pc = 0x824B38A0; continue 'dispatch;
            }
            0x824B3854 => {
    //   block [0x824B3854..0x824B38A0)
	// 824B3854: 8149000C  lwz r10, 0xc(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B3858: A163001A  lhz r11, 0x1a(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(26 as u32) ) } as u64;
	// 824B385C: A124001A  lhz r9, 0x1a(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(26 as u32) ) } as u64;
	// 824B3860: 80AA006C  lwz r5, 0x6c(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(108 as u32) ) } as u64;
	// 824B3864: 556A103E  rotlwi r10, r11, 2
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 824B3868: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824B386C: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824B3870: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B3874: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 824B3878: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 824B387C: 894A1BB0  lbz r10, 0x1bb0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(7088 as u32) ) } as u64;
	// 824B3880: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 824B3884: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824B3888: 419A0018  beq cr6, 0x824b38a0
	if ctx.cr[6].eq {
	pc = 0x824B38A0; continue 'dispatch;
	}
	// 824B388C: 554A3032  slwi r10, r10, 6
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824B3890: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 824B3894: 816B1C30  lwz r11, 0x1c30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7216 as u32) ) } as u64;
	// 824B3898: 91650010  stw r11, 0x10(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 824B389C: 480046ED  bl 0x824b7f88
	ctx.lr = 0x824B38A0;
	sub_824B7F88(ctx, base);
	pc = 0x824B38A0; continue 'dispatch;
            }
            0x824B38A0 => {
    //   block [0x824B38A0..0x824B38B8)
	// 824B38A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824B38A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824B38A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824B38AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824B38B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824B38B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B38B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B38B8 size=260
    let mut pc: u32 = 0x824B38B8;
    'dispatch: loop {
        match pc {
            0x824B38B8 => {
    //   block [0x824B38B8..0x824B3964)
	// 824B38B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B38BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824B38C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824B38C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824B38C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B38CC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824B38D0: 80E30004  lwz r7, 4(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B38D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B38D8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B38DC: 88A70068  lbz r5, 0x68(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(104 as u32) ) } as u64;
	// 824B38E0: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 824B38E4: 892B0005  lbz r9, 5(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B38E8: 88CA0005  lbz r6, 5(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B38EC: 7D280774  extsb r8, r9
	ctx.r[8].s64 = ctx.r[9].s8 as i64;
	// 824B38F0: 7CC90774  extsb r9, r6
	ctx.r[9].s64 = ctx.r[6].s8 as i64;
	// 824B38F4: 7C685A14  add r3, r8, r11
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 824B38F8: 7C895214  add r4, r9, r10
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 824B38FC: 89630010  lbz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B3900: 89240010  lbz r9, 0x10(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B3904: 7D6A0774  extsb r10, r11
	ctx.r[10].s64 = ctx.r[11].s8 as i64;
	// 824B3908: 7D2B0774  extsb r11, r9
	ctx.r[11].s64 = ctx.r[9].s8 as i64;
	// 824B390C: 7D4A1A14  add r10, r10, r3
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 824B3910: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 824B3914: 419A0080  beq cr6, 0x824b3994
	if ctx.cr[6].eq {
	pc = 0x824B3994; continue 'dispatch;
	}
	// 824B3918: 892A00D8  lbz r9, 0xd8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(216 as u32) ) } as u64;
	// 824B391C: 2B090007  cmplwi cr6, r9, 7
	ctx.cr[6].compare_u32(ctx.r[9].u32, 7 as u32, &mut ctx.xer);
	// 824B3920: 419A0074  beq cr6, 0x824b3994
	if ctx.cr[6].eq {
	pc = 0x824B3994; continue 'dispatch;
	}
	// 824B3924: 892B00D8  lbz r9, 0xd8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(216 as u32) ) } as u64;
	// 824B3928: 2B090007  cmplwi cr6, r9, 7
	ctx.cr[6].compare_u32(ctx.r[9].u32, 7 as u32, &mut ctx.xer);
	// 824B392C: 419A0068  beq cr6, 0x824b3994
	if ctx.cr[6].eq {
	pc = 0x824B3994; continue 'dispatch;
	}
	// 824B3930: 814A00B8  lwz r10, 0xb8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(184 as u32) ) } as u64;
	// 824B3934: 816B00B8  lwz r11, 0xb8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) } as u64;
	// 824B3938: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824B393C: 419A0058  beq cr6, 0x824b3994
	if ctx.cr[6].eq {
	pc = 0x824B3994; continue 'dispatch;
	}
	// 824B3940: 3BC700B0  addi r30, r7, 0xb0
	ctx.r[30].s64 = ctx.r[7].s64 + 176;
	// 824B3944: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B3948: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B394C: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824B3950: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824B3954: 409A0010  bne cr6, 0x824b3964
	if !ctx.cr[6].eq {
	pc = 0x824B3964; continue 'dispatch;
	}
	// 824B3958: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 824B395C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824B3960: 4BFBA9F1  bl 0x8246e350
	ctx.lr = 0x824B3964;
	sub_8246E350(ctx, base);
	pc = 0x824B3964; continue 'dispatch;
            }
            0x824B3964 => {
    //   block [0x824B3964..0x824B3994)
	// 824B3964: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B3968: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B396C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824B3970: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B3974: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824B3978: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824B397C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B3980: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 824B3984: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B3988: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824B398C: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 824B3990: 48000014  b 0x824b39a4
	pc = 0x824B39A4; continue 'dispatch;
            }
            0x824B3994 => {
    //   block [0x824B3994..0x824B39A4)
	// 824B3994: 48020EAD  bl 0x824d4840
	ctx.lr = 0x824B3998;
	sub_824D4840(ctx, base);
	// 824B3998: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 824B399C: 419A0008  beq cr6, 0x824b39a4
	if ctx.cr[6].eq {
	pc = 0x824B39A4; continue 'dispatch;
	}
	// 824B39A0: 48004711  bl 0x824b80b0
	ctx.lr = 0x824B39A4;
	sub_824B80B0(ctx, base);
	pc = 0x824B39A4; continue 'dispatch;
            }
            0x824B39A4 => {
    //   block [0x824B39A4..0x824B39BC)
	// 824B39A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824B39A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824B39AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824B39B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824B39B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824B39B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B39C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B39C0 size=856
    let mut pc: u32 = 0x824B39C0;
    'dispatch: loop {
        match pc {
            0x824B39C0 => {
    //   block [0x824B39C0..0x824B3A74)
	// 824B39C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B39C4: 480816D1  bl 0x82535094
	ctx.lr = 0x824B39C8;
	sub_82535080(ctx, base);
	// 824B39C8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B39CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824B39D0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 824B39D4: 48013F15  bl 0x824c78e8
	ctx.lr = 0x824B39D8;
	sub_824C78E8(ctx, base);
	// 824B39D8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824B39DC: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 824B39E0: 396B0A64  addi r11, r11, 0xa64
	ctx.r[11].s64 = ctx.r[11].s64 + 2660;
	// 824B39E4: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824B39E8: 3D008206  lis r8, -0x7dfa
	ctx.r[8].s64 = -2113536000;
	// 824B39EC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 824B39F0: 3A7F0050  addi r19, r31, 0x50
	ctx.r[19].s64 = ctx.r[31].s64 + 80;
	// 824B39F4: 394A0A34  addi r10, r10, 0xa34
	ctx.r[10].s64 = ctx.r[10].s64 + 2612;
	// 824B39F8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824B39FC: 3A9F0058  addi r20, r31, 0x58
	ctx.r[20].s64 = ctx.r[31].s64 + 88;
	// 824B3A00: 39290A44  addi r9, r9, 0xa44
	ctx.r[9].s64 = ctx.r[9].s64 + 2628;
	// 824B3A04: 3B5F0078  addi r26, r31, 0x78
	ctx.r[26].s64 = ctx.r[31].s64 + 120;
	// 824B3A08: 3B3F0060  addi r25, r31, 0x60
	ctx.r[25].s64 = ctx.r[31].s64 + 96;
	// 824B3A0C: 93B30004  stw r29, 4(r19)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[19].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 824B3A10: 39080A54  addi r8, r8, 0xa54
	ctx.r[8].s64 = ctx.r[8].s64 + 2644;
	// 824B3A14: 91530000  stw r10, 0(r19)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[19].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 824B3A18: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 824B3A1C: 93B40004  stw r29, 4(r20)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[20].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 824B3A20: 3EA08000  lis r21, -0x8000
	ctx.r[21].s64 = -2147483648;
	// 824B3A24: 91340000  stw r9, 0(r20)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[20].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824B3A28: 3B9A0028  addi r28, r26, 0x28
	ctx.r[28].s64 = ctx.r[26].s64 + 40;
	// 824B3A2C: 3B000FA0  li r24, 0xfa0
	ctx.r[24].s64 = 4000;
	// 824B3A30: 93B90004  stw r29, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 824B3A34: 3BCB9198  addi r30, r11, -0x6e68
	ctx.r[30].s64 = ctx.r[11].s64 + -28264;
	// 824B3A38: 91190000  stw r8, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 824B3A3C: 93BF006C  stw r29, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 824B3A40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824B3A44: 93BF0070  stw r29, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 824B3A48: 92BF0074  stw r21, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[21].u32 ) };
	// 824B3A4C: 931C0000  stw r24, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824B3A50: 93BC0004  stw r29, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 824B3A54: 93BC0008  stw r29, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 824B3A58: 4BFB2721  bl 0x82466178
	ctx.lr = 0x824B3A5C;
	sub_82466178(ctx, base);
	// 824B3A5C: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 824B3A60: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 824B3A64: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824B3A68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B3A6C: 419A0008  beq cr6, 0x824b3a74
	if ctx.cr[6].eq {
	pc = 0x824B3A74; continue 'dispatch;
	}
	// 824B3A70: 934B002C  stw r26, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[26].u32 ) };
	pc = 0x824B3A74; continue 'dispatch;
            }
            0x824B3A74 => {
    //   block [0x824B3A74..0x824B3AE0)
	// 824B3A74: 3AC0FFFF  li r22, -1
	ctx.r[22].s64 = -1;
	// 824B3A78: 93DC0004  stw r30, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 824B3A7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824B3A80: 935E0030  stw r26, 0x30(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[26].u32 ) };
	// 824B3A84: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 824B3A88: F97E0020  std r11, 0x20(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[11].u64 ) };
	// 824B3A8C: 482597E1  bl 0x8270d26c
	ctx.lr = 0x824B3A90;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 824B3A90: 38800FA0  li r4, 0xfa0
	ctx.r[4].s64 = 4000;
	// 824B3A94: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 824B3A98: 4825A285  bl 0x8270dd1c
	ctx.lr = 0x824B3A9C;
	// extern call 0x8270DD1C  crate::xboxkrnl::RtlInitializeCriticalSectionAndSpinCount
	crate::xboxkrnl::RtlInitializeCriticalSectionAndSpinCount(ctx, base);
	// 824B3A9C: 3AFF00C0  addi r23, r31, 0xc0
	ctx.r[23].s64 = ctx.r[31].s64 + 192;
	// 824B3AA0: FADA0020  std r22, 0x20(r26)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[26].u32.wrapping_add(32 as u32), ctx.r[22].u64 ) };
	// 824B3AA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824B3AA8: 3B970028  addi r28, r23, 0x28
	ctx.r[28].s64 = ctx.r[23].s64 + 40;
	// 824B3AAC: 93BF00B0  stw r29, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[29].u32 ) };
	// 824B3AB0: 93BF00B4  stw r29, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[29].u32 ) };
	// 824B3AB4: 92BF00B8  stw r21, 0xb8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[21].u32 ) };
	// 824B3AB8: 931C0000  stw r24, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824B3ABC: 93BC0004  stw r29, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 824B3AC0: 93BC0008  stw r29, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 824B3AC4: 4BFB26B5  bl 0x82466178
	ctx.lr = 0x824B3AC8;
	sub_82466178(ctx, base);
	// 824B3AC8: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 824B3ACC: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 824B3AD0: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824B3AD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B3AD8: 419A0008  beq cr6, 0x824b3ae0
	if ctx.cr[6].eq {
	pc = 0x824B3AE0; continue 'dispatch;
	}
	// 824B3ADC: 92EB002C  stw r23, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[23].u32 ) };
	pc = 0x824B3AE0; continue 'dispatch;
            }
            0x824B3AE0 => {
    //   block [0x824B3AE0..0x824B3B54)
	// 824B3AE0: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 824B3AE4: 93DC0004  stw r30, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 824B3AE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824B3AEC: 92FE0030  stw r23, 0x30(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[23].u32 ) };
	// 824B3AF0: F97E0020  std r11, 0x20(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[11].u64 ) };
	// 824B3AF4: 48259779  bl 0x8270d26c
	ctx.lr = 0x824B3AF8;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 824B3AF8: 38800FA0  li r4, 0xfa0
	ctx.r[4].s64 = 4000;
	// 824B3AFC: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 824B3B00: 4825A21D  bl 0x8270dd1c
	ctx.lr = 0x824B3B04;
	// extern call 0x8270DD1C  crate::xboxkrnl::RtlInitializeCriticalSectionAndSpinCount
	crate::xboxkrnl::RtlInitializeCriticalSectionAndSpinCount(ctx, base);
	// 824B3B04: 387F00F8  addi r3, r31, 0xf8
	ctx.r[3].s64 = ctx.r[31].s64 + 248;
	// 824B3B08: FAD70020  std r22, 0x20(r23)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[23].u32.wrapping_add(32 as u32), ctx.r[22].u64 ) };
	// 824B3B0C: 4BFDF22D  bl 0x82492d38
	ctx.lr = 0x824B3B10;
	sub_82492D38(ctx, base);
	// 824B3B10: 38A0000A  li r5, 0xa
	ctx.r[5].s64 = 10;
	// 824B3B14: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 824B3B18: 387F0100  addi r3, r31, 0x100
	ctx.r[3].s64 = ctx.r[31].s64 + 256;
	// 824B3B1C: 480F954D  bl 0x825ad068
	ctx.lr = 0x824B3B20;
	sub_825AD068(ctx, base);
	// 824B3B20: 3B5F0140  addi r26, r31, 0x140
	ctx.r[26].s64 = ctx.r[31].s64 + 320;
	// 824B3B24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824B3B28: 3B9A0028  addi r28, r26, 0x28
	ctx.r[28].s64 = ctx.r[26].s64 + 40;
	// 824B3B2C: 931C0000  stw r24, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824B3B30: 93BC0004  stw r29, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 824B3B34: 93BC0008  stw r29, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 824B3B38: 4BFB2641  bl 0x82466178
	ctx.lr = 0x824B3B3C;
	sub_82466178(ctx, base);
	// 824B3B3C: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 824B3B40: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 824B3B44: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824B3B48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B3B4C: 419A0008  beq cr6, 0x824b3b54
	if ctx.cr[6].eq {
	pc = 0x824B3B54; continue 'dispatch;
	}
	// 824B3B50: 934B002C  stw r26, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[26].u32 ) };
	pc = 0x824B3B54; continue 'dispatch;
            }
            0x824B3B54 => {
    //   block [0x824B3B54..0x824B3C00)
	// 824B3B54: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 824B3B58: 93DC0004  stw r30, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 824B3B5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824B3B60: 935E0030  stw r26, 0x30(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[26].u32 ) };
	// 824B3B64: F97E0020  std r11, 0x20(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[11].u64 ) };
	// 824B3B68: 48259705  bl 0x8270d26c
	ctx.lr = 0x824B3B6C;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 824B3B6C: 38800FA0  li r4, 0xfa0
	ctx.r[4].s64 = 4000;
	// 824B3B70: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 824B3B74: 4825A1A9  bl 0x8270dd1c
	ctx.lr = 0x824B3B78;
	// extern call 0x8270DD1C  crate::xboxkrnl::RtlInitializeCriticalSectionAndSpinCount
	crate::xboxkrnl::RtlInitializeCriticalSectionAndSpinCount(ctx, base);
	// 824B3B78: 3B9F0300  addi r28, r31, 0x300
	ctx.r[28].s64 = ctx.r[31].s64 + 768;
	// 824B3B7C: 3AFF0280  addi r23, r31, 0x280
	ctx.r[23].s64 = ctx.r[31].s64 + 640;
	// 824B3B80: FADA0020  std r22, 0x20(r26)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[26].u32.wrapping_add(32 as u32), ctx.r[22].u64 ) };
	// 824B3B84: 3ABF0200  addi r21, r31, 0x200
	ctx.r[21].s64 = ctx.r[31].s64 + 512;
	// 824B3B88: 387F0180  addi r3, r31, 0x180
	ctx.r[3].s64 = ctx.r[31].s64 + 384;
	// 824B3B8C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 824B3B90: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 824B3B94: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 824B3B98: 480F8681  bl 0x825ac218
	ctx.lr = 0x824B3B9C;
	sub_825AC218(ctx, base);
	// 824B3B9C: 38A003E8  li r5, 0x3e8
	ctx.r[5].s64 = 1000;
	// 824B3BA0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 824B3BA4: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 824B3BA8: 480F94C1  bl 0x825ad068
	ctx.lr = 0x824B3BAC;
	sub_825AD068(ctx, base);
	// 824B3BAC: 38A003E8  li r5, 0x3e8
	ctx.r[5].s64 = 1000;
	// 824B3BB0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 824B3BB4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 824B3BB8: 480F94B1  bl 0x825ad068
	ctx.lr = 0x824B3BBC;
	sub_825AD068(ctx, base);
	// 824B3BBC: 38A003E8  li r5, 0x3e8
	ctx.r[5].s64 = 1000;
	// 824B3BC0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 824B3BC4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824B3BC8: 480F94A1  bl 0x825ad068
	ctx.lr = 0x824B3BCC;
	sub_825AD068(ctx, base);
	// 824B3BCC: 3B5F0340  addi r26, r31, 0x340
	ctx.r[26].s64 = ctx.r[31].s64 + 832;
	// 824B3BD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824B3BD4: 3B9A0028  addi r28, r26, 0x28
	ctx.r[28].s64 = ctx.r[26].s64 + 40;
	// 824B3BD8: 931C0000  stw r24, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824B3BDC: 93BC0004  stw r29, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 824B3BE0: 93BC0008  stw r29, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 824B3BE4: 4BFB2595  bl 0x82466178
	ctx.lr = 0x824B3BE8;
	sub_82466178(ctx, base);
	// 824B3BE8: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 824B3BEC: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 824B3BF0: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824B3BF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B3BF8: 419A0008  beq cr6, 0x824b3c00
	if ctx.cr[6].eq {
	pc = 0x824B3C00; continue 'dispatch;
	}
	// 824B3BFC: 934B002C  stw r26, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[26].u32 ) };
	pc = 0x824B3C00; continue 'dispatch;
            }
            0x824B3C00 => {
    //   block [0x824B3C00..0x824B3C5C)
	// 824B3C00: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 824B3C04: 93DC0004  stw r30, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 824B3C08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824B3C0C: 935E0030  stw r26, 0x30(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[26].u32 ) };
	// 824B3C10: F97E0020  std r11, 0x20(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[11].u64 ) };
	// 824B3C14: 48259659  bl 0x8270d26c
	ctx.lr = 0x824B3C18;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 824B3C18: 38800FA0  li r4, 0xfa0
	ctx.r[4].s64 = 4000;
	// 824B3C1C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 824B3C20: 4825A0FD  bl 0x8270dd1c
	ctx.lr = 0x824B3C24;
	// extern call 0x8270DD1C  crate::xboxkrnl::RtlInitializeCriticalSectionAndSpinCount
	crate::xboxkrnl::RtlInitializeCriticalSectionAndSpinCount(ctx, base);
	// 824B3C24: 3B9F0380  addi r28, r31, 0x380
	ctx.r[28].s64 = ctx.r[31].s64 + 896;
	// 824B3C28: FADA0020  std r22, 0x20(r26)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[26].u32.wrapping_add(32 as u32), ctx.r[22].u64 ) };
	// 824B3C2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824B3C30: 3B5C0028  addi r26, r28, 0x28
	ctx.r[26].s64 = ctx.r[28].s64 + 40;
	// 824B3C34: 931A0000  stw r24, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 824B3C38: 93BA0004  stw r29, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 824B3C3C: 93BA0008  stw r29, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 824B3C40: 4BFB2539  bl 0x82466178
	ctx.lr = 0x824B3C44;
	sub_82466178(ctx, base);
	// 824B3C44: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 824B3C48: 917A0008  stw r11, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 824B3C4C: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824B3C50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B3C54: 419A0008  beq cr6, 0x824b3c5c
	if ctx.cr[6].eq {
	pc = 0x824B3C5C; continue 'dispatch;
	}
	// 824B3C58: 938B002C  stw r28, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[28].u32 ) };
	pc = 0x824B3C5C; continue 'dispatch;
            }
            0x824B3C5C => {
    //   block [0x824B3C5C..0x824B3D18)
	// 824B3C5C: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 824B3C60: 93DA0004  stw r30, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 824B3C64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824B3C68: 939E0030  stw r28, 0x30(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[28].u32 ) };
	// 824B3C6C: F97E0020  std r11, 0x20(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[11].u64 ) };
	// 824B3C70: 482595FD  bl 0x8270d26c
	ctx.lr = 0x824B3C74;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 824B3C74: 38800FA0  li r4, 0xfa0
	ctx.r[4].s64 = 4000;
	// 824B3C78: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824B3C7C: 4825A0A1  bl 0x8270dd1c
	ctx.lr = 0x824B3C80;
	// extern call 0x8270DD1C  crate::xboxkrnl::RtlInitializeCriticalSectionAndSpinCount
	crate::xboxkrnl::RtlInitializeCriticalSectionAndSpinCount(ctx, base);
	// 824B3C80: FADC0020  std r22, 0x20(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(32 as u32), ctx.r[22].u64 ) };
	// 824B3C84: 93BF00FC  stw r29, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[29].u32 ) };
	// 824B3C88: 38802710  li r4, 0x2710
	ctx.r[4].s64 = 10000;
	// 824B3C8C: 9BBF0068  stb r29, 0x68(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[29].u8 ) };
	// 824B3C90: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B3C94: 806B0054  lwz r3, 0x54(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 824B3C98: 48022651  bl 0x824d62e8
	ctx.lr = 0x824B3C9C;
	sub_824D62E8(ctx, base);
	// 824B3C9C: 93FF0054  stw r31, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 824B3CA0: 3D40824C  lis r10, -0x7db4
	ctx.r[10].s64 = -2108948480;
	// 824B3CA4: 939F005C  stw r28, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 824B3CA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B3CAC: 817B0058  lwz r11, 0x58(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(88 as u32) ) } as u64;
	// 824B3CB0: 394A4B90  addi r10, r10, 0x4b90
	ctx.r[10].s64 = ctx.r[10].s64 + 19344;
	// 824B3CB4: 926B0024  stw r19, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[19].u32 ) };
	// 824B3CB8: 3D60824C  lis r11, -0x7db4
	ctx.r[11].s64 = -2108948480;
	// 824B3CBC: 813B0058  lwz r9, 0x58(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(88 as u32) ) } as u64;
	// 824B3CC0: 396B5028  addi r11, r11, 0x5028
	ctx.r[11].s64 = ctx.r[11].s64 + 20520;
	// 824B3CC4: 92890044  stw r20, 0x44(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(68 as u32), ctx.r[20].u32 ) };
	// 824B3CC8: 813B0058  lwz r9, 0x58(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(88 as u32) ) } as u64;
	// 824B3CCC: 92890028  stw r20, 0x28(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(40 as u32), ctx.r[20].u32 ) };
	// 824B3CD0: 813B0058  lwz r9, 0x58(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(88 as u32) ) } as u64;
	// 824B3CD4: 92890048  stw r20, 0x48(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(72 as u32), ctx.r[20].u32 ) };
	// 824B3CD8: 939F0064  stw r28, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 824B3CDC: 813B0058  lwz r9, 0x58(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(88 as u32) ) } as u64;
	// 824B3CE0: 9329002C  stw r25, 0x2c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(44 as u32), ctx.r[25].u32 ) };
	// 824B3CE4: 813B0058  lwz r9, 0x58(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(88 as u32) ) } as u64;
	// 824B3CE8: 93290064  stw r25, 0x64(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(100 as u32), ctx.r[25].u32 ) };
	// 824B3CEC: 813B0058  lwz r9, 0x58(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(88 as u32) ) } as u64;
	// 824B3CF0: 9329004C  stw r25, 0x4c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(76 as u32), ctx.r[25].u32 ) };
	// 824B3CF4: 813B0058  lwz r9, 0x58(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(88 as u32) ) } as u64;
	// 824B3CF8: 93290068  stw r25, 0x68(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(104 as u32), ctx.r[25].u32 ) };
	// 824B3CFC: 813B0058  lwz r9, 0x58(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(88 as u32) ) } as u64;
	// 824B3D00: 9329006C  stw r25, 0x6c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(108 as u32), ctx.r[25].u32 ) };
	// 824B3D04: 915F01C8  stw r10, 0x1c8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(456 as u32), ctx.r[10].u32 ) };
	// 824B3D08: 917F01CC  stw r11, 0x1cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(460 as u32), ctx.r[11].u32 ) };
	// 824B3D0C: 937F01D0  stw r27, 0x1d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(464 as u32), ctx.r[27].u32 ) };
	// 824B3D10: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 824B3D14: 480813D0  b 0x825350e4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B3D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B3D18 size=248
    let mut pc: u32 = 0x824B3D18;
    'dispatch: loop {
        match pc {
            0x824B3D18 => {
    //   block [0x824B3D18..0x824B3DAC)
	// 824B3D18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B3D1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824B3D20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824B3D24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B3D28: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824B3D2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824B3D30: 396B0A64  addi r11, r11, 0xa64
	ctx.r[11].s64 = ctx.r[11].s64 + 2660;
	// 824B3D34: 387F03A8  addi r3, r31, 0x3a8
	ctx.r[3].s64 = ctx.r[31].s64 + 936;
	// 824B3D38: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824B3D3C: 4BFB25E5  bl 0x82466320
	ctx.lr = 0x824B3D40;
	sub_82466320(ctx, base);
	// 824B3D40: 387F0368  addi r3, r31, 0x368
	ctx.r[3].s64 = ctx.r[31].s64 + 872;
	// 824B3D44: 4BFB25DD  bl 0x82466320
	ctx.lr = 0x824B3D48;
	sub_82466320(ctx, base);
	// 824B3D48: 387F0300  addi r3, r31, 0x300
	ctx.r[3].s64 = ctx.r[31].s64 + 768;
	// 824B3D4C: 480F935D  bl 0x825ad0a8
	ctx.lr = 0x824B3D50;
	sub_825AD0A8(ctx, base);
	// 824B3D50: 387F0280  addi r3, r31, 0x280
	ctx.r[3].s64 = ctx.r[31].s64 + 640;
	// 824B3D54: 480F9355  bl 0x825ad0a8
	ctx.lr = 0x824B3D58;
	sub_825AD0A8(ctx, base);
	// 824B3D58: 387F0200  addi r3, r31, 0x200
	ctx.r[3].s64 = ctx.r[31].s64 + 512;
	// 824B3D5C: 480F934D  bl 0x825ad0a8
	ctx.lr = 0x824B3D60;
	sub_825AD0A8(ctx, base);
	// 824B3D60: 387F0180  addi r3, r31, 0x180
	ctx.r[3].s64 = ctx.r[31].s64 + 384;
	// 824B3D64: 480F90D5  bl 0x825ace38
	ctx.lr = 0x824B3D68;
	sub_825ACE38(ctx, base);
	// 824B3D68: 387F0168  addi r3, r31, 0x168
	ctx.r[3].s64 = ctx.r[31].s64 + 360;
	// 824B3D6C: 4BFB25B5  bl 0x82466320
	ctx.lr = 0x824B3D70;
	sub_82466320(ctx, base);
	// 824B3D70: 387F0100  addi r3, r31, 0x100
	ctx.r[3].s64 = ctx.r[31].s64 + 256;
	// 824B3D74: 480F9335  bl 0x825ad0a8
	ctx.lr = 0x824B3D78;
	sub_825AD0A8(ctx, base);
	// 824B3D78: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 824B3D7C: 4BFB25A5  bl 0x82466320
	ctx.lr = 0x824B3D80;
	sub_82466320(ctx, base);
	// 824B3D80: 817F00B8  lwz r11, 0xb8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 824B3D84: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824B3D88: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824B3D8C: 409A0020  bne cr6, 0x824b3dac
	if !ctx.cr[6].eq {
	pc = 0x824B3DAC; continue 'dispatch;
	}
	// 824B3D90: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B3D94: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824B3D98: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824B3D9C: 809F00B0  lwz r4, 0xb0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 824B3DA0: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824B3DA4: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824B3DA8: 4BFB0311  bl 0x824640b8
	ctx.lr = 0x824B3DAC;
	sub_824640B8(ctx, base);
	pc = 0x824B3DAC; continue 'dispatch;
            }
            0x824B3DAC => {
    //   block [0x824B3DAC..0x824B3DE0)
	// 824B3DAC: 387F00A0  addi r3, r31, 0xa0
	ctx.r[3].s64 = ctx.r[31].s64 + 160;
	// 824B3DB0: 4BFB2571  bl 0x82466320
	ctx.lr = 0x824B3DB4;
	sub_82466320(ctx, base);
	// 824B3DB4: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 824B3DB8: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824B3DBC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824B3DC0: 409A0020  bne cr6, 0x824b3de0
	if !ctx.cr[6].eq {
	pc = 0x824B3DE0; continue 'dispatch;
	}
	// 824B3DC4: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B3DC8: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824B3DCC: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824B3DD0: 809F006C  lwz r4, 0x6c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 824B3DD4: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824B3DD8: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824B3DDC: 4BFB02DD  bl 0x824640b8
	ctx.lr = 0x824B3DE0;
	sub_824640B8(ctx, base);
	pc = 0x824B3DE0; continue 'dispatch;
            }
            0x824B3DE0 => {
    //   block [0x824B3DE0..0x824B3E10)
	// 824B3DE0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824B3DE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B3DE8: 396BFAC4  addi r11, r11, -0x53c
	ctx.r[11].s64 = ctx.r[11].s64 + -1340;
	// 824B3DEC: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 824B3DF0: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 824B3DF4: 917F0050  stw r11, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 824B3DF8: 48013BA1  bl 0x824c7998
	ctx.lr = 0x824B3DFC;
	sub_824C7998(ctx, base);
	// 824B3DFC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824B3E00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824B3E04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824B3E08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824B3E0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B3E10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B3E10 size=200
    let mut pc: u32 = 0x824B3E10;
    'dispatch: loop {
        match pc {
            0x824B3E10 => {
    //   block [0x824B3E10..0x824B3E28)
	// 824B3E10: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B3E14: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B3E18: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824B3E1C: 7CCB5214  add r6, r11, r10
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824B3E20: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 824B3E24: 4098008C  bge cr6, 0x824b3eb0
	if !ctx.cr[6].lt {
	pc = 0x824B3EB0; continue 'dispatch;
	}
	pc = 0x824B3E28; continue 'dispatch;
            }
            0x824B3E28 => {
    //   block [0x824B3E28..0x824B3E64)
	// 824B3E28: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B3E2C: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B3E30: 892B0005  lbz r9, 5(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B3E34: 7D290774  extsb r9, r9
	ctx.r[9].s64 = ctx.r[9].s8 as i64;
	// 824B3E38: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 824B3E3C: 89680005  lbz r11, 5(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B3E40: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824B3E44: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 824B3E48: 88EB0018  lbz r7, 0x18(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824B3E4C: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 824B3E50: 409A0014  bne cr6, 0x824b3e64
	if !ctx.cr[6].eq {
	pc = 0x824B3E64; continue 'dispatch;
	}
	// 824B3E54: 88EB0010  lbz r7, 0x10(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B3E58: 7CE70774  extsb r7, r7
	ctx.r[7].s64 = ctx.r[7].s8 as i64;
	// 824B3E5C: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 824B3E60: 48000008  b 0x824b3e68
	pc = 0x824B3E68; continue 'dispatch;
            }
            0x824B3E64 => {
    //   block [0x824B3E64..0x824B3E68)
	// 824B3E64: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x824B3E68; continue 'dispatch;
            }
            0x824B3E68 => {
    //   block [0x824B3E68..0x824B3E88)
	// 824B3E68: 88A90018  lbz r5, 0x18(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 824B3E6C: 80EB00C0  lwz r7, 0xc0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) } as u64;
	// 824B3E70: 2B050001  cmplwi cr6, r5, 1
	ctx.cr[6].compare_u32(ctx.r[5].u32, 1 as u32, &mut ctx.xer);
	// 824B3E74: 409A0014  bne cr6, 0x824b3e88
	if !ctx.cr[6].eq {
	pc = 0x824B3E88; continue 'dispatch;
	}
	// 824B3E78: 89690010  lbz r11, 0x10(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B3E7C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824B3E80: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 824B3E84: 48000008  b 0x824b3e8c
	pc = 0x824B3E8C; continue 'dispatch;
            }
            0x824B3E88 => {
    //   block [0x824B3E88..0x824B3E8C)
	// 824B3E88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x824B3E8C; continue 'dispatch;
            }
            0x824B3E8C => {
    //   block [0x824B3E8C..0x824B3EA4)
	// 824B3E8C: 816B00C0  lwz r11, 0xc0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) } as u64;
	// 824B3E90: 7F075800  cmpw cr6, r7, r11
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824B3E94: 40990010  ble cr6, 0x824b3ea4
	if !ctx.cr[6].gt {
	pc = 0x824B3EA4; continue 'dispatch;
	}
	// 824B3E98: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B3E9C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824B3EA0: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824B3EA4; continue 'dispatch;
            }
            0x824B3EA4 => {
    //   block [0x824B3EA4..0x824B3EB0)
	// 824B3EA4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 824B3EA8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 824B3EAC: 4198FF7C  blt cr6, 0x824b3e28
	if ctx.cr[6].lt {
	pc = 0x824B3E28; continue 'dispatch;
	}
	pc = 0x824B3EB0; continue 'dispatch;
            }
            0x824B3EB0 => {
    //   block [0x824B3EB0..0x824B3ED8)
	// 824B3EB0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B3EB4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 824B3EB8: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 824B3EBC: 3D40824B  lis r10, -0x7db5
	ctx.r[10].s64 = -2109014016;
	// 824B3EC0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B3EC4: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 824B3EC8: 38CA30E0  addi r6, r10, 0x30e0
	ctx.r[6].s64 = ctx.r[10].s64 + 12512;
	// 824B3ECC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 824B3ED0: 48000C48  b 0x824b4b18
	sub_824B4B18(ctx, base);
	return;
	// 824B3ED4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B3ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824B3ED8 size=736
    let mut pc: u32 = 0x824B3ED8;
    'dispatch: loop {
        match pc {
            0x824B3ED8 => {
    //   block [0x824B3ED8..0x824B3F20)
	// 824B3ED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B3EDC: 480811D9  bl 0x825350b4
	ctx.lr = 0x824B3EE0;
	sub_82535080(ctx, base);
	// 824B3EE0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B3EE4: 836D0000  lwz r27, 0(r13)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B3EE8: 3B800014  li r28, 0x14
	ctx.r[28].s64 = 20;
	// 824B3EEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824B3EF0: 7D5CD82E  lwzx r10, r28, r27
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 824B3EF4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B3EF8: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B3EFC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824B3F00: 40980020  bge cr6, 0x824b3f20
	if !ctx.cr[6].lt {
	pc = 0x824B3F20; continue 'dispatch;
	}
	// 824B3F04: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824B3F08: 39290728  addi r9, r9, 0x728
	ctx.r[9].s64 = ctx.r[9].s64 + 1832;
	// 824B3F0C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824B3F10: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824B3F14: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824B3F18: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824B3F1C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824B3F20; continue 'dispatch;
            }
            0x824B3F20 => {
    //   block [0x824B3F20..0x824B3F7C)
	// 824B3F20: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 824B3F24: 9BDF0068  stb r30, 0x68(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[30].u8 ) };
	// 824B3F28: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B3F2C: 814B0084  lwz r10, 0x84(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 824B3F30: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824B3F34: 914B0084  stw r10, 0x84(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 824B3F38: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B3F3C: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 824B3F40: 9BCB001C  stb r30, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 824B3F44: C01F0018  lfs f0, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B3F48: EDA0082A  fadds f13, f0, f1
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	// 824B3F4C: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 824B3F50: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824B3F54: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 824B3F58: D03F001C  stfs f1, 0x1c(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 824B3F5C: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 824B3F60: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B3F64: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 824B3F68: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 824B3F6C: 419A0010  beq cr6, 0x824b3f7c
	if ctx.cr[6].eq {
	pc = 0x824B3F7C; continue 'dispatch;
	}
	// 824B3F70: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824B3F74: C00B1850  lfs f0, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B3F78: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	pc = 0x824B3F7C; continue 'dispatch;
            }
            0x824B3F7C => {
    //   block [0x824B3F7C..0x824B41B8)
	// 824B3F7C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 824B3F80: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B3F84: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 824B3F88: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 824B3F8C: 39290190  addi r9, r9, 0x190
	ctx.r[9].s64 = ctx.r[9].s64 + 400;
	// 824B3F90: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 824B3F94: E90B0000  ld r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 824B3F98: F9090000  std r8, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 824B3F9C: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 824B3FA0: F9690008  std r11, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 824B3FA4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B3FA8: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 824B3FAC: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 824B3FB0: 396B0050  addi r11, r11, 0x50
	ctx.r[11].s64 = ctx.r[11].s64 + 80;
	// 824B3FB4: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 824B3FB8: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 824B3FBC: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 824B3FC0: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B3FC4: 8064004C  lwz r3, 0x4c(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 824B3FC8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B3FCC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 824B3FD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B3FD4: 4E800421  bctrl
	ctx.lr = 0x824B3FD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824B3FD8: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B3FDC: 4BFEBE85  bl 0x8249fe60
	ctx.lr = 0x824B3FE0;
	sub_8249FE60(ctx, base);
	// 824B3FE0: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B3FE4: 4BFDEFB5  bl 0x82492f98
	ctx.lr = 0x824B3FE8;
	sub_82492F98(ctx, base);
	// 824B3FE8: 48032579  bl 0x824e6560
	ctx.lr = 0x824B3FEC;
	sub_824E6560(ctx, base);
	// 824B3FEC: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 824B3FF0: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B3FF4: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824B3FF8: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 824B3FFC: 394A0190  addi r10, r10, 0x190
	ctx.r[10].s64 = ctx.r[10].s64 + 400;
	// 824B4000: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 824B4004: E8CB0000  ld r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 824B4008: F8CA0000  std r6, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 824B400C: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 824B4010: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 824B4014: C1A10068  lfs f13, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824B4018: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B401C: 396B01A0  addi r11, r11, 0x1a0
	ctx.r[11].s64 = ctx.r[11].s64 + 416;
	// 824B4020: 394B010C  addi r10, r11, 0x10c
	ctx.r[10].s64 = ctx.r[11].s64 + 268;
	// 824B4024: 80CB0114  lwz r6, 0x114(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(276 as u32) ) } as u64;
	// 824B4028: C00B0120  lfs f0, 0x120(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(288 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B402C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 824B4030: D00B010C  stfs f0, 0x10c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 824B4034: 7CC607B4  extsw r6, r6
	ctx.r[6].s64 = ctx.r[6].s32 as i64;
	// 824B4038: C1A1006C  lfs f13, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824B403C: F8C10050  std r6, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u64 ) };
	// 824B4040: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 824B4044: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 824B4048: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 824B404C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 824B4050: D00B0110  stfs f0, 0x110(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 824B4054: 80DF000C  lwz r6, 0xc(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B41B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824B41B8 size=1532
    let mut pc: u32 = 0x824B41B8;
    'dispatch: loop {
        match pc {
            0x824B41B8 => {
    //   block [0x824B41B8..0x824B4214)
	// 824B41B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B41BC: 48080ED9  bl 0x82535094
	ctx.lr = 0x824B41C0;
	sub_82535080(ctx, base);
	// 824B41C0: DBC1FF80  stfd f30, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[30].u64 ) };
	// 824B41C4: DBE1FF88  stfd f31, -0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 824B41C8: E981F000  ld r12, -0x1000(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-4096 as u32) ) };
	// 824B41CC: E981E000  ld r12, -0x2000(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8192 as u32) ) };
	// 824B41D0: E981D000  ld r12, -0x3000(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-12288 as u32) ) };
	// 824B41D4: 9421CE90  stwu r1, -0x3170(r1)
	ea = ctx.r[1].u32.wrapping_add(-12656 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B41D8: 826D0000  lwz r19, 0(r13)
	ctx.r[19].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B41DC: 3A800014  li r20, 0x14
	ctx.r[20].s64 = 20;
	// 824B41E0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 824B41E4: 7D54982E  lwzx r10, r20, r19
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[20].u32.wrapping_add(ctx.r[19].u32)) } as u64;
	// 824B41E8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B41EC: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B41F0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824B41F4: 40980020  bge cr6, 0x824b4214
	if !ctx.cr[6].lt {
	pc = 0x824B4214; continue 'dispatch;
	}
	// 824B41F8: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824B41FC: 39290728  addi r9, r9, 0x728
	ctx.r[9].s64 = ctx.r[9].s64 + 1832;
	// 824B4200: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824B4204: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824B4208: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824B420C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824B4210: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824B4214; continue 'dispatch;
            }
            0x824B4214 => {
    //   block [0x824B4214..0x824B424C)
	// 824B4214: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B4218: 815D0104  lwz r10, 0x104(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(260 as u32) ) } as u64;
	// 824B421C: 812B002C  lwz r9, 0x2c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 824B4220: 7D2A4850  subf r9, r10, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 824B4224: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 824B4228: 40990024  ble cr6, 0x824b424c
	if !ctx.cr[6].gt {
	pc = 0x824B424C; continue 'dispatch;
	}
	// 824B422C: 810B0028  lwz r8, 0x28(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 824B4230: 3CE0824B  lis r7, -0x7db5
	ctx.r[7].s64 = -2109014016;
	// 824B4234: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824B4238: 38C735F8  addi r6, r7, 0x35f8
	ctx.r[6].s64 = ctx.r[7].s64 + 13816;
	// 824B423C: 38A9FFFF  addi r5, r9, -1
	ctx.r[5].s64 = ctx.r[9].s64 + -1;
	// 824B4240: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 824B4244: 7C6B4214  add r3, r11, r8
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 824B4248: 4BFB8E01  bl 0x8246d048
	ctx.lr = 0x824B424C;
	sub_8246D048(ctx, base);
	pc = 0x824B424C; continue 'dispatch;
            }
            0x824B424C => {
    //   block [0x824B424C..0x824B4264)
	// 824B424C: 815D000C  lwz r10, 0xc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B4250: 817D0104  lwz r11, 0x104(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(260 as u32) ) } as u64;
	// 824B4254: 814A002C  lwz r10, 0x2c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 824B4258: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 824B425C: 40980034  bge cr6, 0x824b4290
	if !ctx.cr[6].lt {
	pc = 0x824B4290; continue 'dispatch;
	}
	// 824B4260: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	pc = 0x824B4264; continue 'dispatch;
            }
            0x824B4264 => {
    //   block [0x824B4264..0x824B4290)
	// 824B4264: 811D000C  lwz r8, 0xc(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B4268: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 824B426C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824B4270: 81080028  lwz r8, 0x28(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(40 as u32) ) } as u64;
	// 824B4274: 7D08502E  lwzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824B4278: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 824B427C: B1280020  sth r9, 0x20(r8)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[8].u32.wrapping_add(32 as u32), ctx.r[9].u16 ) };
	// 824B4280: 813D000C  lwz r9, 0xc(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B4284: 8129002C  lwz r9, 0x2c(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(44 as u32) ) } as u64;
	// 824B4288: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824B428C: 4198FFD8  blt cr6, 0x824b4264
	if ctx.cr[6].lt {
	pc = 0x824B4264; continue 'dispatch;
	}
	pc = 0x824B4290; continue 'dispatch;
            }
            0x824B4290 => {
    //   block [0x824B4290..0x824B42F0)
	// 824B4290: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B4294: 4BFDED05  bl 0x82492f98
	ctx.lr = 0x824B4298;
	sub_82492F98(ctx, base);
	// 824B4298: 817D0070  lwz r11, 0x70(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(112 as u32) ) } as u64;
	// 824B429C: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 824B42A0: 815D00B4  lwz r10, 0xb4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(180 as u32) ) } as u64;
	// 824B42A4: 7D6B5215  add. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B42A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824B42AC: C3CB1FF8  lfs f30, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 824B42B0: 41820360  beq 0x824b4610
	if ctx.cr[0].eq {
	pc = 0x824B4610; continue 'dispatch;
	}
	// 824B42B4: 7D54982E  lwzx r10, r20, r19
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[20].u32.wrapping_add(ctx.r[19].u32)) } as u64;
	// 824B42B8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B42BC: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B42C0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824B42C4: 4098002C  bge cr6, 0x824b42f0
	if !ctx.cr[6].lt {
	pc = 0x824B42F0; continue 'dispatch;
	}
	// 824B42C8: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824B42CC: 3D008206  lis r8, -0x7dfa
	ctx.r[8].s64 = -2113536000;
	// 824B42D0: 39290AEC  addi r9, r9, 0xaec
	ctx.r[9].s64 = ctx.r[9].s64 + 2796;
	// 824B42D4: 39080ADC  addi r8, r8, 0xadc
	ctx.r[8].s64 = ctx.r[8].s64 + 2780;
	// 824B42D8: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824B42DC: 910B000C  stw r8, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 824B42E0: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824B42E4: 390B0010  addi r8, r11, 0x10
	ctx.r[8].s64 = ctx.r[11].s64 + 16;
	// 824B42E8: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824B42EC: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824B42F0; continue 'dispatch;
            }
            0x824B42F0 => {
    //   block [0x824B42F0..0x824B4334)
	// 824B42F0: 3ADD00B0  addi r22, r29, 0xb0
	ctx.r[22].s64 = ctx.r[29].s64 + 176;
	// 824B42F4: 3B3D006C  addi r25, r29, 0x6c
	ctx.r[25].s64 = ctx.r[29].s64 + 108;
	// 824B42F8: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 824B42FC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 824B4300: 48049F99  bl 0x824fe298
	ctx.lr = 0x824B4304;
	sub_824FE298(ctx, base);
	// 824B4304: 7D54982E  lwzx r10, r20, r19
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[20].u32.wrapping_add(ctx.r[19].u32)) } as u64;
	// 824B4308: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B430C: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B4310: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824B4314: 40980020  bge cr6, 0x824b4334
	if !ctx.cr[6].lt {
	pc = 0x824B4334; continue 'dispatch;
	}
	// 824B4318: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824B431C: 39290AD0  addi r9, r9, 0xad0
	ctx.r[9].s64 = ctx.r[9].s64 + 2768;
	// 824B4320: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824B4324: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824B4328: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824B432C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824B4330: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824B4334; continue 'dispatch;
            }
            0x824B4334 => {
    //   block [0x824B4334..0x824B4374)
	// 824B4334: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 824B4338: 4BFFFAD9  bl 0x824b3e10
	ctx.lr = 0x824B433C;
	sub_824B3E10(ctx, base);
	// 824B433C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 824B4340: 4BFFFAD1  bl 0x824b3e10
	ctx.lr = 0x824B4344;
	sub_824B3E10(ctx, base);
	// 824B4344: 7D54982E  lwzx r10, r20, r19
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[20].u32.wrapping_add(ctx.r[19].u32)) } as u64;
	// 824B4348: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B434C: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B4350: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824B4354: 40980020  bge cr6, 0x824b4374
	if !ctx.cr[6].lt {
	pc = 0x824B4374; continue 'dispatch;
	}
	// 824B4358: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824B435C: 39290AC4  addi r9, r9, 0xac4
	ctx.r[9].s64 = ctx.r[9].s64 + 2756;
	// 824B4360: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824B4364: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824B4368: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824B436C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824B4370: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824B4374; continue 'dispatch;
            }
            0x824B4374 => {
    //   block [0x824B4374..0x824B43A4)
	// 824B4374: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824B4378: 815D0070  lwz r10, 0x70(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(112 as u32) ) } as u64;
	// 824B437C: D3C130B0  stfs f30, 0x30b0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(12464 as u32), tmp.u32 ) };
	// 824B4380: 92A10064  stw r21, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[21].u32 ) };
	// 824B4384: D3C130B4  stfs f30, 0x30b4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(12468 as u32), tmp.u32 ) };
	// 824B4388: 7EB8AB78  mr r24, r21
	ctx.r[24].u64 = ctx.r[21].u64;
	// 824B438C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824B4390: C3EB8CB4  lfs f31, -0x734c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 824B4394: D3E13090  stfs f31, 0x3090(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(12432 as u32), tmp.u32 ) };
	// 824B4398: 409901B0  ble cr6, 0x824b4548
	if !ctx.cr[6].gt {
	pc = 0x824B4548; continue 'dispatch;
	}
	// 824B439C: 7EBAAB78  mr r26, r21
	ctx.r[26].u64 = ctx.r[21].u64;
	// 824B43A0: 3AE0FFFF  li r23, -1
	ctx.r[23].s64 = -1;
	pc = 0x824B43A4; continue 'dispatch;
            }
            0x824B43A4 => {
    //   block [0x824B43A4..0x824B4400)
	// 824B43A4: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B43A8: 7D6BD214  add r11, r11, r26
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 824B43AC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B43B0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B43B4: 892A0005  lbz r9, 5(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B43B8: 88EB0005  lbz r7, 5(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B43BC: 7D280774  extsb r8, r9
	ctx.r[8].s64 = ctx.r[9].s8 as i64;
	// 824B43C0: 7CE90774  extsb r9, r7
	ctx.r[9].s64 = ctx.r[7].s8 as i64;
	// 824B43C4: 7FE85214  add r31, r8, r10
	ctx.r[31].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 824B43C8: 7FC95A14  add r30, r9, r11
	ctx.r[30].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 824B43CC: 897F0010  lbz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B43D0: 893E0010  lbz r9, 0x10(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B43D4: 7D6A0774  extsb r10, r11
	ctx.r[10].s64 = ctx.r[11].s8 as i64;
	// 824B43D8: 7D2B0774  extsb r11, r9
	ctx.r[11].s64 = ctx.r[9].s8 as i64;
	// 824B43DC: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 824B43E0: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 824B43E4: 808A00B8  lwz r4, 0xb8(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(184 as u32) ) } as u64;
	// 824B43E8: 80AB00B8  lwz r5, 0xb8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) } as u64;
	// 824B43EC: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 824B43F0: 419A0010  beq cr6, 0x824b4400
	if ctx.cr[6].eq {
	pc = 0x824B4400; continue 'dispatch;
	}
	// 824B43F4: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B43F8: 4BFEB549  bl 0x8249f940
	ctx.lr = 0x824B43FC;
	sub_8249F940(ctx, base);
	// 824B43FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	pc = 0x824B4400; continue 'dispatch;
            }
            0x824B4400 => {
    //   block [0x824B4400..0x824B44EC)
	// 824B4400: 815D000C  lwz r10, 0xc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B4404: 90810064  stw r4, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[4].u32 ) };
	// 824B4408: A17F001A  lhz r11, 0x1a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(26 as u32) ) } as u64;
	// 824B440C: A13E001A  lhz r9, 0x1a(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(26 as u32) ) } as u64;
	// 824B4410: 80AA006C  lwz r5, 0x6c(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(108 as u32) ) } as u64;
	// 824B4414: 556A103E  rotlwi r10, r11, 2
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 824B4418: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824B441C: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824B4420: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B4424: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 824B4428: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 824B442C: 894A1BB0  lbz r10, 0x1bb0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(7088 as u32) ) } as u64;
	// 824B4430: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 824B4434: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824B4438: 419A00FC  beq cr6, 0x824b4534
	if ctx.cr[6].eq {
	pc = 0x824B4534; continue 'dispatch;
	}
	// 824B443C: 554A3032  slwi r10, r10, 6
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824B4440: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 824B4444: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 824B4448: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B444C: 816B1C30  lwz r11, 0x1c30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7216 as u32) ) } as u64;
	// 824B4450: 91650010  stw r11, 0x10(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 824B4454: 48003B35  bl 0x824b7f88
	ctx.lr = 0x824B4458;
	sub_824B7F88(ctx, base);
	// 824B4458: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824B445C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 824B4460: 419A00D4  beq cr6, 0x824b4534
	if ctx.cr[6].eq {
	pc = 0x824B4534; continue 'dispatch;
	}
	// 824B4464: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B4468: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 824B446C: 895F000C  lbz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B4470: 839F0010  lwz r28, 0x10(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B4474: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 824B4478: 837F0014  lwz r27, 0x14(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 824B447C: 83CB006C  lwz r30, 0x6c(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 824B4480: 554B3032  slwi r11, r10, 6
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824B4484: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 824B4488: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B448C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824B4490: 396B1C20  addi r11, r11, 0x1c20
	ctx.r[11].s64 = ctx.r[11].s64 + 7200;
	// 824B4494: 917E0060  stw r11, 0x60(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 824B4498: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B449C: 917E0010  stw r11, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 824B44A0: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 824B44A4: D3E13090  stfs f31, 0x3090(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(12432 as u32), tmp.u32 ) };
	// 824B44A8: 92A130E0  stw r21, 0x30e0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(12512 as u32), ctx.r[21].u32 ) };
	// 824B44AC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 824B44B0: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B44B4: 48021445  bl 0x824d58f8
	ctx.lr = 0x824B44B8;
	sub_824D58F8(ctx, base);
	// 824B44B8: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 824B44BC: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 824B44C0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824B44C4: 419A0028  beq cr6, 0x824b44ec
	if ctx.cr[6].eq {
	pc = 0x824B44EC; continue 'dispatch;
	}
	// 824B44C8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B44CC: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 824B44D0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 824B44D4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 824B44D8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 824B44DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B44E0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824B44E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B44E8: 4E800421  bctrl
	ctx.lr = 0x824B44EC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824B44EC => {
    //   block [0x824B44EC..0x824B4500)
	// 824B44EC: C0013090  lfs f0, 0x3090(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(12432 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B44F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824B44F4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 824B44F8: 409A0008  bne cr6, 0x824b4500
	if !ctx.cr[6].eq {
	pc = 0x824B4500; continue 'dispatch;
	}
	// 824B44FC: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	pc = 0x824B4500; continue 'dispatch;
            }
            0x824B4500 => {
    //   block [0x824B4500..0x824B4534)
	// 824B4500: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824B4504: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B4508: 419A002C  beq cr6, 0x824b4534
	if ctx.cr[6].eq {
	pc = 0x824B4534; continue 'dispatch;
	}
	// 824B450C: 3BDD0340  addi r30, r29, 0x340
	ctx.r[30].s64 = ctx.r[29].s64 + 832;
	// 824B4510: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824B4514: 4BFB1C65  bl 0x82466178
	ctx.lr = 0x824B4518;
	sub_82466178(ctx, base);
	// 824B4518: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 824B451C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 824B4520: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 824B4524: 48013BF5  bl 0x824c8118
	ctx.lr = 0x824B4528;
	sub_824C8118(ctx, base);
	// 824B4528: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824B452C: FAFE0020  std r23, 0x20(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[23].u64 ) };
	// 824B4530: 48258D3D  bl 0x8270d26c
	ctx.lr = 0x824B4534;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x824B4534; continue 'dispatch;
            }
            0x824B4534 => {
    //   block [0x824B4534..0x824B4548)
	// 824B4534: 817D0070  lwz r11, 0x70(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(112 as u32) ) } as u64;
	// 824B4538: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 824B453C: 3B5A0008  addi r26, r26, 8
	ctx.r[26].s64 = ctx.r[26].s64 + 8;
	// 824B4540: 7F185800  cmpw cr6, r24, r11
	ctx.cr[6].compare_i32(ctx.r[24].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824B4544: 4198FE60  blt cr6, 0x824b43a4
	if ctx.cr[6].lt {
	pc = 0x824B43A4; continue 'dispatch;
	}
	pc = 0x824B4548; continue 'dispatch;
            }
            0x824B4548 => {
    //   block [0x824B4548..0x824B457C)
	// 824B4548: 92BD0070  stw r21, 0x70(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(112 as u32), ctx.r[21].u32 ) };
	// 824B454C: 7D54982E  lwzx r10, r20, r19
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[20].u32.wrapping_add(ctx.r[19].u32)) } as u64;
	// 824B4550: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B4554: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B4558: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824B455C: 40980020  bge cr6, 0x824b457c
	if !ctx.cr[6].lt {
	pc = 0x824B457C; continue 'dispatch;
	}
	// 824B4560: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824B4564: 39290AB8  addi r9, r9, 0xab8
	ctx.r[9].s64 = ctx.r[9].s64 + 2744;
	// 824B4568: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824B456C: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824B4570: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824B4574: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824B4578: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824B457C; continue 'dispatch;
            }
            0x824B457C => {
    //   block [0x824B457C..0x824B4590)
	// 824B457C: 817D00B4  lwz r11, 0xb4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(180 as u32) ) } as u64;
	// 824B4580: 7EBEAB78  mr r30, r21
	ctx.r[30].u64 = ctx.r[21].u64;
	// 824B4584: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B4588: 40990054  ble cr6, 0x824b45dc
	if !ctx.cr[6].gt {
	pc = 0x824B45DC; continue 'dispatch;
	}
	// 824B458C: 7EBFAB78  mr r31, r21
	ctx.r[31].u64 = ctx.r[21].u64;
	pc = 0x824B4590; continue 'dispatch;
            }
            0x824B4590 => {
    //   block [0x824B4590..0x824B45C8)
	// 824B4590: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B4594: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 824B4598: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B459C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B45A0: 892A0005  lbz r9, 5(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B45A4: 88EB0005  lbz r7, 5(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 824B45A8: 7D280774  extsb r8, r9
	ctx.r[8].s64 = ctx.r[9].s8 as i64;
	// 824B45AC: 7CE90774  extsb r9, r7
	ctx.r[9].s64 = ctx.r[7].s8 as i64;
	// 824B45B0: 7C685214  add r3, r8, r10
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 824B45B4: 7C895A14  add r4, r9, r11
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 824B45B8: 48020289  bl 0x824d4840
	ctx.lr = 0x824B45BC;
	sub_824D4840(ctx, base);
	// 824B45BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 824B45C0: 419A0008  beq cr6, 0x824b45c8
	if ctx.cr[6].eq {
	pc = 0x824B45C8; continue 'dispatch;
	}
	// 824B45C4: 48003BE5  bl 0x824b81a8
	ctx.lr = 0x824B45C8;
	sub_824B81A8(ctx, base);
	pc = 0x824B45C8; continue 'dispatch;
            }
            0x824B45C8 => {
    //   block [0x824B45C8..0x824B45DC)
	// 824B45C8: 817D00B4  lwz r11, 0xb4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(180 as u32) ) } as u64;
	// 824B45CC: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 824B45D0: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 824B45D4: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824B45D8: 4198FFB8  blt cr6, 0x824b4590
	if ctx.cr[6].lt {
	pc = 0x824B4590; continue 'dispatch;
	}
	pc = 0x824B45DC; continue 'dispatch;
            }
            0x824B45DC => {
    //   block [0x824B45DC..0x824B4610)
	// 824B45DC: 92BD00B4  stw r21, 0xb4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(180 as u32), ctx.r[21].u32 ) };
	// 824B45E0: 7D54982E  lwzx r10, r20, r19
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[20].u32.wrapping_add(ctx.r[19].u32)) } as u64;
	// 824B45E4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B45E8: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B45EC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824B45F0: 40980020  bge cr6, 0x824b4610
	if !ctx.cr[6].lt {
	pc = 0x824B4610; continue 'dispatch;
	}
	// 824B45F4: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824B45F8: 3929FE14  addi r9, r9, -0x1ec
	ctx.r[9].s64 = ctx.r[9].s64 + -492;
	// 824B45FC: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824B4600: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824B4604: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824B4608: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824B460C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824B4610; continue 'dispatch;
            }
            0x824B4610 => {
    //   block [0x824B4610..0x824B4650)
	// 824B4610: 9ABD0068  stb r21, 0x68(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(104 as u32), ctx.r[21].u8 ) };
	// 824B4614: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B4618: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 824B461C: 9AAB001C  stb r21, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[21].u8 ) };
	// 824B4620: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B4624: 81630084  lwz r11, 0x84(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(132 as u32) ) } as u64;
	// 824B4628: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B462C: 91630084  stw r11, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 824B4630: 40820020  bne 0x824b4650
	if !ctx.cr[0].eq {
	pc = 0x824B4650; continue 'dispatch;
	}
	// 824B4634: 8963008C  lbz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 824B4638: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B463C: 409A0014  bne cr6, 0x824b4650
	if !ctx.cr[6].eq {
	pc = 0x824B4650; continue 'dispatch;
	}
	// 824B4640: 81630080  lwz r11, 0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 824B4644: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B4648: 419A0008  beq cr6, 0x824b4650
	if ctx.cr[6].eq {
	pc = 0x824B4650; continue 'dispatch;
	}
	// 824B464C: 4BFDEB75  bl 0x824931c0
	ctx.lr = 0x824B4650;
	sub_824931C0(ctx, base);
	pc = 0x824B4650; continue 'dispatch;
            }
            0x824B4650 => {
    //   block [0x824B4650..0x824B46A8)
	// 824B4650: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B4654: C01D0018  lfs f0, 0x18(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B4658: C1BD001C  lfs f13, 0x1c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824B465C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 824B4660: D01D0018  stfs f0, 0x18(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 824B4664: 816B0154  lwz r11, 0x154(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(340 as u32) ) } as u64;
	// 824B4668: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B466C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824B4670: 3BEB74DC  addi r31, r11, 0x74dc
	ctx.r[31].s64 = ctx.r[11].s64 + 29916;
	// 824B4674: 419A009C  beq cr6, 0x824b4710
	if ctx.cr[6].eq {
	pc = 0x824B4710; continue 'dispatch;
	}
	// 824B4678: 7D54982E  lwzx r10, r20, r19
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[20].u32.wrapping_add(ctx.r[19].u32)) } as u64;
	// 824B467C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B4680: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B4684: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824B4688: 40980020  bge cr6, 0x824b46a8
	if !ctx.cr[6].lt {
	pc = 0x824B46A8; continue 'dispatch;
	}
	// 824B468C: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824B4690: 392906F0  addi r9, r9, 0x6f0
	ctx.r[9].s64 = ctx.r[9].s64 + 1776;
	// 824B4694: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824B4698: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824B469C: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824B46A0: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824B46A4: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824B46A8; continue 'dispatch;
            }
            0x824B46A8 => {
    //   block [0x824B46A8..0x824B46D8)
	// 824B46A8: C01D0018  lfs f0, 0x18(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B46AC: C1BD001C  lfs f13, 0x1c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824B46B0: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 824B46B4: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 824B46B8: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 824B46BC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 824B46C0: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 824B46C4: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 824B46C8: 419A0010  beq cr6, 0x824b46d8
	if ctx.cr[6].eq {
	pc = 0x824B46D8; continue 'dispatch;
	}
	// 824B46CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824B46D0: C1AB1850  lfs f13, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824B46D4: EFCD0024  fdivs f30, f13, f0
	ctx.f[30].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	pc = 0x824B46D8; continue 'dispatch;
            }
            0x824B46D8 => {
    //   block [0x824B46D8..0x824B4710)
	// 824B46D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B46DC: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B46E0: D3C1005C  stfs f30, 0x5c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 824B46E4: 4BFF0C65  bl 0x824a5348
	ctx.lr = 0x824B46E8;
	sub_824A5348(ctx, base);
	// 824B46E8: 7D54982E  lwzx r10, r20, r19
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[20].u32.wrapping_add(ctx.r[19].u32)) } as u64;
	// 824B46EC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B46F0: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B46F4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824B46F8: 40980018  bge cr6, 0x824b4710
	if !ctx.cr[6].lt {
	pc = 0x824B4710; continue 'dispatch;
	}
	// 824B46FC: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 824B4700: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824B4704: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824B4708: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824B470C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824B4710; continue 'dispatch;
            }
            0x824B4710 => {
    //   block [0x824B4710..0x824B4740)
	// 824B4710: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B4714: 4BFDE885  bl 0x82492f98
	ctx.lr = 0x824B4718;
	sub_82492F98(ctx, base);
	// 824B4718: 7D54982E  lwzx r10, r20, r19
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[20].u32.wrapping_add(ctx.r[19].u32)) } as u64;
	// 824B471C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B4720: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B4724: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824B4728: 40980018  bge cr6, 0x824b4740
	if !ctx.cr[6].lt {
	pc = 0x824B4740; continue 'dispatch;
	}
	// 824B472C: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 824B4730: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824B4734: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 824B4738: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824B473C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824B4740; continue 'dispatch;
            }
            0x824B4740 => {
    //   block [0x824B4740..0x824B47A4)
	// 824B4740: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B4744: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 824B4748: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824B474C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B4750: 4E800421  bctrl
	ctx.lr = 0x824B4754;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824B4754: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B4758: 896B00D0  lbz r11, 0xd0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 824B475C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B4760: 419A0044  beq cr6, 0x824b47a4
	if ctx.cr[6].eq {
	pc = 0x824B47A4; continue 'dispatch;
	}
	// 824B4764: 817D01B8  lwz r11, 0x1b8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(440 as u32) ) } as u64;
	// 824B4768: 896B0010  lbz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B476C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B4770: 419A0034  beq cr6, 0x824b47a4
	if ctx.cr[6].eq {
	pc = 0x824B47A4; continue 'dispatch;
	}
	// 824B4774: 3BFD0180  addi r31, r29, 0x180
	ctx.r[31].s64 = ctx.r[29].s64 + 384;
	// 824B4778: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 824B477C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B4780: 480F79A9  bl 0x825ac128
	ctx.lr = 0x824B4784;
	sub_825AC128(ctx, base);
	// 824B4784: 817D01B8  lwz r11, 0x1b8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(440 as u32) ) } as u64;
	// 824B4788: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B478C: 9AAB0010  stb r21, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[21].u8 ) };
	// 824B4790: 809D01B8  lwz r4, 0x1b8(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(440 as u32) ) } as u64;
	// 824B4794: 480F78E5  bl 0x825ac078
	ctx.lr = 0x824B4798;
	sub_825AC078(ctx, base);
	// 824B4798: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 824B479C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B47A0: 480F78C9  bl 0x825ac068
	ctx.lr = 0x824B47A4;
	sub_825AC068(ctx, base);
            }
            0x824B47A4 => {
    //   block [0x824B47A4..0x824B47B4)
	// 824B47A4: 38213170  addi r1, r1, 0x3170
	ctx.r[1].s64 = ctx.r[1].s64 + 12656;
	// 824B47A8: CBC1FF80  lfd f30, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 824B47AC: CBE1FF88  lfd f31, -0x78(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 824B47B0: 48080934  b 0x825350e4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B47B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B47B8 size=152
    let mut pc: u32 = 0x824B47B8;
    'dispatch: loop {
        match pc {
            0x824B47B8 => {
    //   block [0x824B47B8..0x824B481C)
	// 824B47B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B47BC: 48080901  bl 0x825350bc
	ctx.lr = 0x824B47C0;
	sub_82535080(ctx, base);
	// 824B47C0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 824B47C4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B47C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824B47CC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 824B47D0: 3BBF0140  addi r29, r31, 0x140
	ctx.r[29].s64 = ctx.r[31].s64 + 320;
	// 824B47D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 824B47D8: 4BFB19A1  bl 0x82466178
	ctx.lr = 0x824B47DC;
	sub_82466178(ctx, base);
	// 824B47DC: 83DF00FC  lwz r30, 0xfc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 824B47E0: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 824B47E4: 395E0001  addi r10, r30, 1
	ctx.r[10].s64 = ctx.r[30].s64 + 1;
	// 824B47E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 824B47EC: 915F00FC  stw r10, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[10].u32 ) };
	// 824B47F0: F97D0020  std r11, 0x20(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), ctx.r[11].u64 ) };
	// 824B47F4: 48258A79  bl 0x8270d26c
	ctx.lr = 0x824B47F8;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 824B47F8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 824B47FC: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 824B4800: 409A001C  bne cr6, 0x824b481c
	if !ctx.cr[6].eq {
	pc = 0x824B481C; continue 'dispatch;
	}
	// 824B4804: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B4808: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 824B480C: 4BFFF6CD  bl 0x824b3ed8
	ctx.lr = 0x824B4810;
	sub_824B3ED8(ctx, base);
	// 824B4810: 387F0100  addi r3, r31, 0x100
	ctx.r[3].s64 = ctx.r[31].s64 + 256;
	// 824B4814: 809F00FC  lwz r4, 0xfc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 824B4818: 480F88A9  bl 0x825ad0c0
	ctx.lr = 0x824B481C;
	sub_825AD0C0(ctx, base);
	pc = 0x824B481C; continue 'dispatch;
            }
            0x824B481C => {
    //   block [0x824B481C..0x824B4840)
	// 824B481C: 387F0100  addi r3, r31, 0x100
	ctx.r[3].s64 = ctx.r[31].s64 + 256;
	// 824B4820: 480F8891  bl 0x825ad0b0
	ctx.lr = 0x824B4824;
	sub_825AD0B0(ctx, base);
	// 824B4824: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B4828: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B482C: 4BFFED0D  bl 0x824b3538
	ctx.lr = 0x824B4830;
	sub_824B3538(ctx, base);
	// 824B4830: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 824B4834: 409A000C  bne cr6, 0x824b4840
	if !ctx.cr[6].eq {
	pc = 0x824B4840; continue 'dispatch;
	}
	// 824B4838: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B483C: 4BFFF97D  bl 0x824b41b8
	ctx.lr = 0x824B4840;
	sub_824B41B8(ctx, base);
	pc = 0x824B4840; continue 'dispatch;
            }
            0x824B4840 => {
    //   block [0x824B4840..0x824B4850)
	// 824B4840: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824B4844: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 824B4848: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 824B484C: 480808C0  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B4850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B4850 size=712
    let mut pc: u32 = 0x824B4850;
    'dispatch: loop {
        match pc {
            0x824B4850 => {
    //   block [0x824B4850..0x824B48CC)
	// 824B4850: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B4854: 48080839  bl 0x8253508c
	ctx.lr = 0x824B4858;
	sub_82535080(ctx, base);
	// 824B4858: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B485C: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 824B4860: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 824B4864: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 824B4868: 7CD13378  mr r17, r6
	ctx.r[17].u64 = ctx.r[6].u64;
	// 824B486C: 8173000C  lwz r11, 0xc(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B4870: 896B00D0  lbz r11, 0xd0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 824B4874: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B4878: 419A0284  beq cr6, 0x824b4afc
	if ctx.cr[6].eq {
	pc = 0x824B4AFC; continue 'dispatch;
	}
	// 824B487C: 817301B8  lwz r11, 0x1b8(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(440 as u32) ) } as u64;
	// 824B4880: 896B0010  lbz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B4884: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B4888: 419A0274  beq cr6, 0x824b4afc
	if ctx.cr[6].eq {
	pc = 0x824B4AFC; continue 'dispatch;
	}
	// 824B488C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B4890: 3AA00010  li r21, 0x10
	ctx.r[21].s64 = 16;
	// 824B4894: 828D0000  lwz r20, 0(r13)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B4898: 836B00B8  lwz r27, 0xb8(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) } as u64;
	// 824B489C: 7C75A02E  lwzx r3, r21, r20
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[21].u32.wrapping_add(ctx.r[20].u32)) } as u64;
	// 824B48A0: 83FB004C  lwz r31, 0x4c(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(76 as u32) ) } as u64;
	// 824B48A4: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 824B48A8: 395F0010  addi r10, r31, 0x10
	ctx.r[10].s64 = ctx.r[31].s64 + 16;
	// 824B48AC: 8123002C  lwz r9, 0x2c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 824B48B0: 55440036  rlwinm r4, r10, 0, 0, 0x1b
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 824B48B4: 7D4B2214  add r10, r11, r4
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 824B48B8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824B48BC: 41990010  bgt cr6, 0x824b48cc
	if ctx.cr[6].gt {
	pc = 0x824B48CC; continue 'dispatch;
	}
	// 824B48C0: 7D795B78  mr r25, r11
	ctx.r[25].u64 = ctx.r[11].u64;
	// 824B48C4: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 824B48C8: 48000018  b 0x824b48e0
	pc = 0x824B48E0; continue 'dispatch;
            }
            0x824B48CC => {
    //   block [0x824B48CC..0x824B48E0)
	// 824B48CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B48D0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 824B48D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B48D8: 4E800421  bctrl
	ctx.lr = 0x824B48DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824B48DC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
            }
            0x824B48E0 => {
    //   block [0x824B48E0..0x824B4928)
	// 824B48E0: 3FC08000  lis r30, -0x8000
	ctx.r[30].s64 = -2147483648;
	// 824B48E4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 824B48E8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 824B48EC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 824B48F0: 7FF2F378  or r18, r31, r30
	ctx.r[18].u64 = ctx.r[31].u64 | ctx.r[30].u64;
	// 824B48F4: 4BFB5A45  bl 0x8246a338
	ctx.lr = 0x824B48F8;
	sub_8246A338(ctx, base);
	// 824B48F8: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 824B48FC: 7D75A02E  lwzx r11, r21, r20
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[21].u32.wrapping_add(ctx.r[20].u32)) } as u64;
	// 824B4900: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 824B4904: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 824B4908: 92E10064  stw r23, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[23].u32 ) };
	// 824B490C: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 824B4910: 810B002C  lwz r8, 0x2c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 824B4914: 392A0FB0  addi r9, r10, 0xfb0
	ctx.r[9].s64 = ctx.r[10].s64 + 4016;
	// 824B4918: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 824B491C: 4199000C  bgt cr6, 0x824b4928
	if ctx.cr[6].gt {
	pc = 0x824B4928; continue 'dispatch;
	}
	// 824B4920: 912B0020  stw r9, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 824B4924: 48000020  b 0x824b4944
	pc = 0x824B4944; continue 'dispatch;
            }
            0x824B4928 => {
    //   block [0x824B4928..0x824B4944)
	// 824B4928: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B492C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 824B4930: 38800FB0  li r4, 0xfb0
	ctx.r[4].s64 = 4016;
	// 824B4934: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 824B4938: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B493C: 4E800421  bctrl
	ctx.lr = 0x824B4940;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824B4940: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
            }
            0x824B4944 => {
    //   block [0x824B4944..0x824B496C)
	// 824B4944: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 824B4948: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 824B494C: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 824B4950: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 824B4954: 616B03E8  ori r11, r11, 0x3e8
	ctx.r[11].u64 = ctx.r[11].u64 | 1000;
	// 824B4958: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 824B495C: 409900CC  ble cr6, 0x824b4a28
	if !ctx.cr[6].gt {
	pc = 0x824B4A28; continue 'dispatch;
	}
	// 824B4960: 7FBAEB78  mr r26, r29
	ctx.r[26].u64 = ctx.r[29].u64;
	// 824B4964: 7F96E378  mr r22, r28
	ctx.r[22].u64 = ctx.r[28].u64;
	// 824B4968: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	pc = 0x824B496C; continue 'dispatch;
            }
            0x824B496C => {
    //   block [0x824B496C..0x824B4990)
	// 824B496C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B4970: 7EFCBB78  mr r28, r23
	ctx.r[28].u64 = ctx.r[23].u64;
	// 824B4974: 3BCB0010  addi r30, r11, 0x10
	ctx.r[30].s64 = ctx.r[11].s64 + 16;
	// 824B4978: A16B0094  lhz r11, 0x94(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(148 as u32) ) } as u64;
	// 824B497C: 7F0BC9AE  stbx r24, r11, r25
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[25].u32), ctx.r[24].u8) };
	// 824B4980: 817E0050  lwz r11, 0x50(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 824B4984: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B4988: 40990090  ble cr6, 0x824b4a18
	if !ctx.cr[6].gt {
	pc = 0x824B4A18; continue 'dispatch;
	}
	// 824B498C: 7EFDBB78  mr r29, r23
	ctx.r[29].u64 = ctx.r[23].u64;
	pc = 0x824B4990; continue 'dispatch;
            }
            0x824B4990 => {
    //   block [0x824B4990..0x824B49C4)
	// 824B4990: 817E004C  lwz r11, 0x4c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 824B4994: 7FFD5A14  add r31, r29, r11
	ctx.r[31].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 824B4998: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B499C: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B49A0: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 824B49A4: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 824B49A8: 814B00B8  lwz r10, 0xb8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) } as u64;
	// 824B49AC: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 824B49B0: 409A0014  bne cr6, 0x824b49c4
	if !ctx.cr[6].eq {
	pc = 0x824B49C4; continue 'dispatch;
	}
	// 824B49B4: A16B0094  lhz r11, 0x94(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(148 as u32) ) } as u64;
	// 824B49B8: 7D6BC8AE  lbzx r11, r11, r25
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 824B49BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B49C0: 409A0044  bne cr6, 0x824b4a04
	if !ctx.cr[6].eq {
	pc = 0x824B4A04; continue 'dispatch;
	}
	pc = 0x824B49C4; continue 'dispatch;
            }
            0x824B49C4 => {
    //   block [0x824B49C4..0x824B49E4)
	// 824B49C4: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 824B49C8: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 824B49CC: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824B49D0: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824B49D4: 409A0010  bne cr6, 0x824b49e4
	if !ctx.cr[6].eq {
	pc = 0x824B49E4; continue 'dispatch;
	}
	// 824B49D8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 824B49DC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 824B49E0: 4BFB9971  bl 0x8246e350
	ctx.lr = 0x824B49E4;
	sub_8246E350(ctx, base);
	pc = 0x824B49E4; continue 'dispatch;
            }
            0x824B49E4 => {
    //   block [0x824B49E4..0x824B4A04)
	// 824B49E4: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 824B49E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B49EC: 81210060  lwz r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 824B49F0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824B49F4: 7D6A492E  stwx r11, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[11].u32) };
	// 824B49F8: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 824B49FC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824B4A00: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	pc = 0x824B4A04; continue 'dispatch;
            }
            0x824B4A04 => {
    //   block [0x824B4A04..0x824B4A18)
	// 824B4A04: 817E0050  lwz r11, 0x50(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 824B4A08: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 824B4A0C: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 824B4A10: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824B4A14: 4198FF7C  blt cr6, 0x824b4990
	if ctx.cr[6].lt {
	pc = 0x824B4990; continue 'dispatch;
	}
	pc = 0x824B4A18; continue 'dispatch;
            }
            0x824B4A18 => {
    //   block [0x824B4A18..0x824B4A28)
	// 824B4A18: 3AD6FFFF  addi r22, r22, -1
	ctx.r[22].s64 = ctx.r[22].s64 + -1;
	// 824B4A1C: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 824B4A20: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 824B4A24: 409AFF48  bne cr6, 0x824b496c
	if !ctx.cr[6].eq {
	pc = 0x824B496C; continue 'dispatch;
	}
	pc = 0x824B4A28; continue 'dispatch;
            }
            0x824B4A28 => {
    //   block [0x824B4A28..0x824B4A60)
	// 824B4A28: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 824B4A2C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B4A30: 419A0030  beq cr6, 0x824b4a60
	if ctx.cr[6].eq {
	pc = 0x824B4A60; continue 'dispatch;
	}
	// 824B4A34: 81530000  lwz r10, 0(r19)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B4A38: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 824B4A3C: 9AE10050  stb r23, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u8 ) };
	// 824B4A40: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 824B4A44: 7E258B78  mr r5, r17
	ctx.r[5].u64 = ctx.r[17].u64;
	// 824B4A48: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 824B4A4C: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 824B4A50: 814A0044  lwz r10, 0x44(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) } as u64;
	// 824B4A54: 88EB0000  lbz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B4A58: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 824B4A5C: 4E800421  bctrl
	ctx.lr = 0x824B4A60;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824B4A60 => {
    //   block [0x824B4A60..0x824B4A88)
	// 824B4A60: 7C75A02E  lwzx r3, r21, r20
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[21].u32.wrapping_add(ctx.r[20].u32)) } as u64;
	// 824B4A64: 8081006C  lwz r4, 0x6c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 824B4A68: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 824B4A6C: 90830020  stw r4, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 824B4A70: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824B4A74: 409A0014  bne cr6, 0x824b4a88
	if !ctx.cr[6].eq {
	pc = 0x824B4A88; continue 'dispatch;
	}
	// 824B4A78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B4A7C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824B4A80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B4A84: 4E800421  bctrl
	ctx.lr = 0x824B4A88;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824B4A88 => {
    //   block [0x824B4A88..0x824B4AAC)
	// 824B4A88: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 824B4A8C: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824B4A90: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824B4A94: 409A0018  bne cr6, 0x824b4aac
	if !ctx.cr[6].eq {
	pc = 0x824B4AAC; continue 'dispatch;
	}
	// 824B4A98: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824B4A9C: 7C75A02E  lwzx r3, r21, r20
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[21].u32.wrapping_add(ctx.r[20].u32)) } as u64;
	// 824B4AA0: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824B4AA4: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 824B4AA8: 4BFAF611  bl 0x824640b8
	ctx.lr = 0x824B4AAC;
	sub_824640B8(ctx, base);
	pc = 0x824B4AAC; continue 'dispatch;
            }
            0x824B4AAC => {
    //   block [0x824B4AAC..0x824B4AD4)
	// 824B4AAC: 7C75A02E  lwzx r3, r21, r20
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[21].u32.wrapping_add(ctx.r[20].u32)) } as u64;
	// 824B4AB0: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 824B4AB4: 93230020  stw r25, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[25].u32 ) };
	// 824B4AB8: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 824B4ABC: 409A0018  bne cr6, 0x824b4ad4
	if !ctx.cr[6].eq {
	pc = 0x824B4AD4; continue 'dispatch;
	}
	// 824B4AC0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B4AC4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 824B4AC8: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824B4ACC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B4AD0: 4E800421  bctrl
	ctx.lr = 0x824B4AD4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824B4AD4 => {
    //   block [0x824B4AD4..0x824B4AFC)
	// 824B4AD4: 564B0000  rlwinm r11, r18, 0, 0, 0
	ctx.r[11].u64 = ctx.r[18].u32 as u64 & 0xFFFFFFFFu64;
	// 824B4AD8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B4ADC: 409A0034  bne cr6, 0x824b4b10
	if !ctx.cr[6].eq {
	pc = 0x824B4B10; continue 'dispatch;
	}
	// 824B4AE0: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824B4AE4: 7C75A02E  lwzx r3, r21, r20
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[21].u32.wrapping_add(ctx.r[20].u32)) } as u64;
	// 824B4AE8: 564500BE  clrlwi r5, r18, 2
	ctx.r[5].u64 = ctx.r[18].u32 as u64 & 0x3FFFFFFFu64;
	// 824B4AEC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 824B4AF0: 4BFAF5C9  bl 0x824640b8
	ctx.lr = 0x824B4AF4;
	sub_824640B8(ctx, base);
	// 824B4AF4: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 824B4AF8: 480805E4  b 0x825350dc
	sub_825350D0(ctx, base);
	return;
            }
            0x824B4AFC => {
    //   block [0x824B4AFC..0x824B4B10)
	// 824B4AFC: 7E268B78  mr r6, r17
	ctx.r[6].u64 = ctx.r[17].u64;
	// 824B4B00: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 824B4B04: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824B4B08: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 824B4B0C: 4801552D  bl 0x824ca038
	ctx.lr = 0x824B4B10;
	sub_824CA038(ctx, base);
	pc = 0x824B4B10; continue 'dispatch;
            }
            0x824B4B10 => {
    //   block [0x824B4B10..0x824B4B18)
	// 824B4B10: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 824B4B14: 480805C8  b 0x825350dc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B4B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B4B18 size=320
    let mut pc: u32 = 0x824B4B18;
    'dispatch: loop {
        match pc {
            0x824B4B18 => {
    //   block [0x824B4B18..0x824B4B34)
	// 824B4B18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B4B1C: 48080591  bl 0x825350ac
	ctx.lr = 0x824B4B20;
	sub_82535080(ctx, base);
	// 824B4B20: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B4B24: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 824B4B28: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 824B4B2C: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 824B4B30: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	pc = 0x824B4B34; continue 'dispatch;
            }
            0x824B4B34 => {
    //   block [0x824B4B34..0x824B4B50)
	// 824B4B34: 7D7ACA14  add r11, r26, r25
	ctx.r[11].u64 = ctx.r[26].u64 + ctx.r[25].u64;
	// 824B4B38: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 824B4B3C: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 824B4B40: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 824B4B44: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824B4B48: 7D6BE02A  ldx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) };
	// 824B4B4C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	pc = 0x824B4B50; continue 'dispatch;
            }
            0x824B4B50 => {
    //   block [0x824B4B50..0x824B4B74)
	// 824B4B50: 57CB1838  slwi r11, r30, 3
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824B4B54: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B4B58: 7FABE214  add r29, r11, r28
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 824B4B5C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 824B4B60: 7F6903A6  mtctr r27
	ctx.ctr.u64 = ctx.r[27].u64;
	// 824B4B64: 4E800421  bctrl
	ctx.lr = 0x824B4B68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824B4B68: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 824B4B6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B4B70: 419A0028  beq cr6, 0x824b4b98
	if ctx.cr[6].eq {
	pc = 0x824B4B98; continue 'dispatch;
	}
            }
            0x824B4B74 => {
    //   block [0x824B4B74..0x824B4B98)
	// 824B4B74: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 824B4B78: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 824B4B7C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B4B80: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 824B4B84: 7F6903A6  mtctr r27
	ctx.ctr.u64 = ctx.r[27].u64;
	// 824B4B88: 4E800421  bctrl
	ctx.lr = 0x824B4B8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824B4B8C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 824B4B90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B4B94: 409AFFE0  bne cr6, 0x824b4b74
	if !ctx.cr[6].eq {
	pc = 0x824B4B74; continue 'dispatch;
	}
            }
            0x824B4B98 => {
    //   block [0x824B4B98..0x824B4BBC)
	// 824B4B98: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824B4B9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 824B4BA0: 7FABE214  add r29, r11, r28
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 824B4BA4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824B4BA8: 7F6903A6  mtctr r27
	ctx.ctr.u64 = ctx.r[27].u64;
	// 824B4BAC: 4E800421  bctrl
	ctx.lr = 0x824B4BB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824B4BB0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 824B4BB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B4BB8: 419A0028  beq cr6, 0x824b4be0
	if ctx.cr[6].eq {
	pc = 0x824B4BE0; continue 'dispatch;
	}
            }
            0x824B4BBC => {
    //   block [0x824B4BBC..0x824B4BE0)
	// 824B4BBC: 3BBDFFF8  addi r29, r29, -8
	ctx.r[29].s64 = ctx.r[29].s64 + -8;
	// 824B4BC0: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 824B4BC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 824B4BC8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824B4BCC: 7F6903A6  mtctr r27
	ctx.ctr.u64 = ctx.r[27].u64;
	// 824B4BD0: 4E800421  bctrl
	ctx.lr = 0x824B4BD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824B4BD4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 824B4BD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B4BDC: 409AFFE0  bne cr6, 0x824b4bbc
	if !ctx.cr[6].eq {
	pc = 0x824B4BBC; continue 'dispatch;
	}
            }
            0x824B4BE0 => {
    //   block [0x824B4BE0..0x824B4C14)
	// 824B4BE0: 7F1FF000  cmpw cr6, r31, r30
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[30].s32, &mut ctx.xer);
	// 824B4BE4: 41980040  blt cr6, 0x824b4c24
	if ctx.cr[6].lt {
	pc = 0x824B4C24; continue 'dispatch;
	}
	// 824B4BE8: 419A002C  beq cr6, 0x824b4c14
	if ctx.cr[6].eq {
	pc = 0x824B4C14; continue 'dispatch;
	}
	// 824B4BEC: 57CB1838  slwi r11, r30, 3
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824B4BF0: 57EA1838  slwi r10, r31, 3
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824B4BF4: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 824B4BF8: 7D4AE214  add r10, r10, r28
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 824B4BFC: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B4C00: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 824B4C04: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 824B4C08: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B4C0C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 824B4C10: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	pc = 0x824B4C14; continue 'dispatch;
            }
            0x824B4C14 => {
    //   block [0x824B4C14..0x824B4C24)
	// 824B4C14: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 824B4C18: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 824B4C1C: 7F1EF800  cmpw cr6, r30, r31
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[31].s32, &mut ctx.xer);
	// 824B4C20: 4099FF30  ble cr6, 0x824b4b50
	if !ctx.cr[6].gt {
	pc = 0x824B4B50; continue 'dispatch;
	}
	pc = 0x824B4C24; continue 'dispatch;
            }
            0x824B4C24 => {
    //   block [0x824B4C24..0x824B4C40)
	// 824B4C24: 7F1AF800  cmpw cr6, r26, r31
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[31].s32, &mut ctx.xer);
	// 824B4C28: 40980018  bge cr6, 0x824b4c40
	if !ctx.cr[6].lt {
	pc = 0x824B4C40; continue 'dispatch;
	}
	// 824B4C2C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 824B4C30: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 824B4C34: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 824B4C38: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824B4C3C: 4BFFFEDD  bl 0x824b4b18
	ctx.lr = 0x824B4C40;
	sub_824B4B18(ctx, base);
	pc = 0x824B4C40; continue 'dispatch;
            }
            0x824B4C40 => {
    //   block [0x824B4C40..0x824B4C50)
	// 824B4C40: 7F1EC800  cmpw cr6, r30, r25
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[25].s32, &mut ctx.xer);
	// 824B4C44: 4098000C  bge cr6, 0x824b4c50
	if !ctx.cr[6].lt {
	pc = 0x824B4C50; continue 'dispatch;
	}
	// 824B4C48: 7FDAF378  mr r26, r30
	ctx.r[26].u64 = ctx.r[30].u64;
	// 824B4C4C: 4BFFFEE8  b 0x824b4b34
	pc = 0x824B4B34; continue 'dispatch;
            }
            0x824B4C50 => {
    //   block [0x824B4C50..0x824B4C58)
	// 824B4C50: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824B4C54: 480804A8  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B4C58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B4C58 size=8
    let mut pc: u32 = 0x824B4C58;
    'dispatch: loop {
        match pc {
            0x824B4C58 => {
    //   block [0x824B4C58..0x824B4C60)
	// 824B4C58: 38630180  addi r3, r3, 0x180
	ctx.r[3].s64 = ctx.r[3].s64 + 384;
	// 824B4C5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B4C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B4C60 size=100
    let mut pc: u32 = 0x824B4C60;
    'dispatch: loop {
        match pc {
            0x824B4C60 => {
    //   block [0x824B4C60..0x824B4CA8)
	// 824B4C60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B4C64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824B4C68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824B4C6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824B4C70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B4C74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824B4C78: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 824B4C7C: 4BFFF09D  bl 0x824b3d18
	ctx.lr = 0x824B4C80;
	sub_824B3D18(ctx, base);
	// 824B4C80: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 824B4C84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B4C88: 419A0020  beq cr6, 0x824b4ca8
	if ctx.cr[6].eq {
	pc = 0x824B4CA8; continue 'dispatch;
	}
	// 824B4C8C: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B4C90: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 824B4C94: 38C00015  li r6, 0x15
	ctx.r[6].s64 = 21;
	// 824B4C98: A0BF0004  lhz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B4C9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824B4CA0: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824B4CA4: 4BFAF415  bl 0x824640b8
	ctx.lr = 0x824B4CA8;
	sub_824640B8(ctx, base);
	pc = 0x824B4CA8; continue 'dispatch;
            }
            0x824B4CA8 => {
    //   block [0x824B4CA8..0x824B4CC4)
	// 824B4CA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B4CAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824B4CB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824B4CB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824B4CB8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824B4CBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824B4CC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B4CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B4CC8 size=16
    let mut pc: u32 = 0x824B4CC8;
    'dispatch: loop {
        match pc {
            0x824B4CC8 => {
    //   block [0x824B4CC8..0x824B4CD8)
	// 824B4CC8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824B4CCC: 396B6DD0  addi r11, r11, 0x6dd0
	ctx.r[11].s64 = ctx.r[11].s64 + 28112;
	// 824B4CD0: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824B4CD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B4CD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B4CD8 size=72
    let mut pc: u32 = 0x824B4CD8;
    'dispatch: loop {
        match pc {
            0x824B4CD8 => {
    //   block [0x824B4CD8..0x824B4D0C)
	// 824B4CD8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824B4CDC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 824B4CE0: 396B0B04  addi r11, r11, 0xb04
	ctx.r[11].s64 = ctx.r[11].s64 + 2820;
	// 824B4CE4: B1430006  sth r10, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 824B4CE8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 824B4CEC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824B4CF0: A1660096  lhz r11, 0x96(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(150 as u32) ) } as u64;
	// 824B4CF4: A1450096  lhz r10, 0x96(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(150 as u32) ) } as u64;
	// 824B4CF8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 824B4CFC: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 824B4D00: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824B4D04: 40980008  bge cr6, 0x824b4d0c
	if !ctx.cr[6].lt {
	pc = 0x824B4D0C; continue 'dispatch;
	}
	// 824B4D08: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x824B4D0C; continue 'dispatch;
            }
            0x824B4D0C => {
    //   block [0x824B4D0C..0x824B4D20)
	// 824B4D0C: B1630018  sth r11, 0x18(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u16 ) };
	// 824B4D10: 9083000C  stw r4, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	// 824B4D14: 90A30010  stw r5, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[5].u32 ) };
	// 824B4D18: 90C30014  stw r6, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[6].u32 ) };
	// 824B4D1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B4D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B4D20 size=376
    let mut pc: u32 = 0x824B4D20;
    'dispatch: loop {
        match pc {
            0x824B4D20 => {
    //   block [0x824B4D20..0x824B4E98)
	// 824B4D20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B4D24: 48080385  bl 0x825350a8
	ctx.lr = 0x824B4D28;
	sub_82535080(ctx, base);
	// 824B4D28: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B4D2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B4E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824B4E98 size=244
    let mut pc: u32 = 0x824B4E98;
    'dispatch: loop {
        match pc {
            0x824B4E98 => {
    //   block [0x824B4E98..0x824B4F30)
	// 824B4E98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B4E9C: 48080215  bl 0x825350b0
	ctx.lr = 0x824B4EA0;
	sub_82535080(ctx, base);
	// 824B4EA0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B4EA4: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 824B4EA8: 83C1011C  lwz r30, 0x11c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(284 as u32) ) } as u64;
	// 824B4EAC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824B4EB0: 83410114  lwz r26, 0x114(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	// 824B4EB4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 824B4EB8: D0210080  stfs f1, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 824B4EBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824B4EC0: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 824B4EC4: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 824B4EC8: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 824B4ECC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B4ED0: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 824B4ED4: 997E000C  stb r11, 0xc(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 824B4ED8: 997E000E  stb r11, 0xe(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(14 as u32), ctx.r[11].u8 ) };
	// 824B4EDC: 997E000D  stb r11, 0xd(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(13 as u32), ctx.r[11].u8 ) };
	// 824B4EE0: 98FE000F  stb r7, 0xf(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(15 as u32), ctx.r[7].u8 ) };
	// 824B4EE4: C01A0000  lfs f0, 0(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B4EE8: 837F0014  lwz r27, 0x14(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 824B4EEC: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 824B4EF0: 83BF0010  lwz r29, 0x10(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B4EF4: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B4EF8: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 824B4EFC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 824B4F00: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 824B4F04: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 824B4F08: 90C10078  stw r6, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[6].u32 ) };
	// 824B4F0C: 9381007C  stw r28, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[28].u32 ) };
	// 824B4F10: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 824B4F14: 4BFEF9A5  bl 0x824a48b8
	ctx.lr = 0x824B4F18;
	sub_824A48B8(ctx, base);
	// 824B4F18: A17D01F4  lhz r11, 0x1f4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(500 as u32) ) } as u64;
	// 824B4F1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B4F20: 419A0010  beq cr6, 0x824b4f30
	if ctx.cr[6].eq {
	pc = 0x824B4F30; continue 'dispatch;
	}
	// 824B4F24: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B4F28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 824B4F2C: 4BFED6DD  bl 0x824a2608
	ctx.lr = 0x824B4F30;
	sub_824A2608(ctx, base);
	pc = 0x824B4F30; continue 'dispatch;
            }
            0x824B4F30 => {
    //   block [0x824B4F30..0x824B4F48)
	// 824B4F30: A17B01F4  lhz r11, 0x1f4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[27].u32.wrapping_add(500 as u32) ) } as u64;
	// 824B4F34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B4F38: 419A0010  beq cr6, 0x824b4f48
	if ctx.cr[6].eq {
	pc = 0x824B4F48; continue 'dispatch;
	}
	// 824B4F3C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B4F40: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 824B4F44: 4BFED6C5  bl 0x824a2608
	ctx.lr = 0x824B4F48;
	sub_824A2608(ctx, base);
	pc = 0x824B4F48; continue 'dispatch;
            }
            0x824B4F48 => {
    //   block [0x824B4F48..0x824B4F7C)
	// 824B4F48: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 824B4F4C: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 824B4F50: 409A002C  bne cr6, 0x824b4f7c
	if !ctx.cr[6].eq {
	pc = 0x824B4F7C; continue 'dispatch;
	}
	// 824B4F54: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B4F58: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 824B4F5C: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B4F60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B4F64: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 824B4F68: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B4F6C: 4E800421  bctrl
	ctx.lr = 0x824B4F70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824B4F70: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 824B4F74: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 824B4F78: 48080188  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x824B4F7C => {
    //   block [0x824B4F7C..0x824B4F8C)
	// 824B4F7C: C001006C  lfs f0, 0x6c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B4F80: D01A0000  stfs f0, 0(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 824B4F84: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 824B4F88: 48080178  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B4F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B4F90 size=148
    let mut pc: u32 = 0x824B4F90;
    'dispatch: loop {
        match pc {
            0x824B4F90 => {
    //   block [0x824B4F90..0x824B4FF4)
	// 824B4F90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B4F94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824B4F98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824B4F9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824B4FA0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B4FA4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 824B4FA8: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 824B4FAC: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 824B4FB0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B4FB4: 83EB0010  lwz r31, 0x10(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B4FB8: 83CB0014  lwz r30, 0x14(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 824B4FBC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B4FC0: B1210050  sth r9, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u16 ) };
	// 824B4FC4: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 824B4FC8: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 824B4FCC: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 824B4FD0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 824B4FD4: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 824B4FD8: 4BFEFAB1  bl 0x824a4a88
	ctx.lr = 0x824B4FDC;
	sub_824A4A88(ctx, base);
	// 824B4FDC: A17F01F4  lhz r11, 0x1f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(500 as u32) ) } as u64;
	// 824B4FE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B4FE4: 419A0010  beq cr6, 0x824b4ff4
	if ctx.cr[6].eq {
	pc = 0x824B4FF4; continue 'dispatch;
	}
	// 824B4FE8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B4FEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B4FF0: 4BFED7D9  bl 0x824a27c8
	ctx.lr = 0x824B4FF4;
	sub_824A27C8(ctx, base);
	pc = 0x824B4FF4; continue 'dispatch;
            }
            0x824B4FF4 => {
    //   block [0x824B4FF4..0x824B500C)
	// 824B4FF4: A17E01F4  lhz r11, 0x1f4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(500 as u32) ) } as u64;
	// 824B4FF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B4FFC: 419A0010  beq cr6, 0x824b500c
	if ctx.cr[6].eq {
	pc = 0x824B500C; continue 'dispatch;
	}
	// 824B5000: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B5004: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824B5008: 4BFED7C1  bl 0x824a27c8
	ctx.lr = 0x824B500C;
	sub_824A27C8(ctx, base);
	pc = 0x824B500C; continue 'dispatch;
            }
            0x824B500C => {
    //   block [0x824B500C..0x824B5024)
	// 824B500C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 824B5010: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824B5014: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824B5018: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824B501C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824B5020: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B5028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B5028 size=148
    let mut pc: u32 = 0x824B5028;
    'dispatch: loop {
        match pc {
            0x824B5028 => {
    //   block [0x824B5028..0x824B508C)
	// 824B5028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B502C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824B5030: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824B5034: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824B5038: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B503C: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 824B5040: 90A10068  stw r5, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[5].u32 ) };
	// 824B5044: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 824B5048: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B504C: B1410050  sth r10, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u16 ) };
	// 824B5050: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 824B5054: 83EB0010  lwz r31, 0x10(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B5058: 83CB0014  lwz r30, 0x14(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 824B505C: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B5060: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 824B5064: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 824B5068: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 824B506C: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 824B5070: 4BFEFA19  bl 0x824a4a88
	ctx.lr = 0x824B5074;
	sub_824A4A88(ctx, base);
	// 824B5074: A17F01F4  lhz r11, 0x1f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(500 as u32) ) } as u64;
	// 824B5078: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B507C: 419A0010  beq cr6, 0x824b508c
	if ctx.cr[6].eq {
	pc = 0x824B508C; continue 'dispatch;
	}
	// 824B5080: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B5084: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B5088: 4BFED741  bl 0x824a27c8
	ctx.lr = 0x824B508C;
	sub_824A27C8(ctx, base);
	pc = 0x824B508C; continue 'dispatch;
            }
            0x824B508C => {
    //   block [0x824B508C..0x824B50A4)
	// 824B508C: A17E01F4  lhz r11, 0x1f4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(500 as u32) ) } as u64;
	// 824B5090: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B5094: 419A0010  beq cr6, 0x824b50a4
	if ctx.cr[6].eq {
	pc = 0x824B50A4; continue 'dispatch;
	}
	// 824B5098: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B509C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824B50A0: 4BFED729  bl 0x824a27c8
	ctx.lr = 0x824B50A4;
	sub_824A27C8(ctx, base);
	pc = 0x824B50A4; continue 'dispatch;
            }
            0x824B50A4 => {
    //   block [0x824B50A4..0x824B50BC)
	// 824B50A4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 824B50A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824B50AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824B50B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824B50B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824B50B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B50C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824B50C0 size=164
    let mut pc: u32 = 0x824B50C0;
    'dispatch: loop {
        match pc {
            0x824B50C0 => {
    //   block [0x824B50C0..0x824B5138)
	// 824B50C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B50C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824B50C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824B50CC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B50D0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824B50D4: D0210064  stfs f1, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 824B50D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B50DC: 393F0020  addi r9, r31, 0x20
	ctx.r[9].s64 = ctx.r[31].s64 + 32;
	// 824B50E0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B50E4: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B50E8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B50EC: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 824B50F0: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 824B50F4: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 824B50F8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 824B50FC: 395F0040  addi r10, r31, 0x40
	ctx.r[10].s64 = ctx.r[31].s64 + 64;
	// 824B5100: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 824B5104: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 824B5108: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 824B510C: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 824B5110: 394B0010  addi r10, r11, 0x10
	ctx.r[10].s64 = ctx.r[11].s64 + 16;
	// 824B5114: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 824B5118: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B511C: 4BFEF885  bl 0x824a49a0
	ctx.lr = 0x824B5120;
	sub_824A49A0(ctx, base);
	// 824B5120: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B5124: A16301F4  lhz r11, 0x1f4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(500 as u32) ) } as u64;
	// 824B5128: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B512C: 419A000C  beq cr6, 0x824b5138
	if ctx.cr[6].eq {
	pc = 0x824B5138; continue 'dispatch;
	}
	// 824B5130: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B5134: 4BFED5B5  bl 0x824a26e8
	ctx.lr = 0x824B5138;
	sub_824A26E8(ctx, base);
	pc = 0x824B5138; continue 'dispatch;
            }
            0x824B5138 => {
    //   block [0x824B5138..0x824B5150)
	// 824B5138: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B513C: A16301F4  lhz r11, 0x1f4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(500 as u32) ) } as u64;
	// 824B5140: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B5144: 419A000C  beq cr6, 0x824b5150
	if ctx.cr[6].eq {
	pc = 0x824B5150; continue 'dispatch;
	}
	// 824B5148: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B514C: 4BFED59D  bl 0x824a26e8
	ctx.lr = 0x824B5150;
	sub_824A26E8(ctx, base);
	pc = 0x824B5150; continue 'dispatch;
            }
            0x824B5150 => {
    //   block [0x824B5150..0x824B5164)
	// 824B5150: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 824B5154: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824B5158: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824B515C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824B5160: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B5168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B5168 size=28
    let mut pc: u32 = 0x824B5168;
    'dispatch: loop {
        match pc {
            0x824B5168 => {
    //   block [0x824B5168..0x824B5184)
	// 824B5168: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824B516C: 90830008  stw r4, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 824B5170: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 824B5174: 396B0B50  addi r11, r11, 0xb50
	ctx.r[11].s64 = ctx.r[11].s64 + 2896;
	// 824B5178: B1430006  sth r10, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 824B517C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824B5180: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B5188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B5188 size=160
    let mut pc: u32 = 0x824B5188;
    'dispatch: loop {
        match pc {
            0x824B5188 => {
    //   block [0x824B5188..0x824B5210)
	// 824B5188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B518C: 4807FF31  bl 0x825350bc
	ctx.lr = 0x824B5190;
	sub_82535080(ctx, base);
	// 824B5190: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B5194: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 824B5198: 80ED0000  lwz r7, 0(r13)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B519C: 7CAA2B78  mr r10, r5
	ctx.r[10].u64 = ctx.r[5].u64;
	// 824B51A0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 824B51A4: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 824B51A8: 38A00022  li r5, 0x22
	ctx.r[5].s64 = 34;
	// 824B51AC: 892B0010  lbz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B51B0: 3880001C  li r4, 0x1c
	ctx.r[4].s64 = 28;
	// 824B51B4: 886A0010  lbz r3, 0x10(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B51B8: 7D280774  extsb r8, r9
	ctx.r[8].s64 = ctx.r[9].s8 as i64;
	// 824B51BC: 7C690774  extsb r9, r3
	ctx.r[9].s64 = ctx.r[3].s8 as i64;
	// 824B51C0: 7C66382E  lwzx r3, r6, r7
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 824B51C4: 7FE85A14  add r31, r8, r11
	ctx.r[31].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 824B51C8: 7FC95214  add r30, r9, r10
	ctx.r[30].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 824B51CC: 4BFAEE6D  bl 0x82464038
	ctx.lr = 0x824B51D0;
	sub_82464038(ctx, base);
	// 824B51D0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824B51D4: 3920001C  li r9, 0x1c
	ctx.r[9].s64 = 28;
	// 824B51D8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 824B51DC: 396B0B04  addi r11, r11, 0xb04
	ctx.r[11].s64 = ctx.r[11].s64 + 2820;
	// 824B51E0: B1230004  sth r9, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u16 ) };
	// 824B51E4: 813D0008  lwz r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B51E8: B1430006  sth r10, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 824B51EC: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 824B51F0: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824B51F4: A17E0096  lhz r11, 0x96(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(150 as u32) ) } as u64;
	// 824B51F8: A15F0096  lhz r10, 0x96(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(150 as u32) ) } as u64;
	// 824B51FC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 824B5200: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 824B5204: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 824B5208: 40980008  bge cr6, 0x824b5210
	if !ctx.cr[6].lt {
	pc = 0x824B5210; continue 'dispatch;
	}
	// 824B520C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x824B5210; continue 'dispatch;
            }
            0x824B5210 => {
    //   block [0x824B5210..0x824B5228)
	// 824B5210: B1630018  sth r11, 0x18(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u16 ) };
	// 824B5214: 9123000C  stw r9, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 824B5218: 93E30010  stw r31, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 824B521C: 93C30014  stw r30, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 824B5220: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824B5224: 4807FEE8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B5228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B5228 size=268
    let mut pc: u32 = 0x824B5228;
    'dispatch: loop {
        match pc {
            0x824B5228 => {
    //   block [0x824B5228..0x824B5288)
	// 824B5228: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B522C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824B5230: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824B5234: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824B5238: 9421FB80  stwu r1, -0x480(r1)
	ea = ctx.r[1].u32.wrapping_add(-1152 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B523C: A1630018  lhz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 824B5240: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824B5244: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 824B5248: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B524C: B1430018  sth r10, 0x18(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u16 ) };
	// 824B5250: 409A00CC  bne cr6, 0x824b531c
	if !ctx.cr[6].eq {
	pc = 0x824B531C; continue 'dispatch;
	}
	// 824B5254: 89640010  lbz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B5258: 89250010  lbz r9, 0x10(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B525C: 7D6A0774  extsb r10, r11
	ctx.r[10].s64 = ctx.r[11].s8 as i64;
	// 824B5260: 7D2B0774  extsb r11, r9
	ctx.r[11].s64 = ctx.r[9].s8 as i64;
	// 824B5264: 7FEA2214  add r31, r10, r4
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 824B5268: 7FCB2A14  add r30, r11, r5
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 824B526C: A17F0096  lhz r11, 0x96(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(150 as u32) ) } as u64;
	// 824B5270: A15E0096  lhz r10, 0x96(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(150 as u32) ) } as u64;
	// 824B5274: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 824B5278: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 824B527C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 824B5280: 41980008  blt cr6, 0x824b5288
	if ctx.cr[6].lt {
	pc = 0x824B5288; continue 'dispatch;
	}
	// 824B5284: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x824B5288; continue 'dispatch;
            }
            0x824B5288 => {
    //   block [0x824B5288..0x824B52CC)
	// 824B5288: B1630018  sth r11, 0x18(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u16 ) };
	// 824B528C: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 824B5290: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B5294: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 824B5298: 7D675850  subf r11, r7, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 824B529C: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 824B52A0: 90E1005C  stw r7, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[7].u32 ) };
	// 824B52A4: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 824B52A8: 90610460  stw r3, 0x460(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1120 as u32), ctx.r[3].u32 ) };
	// 824B52AC: 7D6B53D6  divw r11, r11, r10
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	// 824B52B0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824B52B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B52B8: 41980028  blt cr6, 0x824b52e0
	if ctx.cr[6].lt {
	pc = 0x824B52E0; continue 'dispatch;
	}
	// 824B52BC: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 824B52C0: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824B52C4: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 824B52C8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x824B52CC; continue 'dispatch;
            }
            0x824B52CC => {
    //   block [0x824B52CC..0x824B52E0)
	// 824B52CC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824B52D0: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824B52D4: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 824B52D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B52DC: 4098FFF0  bge cr6, 0x824b52cc
	if !ctx.cr[6].lt {
	pc = 0x824B52CC; continue 'dispatch;
	}
	pc = 0x824B52E0; continue 'dispatch;
            }
            0x824B52E0 => {
    //   block [0x824B52E0..0x824B5304)
	// 824B52E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B52E4: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B52E8: 4BFEF889  bl 0x824a4b70
	ctx.lr = 0x824B52EC;
	sub_824A4B70(ctx, base);
	// 824B52EC: A17F01F4  lhz r11, 0x1f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(500 as u32) ) } as u64;
	// 824B52F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B52F4: 419A0010  beq cr6, 0x824b5304
	if ctx.cr[6].eq {
	pc = 0x824B5304; continue 'dispatch;
	}
	// 824B52F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B52FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B5300: 4BFED5A9  bl 0x824a28a8
	ctx.lr = 0x824B5304;
	sub_824A28A8(ctx, base);
	pc = 0x824B5304; continue 'dispatch;
            }
            0x824B5304 => {
    //   block [0x824B5304..0x824B531C)
	// 824B5304: A17E01F4  lhz r11, 0x1f4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(500 as u32) ) } as u64;
	// 824B5308: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B530C: 419A0010  beq cr6, 0x824b531c
	if ctx.cr[6].eq {
	pc = 0x824B531C; continue 'dispatch;
	}
	// 824B5310: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B5314: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824B5318: 4BFED591  bl 0x824a28a8
	ctx.lr = 0x824B531C;
	sub_824A28A8(ctx, base);
	pc = 0x824B531C; continue 'dispatch;
            }
            0x824B531C => {
    //   block [0x824B531C..0x824B5334)
	// 824B531C: 38210480  addi r1, r1, 0x480
	ctx.r[1].s64 = ctx.r[1].s64 + 1152;
	// 824B5320: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824B5324: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824B5328: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824B532C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824B5330: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B5338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B5338 size=96
    let mut pc: u32 = 0x824B5338;
    'dispatch: loop {
        match pc {
            0x824B5338 => {
    //   block [0x824B5338..0x824B5380)
	// 824B5338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B533C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824B5340: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824B5344: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B5348: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824B534C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824B5350: 396B6DD0  addi r11, r11, 0x6dd0
	ctx.r[11].s64 = ctx.r[11].s64 + 28112;
	// 824B5354: 548A07FE  clrlwi r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 824B5358: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824B535C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824B5360: 419A0020  beq cr6, 0x824b5380
	if ctx.cr[6].eq {
	pc = 0x824B5380; continue 'dispatch;
	}
	// 824B5364: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B5368: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 824B536C: 38C00022  li r6, 0x22
	ctx.r[6].s64 = 34;
	// 824B5370: A0BF0004  lhz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B5374: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824B5378: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824B537C: 4BFAED3D  bl 0x824640b8
	ctx.lr = 0x824B5380;
	sub_824640B8(ctx, base);
	pc = 0x824B5380; continue 'dispatch;
            }
            0x824B5380 => {
    //   block [0x824B5380..0x824B5398)
	// 824B5380: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B5384: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824B5388: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824B538C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824B5390: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824B5394: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B5398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B5398 size=8
    let mut pc: u32 = 0x824B5398;
    'dispatch: loop {
        match pc {
            0x824B5398 => {
    //   block [0x824B5398..0x824B53A0)
	// 824B5398: 38630044  addi r3, r3, 0x44
	ctx.r[3].s64 = ctx.r[3].s64 + 68;
	// 824B539C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B53A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B53A0 size=48
    let mut pc: u32 = 0x824B53A0;
    'dispatch: loop {
        match pc {
            0x824B53A0 => {
    //   block [0x824B53A0..0x824B53D0)
	// 824B53A0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 824B53A4: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 824B53A8: A12B0010  lhz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B53AC: A0EA0004  lhz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B53B0: A10A000C  lhz r8, 0xc(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B53B4: 7D474A14  add r10, r7, r9
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 824B53B8: 3908FFFE  addi r8, r8, -2
	ctx.r[8].s64 = ctx.r[8].s64 + -2;
	// 824B53BC: 7D4A2214  add r10, r10, r4
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 824B53C0: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 824B53C4: 4099000C  ble cr6, 0x824b53d0
	if !ctx.cr[6].gt {
		sub_824B53D0(ctx, base);
		return;
	}
	// 824B53C8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 824B53CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B53D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B53D0 size=20
    let mut pc: u32 = 0x824B53D0;
    'dispatch: loop {
        match pc {
            0x824B53D0 => {
    //   block [0x824B53D0..0x824B53E4)
	// 824B53D0: 7D492214  add r10, r9, r4
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[4].u64;
	// 824B53D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824B53D8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 824B53DC: B14B0010  sth r10, 0x10(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u16 ) };
	// 824B53E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B53E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B53E8 size=148
    let mut pc: u32 = 0x824B53E8;
    'dispatch: loop {
        match pc {
            0x824B53E8 => {
    //   block [0x824B53E8..0x824B544C)
	// 824B53E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B53EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824B53F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824B53F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824B53F8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B53FC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 824B5400: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 824B5404: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 824B5408: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 824B540C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B5410: 83EB0058  lwz r31, 0x58(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 824B5414: 83CB005C  lwz r30, 0x5c(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 824B5418: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B541C: B1210050  sth r9, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u16 ) };
	// 824B5420: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 824B5424: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 824B5428: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 824B542C: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 824B5430: 4BFEF659  bl 0x824a4a88
	ctx.lr = 0x824B5434;
	sub_824A4A88(ctx, base);
	// 824B5434: A17F01F4  lhz r11, 0x1f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(500 as u32) ) } as u64;
	// 824B5438: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B543C: 419A0010  beq cr6, 0x824b544c
	if ctx.cr[6].eq {
	pc = 0x824B544C; continue 'dispatch;
	}
	// 824B5440: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B5444: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B5448: 4BFED381  bl 0x824a27c8
	ctx.lr = 0x824B544C;
	sub_824A27C8(ctx, base);
	pc = 0x824B544C; continue 'dispatch;
            }
            0x824B544C => {
    //   block [0x824B544C..0x824B5464)
	// 824B544C: A17E01F4  lhz r11, 0x1f4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(500 as u32) ) } as u64;
	// 824B5450: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B5454: 419A0010  beq cr6, 0x824b5464
	if ctx.cr[6].eq {
	pc = 0x824B5464; continue 'dispatch;
	}
	// 824B5458: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B545C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824B5460: 4BFED369  bl 0x824a27c8
	ctx.lr = 0x824B5464;
	sub_824A27C8(ctx, base);
	pc = 0x824B5464; continue 'dispatch;
            }
            0x824B5464 => {
    //   block [0x824B5464..0x824B547C)
	// 824B5464: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 824B5468: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824B546C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824B5470: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824B5474: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824B5478: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B5480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B5480 size=24
    let mut pc: u32 = 0x824B5480;
    'dispatch: loop {
        match pc {
            0x824B5480 => {
    //   block [0x824B5480..0x824B5498)
	// 824B5480: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 824B5484: 386B0014  addi r3, r11, 0x14
	ctx.r[3].s64 = ctx.r[11].s64 + 20;
	// 824B5488: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 824B548C: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 824B5490: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B5494: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B5498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B5498 size=24
    let mut pc: u32 = 0x824B5498;
    'dispatch: loop {
        match pc {
            0x824B5498 => {
    //   block [0x824B5498..0x824B54B0)
	// 824B5498: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 824B549C: 386B0014  addi r3, r11, 0x14
	ctx.r[3].s64 = ctx.r[11].s64 + 20;
	// 824B54A0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 824B54A4: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 824B54A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B54AC: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B54B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B54B0 size=20
    let mut pc: u32 = 0x824B54B0;
    'dispatch: loop {
        match pc {
            0x824B54B0 => {
    //   block [0x824B54B0..0x824B54C4)
	// 824B54B0: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 824B54B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B54B8: 409A000C  bne cr6, 0x824b54c4
	if !ctx.cr[6].eq {
		sub_824B54C4(ctx, base);
		return;
	}
	// 824B54BC: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 824B54C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B54C4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B54C4 size=76
    let mut pc: u32 = 0x824B54C4;
    'dispatch: loop {
        match pc {
            0x824B54C4 => {
    //   block [0x824B54C4..0x824B54F0)
	// 824B54C4: 81430020  lwz r10, 0x20(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 824B54C8: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B54CC: 812A0028  lwz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 824B54D0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 824B54D4: 396BFFD0  addi r11, r11, -0x30
	ctx.r[11].s64 = ctx.r[11].s64 + -48;
	// 824B54D8: 7D692E70  srawi r9, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 824B54DC: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B54E0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824B54E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B54E8: 41980020  blt cr6, 0x824b5508
	if ctx.cr[6].lt {
	pc = 0x824B5508; continue 'dispatch;
	}
	// 824B54EC: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x824B54F0; continue 'dispatch;
            }
            0x824B54F0 => {
    //   block [0x824B54F0..0x824B5508)
	// 824B54F0: 7D0A58AE  lbzx r8, r10, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824B54F4: 7F084800  cmpw cr6, r8, r9
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824B54F8: 419A0010  beq cr6, 0x824b5508
	if ctx.cr[6].eq {
	pc = 0x824B5508; continue 'dispatch;
	}
	// 824B54FC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824B5500: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B5504: 4098FFEC  bge cr6, 0x824b54f0
	if !ctx.cr[6].lt {
	pc = 0x824B54F0; continue 'dispatch;
	}
	pc = 0x824B5508; continue 'dispatch;
            }
            0x824B5508 => {
    //   block [0x824B5508..0x824B5510)
	// 824B5508: 5563043E  clrlwi r3, r11, 0x10
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 824B550C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B5510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B5510 size=12
    let mut pc: u32 = 0x824B5510;
    'dispatch: loop {
        match pc {
            0x824B5510 => {
    //   block [0x824B5510..0x824B551C)
	// 824B5510: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 824B5514: 386BFFEC  addi r3, r11, -0x14
	ctx.r[3].s64 = ctx.r[11].s64 + -20;
	// 824B5518: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B5520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824B5520 size=268
    let mut pc: u32 = 0x824B5520;
    'dispatch: loop {
        match pc {
            0x824B5520 => {
    //   block [0x824B5520..0x824B55A0)
	// 824B5520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B5524: 4807FB99  bl 0x825350bc
	ctx.lr = 0x824B5528;
	sub_82535080(ctx, base);
	// 824B5528: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B552C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824B5530: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B5534: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 824B5538: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B553C: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B5540: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B5544: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B5548: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 824B554C: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 824B5550: D0210064  stfs f1, 0x64(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 824B5554: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 824B5558: 396A0010  addi r11, r10, 0x10
	ctx.r[11].s64 = ctx.r[10].s64 + 16;
	// 824B555C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 824B5560: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 824B5564: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 824B5568: 397F0040  addi r11, r31, 0x40
	ctx.r[11].s64 = ctx.r[31].s64 + 64;
	// 824B556C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 824B5570: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824B5574: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 824B5578: 39630014  addi r11, r3, 0x14
	ctx.r[11].s64 = ctx.r[3].s64 + 20;
	// 824B557C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824B5580: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 824B5584: 4BFEF41D  bl 0x824a49a0
	ctx.lr = 0x824B5588;
	sub_824A49A0(ctx, base);
	// 824B5588: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B558C: A16301F4  lhz r11, 0x1f4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(500 as u32) ) } as u64;
	// 824B5590: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B5594: 419A000C  beq cr6, 0x824b55a0
	if ctx.cr[6].eq {
	pc = 0x824B55A0; continue 'dispatch;
	}
	// 824B5598: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B559C: 4BFED14D  bl 0x824a26e8
	ctx.lr = 0x824B55A0;
	sub_824A26E8(ctx, base);
	pc = 0x824B55A0; continue 'dispatch;
            }
            0x824B55A0 => {
    //   block [0x824B55A0..0x824B55B8)
	// 824B55A0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B55A4: A16301F4  lhz r11, 0x1f4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(500 as u32) ) } as u64;
	// 824B55A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B55AC: 419A000C  beq cr6, 0x824b55b8
	if ctx.cr[6].eq {
	pc = 0x824B55B8; continue 'dispatch;
	}
	// 824B55B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B55B4: 4BFED135  bl 0x824a26e8
	ctx.lr = 0x824B55B8;
	sub_824A26E8(ctx, base);
	pc = 0x824B55B8; continue 'dispatch;
            }
            0x824B55B8 => {
    //   block [0x824B55B8..0x824B55D8)
	// 824B55B8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B55BC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B55C0: 896B00D8  lbz r11, 0xd8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(216 as u32) ) } as u64;
	// 824B55C4: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 824B55C8: 419A0010  beq cr6, 0x824b55d8
	if ctx.cr[6].eq {
	pc = 0x824B55D8; continue 'dispatch;
	}
	// 824B55CC: 2B0B0006  cmplwi cr6, r11, 6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 6 as u32, &mut ctx.xer);
	// 824B55D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824B55D4: 409A0008  bne cr6, 0x824b55dc
	if !ctx.cr[6].eq {
	pc = 0x824B55DC; continue 'dispatch;
	}
	pc = 0x824B55D8; continue 'dispatch;
            }
            0x824B55D8 => {
    //   block [0x824B55D8..0x824B55DC)
	// 824B55D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x824B55DC; continue 'dispatch;
            }
            0x824B55DC => {
    //   block [0x824B55DC..0x824B5600)
	// 824B55DC: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824B55E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B55E4: 419A002C  beq cr6, 0x824b5610
	if ctx.cr[6].eq {
	pc = 0x824B5610; continue 'dispatch;
	}
	// 824B55E8: 896A00D8  lbz r11, 0xd8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(216 as u32) ) } as u64;
	// 824B55EC: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 824B55F0: 419A0010  beq cr6, 0x824b5600
	if ctx.cr[6].eq {
	pc = 0x824B5600; continue 'dispatch;
	}
	// 824B55F4: 2B0B0006  cmplwi cr6, r11, 6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 6 as u32, &mut ctx.xer);
	// 824B55F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824B55FC: 409A0008  bne cr6, 0x824b5604
	if !ctx.cr[6].eq {
	pc = 0x824B5604; continue 'dispatch;
	}
	pc = 0x824B5600; continue 'dispatch;
            }
            0x824B5600 => {
    //   block [0x824B5600..0x824B5604)
	// 824B5600: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x824B5604; continue 'dispatch;
            }
            0x824B5604 => {
    //   block [0x824B5604..0x824B5610)
	// 824B5604: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824B5608: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B560C: 409A0018  bne cr6, 0x824b5624
	if !ctx.cr[6].eq {
	pc = 0x824B5624; continue 'dispatch;
	}
	pc = 0x824B5610; continue 'dispatch;
            }
            0x824B5610 => {
    //   block [0x824B5610..0x824B5624)
	// 824B5610: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 824B5614: C0210064  lfs f1, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 824B5618: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824B561C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824B5620: 48011D41  bl 0x824c7360
	ctx.lr = 0x824B5624;
	sub_824C7360(ctx, base);
	pc = 0x824B5624; continue 'dispatch;
            }
            0x824B5624 => {
    //   block [0x824B5624..0x824B562C)
	// 824B5624: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824B5628: 4807FAE4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B5630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824B5630 size=280
    let mut pc: u32 = 0x824B5630;
    'dispatch: loop {
        match pc {
            0x824B5630 => {
    //   block [0x824B5630..0x824B56E4)
	// 824B5630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B5634: 4807FA6D  bl 0x825350a0
	ctx.lr = 0x824B5638;
	sub_82535080(ctx, base);
	// 824B5638: DBE1FFA0  stfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 824B563C: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B5640: 82E1014C  lwz r23, 0x14c(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(332 as u32) ) } as u64;
	// 824B5644: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 824B5648: 7CF83B78  mr r24, r7
	ctx.r[24].u64 = ctx.r[7].u64;
	// 824B564C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 824B5650: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 824B5654: 38C00007  li r6, 7
	ctx.r[6].s64 = 7;
	// 824B5658: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824B565C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 824B5660: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 824B5664: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	// 824B5668: 7D595378  mr r25, r10
	ctx.r[25].u64 = ctx.r[10].u64;
	// 824B566C: 48000B2D  bl 0x824b6198
	ctx.lr = 0x824B5670;
	sub_824B6198(ctx, base);
	// 824B5670: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 824B5674: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824B5678: 815F0058  lwz r10, 0x58(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 824B567C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B5680: 82C10144  lwz r22, 0x144(r1)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(324 as u32) ) } as u64;
	// 824B5684: D3E10080  stfs f31, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 824B5688: 7D6A5278  xor r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 824B568C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 824B5690: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824B5694: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B5698: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 824B569C: 7D5DF278  xor r29, r10, r30
	ctx.r[29].u64 = ctx.r[10].u64 ^ ctx.r[30].u64;
	// 824B56A0: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 824B56A4: C0160000  lfs f0, 0(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B56A8: 93210064  stw r25, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[25].u32 ) };
	// 824B56AC: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 824B56B0: 92E10068  stw r23, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[23].u32 ) };
	// 824B56B4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 824B56B8: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 824B56BC: 93610078  stw r27, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[27].u32 ) };
	// 824B56C0: 9301007C  stw r24, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[24].u32 ) };
	// 824B56C4: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 824B56C8: 4BFEF1F1  bl 0x824a48b8
	ctx.lr = 0x824B56CC;
	sub_824A48B8(ctx, base);
	// 824B56CC: A17E01F4  lhz r11, 0x1f4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(500 as u32) ) } as u64;
	// 824B56D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B56D4: 419A0010  beq cr6, 0x824b56e4
	if ctx.cr[6].eq {
	pc = 0x824B56E4; continue 'dispatch;
	}
	// 824B56D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B56DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824B56E0: 4BFECF29  bl 0x824a2608
	ctx.lr = 0x824B56E4;
	sub_824A2608(ctx, base);
	pc = 0x824B56E4; continue 'dispatch;
            }
            0x824B56E4 => {
    //   block [0x824B56E4..0x824B56FC)
	// 824B56E4: A17D01F4  lhz r11, 0x1f4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(500 as u32) ) } as u64;
	// 824B56E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B56EC: 419A0010  beq cr6, 0x824b56fc
	if ctx.cr[6].eq {
	pc = 0x824B56FC; continue 'dispatch;
	}
	// 824B56F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B56F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 824B56F8: 4BFECF11  bl 0x824a2608
	ctx.lr = 0x824B56FC;
	sub_824A2608(ctx, base);
	pc = 0x824B56FC; continue 'dispatch;
            }
            0x824B56FC => {
    //   block [0x824B56FC..0x824B5734)
	// 824B56FC: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 824B5700: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 824B5704: 409A0030  bne cr6, 0x824b5734
	if !ctx.cr[6].eq {
	pc = 0x824B5734; continue 'dispatch;
	}
	// 824B5708: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B570C: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 824B5710: 80980004  lwz r4, 4(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B5714: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B5718: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 824B571C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B5720: 4E800421  bctrl
	ctx.lr = 0x824B5724;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824B5724: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 824B5728: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 824B572C: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 824B5730: 4807F9C0  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x824B5734 => {
    //   block [0x824B5734..0x824B5748)
	// 824B5734: C001006C  lfs f0, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B5738: D0160000  stfs f0, 0(r22)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 824B573C: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 824B5740: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 824B5744: 4807F9AC  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B5748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824B5748 size=848
    let mut pc: u32 = 0x824B5748;
    'dispatch: loop {
        match pc {
            0x824B5748 => {
    //   block [0x824B5748..0x824B57B8)
	// 824B5748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B574C: 4807F951  bl 0x8253509c
	ctx.lr = 0x824B5750;
	sub_82535080(ctx, base);
	// 824B5750: DBC1FF90  stfd f30, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[30].u64 ) };
	// 824B5754: DBE1FF98  stfd f31, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 824B5758: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B575C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824B5760: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 824B5764: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 824B5768: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 824B576C: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 824B5770: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 824B5774: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 824B5778: A13F0010  lhz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B577C: 7D174378  mr r23, r8
	ctx.r[23].u64 = ctx.r[8].u64;
	// 824B5780: A14B0004  lhz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B5784: A16B000C  lhz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B5788: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 824B578C: 396BFFFE  addi r11, r11, -2
	ctx.r[11].s64 = ctx.r[11].s64 + -2;
	// 824B5790: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824B5794: 419901D8  bgt cr6, 0x824b596c
	if ctx.cr[6].gt {
	pc = 0x824B596C; continue 'dispatch;
	}
	// 824B5798: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824B579C: 409A001C  bne cr6, 0x824b57b8
	if !ctx.cr[6].eq {
	pc = 0x824B57B8; continue 'dispatch;
	}
	// 824B57A0: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B57A4: 389F0044  addi r4, r31, 0x44
	ctx.r[4].s64 = ctx.r[31].s64 + 68;
	// 824B57A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B57AC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B57B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B57B4: 4E800421  bctrl
	ctx.lr = 0x824B57B8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824B57B8 => {
    //   block [0x824B57B8..0x824B596C)
	// 824B57B8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 824B57BC: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B57C0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 824B57C4: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 824B57C8: 3ABC0004  addi r21, r28, 4
	ctx.r[21].s64 = ctx.r[28].s64 + 4;
	// 824B57CC: 4801031D  bl 0x824c5ae8
	ctx.lr = 0x824B57D0;
	sub_824C5AE8(ctx, base);
	// 824B57D0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 824B57D4: 3B7E0010  addi r27, r30, 0x10
	ctx.r[27].s64 = ctx.r[30].s64 + 16;
	pc = 0x824B596C; continue 'dispatch;
            }
            0x824B596C => {
    //   block [0x824B596C..0x824B5A98)
	// 824B596C: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 824B5970: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 824B5974: CBC1FF90  lfd f30, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 824B5978: CBE1FF98  lfd f31, -0x68(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 824B597C: 4807F770  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
	// 824B5980: A1610092  lhz r11, 0x92(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(146 as u32) ) } as u64;
	// 824B5984: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824B5988: B17F0012  sth r11, 0x12(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[11].u16 ) };
	// 824B598C: 896A000D  lbz r11, 0xd(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(13 as u32) ) } as u64;
	// 824B5990: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 824B5994: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 824B5998: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 824B599C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824B59A0: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 824B59A4: C00B2384  lfs f0, 0x2384(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B59A8: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 824B59AC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 824B59B0: 409A00B8  bne cr6, 0x824b5a68
	if !ctx.cr[6].eq {
	pc = 0x824B5A68; continue 'dispatch;
	}
	// 824B59B4: A17D01F4  lhz r11, 0x1f4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(500 as u32) ) } as u64;
	// 824B59B8: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 824B59BC: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 824B59C0: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 824B59C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B59C8: 409A00A0  bne cr6, 0x824b5a68
	if !ctx.cr[6].eq {
	pc = 0x824B5A68; continue 'dispatch;
	}
	// 824B59CC: A17B01F4  lhz r11, 0x1f4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[27].u32.wrapping_add(500 as u32) ) } as u64;
	// 824B59D0: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 824B59D4: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 824B59D8: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 824B59DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B59E0: 409A0088  bne cr6, 0x824b5a68
	if !ctx.cr[6].eq {
	pc = 0x824B5A68; continue 'dispatch;
	}
	// 824B59E4: 39600190  li r11, 0x190
	ctx.r[11].s64 = 400;
	// 824B59E8: 39210054  addi r9, r1, 0x54
	ctx.r[9].s64 = ctx.r[1].s64 + 84;
	// 824B59EC: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 824B59F0: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B5A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B5A98 size=404
    let mut pc: u32 = 0x824B5A98;
    'dispatch: loop {
        match pc {
            0x824B5A98 => {
    //   block [0x824B5A98..0x824B5AEC)
	// 824B5A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B5A9C: 4807F609  bl 0x825350a4
	ctx.lr = 0x824B5AA0;
	sub_82535080(ctx, base);
	// 824B5AA0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B5AA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824B5AA8: 54AB043E  clrlwi r11, r5, 0x10
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x0000FFFFu64;
	// 824B5AAC: 38C000FF  li r6, 0xff
	ctx.r[6].s64 = 255;
	// 824B5AB0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 824B5AB4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 824B5AB8: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B5ABC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 824B5AC0: 83DF0028  lwz r30, 0x28(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 824B5AC4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 824B5AC8: 7FAB50AE  lbzx r29, r11, r10
	ctx.r[29].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824B5ACC: 7CCB51AE  stbx r6, r11, r10
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[6].u8) };
	// 824B5AD0: A31E0004  lhz r24, 4(r30)
	ctx.r[24].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B5AD4: 82FF0028  lwz r23, 0x28(r31)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 824B5AD8: 2F180002  cmpwi cr6, r24, 2
	ctx.cr[6].compare_i32(ctx.r[24].s32, 2, &mut ctx.xer);
	// 824B5ADC: 409A0010  bne cr6, 0x824b5aec
	if !ctx.cr[6].eq {
	pc = 0x824B5AEC; continue 'dispatch;
	}
	// 824B5AE0: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 824B5AE4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 824B5AE8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	pc = 0x824B5AEC; continue 'dispatch;
            }
            0x824B5AEC => {
    //   block [0x824B5AEC..0x824B5B08)
	// 824B5AEC: 570B07FE  clrlwi r11, r24, 0x1f
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x00000001u64;
	// 824B5AF0: 3B480001  addi r26, r8, 1
	ctx.r[26].s64 = ctx.r[8].s64 + 1;
	// 824B5AF4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B5AF8: 3B270001  addi r25, r7, 1
	ctx.r[25].s64 = ctx.r[7].s64 + 1;
	// 824B5AFC: 3B690030  addi r27, r9, 0x30
	ctx.r[27].s64 = ctx.r[9].s64 + 48;
	// 824B5B00: 409A0008  bne cr6, 0x824b5b08
	if !ctx.cr[6].eq {
	pc = 0x824B5B08; continue 'dispatch;
	}
	// 824B5B04: 3B690040  addi r27, r9, 0x40
	ctx.r[27].s64 = ctx.r[9].s64 + 64;
	pc = 0x824B5B08; continue 'dispatch;
            }
            0x824B5B08 => {
    //   block [0x824B5B08..0x824B5B60)
	// 824B5B08: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824B5B0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824B5B10: 48000801  bl 0x824b6310
	ctx.lr = 0x824B5B14;
	sub_824B6310(ctx, base);
	// 824B5B14: 895E000A  lbz r10, 0xa(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(10 as u32) ) } as u64;
	// 824B5B18: 7FAB0734  extsh r11, r29
	ctx.r[11].s64 = ctx.r[29].s16 as i64;
	// 824B5B1C: A13E0006  lhz r9, 6(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) } as u64;
	// 824B5B20: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824B5B24: 7D6A59D6  mullw r11, r10, r11
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 824B5B28: 552A283E  rotlwi r10, r9, 5
	ctx.r[10].u64 = ((ctx.r[9].u32).rotate_left(5)) as u64;
	// 824B5B2C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824B5B30: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 824B5B34: 894B003F  lbz r10, 0x3f(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(63 as u32) ) } as u64;
	// 824B5B38: 714A00FD  andi. r10, r10, 0xfd
	ctx.r[10].u64 = ctx.r[10].u64 & 253;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824B5B3C: 994B003F  stb r10, 0x3f(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(63 as u32), ctx.r[10].u8 ) };
	// 824B5B40: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 824B5B44: 4801087D  bl 0x824c63c0
	ctx.lr = 0x824B5B48;
	sub_824C63C0(ctx, base);
	// 824B5B48: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824B5B4C: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 824B5B50: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B5B54: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824B5B58: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B5B5C: 41980034  blt cr6, 0x824b5b90
	if ctx.cr[6].lt {
	pc = 0x824B5B90; continue 'dispatch;
	}
	pc = 0x824B5B60; continue 'dispatch;
            }
            0x824B5B60 => {
    //   block [0x824B5B60..0x824B5B84)
	// 824B5B60: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B5B64: 7D2A58AE  lbzx r9, r10, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824B5B68: 2B0900FF  cmplwi cr6, r9, 0xff
	ctx.cr[6].compare_u32(ctx.r[9].u32, 255 as u32, &mut ctx.xer);
	// 824B5B6C: 419A0018  beq cr6, 0x824b5b84
	if ctx.cr[6].eq {
	pc = 0x824B5B84; continue 'dispatch;
	}
	// 824B5B70: 7F09E800  cmpw cr6, r9, r29
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[29].s32, &mut ctx.xer);
	// 824B5B74: 40990010  ble cr6, 0x824b5b84
	if !ctx.cr[6].gt {
	pc = 0x824B5B84; continue 'dispatch;
	}
	// 824B5B78: 5529063E  clrlwi r9, r9, 0x18
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 824B5B7C: 392900FF  addi r9, r9, 0xff
	ctx.r[9].s64 = ctx.r[9].s64 + 255;
	// 824B5B80: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	pc = 0x824B5B84; continue 'dispatch;
            }
            0x824B5B84 => {
    //   block [0x824B5B84..0x824B5B90)
	// 824B5B84: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824B5B88: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B5B8C: 4098FFD4  bge cr6, 0x824b5b60
	if !ctx.cr[6].lt {
	pc = 0x824B5B60; continue 'dispatch;
	}
	pc = 0x824B5B90; continue 'dispatch;
            }
            0x824B5B90 => {
    //   block [0x824B5B90..0x824B5BEC)
	// 824B5B90: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 824B5B94: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 824B5B98: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824B5B9C: 419A0050  beq cr6, 0x824b5bec
	if ctx.cr[6].eq {
	pc = 0x824B5BEC; continue 'dispatch;
	}
	// 824B5BA0: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B5BA4: 813C0010  lwz r9, 0x10(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B5BA8: 811C0014  lwz r8, 0x14(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 824B5BAC: 7D5B5050  subf r10, r27, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[27].s64;
	// 824B5BB0: 7D3A4850  subf r9, r26, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[26].s64;
	// 824B5BB4: 7D194050  subf r8, r25, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[25].s64;
	// 824B5BB8: 915C000C  stw r10, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 824B5BBC: 913C0010  stw r9, 0x10(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 824B5BC0: 911C0014  stw r8, 0x14(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 824B5BC4: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 824B5BC8: A14B0016  lhz r10, 0x16(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(22 as u32) ) } as u64;
	// 824B5BCC: A12B0018  lhz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824B5BD0: A10B0014  lhz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 824B5BD4: 7D5A5050  subf r10, r26, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[26].s64;
	// 824B5BD8: 7D394850  subf r9, r25, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[25].s64;
	// 824B5BDC: 7D1B4050  subf r8, r27, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[27].s64;
	// 824B5BE0: B14B0016  sth r10, 0x16(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(22 as u32), ctx.r[10].u16 ) };
	// 824B5BE4: B12B0018  sth r9, 0x18(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[9].u16 ) };
	// 824B5BE8: B10B0014  sth r8, 0x14(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[8].u16 ) };
	pc = 0x824B5BEC; continue 'dispatch;
            }
            0x824B5BEC => {
    //   block [0x824B5BEC..0x824B5C14)
	// 824B5BEC: 80BF0028  lwz r5, 0x28(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 824B5BF0: 7F172840  cmplw cr6, r23, r5
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[5].u32, &mut ctx.xer);
	// 824B5BF4: 419A0020  beq cr6, 0x824b5c14
	if ctx.cr[6].eq {
	pc = 0x824B5C14; continue 'dispatch;
	}
	// 824B5BF8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 824B5BFC: A0C50002  lhz r6, 2(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(2 as u32) ) } as u64;
	// 824B5C00: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 824B5C04: 48005755  bl 0x824bb358
	ctx.lr = 0x824B5C08;
	sub_824BB358(ctx, base);
	// 824B5C08: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 824B5C0C: A16B0002  lhz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 824B5C10: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	pc = 0x824B5C14; continue 'dispatch;
            }
            0x824B5C14 => {
    //   block [0x824B5C14..0x824B5C2C)
	// 824B5C14: A17E0010  lhz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B5C18: 3878FFFF  addi r3, r24, -1
	ctx.r[3].s64 = ctx.r[24].s64 + -1;
	// 824B5C1C: 616B0005  ori r11, r11, 5
	ctx.r[11].u64 = ctx.r[11].u64 | 5;
	// 824B5C20: B17E0010  sth r11, 0x10(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[11].u16 ) };
	// 824B5C24: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824B5C28: 4807F4CC  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B5C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B5C30 size=240
    let mut pc: u32 = 0x824B5C30;
    'dispatch: loop {
        match pc {
            0x824B5C30 => {
    //   block [0x824B5C30..0x824B5C70)
	// 824B5C30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B5C34: 4807F47D  bl 0x825350b0
	ctx.lr = 0x824B5C38;
	sub_82535080(ctx, base);
	// 824B5C38: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B5C3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824B5C40: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 824B5C44: 3BDF0014  addi r30, r31, 0x14
	ctx.r[30].s64 = ctx.r[31].s64 + 20;
	// 824B5C48: 57AB043E  clrlwi r11, r29, 0x10
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x0000FFFFu64;
	// 824B5C4C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 824B5C50: 839F0058  lwz r28, 0x58(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 824B5C54: 835F005C  lwz r26, 0x5c(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 824B5C58: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B5C5C: 7D4A58AE  lbzx r10, r10, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824B5C60: 2F0A00FF  cmpwi cr6, r10, 0xff
	ctx.cr[6].compare_i32(ctx.r[10].s32, 255, &mut ctx.xer);
	// 824B5C64: 409A000C  bne cr6, 0x824b5c70
	if !ctx.cr[6].eq {
	pc = 0x824B5C70; continue 'dispatch;
	}
	// 824B5C68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824B5C6C: 48000028  b 0x824b5c94
	pc = 0x824B5C94; continue 'dispatch;
            }
            0x824B5C70 => {
    //   block [0x824B5C70..0x824B5C94)
	// 824B5C70: 817E0028  lwz r11, 0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 824B5C74: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 824B5C78: 892B000A  lbz r9, 0xa(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(10 as u32) ) } as u64;
	// 824B5C7C: A10B0006  lhz r8, 6(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 824B5C80: 7D4951D6  mullw r10, r9, r10
	ctx.r[10].s32 = ((ctx.r[9].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 824B5C84: 5509283E  rotlwi r9, r8, 5
	ctx.r[9].u64 = ((ctx.r[8].u32).rotate_left(5)) as u64;
	// 824B5C88: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 824B5C8C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 824B5C90: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	pc = 0x824B5C94; continue 'dispatch;
            }
            0x824B5C94 => {
    //   block [0x824B5C94..0x824B5CD0)
	// 824B5C94: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B5C98: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B5C9C: B3A10050  sth r29, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u16 ) };
	// 824B5CA0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 824B5CA4: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 824B5CA8: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 824B5CAC: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 824B5CB0: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	// 824B5CB4: 4BFEEDD5  bl 0x824a4a88
	ctx.lr = 0x824B5CB8;
	sub_824A4A88(ctx, base);
	// 824B5CB8: A17C01F4  lhz r11, 0x1f4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(500 as u32) ) } as u64;
	// 824B5CBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B5CC0: 419A0010  beq cr6, 0x824b5cd0
	if ctx.cr[6].eq {
	pc = 0x824B5CD0; continue 'dispatch;
	}
	// 824B5CC4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B5CC8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824B5CCC: 4BFECAFD  bl 0x824a27c8
	ctx.lr = 0x824B5CD0;
	sub_824A27C8(ctx, base);
	pc = 0x824B5CD0; continue 'dispatch;
            }
            0x824B5CD0 => {
    //   block [0x824B5CD0..0x824B5CE8)
	// 824B5CD0: A17A01F4  lhz r11, 0x1f4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[26].u32.wrapping_add(500 as u32) ) } as u64;
	// 824B5CD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B5CD8: 419A0010  beq cr6, 0x824b5ce8
	if ctx.cr[6].eq {
	pc = 0x824B5CE8; continue 'dispatch;
	}
	// 824B5CDC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B5CE0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 824B5CE4: 4BFECAE5  bl 0x824a27c8
	ctx.lr = 0x824B5CE8;
	sub_824A27C8(ctx, base);
	pc = 0x824B5CE8; continue 'dispatch;
            }
            0x824B5CE8 => {
    //   block [0x824B5CE8..0x824B5D18)
	// 824B5CE8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 824B5CEC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824B5CF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 824B5CF4: 4BFFFDA5  bl 0x824b5a98
	ctx.lr = 0x824B5CF8;
	sub_824B5A98(ctx, base);
	// 824B5CF8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 824B5CFC: 409A001C  bne cr6, 0x824b5d18
	if !ctx.cr[6].eq {
	pc = 0x824B5D18; continue 'dispatch;
	}
	// 824B5D00: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B5D04: 389F0044  addi r4, r31, 0x44
	ctx.r[4].s64 = ctx.r[31].s64 + 68;
	// 824B5D08: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 824B5D0C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B5D10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B5D14: 4E800421  bctrl
	ctx.lr = 0x824B5D18;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824B5D18 => {
    //   block [0x824B5D18..0x824B5D20)
	// 824B5D18: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 824B5D1C: 4807F3E4  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B5D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B5D20 size=32
    let mut pc: u32 = 0x824B5D20;
    'dispatch: loop {
        match pc {
            0x824B5D20 => {
    //   block [0x824B5D20..0x824B5D40)
	// 824B5D20: 81230020  lwz r9, 0x20(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 824B5D24: 548B043E  clrlwi r11, r4, 0x10
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x0000FFFFu64;
	// 824B5D28: 8143003C  lwz r10, 0x3c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 824B5D2C: 7D6958AE  lbzx r11, r9, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824B5D30: 556B283E  rotlwi r11, r11, 5
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(5)) as u64;
	// 824B5D34: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824B5D38: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 824B5D3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B5D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B5D40 size=28
    let mut pc: u32 = 0x824B5D40;
    'dispatch: loop {
        match pc {
            0x824B5D40 => {
    //   block [0x824B5D40..0x824B5D5C)
	// 824B5D40: 81430020  lwz r10, 0x20(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 824B5D44: 548B043E  clrlwi r11, r4, 0x10
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x0000FFFFu64;
	// 824B5D48: 7D4A58AE  lbzx r10, r10, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824B5D4C: 2F0A00FF  cmpwi cr6, r10, 0xff
	ctx.cr[6].compare_i32(ctx.r[10].s32, 255, &mut ctx.xer);
	// 824B5D50: 409A000C  bne cr6, 0x824b5d5c
	if !ctx.cr[6].eq {
		sub_824B5D5C(ctx, base);
		return;
	}
	// 824B5D54: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 824B5D58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B5D5C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B5D5C size=40
    let mut pc: u32 = 0x824B5D5C;
    'dispatch: loop {
        match pc {
            0x824B5D5C => {
    //   block [0x824B5D5C..0x824B5D84)
	// 824B5D5C: 8163003C  lwz r11, 0x3c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 824B5D60: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 824B5D64: 892B000A  lbz r9, 0xa(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(10 as u32) ) } as u64;
	// 824B5D68: A10B0006  lhz r8, 6(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 824B5D6C: 7D4951D6  mullw r10, r9, r10
	ctx.r[10].s32 = ((ctx.r[9].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 824B5D70: 5509283E  rotlwi r9, r8, 5
	ctx.r[9].u64 = ((ctx.r[8].u32).rotate_left(5)) as u64;
	// 824B5D74: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 824B5D78: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 824B5D7C: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 824B5D80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B5D88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B5D88 size=28
    let mut pc: u32 = 0x824B5D88;
    'dispatch: loop {
        match pc {
            0x824B5D88 => {
    //   block [0x824B5D88..0x824B5DA4)
	// 824B5D88: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824B5D8C: 90830008  stw r4, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 824B5D90: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 824B5D94: 396B0B64  addi r11, r11, 0xb64
	ctx.r[11].s64 = ctx.r[11].s64 + 2916;
	// 824B5D98: B1430006  sth r10, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 824B5D9C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824B5DA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B5DB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B5DB0 size=364
    let mut pc: u32 = 0x824B5DB0;
    'dispatch: loop {
        match pc {
            0x824B5DB0 => {
    //   block [0x824B5DB0..0x824B5E08)
	// 824B5DB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B5DB4: 4807F301  bl 0x825350b4
	ctx.lr = 0x824B5DB8;
	sub_82535080(ctx, base);
	// 824B5DB8: 9421FB60  stwu r1, -0x4a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-1184 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B5DBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824B5DC0: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 824B5DC4: A17F0012  lhz r11, 0x12(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 824B5DC8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B5DCC: 3BABFFFF  addi r29, r11, -1
	ctx.r[29].s64 = ctx.r[11].s64 + -1;
	// 824B5DD0: 409A00F0  bne cr6, 0x824b5ec0
	if !ctx.cr[6].eq {
	pc = 0x824B5EC0; continue 'dispatch;
	}
	// 824B5DD4: 89640010  lbz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B5DD8: 89250010  lbz r9, 0x10(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B5DDC: 7D6A0774  extsb r10, r11
	ctx.r[10].s64 = ctx.r[11].s8 as i64;
	// 824B5DE0: 7D2B0774  extsb r11, r9
	ctx.r[11].s64 = ctx.r[9].s8 as i64;
	// 824B5DE4: 7F8A2214  add r28, r10, r4
	ctx.r[28].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 824B5DE8: 7F6B2A14  add r27, r11, r5
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 824B5DEC: A17C0096  lhz r11, 0x96(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(150 as u32) ) } as u64;
	// 824B5DF0: A15B0096  lhz r10, 0x96(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[27].u32.wrapping_add(150 as u32) ) } as u64;
	// 824B5DF4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 824B5DF8: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 824B5DFC: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 824B5E00: 41980008  blt cr6, 0x824b5e08
	if ctx.cr[6].lt {
	pc = 0x824B5E08; continue 'dispatch;
	}
	// 824B5E04: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x824B5E08; continue 'dispatch;
            }
            0x824B5E08 => {
    //   block [0x824B5E08..0x824B5E34)
	// 824B5E08: 80DE0000  lwz r6, 0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B5E0C: 391E0010  addi r8, r30, 0x10
	ctx.r[8].s64 = ctx.r[30].s64 + 16;
	// 824B5E10: 557D043E  clrlwi r29, r11, 0x10
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 824B5E14: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 824B5E18: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 824B5E1C: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 824B5E20: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 824B5E24: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 824B5E28: 93E10460  stw r31, 0x460(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1120 as u32), ctx.r[31].u32 ) };
	// 824B5E2C: 40980058  bge cr6, 0x824b5e84
	if !ctx.cr[6].lt {
	pc = 0x824B5E84; continue 'dispatch;
	}
	// 824B5E30: 80BF0020  lwz r5, 0x20(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	pc = 0x824B5E34; continue 'dispatch;
            }
            0x824B5E34 => {
    //   block [0x824B5E34..0x824B5E4C)
	// 824B5E34: 81680020  lwz r11, 0x20(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(32 as u32) ) } as u64;
	// 824B5E38: 7D4B28AE  lbzx r10, r11, r5
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 824B5E3C: 2F0A00FF  cmpwi cr6, r10, 0xff
	ctx.cr[6].compare_i32(ctx.r[10].s32, 255, &mut ctx.xer);
	// 824B5E40: 409A000C  bne cr6, 0x824b5e4c
	if !ctx.cr[6].eq {
	pc = 0x824B5E4C; continue 'dispatch;
	}
	// 824B5E44: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824B5E48: 48000028  b 0x824b5e70
	pc = 0x824B5E70; continue 'dispatch;
            }
            0x824B5E4C => {
    //   block [0x824B5E4C..0x824B5E70)
	// 824B5E4C: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 824B5E50: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 824B5E54: 892B000A  lbz r9, 0xa(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(10 as u32) ) } as u64;
	// 824B5E58: A08B0006  lhz r4, 6(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 824B5E5C: 7D4951D6  mullw r10, r9, r10
	ctx.r[10].s32 = ((ctx.r[9].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 824B5E60: 5489283E  rotlwi r9, r4, 5
	ctx.r[9].u64 = ((ctx.r[4].u32).rotate_left(5)) as u64;
	// 824B5E64: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 824B5E68: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 824B5E6C: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	pc = 0x824B5E70; continue 'dispatch;
            }
            0x824B5E70 => {
    //   block [0x824B5E70..0x824B5E84)
	// 824B5E70: 39080030  addi r8, r8, 0x30
	ctx.r[8].s64 = ctx.r[8].s64 + 48;
	// 824B5E74: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824B5E78: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 824B5E7C: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 824B5E80: 4198FFB4  blt cr6, 0x824b5e34
	if ctx.cr[6].lt {
	pc = 0x824B5E34; continue 'dispatch;
	}
	pc = 0x824B5E84; continue 'dispatch;
            }
            0x824B5E84 => {
    //   block [0x824B5E84..0x824B5EA8)
	// 824B5E84: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B5E88: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B5E8C: 4BFEECE5  bl 0x824a4b70
	ctx.lr = 0x824B5E90;
	sub_824A4B70(ctx, base);
	// 824B5E90: A17C01F4  lhz r11, 0x1f4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(500 as u32) ) } as u64;
	// 824B5E94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B5E98: 419A0010  beq cr6, 0x824b5ea8
	if ctx.cr[6].eq {
	pc = 0x824B5EA8; continue 'dispatch;
	}
	// 824B5E9C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B5EA0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824B5EA4: 4BFECA05  bl 0x824a28a8
	ctx.lr = 0x824B5EA8;
	sub_824A28A8(ctx, base);
	pc = 0x824B5EA8; continue 'dispatch;
            }
            0x824B5EA8 => {
    //   block [0x824B5EA8..0x824B5EC0)
	// 824B5EA8: A17B01F4  lhz r11, 0x1f4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[27].u32.wrapping_add(500 as u32) ) } as u64;
	// 824B5EAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B5EB0: 419A0010  beq cr6, 0x824b5ec0
	if ctx.cr[6].eq {
	pc = 0x824B5EC0; continue 'dispatch;
	}
	// 824B5EB4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B5EB8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 824B5EBC: 4BFEC9ED  bl 0x824a28a8
	ctx.lr = 0x824B5EC0;
	sub_824A28A8(ctx, base);
	pc = 0x824B5EC0; continue 'dispatch;
            }
            0x824B5EC0 => {
    //   block [0x824B5EC0..0x824B5F14)
	// 824B5EC0: B3BF0012  sth r29, 0x12(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[29].u16 ) };
	// 824B5EC4: 397E0010  addi r11, r30, 0x10
	ctx.r[11].s64 = ctx.r[30].s64 + 16;
	// 824B5EC8: 80DE0000  lwz r6, 0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B5ECC: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 824B5ED0: 40980044  bge cr6, 0x824b5f14
	if !ctx.cr[6].lt {
	pc = 0x824B5F14; continue 'dispatch;
	}
	// 824B5ED4: 393F0014  addi r9, r31, 0x14
	ctx.r[9].s64 = ctx.r[31].s64 + 20;
	// 824B5ED8: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 824B5EDC: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	pc = 0x824B5F14; continue 'dispatch;
            }
            0x824B5F14 => {
    //   block [0x824B5F14..0x824B5F1C)
	// 824B5F14: 382104A0  addi r1, r1, 0x4a0
	ctx.r[1].s64 = ctx.r[1].s64 + 1184;
	// 824B5F18: 4807F1EC  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B5F20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B5F20 size=208
    let mut pc: u32 = 0x824B5F20;
    'dispatch: loop {
        match pc {
            0x824B5F20 => {
    //   block [0x824B5F20..0x824B5FC4)
	// 824B5F20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B5F24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824B5F28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824B5F2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824B5F30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B5F34: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824B5F38: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824B5F3C: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 824B5F40: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 824B5F44: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 824B5F48: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B5F4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B5F50: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B5F54: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B5F58: 4E800421  bctrl
	ctx.lr = 0x824B5F5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824B5F5C: 80DE003C  lwz r6, 0x3c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 824B5F60: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B5F64: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824B5F68: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 824B5F6C: 388B0B80  addi r4, r11, 0xb80
	ctx.r[4].s64 = ctx.r[11].s64 + 2944;
	// 824B5F70: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 824B5F74: A0E60002  lhz r7, 2(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(2 as u32) ) } as u64;
	// 824B5F78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B5F7C: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B5F80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B5F84: 4E800421  bctrl
	ctx.lr = 0x824B5F88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824B5F88: 817E0028  lwz r11, 0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 824B5F8C: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824B5F90: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824B5F94: 409A0030  bne cr6, 0x824b5fc4
	if !ctx.cr[6].eq {
	pc = 0x824B5FC4; continue 'dispatch;
	}
	// 824B5F98: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B5F9C: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 824B5FA0: 556800BE  clrlwi r8, r11, 2
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824B5FA4: 80FE0024  lwz r7, 0x24(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 824B5FA8: 80DE0020  lwz r6, 0x20(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 824B5FAC: 388A0B74  addi r4, r10, 0xb74
	ctx.r[4].s64 = ctx.r[10].s64 + 2932;
	// 824B5FB0: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 824B5FB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B5FB8: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B5FBC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B5FC0: 4E800421  bctrl
	ctx.lr = 0x824B5FC4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824B5FC4 => {
    //   block [0x824B5FC4..0x824B5FF0)
	// 824B5FC4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B5FC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B5FCC: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 824B5FD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B5FD4: 4E800421  bctrl
	ctx.lr = 0x824B5FD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 824B5FD8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824B5FDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824B5FE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824B5FE4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824B5FE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824B5FEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B5FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B5FF0 size=192
    let mut pc: u32 = 0x824B5FF0;
    'dispatch: loop {
        match pc {
            0x824B5FF0 => {
    //   block [0x824B5FF0..0x824B60B0)
	// 824B5FF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B5FF4: 4807F0B9  bl 0x825350ac
	ctx.lr = 0x824B5FF8;
	sub_82535080(ctx, base);
	// 824B5FF8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B5FFC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824B6000: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824B6004: 396B0BCC  addi r11, r11, 0xbcc
	ctx.r[11].s64 = ctx.r[11].s64 + 3020;
	// 824B6008: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 824B600C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 824B6010: 3B7F0044  addi r27, r31, 0x44
	ctx.r[27].s64 = ctx.r[31].s64 + 68;
	// 824B6014: 3B3F0014  addi r25, r31, 0x14
	ctx.r[25].s64 = ctx.r[31].s64 + 20;
	// 824B6018: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 824B601C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824B6020: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 824B6024: B15F0006  sth r10, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 824B6028: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 824B602C: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 824B6030: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 824B6034: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 824B6038: 4800FF91  bl 0x824c5fc8
	ctx.lr = 0x824B603C;
	sub_824C5FC8(ctx, base);
	// 824B603C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824B6040: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 824B6044: 4BFDC11D  bl 0x82492160
	ctx.lr = 0x824B6048;
	sub_82492160(ctx, base);
	// 824B6048: 933F0050  stw r25, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 824B604C: 93BF0058  stw r29, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 824B6050: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 824B6054: 939F005C  stw r28, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 824B6058: 935F000C  stw r26, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 824B605C: B3DF0012  sth r30, 0x12(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[30].u16 ) };
	// 824B6060: B3DF0010  sth r30, 0x10(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u16 ) };
	// 824B6064: B3DF0018  sth r30, 0x18(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u16 ) };
	// 824B6068: B3DF0048  sth r30, 0x48(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[30].u16 ) };
	// 824B606C: A17D002A  lhz r11, 0x2a(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(42 as u32) ) } as u64;
	// 824B6070: A13C002A  lhz r9, 0x2a(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(42 as u32) ) } as u64;
	// 824B6074: 5568103E  rotlwi r8, r11, 2
	ctx.r[8].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 824B6078: 815A0074  lwz r10, 0x74(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(116 as u32) ) } as u64;
	// 824B607C: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 824B6080: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824B6084: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 824B6088: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824B608C: 896B1BB0  lbz r11, 0x1bb0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(7088 as u32) ) } as u64;
	// 824B6090: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824B6094: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824B6098: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 824B609C: A08B1C58  lhz r4, 0x1c58(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(7256 as u32) ) } as u64;
	// 824B60A0: 4BFDC0F9  bl 0x82492198
	ctx.lr = 0x824B60A4;
	sub_82492198(ctx, base);
	// 824B60A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B60A8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 824B60AC: 4807F050  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B60B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B60B0 size=128
    let mut pc: u32 = 0x824B60B0;
    'dispatch: loop {
        match pc {
            0x824B60B0 => {
    //   block [0x824B60B0..0x824B60F0)
	// 824B60B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B60B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824B60B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824B60BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B60C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824B60C4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824B60C8: 396B0BCC  addi r11, r11, 0xbcc
	ctx.r[11].s64 = ctx.r[11].s64 + 3020;
	// 824B60CC: 815F003C  lwz r10, 0x3c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 824B60D0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824B60D4: A16A0004  lhz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B60D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B60DC: 419A0014  beq cr6, 0x824b60f0
	if ctx.cr[6].eq {
	pc = 0x824B60F0; continue 'dispatch;
	}
	// 824B60E0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 824B60E4: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B60E8: 389F0044  addi r4, r31, 0x44
	ctx.r[4].s64 = ctx.r[31].s64 + 68;
	// 824B60EC: 4BFE7C15  bl 0x8249dd00
	ctx.lr = 0x824B60F0;
	sub_8249DD00(ctx, base);
	pc = 0x824B60F0; continue 'dispatch;
            }
            0x824B60F0 => {
    //   block [0x824B60F0..0x824B6130)
	// 824B60F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824B60F4: 387F0044  addi r3, r31, 0x44
	ctx.r[3].s64 = ctx.r[31].s64 + 68;
	// 824B60F8: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 824B60FC: 917F005C  stw r11, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 824B6100: 917F0050  stw r11, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 824B6104: 4BFDC1ED  bl 0x824922f0
	ctx.lr = 0x824B6108;
	sub_824922F0(ctx, base);
	// 824B6108: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 824B610C: 48000355  bl 0x824b6460
	ctx.lr = 0x824B6110;
	sub_824B6460(ctx, base);
	// 824B6110: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824B6114: 396B6DD0  addi r11, r11, 0x6dd0
	ctx.r[11].s64 = ctx.r[11].s64 + 28112;
	// 824B6118: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824B611C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824B6120: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824B6124: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824B6128: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824B612C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B6130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B6130 size=104
    let mut pc: u32 = 0x824B6130;
    'dispatch: loop {
        match pc {
            0x824B6130 => {
    //   block [0x824B6130..0x824B6198)
	// 824B6130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B6134: 4807EF89  bl 0x825350bc
	ctx.lr = 0x824B6138;
	sub_82535080(ctx, base);
	// 824B6138: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B613C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 824B6140: 80ED0000  lwz r7, 0(r13)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B6144: 7CAA2B78  mr r10, r5
	ctx.r[10].u64 = ctx.r[5].u64;
	// 824B6148: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824B614C: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 824B6150: 38A00022  li r5, 0x22
	ctx.r[5].s64 = 34;
	// 824B6154: 892B0010  lbz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B6158: 38800080  li r4, 0x80
	ctx.r[4].s64 = 128;
	// 824B615C: 886A0010  lbz r3, 0x10(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B6160: 7D280774  extsb r8, r9
	ctx.r[8].s64 = ctx.r[9].s8 as i64;
	// 824B6164: 7C690774  extsb r9, r3
	ctx.r[9].s64 = ctx.r[3].s8 as i64;
	// 824B6168: 7C66382E  lwzx r3, r6, r7
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 824B616C: 7FC85A14  add r30, r8, r11
	ctx.r[30].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 824B6170: 7FA95214  add r29, r9, r10
	ctx.r[29].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 824B6174: 4BFADEC5  bl 0x82464038
	ctx.lr = 0x824B6178;
	sub_82464038(ctx, base);
	// 824B6178: 39600080  li r11, 0x80
	ctx.r[11].s64 = 128;
	// 824B617C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 824B6180: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 824B6184: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 824B6188: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B618C: 4BFFFE65  bl 0x824b5ff0
	ctx.lr = 0x824B6190;
	sub_824B5FF0(ctx, base);
	// 824B6190: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824B6194: 4807EF78  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B6198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x824B6198 size=372
    let mut pc: u32 = 0x824B6198;
    'dispatch: loop {
        match pc {
            0x824B6198 => {
    //   block [0x824B6198..0x824B6228)
	// 824B6198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B619C: 4807EF11  bl 0x825350ac
	ctx.lr = 0x824B61A0;
	sub_82535080(ctx, base);
	// 824B61A0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B61A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824B61A8: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 824B61AC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 824B61B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 824B61B4: 387D000C  addi r3, r29, 0xc
	ctx.r[3].s64 = ctx.r[29].s64 + 12;
	// 824B61B8: 837F0058  lwz r27, 0x58(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 824B61BC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 824B61C0: 839F005C  lwz r28, 0x5c(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 824B61C4: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 824B61C8: C01B0084  lfs f0, 0x84(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B61CC: C1BC0084  lfs f13, 0x84(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(132 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824B61D0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 824B61D4: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 824B61D8: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 824B61DC: 4BFCD6D5  bl 0x824838b0
	ctx.lr = 0x824B61E0;
	sub_824838B0(ctx, base);
	// 824B61E0: C1BB0088  lfs f13, 0x88(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824B61E4: C01C0088  lfs f0, 0x88(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B61E8: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 824B61EC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 824B61F0: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 824B61F4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 824B61F8: 995D000E  stb r10, 0xe(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(14 as u32), ctx.r[10].u8 ) };
	// 824B61FC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 824B6200: EDA0002C  fsqrts f13, f0
	ctx.f[13].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 824B6204: C00A2838  lfs f0, 0x2838(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824B6208: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 824B620C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 824B6210: 7C004FAE  stfiwx f0, 0, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32, tmp.u32) };
	// 824B6214: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 824B6218: 995D000D  stb r10, 0xd(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(13 as u32), ctx.r[10].u8 ) };
	// 824B621C: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B6220: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824B6224: 419A0014  beq cr6, 0x824b6238
	if ctx.cr[6].eq {
	pc = 0x824B6238; continue 'dispatch;
	}
	pc = 0x824B6228; continue 'dispatch;
            }
            0x824B6228 => {
    //   block [0x824B6228..0x824B6238)
	// 824B6228: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 824B622C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B6230: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824B6234: 409AFFF4  bne cr6, 0x824b6228
	if !ctx.cr[6].eq {
	pc = 0x824B6228; continue 'dispatch;
	}
	pc = 0x824B6238; continue 'dispatch;
            }
            0x824B6238 => {
    //   block [0x824B6238..0x824B626C)
	// 824B6238: 815F003C  lwz r10, 0x3c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 824B623C: 892B0010  lbz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 824B6240: 7D290774  extsb r9, r9
	ctx.r[9].s64 = ctx.r[9].s8 as i64;
	// 824B6244: 88EA0008  lbz r7, 8(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B6248: 7C695A14  add r3, r9, r11
	ctx.r[3].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 824B624C: 88CA0009  lbz r6, 9(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(9 as u32) ) } as u64;
	// 824B6250: 7D663A15  add. r11, r6, r7
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B6254: 418200B0  beq 0x824b6304
	if ctx.cr[0].eq {
	pc = 0x824B6304; continue 'dispatch;
	}
	// 824B6258: 7F03D840  cmplw cr6, r3, r27
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[27].u32, &mut ctx.xer);
	// 824B625C: 409A0010  bne cr6, 0x824b626c
	if !ctx.cr[6].eq {
	pc = 0x824B626C; continue 'dispatch;
	}
	// 824B6260: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 824B6264: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 824B6268: 4800000C  b 0x824b6274
	pc = 0x824B6274; continue 'dispatch;
            }
            0x824B626C => {
    //   block [0x824B626C..0x824B6274)
	// 824B626C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 824B6270: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x824B6274; continue 'dispatch;
            }
            0x824B6274 => {
    //   block [0x824B6274..0x824B6280)
	// 824B6274: 7F07C800  cmpw cr6, r7, r25
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[25].s32, &mut ctx.xer);
	// 824B6278: 41980008  blt cr6, 0x824b6280
	if ctx.cr[6].lt {
	pc = 0x824B6280; continue 'dispatch;
	}
	// 824B627C: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x824B6280; continue 'dispatch;
            }
            0x824B6280 => {
    //   block [0x824B6280..0x824B6290)
	// 824B6280: 7D47C850  subf r10, r7, r25
	ctx.r[10].s64 = ctx.r[25].s64 - ctx.r[7].s64;
	// 824B6284: 7F065000  cmpw cr6, r6, r10
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[10].s32, &mut ctx.xer);
	// 824B6288: 41980008  blt cr6, 0x824b6290
	if ctx.cr[6].lt {
	pc = 0x824B6290; continue 'dispatch;
	}
	// 824B628C: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	pc = 0x824B6290; continue 'dispatch;
            }
            0x824B6290 => {
    //   block [0x824B6290..0x824B62AC)
	// 824B6290: 39470005  addi r10, r7, 5
	ctx.r[10].s64 = ctx.r[7].s64 + 5;
	// 824B6294: 393D0014  addi r9, r29, 0x14
	ctx.r[9].s64 = ctx.r[29].s64 + 20;
	// 824B6298: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 824B629C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 824B62A0: 7D08EA14  add r8, r8, r29
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[29].u64;
	// 824B62A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B62A8: 419A0028  beq cr6, 0x824b62d0
	if ctx.cr[6].eq {
	pc = 0x824B62D0; continue 'dispatch;
	}
	pc = 0x824B62AC; continue 'dispatch;
            }
            0x824B62AC => {
    //   block [0x824B62AC..0x824B62D0)
	// 824B62AC: 7F0A3800  cmpw cr6, r10, r7
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[7].s32, &mut ctx.xer);
	// 824B62B0: 40980020  bge cr6, 0x824b62d0
	if !ctx.cr[6].lt {
	pc = 0x824B62D0; continue 'dispatch;
	}
	// 824B62B4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B62B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824B62BC: 90A90000  stw r5, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 824B62C0: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 824B62C4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B62C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B62CC: 409AFFE0  bne cr6, 0x824b62ac
	if !ctx.cr[6].eq {
	pc = 0x824B62AC; continue 'dispatch;
	}
	pc = 0x824B62D0; continue 'dispatch;
            }
            0x824B62D0 => {
    //   block [0x824B62D0..0x824B62E0)
	// 824B62D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824B62D4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 824B62D8: 419A002C  beq cr6, 0x824b6304
	if ctx.cr[6].eq {
	pc = 0x824B6304; continue 'dispatch;
	}
	// 824B62DC: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	pc = 0x824B62E0; continue 'dispatch;
            }
            0x824B62E0 => {
    //   block [0x824B62E0..0x824B6304)
	// 824B62E0: 7F0B3000  cmpw cr6, r11, r6
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[6].s32, &mut ctx.xer);
	// 824B62E4: 40980020  bge cr6, 0x824b6304
	if !ctx.cr[6].lt {
	pc = 0x824B6304; continue 'dispatch;
	}
	// 824B62E8: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B62EC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824B62F0: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824B62F4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 824B62F8: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B62FC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 824B6300: 409AFFE0  bne cr6, 0x824b62e0
	if !ctx.cr[6].eq {
	pc = 0x824B62E0; continue 'dispatch;
	}
	pc = 0x824B6304; continue 'dispatch;
            }
            0x824B6304 => {
    //   block [0x824B6304..0x824B630C)
	// 824B6304: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 824B6308: 4807EDF4  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B6310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B6310 size=192
    let mut pc: u32 = 0x824B6310;
    'dispatch: loop {
        match pc {
            0x824B6310 => {
    //   block [0x824B6310..0x824B63C4)
	// 824B6310: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 824B6314: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 824B6318: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B631C: 54892834  slwi r9, r4, 5
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(5);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 824B6320: 88C3000A  lbz r6, 0xa(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(10 as u32) ) } as u64;
	// 824B6324: 7C870734  extsh r7, r4
	ctx.r[7].s64 = ctx.r[4].s16 as i64;
	// 824B6328: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 824B632C: A1030006  lhz r8, 6(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 824B6330: 7D691A14  add r11, r9, r3
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[3].u64;
	// 824B6334: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	// 824B6338: 5508283E  rotlwi r8, r8, 5
	ctx.r[8].u64 = ((ctx.r[8].u32).rotate_left(5)) as u64;
	// 824B633C: 7D2939D6  mullw r9, r9, r7
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * ctx.r[7].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 824B6340: B1430004  sth r10, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u16 ) };
	// 824B6344: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 824B6348: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 824B634C: 7D291A14  add r9, r9, r3
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[3].u64;
	// 824B6350: 7F045000  cmpw cr6, r4, r10
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[10].s32, &mut ctx.xer);
	// 824B6354: 39290030  addi r9, r9, 0x30
	ctx.r[9].s64 = ctx.r[9].s64 + 48;
	// 824B6358: 4098006C  bge cr6, 0x824b63c4
	if !ctx.cr[6].lt {
	pc = 0x824B63C4; continue 'dispatch;
	}
	// 824B635C: 7C845050  subf r4, r4, r10
	ctx.r[4].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 824B6360: 7CC51670  srawi r5, r6, 2
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[6].s32 >> 2) as i64;
	// 824B6364: 3BE00030  li r31, 0x30
	ctx.r[31].s64 = 48;
	// 824B6368: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 824B636C: 38EB0020  addi r7, r11, 0x20
	ctx.r[7].s64 = ctx.r[11].s64 + 32;
	// 824B6370: 7D093214  add r8, r9, r6
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[6].u64;
	// 824B6374: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 824B6378: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	pc = 0x824B63C4; continue 'dispatch;
            }
            0x824B63C4 => {
    //   block [0x824B63C4..0x824B63D0)
	// 824B63C4: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824B63C8: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 824B63CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B63D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B63D0 size=140
    let mut pc: u32 = 0x824B63D0;
    'dispatch: loop {
        match pc {
            0x824B63D0 => {
    //   block [0x824B63D0..0x824B63F4)
	// 824B63D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B63D4: 4807ECE5  bl 0x825350b8
	ctx.lr = 0x824B63D8;
	sub_82535080(ctx, base);
	// 824B63D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B63DC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 824B63E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824B63E4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 824B63E8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B63EC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824B63F0: 40990064  ble cr6, 0x824b6454
	if !ctx.cr[6].gt {
	pc = 0x824B6454; continue 'dispatch;
	}
	pc = 0x824B63F4; continue 'dispatch;
            }
            0x824B63F4 => {
    //   block [0x824B63F4..0x824B6428)
	// 824B63F4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B63F8: 7D6BF0AE  lbzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824B63FC: 2B0B00FF  cmplwi cr6, r11, 0xff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 255 as u32, &mut ctx.xer);
	// 824B6400: 419A0044  beq cr6, 0x824b6444
	if ctx.cr[6].eq {
	pc = 0x824B6444; continue 'dispatch;
	}
	// 824B6404: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 824B6408: 57DD043E  clrlwi r29, r30, 0x10
	ctx.r[29].u64 = ctx.r[30].u32 as u64 & 0x0000FFFFu64;
	// 824B640C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B6410: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824B6414: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824B6418: 409A0010  bne cr6, 0x824b6428
	if !ctx.cr[6].eq {
	pc = 0x824B6428; continue 'dispatch;
	}
	// 824B641C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 824B6420: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B6424: 4BFB7F2D  bl 0x8246e350
	ctx.lr = 0x824B6428;
	sub_8246E350(ctx, base);
	pc = 0x824B6428; continue 'dispatch;
            }
            0x824B6428 => {
    //   block [0x824B6428..0x824B6444)
	// 824B6428: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B642C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B6430: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824B6434: 7FAB532E  sthx r29, r11, r10
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[29].u16) };
	// 824B6438: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B643C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824B6440: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x824B6444; continue 'dispatch;
            }
            0x824B6444 => {
    //   block [0x824B6444..0x824B6454)
	// 824B6444: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B6448: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 824B644C: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824B6450: 4198FFA4  blt cr6, 0x824b63f4
	if ctx.cr[6].lt {
	pc = 0x824B63F4; continue 'dispatch;
	}
	pc = 0x824B6454; continue 'dispatch;
            }
            0x824B6454 => {
    //   block [0x824B6454..0x824B645C)
	// 824B6454: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 824B6458: 4807ECB0  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B6460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B6460 size=144
    let mut pc: u32 = 0x824B6460;
    'dispatch: loop {
        match pc {
            0x824B6460 => {
    //   block [0x824B6460..0x824B64A4)
	// 824B6460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B6464: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824B6468: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824B646C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B6470: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824B6474: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824B6478: 396B0B90  addi r11, r11, 0xb90
	ctx.r[11].s64 = ctx.r[11].s64 + 2960;
	// 824B647C: 809F0028  lwz r4, 0x28(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 824B6480: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 824B6484: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824B6488: 419A001C  beq cr6, 0x824b64a4
	if ctx.cr[6].eq {
	pc = 0x824B64A4; continue 'dispatch;
	}
	// 824B648C: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B6490: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 824B6494: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 824B6498: A0A40002  lhz r5, 2(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(2 as u32) ) } as u64;
	// 824B649C: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824B64A0: 4BFADC19  bl 0x824640b8
	ctx.lr = 0x824B64A4;
	sub_824640B8(ctx, base);
	pc = 0x824B64A4; continue 'dispatch;
            }
            0x824B64A4 => {
    //   block [0x824B64A4..0x824B64D0)
	// 824B64A4: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 824B64A8: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824B64AC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824B64B0: 409A0020  bne cr6, 0x824b64d0
	if !ctx.cr[6].eq {
	pc = 0x824B64D0; continue 'dispatch;
	}
	// 824B64B4: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B64B8: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824B64BC: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824B64C0: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 824B64C4: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 824B64C8: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824B64CC: 4BFADBED  bl 0x824640b8
	ctx.lr = 0x824B64D0;
	sub_824640B8(ctx, base);
	pc = 0x824B64D0; continue 'dispatch;
            }
            0x824B64D0 => {
    //   block [0x824B64D0..0x824B64F0)
	// 824B64D0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824B64D4: 396B6DD0  addi r11, r11, 0x6dd0
	ctx.r[11].s64 = ctx.r[11].s64 + 28112;
	// 824B64D8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824B64DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 824B64E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824B64E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824B64E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824B64EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B64F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824B64F0 size=28
    let mut pc: u32 = 0x824B64F0;
    'dispatch: loop {
        match pc {
            0x824B64F0 => {
    //   block [0x824B64F0..0x824B650C)
	// 824B64F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 824B64F4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 824B64F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B64FC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824B6500: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B6504: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824B6508: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824B6510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824B6510 size=100
    let mut pc: u32 = 0x824B6510;
    'dispatch: loop {
        match pc {
            0x824B6510 => {
    //   block [0x824B6510..0x824B6558)
	// 824B6510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824B6514: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824B6518: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824B651C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824B6520: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824B6524: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824B6528: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 824B652C: 4BFFFF35  bl 0x824b6460
	ctx.lr = 0x824B6530;
	sub_824B6460(ctx, base);
	// 824B6530: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 824B6534: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824B6538: 419A0020  beq cr6, 0x824b6558
	if ctx.cr[6].eq {
	pc = 0x824B6558; continue 'dispatch;
	}
	// 824B653C: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824B6540: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 824B6544: 38C0002C  li r6, 0x2c
	ctx.r[6].s64 = 44;
	// 824B6548: A0BF0004  lhz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824B654C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 824B6550: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 824B6554: 4BFADB65  bl 0x824640b8
	ctx.lr = 0x824B6558;
	sub_824640B8(ctx, base);
	pc = 0x824B6558; continue 'dispatch;
            }
            0x824B6558 => {
    //   block [0x824B6558..0x824B6574)
	// 824B6558: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824B655C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824B6560: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824B6564: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824B6568: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824B656C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824B6570: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


